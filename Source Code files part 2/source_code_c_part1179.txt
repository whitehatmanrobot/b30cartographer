FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0),
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0), 0))
        return(1);

    ObjectUuid.Data1 = 0x12345678;
    ObjectUuid.Data2 = 0x9012;
    ObjectUuid.Data3 = 0xB456;
    ObjectUuid.Data4[0] = 0x80;
    ObjectUuid.Data4[1] = 0x01;
    ObjectUuid.Data4[2] = 0x08;
    ObjectUuid.Data4[3] = 0x00;
    ObjectUuid.Data4[4] = 0x2B;
    ObjectUuid.Data4[5] = 0x03;
    ObjectUuid.Data4[6] = 0x3D;
    ObjectUuid.Data4[7] = 0x7A;

    StringBinding1 = GetStringBinding(FREDRICK, 0, 0) ;
    StringBinding2 = GetStringBinding(FREDRICK,
                            "12345678-9012-B456-8001-08002B033D7A",0) ;

    if (FitzgeraldToStringBinding(StringBinding1, StringBinding2, &ObjectUuid))
        return(1);

#if 0
    if (FitzgeraldToStringBinding(GetStringBinding(FREDRICK,0,0),
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0), &ObjectUuid))
        return(1);
#endif

    if (FitzgeraldInqSetObjectUuid(1,1,&ObjectUuid,
            GetStringBinding(FREDRICK,0,0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(1,0,&ObjectUuid,
            GetStringBinding(FREDRICK,0,0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(0,0,&ObjectUuid,
            GetStringBinding(FREDRICK,0,0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(2,1,&ObjectUuid,
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0)))
        return(1);

    if (FitzgeraldInqSetObjectUuid(2,0,&ObjectUuid,
            GetStringBinding(FREDRICK,
                    "12345678-9012-B456-8001-08002B033D7A",0)))
        return(1);

    return(0);
}


int
FitzgeraldComTimeout (
    IN unsigned int SetBeforeRpc,
    IN unsigned int SetBeforeRpcTimeout,
    IN unsigned int InqBeforeRpc,
    IN unsigned int InqBeforeRpcTimeout,
    IN unsigned int SetAfterRpc,
    IN unsigned int SetAfterRpcTimeout,
    IN unsigned int InqAfterRpc,
    IN unsigned int InqAfterRpcTimeout
    )
/*++

Routine Description:

    Fitzgerald uses this routine to test the communications timeout
    management routines, RpcMgmtInqComTimeout and RpcMgmtSetComTimeout.

Arguments:

    SetBeforeRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be set before making a remote
        procedure call.

    SetBeforeRpcTimeout - Supplies the timeout value to be set before
        making a remote procedure call.

    InqBeforeRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be inquired before making a
        remote procedure call.

    InqBeforeRpcTimeout - Supplies the expected timeout value to be
        inquired before making a remote procedure call.

    SetAfterRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be set after making a remote
        procedure call.

    SetAfterRpcTimeout - Supplies the timeout value to be set after
        making a remote procedure call.

    InqAfterRpc - Supplies a flag which, if it is non-zero, indicates that
        the communications timeout should be inquired after making a
        remote procedure call.

    InqAfterRpcTimeout - Supplies the expected timeout value to be
        inquired after making a remote procedure call.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned int Timeout;

    Status = GetBinding(FREDRICK, &BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }

    if (SetBeforeRpc != 0)
        {
        Status = RpcMgmtSetComTimeout(BindingHandle,SetBeforeRpcTimeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtSetComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtSetComTimeout\n");
            return(1);
            }
        }

    if (InqBeforeRpc != 0)
        {
        Status = RpcMgmtInqComTimeout(BindingHandle,&Timeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtInqComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtInqComTimeout\n");
            return(1);
            }

        if (Timeout != InqBeforeRpcTimeout)
            {
            PrintToConsole("Fitzgerald : FAIL - Timeout != ");
            PrintToConsole("InqBeforeRpcTimeout\n");
            return(1);
            }
        }

    Helga(BindingHandle);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    if (SetAfterRpc != 0)
        {
        Status = RpcMgmtSetComTimeout(BindingHandle,SetAfterRpcTimeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtSetComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtSetComTimeout\n");
            return(1);
            }
        }

    if (InqAfterRpc != 0)
        {
        Status = RpcMgmtInqComTimeout(BindingHandle,&Timeout);
        if (Status)
            {
            ApiError("Fitzgerald","RpcMgmtInqComTimeout",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in");
            PrintToConsole(" RpcMgmtInqComTimeout\n");
            return(1);
            }

        if (Timeout != InqAfterRpcTimeout)
            {
            PrintToConsole("Fitzgerald : FAIL - Timeout != ");
            PrintToConsole("InqAfterRpcTimeout\n");
            return(1);
            }
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldTestFault (
    void
    )
/*++

Routine Description:

    This routine will test that faults get propogated correctly from the
    server back to the client.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE ExceptionBinding;

    Status = GetBinding(FREDRICK, &ExceptionBinding);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }

    Helga(ExceptionBinding);

    if (IsabelleRaiseException(ExceptionBinding, (unsigned char) ulSecurityPackage) != (unsigned char) ulSecurityPackage)
        {
        PrintToConsole("Fitzgerald : FAIL - Exception Not Raised\n");
        return(1);
        }

    Helga(ExceptionBinding);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&ExceptionBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (ExceptionBinding)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldContextHandle (
    )
{
    void PAPI * ContextHandle = 0;
    RPC_BINDING_HANDLE BindingHandle;
    unsigned long ContextUuid[5];


    Status = GetBinding(FREDRICK, &BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }


    Helga(BindingHandle);

    ContextUuid[0] = 0;
    ContextUuid[1] = 1;
    ContextUuid[2] = 2;
    ContextUuid[3] = 3;
    ContextUuid[4] = 4;

    NDRCContextUnmarshall(&ContextHandle, BindingHandle, ContextUuid,
            0x00L | 0x10L | 0x0000L);

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    HelgaUsingContextHandle(ContextHandle);
    RpcSsDestroyClientContext(&ContextHandle);
    if ( ContextHandle != 0 )
        {
        PrintToConsole("Fitzgerald : FAIL - ContextHandle != 0\n");
        return(1);
        }
    return(0);
}


void
Fitzgerald (
    )
/*++

Routine Description:

    We verify all client side APIs in this routine.  The idea is to
    emphasize complete coverage, rather than indepth coverage.  Actually,
    when I say all client side APIs, I really mean all client side APIs
    except for security and name service.  The following list is the
    APIs which will be tested by this routine.

    RpcBindingCopy
    RpcBindingFree
    RpcBindingFromStringBinding
    RpcBindingInqObject
    RpcBindingSetObject
    RpcBindingToStringBinding
    RpcStringBindingCompose
    RpcStringBindingParse
    RpcIfInqId
    RpcNetworkIsProtseqValid
    RpcMgmtInqComTimeout
    RpcMgmtSetComTimeout
    RpcStringFree

    UuidToString
    UuidFromString

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    RPC_IF_ID RpcIfId;
    UUID Uuid;
    unsigned char PAPI * String;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    Synchro(FREDRICK) ;

    PrintToConsole("Fitzgerald : Verify All Client APIs\n");

    if ( FitzgeraldContextHandle() != 0 )
        {
        return;
        }

    // Test that the routines to convert UUIDs to and from strings work
    // correctly.

    GenerateUuidValue(3768,&Uuid);
    Status = UuidToStringA(&Uuid, &String);
    if (Status)
        {
        ApiError("Fitzgerald", "UuidToString", Status);
        PrintToConsole("Fitzgerald : FAIL - UuidToString\n");
        return;
        }

    Status = UuidFromStringA(String, &Uuid);
    if (Status)
        {
        ApiError("Fitzgerald", "UuidFromString", Status);
        PrintToConsole("Fitzgerald : FAIL - UuidFromString\n");
        return;
        }

    Status = RpcStringFreeA(&String);
    if (Status)
        {
        ApiError("Fitzgerald", "RpcStringFree", Status);
        PrintToConsole("Fitzgerald : FAIL - RpcStringFree\n");
        return;
        }

    if ( CheckUuidValue(3768,&Uuid) != 0 )
        {
        OtherError("Fitzgerald", "CheckUuidValue() != 0");
        PrintToConsole("Fitzgerald : FAIL - CheckUuidValue() != 0\n");
        return;
        }

    Status = UuidFromString(0, &Uuid);
    if (Status)
        {
        ApiError("Fitzgerald", "UuidFromString", Status);
        PrintToConsole("Fitzgerald : FAIL - UuidFromString\n");
        return;
        }

    if (   ( Uuid.Data1 != 0 )
        || ( Uuid.Data2 != 0 )
        || ( Uuid.Data3 != 0 )
        || ( Uuid.Data4[0] != 0 )
        || ( Uuid.Data4[1] != 0 )
        || ( Uuid.Data4[2] != 0 )
        || ( Uuid.Data4[3] != 0 )
        || ( Uuid.Data4[4] != 0 )
        || ( Uuid.Data4[5] != 0 )
        || ( Uuid.Data4[6] != 0 )
        || ( Uuid.Data4[7] != 0 ) )
        {
        OtherError("Fitzgerald", "Uuid != NIL UUID");
        PrintToConsole("Fitzgerald : FAIL - Uuid != NIL UUID\n");
        return;
        }

    // Test that a null protocol sequence causes RPC_S_INVALID_RPC_PROTSEQ
    // to be returned rather than RPC_S_PROTSEQ_NOT_SUPPORTED.

    Status = RpcBindingFromStringBindingA(
            (unsigned char PAPI *) ":[\\\\pipe\\\\endpoint]",
            &IsabelleBinding);
    if (Status != RPC_S_INVALID_RPC_PROTSEQ)
        {
        ApiError("Fitzgerald","RpcBindingFromStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - RpcBindingFromStringBinding");
        PrintToConsole(" did not fail with RPC_S_INVALID_RPC_PROTSEQ\n");
        return;
        }

    Status = GetBinding(FREDRICK, &IsabelleBinding);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return;
        }

    Status = RpcNsBindingInqEntryNameA(IsabelleBinding, RPC_C_NS_SYNTAX_DCE,
            &String);
    if ( Status != RPC_S_NO_ENTRY_NAME )
        {
        ApiError("Fitzgerald","RpcNsBindingInqEntryName",Status);
        PrintToConsole("Fitzgerald : FAIL - RpcNsBindingInqEntryName");
        PrintToConsole(" Did Not Fail");
        return;
        }

    // This routine will test RpcStringBindingCompose,
    // RpcStringBindingParse, RpcStringFree for us.

    if (FitzgeraldComposeAndParse())
        return;

    // We test RpcBindingCopy here.

    if (FitzgeraldBindingCopy())
        return;

    // This particular routine gets to test RpcBindingToStringBinding,
    // RpcBindingInqObject, and RpcBindingSetObject.

    if (FitzgeraldStringBindingAndObject())
        return;

    if (FitzgeraldComTimeout(0,0,1,RPC_C_BINDING_DEFAULT_TIMEOUT,
            0,0,1,RPC_C_BINDING_DEFAULT_TIMEOUT))
        return;

    if (FitzgeraldComTimeout(1,RPC_C_BINDING_MAX_TIMEOUT,
            1,RPC_C_BINDING_MAX_TIMEOUT,0,0,1,RPC_C_BINDING_MAX_TIMEOUT))
        return;

    if (FitzgeraldComTimeout(0,0,0,0,1,RPC_C_BINDING_MAX_TIMEOUT,
            1,RPC_C_BINDING_MAX_TIMEOUT))
        return;

    // We need to test faults.  This is done by this routine.

    if (FitzgeraldTestFault())
        return;

    Status = RpcBindingSetObject(IsabelleBinding, 0);
    if (Status)
        {
        ApiError("Fitzgerald", "RpcBindingSetObject", Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Set Object\n");
        return;
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    Status = RpcIfInqId((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
        &RpcIfId);
    if (Status)
        {
        ApiError("Fitzgerald","RpcIfInqId",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcIfInqId\n");
        return;
        }

    if (   (RpcIfId.VersMajor != 1)
        || (RpcIfId.VersMinor != 1)
        || (RpcIfId.Uuid.Data1 != 9)
        || (RpcIfId.Uuid.Data2 != 8)
        || (RpcIfId.Uuid.Data3 != 8)
        || (RpcIfId.Uuid.Data4[0] != 7)
        || (RpcIfId.Uuid.Data4[1] != 7)
        || (RpcIfId.Uuid.Data4[2] != 7)
        || (RpcIfId.Uuid.Data4[3] != 7)
        || (RpcIfId.Uuid.Data4[4] != 7)
        || (RpcIfId.Uuid.Data4[5] != 7)
        || (RpcIfId.Uuid.Data4[6] != 7)
        || (RpcIfId.Uuid.Data4[7] != 7))
        {
        PrintToConsole("Fitzgerald : FAIL - Wrong RpcIfId\n");
        return;
        }
    Status = RpcNetworkIsProtseqValidA((unsigned char *) "ncacn_np");
    if (Status)
        {
        ApiError("Fitzgerald","RpcNetworkIsProtseqValid",Status);
        PrintToConsole("Fitzgerald : FAIL - RpcNetworkIsProtseqValid");
        PrintToConsole(" Failed\n");
        return;
        }

    Status = RpcNetworkIsProtseqValidA((unsigned char *) "nope_np");
    if (Status != RPC_S_INVALID_RPC_PROTSEQ)
        {
        PrintToConsole("Fitzgerald : FAIL - RpcNetworkIsProtseqValid");
        PrintToConsole(" != RPC_S_INVALID_RPC_PROTSEQ\n");
        return;
        }

    Status = RpcNetworkIsProtseqValidA((unsigned char *) "ncacn_fail");
    if (Status != RPC_S_PROTSEQ_NOT_SUPPORTED)
        {
        PrintToConsole("Fitzgerald : FAIL - RpcNetworkIsProtseqValid");
        PrintToConsole(" != RPC_S_PROTSEQ_NOT_SUPPORTED\n");
        return;
        }

    PrintToConsole("Fitzgerald : PASS\n");
}


void
Charles (
    )
/*++

Routine Description:

    This routine works with Christopher in usvr.exe to test all
    server APIs (all except security and name service APIs).

--*/
{
    RPC_BINDING_HANDLE ChristopherBinding;
    RPC_BINDING_HANDLE ChristopherHelgaBinding;
    RPC_BINDING_HANDLE ChristopherIsabelleBinding;
    RPC_BINDING_HANDLE ChristopherHelgaNoEndpoint;
    UUID ObjectUuid;

   if ( NumberOfTestsRun++ )
        {
        PauseExecution(30000);
        }

    Synchro(CHRISTOPHER) ;


    PrintToConsole("Charles : Verify All Server APIs\n");

    Status = GetBinding(CHRISTOPHER, &ChristopherBinding);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(Christopher)\n");
        return;
        }


    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    Status = GetBinding(CHRISTOPHERHELGA, &ChristopherHelgaBinding);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(ChristopherHelga)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherHelgaBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    Status = GetBinding(CHRISTOPHERISABELLE, &ChristopherIsabelleBinding);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(ChristopherIsabelle)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherIsabelleBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    Status = GetBinding(NOENDPOINT, &ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles","GetBinding",Status);
        PrintToConsole("Charles : FAIL - Unable to Bind ");
        PrintToConsole("(ChristopherHelgaNoEndpoint)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    Status = RpcBindingSetObject(ChristopherHelgaNoEndpoint, &ObjectUuid);
    if (Status)
        {
        ApiError("Charles", "RpcBindingSetObject", Status);
        PrintToConsole("Charles : FAIL - Unable to Set Object\n");
        return;
        }

    SylviaBinding = ChristopherBinding;
    if (SylviaCall(ChristopherBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Charles : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    SylviaBinding = ChristopherHelgaBinding;
    if (SylviaCall(ChristopherHelgaBinding,10,5,0)
            != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Charles : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    SylviaBinding = ChristopherIsabelleBinding;
    if (SylviaCall(ChristopherIsabelleBinding,10,5,0)
            != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Charles : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    IsabelleToStringBinding(ChristopherBinding);
    IsabelleToStringBinding(ChristopherIsabelleBinding);
    IsabelleToStringBinding(ChristopherHelgaBinding);

    TestHelgaInterface(ChristopherHelgaNoEndpoint, HelgaMaxSize);

    Status = RpcBindingReset(ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles", "RpcBindingReset", Status);
        PrintToConsole("Charles : FAIL - Unable to Reset");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    Helga(ChristopherHelgaNoEndpoint);

    Status = RpcBindingReset(ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles", "RpcBindingReset", Status);
        PrintToConsole("Charles : FAIL - Unable to Reset");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    Helga(ChristopherHelgaNoEndpoint);

    Status = RpcBindingReset(ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles", "RpcBindingReset", Status);
        PrintToConsole("Charles : FAIL - Unable to Reset");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    IsabelleShutdown(ChristopherBinding);

    // We need an extra delay in here because Christopher performs some
    // other tests after RpcServerListen returns.

    PauseExecution(LONG_TESTDELAY);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Charles : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Charles : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Charles : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&ChristopherHelgaBinding);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherHelgaBinding)\n");
        return;
        }

    Status = RpcBindingFree(&ChristopherBinding);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherBinding)\n");
        return;
        }

    Status = RpcBindingFree(&ChristopherHelgaNoEndpoint);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherHelgaNoEndpoint)\n");
        return;
        }

    Status = RpcBindingFree(&ChristopherIsabelleBinding);
    if (Status)
        {
        ApiError("Charles","RpcBindingFree",Status);
        PrintToConsole("Charles : FAIL - Unable to Free Binding");
        PrintToConsole(" (ChristopherIsabelleBinding)\n");
        return;
        }

    PrintToConsole("Charles : PASS\n");
}


int
ThomasNtSecurity
(
    IN char * NetworkOptions
    )
/*++

Routine Description:

    Thomas uses this routine to test NT security and RPC.

Arguments:

    NetworkOptions - Supplies the network options to be used for the
        binding.

Return Value:

    Zero will be returned if the test completes successfully, otherwise,
    non-zero will be returned.

--*/
{
    RPC_BINDING_HANDLE ThomasNormalBinding;

    Status = RpcBindingFromStringBindingA(
            GetStringBinding(TYLER,0,(unsigned char *) NetworkOptions),
                    &ThomasNormalBinding);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFromStringBinding",Status);
        PrintToConsole("Thomas : FAIL - Unable to Bind (Tyler)\n");
        return(1);
        }

    IsabelleNtSecurity(ThomasNormalBinding,
            strlen((char *) NetworkOptions) + 1, NetworkOptions);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Thomas : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&ThomasNormalBinding);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFree",Status);
        PrintToConsole("Thomas : FAIL - Unable to Free Binding");
        PrintToConsole(" (ThomasNormalBinding)\n");
        return(1);
        }

    return(0);
}


int
ThomasTestNtSecurity (
    )
/*++

Routine Description:

    This helper routine tests NT security (such as over named pipes and
    lpc).

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{
    if (ThomasNtSecurity("") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Dynamic True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Static True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Dynamic False") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Identification Static False") != 0)
        return(1);


    if (ThomasNtSecurity("Security=Anonymous Dynamic True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Anonymous Static True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Anonymous Dynamic False") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Anonymous Static False") != 0)
        return(1);


    if (ThomasNtSecurity("Security=Impersonation Dynamic True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Impersonation Static True") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Impersonation Dynamic False") != 0)
        return(1);

    if (ThomasNtSecurity("Security=Impersonation Static False") != 0)
        return(1);

    return(0);
}


int
ThomasInqSetAuthInfo (
    IN unsigned char PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN unsigned long AuthzSvc,
    IN RPC_STATUS ExpectedResult,
    IN unsigned long ExpectedAuthnLevel
    )
/*++

Routine Description:

    We test RpcBindingSetAuthInfo and RpcBindingInqAuthInfo in this
    routine.

Arguments:

    ServerPrincName - Supplies the server principal name to use.

    AuthnLevel - Supplies the authentication level to use.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentity - Supplies the security context to use.

    AuthzSvc - Supplies the authorization service to use.

    ExpectedResult - Supplies the result expected from RpcBindingSetAuthInfo.

    ExpectedAuthnLevel - Supplies the expected authentication level to
        be obtained from RpcBindingSetAuthInfo.

Return Value:

    A non-zero result indicates that the test failed.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    unsigned long AuthorizationService;
    unsigned char IgnoreString[4];

    Status = GetBinding(TYLER, &BindingHandle);
    if (Status)
        {
        ApiError("Thomas", "GetBinding", Status);
        PrintToConsole("Thomas : FAIL - Unable to Bind (Tyler)\n");
        return(1);
        }

    if (gPrincName)
        {
        ServerPrincName = (unsigned char *)gPrincName;
        }

    Status = RpcBindingSetAuthInfoA(BindingHandle, ServerPrincName, AuthnLevel,
            AuthnSvc, AuthIdentity, AuthzSvc);
    if ( Status != ExpectedResult )
        {
        ApiError("Thomas", "RpcBindingSetAuthInfo", Status);
        PrintToConsole("Thomas : FAIL - RpcBindingSetAuthInfo, Unexpected");
        PrintToConsole(" Result\n");
        return(1);
        }

    if (Status)
        {
        return(0);
        }

    Status = RpcBindingInqAuthInfo(BindingHandle, 0, &AuthenticationLevel,
            &AuthenticationService, 0, &AuthorizationService);
    if (Status)
        {
        ApiError("Thomas", "RpcBindingInqAuthInfo", Status);
        PrintToConsole("Thomas : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthenticationLevel != ExpectedAuthnLevel )
        {
        PrintToConsole("Thomas : WARNING - ");
        PrintToConsole("AuthenticationLevel != ExpectedAuthnLevel\n");
        }

    if ( AuthenticationService != AuthnSvc )
        {
        OtherError("Thomas", "AuthenticationService != AuthnSvc");
        PrintToConsole("Thomas : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthorizationService != AuthzSvc )
        {
        OtherError("Thomas", "AuthorizationService != AuthzSvc");
        PrintToConsole("Thomas : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    TestHelgaInterface(BindingHandle, HelgaMaxSize);
    IsabelleNtSecurity(BindingHandle, 1, IgnoreString);

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFree",Status);
        PrintToConsole("Thomas : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
ThomasTestRpcSecurity (BOOL fServerIsNTSystem
    )
/*++

Routine Description:

    This routine exercises rpc protocol level security support in the
    runtime.

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{
    RPC_AUTH_IDENTITY_HANDLE AuthId = NULL;
    OSVERSIONINFO versionInfo;

    if(ulSecurityPackage == 123)
        AuthId = 0 ;

    // if platform is Win98 and transport is MSMQ, no point of doing security tests
    // Falcon will try to upgrade connection level authentication to packet, which in turn
    // will be rejected by the security system. The only possible connection is not authenticated
    if (TransportType == RPC_TRANSPORT_MSMQ)
        {
        memset(&versionInfo, 0, sizeof(versionInfo));
        versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
        GetVersionEx(&versionInfo);
        if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            return 0;
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }
    }

    if (!fServerIsNTSystem)
        return 0;

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }
    }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT) != 0 )
        {
        return(1);
        }
    }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) != 0 )
        {
        return(1);
        }
    }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if(ulSecurityPackage == 123)
    {
    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }
    }

    return(0);
}


#ifdef WIN32RPC
int
ThomasTestLRpcSecurity (
    )
/*++

Routine Description:

    This routine exercises rpc protocol level security support in the
    runtime.

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{

    SEC_WINNT_AUTH_IDENTITY  ntssp;
    RPC_AUTH_IDENTITY_HANDLE AuthId = &ntssp;

    ntssp.User     = (RPC_CHAR *) SecurityUser;
    if (ntssp.User)
        {
        ntssp.UserLength = lstrlen((const RPC_SCHAR *) SecurityUser);
        }
    else
        {
        ntssp.UserLength = 0;
        }

    ntssp.Domain   = (RPC_CHAR *) SecurityDomain;
    if (ntssp.Domain)
        {
        ntssp.DomainLength = lstrlen((const RPC_SCHAR *) SecurityDomain);
        }
    else
        {
        ntssp.DomainLength = 0;
        }

    ntssp.Password = (RPC_CHAR *) SecurityPassword;
    if (ntssp.Password)
        {
        ntssp.PasswordLength = lstrlen((const RPC_SCHAR *) SecurityPassword);
        }
    else
        {
        ntssp.PasswordLength = 0;
        }

    ntssp.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // LRPC can only use 10
    ulSecurityPackage = 10 ;
    unsigned long size = 256;
    char UserName[256];
    char Tmp[256];

    //
    // hack
    //
    strcpy(UserName, "redmond\\");

    if (GetUserNameA(Tmp, &size) == 0)
        {
        return (1);
        }

    strcat(UserName, Tmp);

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CALL, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo((unsigned char PAPI *) UserName,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage, AuthId , 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    if ( ThomasInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, ulSecurityPackage,
                (RPC_AUTH_IDENTITY_HANDLE) RPC_CONST_STRING("ClientPrincipal"),
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_PKT_PRIVACY) != 0 )
        {
        return(1);
        }

    return(0);
}
#endif



void
Thomas (
    )
/*++

Routine Description:

    This routine is used to test security, both at the transport level,
    and at the RPC level.  We work with Tyler in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    BOOL fServerIsNTSystem;

    Synchro(TYLER) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Thomas : Test Security\n");

    Status = GetBinding(TYLER, &IsabelleBinding);
    if (Status)
        {
        ApiError("Thomas","GetBinding",Status);
        PrintToConsole("Thomas : FAIL - Unable to Bind (Tyler)\n");
        return;
        }

    fServerIsNTSystem = IsServerNTSystem(IsabelleBinding);

    // change here to test rpc security for LRPC also

    if(TransportType != RPC_LRPC)
        {
        if ( ThomasTestRpcSecurity(fServerIsNTSystem) != 0 )
            {
            return;
            }
        }

    if ( TransportType == RPC_TRANSPORT_NAMEPIPE || TransportType == RPC_LRPC )
        {
        if ( ThomasTestNtSecurity() != 0 )
            {
            return;
            }
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Thomas : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Thomas","RpcBindingFree",Status);
        PrintToConsole("Thomas : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Thomas : PASS\n");
}


int
TimInqSetAuthInfo (
    IN unsigned char PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN unsigned long AuthzSvc,
    IN RPC_STATUS ExpectedResult,
    IN unsigned long ExpectedAuthnLevel
    )
/*++

Routine Description:

    We test RpcBindingSetAuthInfo and RpcBindingInqAuthInfo in this
    routine.

Arguments:

    ServerPrincName - Supplies the server principal name to use.

    AuthnLevel - Supplies the authentication level to use.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentity - Supplies the security context to use.

    AuthzSvc - Supplies the authorization service to use.

    ExpectedResult - Supplies the result expected from RpcBindingSetAuthInfo.

    ExpectedAuthnLevel - Supplies the expected authentication level to
        be obtained from RpcBindingSetAuthInfo.

Return Value:

    A non-zero result indicates that the test failed.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    unsigned long AuthorizationService;
    unsigned char IgnoreString[4];

    Status = GetBinding(TYLER, &BindingHandle);
    if (Status)
        {
        ApiError("Tim", "GetBinding", Status);
        PrintToConsole("Tim : FAIL - Unable to Bind (Tyler)\n");
        return(1);
        }

    Status = RpcBindingSetAuthInfoA(BindingHandle, ServerPrincName, AuthnLevel,
            AuthnSvc, AuthIdentity, AuthzSvc);
    if ( Status != ExpectedResult )
        {
        ApiError("Tim", "RpcBindingSetAuthInfo", Status);
        PrintToConsole("Tim : FAIL - RpcBindingSetAuthInfo, Unexpected");
        PrintToConsole(" Result\n");
        return(1);
        }

    if (Status)
        {
        return(0);
        }

    Status = RpcBindingInqAuthInfo(BindingHandle, 0, &AuthenticationLevel,
            &AuthenticationService, 0, &AuthorizationService);
    if (Status)
        {
        ApiError("Tim", "RpcBindingInqAuthInfo", Status);
        PrintToConsole("Tim : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthenticationLevel != ExpectedAuthnLevel )
        {
        PrintToConsole("Tim : WARNING - ");
        PrintToConsole("AuthenticationLevel != ExpectedAuthnLevel\n");
        }

    if ( AuthenticationService != AuthnSvc )
        {
        OtherError("Tim", "AuthenticationService != AuthnSvc");
        PrintToConsole("Tim : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    if ( AuthorizationService != AuthzSvc )
        {
        OtherError("Tim", "AuthorizationService != AuthzSvc");
        PrintToConsole("Tim : FAIL - RpcBindingInqAuthInfo\n");
        return(1);
        }

    TestHelgaInterface(BindingHandle, HelgaMaxSize);
    IsabelleNtSecurity(BindingHandle, 1, IgnoreString);

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Tim","RpcBindingFree",Status);
        PrintToConsole("Tim : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
TimTestRpcSecurity (
    )
/*++

Routine Description:

    This routine exercises rpc protocol level security support in the
    runtime.

Return Value:

    A non-zero return value indicates that the test failed.

--*/
{

    RPC_AUTH_IDENTITY_HANDLE AuthId = NULL;

    // RPC_C_AUTHN_WINNT to ulSecurityPackage in the intrest of generality
    if ( TimInqSetAuthInfo((unsigned char PAPI *) "ServerPrincipal",
                RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage, AuthId, 0, RPC_S_OK,
                RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }

    // RPC_C_AUTHN_WINNT to ulSecurityPackage in the intrest of generality
    if ( TimInqSetAuthInfo(0, RPC_C_AUTHN_LEVEL_CONNECT, ulSecurityPackage,
                              AuthId,
                0, RPC_S_OK, RPC_C_AUTHN_LEVEL_CONNECT) != 0 )
        {
        return(1);
        }

    return(0);
}


void
Tim (
    )
/*++

Routine Description:

    This routine is used to test security, both at the transport level,
    and at the RPC level.  We work with Terry in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;

    Synchro(TYLER) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Tim : Test Security\n");

    Status = GetBinding(TYLER, &IsabelleBinding);
    if (Status)
        {
        ApiError("Tim","GetBinding",Status);
        PrintToConsole("Tim : FAIL - Unable to Bind (Tyler)\n");
        return;
        }


    if ( TransportType != RPC_LRPC )
        {
        if ( TimTestRpcSecurity() != 0 )
            {
            return;
            }
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Tim : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Tim","RpcBindingFree",Status);
        PrintToConsole("Tim : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Tim : PASS\n");
}


void
Robert (
    )
/*++

Routine Description:

    Robert works with Richard (in usvr.cxx) to test call and callback
    failures.

--*/
{
    RPC_BINDING_HANDLE RichardBinding;
    RPC_BINDING_HANDLE RichardHelperBinding;
    unsigned int RetryCount;

    Synchro(RICHARD) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Robert : Test Call and Callback Failures\n");

    Status = GetBinding(RICHARD, &RichardBinding);
    if (Status)
        {
        ApiError("Robert","GetBinding",Status);
        PrintToConsole("Robert : FAIL - Unable to Bind (Richard)\n");
        return;
        }


    Status = GetBinding(RICHARDHELPER, &RichardHelperBinding);
    if (Status)
        {
        ApiError("Robert","GetBinding",Status);
        PrintToConsole("Robert : FAIL - Unable to Bind (RichardHelper)\n");
        return;
        }

    Status = IsabelleRichardHelper(RichardBinding,RICHARDHELPER_EXECUTE);
    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

  //  PauseExecution(30000L);
   Synchro(RICHARDHELPER) ;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        Status = IsabelleRichardHelper(RichardHelperBinding,
                RICHARDHELPER_IGNORE);
        if (Status == RPC_S_OK)
            break;
        PauseExecution(RETRYDELAY);
        }

    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    Status = IsabelleRichardHelper(RichardHelperBinding, RICHARDHELPER_EXIT);
    if (Status == RPC_S_OK)
        {
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXIT) ");
        PrintToConsole("Succeeded\n");
        return;
        }

    if (Status != RPC_S_CALL_FAILED)
        {
        PrintToConsole("Robert : WARN - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXIT) != ");
        PrintToConsole("RPC_S_CALL_FAILED\n");
        }

    PauseExecution(TestDelay);

    Status = IsabelleRichardHelper(RichardHelperBinding,RICHARDHELPER_IGNORE);

    if (Status == RPC_S_OK)
        {
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE) ");
        PrintToConsole("Succeeded\n");
        return;
        }

    PrintToConsole("Robert : Spawning RichardHelper again\n") ;
    Status = IsabelleRichardHelper(RichardBinding,RICHARDHELPER_EXECUTE);

    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

 //   PauseExecution(30000L);
   Synchro(RICHARDHELPER) ;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        Status = IsabelleRichardHelper(RichardHelperBinding,
                RICHARDHELPER_IGNORE);
        if (Status == RPC_S_OK)
            break;
        PauseExecution(RETRYDELAY);
        }

    if (Status != RPC_S_OK)
        {
        ApiError("Robert","IsabelleRichardHelper",Status);
        PrintToConsole("Robert : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    IsabelleShutdown(RichardHelperBinding);
    IsabelleShutdown(RichardBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Robert : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&RichardBinding);
    if (Status)
        {
        ApiError("Robert","RpcBindingFree",Status);
        PrintToConsole("Robert : FAIL - Unable to Free Binding");
        PrintToConsole(" (RichardBinding)\n");
        return;
        }

    Status = RpcBindingFree(&RichardHelperBinding);
    if (Status)
        {
        ApiError("Robert","RpcBindingFree",Status);
        PrintToConsole("Robert : FAIL - Unable to Free Binding");
        PrintToConsole(" (RichardHelperBinding)\n");
        return;
        }

    PrintToConsole("Robert : PASS\n");
}


void
Keith (
    )
/*++

Routine Description:

    Keith works with Kenneth (in usvr.cxx) to test auto-reconnect.

--*/
{
    RPC_BINDING_HANDLE KennethBinding;
    RPC_BINDING_HANDLE KennethHelperBinding;

    Synchro(KENNETH) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Keith : Test Auto Reconnect\n");

    Status = GetBinding(KENNETH, &KennethBinding);
    if (Status)
        {
        ApiError("Keith","GetBinding",Status);
        PrintToConsole("Keith : FAIL - Unable to Bind (Kenneth)\n");
        return;
        }

    Status = GetBinding(RICHARDHELPER, &KennethHelperBinding);
    if (Status)
        {
        ApiError("Keith","GetBinding",Status);
        PrintToConsole("Keith : FAIL - Unable to Bind (KennethHelper)\n");
        return;
        }

    Status = IsabelleRichardHelper(KennethBinding, RICHARDHELPER_EXECUTE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

    PauseExecution(20000L);

    Status = IsabelleRichardHelper(KennethHelperBinding, RICHARDHELPER_IGNORE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    Status = IsabelleRichardHelper(KennethHelperBinding,
            RICHARDHELPER_DELAY_EXIT);
    if (Status != RPC_S_OK)
        {
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_DELAY_EXIT) ");
        PrintToConsole("Failed\n");
        return;
        }

    PauseExecution(30000L);

    Status = IsabelleRichardHelper(KennethBinding, RICHARDHELPER_EXECUTE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_EXECUTE)\n");
        return;
        }

    PauseExecution(40000L);

    Status = IsabelleRichardHelper(KennethHelperBinding, RICHARDHELPER_IGNORE);
    if (Status != RPC_S_OK)
        {
        ApiError("Keith","IsabelleRichardHelper",Status);
        PrintToConsole("Keith : FAIL - ");
        PrintToConsole("IsabelleRichardHelper(RICHARDHELPER_IGNORE)\n");
        return;
        }

    IsabelleShutdown(KennethHelperBinding);
    IsabelleShutdown(KennethBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Keith : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&KennethBinding);
    if (Status)
        {
        ApiError("Keith","RpcBindingFree",Status);
        PrintToConsole("Keith : FAIL - Unable to Free Binding");
        PrintToConsole(" (KennethBinding)\n");
        return;
        }

    Status = RpcBindingFree(&KennethHelperBinding);
    if (Status)
        {
        ApiError("Keith","RpcBindingFree",Status);
        PrintToConsole("Keith : FAIL - Unable to Free Binding");
        PrintToConsole(" (KennethHelperBinding)\n");
        return;
        }

    PrintToConsole("Keith : PASS\n");
}


void
Daniel (
    )
/*++

Routine Description:

    This routine is used to test association context rundown support;
    it works with David in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE DanielFirst;;
    RPC_BINDING_HANDLE DanielSecond;
    CCONTEXT *ContextHandle, *ContextHandle2;

    Synchro(DAVIDFIRST) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Daniel : Association Context and Rundown\n");

    Status = GetBinding(DAVIDFIRST, &DanielFirst);
    if (Status)
        {
        ApiError("Daniel","GetBinding",Status);
        PrintToConsole("Daniel : FAIL - Unable to Bind (DavidFirst)\n");
        return;
        }


    Status = GetBinding(DAVIDSECOND, &DanielSecond);
    if (Status)
        {
        ApiError("Daniel","GetBinding",Status);
        PrintToConsole("Daniel : FAIL - Unable to Bind (DavidSecond)\n");
        return;
        }

    IsabelleSetRundown(DanielSecond);
    IsabelleCheckContext(DanielSecond);

    #ifdef DEBUGRPC
    PrintToDebugger("\n\n\n\nUCLNT: Calling RpcBindingFree\n");
    #endif

    Status = RpcBindingFree(&DanielSecond);
    if (Status)
        {
        ApiError("Daniel","RpcBindingFree",Status);
        PrintToConsole("Daniel : FAIL - Unable to Free Binding");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    PauseExecution(3000L);

    IsabelleCheckRundown(DanielFirst);

    ContextHandle = (CCONTEXT *)I_RpcAllocate(sizeof(CCONTEXT));
    if (!ContextHandle)
        {
        ApiError("Daniel","I_RpcAllocate",Status);
        PrintToConsole("Daniel : FAIL - Unable to I_RpcAllocate");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    OpenContextHandle(DanielFirst, &IsabelleInterfaceInformation, NULL);

    OpenContextHandle(DanielFirst, &IsabelleInterfaceInformation, ContextHandle);

    Status = RpcBindingCopy(ContextHandle, (RPC_BINDING_HANDLE *)&ContextHandle2);
    if (Status)
        {
        ApiError("Daniel","RpcBindingCopy",Status);
        PrintToConsole("Daniel : FAIL - Unable to copy context handle");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    Status = RpcBindingSetOption(ContextHandle2, RPC_C_OPT_DONT_LINGER, TRUE);
    if (Status)
        {
        ApiError("Daniel","RpcBindingSetOption",Status);
        PrintToConsole("Daniel : FAIL - Unable to set context handle options");
        PrintToConsole(" (DanielSecond)\n");
        return;
        }

    RpcSsDestroyClientContext((void **)&ContextHandle);
    RpcSsDestroyClientContext((void **)&ContextHandle2);

    OpenContextHandle(DanielFirst, &HelgaInterfaceInformation, NULL);
    OpenContextHandle(DanielFirst, &HelgaInterfaceInformation, NULL);

    UnregisterHelgaEx(DanielFirst);

    IsabelleShutdown(DanielFirst);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Daniel : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&DanielFirst);
    if (Status)
        {
        ApiError("Daniel","RpcBindingFree",Status);
        PrintToConsole("Daniel : FAIL - Unable to Free Binding");
        PrintToConsole(" (DanielFirst)\n");
        return;
        }

    PrintToConsole("Daniel : PASS\n");
}


int
BenjaminTestBinding (
    IN unsigned char PAPI * StringBinding
    )
/*++

Routine Description:

    This helper routine will take and convert the string binding into
    a binding, use the binding to make a remote procedure call, and
    then free the binding.

Arguments:

    StringBinding - Supplies the string binding to use to convert into
        a binding.

Return Value:

    If the test passes, zero will be returned; otherwise, non-zero will
    be returned.

--*/
{
    RPC_BINDING_HANDLE Binding;
    unsigned char PAPI * ObjUuid;
    unsigned char PAPI * Protseq;
    unsigned char PAPI * NetworkAddr;
    unsigned char PAPI * NetworkOptions;
    int OldCallbacksFlag = 0;
    unsigned int TransportType;

    if ( UseEndpointMapperFlag != 0 )
        {
        Status = RpcStringBindingParseA(StringBinding, &ObjUuid, &Protseq,
                &NetworkAddr, 0, &NetworkOptions);
        if (Status)
            {
            ApiError("Benjamin", "RpcStringBindingParse", Status);
            PrintToConsole("Benjamin : RpcStringBindingParse Failed\n");
            return(1);
            }

        Status = RpcStringBindingComposeA(ObjUuid, Protseq, NetworkAddr, 0,
                NetworkOptions, &StringBinding);
        if (Status)
            {
            ApiError("Benjamin", "RpcStringBindingCompose", Status);
            PrintToConsole("Benjamin : RpcStringBindingCompose Failed\n");
            return(1);
            }

        Status = RpcStringFreeA(&Protseq);
        if (!Status)
              RpcStringFreeA(&NetworkOptions);
        if (!Status)
              RpcStringFreeA(&ObjUuid);
        if (Status)
           {
            ApiError("Benjamin", "RpcStringFree", Status);
            PrintToConsole("Benjamin : RpcStringFree Failed\n");
            return(1);
           }

        }

    PrintToConsole("Benjamin : ");
    PrintToConsole("%s - ", StringBinding);

    Status = RpcBindingFromStringBindingA(StringBinding, &Binding);
    if (Status)
        {
        if (Status == RPC_S_PROTSEQ_NOT_SUPPORTED)
            {
            return(0);
            }
        ApiError("Benjamin", "RpcBindingFromStringBinding", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Binding");
        PrintToConsole(" (StringBinding)\n");
        return(1);
        }

    SylviaBinding = Binding;

    Status = I_RpcBindingInqTransportType(SylviaBinding, &TransportType);

    if (Status)
        {
        ApiError("Benjamin", "I_RpcBindingInqTransportType", Status);
        PrintToConsole("Benjamin : I_RpcBindingInqTransportType Failed\n");
        return(1);
        }

    switch(TransportType)
        {
        case TRANSPORT_TYPE_CN:
            PrintToConsole("( cn )\n");
            break;
        case TRANSPORT_TYPE_DG:
            PrintToConsole(" ( dg )\n");
            break;
        case TRANSPORT_TYPE_LPC:
            PrintToConsole("( lpc )\n");
            break;
        default:
            {
            PrintToConsole("Benjamin : FAIL - Incorrect result");
            PrintToConsole("Benjamin : I_RpcBindingInqTransportType Failed\n");
            return(1);
            }
        }

    //This is a temporary workaround till dg implements callbacks
    //What we want to do is if the transport type is datagram, set the no
    //callback flag even if user didnt specify. Then unset it again!

    if (TransportType == TRANSPORT_TYPE_DG)
        {
        OldCallbacksFlag = NoCallBacksFlag;
        NoCallBacksFlag = 1;
        }

    if ( SylviaCall(SylviaBinding, 5, 0, 0) != LocalSylviaCall(5, 0, 0) )
        {
        PrintToConsole("Benjamin : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(5,0,0)\n");
        return(1);
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Benjamin : FAIL - Error(s) in Sylvia");
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    if (TransportType == TRANSPORT_TYPE_DG)
       {
         NoCallBacksFlag = OldCallbacksFlag;
       }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Benjamin", "RpcBindingFree", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return(1);
        }


    return(0);
}


void
Benjamin (
    )
/*++

Routine Description:

    This routine works with Bartholomew in usvr.exe to test that
    dynamic endpoints work.  What we actually do is inquire all bindings
    supported by the server, and then this client binds to each of
    them, and makes a call.

--*/
{
    RPC_BINDING_HANDLE Bartholomew;
    unsigned char * StringBinding;

    Synchro(BARTHOLOMEW) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(4*LONG_TESTDELAY);
        }

    PrintToConsole("Benjamin : Test Dynamic Endpoints\n");

    Status = GetBinding(BARTHOLOMEW, &Bartholomew);
    if (Status)
        {
        ApiError("Benjamin", "GetBinding", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Bind (Bartholomew)\n");
        return;
        }


    while ((StringBinding = IsabelleGetStringBinding(Bartholomew)) != 0)
        {
        if (0 != strstr("http", (char *) StringBinding))
            {
            delete StringBinding;
            continue;
            }

        if (BenjaminTestBinding(StringBinding) != 0)
            return;
        delete StringBinding;
        }

    IsabelleShutdown(Bartholomew);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Benjamin : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Bartholomew);
    if (Status)
        {
        ApiError("Benjamin", "RpcBindingFree", Status);
        PrintToConsole("Benjamin : FAIL - Unable to Free Binding");
        PrintToConsole(" (Bartholomew)\n");
        return;
        }

    PrintToConsole("Benjamin : PASS\n");
}


void
Harold (
    )
/*++

Routine Description:

    This routine works with Herman in usvr.exe to test that idle
    connections get cleaned up properly, and that context is maintained.

--*/
{
    RPC_BINDING_HANDLE Binding, ContextBinding;
    int seconds;

    PrintToConsole("Harold : Test Idle Connection Cleanup and Context\n");
    Synchro(HERMAN) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    Status = RpcMgmtEnableIdleCleanup();
    if (Status)
        {
        ApiError("Harold","RpcMgmtEnableIdleCleanup",Status);
        PrintToConsole("Harold : FAIL - RpcMgmtEnableIdleCleanup\n");
        return;
        }

    Status = GetBinding(HERMAN, &Binding);
    if (Status)
        {
        ApiError("Harold","GetBinding",Status);
        PrintToConsole("Harold : FAIL - Unable to Bind (Herman)\n");
        return;
        }


    IsabelleSetRundown(Binding);
    IsabelleCheckContext(Binding);

    // We want to wait for eight minutes.  This will give enough time for
    // the cleanup code to get run to cleanup the idle connection.

    PrintToConsole("Harold : Waiting");
    for (seconds = 0; seconds < 30; seconds++)
        {
        PauseExecution(1000L);
        PrintToConsole(".");
        }
    PrintToConsole("\n");

    IsabelleCheckRundown(Binding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Harold : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = I_RpcBindingCopy(Binding, &ContextBinding);
    if (Status)
        {
        ApiError("Harold", "I_RpcBindingCopy", Status);
        PrintToConsole("Harold : FAIL - I_RpcBindingCopy Failed\n");
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Harold","RpcBindingFree",Status);
        PrintToConsole("Harold : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    IsabelleSetRundown(ContextBinding);
    IsabelleCheckContext(ContextBinding);

    // We want to wait for eight minutes.  This will give enough time for
    // the cleanup code to get run to cleanup the idle connection, but this
    // time the connection should not be cleaned up because we have got
    // context open.

    PrintToConsole("Harold : Waiting");
    for (seconds = 0; seconds < 30; seconds++)
        {
        PauseExecution(1000L);
        PrintToConsole(".");
        }
    PrintToConsole("\n");

    IsabelleCheckNoRundown(ContextBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Harold : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }


    IsabelleShutdown(ContextBinding);

    Status = RpcBindingFree(&ContextBinding);
    if (Status)
        {
        ApiError("Harold","RpcBindingFree",Status);
        PrintToConsole("Harold : FAIL - Unable to Free Binding");
        PrintToConsole(" (ContextBinding)\n");
        return;
        }

    PrintToConsole("Harold : PASS\n");
}


unsigned int JamesSize = 128;
unsigned int JamesCount = 100;


void
James (
    )
/*++

Routine Description:

    This routine works with Jason in usvr.exe to perform timing tests
    of the runtime.

--*/
{
    RPC_BINDING_HANDLE Binding;
    unsigned int Count;
    unsigned long StartingTime, EndingTime;
    unsigned char PAPI * StringBinding;
    UUID ObjectUuid;

    PrintToConsole("James : Timing Test (%d) %d times\n", JamesSize,
            JamesCount);

    Synchro(JASON) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    //
    // Bind, NullCall, Free
    //

    StringBinding = GetStringBinding(JASON,0,0);
    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        Status = RpcBindingFromStringBindingA(StringBinding,&Binding);
        if (Status)
            {
            ApiError("James","RpcBindingFromStringBinding",Status);
            PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
            return;
            }

        if (fUniqueBinding)
            {
            Status = RpcBindingSetOption( Binding, RPC_C_OPT_UNIQUE_BINDING, TRUE );
            if (Status != RPC_S_OK)
                {
                ApiError("James","RpcBindingSetOption",Status);
                return;
                }
            }

        Helga(Binding);

        if (HelgaErrors != 0)
            {
            PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
            HelgaErrors = 0;
            return;
            }

        Status = RpcBindingFree(&Binding);
        if (Status)
            {
            ApiError("James","RpcBindingFree",Status);
            PrintToConsole("James : FAIL - Unable to Free Binding");
            PrintToConsole(" (Binding)\n");
            return;
            }
        }

    EndingTime = GetCurrentTime();
    PrintToConsole("    Bind, NullCall, Free : %d.%d ms [%d in %d milliseconds]\n",
            (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // NullCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        Helga(Binding);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    NullCall : %d.%d ms [%d in %d milliseconds]\n",
            (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // InCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaIN(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    InCall(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));


    //
    // InCall w/Binding Object UUID
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }
    GenerateUuidValue(8179, &ObjectUuid);
    Status = RpcBindingSetObject(Binding, &ObjectUuid);
    if (Status)
        {
        ApiError("Graham", "RpcBindingSetObject", Status);
        PrintToConsole("Graham : FAIL - Unable to Set Object\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaIN(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("  InCall/WUUID(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // OUTCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaOUT(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    OutCall(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    //
    // InOutCall
    //

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    Helga(Binding);

    StartingTime = GetCurrentTime();

    for (Count = 0; Count < JamesCount; Count++)
        {
        HelgaINOUT(Binding,JamesSize);
        }

    EndingTime = GetCurrentTime();

    if (HelgaErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("    InOutCall(%d) : %d.%d ms [%d in %d milliseconds]\n",
            JamesSize, (EndingTime - StartingTime) / JamesCount,
            ((1000 * (EndingTime - StartingTime) / JamesCount) % 1000),
            JamesCount, (EndingTime - StartingTime));

    Status = GetBinding(JASON, &Binding);
    if (Status)
        {
        ApiError("James","GetBinding",Status);
        PrintToConsole("James : FAIL - Unable to Bind (Jason)\n");
        return;
        }

    IsabelleShutdown(Binding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("James : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("James","RpcBindingFree",Status);
        PrintToConsole("James : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("James : PASS\n");
}


int
IsaacStressTest (
    IN unsigned int Iteration,
    IN unsigned int InitialSize,
    IN unsigned int MaximumSize,
    IN unsigned int Increment
    )
/*++

Routine Description:

    This routine performs one iteration of the stress test.  We bind with
    the server, perform one or more remote procedure calls, and then
    unbind.

Arguments:

    Iteration - Supplies an indication of which iteration of the test is
        being performed.  We will use that information to print out the
        buffer sizes the first time.

    InitialSize - Supplies the initial buffer size to use.

    MaximumSize - Supplies the maximum buffer size to use; when this size
        is reach, the test will return.

    Increment - Supplies the amount to increment the buffer size each
        time.

Return Value:

    Zero will be returned if the test completes successfully; otherwise,
    non-zero will be returned.

--*/
{
    RPC_BINDING_HANDLE Binding;

    Status = GetBinding(IVAN, &Binding);
    if (Status)
        {
        ApiError("Isaac","GetBinding",Status);
        PrintToConsole("Isaac : FAIL - Unable to Bind (Ivan)\n");
        return(1);
        }

    for (; InitialSize < MaximumSize; InitialSize += Increment)
        {
        if (Iteration == 0)
            {
            PrintToConsole("%d ",InitialSize);
            }
        Helga(Binding);
        HelgaIN(Binding, InitialSize);
        HelgaOUT(Binding, InitialSize);
        HelgaINOUT(Binding, InitialSize);
        }

    if (Iteration == 0)
        {
        PrintToConsole("\n");
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Isaac : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Isaac","RpcBindingFree",Status);
        PrintToConsole("Isaac : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return(1);
        }

    return(0);
}

unsigned int IsaacIterations = 100;
unsigned int IsaacInitialSize = 128;
unsigned int IsaacMaximumSize = 4096;
unsigned int IsaacIncrement = 512;


void
Isaac (
    )
/*++

Routine Description:

    This routine works to Ivan in usvr.exe to stress test the runtime.

--*/
{
    RPC_BINDING_HANDLE Binding;
    unsigned int Count;

    PrintToConsole("Isaac : Stress Test (%d to %d by %d) %d times\n",
            IsaacInitialSize, IsaacMaximumSize, IsaacIncrement,
            IsaacIterations);
    Synchro(IVAN) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    for (Count = 0; Count < IsaacIterations ; Count++)
        {
        if ( IsaacStressTest(Count, IsaacInitialSize, IsaacMaximumSize,
                    IsaacIncrement) != 0 )
            {
            return;
            }
        PrintToConsole(".");
        }
    PrintToConsole("\n");

       // this piece of code was below the loop
    Status = GetBinding(IVAN, &Binding);
    if (Status)
        {
        ApiError("Isaac","GetBinding",Status);
        PrintToConsole("Isaac : FAIL - Unable to Bind (Ivan)\n");
        return;
        }



    IsabelleShutdown(Binding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Isaac : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Isaac","RpcBindingFree",Status);
        PrintToConsole("Isaac : FAIL - Unable to Free Binding");
        PrintToConsole(" (Binding)\n");
        return;
        }

    PrintToConsole("Isaac : PASS\n");
}

void
ExtendedError (
    )
{
    RPC_BINDING_HANDLE Binding ;
    RPC_SECURITY_QOS QOS;
    UUID ObjectUuid;

    Status = GetBinding(TYLER, &Binding);
    if (Status)
        {
        ApiError("ExtendedError", "GetBinding", Status);
        PrintToConsole("ExtendedError : FAIL - Unable to Bind (Tyler)\n");
        return;
        }

    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    QOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;

    Status = RpcBindingSetAuthInfoEx(
                          Binding,
                          (RPC_CHAR  *) L"ServerPrincipal",
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("ExtendedError","RpcBindingSetAuthInfoEx",Status);
        return;
        }

    Helga(Binding);
    if (HelgaErrors)
        {
        PrintToConsole("RPC extended error: %d",
                        I_RpcGetExtendedError());
        }
    else
        {
        PrintToConsole("RPC call passed\n");
        }

    RpcBindingFree( &Binding );

    //
    // check propagation of extended-error packets
    //
    Status = GetBinding(TYLER, &Binding);
    if (Status)
        {
        ApiError("Async", "GetBinding", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

    //
    // see usvr.cxx: activates the extended error info in "ThreadProc"
    //
    GenerateUuidValue(UUID_EXTENDED_ERROR, &ObjectUuid);
    Status = RpcBindingSetObject(Binding, &ObjectUuid);
    if (Status)
        {
        ApiError("Async", "BindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

    int i;
    //
    // make a few calls on the helga interface
    // this should cause an alter context
    //
    for (i=0; i<3; i++)
        {
        __try
        {
            int inbuf[1];

            int sizeout = 0;
            int * bufferout;

            //
            // FooSync will force an exception on the server if the in-size is zero.
            //
            FooSync( Binding, sizeof(int), inbuf, &sizeout, &bufferout);
        }
        __except(1)
        {
            Status = GetExceptionCode();
        }

        if (Status != EXTENDED_ERROR_EXCEPTION)
            {
            PrintToConsole("eeinfo: call returned status %d instead of %d\n", Status, EXTENDED_ERROR_EXCEPTION);
            }

        DumpEeInfo(1);
        }
}

void  TestYield(void)
{
    RPC_BINDING_HANDLE Binding ;
    RPC_MESSAGE Caller;

    Synchro(TESTYIELD) ;

    Caller.BufferLength = 0;
    Caller.ProcNum = 5 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation ;
    Caller.RpcFlags = 0;

    Status = GetBinding(TESTYIELD, &Binding);
    if (Status)
        {
        ApiError("TestYield","GetBinding",Status);
        PrintToConsole("TestYield: FAIL - Unable to Bind\n");

        return;
        }

    // new code end
    Caller.Handle = Binding;

    while(UclntGetBuffer(&Caller))
    {
       Caller.Handle = Binding ;
       PauseExecution(1000) ;
    }

    if(UclntSendReceive(&Caller) != 0)
    {
        ApiError("TestYield","GetBinding",Status);
        PrintToConsole("TestYield: FAIL - Unable to Bind\n");

        return;
    }

   Status = I_RpcFreeBuffer(&Caller);
   if (Status)
       ApiError("TestYield","I_RpcFreeBuffer",Status);

   Status = RpcBindingFree(&Binding);
   if (Status)
        {
        ApiError("TestYield","RpcBindingFree",Status);
        PrintToConsole("TestYield: FAIL - Unable to Free Binding");
        return;
        }
}

char *GetNextCard (
    char **Ptr
    )
{
    char *Card = *Ptr ;
    if (*Card == 0)
        {
        return NULL ;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    ASSERT(*Card == '\\') ;
    Card++ ;
    while (*Card != '\\') Card++ ;
    Card++ ;

    return Card ;
}

char *GetNextIPAddress(
    char **Ptr
    )
{
    char *Address = *Ptr ;
    if (*Address == 0)
        {
        return NULL ;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    return Address ;
}

void PrintAddresses(
    char *Card
    )
{
    char szBuf[512] ;
    HKEY hKey;
    RPC_STATUS Status;
    char Buffer[512] ;
    DWORD Size = 512;
    char *address ;
    char *temp1 ;
    DWORD Type;

    // Create the key string
    sprintf(szBuf,
             "System\\CurrentControlSet\\Services\\%s\\Parameters\\Tcpip",
             Card) ;

    Status =
    RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        szBuf,
        0,
        KEY_READ,
        &hKey);

    if (   Status != ERROR_SUCCESS
    && Status != ERROR_FILE_NOT_FOUND )
    {
    ASSERT(0);
    return;
    }

    // Get DHCP Address
    if (Status == ERROR_SUCCESS)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "DhcpIPAddress",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        }

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return ;
        }

    PrintToConsole("\tDHCP: %s\n", Buffer) ;
    Status =
    RegQueryValueExA(
        hKey,
        "IPAddress",
        0,
        &Type,
        (unsigned char *) Buffer,
        &Size);

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return ;
        }

    int i ;
    for (i =0, temp1 = Buffer; address = GetNextIPAddress(&temp1); i++)
        {
        PrintToConsole("\tStatic IP Address [%d]: %s\n", i, address) ;
        }
}

void RegLookup()
{
    char *temp ;
    char *Card ;
    char Buffer[512] ;
    RPC_STATUS Status;
    HKEY hKey;
    DWORD Size = 512;
    DWORD Type;

    PrintToConsole("RegLookup\n") ;
    NumberOfTestsRun++ ;

    Status =
    RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Services\\Rpc\\Linkage",
        0,
        KEY_READ,
        &hKey);

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return;
        }

    if (Status == ERROR_SUCCESS)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "Bind",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        }

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return ;
        }

    char *temp1;
    char *address;

    PrintToConsole("Cards:") ;
    for (temp = Buffer; Card = GetNextCard(&temp);)
        {
        PrintToConsole("%s:\n", Card) ;
        PrintAddresses(Card) ;
        }
}

void
Except()
{
    int i ;

    for  (i =0; i <100; i++)
        {
        RpcTryExcept
        {
        RpcRaiseException(10) ;
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("exception raised!") ;
        }
        RpcEndExcept
        }
}

char *osf_ptype[]  =
{
    "rpc_request",
    "bad packet",
    "rpc_response",
    "rpc_fault",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "rpc_bind",
    "rpc_bind_ack",
    "rpc_bind_nak",
    "rpc_alter_context",
    "rpc_alter_context_resp",
    "rpc_auth_3",
    "rpc_shutdown",
    "rpc_cancel",
    "rpc_orphaned"
};

void
PrintUuid(UUID *Uuid)
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;
    if (   (Vector[0] == 0)
         && (Vector[1] == 0)
         && (Vector[2] == 0)
         && (Vector[3] == 0))
    {
        PrintToConsole("(Null Uuid)");
    }
    else
    {
        PrintToConsole("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                       Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                       Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                       Uuid->Data4[6], Uuid->Data4[7] );
    }
    return;
}

void do_copacket (
    rpcconn_common *Packet
    )
{
    sec_trailer *SecurityTrailer;

    //
    // Dump the common header first
    //
    PrintToConsole("\n");
    PrintToConsole ("rpc_vers\t\t- 0x%x\n", Packet->rpc_vers);
    PrintToConsole ("rpc_vers_minor\t\t- 0x%x\n", Packet->rpc_vers_minor);
    PrintToConsole ("PTYPE\t\t\t- 0x%x, %s\n",
             Packet->PTYPE, osf_ptype[Packet->PTYPE]);
    PrintToConsole ("pfc_flags\t\t- 0x%x\n", Packet->pfc_flags);
    PrintToConsole ("drep\t\t\t- 0x%x\n", (DWORD) *((DWORD *) &(Packet->drep)));
    PrintToConsole ("frag_length\t\t- 0x%x\n", Packet->frag_length);
    PrintToConsole ("auth_length\t\t- 0x%x\n", Packet->auth_length);
    PrintToConsole ("call_id\t\t\t- 0x%x\n", Packet->call_id);


    //
    //
    // Dump the packet specific stuff
    //
    switch (Packet->PTYPE)
        {
        case rpc_request:
            PrintToConsole ("alloc_hint\t\t- 0x%x\n", ((rpcconn_request *) Packet)->alloc_hint);
            PrintToConsole ("p_cont_id\t\t- 0x%x\n", ((rpcconn_request *) Packet)->p_cont_id);
            PrintToConsole ("opnum\t\t\t- 0x%x\n", ((rpcconn_request *) Packet)->opnum);
            if (Packet->pfc_flags & PFC_OBJECT_UUID)
                {
                PrintToConsole("UUID\t\t -\n");
                PrintUuid((UUID *) (((char *)Packet)+sizeof(rpcconn_common)));
                PrintToConsole("\n");
                PrintToConsole ("Stub Data\t\t- 0x%p\n",
                         (char *) Packet+sizeof(rpcconn_request)+sizeof(UUID));
                }
            else
                {
                PrintToConsole ("Stub Data\t\t- 0x%p\n", (char *) Packet+sizeof(rpcconn_request));
                }
            break;

        case rpc_response:
            PrintToConsole ("alloc_hint\t\t- 0x%x\n", ((rpcconn_response *) Packet)->alloc_hint);
            PrintToConsole ("p_cont_id\t\t- 0x%x\n", ((rpcconn_response *) Packet)->p_cont_id);
            PrintToConsole ("alert_count\t\t- 0x%x\n", ((rpcconn_response *) Packet)->alert_count);
            PrintToConsole ("reserved\t\t- 0x%x\n", ((rpcconn_response *) Packet)->reserved);
            PrintToConsole ("Stub Data\t\t- 0x%p\n", (char *) Packet+sizeof(rpcconn_response));
            break;

        case rpc_fault:
            PrintToConsole ("alloc_hint\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->alloc_hint);
            PrintToConsole ("p_cont_id\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->p_cont_id);
            PrintToConsole ("alert_count\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->alert_count);
            PrintToConsole ("reserved\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->reserved);
            PrintToConsole ("status\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->status);
            PrintToConsole ("reserved2\t\t- 0x%x\n", ((rpcconn_fault *) Packet)->reserved2);
            break;

        case rpc_bind:
        case rpc_alter_context:
            PrintToConsole ("max_xmit_frag\t\t- 0x%x\n", ((rpcconn_bind *) Packet)->max_xmit_frag);
            PrintToConsole ("max_recv_frag\t\t- 0x%x\n", ((rpcconn_bind *) Packet)->max_recv_frag);
            PrintToConsole ("assoc_group_id\t\t- 0x%x\n", ((rpcconn_bind *) Packet)->assoc_group_id);
            break;

        case rpc_bind_ack:
            PrintToConsole ("max_xmit_frag\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->max_xmit_frag);
            PrintToConsole ("max_recv_frag\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->max_recv_frag);
            PrintToConsole ("assoc_group_id\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->assoc_group_id);
            PrintToConsole ("sec_addr_length\t\t- 0x%x\n", ((rpcconn_bind_ack *) Packet)->sec_addr_length);
            break;

        case rpc_bind_nak:
            PrintToConsole ("provider_reject_reason\t\t- 0x%x\n", ((rpcconn_bind_nak *) Packet)->provider_reject_reason);
            PrintToConsole ("versions\t\t- 0x%x\n", ((rpcconn_bind_nak *) Packet)->versions);
            break;

        case rpc_alter_context_resp:
            PrintToConsole ("max_xmit_frag\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->max_xmit_frag);
            PrintToConsole ("max_recv_frag\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->max_recv_frag);
            PrintToConsole ("assoc_group_id\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->assoc_group_id);
            PrintToConsole ("sec_addr_length\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->sec_addr_length);
            PrintToConsole ("pad\t\t- 0x%x\n", ((rpcconn_alter_context_resp *) Packet)->pad);
            break;

        case rpc_auth_3:
        case rpc_shutdown:
        case rpc_cancel:
        case rpc_orphaned:
            break;

        default:
            PrintToConsole ("Bad Packet\n");
            break;
        }

    //
    // Dump the security trailer
    //
    if (Packet->auth_length)
        {
        SecurityTrailer = (sec_trailer *) ((char *) Packet+Packet->frag_length
            -Packet->auth_length - sizeof(sec_trailer));
        PrintToConsole("Security trailer: 0x%p\n", SecurityTrailer);
        PrintToConsole ("auth_type\t\t- 0x%x\n", SecurityTrailer->auth_type);
        PrintToConsole ("auth_level\t\t- 0x%x\n", SecurityTrailer->auth_level);
        PrintToConsole ("auth_pad_length\t\t- 0x%x\n", SecurityTrailer->auth_pad_length);
        PrintToConsole ("auth_reserved\t\t- 0x%x\n", SecurityTrailer->auth_reserved);
        PrintToConsole ("auth_context_id\t\t- 0x%x\n", SecurityTrailer->auth_context_id);
        PrintToConsole ("trailer\t\t-0x%p\n", SecurityTrailer+1);
        }
}

void
RpcPduFilter (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN BOOL fDatagram
    )
{
    if (fDatagram == 0)
        {
        do_copacket((rpcconn_common *) Buffer);
        }
    else
        {
        PrintToConsole("UCNT: Datagram PDU\n");
        }
}

void
SetPDUFilter (
    )
{
    HMODULE hLibrary;
    RPC_SETFILTER_FUNC pSetFilterFunc;

    hLibrary = LoadLibraryA("rpcrt4.dll");
    if (hLibrary == 0)
        {
        PrintToConsole("UCLNT: Cannot set PDU filter\n");
        return;
        }

    pSetFilterFunc = (RPC_SETFILTER_FUNC) GetProcAddress(
                            hLibrary, "I_RpcltDebugSetPDUFilter");
    if (pSetFilterFunc == 0)
        {
        PrintToConsole("UCLNT: Cannot set PDU filter\n");
        return;
        }

    (*pSetFilterFunc) (RpcPduFilter);
}

extern void
Async (
    int testnum
    ) ;

extern void
SendAck (
    int testnum
    ) ;

extern void
AsyncAll (
        void
        ) ;


int __cdecl
main (
    int argc,
    char * argv[]
    )

/*
Transports:

    Update this to add a new transport.
*/

{
    int argscan;
    RPC_STATUS RpcStatus = RPC_S_OK;
    char *option ;
    int testnum = 0;
    DWORD dwTickCount;

    dwTickCount = GetTickCount();

    InitializeCriticalSection(&TestMutex);

    // Normally, this routine will be called by the DLL initialization
    // routine.  However, we are linking in our own copy of the threads
    // package, so we need to call this to initialize it.

    RpcMgmtSetCancelTimeout(20) ;

    ASSERT( RpcStatus == RPC_S_OK );

    PrintToConsole("RPC Runtime Client Build Verification Test\n");

    TransportType = RPC_TRANSPORT_NAMEPIPE;

    for (argscan = 1; argscan < argc; argscan++)
        {

        if (strcmp(argv[argscan], "-p") == 0)
        {
            ulSecurityPackage = (unsigned long) atol(argv[argscan+1]);
            argscan++;
        }
        else if (strcmp(argv[argscan],"-princ") == 0)
            {
            gPrincName = argv[argscan + 1];
            argscan ++;
            }
        else if (strcmp(argv[argscan],"-warn") == 0)
            {
            WarnFlag = 1;
            }
        else if (strcmp(argv[argscan],"-noncausal") == 0)
            {
            fNonCausal = 1;
            }
        else if (strcmp(argv[argscan],"-unique") == 0)
            {
            fUniqueBinding = 1;
            }
        else if (strcmp(argv[argscan],"-v") == 0)
            {
            Verbose = 1;
            }
        else if (strcmp(argv[argscan],"-verbose") == 0)
            {
            Verbose = 1;
            }
        else if (strcmp(argv[argscan],"-error") == 0)
            {
            ErrorFlag = 1;
            }
        else if (strcmp(argv[argscan],"-rpcss") == 0)
            {
            UseEndpointMapperFlag = 1;
            }
        else if (strcmp(argv[argscan],"-nosecuritytests") == 0)
            {
            NoSecurityTests = 1;
            }
        else if (strcmp(argv[argscan],"-nocallbacks") == 0)
            {
            NoCallBacksFlag = 1;
            }
        else if (strcmp(argv[argscan],"-small") == 0)
            {
            HelgaMaxSize = 1024;
            }
        else if (strcmp(argv[argscan],"-medium") == 0)
            {
            HelgaMaxSize = 8*1024;
            }
        else if (strcmp(argv[argscan],"-exceptfail") == 0)
            {
            RpcRaiseException(437);
            }
        else if (strcmp(argv[argscan],"-idempotent") == 0)
            {
            HackForOldStubs = RPC_FLAGS_VALID_BIT;
            }
        else if (strcmp(argv[argscan],"-theodore") == 0)
            {
            Theodore();
            }
        else if (strcmp(argv[argscan],"-sebastian") == 0)
            {
            Sebastian();
            }
        else if (strcmp(argv[argscan],"-hybrid") == 0)
            {
            Hybrid();
            }
        else if (strcmp(argv[argscan],"-lpcsecurity") == 0)
            {
            LpcSecurity();
            }
        else if (strcmp(argv[argscan],"-objuuid") == 0)
            {
            TestObjectUuids();
            }
        else if (strcmp(argv[argscan],"-connid") == 0)
            {
            TestConnId();
            }
        else if (strcmp(argv[argscan],"-graham") == 0)
            {
            Graham();
            }
        else if (strcmp(argv[argscan],"-edward") == 0)
            {
            Edward();
            }
        else if (strcmp(argv[argscan],"-astro") == 0)
            {
            Astro();
            }
        else if (strcmp(argv[argscan],"-fitzgerald") == 0)
            {
            Fitzgerald();
            }
        else if (strcmp(argv[argscan],"-charles") == 0)
            {
            Charles();
            }
        else if (strcmp(argv[argscan],"-daniel") == 0)
            {
            Daniel();
            }
        else if (strcmp(argv[argscan],"-thomas") == 0)
            {
            Thomas();
            }
        else if (strcmp(argv[argscan],"-tim") == 0)
            {
            Tim();
            }
        else if (strcmp(argv[argscan],"-robert") == 0)
            {
            Robert();
            }
        else if (strcmp(argv[argscan],"-benjamin") == 0)
            {
            Benjamin();
            }
        else if (strcmp(argv[argscan],"-harold") == 0)
            {
            Harold();
            }
        else if (strcmp(argv[argscan],"-isaac") == 0)
            {
            Isaac();
            }
        else if (strcmp(argv[argscan],"-james") == 0)
            {
            James();
            }
        else if (strcmp(argv[argscan],"-keith") == 0)
            {
            Keith();
            }
        else if (strcmp(argv[argscan],"-exerror") == 0)
            {
            ExtendedError();
            }
        else if (strcmp(argv[argscan],"-eeinfo") == 0)
            {
            ExtendedErrorInfo();
            }
        else if (strcmp(argv[argscan],"-async") == 0)
            {
            Async(testnum);
            }
        else if (strcmp(argv[argscan],"-mutextest") == 0)
            {
            PerformMultiThreadAstroTest(AstroDontBind, AstroMutex, 0);
            }
        else if (strcmp(argv[argscan],"-asynctest") == 0)
            {
            argscan++ ;
            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }
            }
        else if (strcmp(argv[argscan],"-sendack") == 0)
            {
            argscan++ ;

            if (argscan == argc)
                {
                PrintToConsole("-sendack: you must specify a test #, or zero for all, or '?' for help\n");
                return 1;
                }

            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }

            SendAck( testnum );
            }
        else if (strcmp(argv[argscan],"-dgtransport") == 0)
            {
            argscan++ ;

            if (argscan == argc)
                {
                PrintToConsole("-dgtransport: you must specify a test #, or zero for all, or '?' for help\n");
                return 1;
                }

            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }

            DgTransport( testnum );
            }
        else if (strcmp(argv[argscan],"-securityerror") == 0)
            {
            PrintToConsole("security provider error tests \n");

            argscan++ ;

            if (argscan == argc)
                {
                PrintToConsole("-securityerror: you must specify a test #, or zero for all, or '?' for help\n");
                return 1;
                }

            if (strcmp(argv[argscan], "?") == 0)
                {
                testnum = 100 ;
                }
            else
                {
                testnum = atoi(argv[argscan]) ;
                }
            SecurityErrorWrapper(testnum);
            }
        else if (strcmp(argv[argscan],"-reg") == 0)
            {
            RegLookup() ;
            }
        else if (strcmp(argv[argscan],"-pipe") == 0)
            {
            Pipe() ;
            }
        else if (strcmp(argv[argscan],"-except") == 0)
            {
            Except();
            }
        else if (strcmp(argv[argscan],"-namepipe") == 0)
            {
            TransportType = RPC_TRANSPORT_NAMEPIPE;
            }
        else if (strcmp(argv[argscan],"-lrpc") == 0)
            {
            TransportType = RPC_LRPC;
            }
        else if (strcmp(argv[argscan],"-tcp") == 0)
            {
            TransportType = RPC_TRANSPORT_TCP;
            }
        else if (strcmp(argv[argscan],"-udp") == 0)
            {
            DatagramTests   = 1;
            NoCallBacksFlag = 1;
            TransportType = RPC_TRANSPORT_UDP;
            }
        else if (strcmp(argv[argscan],"-dnet") == 0)
            {
            TransportType = RPC_TRANSPORT_DNET;
            }
        else if (strcmp(argv[argscan],"-netbios") == 0)
            {
            TestDelay = LONG_TESTDELAY;
            TransportType = RPC_TRANSPORT_NETBIOS;
            }
        else if (strcmp(argv[argscan],"-spx") == 0)
            {
            TransportType = RPC_TRANSPORT_SPX;
            }
        else if (strcmp(argv[argscan], "-dsp") == 0)
            {
            TransportType = RPC_TRANSPORT_DSP ;
            }
        else if (strcmp(argv[argscan], "-autolisten") == 0)
            {
            AutoListenFlag = 1 ;
            }
        else if (strcmp(argv[argscan], "-ifsecurity") == 0)
            {
            IFSecurityFlag = 1 ;
            }
        else if (strcmp(argv[argscan],"-ipx") == 0)
            {
            DatagramTests   = 1;
            NoCallBacksFlag = 1;
            TransportType = RPC_TRANSPORT_IPX;
            }
        else if (strcmp(argv[argscan],"-vns") == 0)
            {
            TransportType = RPC_TRANSPORT_VNS;
            }
        else if (strcmp(argv[argscan],"-msmq") == 0)
            {
            DatagramTests   = 1;
            NoCallBacksFlag = 1;
            TransportType = RPC_TRANSPORT_MSMQ;
            }
        else if (strcmp(argv[argscan],"-pdufilter") == 0)
            {
            SetPDUFilter();
            }
        else if (strcmp(argv[argscan],"-protocol") == 0)
            {
            strcpy(NetBiosProtocol+sizeof("ncacn_nb_")-1, argv[argscan+1]);
            argscan++;
            }

        else if (strncmp(argv[argscan],"-server:",strlen("-server:")) == 0)
            {
            Server = argv[argscan] + strlen("-server:");
            }
        else if (strncmp(argv[argscan],"-su:",
                         strlen("-su:")) == 0)
            {
            SecurityUser = (char *)(argv[argscan] + strlen("-su:"));
            }
        else if (strncmp(argv[argscan],"-sd:",
                         strlen("-sd:")) == 0)
            {
            SecurityDomain = (char *) (argv[argscan] + strlen("-sd:"));
            }
        else if (strncmp(argv[argscan],"-sp:",
                         strlen("-sp:")) == 0)
            {
            SecurityPassword = (char *) (argv[argscan] + strlen("-sp:"));
            }
            else if (strncmp(argv[argscan],"-threads:",strlen("-threads:")) == 0)
            {
            AstroThreads = atoi(argv[argscan] + strlen("-threads:"));
            if (AstroThreads == 0)
                {
                AstroThreads = 1;
                }
            }
        else if (strncmp(argv[argscan],"-iterations:",strlen("-iterations:"))
                    == 0)
            {
            IsaacIterations = atoi(argv[argscan] + strlen("-iterations:"));
            if (IsaacIterations == 0)
                {
                IsaacIterations = 100;
                }
            }
        else if (strncmp(argv[argscan],"-initial:",strlen("-initial:"))
                    == 0)
            {
            IsaacInitialSize = atoi(argv[argscan] + strlen("-initial:"));
            if (IsaacInitialSize < 4)
                {
                IsaacInitialSize = 128;
                }
            }
        else if (strncmp(argv[argscan],"-maximum:",strlen("-maximum:"))
                    == 0)
            {
            IsaacMaximumSize = atoi(argv[argscan] + strlen("-maximum:"));
            if (IsaacMaximumSize < IsaacInitialSize)
                {
                IsaacMaximumSize = 4096;
                }
            }
        else if (strncmp(argv[argscan],"-increment:",strlen("-increment:"))
                    == 0)
            {
            IsaacIncrement = atoi(argv[argscan] + strlen("-increment:"));
            if (IsaacIncrement == 0)
                {
                IsaacIncrement = 512;
                }
            }
        else if (strncmp(argv[argscan],"-size:",strlen("-size:"))
                    == 0)
            {
            JamesSize = atoi(argv[argscan] + strlen("-size:"));
            if (JamesSize <4)
                {
                JamesSize = 4;
                }
            }
        else if (strncmp(argv[argscan],"-count:",strlen("-count:"))
                    == 0)
            {
            JamesCount = atoi(argv[argscan] + strlen("-count:"));
            if (JamesCount == 0)
                {
                JamesCount = 100;
                }
            }

        else if (   (strcmp(argv[argscan],"-usage") == 0)
                 || (strcmp(argv[argscan],"-?") == 0))
            {
            PrintToConsole("Usage : uclnt\n");
            PrintToConsole("        -warn : turn on warning messages\n");
            PrintToConsole("        -error : turn on error messages\n");
            PrintToConsole("        -nocallbacks\n");
            PrintToConsole("        -nosecuritytests\n");
            PrintToConsole("        -theodore\n");
            PrintToConsole("        -exceptfail\n");
            PrintToConsole("        -sebastian\n");
            PrintToConsole("        -graham\n");
            PrintToConsole("        -edward\n");
            PrintToConsole("        -astro\n");
            PrintToConsole("        -fitzgerald\n");
            PrintToConsole("        -charles\n");
            PrintToConsole("        -daniel\n");
            PrintToConsole("        -thomas\n");
            PrintToConsole("        -tim\n");
            PrintToConsole("        -robert\n");
            PrintToConsole("        -benjamin\n");
            PrintToConsole("        -harold\n");
            PrintToConsole("        -isaac\n");
            PrintToConsole("        -james\n");
            PrintToConsole("        -keith\n");
            PrintToConsole("        -hybrid\n");
            PrintToConsole("        -connid\n");
            PrintToConsole("        -pipe\n") ;
            PrintToConsole("        -namepipe\n");
            PrintToConsole("        -lrpc\n");
            PrintToConsole("        -tcp\n");
            PrintToConsole("        -udp [-idempotent -maybe -broadcast]\n");
            PrintToConsole("        -dnet\n");
            PrintToConsole("        -netbios\n");
            PrintToConsole("        -server:<server>\n");
            PrintToConsole("        -spx\n");
            PrintToConsole("        -ipx\n");
            PrintToConsole("        -dsp\n") ;
            PrintToConsole("        -msmq\n") ;
            PrintToConsole("        -threads:<astro threads>\n");
            PrintToConsole("        -iterations:<isaac iterations>\n");
            PrintToConsole("        -initial:<isaac initial size>\n");
            PrintToConsole("        -maximum:<isaac maximum size>\n");
            PrintToConsole("        -increment:<isaac increment>\n");
            PrintToConsole("        -size:<james size>\n");
            PrintToConsole("        -count:<james count>\n");
            PrintToConsole("        -rpcss\n");
            PrintToConsole("        -p <security provider #>\n");
            PrintToConsole("        -su:<tim user>\n");
            PrintToConsole("        -sd:<tim domain>\n");
            PrintToConsole("        -sp:<tim password>\n");
            PrintToConsole("        -unique             (enables RPC_C_OPT_UNIQUE_BINDING)\n");
            PrintToConsole("        -noncausal          (enables RPC_C_OPT_BINDING_NONCAUSAL)\n");
            return(1);
            }
        else if (argv[argscan][0] == '-')
            {
            PrintToConsole("unknown option '%s'\n", argv[argscan]);
            return 1;
            }
        else
            Server = argv[argscan];
        }

    if ( NumberOfTestsRun == 0 )
        {
        Theodore();
        Sebastian();
        Graham();
        Edward();
        Astro();
        Fitzgerald();
        Charles();
        Daniel();
        if ( NoSecurityTests == 0)
            {
            Thomas();
            }
        if ( TransportType != RPC_LRPC )
            {
            Robert();
            }
        Keith();
        Benjamin();
        Async(0);
        }

    return(0); // To keep the compiler happy.
}


//
// BVT for Async RPC
//

//
// Client side code
//

//
// the following routines outline the client side code for a simple async
// function
//

#define TRACE(_x) { \
    if (Verbose) \
        {\
        PrintToConsole _x;\
        }\
    }

int OutstandingCalls ;
int FooProcnum = 16 ;
int FooPipeProcnum = 17 ;
void * FooInterface = &IsabelleInterfaceInformation;

#if 0
//
// Begin, Approximate idl file
//
interface FooInterface {
    int Foo (handle_t hBinding, [in] int sizein, [in] int *bufferin,
                [in, out] int *sizeout, [out] int **bufferout) ;
    }
// End, idl file

//
// Begin, Corresponding ACF file
//
interface FooInterface {
    [async] Foo () ;
    }
// End, acf file

//
// look at asyncstub.h for the generated header
// file for function Foo
//
#endif

////////////////////////////////////////////////////////////
// Begin, stubs for Foo                                                      //
////////////////////////////////////////////////////////////

HANDLE SyncEvent ;
typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    void *state ;
    int *sizeout ;
    int **bufferout ;
    } FOO_ASYNC_CLIENT_STATE;


RPC_STATUS
FooComplete(
    IN PRPC_ASYNC_STATE pAsync,
    OUT void *Reply
    )
/*++

Routine Description:

    The completion routine corresponding to the function Foo. This routine
    is called to get the out parameters from an async function.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    RPC_STATUS Status ;
    RPC_MESSAGE Message ;
    int *ptr ;
    FOO_ASYNC_CLIENT_STATE *StubInfo =
               (FOO_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;

    Message.RpcInterfaceInformation = FooInterface ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength ;
    Status = I_RpcReceive(&Message, 0) ;
    if (Status)
        {
        return Status ;
        }

    ptr = (int *) Message.Buffer ;

    *((int *) Reply) = *ptr++ ;
    *(StubInfo->sizeout) = *ptr++ ;

    *(StubInfo->bufferout) = (int *) I_RpcAllocate(*(StubInfo->sizeout)) ;
    if (*(StubInfo->bufferout) == 0)
        {
        return RPC_S_OUT_OF_MEMORY ;
        }

    RpcpMemoryCopy(*(StubInfo->bufferout), ptr, *(StubInfo->sizeout)) ;

    I_RpcFreeBuffer(&Message) ;
    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}


void
Foo (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    )
/*++

Routine Description:

    Client stub for function Foo.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOO_ASYNC_CLIENT_STATE *StubInfo ;
    int *Ptr ;

    StubInfo = (FOO_ASYNC_CLIENT_STATE *) I_RpcAllocate (
                        sizeof(FOO_ASYNC_CLIENT_STATE)) ;
    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->StubInfo = (void *) StubInfo ;

    StubInfo->StubState.CallHandle = hBinding ;

    Message.Handle = hBinding ;
    Message.BufferLength = 8+sizein+(sizein%4) ;
    Message.ProcNum = FooProcnum | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = FooInterface ;
    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // marshal ;-)
    Ptr = (int *) Message.Buffer ;
    *Ptr++ = sizein ;

    RpcpMemoryCopy(Ptr, bufferin, sizein) ;

    Ptr += (sizein+3)/sizeof(int) ;

    *Ptr = *sizeout ;

    StubInfo->StubState.Flags = 0;
    StubInfo->sizeout = sizeout ;
    StubInfo->bufferout = bufferout ;

    RpcStatus = I_RpcAsyncSetHandle(&Message, (PRPC_ASYNC_STATE) pAsync) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CompletionRoutine = FooComplete ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CallHandle = Message.Handle ;
    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;
    // return to the app
}



int
FooSync (
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    )
/*++

Routine Description:

    Client stub for function Foo.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    int *Ptr ;
    int retval ;

    Message.Handle = hBinding ;
    Message.BufferLength = 8+sizein+(sizein%4) ;
    Message.ProcNum = FooProcnum | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = 0;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    Ptr = (int *) Message.Buffer ;
    *Ptr++ = sizein ;

    RpcpMemoryCopy(Ptr, bufferin, sizein) ;

    Ptr += (sizein+3)/sizeof(int) ;

    *Ptr = *sizeout ;

    Message.RpcFlags = 0;

    RpcStatus = I_RpcSendReceive(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    *bufferout = (int *) I_RpcAllocate(*sizeout) ;
    if (*bufferout == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    Ptr = (int *) Message.Buffer ;
    retval = *Ptr++ ;
    *sizeout = *Ptr++;

    RpcpMemoryCopy(*bufferout, Ptr, *sizeout) ;

    I_RpcFreeBuffer(&Message) ;

    return retval ;
}

////////////////////////////////////////////////////////////
// End, stubs for Foo                                                        //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STATE Async ;
    int SizeOut ;
    int *BufferOut ;
    BOOL CallFinished ;
    } CALL_COOKIE ;


void
ThreadProc(
    IN CALL_COOKIE *Cookie
    )
/*++

Routine Description:

    completion routine is called in another thread. To prove that it can be.

Arguments:

     pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    int retval ;

    TRACE(("Foo: waiting for aync reply\n")) ;

    RpcTryExcept
        {
        WaitForSingleObject(Cookie->Async.u.hEvent, INFINITE) ;

        Status = MyRpcCompleteAsyncCall(&Cookie->Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie->BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    SetEvent(SyncEvent) ;
}

void
WaitForReply (
    IN BOOL *pfCallFinished
    )
{
    do
        {
        if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
            {
            RpcRaiseException(APP_ERROR);
            }
        } while (*pfCallFinished == 0);
}

void
FooAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    CALL_COOKIE *Cookie = (CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcCallComplete:
            Cookie->CallFinished = 1;
            OutstandingCalls--;
            break;
        }
}



void
CallFoo (
    RPC_BINDING_HANDLE Binding,
    CALL_COOKIE *Cookie,
    RPC_NOTIFICATION_TYPES NotificationType,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int *BufferIn ;

    BufferIn = (int *) new char[SizeIn] ;
    if (BufferIn == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    Cookie->SizeOut = SizeOut ;
    Cookie->Async.Size = sizeof(RPC_ASYNC_STATE) ;
    Cookie->Async.Flags = 0;
    Cookie->Async.Lock = 0;
    Cookie->Async.NotificationType = NotificationType ;

    switch (NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeEvent:
            Cookie->Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
            if (Cookie->Async.u.hEvent == 0)
                {
                RpcRaiseException(APP_ERROR) ;
                }

            Cookie->Async.NotificationType = RpcNotificationTypeEvent ;
            break;

        case RpcNotificationTypeApc:
            Cookie->Async.NotificationType = RpcNotificationTypeApc ;
            Cookie->Async.u.APC.NotificationRoutine = FooAPCRoutine ;
            Cookie->Async.u.APC.hThread = 0;
            Cookie->CallFinished = 0;
            break;

        default:
            PrintToConsole("Async: bad notification type\n") ;
            break;
        }

    Cookie->Async.UserInfo = (void *) Cookie ;

    // call the async function
    // the buffers supplied for the [out] and the [in, out] params
    // should be valid until the logical RPC call has completed.
    Foo(&Cookie->Async,
          Binding,
          SizeIn,
          BufferIn,
          &Cookie->SizeOut,
          &Cookie->BufferOut) ;

    delete BufferIn ;
}


void
AsyncUsingEvent(
    IN RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    int userstate = 10;
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    CALL_COOKIE *Cookie = 0;


    RpcTryExcept
        {
        Cookie =new CALL_COOKIE ;

        if (Cookie == 0)
            {
            RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
            }

        CallFoo (Binding, Cookie, RpcNotificationTypeEvent, SizeIn, SizeOut) ;

        HandleToThread = CreateThread(
                                    0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) ThreadProc,
                                    Cookie,
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            PrintToConsole("Foo: Error, couldn't create thread\n") ;
            RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
            }

        // wait for the other guy to finish
        TRACE(("Foo: Waiting...\n")) ;
        WaitForSingleObject(SyncEvent, INFINITE) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    if (Cookie && Cookie->Async.u.hEvent)
        {
        CloseHandle(Cookie->Async.u.hEvent) ;
        }
}


void
AsyncUsingAPC(
    RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    CALL_COOKIE Cookie ;
    int retval ;


    RpcTryExcept
        {
        CallFoo(Binding, &Cookie, RpcNotificationTypeApc, SizeIn, SizeOut) ;

        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie.BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}


void
AsyncUsingPolling(
    RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    CALL_COOKIE Cookie ;
    int retval ;


    RpcTryExcept
        {
        CallFoo(Binding, &Cookie, RpcNotificationTypeNone, SizeIn, SizeOut) ;

        while ((Status = RpcAsyncGetCallStatus(&Cookie.Async))
                    == RPC_S_ASYNC_CALL_PENDING)
            {
            Sleep(1) ;
            }

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie.BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}

///////////////////////////////////////////////////////////
// End, Application                                                         //
//////////////////////////////////////////////////////////

//
// The following routines outline the client side code for a simple async function
// using pipes.
//

#if 0
//
// Begin, Approximate idl file
//
interface FooInterface {
    typedef pipe int aysnc_intpipe ;

    int FooPipe (handle_t hBinding, [in] int checksum_in, [in] async_intpipe *inpipe,
                      [out] async_intpipe *outpipe, [out] int *checksum_out) ;
    } ;
// End, idl file

//
// Begin, corresponding acf file
//
interface FooInterface {
    [async] Foo () ;
    } ;
//
// End, acf file
//

//
// look at asyncstub.h for generated header
// file for function FooPipe
//
#endif

////////////////////////////////////////////////////////////
// Begin, stubs for FooPipe                                                //
////////////////////////////////////////////////////////////

// declare the async handle
typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    void *state ;
    async_intpipe outpipe ;
    int *checksum_out;
    } FOOPIPE_ASYNC_CLIENT_STATE, *FOOPIPE_ASYNC_CLIENT_HANDLE ;


#define ASYNC_CHUNK_SIZE 1000
#define ASYNC_NUM_CHUNKS 20


RPC_STATUS
PipeReceiveFunction (
    IN PRPC_ASYNC_STATE pAsync,
    IN int *buffer,
    IN int requested_count,
    IN int *actual_count
    )
/*++
Function Name:PipeReceiveFunction

Parameters:

Description:

Returns:

--*/
{
    int num_elements = 0;
    RPC_MESSAGE Callee ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo =
        (FOOPIPE_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;
    PIPE_STATE *state = &(StubInfo->StubState.PipeState);
    DWORD size = (DWORD) requested_count * state->PipeElementSize ;

    *actual_count = 0 ;

    if (state->EndOfPipe)
        {
        return RPC_S_OK;
        }

    I_RpcReadPipeElementsFromBuffer(
                                    state,
                                    (char *) buffer,
                                    size,
                                    &num_elements) ;
    *actual_count += num_elements ;
    size -= num_elements * state->PipeElementSize ;

    if (state->EndOfPipe == 0 &&
        num_elements < requested_count)
        {
        Callee.ProcNum = RPC_FLAGS_VALID_BIT ;
        Callee.Handle = StubInfo->StubState.CallHandle ;

        Callee.RpcFlags = RPC_BUFFER_PARTIAL | RPC_BUFFER_ASYNC ;
        if (num_elements)
            {
            Callee.RpcFlags |= RPC_BUFFER_NONOTIFY;
            }

        Callee.Buffer = 0 ;
        Callee.BufferLength = 0 ;

        Status = I_RpcReceive(&Callee, size) ;
        if (Status)
            {
            if (num_elements && Status == RPC_S_ASYNC_CALL_PENDING)
                {
                num_elements = 0 ;
                return RPC_S_OK;
                }

            if (Status != RPC_S_ASYNC_CALL_PENDING)
                {
                ApiError("PipePull", "I_RpcReceive", Status) ;
                }

            num_elements = 0 ;
            return Status;
            }

        state->Buffer = Callee.Buffer ;
        state->BufferLength = Callee.BufferLength ;
        state->CurPointer = (char *) Callee.Buffer ;
        state->BytesRemaining = Callee.BufferLength ;

        buffer = (pipe_element_t *)
                    ((char *) buffer + num_elements * state->PipeElementSize) ;

        num_elements = 0 ;
        I_RpcReadPipeElementsFromBuffer(
                                        state,
                                        (char *) buffer,
                                        size,
                                        &num_elements) ;
        *actual_count += num_elements ;
        }

    return RPC_S_OK;
}


RPC_STATUS
PipeSendFunction (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *context,
    IN int *buffer,
    IN int num_elements
    )
/*++

Routine Description:

 this function is always implemented by the stubs. This routine is called by
 the application, to send pipe data.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    unsigned int Flags = 0;
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo =
        (FOOPIPE_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;
    int calculated_length = num_elements * sizeof(int) + sizeof(int);
    char *ptr ;

    Message.ProcNum = FooPipeProcnum | HackForOldStubs;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        calculated_length += StubInfo->StubState.BufferLength ;
        }

    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcReallocPipeBuffer (&Message, calculated_length) ;
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    ptr = (char *) Message.Buffer ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        ptr += StubInfo->StubState.BufferLength ;
        }

    *((int *) ptr) = num_elements ;
    RpcpMemoryCopy(ptr+sizeof(int), buffer, num_elements *sizeof(int)) ;

    if (num_elements) // || !lastpipe
        {
        Message.RpcFlags = RPC_BUFFER_PARTIAL ;
        }
    else
        {
        // we are making a simplifying assumption
        // that there is a single [in] pipe.
        Message.RpcFlags = 0;
        }

    Message.RpcFlags |= RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus == RPC_S_OK)
        {
        StubInfo->StubState.State = SEND_COMPLETE ;
        }
    else if (RpcStatus == RPC_S_SEND_INCOMPLETE)
        {
        StubInfo->StubState.State = SEND_INCOMPLETE ;
        }
    else
        {
        return RpcStatus;
        }

    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;

    return RPC_S_OK;
}


RPC_STATUS
FooPipeComplete(
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:

    Stub for the completion routine of FooPipe

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS Status ;
    RPC_MESSAGE Message ;
    void *ptr ;
    int retval;
    UINT_PTR offset ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo =
        (FOOPIPE_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;

    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.PipeState.Buffer;
    Message.BufferLength = 0;

    if (StubInfo->StubState.PipeState.BytesRemaining < 8)
        {
        Message.RpcFlags = RPC_BUFFER_ASYNC|RPC_BUFFER_EXTRA;
        Status = I_RpcReceive(&Message, 8) ;
        if (Status)
            {
            return Status ;
            }
        // just being paranoid here. I didn't want an overflow.
        offset = StubInfo->StubState.PipeState.CurPointer
                - (char *) StubInfo->StubState.PipeState.Buffer ;
        ptr = (char *) Message.Buffer + offset ;
        }
    else
        {
        ptr = StubInfo->StubState.PipeState.CurPointer ;
        if (!ptr)
            {
            return RPC_S_OUT_OF_MEMORY ;
            }
        }


    *((int *) Reply) =  *((int *) ptr) ;
    *(StubInfo->checksum_out) = *(((int *) ptr)+1) ;

    I_RpcFreeBuffer(&Message) ;
    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}

int tempint ;


void
FooPipe (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int checksum_in,
    /* [in] */ async_intpipe *inpipe,
    /* [out] */ async_intpipe *outpipe,
    /* [out] */ int *checksum_out
    )
/*++

Routine Description:

    The stub routine for FooPipe function.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOPIPE_ASYNC_CLIENT_STATE *StubInfo ;

    StubInfo = (FOOPIPE_ASYNC_CLIENT_STATE *) I_RpcAllocate (
                        sizeof(FOOPIPE_ASYNC_CLIENT_STATE)) ;
    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->StubInfo = (void *) StubInfo ;

    StubInfo->StubState.CallHandle = hBinding ;

    Message.Handle = hBinding ;
    Message.BufferLength = 4 ;
    Message.ProcNum = FooPipeProcnum | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = RPC_BUFFER_ASYNC | RPC_BUFFER_PARTIAL ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // initialize the async handle and register it with the
    // RPC runtime.

    StubInfo->StubState.PipeState.Buffer = 0;
    StubInfo->StubState.PipeState.CurrentState = start;
    StubInfo->StubState.PipeState.CurPointer = 0;
    StubInfo->StubState.PipeState.BytesRemaining = 0;
    StubInfo->StubState.PipeState.EndOfPipe = 0;
    StubInfo->StubState.PipeState.PipeElementSize = sizeof(int);
    StubInfo->StubState.PipeState.PartialPipeElement = &tempint;
    StubInfo->StubState.PipeState.PreviousBuffer = 0;

    RpcStatus = I_RpcAsyncSetHandle(&Message, pAsync) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    *((int *) Message.Buffer) = checksum_in ;
    inpipe->PipeSend = PipeSendFunction ;
    outpipe->PipeReceive = PipeReceiveFunction;


    StubInfo->StubState.CompletionRoutine = FooPipeComplete ;
    StubInfo->checksum_out = checksum_out ;
    Message.RpcFlags = RPC_BUFFER_PARTIAL| RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus == RPC_S_OK)
        {
        StubInfo->StubState.State = SEND_COMPLETE ;
        }
    else if (RpcStatus == RPC_S_SEND_INCOMPLETE)
        {
        StubInfo->StubState.State = SEND_INCOMPLETE ;
        }
    else
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CallHandle = Message.Handle ;
    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;
}

////////////////////////////////////////////////////////////
// End, stubs for FooPipe                                                   //
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
// Begin, Application                                                          //
////////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STATE Async ;
    async_intpipe inpipe ;
    async_intpipe outpipe ;
    BOOL CallFinished ;
    BOOL PipeDataSent;
    int checksum_out;
    int PipeChecksum ;
    int PipeBuffer[ASYNC_CHUNK_SIZE] ;
    int ExpectedValue;
    int i ;
    } PIPE_CALL_COOKIE ;


int PipeCount = 0;


void
FooPipeAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description
--*/

{
    PIPE_CALL_COOKIE *Cookie = (PIPE_CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcSendComplete:
            if (Cookie->i % 7)
                {
                Sleep(10);
                }

            if (Cookie->i <ASYNC_NUM_CHUNKS)
                {
                Cookie->i++ ;
                Status = Cookie->inpipe.PipeSend(
                                                 pAsync,
                                                 0,
                                                 (int *) Cookie->PipeBuffer,
                                                 ASYNC_CHUNK_SIZE) ;
                }
            else
                {
                ASSERT(Cookie->PipeDataSent == 0);

                pAsync->Flags = 0;
                Status = Cookie->inpipe.PipeSend(
                                                 pAsync,
                                                 0, 0, 0) ;
                Cookie->PipeDataSent = 1;
                }

            if (Status != RPC_S_OK)
                {
                PrintToConsole("FooPipeAPCRoutine: PipeSend failed\n");
                IsabelleError();
                }
            break;

        case RpcCallComplete:
            Cookie->CallFinished = 1;
            OutstandingCalls-- ;
            break;
        }
}



void
CallFooPipe (
    RPC_BINDING_HANDLE Binding,
    PIPE_CALL_COOKIE *Cookie,
    RPC_NOTIFICATION_TYPES NotificationType
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int Checksum = 0;
    int n ;
    int *ptr ;

    Cookie->Async.Size = sizeof(RPC_ASYNC_STATE) ;
    Cookie->Async.UserInfo = (void *) Cookie ;

    Cookie->outpipe.state = 0;
    Cookie->inpipe.state = 0;

    Cookie->PipeChecksum = 0;
    Cookie->CallFinished = 0;
    Cookie->i = 0;
    Cookie->PipeDataSent = 0;
    Cookie->Async.Flags = 0;
    Cookie->Async.Lock = 0;
    Cookie->ExpectedValue = 0;

    switch (NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeEvent:
            Cookie->Async.NotificationType = RpcNotificationTypeEvent ;

            Cookie->Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;

            if (Cookie->Async.u.hEvent == 0)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            break;

        case RpcNotificationTypeApc:
            Cookie->Async.Flags = RPC_C_NOTIFY_ON_SEND_COMPLETE;
            Cookie->Async.NotificationType = RpcNotificationTypeApc ;
            Cookie->Async.u.APC.NotificationRoutine = FooPipeAPCRoutine ;
            Cookie->Async.u.APC.hThread = 0 ;
            break;

        default:
            PrintToConsole("Async: bad notification type\n") ;
            break;
        }

    ptr =  Cookie->PipeBuffer ;
    for (n = 0; n <ASYNC_CHUNK_SIZE; n++)
        {
        *ptr++ = n;
        Checksum += n ;
        }

    TRACE(("FooPipe: [in] Block checksum: %d\n", Checksum)) ;
    Checksum *= ASYNC_NUM_CHUNKS ;

    TRACE(("FooPipe: [in] Total checksum: %d\n", Checksum)) ;

    FooPipe(&(Cookie->Async),
                Binding,
                Checksum,
                &(Cookie->inpipe),
                &(Cookie->outpipe),
                &(Cookie->checksum_out)) ;
}


void
AsyncPipesUsingAPC(
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    Call the async function.

Arguments:

    Binding - Binding handle.
--*/

{
    RPC_STATUS Status ;
    PIPE_CALL_COOKIE *Cookie;
    int retval ;
    BOOL fDone = 0;
    int num_elements;
    int i;

    RpcTryExcept
        {
        Cookie = new PIPE_CALL_COOKIE ;

        if (Cookie == 0)
            {
            RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
            }

        CallFooPipe (Binding, Cookie, RpcNotificationTypeApc) ;

        while (Cookie->PipeDataSent == 0)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        while (!fDone)
            {
            Status = Cookie->outpipe.PipeReceive(
                                                  &(Cookie->Async),
                                                  (int *) Cookie->PipeBuffer,
                                                  ASYNC_CHUNK_SIZE,
                                                  &num_elements);
            switch (Status)
                {
                case RPC_S_ASYNC_CALL_PENDING:
                    if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                        {
                        RpcRaiseException(APP_ERROR) ;
                        }
                    break;

                case RPC_S_OK:
                    if (num_elements == 0)
                        {
                        fDone = 1;
                        }
                    else
                        {
                        for (i = 0; i <num_elements; i++)
                            {
                            Cookie->PipeChecksum += Cookie->PipeBuffer[i] ;
                            if (Cookie->PipeBuffer[i] != Cookie->ExpectedValue)
                                {
                                printf("pipe recv fn: elt %d contains %lx, expected %lx\n",
                                       i, Cookie->PipeBuffer[i], Cookie->ExpectedValue);
                                DebugBreak();
                                }

                            Cookie->ExpectedValue =
                                (Cookie->PipeBuffer[i]+1) % ASYNC_CHUNK_SIZE;
                            }
                        }
                    break;

                default:
                    fDone = 1;
                    break;
                }

            //
            // This code is for testing flow control
            //
            PipeCount++;
            if (PipeCount % 3)
                {
                Sleep(100);
                }
            }

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        while (Cookie->CallFinished == 0)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        Status = MyRpcCompleteAsyncCall(&Cookie->Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        if (Cookie->PipeChecksum != Cookie->checksum_out)
            {
            PrintToConsole("FooPipe: Checksum Error, expected: %d, checksum: %d\n",
                    Cookie->checksum_out, Cookie->PipeChecksum) ;
            RpcRaiseException(APP_ERROR) ;
            }
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("FooPipe: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    if (Cookie)
        {
        delete Cookie ;
        }
}


void
MultipleOutstandingCalls (
    IN RPC_BINDING_HANDLE Binding,
    IN int NumCalls
    )
/*++

Routine Description:

tests multiple outstanding calls and causal ordering

Arguments:

 Binding - Binding on which to make the calls
 NumCalls - Number of outstanding calls

--*/

{
    RPC_STATUS Status ;
    PIPE_CALL_COOKIE *PipeCookies;
    CALL_COOKIE *Cookies ;
    int retval ;
    int i ;
    int SizeIn, SizeOut ;

    RpcTryExcept
        {
        Cookies = new CALL_COOKIE[NumCalls] ;
        if (Cookies == 0)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        PipeCookies = new PIPE_CALL_COOKIE[NumCalls] ;

        if (PipeCookies == 0)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        OutstandingCalls = 0;

        SizeIn = 10;
        SizeOut = 10 ;

        for (i = 0; i < NumCalls; i++)
            {
            CallFoo(Binding, &Cookies[i], RpcNotificationTypeApc, SizeIn, SizeOut) ;

            SizeIn += 100 ;
            SizeOut+= 100 ;

            OutstandingCalls++ ;

            }

        while (OutstandingCalls)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        for (i = 0; i < NumCalls; i++)
            {
            Status = MyRpcCompleteAsyncCall(&Cookies[i].Async, &retval) ;
            if (Status != RPC_S_OK)
                {
                PrintToConsole("Call %d on handle %p returned %d\n",
                               i, &Cookies[i].Async, Status);
                continue;
                }

            TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

            if (retval != 1)
                {
                RpcRaiseException(APP_ERROR) ;
                }

            I_RpcFree(Cookies[i].BufferOut) ;
            }
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("MultipeOutstandingCalls: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept

    if (Cookies)
        {
        delete Cookies ;
        }

    if (PipeCookies)
        {
        delete PipeCookies ;
        }
}


void
SyncAsyncInterop (
    IN RPC_BINDING_HANDLE Binding,
    IN int SizeIn,
    IN int SizeOut
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int retval ;
    int *bufferout ;
    int *bufferin ;

    RpcTryExcept
        {
        bufferin = (int *) I_RpcAllocate(SizeIn) ;
        if (bufferin == 0)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        // sync client,  async server
        retval = FooSync (Binding, SizeIn, bufferin, &SizeOut, &bufferout) ;
        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(bufferout) ;

        // ugly hack alert
        FooProcnum = 18 ;

        // async client, sync server (calling FooBar)
        AsyncUsingAPC(Binding, SizeIn, SizeOut) ;

        FooProcnum = 16 ;

        // sync client, async server using pipes

        // async client, sync server using pipes
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("SyncAsyncInterop: Exception 0x%lX\n", GetExceptionCode()) ;
        IsabelleError() ;
        }
    RpcEndExcept
}

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    } else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}


DWORD
AddServicePrivToAccount(
    LPWSTR MachineName,
    LPWSTR pAccount
)
/*++

Routine Description:

    Enables the appropriate privileges for the cluster account and
    sets up the cluster service to run in the specified account.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LSA_HANDLE PolicyHandle;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    NTSTATUS Status;

    WCHAR domain[MAX_PATH];

    PSID         pSid;
    SID_NAME_USE sidType;
    DWORD        nBytes;
    DWORD        maxDomain;


    if (MachineName != NULL) {
        InitLsaString(&ServerString, MachineName);
        Server = &ServerString;
    }

    PrintToConsole("Machine: %ls, Account: %ls.\n",MachineName,pAccount);

    nBytes=0;
    maxDomain=MAX_PATH*sizeof(WCHAR);

    if (LookupAccountName(MachineName,pAccount,NULL,&nBytes,
                          domain,&maxDomain,&sidType))
    {
        PrintToConsole("AddServicePrivToAccount: LookupAccountName(NULL) failed.\n");
        return ERROR_INVALID_PARAMETER;
    }

    pSid=LocalAlloc(LPTR,nBytes);
    if (NULL == pSid)
    {
        PrintToConsole("AddServicePrivToAccount: LocalAlloc failed.\n");
        return GetLastError();
    }

    if (!LookupAccountName(MachineName,pAccount,pSid,&nBytes,
                           domain,&maxDomain,&sidType))
    {
        PrintToConsole(
                  "AddServicePrivToAccount: LookupAccountName(%ls) failed.\n",
                  pAccount);
        return GetLastError();
    }

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    //
    // Attempt to open the local policy.
    //
    Status = LsaOpenPolicy(Server,
                           &ObjectAttributes,
                           POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                           &PolicyHandle);
    if (MachineName != NULL) {
        if (!NT_SUCCESS(Status)) {
            //
            // We could not contact the PDC to configure the service account.
            // Put up a nice informative popup and let the user run setup
            // again when the PDC is back.
            //
            PrintToConsole("AddServicePrivToAccount: LsaOpenPolicy failed.\n");
            return(Status);
        }
    } else {
        if (!NT_SUCCESS(Status)) {
            PrintToConsole(
                      "AddServicePrivToAccount: LsaOpenPolicy failed 2.\n");
            return(Status);
        }
    }

    //
    // Add the SeTcbPriviledge
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_TCB_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(tcb).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the SeServiceLogonRight
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_SERVICE_LOGON_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(logon).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the SeBackupPrivilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_BACKUP_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(backup).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the SeRestorePrivilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_RESTORE_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(restore).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the lock memory privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_LOCK_MEMORY_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(memory).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the increase quota privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_INCREASE_QUOTA_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(quota).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the load driver privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_LOAD_DRIVER_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(driver).\n");
        goto AddServicePrivToAccount_Bail;
    }

    //
    // Add the increase base priority privilege
    //
    Status = SetPrivilegeOnAccount(PolicyHandle,
                                   pSid,
                                   SE_INC_BASE_PRIORITY_NAME,
                                   TRUE);
    if (!NT_SUCCESS(Status)) {
        PrintToConsole(
                  "AddServicePrivToAccount: SetPrivilegeOnAccount(priority)\n");
        goto AddServicePrivToAccount_Bail;
    }


    Status=ERROR_SUCCESS;

AddServicePrivToAccount_Bail:

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    return(Status);
}


void
AsyncSecurity (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    HANDLE hToken;
    WCHAR FullName[512];

    wsprintf((PWSTR) &FullName[0], L"%hs\\%hs", SecurityDomain, SecurityUser);

    AddServicePrivToAccount(L"", &FullName[0]);

    while (1)
        {
        if (LogonUserA(SecurityUser, SecurityDomain, SecurityPassword,
                   LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &hToken) == 0)
            {
            PrintToConsole("LogonUser failed: %d\n", GetLastError());
            break;
            }

        ImpersonateLoggedOnUser(hToken);
        // set auth info to various levels
        // and impersonate on the server
        Status = RpcBindingSetAuthInfo(Binding, NULL, RPC_C_AUTHN_DEFAULT,
                                       RPC_C_AUTHN_WINNT, NULL, NULL);

        AsyncUsingAPC(Binding, 20, 20);
        CloseHandle(hToken);
        }
}

void
AsyncSecurityThreads()
{
    int i;
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    RPC_BINDING_HANDLE Binding;
    UUID ObjectUuid;
    GenerateUuidValue(UUID_TEST_CANCEL, &ObjectUuid);

    for (i = 0; i<3; i++)
        {
        Status = GetBinding(BARTHOLOMEW, &Binding);
        if (Status)
            {
            ApiError("Async", "GetBinding", Status);
            PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
            return;
            }

        Status = RpcBindingSetObject(Binding, &ObjectUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        HandleToThread = CreateThread(
                                    0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) AsyncSecurity,
                                    Binding,
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            PrintToConsole("AsyncSecurity: Error, couldn't create thread\n") ;
            IsabelleError();
            return;
            }
        CloseHandle(HandleToThread);
        }

    Status = GetBinding(BARTHOLOMEW, &Binding);
    if (Status)
        {
        ApiError("Async", "GetBinding", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

    Status = RpcBindingSetObject(Binding, &ObjectUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to Set Object\n");
        return;
        }

    AsyncSecurity(Binding);
}




void
AsyncExceptions (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    BOOL ExceptionOccured ;
    int ExceptionCode ;
    UUID SavedUuid;
    UUID ExceptionUuid;

    //
    // object UUID is used to control server-side exceptions: save the original one.
    //
    Status = RpcBindingInqObject(Binding, &SavedUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingInqObject", Status);
        PrintToConsole("Async : FAIL - Unable to save original object UUID\n");
        return;
        }

    // test sync exceptions (async server)
    RpcTryExcept
        {
        ExceptionOccured = 0;
        ExceptionCode = 0;

        GenerateUuidValue(UUID_SYNC_EXCEPTION, &ExceptionUuid);
        Status = RpcBindingSetObject(Binding, &ExceptionUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        AsyncUsingAPC(Binding, 0, 10) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionOccured = 1;
        ExceptionCode = GetExceptionCode() ;
        }
    RpcEndExcept

    if (ExceptionOccured == 0
        || ExceptionCode != SYNC_EXCEPT)
        {
        PrintToConsole("Async: wrong exception value 0x%x\n", ExceptionCode );
        IsabelleError() ;

        Status = RpcBindingSetObject(Binding, &SavedUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to restore original object UUID\n");
            }

        return ;
        }

    // test sync exceptions (sync server)
    RpcTryExcept
        {
        ExceptionOccured = 0;
        ExceptionCode = 0;

        // ugly hack alert
        FooProcnum = 18 ;

        GenerateUuidValue(UUID_SYNC_EXCEPTION, &ExceptionUuid);
        Status = RpcBindingSetObject(Binding, &ExceptionUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        // async client, sync server (calling FooBar)
        AsyncUsingAPC(Binding, 0, 10) ;

        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionOccured = 1;
        ExceptionCode = GetExceptionCode() ;
        }
    RpcEndExcept

    FooProcnum = 16 ;

    if (ExceptionOccured == 0
        || ExceptionCode != SYNC_EXCEPT)
        {
        PrintToConsole("Async: wrong exception value 0x%x\n", ExceptionCode );
        IsabelleError() ;

        Status = RpcBindingSetObject(Binding, &SavedUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to restore original object UUID\n");
            }

        return ;
        }

    // test async exceptions
    RpcTryExcept
        {
        ExceptionOccured = 0;
        ExceptionCode = 0;

        GenerateUuidValue(UUID_ASYNC_EXCEPTION, &ExceptionUuid);
        Status = RpcBindingSetObject(Binding, &ExceptionUuid);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetObject", Status);
            PrintToConsole("Async : FAIL - Unable to Set Object\n");
            return;
            }

        AsyncUsingAPC(Binding, 10, 0) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionOccured = 1;
        ExceptionCode = GetExceptionCode() ;
        }
    RpcEndExcept

    if (ExceptionOccured == 0
        || ExceptionCode != ASYNC_EXCEPT)
        {
        PrintToConsole("Async: wrong exception value 0x%x\n", ExceptionCode );
        IsabelleError() ;
        }

    Status = RpcBindingSetObject(Binding, &SavedUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to restore original object UUID\n");
        }
}

////////////////////////////////////////////////////////////
// Begin, stubs for FooCH                                                      //
////////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    void *state ;
    int *sizeout ;
    int **bufferout ;
    } FOOCH_ASYNC_CLIENT_STATE;


RPC_STATUS
FooCHComplete(
    IN PRPC_ASYNC_STATE pAsync,
    OUT void *Reply
    )
/*++

Routine Description:

    The completion routine corresponding to the function Foo. This routine
    is called to get the out parameters from an async function.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    RPC_STATUS Status ;
    RPC_MESSAGE Message ;
    int *ptr ;
    FOOCH_ASYNC_CLIENT_STATE *StubInfo =
               (FOOCH_ASYNC_CLIENT_STATE *) pAsync->StubInfo ;

    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength ;
    Status = I_RpcReceive(&Message, 0) ;
    if (Status)
        {
        return Status ;
        }

    ptr = (int *) Message.Buffer ;

    *((int *) Reply) = *ptr++ ;
    *(StubInfo->sizeout) = *ptr++ ;

    *(StubInfo->bufferout) = (int *) I_RpcAllocate(*(StubInfo->sizeout)) ;
    if (*(StubInfo->bufferout) == 0)
        {
        return RPC_S_OUT_OF_MEMORY ;
        }

    RpcpMemoryCopy(*(StubInfo->bufferout), ptr, *(StubInfo->sizeout)) ;

    I_RpcFreeBuffer(&Message) ;
    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}


void
FooCH (
    PRPC_ASYNC_STATE pAsync,
    /* [in] */ void PAPI *ContextHandle,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    )
/*++

Routine Description:

    Client stub for function FooCH.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/

{
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOCH_ASYNC_CLIENT_STATE *StubInfo ;
    int *Ptr ;

    StubInfo = (FOOCH_ASYNC_CLIENT_STATE *) I_RpcAllocate (
                        sizeof(FOOCH_ASYNC_CLIENT_STATE)) ;
    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->StubInfo = (void *) StubInfo ;

    StubInfo->StubState.CallHandle = NDRCContextBinding(ContextHandle) ;

    Message.Handle =  StubInfo->StubState.CallHandle;
    Message.BufferLength = 20+8+sizein+(sizein%4) ;
    Message.ProcNum = 19 | HackForOldStubs | RPC_FLAGS_VALID_BIT ;
    Message.RpcInterfaceInformation = &IsabelleInterfaceInformation ;
    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // marshal ;-)
    Ptr = (int *) Message.Buffer ;

    NDRCContextMarshall(ContextHandle, Ptr) ;

    Ptr += 20 / sizeof(int) ;

    *Ptr++ = sizein ;

    RpcpMemoryCopy(Ptr, bufferin, sizein) ;

    Ptr += (sizein+3)/sizeof(int) ;

    *Ptr = *sizeout ;

    StubInfo->StubState.Flags = 0;
    StubInfo->sizeout = sizeout ;
    StubInfo->bufferout = bufferout ;

    RpcStatus = I_RpcAsyncSetHandle(&Message, (PRPC_ASYNC_STATE) pAsync) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CompletionRoutine = FooCHComplete ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    StubInfo->StubState.CallHandle = Message.Handle ;
    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;
    // return to the app
}

typedef struct {
    RPC_ASYNC_STATE Async ;
    int SizeOut ;
    int *BufferOut ;
    BOOL CallFinished ;
    void PAPI *ContextHandle ;
    } FOOCH_CALL_COOKIE ;

void
FooCHAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    FOOCH_CALL_COOKIE *Cookie = (FOOCH_CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcCallComplete:
            Cookie->CallFinished = 1;
            OutstandingCalls--;
            break;
        }
}



void
CallFooCH (
    RPC_BINDING_HANDLE BindingHandle,
    FOOCH_CALL_COOKIE *Cookie,
    RPC_NOTIFICATION_TYPES NotificationType,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int *BufferIn ;
    unsigned long ContextUuid[5];

    Cookie->ContextHandle = 0;
    ContextUuid[0] = 0;
    ContextUuid[1] = 1;
    ContextUuid[2] = 2;
    ContextUuid[3] = 3;
    ContextUuid[4] = 4;

    NDRCContextUnmarshall(&(Cookie->ContextHandle),
                                       BindingHandle,
                                       ContextUuid,
                                       0x00L | 0x10L | 0x0000L);

    BufferIn = (int *) new char[SizeIn] ;
    if (BufferIn == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    Cookie->SizeOut = SizeOut ;
    Cookie->Async.Size = sizeof(RPC_ASYNC_STATE) ;
    Cookie->Async.Flags = 0;
    Cookie->Async.Lock = 0;
    Cookie->Async.NotificationType = NotificationType ;

    switch (NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeEvent:
            Cookie->Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
            if (Cookie->Async.u.hEvent == 0)
                {
                RpcRaiseException(APP_ERROR) ;
                }

            Cookie->Async.NotificationType = RpcNotificationTypeEvent ;
            break;

        case RpcNotificationTypeApc:
            Cookie->Async.NotificationType = RpcNotificationTypeApc ;
            Cookie->Async.u.APC.NotificationRoutine = FooCHAPCRoutine ;
            Cookie->Async.u.APC.hThread = 0;
            Cookie->CallFinished = 0;
            break;

        default:
            PrintToConsole("Async: bad notification type\n") ;
            break;
        }

    Cookie->Async.UserInfo = (void *) Cookie ;

    // call the async function
    // the buffers supplied for the [out] and the [in, out] params
    // should be valid until the logical RPC call has completed.
    FooCH(&Cookie->Async,
          Cookie->ContextHandle,
          SizeIn,
          BufferIn,
          &Cookie->SizeOut,
          &Cookie->BufferOut) ;

    delete BufferIn ;
}


void
ContextHandles(
    RPC_BINDING_HANDLE Binding,
    int SizeIn,
    int SizeOut
    )
/*++

Routine Description:
    The code that calls the async function.

Arguments:

 Binding - the binding handle.

--*/

{
    RPC_STATUS Status ;
    FOOCH_CALL_COOKIE Cookie ;
    int retval ;

    RpcTryExcept
        {
        CallFooCH(Binding, &Cookie, RpcNotificationTypeApc, SizeIn, SizeOut) ;

        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        if (retval != 1)
            {
            RpcRaiseException(APP_ERROR) ;
            }

        RpcSsDestroyClientContext(&(Cookie.ContextHandle));
        if ( Cookie.ContextHandle != 0 )
            {
            PrintToConsole("Async : ContextHandle != 0\n");
            RpcRaiseException(APP_ERROR) ;
            }

        I_RpcFree(Cookie.BufferOut) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("FooCH: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}

int AsyncSizes[] =
 {
 20, 100, 256, 1024, 10000, 100000
 } ;

#define CHECK_ERRORS \
    if (IsabelleErrors != 0)\
        {\
        PrintToConsole("Async : FAIL - Error(s) in Isabelle");\
        PrintToConsole(" Interface\n");\
        IsabelleShutdown(Async);\
        IsabelleErrors = 0;\
        return;\
        }

void
PingServer (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 4 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation ;
    Caller.RpcFlags = 0;

    if (UclntGetBuffer(&Caller) != RPC_S_OK)
        {
        IsabelleError();
        return ;
        }

    if (UclntSendReceive(&Caller) != RPC_S_OK)
        {
        IsabelleError();
        return;
        }

    if (I_RpcFreeBuffer(&Caller) != RPC_S_OK)
        {
        IsabelleError();
        }
}

long PendingCalls;

void
AsyncPingProc(
    IN PRPC_MESSAGE Message
    )
{
    if (UclntSendReceive(Message) != RPC_S_OK)
        {
        IsabelleError();
        InterlockedDecrement(&PendingCalls);

        return;
        }

    InterlockedDecrement(&PendingCalls);
}

void
AsyncPingServer (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller[20];
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    int i;

    for (i = 0; i <20; i++)
        {
        Caller[i].Handle = Binding;
        Caller[i].BufferLength = 0;
        Caller[i].ProcNum = 4 | HackForOldStubs ;
        Caller[i].RpcInterfaceInformation = &HelgaInterfaceInformation ;
        Caller[i].RpcFlags = 0;

        if (UclntGetBuffer(&Caller[i]) != RPC_S_OK)
            {
            IsabelleError();
            return ;
            }
        }

    PendingCalls = 20;
    for (i = 0; i<20; i++)
        {
        HandleToThread = CreateThread(
                                    0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) AsyncPingProc,
                                    &Caller[i],
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            PrintToConsole("AsyncPingServer: Error, couldn't create thread\n") ;
            IsabelleError();
            return;
            }
        }

    while (PendingCalls)
        {
        Sleep(1000);
        }

    for (i = 0; i < 20; i++)
        {
        if (I_RpcFreeBuffer(&Caller[i]) != RPC_S_OK)
            {
            IsabelleError();
            }
        }
}


void
AsyncCancels (
    IN RPC_BINDING_HANDLE Binding
    )
{
    RPC_STATUS Status ;
    CALL_COOKIE Cookie ;
    int retval ;


    RpcTryExcept
        {
        //
        // Test non abortive cancels
        //
        CallFoo(Binding, &Cookie, RpcNotificationTypeApc, 20, 20) ;

        Sleep(10);

        //
        // non abortive cancel
        //
        Status = RpcAsyncCancelCall(&Cookie.Async, 0);
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }


        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;

        //
        // Test abortive cancels
        //
        CallFoo(Binding, &Cookie, RpcNotificationTypeApc, 20, 20) ;

        Sleep(10);

        //
        // Abortive cancel
        //
        Status = RpcAsyncCancelCall(&Cookie.Async, 1);
        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        WaitForReply(&(Cookie.CallFinished));

        Status = MyRpcCompleteAsyncCall(&Cookie.Async, &retval) ;
        if (Status != RPC_S_CALL_CANCELLED)
            {
            RpcRaiseException(Status) ;
            }

        TRACE(("Async: MyRpcCompleteAsyncCall returned %d\n", retval)) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Foo: Exception 0x%lX\n", GetExceptionCode()) ;

        Status = GetExceptionCode() ;
        if (Status == SYNC_EXCEPT
           || Status == ASYNC_EXCEPT)
           {
           RpcRaiseException(Status) ;
           }
       else
           {
           IsabelleError() ;
           }
        }
    RpcEndExcept
}

#define LAST 15

extern void
AsyncAll (
        void
        )
/*++

Routine Description:
    Loop through all Async tests.

--*/
{
        int i;
        for( i = 0; i < LAST; i ++)
                {
                Async(i);
                }
}


void
Async (
    int testnum
    )
/*++

Routine Description:
    Invoke the tests.

--*/
{
    int i ;
    UUID ObjectUuid;
    UUID CancelUuid;
    RPC_BINDING_HANDLE Async;
    RPC_BINDING_HANDLE AsyncBind;

    if (testnum > LAST)
        {
        PrintToConsole("Async tests:\n") ;
        PrintToConsole("0: Run all the tests\n") ;
        PrintToConsole("1: Async using APCs, events and polling\n") ;
        PrintToConsole("2: Async pipes using events\n") ;
        PrintToConsole("3: Async pipes using APC, and flow control\n") ;
        PrintToConsole("4: Async with security\n") ;
        PrintToConsole("5: Sync and async exceptions\n") ;
        PrintToConsole("6: Multiple outstanding calls and causal ordering\n") ;
        PrintToConsole("7: Context handles\n") ;
        PrintToConsole("8: Sync/Async interop\n") ;
        PrintToConsole("9: Async ping server") ;
        PrintToConsole("10: Alter context during async calls\n") ;
        PrintToConsole("11: Async cancels\n") ;
        PrintToConsole("12: Multiple outstanding non causal calls\n") ;
        PrintToConsole("13: Rebinds on secure calls with uuids\n") ;
        NumberOfTestsRun++ ;
        return ;
        }

    Synchro(BARTHOLOMEW) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Async : Test Async RPC\n");

    Status = GetBinding(BARTHOLOMEW, &Async);
    if (Status)
        {
        ApiError("Async", "GetBinding", Status);
        PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
        return;
        }

#if 0
    PingServer(Async);
    CHECK_ERRORS;
#endif

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError("Async", "CreateEvent", Status);
        return;
        }

    GenerateUuidValue(UUID_TEST_CANCEL, &ObjectUuid);
    Status = RpcBindingSetObject(Async, &ObjectUuid);
    if (Status)
        {
        ApiError("Async", "RpcBindingSetObject", Status);
        PrintToConsole("Async : FAIL - Unable to Set Object\n");
        return;
        }

    if (fNonCausal)
        {
        Status = RpcBindingSetOption(Async,
                                 RPC_C_OPT_BINDING_NONCAUSAL,
                                 1);
        if (Status)
            {
            ApiError("Async", "RpcBindingSetOption", Status);
            PrintToConsole("Async : FAIL - Unable to Set Option\n");
            return;
            }
        }

    switch (testnum)
        {
        case 0:
        case 1:
            PrintToConsole("Async: Testing async using APCs, events and polling\n") ;
            for (i = 0; i < sizeof(AsyncSizes)/sizeof(int); i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;

                AsyncUsingEvent(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;

                AsyncUsingPolling(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }
            if (testnum != 0)
                {
                break;
                }

        case 2:
            PrintToConsole("Async: Testing async pipes using events\n") ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 3:
            PrintToConsole("Async: Testing async async pipes using APC, and flow control\n") ;
            AsyncPipesUsingAPC(Async) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 4:
            if (testnum != 0)
                {
                PrintToConsole("Async: Testing security\n") ;
                AsyncSecurityThreads() ;
                CHECK_ERRORS;
                break;
                }

        case 5:
            PrintToConsole("Async: Testing sync and async exceptions\n") ;
            AsyncExceptions(Async) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 6:
            PrintToConsole("Async: Testing multiple outstanding calls and causal ordering\n") ;
            MultipleOutstandingCalls(Async, 20) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 7:
            PrintToConsole("Async: Testing context handles\n") ;
            ContextHandles(Async, 20, 20) ;
            if (testnum != 0)
                {
                break;
                }

        case 8:
            PrintToConsole("Async: Testing Sync/Async interop\n") ;
            for (i = 0; i < sizeof(AsyncSizes)/sizeof(int); i++)
                {
                SyncAsyncInterop(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }
            if (testnum != 0)
                {
                break;
                }

        case 9:
            AsyncPingServer(Async);

            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 10:
            //
            // make a few calls on the Isabelle interface
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }

            FooProcnum = 7;
            FooInterface = &HelgaInterfaceInformation;

            //
            // make a few calls on the helga interface
            // this should cause an alter context
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }


            FooProcnum = 16;
            FooInterface = &IsabelleInterfaceInformation;
            //
            // make a few calls on the Isabelle interface
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }

            if (testnum != 0)
                {
                break;
                }

        case 11:
            PrintToConsole("Async: Test async cancels\n");

            GenerateUuidValue(UUID_SLEEP_1000, &ObjectUuid);
            Status = RpcBindingSetObject(Async, &ObjectUuid);
            if (Status)
                {
                ApiError("Async", "RpcBindingSetObject", Status);
                PrintToConsole("Async : FAIL - Unable to Set Object\n");
                return;
                }

            AsyncCancels(Async);
            CHECK_ERRORS;

            if (testnum != 0)
                {
                break;
                }

        case 12:
            PrintToConsole("Async: Testing multiple outstanding calls and causal ordering\n") ;

            Status = RpcBindingSetOption(Async, RPC_C_OPT_BINDING_NONCAUSAL, TRUE);
            if (Status)
              {
              ApiError("Async", "RpcBindingSetOption", Status);
              return;
              }

            MultipleOutstandingCalls(Async, 20) ;
            CHECK_ERRORS;
            if (testnum != 0)
                {
                break;
                }

        case 13:
            RpcBindingFree(&Async);
            Status = GetBinding(BARTHOLOMEW, &Async);
            if (Status)
                {
                ApiError("Async", "GetBinding", Status);
                PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
                return;
                }

            PrintToConsole("Async: Bind and async calls\n") ;
            for (i = 0; i < 10; i++)
                {
                Status = GetBinding(BARTHOLOMEW, &AsyncBind);
                if (Status)
                    {
                    ApiError("Async", "GetBinding", Status);
                    PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
                    return;
                    }

                Status = RpcBindingSetObject(AsyncBind, &ObjectUuid);
                if (Status)
                    {
                    ApiError("Async", "RpcBindingSetObject", Status);
                    PrintToConsole("Async : FAIL - Unable to Set Object\n");
                    return;
                    }

                Status = RpcBindingSetAuthInfoA(AsyncBind,
                                               (unsigned char *) "ServerPrincipal",
                                               RPC_C_AUTHN_LEVEL_CONNECT,
                                               10,
                                               NULL,
                                               0);
                if (Status)
                    {
                    ApiError("Async", "RpcBindingSetAuthInfo", Status);
                    PrintToConsole("Async : FAIL - Unable to Set AuthInfo\n");
                    return;
                    }

                AsyncUsingAPC(AsyncBind, 10, 10) ;
                CHECK_ERRORS;
                RpcBindingFree(&AsyncBind);
                }
            if (testnum != 0)
                {
                break;
                }

        case 14:

            Status = GetBinding(BARTHOLOMEW, &Async);
            if (Status)
                {
                ApiError("Async", "GetBinding", Status);
                PrintToConsole("Async : FAIL - Unable to Bind (Async)\n");
                return;
                }

            FooProcnum = 7;
            FooInterface = &HelgaInterfaceInformation;

            //
            // make a few calls on the helga interface
            // this should cause an alter context
            //
            for (i=0; i<3; i++)
                {
                AsyncUsingAPC(Async, AsyncSizes[i], AsyncSizes[i]) ;
                CHECK_ERRORS;
                }
            if (testnum != 0)
                {
                break;
                }
        case LAST:
            PrintToConsole("hacked-up test\n");

            GenerateUuidValue(UUID_SLEEP_2000, &ObjectUuid);
            Status = RpcBindingSetObject(Async, &ObjectUuid);
            if (Status)
                {
                ApiError("Async", "RpcBindingSetObject", Status);
                PrintToConsole("Async : FAIL - Unable to Set Object\n");
                return;
                }

            AsyncUsingEvent( Async, 100, 100 );

            if (testnum != 0)
                {
                break;
                }

        default:
            PrintToConsole("Async tests:\n") ;
            PrintToConsole("0: Run all the tests\n") ;
            PrintToConsole("1: Async using APCs, events and polling\n") ;
            PrintToConsole("2: Async pipes using events\n") ;
            PrintToConsole("3: Async pipes using APC, and flow control\n") ;
            PrintToConsole("4: Async with security\n") ;
            PrintToConsole("5: Sync and async exceptions\n") ;
            PrintToConsole("6: Multiple outstanding calls and causal ordering\n") ;
            PrintToConsole("7: Context handles\n") ;
            PrintToConsole("8: Sync/Async interop\n") ;
            PrintToConsole("9: Async ping server") ;
            PrintToConsole("10: Alter context during async calls\n") ;
            PrintToConsole("11: Async cancels\n") ;
            PrintToConsole("12: Multiple outstanding non causal calls\n") ;
            PrintToConsole("13: Rebinds on secure calls with uuids\n") ;
            NumberOfTestsRun++ ;
            return ;
            break;
        }

    if (Async)
        {
        IsabelleShutdown(Async);
        }

    CHECK_ERRORS;

    CloseHandle(SyncEvent) ;

    RpcBindingFree(&Async);

    PrintToConsole("Async : PASS\n");
}

//
// datagram SendAck test data
//
#include "dgpkt.hxx"


typedef DWORD
(RPCRTAPI RPC_ENTRY *SET_TEST_HOOK_FN)(
                    RPC_TEST_HOOK_ID id,
                    RPC_TEST_HOOK_FN fn
                    );

SET_TEST_HOOK_FN SetTestHookFn;

PVOID ChosenConnection;

RPC_TEST_HOOK_ID BasicHookId;

void
BasicPokeEventFn(
    RPC_TEST_HOOK_ID id,
    PVOID arg1,
    PVOID arg2
    )
{
    PrintToConsole("PokeEventFn: conn = %p, setting the sync event\n", arg1);
    SetEvent( SyncEvent );
}

void BasicSendAckTest(
    int Hook
    )
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    ChosenConnection = 0;

    Status = GetBinding(BARTHOLOMEW, &binding);
    if (Status)
        {
        ApiError("SendAck", "GetBinding", Status);
        PrintToConsole("SetAsync : FAIL - Unable to Bind \n");
        return;
        }

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError("SendAck", "CreateEvent", Status);
        return;
        }

    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("SendAck","GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("SendAck", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        if (GetLastError() == ERROR_PROC_NOT_FOUND)
            {
            PrintToConsole("you need to recompile with -DRPC_ENABLE_TEST_HOOKS\n");
            }
        return;
        }

    BasicHookId = MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, Hook );

    (*SetTestHookFn)( BasicHookId, BasicPokeEventFn );

    // make first call
    //
    PrintToConsole("SendAck: first call...\n") ;
    Helga( binding );

    // wait for the ACK to complete
    //
    TRACE(("SendAck: Waiting...\n")) ;
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // make second call
    //
    PrintToConsole("SendAck: second call...\n") ;
    Helga( binding );

    // clear the hook
    //
    (*SetTestHookFn)( BasicHookId, 0 );

    PrintToConsole("PASS\n");
}


void
Test5EventFn(
    RPC_TEST_HOOK_ID id,
    PVOID arg1,
    PVOID arg2
    )
{
    // release the app thread to make calls
    //
    PrintToConsole("PokeEventFn: conn = %p, setting the sync event\n", arg1);
    SetEvent( SyncEvent );

    // wait for it to finish
    //
    WaitForSingleObject(SyncEvent, INFINITE);
    PrintToConsole("PokeEventFn: signalled\n");
}

void AckTest5()
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    ChosenConnection = 0;

    Status = GetBinding(BARTHOLOMEW, &binding);
    if (Status)
        {
        ApiError("SendAck", "GetBinding", Status);
        PrintToConsole("SetAsync : FAIL - Unable to Bind \n");
        return;
        }

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError("SendAck", "CreateEvent", Status);
        return;
        }

    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("SendAck","GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("SendAck", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        if (GetLastError() == ERROR_PROC_NOT_FOUND)
            {
            PrintToConsole("you need to recompile with -DRPC_ENABLE_TEST_HOOKS\n");
            }
        return;
        }

    // set hook for beginning of procedure
    //
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 1 ), Test5EventFn );

    // make first call
    //
    PrintToConsole("SendAck: first call, will cause a delayed ACK\n") ;
    Helga( binding );

    // wait for the ACK to start
    //
    TRACE(("SendAck: Waiting...\n")) ;
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // make a couple of calls
    //
    PrintToConsole("SendAck: second call, completes quickly\n") ;
    Helga( binding );

    PrintToConsole("SendAck: third call, completes quickly\n") ;
    Helga( binding );

    // clear the hook and add one for the end of the ACK proc.
    //
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 1 ), 0 );
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 6 ), BasicPokeEventFn );

    // release the ACK thread
    PrintToConsole("SendAck: releasing orphaned delayed-ACK call and waiting for completion\n") ;
    SetEvent( SyncEvent );
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // make a couple of calls
    //
    PrintToConsole("SendAck: first post-ACK call...\n") ;
    Helga( binding );

    PrintToConsole("SendAck: second post-ACK call...\n") ;
    Helga( binding );

    // wait for the ACK to finish
    //
    TRACE(("SendAck: waiting for delayed ACK to complete\n")) ;
    WaitForSingleObject(SyncEvent, INFINITE) ;

    // clear the hook.
    //
    (*SetTestHookFn)( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 6 ), 0 );

    PrintToConsole("PASS\n");
}


void
SendAck (
    int testnum
    )
{
    switch (testnum)
        {
        default:
            {
            PrintToConsole("unknown send-ack case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n"
                           "\n"
                           "    1 - make 2nd call after delayed-ACK proc has finished\n"
                           "    2 - make 2nd call before ACK proc can take connection mutex\n"
                           "    3 - make 2nd call just after ACK proc takes conn mutex\n"
                           "    4 - make 2nd call after ACK proc decrements AckPending\n"
                           "    5 - ACK proc blocks just before taking mutex - other calls proceed.\n"
                           );
            return;
            }

        case 0:
            {
            PrintToConsole("SendAck: testing each case\n");

            // no break here
            }

        case 1:
            {
            //
            // 1. thread makes one call
            // 2. ACK is sent
            // 3. thread makes second call
            //
            PrintToConsole("case 1 - make 2nd call after delayed-ACK proc has finished\n");

            BasicSendAckTest( 6 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 2:
            {
            // 1. thread makes a call
            // 2. ACK proc is launched but has not yet taken mutex
            // 3. thread makes second call
            PrintToConsole("case 2 - make 2nd call before ACK proc can take connection mutex\n");

            BasicSendAckTest( 1 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 3:
            {
            // 1. thread makes a call
            // 2. ACK proc is launched, takes connection mutex
            // 3. thread makes second call
            PrintToConsole("case 3 - make 2nd call just after ACK proc takes conn mutex\n");

            BasicSendAckTest( 2 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 4:
            {
            // 1. thread makes a call
            // 2. ACK proc is launched, sends ACK, decrements AckPending
            // 3. thread makes second call
            PrintToConsole("case 4 - make 2nd call after ACK proc decrements AckPending\n");

            BasicSendAckTest( 4 );

            if (testnum != 0)
                {
                break;
                }
            }

        case 5:
            {
            // 1. make a call, and wait for the ACK.
            // 3, ACK proc runs in delayed-proc thread , and signals the first thread
            // 4. first thread makes a couple of calls, calling CancelDelayedAck several times.
            // 5. ACK proc finishes.
            // 6. Make anther call, and wait for the ACK.
            // 6. Make anther call, and wait for the ACK.
            PrintToConsole("case 5 - test orphaned ACK proc handling");

            AckTest5();

            if (testnum != 0)
                {
                break;
                }
            }
        }
}

void
SendErrorHook(
    RPC_TEST_HOOK_ID id,
    PVOID arg1,
    PVOID arg2
    )
{
    ASSERT( id == TH_X_DG_SEND );

    NCA_PACKET_HEADER * header = (NCA_PACKET_HEADER *) arg1;
    DWORD * pStatus = (DWORD *) arg2;

    TRACE(("SendErrorHook called: pkt type %d, serial %d\n", header->PacketType, header->SerialLo));

    switch (Subtest)
        {
        case 1:
            {
            // first request is dropped with RPC_P_SEND_FAILED
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = RPC_P_SEND_FAILED;
                }
            break;
            }
        case 2:
            {
            // first request is dropped with RPC_S_OUT_OF_RESOURCES
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = RPC_S_OUT_OF_RESOURCES;
                }
            break;
            }
        case 3:
            {
            // first request is dropped with ERROR_NOT_ENOUGH_MEMORY
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            break;
            }
        case 4:
            {
            // first request is dropped with RPC_P_HOST_DOWN
            //
            if (header->PacketType == DG_REQUEST && header->SerialLo == 0)
                {
                *pStatus = RPC_P_HOST_DOWN;
                }
            break;
            }
        default:
            {
            PrintToConsole("SendErrorHook: subtest %d is not defined\n", Subtest);
            }
        }

    TRACE(("status is %d (0x%x)\n", *pStatus, *pStatus));
}



void
DgTransport (
    int testnum
    )
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    char * name = "DgTransport";

    ChosenConnection = 0;

    Status = GetBinding(BARTHOLOMEW, &binding);
    if (Status)
        {
        ApiError(name, "GetBinding", Status);
        PrintToConsole("%s : FAIL - Unable to Bind \n", name);
        return;
        }

    SyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (SyncEvent == 0)
        {
        ApiError(name, "CreateEvent", Status);
        return;
        }

    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError(name, "GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        PrintToConsole("%s: can't find rpcrt4!I_RpcSetTestHook.\nRecompile RPCRT4.DLL with MSC_OPTIMIZATION=-DRPC_ENABLE_TEST_HOOKS\n");
        ApiError(name, "GetProcAddress: I_RpcSetTestHook", GetLastError());
        return;
        }

    switch (testnum)
        {
        default:
            {
            PrintToConsole("unknown DG transport case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n");
            PrintToConsole("case 1 - first request dropped with RPC_P_SEND_FAILED \n");
            PrintToConsole("case 2 - first request dropped with RPC_S_OUT_OF_RESOURCES \n");
            PrintToConsole("case 3 - first request dropped with ERROR_NOT_ENOUGH_MEMORY \n");
            PrintToConsole("case 4 - first request dropped with RPC_P_HOST_DOWN \n");
            PrintToConsole("case 5 - simulate ICMP reject on first request \n");
            return;
            }

        case 0:
            {
            PrintToConsole("DgTransport: testing each case\n");

            // no break here
            }

        case 1:
            {
            PrintToConsole("case 1 - first request dropped with RPC_P_SEND_FAILED \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Helga( binding );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            PrintToConsole("PASS\n");

            if (testnum != 0)
                {
                break;
                }
            }
        case 2:
            {
            PrintToConsole("case 2 - first request dropped with RPC_S_OUT_OF_RESOURCES \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Helga( binding );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            PrintToConsole("PASS\n");

            if (testnum != 0)
                {
                break;
                }
            }
        case 3:
            {
            PrintToConsole("case 3 - first request dropped with ERROR_NOT_ENOUGH_MEMORY \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Helga( binding );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            PrintToConsole("PASS\n");

            if (testnum != 0)
                {
                break;
                }
            }
        case 4:
            {
            PrintToConsole("case 4 - first request dropped with RPC_P_HOST_DOWN \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            if (Status != RPC_S_SERVER_UNAVAILABLE)
                {
                PrintToConsole("FAIL: wrong error code %d (0x%x)\n", Status, Status);
                }
            else
            {
                PrintToConsole("PASS\n");
                }

            if (testnum != 0)
                {
                break;
                }
            }
        case 5:
            {
            PrintToConsole("case 4 - first request dropped with RPC_P_HOST_DOWN \n");

            Subtest = testnum;

            (*SetTestHookFn)( TH_X_DG_SEND, SendErrorHook );

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            (*SetTestHookFn)( TH_X_DG_SEND, 0 );

            if (Status != RPC_S_SERVER_UNAVAILABLE)
                {
                PrintToConsole("FAIL: wrong error code %d (0x%x)\n", Status, Status);
                }
            else
                {
                PrintToConsole("PASS\n");
                }

            if (testnum != 0)
                {
                break;
                }
            }
        }
}


PVOID LastConnectionCreated = 0;

PVOID MySecurityContext = 0;

DWORD ChosenErrorCode = 0;

void
ShutdownHookFn(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    switch (id)
        {
        case TH_RPC_LOG_EVENT:
            {
            RPC_EVENT * event = (RPC_EVENT *) subject;

//            TRACE(("  hook: %c %c %p %p\n", event->Subject, event->Verb, event->SubjectPointer, event->ObjectPointer));

            //
            // Record sconnection creation.
            //
            if (event->Subject == SU_CCONN &&
                event->Verb    == EV_CREATE)
                {
                TRACE(("  hook: created connection %p\n", event->SubjectPointer));



                LastConnectionCreated = event->SubjectPointer;
                }

                break;
            }

        default:
            {
            break;
            }
        }
}

void
SecurityContextHook(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    if (subject == MySecurityContext)
        {
        TRACE(("  hook executed: context %p, hook ID %x, error code is 0x%x\n", subject, id, ChosenErrorCode));

        DWORD * pStatus = (DWORD *) object;

        *pStatus = ChosenErrorCode;
                }
    else
        {
        TRACE(("  hook: ignoring notification, my cxt = %p, context %p, hook ID %x, error code is 0x%x\n",
               MySecurityContext, subject, id, ChosenErrorCode));
        }
}



void
SecurityErrorWrapper(
    int subtest
    )
{
    RPC_BINDING_HANDLE binding;

    // housekeeping
    //
    DWORD Status = 0;

    ++NumberOfTestsRun;

    char * name = "security error test";

    ChosenConnection = 0;

    Status = GetBinding(SECURITY_ERROR, &binding);
    if (Status)
        {
        ApiError(name, "GetBinding", Status);
        PrintToConsole("%s : FAIL - Unable to Bind \n", name);
        return;
            }

    Status = RpcBindingSetAuthInfo( binding,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    ulSecurityPackage,
                                    NULL,
                                    RPC_C_AUTHZ_NONE
                                    );
    if (Status)
        {
        ApiError(name, "SetAuthInfo", Status);
        PrintToConsole("%s : FAIL\n", name);
        return;
        }

    //
    // Set up the test hook.
    //
    {
    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("","GetModuleHandle",GetLastError());
        return;
}

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        }
    }

    switch (subtest)
        {
        default:
            {
            PrintToConsole("unknown security-error case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n"
                           "\n"
                           "    1 - AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           "    2 - AcceptThirdLeg  returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           );
            return;
            }

        case 0:
            {
            PrintToConsole("running all sub tests\n");
            }

        case 1:
            {
            PrintToConsole("subtest 1: AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            Synchro(SECURITY_ERROR);

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            DWORD ExpectedStatus;

            if (TransportType == RPC_TRANSPORT_UDP ||
                TransportType == RPC_TRANSPORT_IPX)
                {
                ExpectedStatus = RPC_S_SERVER_UNAVAILABLE;
                }
            else
                {
                ExpectedStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
                }

            if (Status != ExpectedStatus)
                {
                PrintToConsole("FAIL: expected error %d, received error code %d (0x%x)\n", ExpectedStatus, Status, Status);
                }
            else
                {
                PrintToConsole("PASS\n");
                }

            IsabelleShutdown(binding);

            if (subtest)
                {
                break;
                }
            }

        case 2:
            {
            PrintToConsole("subtest 2: AcceptThirdLeg returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            Synchro(SECURITY_ERROR);

            // make first call
            //
            PrintToConsole("%s: calling...", name) ;
            Status = HelgaSendReceiveFailure( binding, 0 );

            PrintToConsole("done\n");

            DWORD ExpectedStatus;

            if (TransportType == RPC_TRANSPORT_UDP ||
                TransportType == RPC_TRANSPORT_IPX)
                {
                ExpectedStatus = RPC_S_SERVER_UNAVAILABLE;
                }
            else
                {
                ExpectedStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
                }

            if (Status != ExpectedStatus)
                {
                PrintToConsole("FAIL: expected error %d, received error code %d (0x%x)\n", ExpectedStatus, Status, Status);
                }
            else
                {
                PrintToConsole("PASS\n");
                }

            IsabelleShutdown(binding);

            if (subtest)
                {
                break;
                }
            }
        }
}


EVENT::EVENT (
    IN OUT RPC_STATUS PAPI * RpcStatus,
    IN int ManualReset,
    IN BOOL fDelayInit
    )
{
    EventHandle = NULL;

    // DelayInit events are auto reset
    ASSERT(ManualReset == FALSE || fDelayInit == FALSE);

    if (!fDelayInit && *RpcStatus == RPC_S_OK )
        {
        EventHandle = CreateEvent(NULL, ManualReset, 0, NULL);
        if ( EventHandle != NULL )
            {
            *RpcStatus = RPC_S_OK;
            }
        else
            {
            *RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
}


EVENT::~EVENT (
    )
{

    if ( EventHandle )
        {
        BOOL bResult;
        bResult = CloseHandle(EventHandle);
        ASSERT(bResult != 0);
        }
}

int
EVENT::Wait (
    long timeout
    )
{
    DWORD result;

    if (NULL == EventHandle)
        {
        InitializeEvent();
        }

    result = WaitForSingleObject(EventHandle, timeout);

    if (result == WAIT_TIMEOUT)
        return(1);
    return(0);
}


void
EVENT::InitializeEvent (
    )
// Used when fDelayInit is TRUE in the c'tor.
{
    if (EventHandle)
        {
        return;
        }


    HANDLE event = CreateEvent(0, FALSE, FALSE, 0);

    if (event)
        {
        if (InterlockedCompareExchangePointer(&EventHandle, event, 0) != 0)
            {
            CloseHandle(event);
            }
        return;
        }

    // Can't allocate an event.
    RpcRaiseException(RPC_S_OUT_OF_RESOURCES);
}

void
Indent(
    int indentlevel
    )
{
    const int SPACES_PER_INDENT = 4;

    int i;
    for (i=0; i < SPACES_PER_INDENT * indentlevel; ++i)
        {
        PrintToConsole(" ");
        }
}

DWORD
DumpEeInfo(
    int indentlevel
    )
{
    RPC_STATUS Status2;
    RPC_ERROR_ENUM_HANDLE EnumHandle;

    Status2 = RpcErrorStartEnumeration(&EnumHandle);
    if (Status2 == RPC_S_ENTRY_NOT_FOUND)
        {
        PrintToConsole("eeinfo: no extended error info available\n");
        }
    else if (Status2 != RPC_S_OK)
        {
        PrintToConsole("Couldn't get EEInfo: %d\n", Status2);
        }
    else
        {
        RPC_EXTENDED_ERROR_INFO ErrorInfo;
        int Records;
        BOOL Result;
        BOOL CopyStrings = TRUE;
        PVOID Blob;
        size_t BlobSize;
        BOOL fUseFileTime = TRUE;
        SYSTEMTIME *SystemTimeToUse;
        SYSTEMTIME SystemTimeBuffer;

        Status2 = RpcErrorGetNumberOfRecords(&EnumHandle, &Records);
        if (Status2 == RPC_S_OK)
            {
            Indent(indentlevel);
            PrintToConsole("Number of records is: %d\n", Records);
            }

        while (Status2 == RPC_S_OK)
            {
            ErrorInfo.Version = RPC_EEINFO_VERSION;
            ErrorInfo.Flags = 0;
            ErrorInfo.NumberOfParameters = 4;
            if (fUseFileTime)
                {
                ErrorInfo.Flags |= EEInfoUseFileTime;
                }

            Status2 = RpcErrorGetNextRecord(&EnumHandle, CopyStrings, &ErrorInfo);
            if (Status2 == RPC_S_ENTRY_NOT_FOUND)
                {
                RpcErrorResetEnumeration(&EnumHandle);
                break;
                }
            else if (Status2 != RPC_S_OK)
                {
                PrintToConsole("Couldn't finish enumeration: %d\n", Status2);
                break;
                }
            else
                {
                int i;

                if (ErrorInfo.ComputerName)
                    {
                    Indent(indentlevel+1);
                    PrintToConsole("ComputerName is %S\n", ErrorInfo.ComputerName);
                    if (CopyStrings)
                        {
                        Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.ComputerName);
                        ASSERT(Result);
                        }
                    }

                Indent(indentlevel+1);
                PrintToConsole("ProcessID is %d\n", ErrorInfo.ProcessID);
                if (fUseFileTime)
                    {
                    Result = FileTimeToSystemTime(&ErrorInfo.u.FileTime, &SystemTimeBuffer);
                    ASSERT(Result);
                    SystemTimeToUse = &SystemTimeBuffer;
                    }
                else
                    SystemTimeToUse = &ErrorInfo.u.SystemTime;

                Indent(indentlevel+1);
                PrintToConsole("System Time is: %d/%d/%d %d:%d:%d:%d\n",
                    SystemTimeToUse->wMonth,
                    SystemTimeToUse->wDay,
                    SystemTimeToUse->wYear,
                    SystemTimeToUse->wHour,
                    SystemTimeToUse->wMinute,
                    SystemTimeToUse->wSecond,
                    SystemTimeToUse->wMilliseconds);

                Indent(indentlevel+1);
                PrintToConsole("Generating component is %d\n", ErrorInfo.GeneratingComponent);
                Indent(indentlevel+1);
                PrintToConsole("Status is %d\n", ErrorInfo.Status);
                Indent(indentlevel+1);
                PrintToConsole("Detection location is %d\n", (int)ErrorInfo.DetectionLocation);
                Indent(indentlevel+1);
                PrintToConsole("Flags is %d\n", ErrorInfo.Flags);
                Indent(indentlevel+1);
                PrintToConsole("NumberOfParameters is %d\n", ErrorInfo.NumberOfParameters);

                for (i = 0; i < ErrorInfo.NumberOfParameters; i ++)
                    {
                    switch(ErrorInfo.Parameters[i].ParameterType)
                        {
                        case eeptAnsiString:
                            Indent(indentlevel+1);
                            PrintToConsole("Ansi string: %s\n", ErrorInfo.Parameters[i].u.AnsiString);
                            if (CopyStrings)
                                {
                                Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.Parameters[i].u.AnsiString);
                                ASSERT(Result);
                                }
                            break;

                        case eeptUnicodeString:
                            Indent(indentlevel+1);
                            PrintToConsole("Unicode string: %S\n", ErrorInfo.Parameters[i].u.UnicodeString);
                            if (CopyStrings)
                                {
                                Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.Parameters[i].u.UnicodeString);
                                ASSERT(Result);
                                }
                            break;

                        case eeptLongVal:
                            Indent(indentlevel+1);
                            PrintToConsole("Long val: %d\n", ErrorInfo.Parameters[i].u.LVal);
                            break;

                        case eeptShortVal:
                            Indent(indentlevel+1);
                            PrintToConsole("Short val: %d\n", (int)ErrorInfo.Parameters[i].u.SVal);
                            break;

                        case eeptPointerVal:
                            Indent(indentlevel+1);
                            PrintToConsole("Pointer val: %d\n", ErrorInfo.Parameters[i].u.PVal);
                            break;

                        case eeptNone:
                            Indent(indentlevel+1);
                            PrintToConsole("Truncated\n");
                            break;

                        default:
                            Indent(indentlevel+1);
                            PrintToConsole("Invalid type: %d\n", ErrorInfo.Parameters[i].ParameterType);
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                }
            }

        Status2 = RpcErrorSaveErrorInfo(&EnumHandle, &Blob, &BlobSize);
        if (Status2)
            {
            PrintToConsole("RpcErrorSaveErrorInfo: %d", Status2);
            }

        RpcErrorClearInformation();
        RpcErrorEndEnumeration(&EnumHandle);
        Status2 = RpcErrorLoadErrorInfo(Blob, BlobSize, &EnumHandle);
        if (Status2)
            {
            PrintToConsole("RpcErrorLoadErrorInfo: %d", Status2);
            }
        }

    return Status2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WMILIB_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags;
    ULONG EnableLevel;

    struct _WMILIB_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WMILIB_REG_STRUCT, *PWMILIB_REG_STRUCT;

typedef PWMILIB_REG_STRUCT WMILIB_REG_HANDLE;

typedef void (*WMILIBPRINTFUNC)(UINT Level, PCHAR String);

ULONG
WmlInitialize(
    IN LPWSTR ProductName,
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*,
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT
    );

VOID
WmlUninitialize(
    IN WMILIB_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef
ULONG
(*PWML_INITIALIZE)(
    IN LPWSTR ProductName,
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*,
    ...
    );

typedef
VOID
(*PWML_UNINITIALIZE)(
    IN WMILIB_REG_HANDLE);

typedef
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ...
    );

typedef
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;

    WMILIB_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;

} WML_DATA;


#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibraryW(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)

#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\util.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    util.c

Abstract:

    Various helper and debug functions shared between platforms.

Author:

    Mario Goertzel    [MarioGo]


Revision History:

    MarioGo     95/10/21        Bits 'n pieces

--*/

#include <precomp.hxx>
#include <stdarg.h>

#ifdef DEBUGRPC
BOOL ValidateError(
    IN unsigned int Status,
    IN unsigned int Count,
    IN const int ErrorList[])
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            // more error codes here
            } END_VALIDATE;

     This function is called with the RpcStatus and expected errors codes
     as parameters.  If RpcStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.
    Count - number of variable length arguments

    ... - One or more expected status codes.  Terminated with 0 (RPC_S_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    unsigned i;

    for (i = 0; i < Count; i++)
        {
        if (ErrorList[i] == (int) Status)
            {
            return TRUE;
            }
        }

    PrintToDebugger("RPC Assertion: unexpected failure %lu (0lx%08x)\n",
                    (unsigned long)Status, (unsigned long)Status);

    return(FALSE);
}

#endif // DEBUGRPC

//------------------------------------------------------------------------

#ifdef RPC_ENABLE_WMI_TRACE

#include <wmistr.h>
#include <evntrace.h>
#include "wmlum.h"              // private header from clustering

extern "C"
{
DWORD __stdcall
I_RpcEnableWmiTrace(
    PWML_TRACE fn,
    WMILIB_REG_STRUCT ** pHandle
    );
}

typedef DWORD (*WMI_TRACE_FN)();

PWML_TRACE WmiTraceFn = 0;

WMILIB_REG_STRUCT WmiTraceData;

GUID WmiMessageGuid = { /* 41de81c0-aa28-460b-a455-c23809e7c170 */
    0x41de81c0,
    0xaa28,
    0x460b,
    {0xa4, 0x55, 0xc2, 0x38, 0x09, 0xe7, 0xc1, 0x70}
  };


DWORD __stdcall
I_RpcEnableWmiTrace(
    PWML_TRACE fn,
    WMILIB_REG_STRUCT ** pHandle
    )
{
    WmiTraceFn = fn;

    *pHandle = &WmiTraceData;

    return 0;
}

#endif

BOOL fEnableLog = TRUE;

C_ASSERT(sizeof(LUID) == sizeof(__int64));

struct RPC_EVENT * RpcEvents;

long EventArrayLength = MAX_RPC_EVENT;
long NextEvent  = 0;

BOOL    DisableEvents = 0;

boolean SubjectExceptions[256];
boolean VerbExceptions[256];

#define LOG_VAR( x ) &(x), sizeof(x)

HANDLE hLogFile = 0;

struct RPC_EVENT_LOG
{
    DWORD           Thread;
    union
        {
        struct
            {
            unsigned char   Subject;
            unsigned char   Verb;
            };
        DWORD ZeroSet;
        };

    void *          SubjectPointer;
    void *          ObjectPointer;

    ULONG_PTR       Data;
    void *          EventStackTrace[STACKTRACE_DEPTH];
};

void
TrulyLogEvent(
    IN unsigned char   Subject,
    IN unsigned char   Verb,
    IN void *   SubjectPointer,
    IN void *   ObjectPointer,
    IN ULONG_PTR  Data,
    IN BOOL fCaptureStackTrace,
    IN int    AdditionalFramesToSkip
    )
{
    if (DisableEvents != SubjectExceptions[Subject] ||
        DisableEvents != VerbExceptions[Verb])
        {
        return;
        }

    //
    // Allocate the event table if it isn't already there.
    //
    if (!RpcEvents)
        {
        struct RPC_EVENT * Temp = (struct RPC_EVENT *) HeapAlloc( GetProcessHeap(),
                                                                  HEAP_ZERO_MEMORY,
                                                                  EventArrayLength * sizeof(RPC_EVENT) );
        HANDLE LocalFile;
        if (!Temp)
            {
            return;
            }

        if (InterlockedCompareExchangePointer((void **) &RpcEvents, Temp, 0) != 0)
            {
            HeapFree(GetProcessHeap(), 0, Temp);
            }

        /*
        if (wcsstr(GetCommandLine(), L"fs.exe") != NULL)
            {
            LocalFile = CreateFile(L"d:\\rpcclnt.log", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);

            if (LocalFile != INVALID_HANDLE_VALUE)
                {
                hLogFile = LocalFile;
                }
            else
                {
                if (hLogFile == 0)
                    {
                    DbgPrint("ERROR: Could not create RPC log file: %d\n", GetLastError());
                    }
                // else
                // somebody already set it - ignore
                }
            }
        else if (wcsstr(GetCommandLine(), L"fssvr.exe") != NULL)
            {
            LocalFile = CreateFile(L"d:\\rpcsvr.log", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);

            if (LocalFile != INVALID_HANDLE_VALUE)
                {
                hLogFile = LocalFile;
                }
            else
                {
                if (hLogFile == 0)
                    {
                    DbgPrint("ERROR: Could not create RPC log file: %d\n", GetLastError());
                    }
                // else
                // somebody already set it - ignore
                }
            }
            */

        /*
        DisableEvents = TRUE;
        SubjectExceptions[SU_ADDRESS] = TRUE;
        VerbExceptions[EV_CREATE] = TRUE;
        VerbExceptions[EV_DELETE] = TRUE;
        */
        /*
        SubjectExceptions[SU_HEAP] = TRUE;
        SubjectExceptions[SU_EVENT] = TRUE;
        SubjectExceptions[SU_BCACHE] = TRUE;
        */
        /*
        DisableEvents = TRUE;
        SubjectExceptions['a'] = TRUE;
        SubjectExceptions['g'] = TRUE;
        SubjectExceptions['G'] = TRUE;
        SubjectExceptions['W'] = TRUE;
        SubjectExceptions['X'] = TRUE;
        SubjectExceptions['Y'] = TRUE;
        SubjectExceptions['Z'] = TRUE;
        SubjectExceptions['w'] = TRUE;
        SubjectExceptions['x'] = TRUE;
        SubjectExceptions['y'] = TRUE;
        SubjectExceptions['z'] = TRUE;
        VerbExceptions['t'] = TRUE;
        VerbExceptions['G'] = TRUE;
        VerbExceptions['g'] = TRUE;
        VerbExceptions['w'] = TRUE;
        VerbExceptions['x'] = TRUE;
        VerbExceptions['y'] = TRUE;
        VerbExceptions['z'] = TRUE;
        VerbExceptions['W'] = TRUE;
        VerbExceptions['X'] = TRUE;
        VerbExceptions['Y'] = TRUE;
        VerbExceptions['Z'] = TRUE;
        */
        }

    unsigned index = InterlockedIncrement(&NextEvent);

    index %= EventArrayLength;

    RpcEvents[index].Time            = GetTickCount();
    RpcEvents[index].Verb            = Verb;
    RpcEvents[index].Subject         = Subject;
    RpcEvents[index].Thread          = (short) GetCurrentThreadId();
    RpcEvents[index].SubjectPointer  = SubjectPointer;
    RpcEvents[index].ObjectPointer   = ObjectPointer;
    RpcEvents[index].Data            = Data;

    CallTestHook( TH_RPC_LOG_EVENT, &RpcEvents[index], 0 );

#ifdef RPC_ENABLE_WMI_TRACE
    if (WmiTraceData.EnableFlags)
        {
        TraceMessage(
                      WmiTraceData.LoggerHandle,
                      TRACE_MESSAGE_SEQUENCE   | TRACE_MESSAGE_GUID | TRACE_MESSAGE_SYSTEMINFO | TRACE_MESSAGE_TIMESTAMP,
                      &WmiMessageGuid,
                      Verb,
                      LOG_VAR(Subject),
                      LOG_VAR(SubjectPointer),
                      LOG_VAR(ObjectPointer),
                      LOG_VAR(Data),
                      0
                      );
        }
#endif

#if i386
    if (fCaptureStackTrace)
        {
        ULONG ignore;

        RtlCaptureStackBackTrace(
                                 1 + AdditionalFramesToSkip,
                                 STACKTRACE_DEPTH,
                                 (void **) &RpcEvents[index].EventStackTrace,
                                 &ignore);
        }
    else
#endif
        {
        RpcEvents[index].EventStackTrace[0] = 0;
        }

    if (hLogFile)
        {
        DWORD BytesWritten;
        /*
        RPC_EVENT_LOG logEntry;
        RPC_EVENT *CurrentEvent = &RpcEvents[index];
        logEntry.Thread = CurrentEvent->Thread;
        logEntry.ZeroSet = 0;
        logEntry.Subject = CurrentEvent->Subject;
        logEntry.Verb = CurrentEvent->Verb;
        logEntry.Data = CurrentEvent->Data;
        logEntry.ObjectPointer = CurrentEvent->ObjectPointer;
        logEntry.SubjectPointer = CurrentEvent->SubjectPointer;
        memcpy(logEntry.EventStackTrace, CurrentEvent->EventStackTrace, sizeof(logEntry.EventStackTrace));
        WriteFile(hLogFile, &logEntry, sizeof(logEntry), &BytesWritten, NULL);
        */
        WriteFile(hLogFile, &RpcEvents[index], sizeof(RpcEvents[index]), &BytesWritten, NULL);
        }
}

void RPC_ENTRY
I_RpcLogEvent (
    IN unsigned char Subject,
    IN unsigned char Verb,
    IN void *        SubjectPointer,
    IN void *        ObjectPointer,
    IN unsigned      Data,
    IN BOOL          fCaptureStackTrace,
    IN int           AdditionalFramesToSkip
    )
{
    LogEvent(Subject, Verb, SubjectPointer, ObjectPointer, Data,
             fCaptureStackTrace, AdditionalFramesToSkip);
}

#if 0

BOOL
IsLoggingEnabled()
{
    RPC_CHAR ModulePath[ MAX_PATH ];
    RPC_CHAR * ModuleName;

    //
    // Find out the .EXE name.
    //
    if (!GetModuleFileName( NULL, ModulePath, sizeof(ModulePath)))
        {
        return FALSE;
        }

    signed i;
    for (i=RpcpStringLength(ModulePath)-1; i >= 0; --i)
        {
        if (ModulePath[i] == '\\')
            {
            break;
            }
        }

    ModuleName = ModulePath + i + 1;

    //
    // See whether logging should be enabled.
    //
    HANDLE hImeo;
    HANDLE hMyProcessOptions;
    DWORD Error;
    DWORD Value;
    DWORD Length = sizeof(Value);
    DWORD Type;

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          RPC_CONST_STRING("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options"),
                          0,
                          KEY_READ,
                          &hImeo
                          );
    if (Error)
        {
        return FALSE;
        }

    Error = RegOpenKeyEx( hImeo,
                          ModuleName,
                          0,
                          KEY_READ,
                          &hMyProcessOptions
                          );
    RegCloseKey( hImeo );

    if (Error)
        {
        return FALSE;
        }

    Error = RegQueryValueEx( hMyProcessOptions,
                             RPC_CONST_STRING("Enable RPC Logging"),
                             0,
                             &Type,
                             &Value,
                             &Length
                             );

    RegCloseKey( hMyProcessOptions );

    if (Error)
        {
        return FALSE;
        }

    if (Type == REG_DWORD && Value)
        {
        return TRUE;
        }

    if (Type == REG_SZ && 0 == RpcpStringCompare((RPC_CHAR *) Value, RPC_CONST_CHAR('Y')))
        {
        return TRUE;
        }

    return FALSE;
}

#endif

extern "C" int __cdecl _purecall(void)
{
#ifdef DEBUGRPC
    ASSERT(!"PureVirtualCalled");
#endif
    return 0;
}

const RPC_CHAR *
FastGetImageBaseName (
    void
    )
/*++
Routine Description

    Retrieves the image base name with touching minimal amount of
    other memory.

Arguments:


Return Value:

    A pointer to LDR private string with the image name. Don't write or
    delete it!

--*/
{
    PLIST_ENTRY Module;
    PLDR_DATA_TABLE_ENTRY Entry;

    Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink;
    Entry = CONTAINING_RECORD(Module,
                                LDR_DATA_TABLE_ENTRY,
                                InLoadOrderLinks);

    return Entry->BaseDllName.Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\cmap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cmap.cxx
//
//--------------------------------------------------------------------------


#include <precomp.hxx>
#include <mqtrans.hxx>

//------------------------------------------------------------------------
//  Constructor
//------------------------------------------------------------------------
CQueueMap::CQueueMap() : cs((InitStatus = RPC_S_OK, &InitStatus))
{
    dwMapSize = 0;
    dwOldest = 0;
    pMap = 0;
}

//------------------------------------------------------------------------
//  Initialize()
//------------------------------------------------------------------------
BOOL CQueueMap::Initialize( DWORD dwNewMapSize )
{
    if (!dwNewMapSize)
       return FALSE;

    if (!dwMapSize)
       {

       if (InitStatus != RPC_S_OK)
           return FALSE;

       pMap = new QUEUEMAP_ENTRY [dwNewMapSize];
       if (!pMap)
          return FALSE;

       dwMapSize = dwNewMapSize;

       for (unsigned i=0; i<dwMapSize; i++)
           {
           pMap[i].hQueue = 0;
           pMap[i].pwsQFormat = 0;
           }
    }

    return TRUE;
}

//------------------------------------------------------------------------
//  Destructor
//------------------------------------------------------------------------
CQueueMap::~CQueueMap()
{
    if (pMap)
        {
        for (unsigned i=0; i<dwMapSize; i++)
            {
            if (pMap[i].hQueue)
               MQCloseQueue(pMap[i].hQueue);
            if (pMap[i].pwsQFormat)
               delete [] pMap[i].pwsQFormat;
            }
        }

   delete pMap;
}

//------------------------------------------------------------------------
//  Lookup()
//------------------------------------------------------------------------
QUEUEHANDLE CQueueMap::Lookup( RPC_CHAR *pwsQFormat )
{

    cs.Request();

    for (unsigned i=0; i<dwMapSize; i++)
        {
        if ((pMap[i].pwsQFormat)&&(!RpcpStringSCompare(pwsQFormat,pMap[i].pwsQFormat)))
            {
            cs.Clear();
            return pMap[i].hQueue;
            }
        }

    cs.Clear();

    return 0;
}

//------------------------------------------------------------------------
//  Add()
//------------------------------------------------------------------------
BOOL CQueueMap::Add( RPC_CHAR *pwsQFormat, QUEUEHANDLE hQueue )
{
    // Only add entries that look valid...
    if ( !pwsQFormat || !hQueue )
        {
        return FALSE;
        }

    cs.Request();

    // If the table is full, the clear out the oldest entry:
    if (pMap[dwOldest].hQueue)
        {
        MQCloseQueue(pMap[dwOldest].hQueue);
        pMap[dwOldest].hQueue = 0;
        }

    if (pMap[dwOldest].pwsQFormat)
        {
        delete [] pMap[dwOldest].pwsQFormat;
        pMap[dwOldest].pwsQFormat = 0;
        }

    // New entry:
    pMap[dwOldest].pwsQFormat = new RPC_CHAR [1+RpcpStringLength(pwsQFormat)];
    if (!pMap[dwOldest].pwsQFormat)
        {
        cs.Clear();
        return FALSE;
        }

    RpcpStringCopy(pMap[dwOldest].pwsQFormat,pwsQFormat);
    pMap[dwOldest].hQueue = hQueue;

    dwOldest = (1 + dwOldest)%dwMapSize;

    cs.Clear();

    return TRUE;
}

//------------------------------------------------------------------------
//  Remove()
//------------------------------------------------------------------------
BOOL CQueueMap::Remove( RPC_CHAR *pwsQFormat )
{
    cs.Request();

    for (unsigned i=0; i<dwMapSize; i++)
        {
        if ((pMap[i].pwsQFormat)&&(!RpcpStringSCompare(pwsQFormat,pMap[i].pwsQFormat)))
            {
            delete [] pMap[i].pwsQFormat;
            pMap[i].pwsQFormat = 0;
            pMap[i].hQueue = 0;
            cs.Clear();
            return TRUE;
            }
        }

    cs.Clear();

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\afd.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

    Module Name:

        Afd.cxx

    Abstract:

        Wrappers to simulate winsock API directly on top of AFD IOCTLS.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     4/4/1997    Based on NT 4 DG code.

--*/

#include <precomp.hxx>
#include <tdi.h>
#include <clustdi.h>
#include <afd.h>

void
InitializeRawAddress(
    IN WS_SOCKADDR *pSockAddr,
    OUT PVOID pRawAddress,
    OUT DWORD *pdwRawAddressSize
    )
/*++

Routine Description:

    Converts from a winsock sockaddr to a TDI format address.

Arguments:

    pSockAddr - The address to convert from, must be either a
        AF_INET (IP), AF_IPX, or AF_CLUSTER family address.

    pRawAddress - The buffer to store the TDI format address.
    pdwRawAddressSize - On return, the size of the TDI format address.

Return Value:

    None

--*/

{
#ifdef IPX_ON
    ASSERT(   pSockAddr->generic.sa_family == AF_INET
           || pSockAddr->generic.sa_family == AF_IPX
           || pSockAddr->generic.sa_family == AF_CLUSTER);
#else
    ASSERT(   pSockAddr->generic.sa_family == AF_INET
           || pSockAddr->generic.sa_family == AF_CLUSTER);
#endif

    switch (pSockAddr->generic.sa_family) {
    case AF_INET:
        {
        // UDP

        TA_IP_ADDRESS *pra = (TA_IP_ADDRESS *)pRawAddress;

        pra->TAAddressCount = 1;
        pra->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pra->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        pra->Address[0].Address[0].sin_port = pSockAddr->inetaddr.sin_port;
        pra->Address[0].Address[0].in_addr = pSockAddr->inetaddr.sin_addr.s_addr;
        memset(pra->Address[0].Address[0].sin_zero, 0, 8);

        *pdwRawAddressSize = sizeof(TA_IP_ADDRESS);
        break;
        }

#ifdef IPX_ON
    case AF_IPX:
        {
        // IPX

        TA_IPX_ADDRESS *pra = (TA_IPX_ADDRESS *)pRawAddress;

        pra->TAAddressCount = 1;
        pra->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IPX;
        pra->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
        memcpy(&pra->Address[0].Address[0].NetworkAddress, pSockAddr->ipxaddr.sa_netnum, 4);
        memcpy(&pra->Address[0].Address[0].NodeAddress, pSockAddr->ipxaddr.sa_nodenum, 6);
        pra->Address[0].Address[0].Socket = pSockAddr->ipxaddr.sa_socket;

        *pdwRawAddressSize = sizeof(TA_IPX_ADDRESS);
        break;
        }
#endif

    case AF_CLUSTER:
        {
        // Clusters

        TA_CLUSTER_ADDRESS *pra = (TA_CLUSTER_ADDRESS *)pRawAddress;

        pra->TAAddressCount = 1;
        pra->Address[0].AddressLength = TDI_ADDRESS_LENGTH_CLUSTER;
        pra->Address[0].AddressType = TDI_ADDRESS_TYPE_CLUSTER;
        pra->Address[0].Address[0].Port = pSockAddr->clusaddr.sac_port;
        pra->Address[0].Address[0].Node = pSockAddr->clusaddr.sac_node;
        pra->Address[0].Address[0].ReservedMBZ = 0;

        *pdwRawAddressSize = sizeof(TA_CLUSTER_ADDRESS);
        }
    }

    return;
}


int
WSAAPI
AFD_SendTo(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++

Routine Description:

    Implement's a wrapper around the AFD recv IOCTL which looks like WSASendTo.
    RPC uses this when MSAFD is the network provider.

Note:

    Try reading private\net\sockets\winsock2\wsp\msafd\send.c if you want
    more information.

Arguments:

    WSASendTo arguments

Return Value:

    0 - success
    ERROR_IO_PENDING - IO submitted

    non-zero - error

--*/

{
    PIO_STATUS_BLOCK pIoStatus = (PIO_STATUS_BLOCK)&lpOverlapped->Internal;
    AFD_SEND_DATAGRAM_INFO sendInfo;
    UCHAR abRawAddress[max(sizeof(TA_IP_ADDRESS),sizeof(TA_IPX_ADDRESS))];
    DWORD dwRawAddressSize;
    int status;
    NTSTATUS NtStatus;

    ASSERT(lpCompletionRoutine == 0);
    ASSERT(lpOverlapped);

    InitializeRawAddress((WS_SOCKADDR *)lpTo, abRawAddress, &dwRawAddressSize);

    sendInfo.AfdFlags = AFD_OVERLAPPED;
    sendInfo.BufferArray = lpBuffers;
    sendInfo.BufferCount = dwBufferCount;
    sendInfo.TdiRequest.SendDatagramInformation = &sendInfo.TdiConnInfo;
    sendInfo.TdiConnInfo.UserDataLength = 0;
    sendInfo.TdiConnInfo.UserData = 0;
    sendInfo.TdiConnInfo.OptionsLength = 0;
    sendInfo.TdiConnInfo.Options = 0;
    sendInfo.TdiConnInfo.RemoteAddressLength = dwRawAddressSize;
    sendInfo.TdiConnInfo.RemoteAddress = abRawAddress;

    pIoStatus->Status = STATUS_PENDING;

    NtStatus = NtDeviceIoControlFile(
                                     (HANDLE)s,
                                     lpOverlapped->hEvent,
                                     NULL,
                                     ( PtrToUlong(lpOverlapped->hEvent) & 1 ) ? NULL : lpOverlapped,
                                     pIoStatus,
                                     IOCTL_AFD_SEND_DATAGRAM,
                                     &sendInfo,
                                     sizeof(sendInfo),
                                     NULL,
                                     0
                                     );

    if (NtStatus == STATUS_PENDING)
        {
        SetLastError(WSA_IO_PENDING);
        *lpNumberOfBytesSent = 0;
        return(-1);
        }

    if (NtStatus == STATUS_HOST_DOWN)
        {
        SetLastError(WSAEHOSTDOWN);
        return(-1);
        }

    if (!NT_SUCCESS(NtStatus))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Afd send failed: 0x%x\n",
                       NtStatus));

        SetLastError(RtlNtStatusToDosError(NtStatus));
        return(-1);
        }

    *lpNumberOfBytesSent = ULONG(pIoStatus->Information);

    ASSERT(*lpNumberOfBytesSent);

    return 0;
}

int
WSAAPI
AFD_RecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++

Routine Description:

    Implement's a wrapper around the AFD recv IOCTL which looks like WSARecvFrom.
    RPC uses this when MSAFD is the network provider.

Notes:

    Try reading private\net\sockets\winsock2\wsp\msafd\recv.c if you want
    more information.

Arguments:

    WSARecvFrom arguments

Return Value:

    0 - success
    ERROR_IO_PENDING - IO submitted

    non-zero - error

--*/

{
    PIO_STATUS_BLOCK pIoStatus = (PIO_STATUS_BLOCK )&lpOverlapped->Internal;
    AFD_RECV_DATAGRAM_INFO recvInfo;
    int status;
    NTSTATUS NtStatus;

    ASSERT(lpCompletionRoutine == 0);
    ASSERT(lpOverlapped);

    recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
    recvInfo.AfdFlags = AFD_OVERLAPPED;
    recvInfo.BufferArray = lpBuffers;
    recvInfo.BufferCount = dwBufferCount;
    recvInfo.Address = lpFrom;
    recvInfo.AddressLength = (PULONG)lpFromlen;

    pIoStatus->Status = STATUS_PENDING;

    NtStatus = NtDeviceIoControlFile((HANDLE)s,
                                     lpOverlapped->hEvent,
                                     0,
                                     ( PtrToUlong(lpOverlapped->hEvent) & 1 ) ? NULL : lpOverlapped,
                                     pIoStatus,
                                     IOCTL_AFD_RECEIVE_DATAGRAM,
                                     &recvInfo,
                                     sizeof(recvInfo),
                                     NULL,
                                     0);

    if (NtStatus == STATUS_PENDING)
        {
        SetLastError(ERROR_IO_PENDING);
        return(ERROR_IO_PENDING);
        }

    if (!NT_SUCCESS(NtStatus))
        {
        switch (NtStatus)
            {
            case STATUS_PORT_UNREACHABLE:       status = WSAECONNRESET;   break;
            case STATUS_HOST_UNREACHABLE:       status = WSAEHOSTUNREACH; break;
            case STATUS_NETWORK_UNREACHABLE:    status = WSAENETUNREACH;  break;

            case STATUS_BUFFER_OVERFLOW:
            case STATUS_RECEIVE_PARTIAL:
                {
                *lpNumberOfBytesRecvd = -1 * ULONG(pIoStatus->Information);
                status = WSAEMSGSIZE;
                break;
                }

            default:
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "Afd recv failed: 0x%x\n",
                               NtStatus));

                status = RPC_S_OUT_OF_RESOURCES;
                break;
                }
            }

        SetLastError( status );
        }
    else
        {
        *lpNumberOfBytesRecvd = ULONG(pIoStatus->Information);
        status = NO_ERROR;
        }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\complete.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Complete.cxx

Abstract:

    The place that IO completes

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/19/1996    Bits 'n pieces
    MarioGo    10/25/1996    Async RPC

--*/
#include <precomp.hxx>
#include <trans.hxx>
#include <cotrans.hxx>

HANDLE RpcCompletionPort = 0;
HANDLE InactiveRpcCompletionPort = 0;

HANDLE *RpcCompletionPorts;
long *CompletionPortHandleLoads;

BASE_ADDRESS *AddressList = 0;

HANDLE g_NotificationHandle = 0;
LONG g_ListeningForPNPNotifications = 0;
LONG g_NotifyRt = 0;

OVERLAPPED g_Overlapped;
CRITICAL_SECTION AddressListLock;


RPC_STATUS
RPC_ENTRY
COMMON_PostNonIoEvent(
    RPC_TRANSPORT_EVENT Event,
    DWORD Type,
    PVOID Context
    )
{
    BOOL b;
    int i = 5;

    ASSERT(Event != TRANSPORT_POSTED_KEY);

    do
        {
        // Kick a listening thread
        b = PostQueuedCompletionStatus(RpcCompletionPort,
                                       Type,
                                       Event,
                                       (LPOVERLAPPED)Context
                                       );
        if (b)
            {
            break;
            }

        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "PostQueuedCompleitonStatus failed %d\n",
                       GetLastError()));

        Sleep(100);
        i--;
        }
    while(i);

    //
    // If this has failed we are out of luck unless something else manages
    // to wake up the listen thread.
    //
    // As of 4/19/96 PostQueuedCompletionStatus will only fail if the handle
    // is invalid or the kernel is unable to allocate a small bit of non-paged
    // pool.  Either way we're toast...
    //

    ASSERT(b);

    if (!b)
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
COMMON_PostRuntimeEvent(
    IN DWORD Type,
    IN PVOID Context
    )
/*++

Routine Description:

    Posts an event to the completion port.  This will complete
    with an event type of RuntimePosted, event status RPC_S_OK
    and event context of Context.

Arguments:
    Context - Context associated with the event

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    return(COMMON_PostNonIoEvent(RuntimePosted, Type, Context));
}



void
COMMON_AddressManager(
    BASE_ADDRESS *pAddress
    )
/*++

Routine Description:

    When an address does not have an outstanding connect/accept/recv for some
    reason it is added to the AddressList global list of address objects.  Listen
    threads will try to submit a listen on these as time passed.  New addresses
    are put onto this list when they are ready to start listening.

Arguments:

    pAddress - An address without an outstanding listen.

Return Value:

    None

--*/
{

    EnterCriticalSection(&AddressListLock);

    if (pAddress->InAddressList == NotInList)
        {

        #if DBG
        // The address should not be in the list.
        BASE_ADDRESS *pT = AddressList;
        while(pT)
            {
            ASSERT(pT != pAddress);
            pT = pT->pNext;
            }
        #endif

        pAddress->pNext = AddressList;
        AddressList = pAddress;
        pAddress->InAddressList = InTheList;
        }

    LeaveCriticalSection(&AddressListLock);
}


void RPC_ENTRY
COMMON_ServerCompleteListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress
    )
/*++

Routine Description:

    Called on an address once the runtime is really ready to start
    processing connections on this address.

Arguments:

    Address - A fully initalized address which the runtime is
        ready to start receiving connection on.

Return Value:

    None

--*/
{
    BASE_ADDRESS *pList = (BASE_ADDRESS *) ThisAddress;

    while(pList)
        {
        COMMON_AddressManager(pList);
        pList = pList->pNextAddress;
        }

    COMMON_ListenForPNPNotifications();

    // The TRANSPORT message indicates that a new
    // address has been added to the AddressList.

    COMMON_PostNonIoEvent(TRANSPORT, 0, 0);


    return;
}



RPC_STATUS RPC_ENTRY
COMMON_PrepareNewHandle(HANDLE hAdd)
/*++

Routine Description:

    Generic wrapper used to add a newly create IO handle to
    to the IO completion port.

Arguments:

    hAdd - The handle to be added to the port.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    HANDLE h = CreateIoCompletionPort(hAdd,
                                      RpcCompletionPort,
                                      TRANSPORT_POSTED_KEY,
                                      0);

    if (h)
        {
        ASSERT(h == RpcCompletionPort);
        return(RPC_S_OK);
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "CreateIoCompletionPort failed %d\n",
                   GetLastError()));

    ASSERT(GetLastError() == ERROR_NO_SYSTEM_RESOURCES);

    return(RPC_S_OUT_OF_MEMORY);
}


void
COMMON_RemoveAddress (
    IN BASE_ADDRESS *Address
    )
/*++
Function Name:COMMON_RemoveAddress

Parameters:

Description:
    This function must be called only when AddressListLock is held
    Remove address from the address manager list

Returns:

--*/
{
    Address->InAddressList = Inactive;

    //
    // Close the sockets in the address
    //

    if (Address->type & DATAGRAM)
        {
        DG_DeactivateAddress((WS_DATAGRAM_ENDPOINT *) Address);
        }
    else
        {
        WS_DeactivateAddress((WS_ADDRESS *) Address);
        }
}


VOID
RPC_ENTRY
COMMON_StartPnpNotifications (
    )
{
    ASSERT(RpcCompletionPort);

    g_NotifyRt = TRUE;
    COMMON_ListenForPNPNotifications();
}


VOID
RPC_ENTRY
COMMON_ListenForPNPNotifications (
    )
/*++
Function Name:COMMON_ListenForPNPNotifications

Parameters:

Description:

Returns:

--*/
{
    int retval;
    HANDLE h;

    if (hWinsock2 == 0)
        {
        //
        // Winsock not loaded, don't need to do any PNP stuff
        //
        return;
        }

    if (InterlockedIncrement(&g_ListeningForPNPNotifications) != 1)
        {
        return;
        }

    // REVIEW: We may need to provide a mechanism to prevent spinning for lack of
    // resources

    if (g_NotificationHandle == 0)
        {
        retval = WSAProviderConfigChange(
                                     &g_NotificationHandle,
                                     0, 0);
        if (retval != 0 || g_NotificationHandle == 0)
            {
            if (g_NotificationHandle)
                CloseHandle(g_NotificationHandle);
            goto Cleanup;
            }

        h = CreateIoCompletionPort(g_NotificationHandle,
                               RpcCompletionPort,
                               NewAddress,
                               0);

        if (h == 0)
            {
            CloseHandle(g_NotificationHandle);
            goto Cleanup;
            }
        else
            {
            ASSERT(h == RpcCompletionPort);
            }
        }

    // if the previous request is still there, we don't want to submit another one
    if (g_Overlapped.Internal != STATUS_PENDING)
        {
        g_Overlapped.hEvent = 0;
        g_Overlapped.Offset = 0;
        g_Overlapped.OffsetHigh = 0;

        retval = WSAProviderConfigChange(
                                         &g_NotificationHandle,
                                         &g_Overlapped,
                                         0);
        if (retval != 0)
            {
            if (GetLastError() != WSA_IO_PENDING)
                {
                CloseHandle(g_NotificationHandle);
                goto Cleanup;
                }
            }
        }

    if (!TransportProtocol::ResubmitQueriesIfNecessary())
        {
        CloseHandle(g_NotificationHandle);
        goto Cleanup;
        }

    g_ListeningForPNPNotifications = 2;
    return;

Cleanup:
    g_ListeningForPNPNotifications = 0;
    g_NotificationHandle = 0;
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "COMMON_ListenForPNPNotifications failed\n"));
}


RPC_STATUS
RPC_ENTRY
COMMON_ProcessCalls(
    IN  INT Timeout,
    OUT RPC_TRANSPORT_EVENT *pEvent,
    OUT RPC_STATUS *pEventStatus,
    IN OUT PVOID *ppEventContext,
    OUT UINT *pBufferLength,
    OUT BUFFER *pBuffer,
    OUT PVOID *ppSourceContext)
/*++

Routine Description:

    This routine waits for any async IO to complete for all protocols
    within a transport DLL.  It maybe called by multiple threads at a
    time.  A minimum of one thread should always be calling this function
    for each DLL.

    Note: async clients with no outstanding IO may allow the
        last thread to timeout and only call this function again
        when a new call is started.

    Note: During calls to this API in connection oriented servers
        a callback to I_RpcTransServerNewConnection() may occur.

Arguments:

    Timeout - -1 - infinite
              other - number of milliseconds to wait for IO

    pEvent - Set on return to the type of IO event which finished.

    pEventStatus - The status of the IO event

    ppEventContext - On IN, the handle that the thread should dequeue on.
        On output the context of the event

    pBufferLength - If the event is successful then the number of
        bytes transferred.

    pBuffer - If the even is successful then the buffer associated
        with the IO.

    ppSourceContext - For datagram recvs this is the address
        of the sender.
            For connection sends this is the SendContext associated
        with the IO.  For connection recvs it is NULL.

Return Value:

    RPC_S_OK - IO completed, see pEventStatus.

    RPC_P_TIMEOUT - only if Timeout != INFINITE and is exceeded.

--*/
{
    BOOL b;
    ULONG_PTR key;
    DWORD bytes;
    RPC_STATUS status;
    LPOVERLAPPED lpOverlapped;
    PBASE_OVERLAPPED pBaseOverlapped;
    PREQUEST pRequest;
    PCONNECTION pConnection;
    PADDRESS pAddress;
    INT LocalTimeout;
    HANDLE hCompletionPortHandle = (HANDLE) *ppEventContext;
    DWORD LastError;

    ASSERT(RpcCompletionPort);

    *pEvent = 0;
    *pBuffer = 0;

    for(;;)
        {

        //
        // Do general house keeping work here.  If it appears that more
        // house keeping work will be required in the future make
        // sure to reduce the LocalTimeout to something < INFINITE.
        //

        LocalTimeout = Timeout;

        // House keeping - look for any non-listening addresses and see if we
        // can make them listen now.  Addresses start in this list and are added
        // back into the list if they are unable to submit a listen for some reason.

        if (AddressList)
            {
            EnterCriticalSection(&AddressListLock);

            if (AddressList)
                {

                pAddress = (PADDRESS)AddressList;
                AddressList = 0;

                if (Timeout == INFINITE)
                    {
                    // We want to wake up again soon and recheck the AddressList.
                    LocalTimeout = 7*1000;
                    }
                }
            else
                {
                pAddress = 0;
                }

            LeaveCriticalSection(&AddressListLock);

            while(pAddress)
                {
                PADDRESS pNext = (PADDRESS)pAddress->pNext;
                pAddress->pNext = 0;

                if (pAddress->InAddressList == InTheList)
                    {
                    pAddress->InAddressList = NotInList;
                    pAddress->SubmitListen(pAddress);
                    }
                pAddress = pNext;
                }
            }

        if (!g_ListeningForPNPNotifications)
            {
            COMMON_ListenForPNPNotifications();
            }

        //
        // The good part!  Wait for something to happen...
        //
        b = GetQueuedCompletionStatus(hCompletionPortHandle,
                                      &bytes,
                                      &key,
                                      &lpOverlapped,
                                      LocalTimeout
                                      );

        if (!b && !lpOverlapped)
            {
            // If lpOverlapped is NULL this mean no IO completed.
            if ((status = GetLastError()) == STATUS_TIMEOUT)
                {
                if (Timeout == INFINITE)
                    {
                    continue;
                    }
                return(RPC_P_TIMEOUT);
                }
            else
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "GetQueuedCompletionStatus failed %d\n",
                               status));

                ASSERT(0);
                Sleep(1);  // Avoid burning all the CPU in case we are hosed.
                continue;
                }
            }

        //PrintToDebugger("A request arrived at the completion port\n");
        if (key != TRANSPORT_POSTED_KEY)
            {
            if (b)
                {
                // Internal Non-IO posted event
                //    Key - The type of event
                //    lpOverlapped - The context associated with the event

                ASSERT(   key == RuntimePosted
                   || key == TRANSPORT
                   || key == NewAddress);

                // RuntimePosted events allowed the RPC runtime to wake
                // a listening thread with an atbitrary context.
                if (key == RuntimePosted)
                    {
                    *pEvent = RuntimePosted;
                    *pEventStatus = RPC_S_OK;
                    *ppEventContext = lpOverlapped;
                    *pBufferLength = bytes;
                    return(RPC_S_OK);
                    }

                //
                // A protocol was just loaded or unloaded. Take care of it
                //
                if (key == NewAddress)
                    {
                    if (TransportProtocol::HandlePnPStateChange())
                        {
                        g_ListeningForPNPNotifications = 0;
                        *pEvent = NewAddress;

                        return(RPC_S_OK);
                        }

                    // REVIEW: Not processing notification handling failures
                    // may create problems where new protocols, or unloading of
                    // old ones are ignored. This is not very bad, so we keep
                    // it simple and ignore it.
                    g_ListeningForPNPNotifications = 0;
                    continue;
                    }

                // TRANSPORT event is posted when a new address
                // has been added to the AddressListen.  Simply continue
                // around the loop.

                ASSERT(bytes == 0);
                ASSERT(lpOverlapped == 0);
                }
            else
                {

                if (key == NewAddress)
                    {
                    g_ListeningForPNPNotifications = 0;
                    }
                }
            continue;
            }

        ASSERT(!b || lpOverlapped);

        status = RPC_S_OK;

        if (!b)
            {
            pBaseOverlapped = FindOverlapped(lpOverlapped);
            pRequest = FindRequest(lpOverlapped);

            LastError = GetLastError();
            if ((   pRequest->type & ADDRESS)
                 && (LastError != ERROR_MORE_DATA))
                {
                VALIDATE(GetLastError())
                    {
                    ERROR_NETNAME_DELETED,
                    ERROR_BAD_NETPATH,
                    ERROR_NO_SYSTEM_RESOURCES,
                    ERROR_SEM_TIMEOUT,
                    ERROR_OPERATION_ABORTED,
                    ERROR_HOST_UNREACHABLE,
                    ERROR_NETWORK_UNREACHABLE,
                    ERROR_UNEXP_NET_ERR,
                    ERROR_NOT_ENOUGH_QUOTA,
                    ERROR_BROKEN_PIPE,
                    ERROR_CONNECTION_ABORTED
                    } END_VALIDATE;

                COMMON_AddressManager((BASE_ADDRESS *)pRequest);
                continue;
                }

            switch (LastError)
                {
                case ERROR_MORE_DATA:
                    {
                    // Normal parital read of a connection request
                    // or an oversized datagram.  This is ok, falls
                    // into the normal path.

                    status = RPC_P_OVERSIZE_PACKET;
                    break;
                    }

                case ERROR_INVALID_HANDLE:
                    // Named pipes allows a close to reach the server before
                    // the read.  When this happens the server rejects the read
                    // with an invalid handle error.
                    ASSERT(pRequest->id == NMP);
                    ASSERT(pRequest->fAborted);

                    // Fall into normal close case.

                case ERROR_NETNAME_DELETED:
                case ERROR_BROKEN_PIPE:
                case ERROR_PIPE_NOT_CONNECTED:
                case ERROR_NO_DATA:
                case ERROR_SEM_TIMEOUT:
                case ERROR_GRACEFUL_DISCONNECT:
                case WSAECONNRESET:
                case WSAESHUTDOWN:
                case WSAECONNABORTED:
                case WSAEHOSTDOWN:
                case ERROR_CONNECTION_ABORTED:
                    {
                    bytes = 0;
                    ASSERT((pRequest->type & PROTO_MASK) == CONNECTION);
                    // Will be handled as a close
                    break;
                    }

                case ERROR_NO_SYSTEM_RESOURCES:
                    {
                    //
                    // This is just like the errors above except that both c/o and datagram requests
                    // can generate it.
                    //
                    if ((pRequest->type & PROTO_MASK) == CONNECTION)
                        {
                        bytes = 0;
                        // Will be handled as a close
                        }
                    else
                        {
                        bytes = 0;
                        status = ERROR_OPERATION_ABORTED;
                        }

                    break;
                    }

                case ERROR_OPERATION_ABORTED:
                    {
                    //
                    // When a thread that issued an I/O dies the operation
                    // completes with this error.
                    // There are a couple cases here:
                    //  1) The IO is datagram in which case we can just
                    //     reissue the I/O on this thread.  In an idle
                    //     server eventually all DG I/O will migrate to
                    //     the single listening thread.
                    //  2) The IO is on a client connection and the
                    //     the client thread has died.  In this case
                    //     we need to abort the connection and return
                    //     to the runtime.
                    //  3) If this happens on an address we have a bug.
                    //  4) If this happens on a server connection we have a bug.
                    //

                    if (pRequest->type & DATAGRAM)
                        {
                        // We deal with this in the normal datagram path
                        ASSERT(bytes == 0);
                        status = ERROR_OPERATION_ABORTED;
                        break;
                        }

                    ASSERT((pRequest->type & PROTO_MASK) == CONNECTION);
                    // zero out the bytes just in case. Sometimes network operations
                    // return positive byte count on operation aborted
                    bytes = 0;

                    // We'll treat this as a connection close on the client.
                    // REVIEW: Maybe do something better.

                    break;
                    }

                case ERROR_NETWORK_UNREACHABLE:
                case ERROR_HOST_UNREACHABLE:
                case ERROR_PORT_UNREACHABLE:
                    //
                    // errors coming from ICMP packets to our UDP endpoint.
                    // Winsock does not present this in a way our async architecture
                    // can use, so ignore them.
                    //
                    if ((pRequest->type & PROTO_MASK) == CONNECTION)
                        {
                        bytes = 0;
                        // Will be handled as a close
                        }
                    else
                        {
                        status = ERROR_OPERATION_ABORTED;
                        }
                    break;

                default:
                    {
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "IO failed %lX %d\n",
                                   pRequest,
                                   GetLastError()));

                    ASSERT(0);
                    status = RPC_S_OUT_OF_RESOURCES;
                    // treat as a close
                    bytes = 0;
                    break;
                    }
                }
            }

        // here we actually have a completed IO
        pBaseOverlapped = FindOverlapped(lpOverlapped);
        pRequest = FindRequest(lpOverlapped);

        switch(pRequest->type & PROTO_MASK)
            {
            case CONNECTION:
                //
                // Connection IO completed.
                //
                I_RpcTransUnprotectThread(pBaseOverlapped->thread);

                pConnection = (PCONNECTION)pRequest;

                // A read or write either completed or failed

                *ppEventContext = pConnection;

                if (pBaseOverlapped == &pConnection->Read)
                    {
                    // Read completed
                    *ppSourceContext = UlongToPtr(bytes);

                    if (bytes == 0)
                        {
                        *pEvent = pConnection->type | RECEIVE;
                        pConnection->Abort();

                        *pEventStatus = RPC_P_CONNECTION_SHUTDOWN;
                        return(RPC_S_OK);
                        }

                    status = pConnection->ProcessRead(bytes,
                                                      pBuffer,
                                                      pBufferLength);

                    // N.B. Do not move the reading of the pConnection->type
                    // before ProcessRead. ProcessRead can change the type based
                    // on what it reads
                    *pEvent = pConnection->type | RECEIVE;

                    if (status != RPC_P_PARTIAL_RECEIVE)
                        {
                        ASSERT(   status == RPC_P_RECEIVE_FAILED
                               || status == RPC_S_OK
                               || status == RPC_P_PACKET_CONSUMED);


                        *pEventStatus = status;
                        return(RPC_S_OK);
                        }

                    // Message is not complete, submit the next read and continue.

                    status = CO_SubmitRead(pConnection);

                    if (status != RPC_S_OK)
                        {
                        ASSERT(status == RPC_P_RECEIVE_FAILED);
                        *pEventStatus = status;
                        return(RPC_S_OK);
                        }
                    }
                else
                    {
                    // Write completed
                    CO_SEND_CONTEXT *pSend = (CO_SEND_CONTEXT *)pBaseOverlapped;

                    ASSERT(pSend->Write.pAsyncObject == pConnection);

                    *pEvent = pConnection->type | SEND;
                    *ppSourceContext = pSend;

                    *pBuffer = pSend->pWriteBuffer;

                    if (bytes == 0)
                        {
                        pConnection->Abort();

                        *pEventStatus = RPC_P_SEND_FAILED;
                        *pBufferLength = 0;
                        }
                    else
                        {
                        status = RPC_S_OK;

                        *pEventStatus = status;
                        *pBufferLength = pSend->maxWriteBuffer;

                        // Netbios client-side writes are sizeof(DWORD) too big since
                        // they also include the sequence number.

                        ASSERT(   bytes == pSend->maxWriteBuffer
                                       || (    (bytes == pSend->maxWriteBuffer + sizeof(DWORD))
                                          && ((pConnection->type & TYPE_MASK) == CLIENT) ) );
                        }

                    return(RPC_S_OK);
                    }
                break;

            case ADDRESS:
                {
//                ASSERT(bytes == 0);
                pAddress = (PADDRESS)pRequest;
                PCONNECTION pNewConnection = 0;

                status = pAddress->NewConnection(pAddress, &pNewConnection);

                if (RPC_S_OK == status)
                    {
                    // Opened a connection, now try to submit the first recv.

                    ASSERT(pNewConnection);
                    RPC_CONNECTION_TRANSPORT *pInfo;

                    pInfo = (RPC_CONNECTION_TRANSPORT *)TransportTable[pAddress->id].pInfo;

                    ASSERT(pInfo->Recv);

                    status = (pInfo->Recv)(pNewConnection);

                    if (RPC_S_OK != status)
                        {
                        ASSERT(status == RPC_P_RECEIVE_FAILED);
                        *pEvent = pNewConnection->type | RECEIVE;
                        *ppEventContext = pNewConnection;
                        *pEventStatus = status;
                        return(RPC_S_OK);
                        }
                    }

                // Connection has been established or closed, either
                // way we can continue around the loop.
                }
                break;

            case DATAGRAM:
                {
                BASE_ASYNC_OBJECT *pBase = (BASE_ASYNC_OBJECT*)pRequest;

#ifdef NCADG_MQ_ON
                if (pBase->id == MSMQ)
                    {
                    // MSMQ (Falcon) datagram path:
                    MQ_DATAGRAM          *pDatagram = (MQ_DATAGRAM*)pRequest;
                    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)pDatagram->pEndpoint;

                    if (status == RPC_P_OVERSIZE_PACKET)
                        {
                        // Data still pending, get it:
                        status = MQ_ResizePacket( pEndpoint,
                                                  (void**)&pDatagram->pAddress,
                                                  (unsigned int*)pBufferLength,
                                                  pBuffer );
                        }

                    if (status == RPC_S_OK)
                        {
                        MQ_FillInAddress(pDatagram->pAddress,pDatagram->Read.aMsgPropVar);

                        *pEvent = pDatagram->type;
                        *pEventStatus = status;
                        *ppEventContext = pEndpoint;
                        // WATCH OUT! MSMQ doesn't return the size in "bytes"
                        // from GetQueuedCompletionStatus() like everything
                        // else does! We need to extract the #bytes from the
                        // message structure.
                        //
                        // DON'T: *pBufferLength = bytes;
                        *pBufferLength = pDatagram->Read.aMsgPropVar[1].ulVal;
                        *pBuffer = (BUFFER)pDatagram->pPacket;
                        *ppSourceContext = pDatagram->pAddress;

                        pDatagram->pPacket = 0;
                        pDatagram->dwPacketSize = 0;
                        }

                    pDatagram->Busy = 0;

                    LONG c = InterlockedDecrement(&pEndpoint->cPendingIos);

                    ASSERT(c >= 0);

                    if (c == 0)
                        {
                        // No pending receives, time to post more. This doesn't
                        // get hit very often, normally additional recieves are
                        // after sending a packet. (see DG_SendPacket)

                        MQ_SubmitReceives(pEndpoint);
                        }

                    if (status == RPC_S_OK)
                        {
                        return RPC_S_OK;
                        }
                    }
                else
#endif
                    {
                    // Normal datagram path:
                    WS_DATAGRAM          *pDatagram = (WS_DATAGRAM *)pRequest;
                    WS_DATAGRAM_ENDPOINT *pEndpoint = (WS_DATAGRAM_ENDPOINT*)pDatagram->pEndpoint;

                    if (status == RPC_P_OVERSIZE_PACKET)
                        {
                        ASSERT(bytes == pDatagram->Packet.len);
                        }

                    if (   status == RPC_S_OK
                           || status == RPC_P_OVERSIZE_PACKET)
                        {
                        // A receive completed

                        ASSERT(bytes);

                        *pEvent = pDatagram->type;
                        *pEventStatus = status;
                        *ppEventContext = pEndpoint;
                        *pBufferLength = bytes;
                        *pBuffer = (BUFFER)pDatagram->Packet.buf;
                        *ppSourceContext = pDatagram->AddressPair;

                        ASSERT( pDatagram->Packet.buf );

                        // Ready the datagram for another IO operation.
                        pDatagram->Packet.buf = 0;

                        status = RPC_S_OK;
                        }

#if DBG
                    if (status != RPC_S_OK &&
                        status != ERROR_OPERATION_ABORTED)
                        {
                        DbgPrint("RPC: I/O completed with 0x%x\n", status);

                        ASSERT( 0 );
                        }
#endif

                    // Do not touch the datagram after this!
                    pDatagram->Busy = 0;

                    LONG c = InterlockedDecrement(&pEndpoint->cPendingIos);

                    ASSERT(c >= 0);

                    if (c == 0)
                        {
                        // No pending receives, time to post more. This doesn't
                        // get hit very often, normally additional recieves are
                        // after sending a packet. (see DG_SendPacket)

                        DG_SubmitReceives(pEndpoint);
                        }

                    if (status == RPC_S_OK)
                        {
                        return RPC_S_OK;
                        }
                    }
                }
                // Operation aborted, continue around the loop.
                break;

            default:
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "Invalid request type: 0x%x (%p)\n",
                               pRequest->type, pRequest));

                ASSERT(0);
                break;
            }

        // Loop
        }

    ASSERT(0);
    return(RPC_S_INTERNAL_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\hndlcach.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    hndlcach.cxx

Abstract:

    The handle cache.

Author:

    Kamen Moutafov    [KamenM]

Revision History:

--*/

#include <precomp.hxx>

HandleCache::~HandleCache(void)
{
    int i;
    BOOL b;

    for (i = 0; i < DEFAULT_CACHE_SIZE; i ++)
        {
        if (cacheSlots[i] == NULL)
            {
            b = CloseHandle(cacheSlots[i]);
            ASSERT(b);
            cacheSlots[i] = NULL;
            }
        }    
}


HANDLE HandleCache::CheckOutHandle(void)
{
    int i;
    HANDLE h;

    for (i = 0; i < DEFAULT_CACHE_SIZE; i++)
        {
        if (cacheSlots[i] != NULL)
            {
            h = cacheSlots[i];
            cacheSlots[i] = NULL;
            return h;
            }
        }

    return NULL;
}

void HandleCache::CheckinHandle(HANDLE *ph)
{
    int i;

    for (i = 0; i < DEFAULT_CACHE_SIZE; i++)
        {
        if ( NULL == InterlockedCompareExchangePointer(&cacheSlots[i],
                                                       *ph, NULL) )
            {
            *ph = NULL;
            break;
            }
        }
}

#if defined(DBG) || defined(_DEBUG)
BOOL HandleCache::IsSecondHandleUsed(void)
{
    ASSERT (DEFAULT_CACHE_SIZE >= 2);
    return (cacheSlots[1] != NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\cotrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CoTrans.cxx

Abstract:

    Common connection-oriented helper functions

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo    11/11/1996    Async RPC

--*/

#include <precomp.hxx>
#include <trans.hxx>
#include <cotrans.hxx>


RPC_STATUS
RPC_ENTRY
CO_Send(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Length,
    BUFFER Buffer,
    PVOID SendContext
    )
/*++

Routine Description:

    Submits a send of the buffer on the connection.  Will complete with
    ConnectionServerSend or ConnectionClientSend event either when
    the data has been sent on the network or when the send fails.

Arguments:

    ThisConnection - The connection to send the data on.
    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer to use as the CO_SEND_CONTEXT for
        this operation.

Return Value:

    RPC_S_OK

    RPC_P_SEND_FAILED - Connection aborted

--*/
{
    PCONNECTION pConnection = (PCONNECTION)ThisConnection;
    CO_SEND_CONTEXT *pSend = (CO_SEND_CONTEXT *)SendContext;
    BOOL b;
    DWORD ignored;
    RPC_STATUS status;

    pConnection->StartingWriteIO();

    if (pConnection->fAborted)
        {
        pConnection->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    pSend->maxWriteBuffer = Length;
    pSend->pWriteBuffer = Buffer;
    pSend->Write.pAsyncObject = pConnection;
    pSend->Write.ol.hEvent = 0;
    pSend->Write.ol.Offset = 0;
    pSend->Write.ol.OffsetHigh = 0;
    pSend->Write.thread = I_RpcTransProtectThread();

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (Buffer, Length, 0);
        }
#endif

    status = pConnection->Send(
                            pConnection->Conn.Handle,
                            Buffer,
                            Length,
                            &ignored,
                            &pSend->Write.ol
                            );

    pConnection->WriteIOFinished();

    if (   (status != RPC_S_OK)
        && (status != ERROR_IO_PENDING) )
        {
        RpcpErrorAddRecord(EEInfoGCIO,
            status, 
            EEInfoDLCOSend10,
            (ULONGLONG)pConnection,
            (ULONGLONG)Buffer,
            Length);

        VALIDATE(status)
            {
            ERROR_NETNAME_DELETED,
            ERROR_BROKEN_PIPE,
            ERROR_GRACEFUL_DISCONNECT,
            ERROR_NO_DATA,
            ERROR_NO_SYSTEM_RESOURCES,
            ERROR_WORKING_SET_QUOTA,
            ERROR_BAD_COMMAND,
            ERROR_OPERATION_ABORTED,
            ERROR_WORKING_SET_QUOTA,
            ERROR_PIPE_NOT_CONNECTED,
            WSAECONNABORTED,
            WSAECONNRESET
            } END_VALIDATE;

        I_RpcTransUnprotectThread(pSend->Write.thread);

        pConnection->Abort();

        return(RPC_P_SEND_FAILED);
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
CO_SubmitRead(
    PCONNECTION pConnection
    )
/*++

Routine Description:

    Generic routine to submit an async read on an existing connection.

Arguments:

    pConnection - The connection to submit the read on.
        pConnection->pReadBuffer - valid buffer to receive into or null.
        pConnection->maxReadBuffer - size of pReadBuffer or null.
        pConnection->iLastRead is an offset into pReadBuffer of
            data already read.

Return Value:

    RPC_S_OK - Read pending

    RPC_P_RECEIVE_FAILED - Connection aborted

--*/
{
    BOOL b;
    DWORD ignored;
    RPC_STATUS status;

    if (pConnection->pReadBuffer == 0)
        {
        ASSERT(pConnection->iLastRead == 0);

        pConnection->pReadBuffer = TransConnectionAllocatePacket(pConnection,
                                                                 pConnection->iPostSize);
        if (pConnection->pReadBuffer == 0)
            {
            pConnection->Abort();
            return(RPC_P_RECEIVE_FAILED);
            }

        pConnection->maxReadBuffer = pConnection->iPostSize;
        }
    else
        {
        ASSERT(pConnection->iLastRead < pConnection->maxReadBuffer);
        }

    pConnection->StartingReadIO();
    if (pConnection->fAborted)
        {
        pConnection->ReadIOFinished();
        return(RPC_P_RECEIVE_FAILED);
        }

    pConnection->Read.thread = I_RpcTransProtectThread();
    pConnection->Read.ol.hEvent = 0;

    ASSERT(pConnection->Read.ol.Internal != STATUS_PENDING);

    status = pConnection->Receive(
                           pConnection->Conn.Handle,
                           pConnection->pReadBuffer + pConnection->iLastRead,
                           pConnection->maxReadBuffer - pConnection->iLastRead,
                           &ignored,
                           &pConnection->Read.ol
                           );

    pConnection->ReadIOFinished();

    if (   (status != RPC_S_OK)
        && (status != ERROR_IO_PENDING)
        && (status != ERROR_MORE_DATA) )
        {
        if (   status != ERROR_NETNAME_DELETED
            && status != ERROR_BROKEN_PIPE
            && status != ERROR_GRACEFUL_DISCONNECT)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "UTIL_ReadFile failed %d on %p\n",
                           status,
                           pConnection));
            }

        RpcpErrorAddRecord(EEInfoGCIO,
            status, 
            EEInfoDLCOSubmitRead10);

        // the IO system does not necessarily reset the Internal on sync failure.
        // Reset it because in HTTP when we encounted a sync failure on RTS receive 
        // we may submit a second receive after a failed receive and this will 
        // trigger the ASSERT above
        pConnection->Read.ol.Internal = status;

        I_RpcTransUnprotectThread(pConnection->Read.thread);

        pConnection->Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    // Even if the read completed here, it will also be posted to the
    // completion port.  This means we don't need to handle the read here.

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
CO_Recv(
    RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    Called be the runtime on a connection without a currently
    pending recv.

Arguments:

    ThisConnection - A connection without a read pending on it.

Return Value:

    RPC_S_OK
    RPC_P_RECEIVE_FAILED

--*/
{
    PCONNECTION p = (PCONNECTION)ThisConnection;

    if (   p->iLastRead
        && p->iLastRead == p->maxReadBuffer)
        {
        ASSERT(p->pReadBuffer);

        // This means we received a coalesced read of a complete
        // message. (Or that we received a coalesced read < header size)
        // We should complete that as it's own IO. This is very
        // rare.

        TransDbgDetail((DPFLTR_RPCPROXY_ID,
                        DPFLTR_INFO_LEVEL,
                        RPCTRANS "Posted coalesced data in %p of %d byte\n",
                        p,
                        p->iLastRead));

        UINT bytes;

        bytes = p->iLastRead;
        p->iLastRead = 0;
        p->Read.thread = I_RpcTransProtectThread();

        // This means we want to process this as a new receive
        BOOL b = PostQueuedCompletionStatus(RpcCompletionPort,
                                            bytes,
                                            TRANSPORT_POSTED_KEY,
                                            &p->Read.ol);

        ASSERT(b); // See complete.cxx - we can handle it here if needed.

        return(RPC_S_OK);
        }

    ASSERT(p->iLastRead == 0 || (p->iLastRead < p->maxReadBuffer));

    return(CO_SubmitRead(p));
}


RPC_STATUS BASE_CONNECTION::ProcessRead(IN  DWORD bytes, OUT BUFFER *pBuffer,
                                        OUT PUINT pBufferLength)
/*++

Routine Description:

    Receives a message from a message or byte mode protocol.

Arguments:

    bytes - The number of read (not including those in iLastRead).
    pBuffer - When returning RPC_S_OK will contain the message.
    pBufferLength - When return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK - A complete message has been returned.

    RPC_P_RECEIVE_FAILED - something failed.

    RPC_P_PARTIAL_RECEIVE - Partial message recv'd, need to submit another recv.

--*/
{
    DWORD message_size;
    RPC_STATUS status;

    bytes += iLastRead;

    if (bytes < sizeof(CONN_RPC_HEADER))
        {
        // Not a whole header, resubmit the read and continue.

        iLastRead = bytes;

        return(RPC_P_PARTIAL_RECEIVE);
        }

    message_size = MessageLength((PCONN_RPC_HEADER)pReadBuffer);

    if (message_size < sizeof(CONN_RPC_HEADER))
        {
        ASSERT(message_size >= sizeof(CONN_RPC_HEADER));
        Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    if (bytes == message_size)
        {
        // All set, have a complete request.
        *pBuffer = pReadBuffer;
        *pBufferLength = message_size;

        iLastRead = 0;
        pReadBuffer = 0;
        return(RPC_S_OK);
        }
    else if (message_size > bytes)
        {
        // Don't have a complete message, realloc if needed and
        // resubmit a read for the remaining bytes.

        if (maxReadBuffer < message_size)
            {
            // Buffer too small for the message.
            status = TransConnectionReallocPacket(this,
                                                  &pReadBuffer,
                                                  bytes,
                                                  message_size);

            if (status != RPC_S_OK)
                {
                ASSERT(status == RPC_S_OUT_OF_MEMORY);
                Abort();
                return(RPC_P_RECEIVE_FAILED);
                }

            // increase the post size, but not if we are in paged
            // buffer mode.
            if (!fPagedBCacheMode)
                iPostSize = message_size;
            }

        // Setup to receive exactly the remaining bytes of the message.
        iLastRead = bytes;
        maxReadBuffer = message_size;

        return(RPC_P_PARTIAL_RECEIVE);
        }

    // Coalesced read, save extra data.  Very uncommon, impossible for
    // message mode protocols.

    ASSERT(bytes > message_size);

#ifdef SPX_ON
    ASSERT((id == TCP) || (id == SPX) || (id == HTTP) || (id == TCP_IPv6) || (id == HTTPv2));
#else
    ASSERT((id == TCP) || (id == HTTP) || (id == TCP_IPv6) || (id == HTTPv2));
#endif

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "Coalesced read of %d bytes, connection %p\n",
                   bytes - message_size,
                   this));

    // The first message and size will be returned

    *pBuffer = pReadBuffer;
    *pBufferLength = message_size;

    UINT extra = bytes - message_size;
    UINT alloc_size;

    // Try to find a good size of the extra PDU(s)
    if (extra < sizeof(CONN_RPC_HEADER))
        {
        // Not a whole header, we'll assume iPostSize;

        alloc_size = iPostSize;
        }
    else
        {
#ifdef _M_IA64
        // The first packet may not contain a number of bytes
        // that align the second on an 8-byte boundary.  Hence, the
        // structure may end up unaligned. 
        alloc_size = MessageLengthUnaligned((PCONN_RPC_HEADER)(pReadBuffer
                                                               + message_size));
#else
        alloc_size = MessageLength((PCONN_RPC_HEADER)(pReadBuffer
                                                      + message_size));
#endif
        }

    if (alloc_size < extra)
        {
        // This can happen if there are more than two PDUs coalesced together
        // in the buffer.  Or if the PDU is invalid. Or if the iPostSize is
        // smaller than the next PDU.
        alloc_size = extra;
        }

    // Allocate a new buffer to save the extra data for the next read.
    PBYTE pNewBuffer;

    pNewBuffer = TransConnectionAllocatePacket(this,
                                               alloc_size);

    if (0 == pNewBuffer)
        {
        // We have a complete request.  We could process the request and
        // close the connection only after trying to send the reply.

        *pBuffer = 0;
        *pBufferLength = 0;

        Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    ASSERT(*pBuffer);

    // Save away extra data for the next receive
    RpcpMemoryCopy(pNewBuffer,
                   pReadBuffer + *pBufferLength,
                   extra);
    pReadBuffer = pNewBuffer;
    iLastRead = extra;
    maxReadBuffer = alloc_size;

    ASSERT(iLastRead <= maxReadBuffer);

    ASSERT(pReadBuffer != *pBuffer);

    return(RPC_S_OK);
}


RPC_STATUS
CO_SubmitSyncRead(
    IN PCONNECTION pConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pMessageLength
    )
/*++

Routine Description:

    Called in the synchronous receive path when more data is needed
    in to complete the message.  This function is non-blocking but
    it will try to read as much data as it can and may return a
    completed PDU.

Arguments:

    pConnection - The connection to receive from.
            ->pReadBuffer
            ->maxReadBuffer
            ->iLastRead

Return Value:

    RPC_S_OK - Ok and a complete PDU has arrived

    RPC_P_IO_PENDING - A receive is now outstanding on the connection.
        Wait for it to complete..

    RPC_P_RECEIVE_FAILED - Failure
    RPC_P_CONNECTION_SHUTDOWN - Failure - graceful close received.

--*/
{
    RPC_STATUS status;

    ASSERT(pConnection->pReadBuffer);

    if (pConnection->maxReadBuffer == pConnection->iLastRead)
        {
        // Coalesced receive and we've got one (or more) PDUs
        status = pConnection->ProcessRead(0, pBuffer, pMessageLength);

        ASSERT(status != RPC_P_PARTIAL_RECEIVE);

        return(status);
        }

    DWORD bytes;
    DWORD readbytes;

    ASSERT_READ_EVENT_IS_THERE(pConnection);

    do
        {
        BOOL b;

        readbytes = pConnection->maxReadBuffer - pConnection->iLastRead;

        pConnection->StartingReadIO();
        if (pConnection->fAborted)
            {
            pConnection->ReadIOFinished();
            return(RPC_P_RECEIVE_FAILED);
            }

        status = pConnection->Receive(pConnection->Conn.Handle,
                               pConnection->pReadBuffer + pConnection->iLastRead,
                               readbytes,
                               &bytes,
                               &pConnection->Read.ol);

        pConnection->ReadIOFinished();

        if ((status == ERROR_IO_PENDING) || (status == ERROR_IO_INCOMPLETE))
            {
            // The most common path
            return(RPC_P_IO_PENDING);
            }

        if (status != RPC_S_OK)
            {
            switch (status)
                {
                case ERROR_MORE_DATA:
                    // Treat as success

                    // Note: ReadFile doesn't return the number of bytes read in this
                    // case even though the data is available...
                    // It should still be right, but this double checks it.

                    ASSERT(pConnection->Read.ol.InternalHigh == readbytes);

                    ASSERT(MessageLength((PCONN_RPC_HEADER)pConnection->pReadBuffer) >
                           pConnection->maxReadBuffer);

                    bytes = readbytes;

                    status = RPC_S_OK;
                    break;

                case ERROR_GRACEFUL_DISCONNECT:
                    RpcpErrorAddRecord(EEInfoGCIO,
                        status, 
                        EEInfoDLCOSubmitSyncRead10);
                    status = RPC_P_CONNECTION_SHUTDOWN;
                    break;

                default:
                    RpcpErrorAddRecord(EEInfoGCIO,
                        status, 
                        EEInfoDLCOSubmitSyncRead20);
                    VALIDATE(status)
                        {
                        ERROR_NETNAME_DELETED,
                        ERROR_BROKEN_PIPE,
                        ERROR_PIPE_NOT_CONNECTED,
                        ERROR_NO_SYSTEM_RESOURCES,
                        ERROR_COMMITMENT_LIMIT,
                        WSAECONNRESET,
                        WSAESHUTDOWN,
                        WSAECONNABORTED,
                        ERROR_UNEXP_NET_ERR,
                        ERROR_WORKING_SET_QUOTA
                        } END_VALIDATE;
                    status = RPC_P_RECEIVE_FAILED;
                    break;
                }
            }

        if (bytes == 0)
            {
            status = RPC_P_CONNECTION_SHUTDOWN;
            }

        if (status != RPC_S_OK)
            {
            pConnection->Abort();
            return(status);
            }

        // Read completed, process the data now..
        status = pConnection->ProcessRead(bytes, pBuffer, pMessageLength);
        }
    while (status == RPC_P_PARTIAL_RECEIVE );

    return(status);
}

RPC_STATUS
RPC_ENTRY
CO_SyncRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Receive the next PDU to arrive at the connection.

Arguments:

    ThisConnection - The connection to read from.

    pBuffer - If successful, points to a buffer containing the next PDU.
    pBufferLength -  If successful, contains the length of the message.

Return Value:

    RPC_S_OK

    RPC_P_RECEIVE_FAILED - Connection aborted.
    RPC_S_CALL_CANCELLED - Connection aborted.

--*/
{
    PCONNECTION p = (PCONNECTION)ThisConnection;
    DWORD bytes;
    RPC_STATUS status;
    HANDLE hEvent;

    ASSERT((p->type & TYPE_MASK) == CLIENT);

    ASSERT(p->pReadBuffer == 0);

    p->pReadBuffer = TransConnectionAllocatePacket(p, p->iPostSize);

    hEvent = I_RpcTransGetThreadEvent();

    if (p->pReadBuffer == 0)
        {
        p->Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    p->maxReadBuffer = p->iPostSize;
    p->iLastRead = 0;
    p->Read.ol.hEvent = (HANDLE)((ULONG_PTR)hEvent | 0x01);

    do
        {
        status = CO_SubmitSyncRead(p, pBuffer, pBufferLength);

        if (status != RPC_P_IO_PENDING)
            {
            ASSERT(status != RPC_S_CALL_CANCELLED);
            break;
            }

        status = UTIL_GetOverlappedResultEx(ThisConnection,
                                            &p->Read.ol,
                                            &bytes,
                                            TRUE, // Alertable
                                            dwTimeout);

        if (status != RPC_S_OK)
            {
            if (status != ERROR_MORE_DATA)
                {
                RpcpErrorAddRecord(EEInfoGCIO,
                    status, 
                    EEInfoDLCOSyncRecv10);
                if ((status != RPC_S_CALL_CANCELLED) && (status != RPC_P_TIMEOUT))
                    {
                    status = RPC_P_RECEIVE_FAILED;
                    }

                break;
                }

            // ERROR_MORE_DATA is success
            }


        status = p->ProcessRead(bytes, pBuffer, pBufferLength);

        }
    while (status == RPC_P_PARTIAL_RECEIVE);

    if (status == RPC_S_OK)
        {
        ASSERT(p->pReadBuffer == 0);

        return(RPC_S_OK);
        }

    p->Abort();

    if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
        {
        // Wait for the read to complete.  Since the connection has
        // just been closed this won't take very long.
        UTIL_WaitForSyncIO(&p->Read.ol,
                           FALSE,
                           INFINITE);
        }

    return(status);
}

void 
BASE_CONNECTION::Initialize (
    void
    )
/*++

Routine Description:

    Initializes a base connection. Prior initialization
    ensures orderly cleanup.

Arguments:

Return Value:

--*/
{
    type = CLIENT | CONNECTION;
    pReadBuffer = 0;
    Conn.Handle = 0;
    fAborted = FALSE;
    pReadBuffer = 0;
    maxReadBuffer = 0;
    iPostSize = gPostSize;
    iLastRead = 0;
    RpcpMemorySet(&Read.ol, 0, sizeof(Read.ol));
    Read.pAsyncObject = this;
    Read.thread       = 0;
    InitIoCounter();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\dgtrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    dgtrans.cxx

Abstract:

    Common code for winsock-based datagram transports.

Author:

    Dave Steckler (davidst)   15-Mar-1993
    Jeff Roberts (jroberts)   02-Dec-1994
    Mario Goertzel (mariogo)  10-Apr-1996
    Michael Burton (t-mburt)  05-Sep-1997
    Charlie Wickham (charlwi) 01-Oct-1997

Revision History:

    Dave wrote a version.
    Connie changed it but forgot to add her name.
    Jeff made it work.
    Mario rewrote most of it for NT and io completion ports.

    MarioGo    12/10/1996  Changes for async support, added client
    t-mburt    09/05/1997  Added prelim support for clusters
    charlwi    10/01/1997  Finished cluster work

--*/
#include <precomp.hxx>
#include <trans.hxx>
#include <dgtrans.hxx>
#include <wswrap.hxx>

#ifdef NCADG_MQ_ON
#include "mqtrans.hxx"
#endif

//
// If a datagram send doesn't complete within 5 seconds, abort it.
//
#define DG_SEND_TIMEOUT (5000)

// Cluster SOCKADDR_CLUSTER initialization routine
inline void
CDP_InitLocalAddress(
    SOCKADDR_CLUSTER *Address,
    unsigned short Endpoint
    )
{
    Address->sac_family       = AF_CLUSTER;
    Address->sac_node         = CLUSADDR_ANY;
    Address->sac_port         = Endpoint;
    Address->sac_zero         = 0;
}

extern RPC_STATUS CDP_InitializeSockAddr(char *Endpoint, WS_SOCKADDR *);
extern RPC_STATUS UDP_InitializeSockAddr(char *Endpoint, WS_SOCKADDR *);

#ifdef IPX_ON
extern RPC_STATUS IPX_InitializeSockAddr(char *Endpoint, WS_SOCKADDR *);
#endif

const DG_TRANS_INFO DgTransportTable[] =
{
    // UDP
    {
    AF_INET,
    SOCK_DGRAM,
    IPPROTO_UDP,
    0x40000,
    0x10000,
    UDP_InitializeSockAddr
    },

#ifdef IPX_ON
    // IPX
    {
    AF_IPX,
    SOCK_DGRAM,
    NSPROTO_IPX,
    0x40000,
    0x10000,
    IPX_InitializeSockAddr
    },
#else
    // IPX
    {
    0,
    0,
    0,
    0,
    0,
    0
    },
#endif

    // CDP
    {
    AF_CLUSTER,
    SOCK_DGRAM,
    CLUSPROTO_CDP,
    0x40000,
    0x10000,
    CDP_InitializeSockAddr
    }

};

inline const DG_TRANS_INFO *GetDgTransportInfo(PROTOCOL_ID id)
{
#ifdef IPX_ON
    ASSERT(id == UDP || id == IPX || id == CDP);
#else
    ASSERT(id == UDP || id == CDP);
#endif

    return &DgTransportTable[id - UDP];
}

typedef const DG_TRANS_INFO *PDG_TRANS_INFO;

// may be TRUE only for rpcss. For all others it's FALSE
BOOL fWSARecvMsgFnPtrInitialized = FALSE;
const UUID WSARecvMsgFnPtrUuid = WSAID_WSARECVMSG;


////////////////////////////////////////////////////////////////////////
//
// Generic datagram (winsock and NT based) routines.
//

RPC_STATUS
DG_SubmitReceive(IN PWS_DATAGRAM_ENDPOINT pEndpoint,
                 IN PWS_DATAGRAM pDatagram)
/*++

Arguments:

    pEndpoint - The endpoint on which the receive should be posted.
    pDatagram - The datagram object to manage the receive.

Return Value:

    RPC_P_IO_PENDING - OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/

{
    RPC_STATUS status;
    NTSTATUS NtStatus;
    DWORD bytes, flags;
    int err;

    if (pDatagram->Packet.buf == 0)
        {
        status = I_RpcTransDatagramAllocate(pEndpoint,
                                            (BUFFER *)&pDatagram->Packet.buf,
                                            (PUINT)   &pDatagram->Packet.len,
                                            &pDatagram->AddressPair);

        if (status != RPC_S_OK)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        pDatagram->AddressPair->LocalAddress
            = WSA_CMSG_DATA(&pDatagram->MessageAncillaryData)
              + FIELD_OFFSET(in_pktinfo, ipi_addr);

        ASSERT( pDatagram->Packet.buf );
        }

    ASSERT(*(PDWORD)pDatagram->Packet.buf = 0xDEADF00D);
    bytes = flags = 0;

    if (!fWSARecvMsgFnPtrInitialized)
        {
        pDatagram->cRecvAddr = sizeof(WS_SOCKADDR);

        err = WSARecvFrom(((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket,
                              &pDatagram->Packet,
                              1,
                              &bytes,
                              &flags,
                              &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic,
                              &pDatagram->cRecvAddr,
                              &pDatagram->Read.ol,
                              0);
        }
    else
        {
        pDatagram->Msg.lpBuffers = &pDatagram->Packet;
        pDatagram->Msg.name = &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic;
        pDatagram->Msg.namelen = sizeof(WS_SOCKADDR);
        pDatagram->Msg.dwBufferCount = 1;
        pDatagram->Msg.Control.buf = (char *)pDatagram->MessageAncillaryData;
        pDatagram->Msg.Control.len = sizeof(pDatagram->MessageAncillaryData);
        pDatagram->Msg.dwFlags = 0;
        err = WSARecvMsg(((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket,
                              &pDatagram->Msg,
                              &bytes,
                              &pDatagram->Read.ol,
                              0);
        }
    #if 0
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "ERROR: RecvFrom: %p buf %p (%d bytes) status %d\n",
                   pDatagram,
                   pDatagram->Packet.buf,
                   pDatagram->Packet.len,
                   err == 0 ? 0 : GetLastError()));
    #endif

    if (err == NO_ERROR)
        {
        return(RPC_P_IO_PENDING);
        }

    status = GetLastError();
    if (   status == ERROR_IO_PENDING
        || status == WSAEMSGSIZE )
        {
        // WSAEMSGSIZE will be handled in complete.cxx.  This is like "NO_ERROR"
        return(RPC_P_IO_PENDING);
        }

    RpcpErrorAddRecord( EEInfoGCWinsock,
                        status,
                        EEInfoDLWinsockDatagramSubmitReceive10,
                        ((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket
                        );

    if (WSAECONNRESET == status)
        {
        return RPC_P_PORT_DOWN;
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "WSARecvFrom failed %p\n",
                   GetLastError()));

    return(RPC_S_OUT_OF_RESOURCES);
}


void
DG_SubmitReceives(
    BASE_ADDRESS *ThisEndpoint
    )
/*++

Routine Description:

    Helper function called when the pending IO count
    on an address is too low.

Arguments:

    ThisEndpoint - The address to submit IOs on.

Return Value:

    None

--*/
{
    PWS_DATAGRAM pDg;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;

    if (pEndpoint->Socket == 0)
        {
        //
        // The address is currently deactivated, don't submit more I/O
        //
        return;
        }

    do
        {
        BOOL fIoSubmitted;

        fIoSubmitted = FALSE;

        // Only one thread should be trying to submit IOs at a time.
        // This saves locking each DATAGRAM object.

        // Simple lock - but requires a loop. See the comment at the end
        // of the loop.

        if (pEndpoint->fSubmittingIos != 0)
            break;

        if (InterlockedIncrement(&pEndpoint->fSubmittingIos) != 1)
            break;

        // Submit new IOs on all the idle datagram objects

        for (int i = 0; i < pEndpoint->cMaximumIos; i++)
            {
            pDg = &pEndpoint->aDatagrams[i];

            if (pDg->Busy)
                {
                continue;
                }

            // Must be all set for the IO to complete before trying
            // to submit the IO.
            InterlockedIncrement(&pEndpoint->cPendingIos);
            pDg->Busy = TRUE;

            if (DG_SubmitReceive(pEndpoint, pDg) == RPC_P_IO_PENDING)
                {
                fIoSubmitted = TRUE;
                }
            else
                {
                pDg->Busy = FALSE;
                InterlockedDecrement(&pEndpoint->cPendingIos);
                break;
                }
            }

        // Release the "lock" on the endpoint object.
        pEndpoint->fSubmittingIos = 0;

        if (!fIoSubmitted && pEndpoint->cPendingIos == 0)
            {
            // It appears that no IO is pending on the endpoint.
            COMMON_AddressManager(pEndpoint);
            return;
            }

        // Even if we submitted new IOs, they may all have completed
        // already.  Which means we may need to loop and submit more
        // IOs.  This is needed since the thread which completed the
        // last IO may have run into our lock and returned.
        }
    while (pEndpoint->cPendingIos == 0);

    return;
}

RPC_STATUS RPC_ENTRY
DG_SendPacket(
    IN DG_TRANSPORT_ENDPOINT        ThisEndpoint,
    IN DG_TRANSPORT_ADDRESS         pAddress,
    IN BUFFER                       pHeader,
    IN unsigned                     cHeader,
    IN BUFFER                       pBody,
    IN unsigned                     cBody,
    IN BUFFER                       pTrailer,
    IN unsigned                     cTrailer
    )
/*++

Routine Description:

    Sends a packet to an address.

    The routine will send a packet built out of the three buffers supplied.
    All the buffers are optional, the actual packet sent will be built from
    all the buffers actually supplied.  In each call at least buffer should
    NOT be null.

Arguments:

    ThisEndpoint  - Endpoint to send from.
    pAddress      - Address to send to.

    pHeader       - First data buffer
    cHeader       - Size of the first data buffer or 0.

    pBody         - Second data buffer
    cBody         - Size of the second data buffer or 0.

    pTrailer      - Third data buffer.
    cTrailer      - Size of the first data buffer or 0.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_P_SEND_FAILED

--*/
{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR* pSockAddr = (WS_SOCKADDR *)pAddress;
    WSABUF buffers[3];
    int cBuffers;
    HANDLE hIoEvent;

    DWORD Status = 0;

    if (pHeader)
        {
        CallTestHook( TH_X_DG_SEND, pHeader, &Status );
        }
    else
        {
        CallTestHook( TH_X_DG_SEND, pBody, &Status );
        }

    if (Status)
        {
        return Status;
        }

    hIoEvent = I_RpcTransGetThreadEvent();

    cBuffers = 0;
    if (cHeader)
        {
        buffers[cBuffers].len = cHeader;
        buffers[cBuffers].buf = (PCHAR) pHeader;
        cBuffers++;
        }
    if (cBody)
        {
        buffers[cBuffers].len = cBody;
        buffers[cBuffers].buf = (PCHAR) pBody;
        cBuffers++;
        }
    if (cTrailer)
        {
        buffers[cBuffers].len = cTrailer;
        buffers[cBuffers].buf = (PCHAR) pTrailer;
        cBuffers++;
        }
    ASSERT(cBuffers);

    // All RPC packets have version 4.
    //
    ASSERT( buffers[0].buf[0] == 4 );


    OVERLAPPED ol;
    ol.hEvent = (HANDLE)(ULONG_PTR(hIoEvent) | 1);
    DWORD bytes;

    if ( WSASendTo(pEndpoint->Socket,
                   buffers,
                   cBuffers,
                   &bytes,
                   0,
                   &pSockAddr->generic,
                   WsTransportTable[pEndpoint->id].SockAddrSize,
                   &ol,
                   0) != 0)
        {
        DWORD Status = GetLastError();

        RpcpErrorAddRecord( EEInfoGCWinsock,
                            Status,
                            EEInfoDLWinsockDatagramSend10,
                            PULONG(&pSockAddr->generic)[0],
                            PULONG(&pSockAddr->generic)[1]
                            );

        if (WSAENETUNREACH == Status)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "WSASendTo failed with net unreachable\n",
                            GetLastError()));

            return RPC_P_PORT_DOWN;
            }

        if (WSAEHOSTDOWN == Status)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "WSASendTo failed with host down\n",
                            GetLastError()));
            return RPC_P_HOST_DOWN;
            }

        if (Status != WSA_IO_PENDING)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "WSASendTo failed %d\n",
                            GetLastError()));

            return(RPC_P_SEND_FAILED);
            }

        if (WAIT_OBJECT_0 != WaitForSingleObject( hIoEvent, DG_SEND_TIMEOUT ))
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "Dg Send timed out\n"));

            //
            // Cancel the send and wait for it to complete.
            //
            CancelIo( (HANDLE)pEndpoint->Socket );

            GetOverlappedResult((HANDLE)pEndpoint->Socket,
                                     &ol,
                                     &bytes,
                                     TRUE);

            return(RPC_P_SEND_FAILED);
            }

        BOOL b = GetOverlappedResult((HANDLE)pEndpoint->Socket,
                                     &ol,
                                     &bytes,
                                     TRUE);

        if (!b)
            {
            TransDbgDetail((DPFLTR_RPCPROXY_ID,
                            DPFLTR_INFO_LEVEL,
                            RPCTRANS "Dg Send wait failed %d\n",
                            GetLastError()));

            return(RPC_P_SEND_FAILED);
            }
        }

    ASSERT(bytes == cHeader + cBody + cTrailer);

    if (pEndpoint->cMinimumIos &&
        pEndpoint->cPendingIos <= pEndpoint->cMinimumIos)
        {
        // It's ok if this fails, this is just a performance optimization.
        // Right after a send there often "idle" time waiting for the response
        // so this is a good time to submit receives.

        DG_SubmitReceives(pEndpoint);
        }

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
DG_ForwardPacket(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BUFFER                pHeader,
    IN unsigned              cHeader,
    IN BUFFER                pBody,
    IN unsigned              cBody,
    IN BUFFER                pTrailer,
    IN unsigned              cTrailer,
    IN CHAR *                pszPort
    )

/*++

Routine Description:

    Sends a packet to the server it was originally destined for (that
    is, the client had a dynamic endpoint it wished the enpoint mapper
    to resolve and forward the packet to).

Arguments:

    ThisEndpoint      - The endpoint to forward the packet from.

    // Buffer like DG_SendPacket

    pszPort           - Pointer to the server port num to forward to.
                        This is in an Ansi string.

Return Value:

    RPC_S_CANT_CREATE_ENDPOINT - pEndpoint invalid.

    results of SendPacket().

--*/

{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR  SockAddr;
    PDG_TRANS_INFO pInfo = GetDgTransportInfo(pEndpoint->id);

    ASSERT(pEndpoint->type | SERVER);

    if (pInfo->EndpointToAddr(pszPort, &SockAddr) != RPC_S_OK)
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }

    return ( DG_SendPacket(ThisEndpoint,
                           (PVOID)&SockAddr,
                           pHeader,
                           cHeader,
                           pBody,
                           cBody,
                           pTrailer,
                           cTrailer) );
}

RPC_STATUS
RPC_ENTRY
DG_ReceivePacket(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer,
    IN LONG Timeout
    )
/*++

Routine Description:

    Used to wait for a datagram from a server.  Returns the data
    returned and the address of the machine which replied.

    This is a blocking API. It should only be called during sync
    client RPC threads.

Arguments:

    Endpoint - The endpoint to receive from.
    ReplyAddress - Contain the source address of the datagram if
        successful.
    BufferLength - The size of Buffer on input, the size of the
        datagram received on output.
    Timeout - Milliseconds to wait for a datagram.

Return Value:

    RPC_S_OK

    RPC_P_OVERSIZE_PACKET - Datagram > BufferLength arrived,
        first BufferLength bytes of Buffer contain the partial datagram.

    RPC_P_RECEIVE_FAILED

    RPC_P_TIMEOUT
--*/
{
    RPC_STATUS status;
    BOOL b;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    PWS_DATAGRAM pDatagram = &pEndpoint->aDatagrams[0];
    DWORD bytes;
    DWORD flags;
    int err;

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->aDatagrams[0].Read.ol.hEvent);

    DWORD Status = 0;

    CallTestHook( TH_X_DG_SYNC_RECV, ThisEndpoint, &Status );

    if (Status)
        {
        return Status;
        }

    if (pDatagram->Busy == 0)
        {
        if (pEndpoint->aDatagrams[0].Packet.buf == 0)
            {
            status = I_RpcTransDatagramAllocate(pEndpoint,
                                                (BUFFER *)&pDatagram->Packet.buf,
                                                (PUINT)   &pDatagram->Packet.len,
                                                &pDatagram->AddressPair);

            if (status != RPC_S_OK)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }

            pDatagram->cRecvAddr = sizeof(WS_SOCKADDR);
            pDatagram->AddressPair->LocalAddress
                = WSA_CMSG_DATA(&pDatagram->MessageAncillaryData)
                  + FIELD_OFFSET(in_pktinfo, ipi_addr);

            ASSERT( pDatagram->Packet.buf );
            }

        bytes = flags = 0;

        if (!fWSARecvMsgFnPtrInitialized)
            {
            err = WSARecvFrom(pEndpoint->Socket,
                         &pDatagram->Packet,
                         1,
                         &bytes,
                         &flags,
                         &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic,
                         &pDatagram->cRecvAddr,
                         &pDatagram->Read.ol,
                         0);
            }
        else
            {
            pDatagram->Msg.lpBuffers = &pDatagram->Packet;
            pDatagram->Msg.name = &((WS_SOCKADDR *)pDatagram->AddressPair->RemoteAddress)->generic;
            pDatagram->Msg.namelen = sizeof(WS_SOCKADDR);
            pDatagram->Msg.dwBufferCount = 1;
            pDatagram->Msg.Control.buf = (char *)&pDatagram->MessageAncillaryData;
            pDatagram->Msg.Control.len = sizeof(pDatagram->MessageAncillaryData);
            pDatagram->Msg.dwFlags = 0;

            err = WSARecvMsg(((WS_DATAGRAM_ENDPOINT*)(pDatagram->pEndpoint))->Socket,
                                  &pDatagram->Msg,
                                  &bytes,
                                  &pDatagram->Read.ol,
                                  0);
            }

        if ( err != 0)
            {

            status = GetLastError();

            if (status != WSA_IO_PENDING)
                {
                RpcpErrorAddRecord( EEInfoGCWinsock,
                                    status,
                                    EEInfoDLWinsockDatagramReceive10,
                                    pEndpoint->Socket
                                    );

                if (status == WSAEMSGSIZE)
                    {
                    status = RPC_P_OVERSIZE_PACKET;
                    }
                else if (status == WSAECONNRESET)
                    {
                    return RPC_P_PORT_DOWN;
                    }
                else
                    {
                    // No need to free the packet now.
                    TransDbgDetail((DPFLTR_RPCPROXY_ID,
                                    DPFLTR_INFO_LEVEL,
                                    RPCTRANS "WSARecvFrom failed %d\n",
                                    status));

                    ASSERT(pDatagram->Busy == 0);
                    return(RPC_P_RECEIVE_FAILED);
                    }
                }
            else
                {
                status = RPC_P_IO_PENDING;
                }
            }
        else
            {
            status = RPC_S_OK;
            }

        pDatagram->Busy = TRUE;
        }
    else
        {
        ASSERT(pDatagram->Busy);
        ASSERT(pDatagram->Packet.buf);

        status = RPC_P_IO_PENDING;
        }

    // Wait for IO to complete or timeout

    if (status == RPC_P_IO_PENDING)
        {
        status = WaitForSingleObjectEx(pDatagram->Read.ol.hEvent,
                                       Timeout,
                                       TRUE);

        if (status != STATUS_WAIT_0)
            {
            // In the timeout case we just want to return and
            // leave.  We'll finish the receive on the next call.
            if (status == WAIT_IO_COMPLETION)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "DG received cancelled (%p)\n",
                               pDatagram));
                }
            else
                {
                ASSERT(status == STATUS_TIMEOUT);
                }

            ASSERT(pDatagram->Busy);

            return(RPC_P_TIMEOUT);
            }

        BOOL b = GetOverlappedResult((HANDLE)pEndpoint->Socket,
                                     &pDatagram->Read.ol,
                                     &bytes,
                                     FALSE);

        if (!b)
            {
            RpcpErrorAddRecord( EEInfoGCWinsock,
                                GetLastError(),
                                EEInfoDLWinsockDatagramSend20,
                                pEndpoint->Socket
                                );

            switch (GetLastError())
                {
                case WSAEMSGSIZE:
                case ERROR_MORE_DATA:
                    ASSERT(bytes == pDatagram->Packet.len);
                    status = RPC_P_OVERSIZE_PACKET;
                    break;

                case ERROR_PORT_UNREACHABLE:
                    pDatagram->Busy = 0;
                    return RPC_P_PORT_DOWN;
                    break;

                case STATUS_TIMEOUT:
                    ASSERT(0);

                case ERROR_OPERATION_ABORTED:
                    // ERROR_OPERATION_ABORTED can occur if one thread
                    // tried to make a call and failed, leaving a pending
                    // receive.  That thread dies.  Then the endpoint is
                    // reused by a different thread and the IO is aborted.
                    // Returning receive failed will cause the runtime to
                    // retransmit which will do the right thing.
                default:
                    TransDbgDetail((DPFLTR_RPCPROXY_ID,
                                    DPFLTR_INFO_LEVEL,
                                    RPCTRANS "DG sync recv failed %d\n",
                                    GetLastError()));

                    pDatagram->Busy = 0;
                    return(RPC_P_RECEIVE_FAILED);
                    break;
                }
            }
        else
            {
            status = RPC_S_OK;
            }
        }

    ASSERT(   status == RPC_S_OK
           || status == RPC_P_OVERSIZE_PACKET);

    ASSERT(pDatagram->Busy);
    ASSERT(pDatagram->Packet.buf);
    ASSERT(bytes <= pDatagram->Packet.len);

    *pBuffer = (BUFFER)pDatagram->Packet.buf;
    *pBufferLength = bytes;
    *pReplyAddress = pDatagram->AddressPair->RemoteAddress;

    pDatagram->Packet.buf = 0;
    pDatagram->Busy = 0;

    return(status);
}

RPC_STATUS
DG_CreateEndpoint(
    OUT WS_DATAGRAM_ENDPOINT *pEndpoint
    )
/*++

Routine Description:

    Creates a new endpoint.

Arguments:

    pEndpoint - The runtime allocated endpoint structure to
        filled in.

    pSockAddr - An initialized sockaddr with the correct
        (or no) endpoint.

    id - The id of the protocol to use in creating the address.

    fClient - If TRUE this is a client endpoint

    fAsync  - If TRUE this endpoint is "async" which means that
        a) It should be added to the IO completion port and
        b) that the transport should pend a number of receives
        on the endpoint automatically.

    EndpointFlags - used in allocation IP ports.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_DATAGRAM pDatagram;
    int i, err;
    int length;
    RPC_STATUS status = RPC_S_OK;
    SOCKET sock = 0;
    PDG_TRANS_INFO pInfo = GetDgTransportInfo(pEndpoint->id);
    BOOL fClient = pEndpoint->fClient;
    BOOL fAsync = pEndpoint->fAsync;
    LPFN_WSARECVMSG WSARecvMsgFnPtr;
    DWORD dwBytesReturned;

    // Common stuff

    pEndpoint->type = DATAGRAM | ADDRESS;
    pEndpoint->Socket = 0;
    pEndpoint->Endpoint = 0;
    pEndpoint->pAddressVector = 0;
    pEndpoint->SubmitListen = DG_SubmitReceives;
    pEndpoint->InAddressList = NotInList;
    pEndpoint->pNext = 0;
    pEndpoint->fSubmittingIos = 0;
    pEndpoint->cPendingIos = 0;
    pEndpoint->cMinimumIos = 0;
    pEndpoint->cMaximumIos = 0;
    pEndpoint->aDatagrams  = 0;
    pEndpoint->pFirstAddress = pEndpoint;
    pEndpoint->pNextAddress = 0;
    pEndpoint->fAborted = 0;

    if (fClient)
        {
        pEndpoint->type |= CLIENT;
        }
    else
        {
        pEndpoint->type |= SERVER;
        }

    //
    // Check if we can use a wrapper around the AFD send/recv
    // IOCTLs instead WSASendTo.
    //
    TryUsingAfd();

    //
    // Create the socket.
    //
    sock = WSASocketT(pInfo->AddressFamily,
                      pInfo->SocketType,
                      pInfo->Protocol,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);

    if (sock == INVALID_SOCKET)
        {
        RpcpErrorAddRecord( EEInfoGCWinsock,
                            GetLastError(),
                            EEInfoDLWinsockDatagramCreate10,
                            (ULONG) pInfo->AddressFamily,
                            (ULONG) pInfo->Protocol
                            );

        switch(GetLastError())
            {
            case WSAEAFNOSUPPORT:
            case WSAEPROTONOSUPPORT:
            case WSAENETDOWN:
            case WSAESOCKTNOSUPPORT:
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            case WSAENOBUFS:
            case WSAEMFILE:
            case WSA_NOT_ENOUGH_MEMORY:
                status = RPC_S_OUT_OF_MEMORY;
                break;

            default:
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "DG socket() returned 0x%lx\n",
                               GetLastError()));

                ASSERT(0);
                // no break

            case WSAEPROVIDERFAILEDINIT:
                status = RPC_S_OUT_OF_RESOURCES;
                break;
            }
        return(status);
        }

    if (fWSARecvMsgFnPtrInitialized == FALSE)
        {
        // if the AddressChangeFn is non-default (i.e. we are in RPCSS),
        // use WSARecvMsg so that we can retrieve the local address as
        // well
        if (AddressChangeFn && (AddressChangeFn != NullAddressChangeFn))
            {
            // retrieve the WSARecvMsg function pointer
            err = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, (void *) &WSARecvMsgFnPtrUuid,
                sizeof(UUID), (void *) &WSARecvMsgFnPtr, sizeof(void *), &dwBytesReturned,
                NULL, NULL);

            if (err == SOCKET_ERROR)
                {
                closesocket(sock);
                return RPC_S_PROTSEQ_NOT_SUPPORTED;
                }

            WFT.pWSARecvMsg = WSARecvMsgFnPtr;
            fWSARecvMsgFnPtrInitialized = TRUE;
            }
        }


    //
    // Make the handle non-inheritable so it goes away when we close it.
    //
    if (FALSE == SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0))
        {
        closesocket(sock);
        return RPC_S_OUT_OF_RESOURCES;
        }

    //
    // Protect the socket to prevent another server from using our port.
    //

    WS_ProtectListeningSocket(sock, TRUE);

    //
    // Bind the socket to the endpoint (or to a dynamic endpoint)
    //

    status = WS_Bind(sock,
                     &pEndpoint->ListenAddr,
                     (pEndpoint->id == UDP),
                     pEndpoint->EndpointFlags);

    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return(status);
        }

    pEndpoint->Socket = sock;

    //
    // Turn on ring buffering for server- and client-side async endpoints.
    // Any error is ignored.
    //
    if (fAsync || !fClient)
        {
        DWORD BytesReturned;
        if (0 != WSAIoctl( sock, SIO_ENABLE_CIRCULAR_QUEUEING, 0, 0, 0, 0, &BytesReturned, 0, 0 ))
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG couldn't enable circular queueing 0x%lx\n",
                           GetLastError()));
            }
        }

    if (!fClient)
        {
        //
        // Set server socket recv buffer size..
        //

        int size;
        int PacketInfoOn = TRUE;

        if (gfServerPlatform == TRUE && gPhysicalMemorySize >= 40)
            {
            size = pInfo->ServerBufferSize;
            }
        else
            {
            size = pInfo->WorkstationBufferSize;
            }

        if (fWSARecvMsgFnPtrInitialized)
            {
            err = setsockopt(sock,
                             IPPROTO_IP,
                             IP_PKTINFO,
                             (char *)&PacketInfoOn,
                             sizeof(PacketInfoOn)
                             );
            if (err != 0)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "DG couldn't set packet info %d\n",
                               GetLastError()));

                closesocket(sock);
                return(RPC_S_OUT_OF_MEMORY);
                }
            }

        err = setsockopt(sock,
                         SOL_SOCKET,
                         SO_RCVBUF,
                         (char *) &size,
                          sizeof(size)
                          );
        #if DBG
        if (err != 0)
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG couldn't set buffer size %d\n",
                           GetLastError()));
        #endif
        }
    else
        {
        // Enable broadcast send on the client

        DWORD option = TRUE;

        err = setsockopt(sock,
                         SOL_SOCKET,
                         SO_BROADCAST,
                         (PCHAR)&option,
                         sizeof(option));

        ASSERT(err == 0);
        }

    //
    // If the endpoint is going to async initialize async part
    // and add the socket to the IO completion port.
    //

    if (status == RPC_S_OK)
        {
        int cMaxIos;
        int cMinIos;

        ASSERT(fAsync || fClient);

        // Step one, figure out the high and low mark for ios.

        if (fAsync)
            {
            cMinIos = 1;
            cMaxIos = 2;

            if (gPhysicalMemorySize >= 40)    // megabytes
                {
                cMaxIos = 2
                          + (gfServerPlatform == TRUE) * 2
                          + (fClient == FALSE) * gNumberOfProcessors;

                // This should be larger than zero so that we'll generally submit new
                // recvs during idle time rather then just after receiving a datagram.
                cMinIos = 1 + (fClient == FALSE ) * (gNumberOfProcessors/2);
                }
            }
        else
            {
            // For sync endpoints we need to allocate a single datagram
            // object for the receive.
            cMinIos = 0;
            cMaxIos = 1;
            }

        ASSERT(cMinIos < cMaxIos);

        pEndpoint->cMinimumIos = cMinIos;
        pEndpoint->cMaximumIos = cMaxIos;

        // Allocate a chunk on memory to hold the array of datagrams

        // PERF: For clients, allocate larger array but don't submit all
        // the IOs unless we determine that the port is "really" active.

        pEndpoint->aDatagrams = new WS_DATAGRAM[cMaxIos];

        if (pEndpoint->aDatagrams)
            {
            UINT type;
            type = DATAGRAM | RECEIVE;
            type |= (fClient) ? CLIENT : SERVER;

            for (i = 0; i < cMaxIos; i++)
                {
                pDatagram = &pEndpoint->aDatagrams[i];

                pDatagram->id = pEndpoint->id;
                pDatagram->type = type;
                pDatagram->pEndpoint = pEndpoint;
                pDatagram->Busy = 0;
                pDatagram->Packet.buf = 0;
                memset(&pDatagram->Read, 0, sizeof(pDatagram->Read));
                pDatagram->Read.pAsyncObject = pDatagram;
                }

            if (fAsync)
                {
                status = COMMON_PrepareNewHandle((HANDLE)sock);
                }
            else
                {
                // The receive operation on sync endpoints will may span
                // several receives.  This means it can't use the thread
                // event, so allocate an event for the receive.
                HANDLE hEvent = CreateEventW(0, TRUE, FALSE, 0);
                if (!hEvent)
                    {
                    status = RPC_S_OUT_OF_RESOURCES;
                    }
                else
                    {
                    ASSERT(pDatagram == &pEndpoint->aDatagrams[0]);
                    pDatagram->Read.ol.hEvent = hEvent;
                    }
                }
            }
        else
            {
            status = RPC_S_OUT_OF_MEMORY;
            }
        }

    // If adding a new failure case here, add code to close the sync receive event.

    if (status != RPC_S_OK)
        {
        closesocket(sock);

        delete pEndpoint->aDatagrams;

        return(status);
        }

    TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) pEndpoint);

    if (!fClient)
        {
        TransportProtocol::FunctionalProtocolDetected(pEndpoint->id);
        }

    return(RPC_S_OK);
}


VOID
DG_DeactivateAddress (
    IN WS_DATAGRAM_ENDPOINT *pEndpoint
    )
/*++
Function Name:DG_DeactivateAddress

Parameters:

Description:

Returns:

--*/
{
    if (InterlockedIncrement(&pEndpoint->fAborted) != 1)
        {
        return;
        }

    if (pEndpoint->Socket)
        {
        closesocket(pEndpoint->Socket);
        pEndpoint->Socket = 0;
        }
}


RPC_STATUS
DG_ReactivateAddress (
    IN WS_DATAGRAM_ENDPOINT *pEndpoint
    )
/*++
Function Name:DG_DeactivateAddress

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    //
    // If the endpoint is dynamic, clear out the endpoint
    //
    if (pEndpoint->fDynamicEndpoint)
        {
        //
        // Clear out the listenaddr
        //
        switch (pEndpoint->id)
            {
#ifdef IPX_ON
            case IPX:
                addr->ipxaddr.sa_socket = 0;
                break;
#endif

            case CDP:
                CDP_InitLocalAddress(&addr->clusaddr, 0);
                break;

            case UDP:
                addr->inetaddr.sin_port = 0;
                break;

            default:
                ASSERT(0);
            }
        }

    Status = DG_CreateEndpoint(pEndpoint);
    if (Status == RPC_S_OK)
        {
        pEndpoint->fAborted = 0;
        DG_SubmitReceives(pEndpoint);
        }

    return Status;
}


void RPC_ENTRY
DG_ServerAbortListen(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Callback after DG_CreateEndpoint has completed successfully
    but the runtime for some reason is not going to be able to
    listen on the endpoint.

--*/
{
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;

    ASSERT(pEndpoint->cPendingIos == 0);
    ASSERT(pEndpoint->Socket);
    ASSERT(pEndpoint->pNext == 0);
    ASSERT(pEndpoint->type & SERVER);

    delete pEndpoint->pAddressVector;
    delete pEndpoint->aDatagrams;
    closesocket(pEndpoint->Socket);

    return;
}

RPC_STATUS RPC_ENTRY
DG_ClientCloseEndpoint(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Called on sync client endpoints when they are no longer needed.

Arguments:

    ThisEndpoint

Return Value:

    RPC_S_OK

--*/
{
    BOOL b;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    PWS_DATAGRAM pDatagram = &pEndpoint->aDatagrams[0];

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->Socket);  // Open must have worked
    ASSERT(pEndpoint->cMinimumIos == 0);
    ASSERT(pEndpoint->cMaximumIos == 1); // Must not be async!
    ASSERT(pEndpoint->aDatagrams);
    ASSERT(pEndpoint->aDatagrams[0].Read.ol.hEvent);
    ASSERT(pEndpoint->Endpoint == 0);
    ASSERT(pEndpoint->pAddressVector == 0);
    ASSERT(pEndpoint->pNext == 0);

    // If there is a pending receive, closing the socket will cancel the IO.
    closesocket(pEndpoint->Socket);

    // Wait for the pending receive to actually complete.

    if (pDatagram->Busy)
        {
        DWORD bytes;
        ASSERT(pDatagram->Busy);
        ASSERT(pDatagram->Packet.buf);

        GetOverlappedResult((HANDLE)pEndpoint->Socket,
                            &pDatagram->Read.ol,
                            &bytes,
                            TRUE);

        if (GetLastError() != ERROR_OPERATION_ABORTED)
            {
            // Overactive output, the receive may have completed normally..
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG receive completed %d on %p after closed\n",
                           GetLastError(),
                           pDatagram));
            }
        }

    b = CloseHandle(pEndpoint->aDatagrams[0].Read.ol.hEvent);
    ASSERT(b);

    TransportProtocol::RemoveObjectFromProtocolList(pEndpoint);

    // Free the receive buffer if allocated

    if (pDatagram->Packet.buf)
        {
        I_RpcTransDatagramFree(pEndpoint,
                               (BUFFER)pDatagram->Packet.buf
                               );
        }

    delete pDatagram;

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
DG_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    DWORD Status;
    DWORD Data;
    int   Length;
    BOOL  Ok;

    PWS_DATAGRAM_ENDPOINT Endpoint = (PWS_DATAGRAM_ENDPOINT) ThisEndpoint;

    Length = sizeof(DWORD);

    Status = getsockopt(Endpoint->Socket, SOL_SOCKET, SO_MAX_MSG_SIZE, (char *) &Data, &Length);
    if (Status)
        {
        return GetLastError();
        }

    //
    // jroberts, 10-Jan-2001 : I believe that getsockopt is returning 0xffffffff occasionally.
    // This is an attempt to catch it.
    //
    if (Endpoint->id == UDP)
        {
        ASSERT( Data < 0x10000 );
        }

    Data &= ~7UL;

    pStats->MaxPduSize = Data;

    Length = sizeof(DWORD);

    Status = getsockopt(Endpoint->Socket, SOL_SOCKET, SO_RCVBUF, (char *) &Data, &Length);
    if (Status)
        {
        return GetLastError();
        }

    Data &= ~7UL;
    pStats->ReceiveBufferSize = Data;

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// CDP/IP specific functions.
//

RPC_STATUS RPC_ENTRY
CDP_ServerListen(
    IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
    IN RPC_CHAR      *NetworkAddress,
    IN OUT RPC_CHAR **pPort,
    IN     void      *pSecurityDescriptor,
    IN     ULONG      EndpointFlags,
    IN     ULONG      NICFlags,
    OUT    NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
    )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    pPort - The endpoint to listen on or a pointer to 0 if
        the transport should choose the address.
        Contains the endpoint listened to on output.  The
        caller should free this.
    pSecurityDiscriptor - Security to attach to this endpoint (not
        used by this transport).
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS      status;
    NTSTATUS        NtStatus;
    USHORT          port;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AsciiString;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;
    NETWORK_ADDRESS_VECTOR * ServerAddress;

    // Figure out the port to listen on.

    if (*pPort)
        {
        status = EndpointToPortNumber(*pPort, port);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        pEndpoint->fDynamicEndpoint = 0;

        CDP_InitLocalAddress( &addr->clusaddr, port );
        }
    else
        {
        return RPC_S_INVALID_ENDPOINT_FORMAT;
        }

    pEndpoint->id = CDP;
    pEndpoint->fClient = FALSE;
    pEndpoint->fAsync = TRUE;
    pEndpoint->EndpointFlags = 0;

    //
    // Actually create the endpoint
    //
    status =
    DG_CreateEndpoint(pEndpoint);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    // Figure out the network addresses.
    // The only way we can determine our cluster
    // address is to read it out of the registry

    status = CDP_BuildAddressVector(&pEndpoint->pAddressVector);

    if (status != RPC_S_OK)
        {
        DG_ServerAbortListen(ThisEndpoint);
        return(status);
        }

    *ppNetworkAddressVector = pEndpoint->pAddressVector;

    return RPC_S_OK;
}

RPC_STATUS
CDP_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    WS_SOCKADDR * pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    unsigned NativeSocket = pSockAddr->clusaddr.sac_port;
    char AnsiBuffer[CDP_MAXIMUM_ENDPOINT];

    char * pAnsi = AnsiBuffer;
    RPC_CHAR * pUni = pClientEndpoint;

    //
    // Convert endpoint to an ASCII string, and thence to Unicode.
    //
    _ultoa(NativeSocket, AnsiBuffer, 10);

    while ( *pUni++ = *pAnsi++ );

    return RPC_S_OK;
}


RPC_STATUS
CDP_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientAddress
    )
{
    PSOCKADDR_CLUSTER pSockAddr = (PSOCKADDR_CLUSTER) pOriginalEndpoint;

    _ultow(pSockAddr->sac_node, pClientAddress, 10);

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
CDP_ClientInitializeAddress
    (
     OUT DG_TRANSPORT_ADDRESS Address,
     IN RPC_CHAR *NetworkAddress,
     IN RPC_CHAR *pPort,
     IN BOOL fUseCache,
     IN BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    Address - Storage for the address
    NetworkAddress - The address of the server or 0 if local
    Endpoint - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    WS_SOCKADDR *pAddr = (WS_SOCKADDR *)Address;
    ULONG HostAddr;
    ULONG Endpoint;
    int i;
    USHORT port;
    RPC_STATUS status;


    // Figure out the destination port

    status = EndpointToPortNumber(pPort, port);

    if (RPC_S_OK != status)
        {
        ASSERT( 0 );
        return(status);
        }

    CDP_InitLocalAddress( &pAddr->clusaddr, port );

    // Resolve the network address - CDP addresses are
    // numbers representing a member ID in the cluster.

    pAddr->clusaddr.sac_node = _wtol( NetworkAddress );

    return(status);
}

RPC_STATUS
RPC_ENTRY
CDP_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD Flags
    )
{
    RPC_STATUS Status;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;


    // We don't care what port we bind to, we also don't care what
    // port we bind to.
    // I think he's trying to say that we don't care what port
    // we bind to.

    CDP_InitLocalAddress(&pEndpoint->ListenAddr.clusaddr, 0);

    pEndpoint->id = CDP;
    pEndpoint->fClient = TRUE;
    pEndpoint->fAsync = fAsync;
    pEndpoint->EndpointFlags = 0;
    pEndpoint->fDynamicEndpoint = 1;

    Status = DG_CreateEndpoint(pEndpoint);

    return Status;
}


RPC_STATUS
CDP_InitializeSockAddr(
    IN char *Endpoint,
    OUT WS_SOCKADDR *pSockAddr
    )
/*++

Routine Description:

    Initialized the sockaddr to be a loopback address to the
    endpoint specified.  Used to forward packets locally.

Arguments:

    Endpoint - The string value of the servers endpoint.

    pSockAddr - The sockaddr to fill in.

Return Value:

    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_OK

--*/
{
    long port;

    port = atol(Endpoint);

    if (port <= 0 || port > 0xFFFF)
        {
        ASSERT( 0 );
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    CDP_InitLocalAddress(&pSockAddr->clusaddr, (unsigned short) port);

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
CDP_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    RPC_STATUS Status;

    Status = DG_GetEndpointStats(ThisEndpoint, pStats);
    if (Status)
        {
        pStats->MaxPduSize       = 1452;
        pStats->MaxPacketSize    = 1452;
        pStats->PreferredPduSize = 1452;

        pStats->ReceiveBufferSize= 8192;
        return Status;
        }

    //
    // ethernet frame (1500) - UDP/IP headers (28) - CNP/CDP headers (20)
    //

    pStats->MaxPacketSize    = 1452;
    pStats->PreferredPduSize = 4096;
    if (pStats->PreferredPduSize > pStats->MaxPduSize)
        {
        pStats->PreferredPduSize = pStats->MaxPduSize;
        }

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// UDP/IP specific functions.
//
RPC_STATUS RPC_ENTRY
UDP_ServerListen(
    IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
    IN RPC_CHAR      *NetworkAddress,
    IN OUT RPC_CHAR **pPort,
    IN     void      *pSecurityDescriptor,
    IN     ULONG      EndpointFlags,
    IN     ULONG      NICFlags,
    OUT    NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
    )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    pPort - The endpoint to listen on or a pointer to 0 if
        the transport should choose the address.
        Contains the endpoint listened to on output.  The
        caller should free this.
    pSecurityDiscriptor - Security to attach to this endpoint (not
        used by UDP).
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS      status;
    NTSTATUS        NtStatus;
    USHORT          port;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AsciiString;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    addr->inetaddr.sin_family = AF_INET;

    if (NetworkAddress)
        {
        IP_ADDRESS_RESOLVER resolver(NetworkAddress,
            cosServer,
            ipvtuIPv4       // IP version to use
            );

        // Loop until success, fatal failure or we run out of addresses.

        status = resolver.NextAddress(&addr->inetaddr);
        if (status != RPC_S_OK)
            {
            return RPC_S_INVALID_NET_ADDR;
            }
        }
    else
        {
        addr->inetaddr.sin_addr.s_addr = INADDR_ANY;
        }

    // Figure out the port to listen on.

    if (*pPort)
        {
        status = EndpointToPortNumber(*pPort, port);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        pEndpoint->fDynamicEndpoint = 0;
        addr->inetaddr.sin_port = htons(port);
        }
    else
        {
        addr->inetaddr.sin_port = 0;
        pEndpoint->fDynamicEndpoint = 1;
        }

    pEndpoint->id = UDP;
    pEndpoint->fClient = FALSE;
    pEndpoint->fAsync = TRUE;
    pEndpoint->EndpointFlags = EndpointFlags;

    //
    // Actually create the endpoint
    //
    status =
    DG_CreateEndpoint(pEndpoint);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    // If needed, figure out the dynamically allocated endpoint.

    if (!*pPort)
        {
        *pPort = new RPC_CHAR[IP_MAXIMUM_ENDPOINT];
        if (!*pPort)
            {
            DG_ServerAbortListen(ThisEndpoint);
            return(RPC_S_OUT_OF_MEMORY);
            }

        port = ntohs(addr->inetaddr.sin_port);

        PortNumberToEndpoint(port, *pPort);
        }

    // Figure out the network addresses

    status = IP_BuildAddressVector(&pEndpoint->pAddressVector,
                                   RPC_C_BIND_TO_ALL_NICS,
                                   NULL,
                                   NULL);

    if (status != RPC_S_OK)
        {
        DG_ServerAbortListen(ThisEndpoint);
        return(status);
        }

    *ppNetworkAddressVector = pEndpoint->pAddressVector;

    return RPC_S_OK;
}

RPC_STATUS
UDP_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    WS_SOCKADDR * pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    unsigned NativeSocket = ntohs(pSockAddr->inetaddr.sin_port);
    char AnsiBuffer[IP_MAXIMUM_ENDPOINT];

    char * pAnsi = AnsiBuffer;
    RPC_CHAR * pUni = pClientEndpoint;

    //
    // Convert endpoint to an ASCII string, and thence to Unicode.
    //
    _ultoa(NativeSocket, AnsiBuffer, 10);

    while ( *pUni++ = *pAnsi++ );

    return RPC_S_OK;
}

RPC_STATUS
UDP_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientAddress
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AsciiString;
    WS_SOCKADDR *pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    NTSTATUS NtStatus;

    UnicodeString.Buffer = pClientAddress;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = IP_MAXIMUM_RAW_NAME * sizeof(RPC_CHAR);

    char *t = inet_ntoa(pSockAddr->inetaddr.sin_addr);
    ASSERT(t);

    RtlInitAnsiString(&AsciiString, t);
    ASSERT(AsciiString.Length < IP_MAXIMUM_RAW_NAME);

    NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString,
                                            &AsciiString,
                                            FALSE);

    if (!NT_SUCCESS(NtStatus))
        {
        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
UDP_ClientInitializeAddress
    (
     OUT DG_TRANSPORT_ADDRESS Address,
     IN RPC_CHAR *NetworkAddress,
     IN RPC_CHAR *pPort,
     IN BOOL fUseCache,
     IN BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    Address - Storage for the address
    NetworkAddress - The address of the server or 0 if local
    Endpoint - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    WS_SOCKADDR *pAddr = (WS_SOCKADDR *)Address;
    ULONG HostAddr;
    ULONG Endpoint;
    int i;
    USHORT port;
    RPC_STATUS status;

    // Contant part of address
    memset(pAddr->inetaddr.sin_zero, 0, 8);

    pAddr->inetaddr.sin_family = AF_INET;

    // Figure out the destination port

    status = EndpointToPortNumber(pPort, port);

    if (RPC_S_OK != status)
        {
        return(status);
        }

    pAddr->inetaddr.sin_port = htons(port);

    // Resolve the network address

    if (fBroadcast)
        {
        pAddr->inetaddr.sin_addr.s_addr = INADDR_BROADCAST;
        return(RPC_S_OK);
        }

    // Multiple server address support for UDP/IP is not available.

    IP_ADDRESS_RESOLVER resolver(NetworkAddress,
        cosClient,
        ipvtuIPv4       // IP version to use
        );

    status = resolver.NextAddress(&pAddr->inetaddr);

    if (status)
        {
        RpcpErrorAddRecord( EEInfoGCWinsock,
                            status,
                            EEInfoDLWinsockDatagramResolve10,
                            NetworkAddress
                            );
        }

    return(status);
}

RPC_STATUS
RPC_ENTRY
UDP_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD EndpointFlags
    )
{

    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR *addr = &pEndpoint->ListenAddr;

    // We don't care what port we bind to, we also don't care what
    // port we bind to.

    memset(addr, 0, sizeof(*addr));

    addr->inetaddr.sin_family = AF_INET;
    pEndpoint->id = UDP;
    pEndpoint->fClient = TRUE;
    pEndpoint->fAsync = fAsync;
    pEndpoint->EndpointFlags = EndpointFlags;
    pEndpoint->fDynamicEndpoint = 1;

    return(DG_CreateEndpoint(pEndpoint));
}


RPC_STATUS
UDP_InitializeSockAddr(
    IN char *Endpoint,
    OUT WS_SOCKADDR *pSockAddr
    )
/*++

Routine Description:

    Initialized the sockaddr to be a loopback address to the
    endpoint specified.  Used to forward packets locally.

Arguments:

    Endpoint - The string value of the servers endpoint.

    pSockAddr - The sockaddr to fill in.

Return Value:

    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_OK

--*/
{
    int len;
    long port;

    pSockAddr->generic.sa_family = AF_INET;
    pSockAddr->inetaddr.sin_addr.s_addr = 0x0100007F;  // byte swapped, 127.0.0.1

    port = atol(Endpoint);

    if (port <= 0 || port > 0xFFFF)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    pSockAddr->inetaddr.sin_port = htons((USHORT) port);

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
UDP_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    RPC_STATUS Status;

    Status = DG_GetEndpointStats(ThisEndpoint, pStats);
    if (Status)
        {
        pStats->MaxPduSize       = 1472;
        pStats->MaxPacketSize    = 1472;
        pStats->PreferredPduSize = 1472;

        pStats->ReceiveBufferSize= 8192;
        return Status;
        }

    pStats->MaxPacketSize    = 1472;
    pStats->PreferredPduSize = 4096;
    if (pStats->PreferredPduSize > pStats->MaxPduSize)
        {
        pStats->PreferredPduSize = pStats->MaxPduSize;
        }

    return RPC_S_OK;
}


#ifdef IPX_ON

////////////////////////////////////////////////////////////////////////
//
// IPX specific functions.
//

RPC_STATUS RPC_ENTRY
IPX_ServerListen(
   IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
   IN RPC_CHAR      *NetworkAddress,
   IN OUT RPC_CHAR **pPort,
   IN     void      *pSecurityDescriptor,
   IN     ULONG      EndpointFlags,
   IN     ULONG      NICFlags,
   OUT    NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
   )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    pPort - The endpoint to listen on or a pointer to 0 if
        the transport should choose the address.
        Contains the endpoint listened to on output.  The
        caller should free this.
    pSecurityDiscriptor - Security to attach to this endpoint (not
        used by the IPX transport).
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS      status;
    NTSTATUS        NtStatus;
    USHORT          port;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AsciiString;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    //
    // Figure out what port to listen on.
    //
    if (*pPort)
        {
        status = EndpointToPortNumber(*pPort, port);

        if (status != RPC_S_OK)
            {
            return(status);
            }
        pEndpoint->fDynamicEndpoint = 0;
        }
    else
        {
        port = 0;
        pEndpoint->fDynamicEndpoint = 1;
        }


    addr->generic.sa_family = AF_IPX;
    addr->ipxaddr.sa_socket = htons(port);

    pEndpoint->id = IPX;
    pEndpoint->fClient = FALSE;
    pEndpoint->fAsync = TRUE;
    pEndpoint->EndpointFlags = 0;

    //
    // Actually create the endpoint
    //
    status =
    DG_CreateEndpoint(pEndpoint);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    // If needed, figure out the dynamically allocated endpoint.

    if (!*pPort)
        {
        *pPort = new RPC_CHAR[IP_MAXIMUM_ENDPOINT];
        if (!*pPort)
            {
            DG_ServerAbortListen(ThisEndpoint);
            return(RPC_S_OUT_OF_MEMORY);
            }

        port = ntohs(addr->ipxaddr.sa_socket);

        PortNumberToEndpoint(port, *pPort);
        }

    // Update the local address cache
    //
    // Since there is only one addess no lock is required.
    //
    memcpy(IpxAddr.sa_netnum, addr->ipxaddr.sa_netnum, sizeof(IpxAddr.sa_netnum));
    memcpy(IpxAddr.sa_nodenum, addr->ipxaddr.sa_nodenum, sizeof(IpxAddr.sa_nodenum));
    fIpxAddrValid = TRUE;

    //
    // Figure out our server's raw IPX address.
    //

    status = IPX_BuildAddressVector(ppNetworkAddressVector);
    if (status != RPC_S_OK)
        {
        DG_ServerAbortListen(ThisEndpoint);
        delete *pPort;
        return(status);
        }

    pEndpoint->pAddressVector = *ppNetworkAddressVector;

    return RPC_S_OK;
}


RPC_STATUS
IPX_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    WS_SOCKADDR * pSockAddr = (WS_SOCKADDR *)pOriginalEndpoint;
    unsigned NativeSocket = ntohs(pSockAddr->ipxaddr.sa_socket);
    char AnsiBuffer[IPX_MAXIMUM_ENDPOINT];

    char * pAnsi = AnsiBuffer;
    RPC_CHAR * pUni = pClientEndpoint;

    //
    // Convert endpoint to an ASCII string, and thence to Unicode.
    //
    _ultoa(NativeSocket, AnsiBuffer, 10);

    while ( *pUni++ = *pAnsi++ );

    return RPC_S_OK;
}

RPC_STATUS
IPX_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pString
    )
{
    WS_SOCKADDR *pSockAddr = (WS_SOCKADDR *) pOriginalEndpoint;

    IPX_AddressToName(&pSockAddr->ipxaddr, pString);

    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
IPX_ClientInitializeAddress
    (
     OUT DG_TRANSPORT_ADDRESS Address,
     IN RPC_CHAR *NetworkAddress,
     IN RPC_CHAR *pPort,
     IN BOOL fUseCache,
     IN BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    Address - Storage for the address
    NetworkAddress - The address of the server or 0 if local
    pPort - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    WS_SOCKADDR *pAddr = (WS_SOCKADDR *)Address;
    RPC_STATUS status = RPC_S_OK;
    USHORT port = 0;

    pAddr->ipxaddr.sa_family = AF_IPX;
    pAddr->ipxaddr.sa_socket = 0;

    // Convert unicode endpoint to port number

    status = EndpointToPortNumber(pPort, port);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    //
    // Convert unicode network address to ipx address
    //

    if (FALSE == fBroadcast)
        {
        status = IPX_NameToAddress(NetworkAddress,
                                   fUseCache,
                                   &pAddr->ipxaddr
                                   );

        }
    else
        {
        memset(pAddr->ipxaddr.sa_netnum, 0, sizeof(pAddr->ipxaddr.sa_netnum));
        memset(pAddr->ipxaddr.sa_nodenum, 0xFF, sizeof(pAddr->ipxaddr.sa_nodenum));
        }

    pAddr->ipxaddr.sa_socket = htons(port);

    return(status);
}


RPC_STATUS
RPC_ENTRY
IPX_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD Flags
    )
{
    RPC_STATUS status;
    PWS_DATAGRAM_ENDPOINT pEndpoint = (PWS_DATAGRAM_ENDPOINT)ThisEndpoint;
    WS_SOCKADDR     *addr = &pEndpoint->ListenAddr;

    // We don't care what port we bind to, we also don't care what
    // port we bind to.

    memset(addr, 0, sizeof(*addr));

    addr->ipxaddr.sa_family = AF_IPX;

    pEndpoint->id = IPX;
    pEndpoint->fClient = TRUE ;
    pEndpoint->fAsync = fAsync;
    pEndpoint->EndpointFlags = 0;
    pEndpoint->fDynamicEndpoint = 1;

    status = DG_CreateEndpoint(pEndpoint);

    if (status == RPC_S_OK)
        {
        // Update cache
        memcpy(IpxAddr.sa_netnum, addr->ipxaddr.sa_netnum, sizeof(IpxAddr.sa_netnum));
        memcpy(IpxAddr.sa_nodenum, addr->ipxaddr.sa_nodenum, sizeof(IpxAddr.sa_nodenum));
        fIpxAddrValid = TRUE;
        }

    return(status);
}


RPC_STATUS
IPX_InitializeSockAddr(
    IN char *Endpoint,
    OUT WS_SOCKADDR *pSockAddr
    )
/*++

Routine Description:

    Initialized the sockaddr to be a loopback address to the
    endpoint specified.  Used to forward packets locally.

Arguments:

    Endpoint - The string value of the servers endpoint.

    pSockAddr - The sockaddr to fill in.

Return Value:

    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_OK

--*/
{
    int len;
    long port;

    pSockAddr->generic.sa_family = AF_IPX;

    port = atol(Endpoint);
    if (port <= 0 || port > 0xFFFF)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }
    pSockAddr->ipxaddr.sa_socket = htons((USHORT)port);

    //
    // In order to get this far this server must have
    // alrady listened to IPX.
    //
    ASSERT(fIpxAddrValid);
    memcpy(pSockAddr->ipxaddr.sa_netnum, IpxAddr.sa_netnum, sizeof(pSockAddr->ipxaddr.sa_netnum));
    memcpy(pSockAddr->ipxaddr.sa_nodenum, IpxAddr.sa_nodenum, sizeof(pSockAddr->ipxaddr.sa_nodenum));

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
IPX_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    RPC_STATUS Status;

    Status = DG_GetEndpointStats(ThisEndpoint, pStats);
    if (Status)
        {
        pStats->MaxPduSize       = 1478;
        pStats->MaxPacketSize    = 1478;
        pStats->PreferredPduSize = 1478;

        pStats->ReceiveBufferSize= 8192;
        return Status;
        }

    pStats->MaxPacketSize    = 1478;
    pStats->PreferredPduSize = pStats->MaxPduSize;
    pStats->MaxPacketSize    = pStats->MaxPduSize;

    return RPC_S_OK;
}
#endif

////////////////////////////////////////////////////////////////////////
//
// Transport interface structures and loader
//

const RPC_DATAGRAM_TRANSPORT
UDP_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    UDP_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_ip_udp"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_SOCKADDR),
    IP_MAXIMUM_ENDPOINT,
    IP_MAXIMUM_PRETTY_NAME,
    1024,
    1472,
    DG_SendPacket,
    UDP_ClientOpenEndpoint,
    UDP_ClientInitializeAddress,
    DG_ClientCloseEndpoint,
    DG_ReceivePacket,
    UDP_ServerListen,
    DG_ServerAbortListen,
    COMMON_ServerCompleteListen,
    DG_ForwardPacket,
    UDP_QueryAddress,
    UDP_QueryEndpoint,
    UDP_GetEndpointStats,

    FALSE,              // fIsMessageTransport (TRUE/FALSE).

    0,                  // OptionSize
    0,                  // InitOptions()
    0,                  // SetOption()
    0,                  // InqOption()
    0,                  // ImplementOptions()
    0,                  // AllowReceives()
    0                   // InquireAuthClient()
};

const RPC_DATAGRAM_TRANSPORT
CDP_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    CDP_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_cluster"),
    NULL,
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_SOCKADDR),
    IP_MAXIMUM_ENDPOINT,
    IP_MAXIMUM_PRETTY_NAME,
    1024,
    1452,
    DG_SendPacket,
    CDP_ClientOpenEndpoint,
    CDP_ClientInitializeAddress,
    DG_ClientCloseEndpoint,
    DG_ReceivePacket,
    CDP_ServerListen,
    DG_ServerAbortListen,
    COMMON_ServerCompleteListen,
    DG_ForwardPacket,
    CDP_QueryAddress,
    CDP_QueryEndpoint,
    CDP_GetEndpointStats,

    FALSE,              // fIsMessageTransport (TRUE/FALSE).

    0,                  // OptionSize
    0,                  // InitOptions()
    0,                  // SetOption()
    0,                  // InqOption()
    0,                  // ImplementOptions()
    0,                  // AllowReceives()
    0                   // InquireAuthClient()
};

#ifdef IPX_ON
const RPC_DATAGRAM_TRANSPORT
IPX_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    IPX_TOWER_ID,
    IPX_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_ipx"),
    "34280",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_DATAGRAM_ENDPOINT),
    sizeof(WS_SOCKADDR),
    IPX_MAXIMUM_ENDPOINT,
    IPX_MAXIMUM_PRETTY_NAME,
    1024,
    1464,
    DG_SendPacket,
    IPX_ClientOpenEndpoint,
    IPX_ClientInitializeAddress,
    DG_ClientCloseEndpoint,
    DG_ReceivePacket,
    IPX_ServerListen,
    DG_ServerAbortListen,
    COMMON_ServerCompleteListen,
    DG_ForwardPacket,
    IPX_QueryAddress,
    IPX_QueryEndpoint,
    IPX_GetEndpointStats,

    FALSE,              // fIsMessageTransport (TRUE/FALSE).

    0,                  // OptionSize
    0,                  // InitOptions()
    0,                  // SetOption()
    0,                  // InqOption()
    0,                  // ImplementOptions()
    0,                  // AllowReceives()
    0                   // InquireAuthClient()
};
#endif


#ifdef NCADG_MQ_ON
const RPC_DATAGRAM_TRANSPORT
MQ_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    MQ_TOWER_ID,
    MQ_ADDRESS_ID,
    RPC_STRING_LITERAL("ncadg_mq"),
    "EpMapper",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    TRUE,
    sizeof(MQ_DATAGRAM_ENDPOINT),
    sizeof(MQ_DATAGRAM_ENDPOINT),
    sizeof(MQ_ADDRESS),
    MQ_MAXIMUM_ENDPOINT,
    MQ_MAXIMUM_PRETTY_NAME,

    MQ_MAX_PDU_SIZE,
    MQ_PREFERRED_PDU_SIZE,

    MQ_SendPacket,
    MQ_ClientOpenEndpoint,
    MQ_ClientInitializeAddress,
    MQ_ClientCloseEndpoint,
    MQ_ReceivePacket,
    MQ_ServerListen,
    MQ_ServerAbortListen,
    COMMON_ServerCompleteListen,
    MQ_ForwardPacket,
    MQ_QueryAddress,
    MQ_QueryEndpoint,
    MQ_GetEndpointStats,

    TRUE,                // fIsMessageTransport (TRUE/FALSE).

    sizeof(MQ_OPTIONS),  // OptionSize
    MQ_InitOptions,      // InitOptions()
    MQ_SetOption,        // SetOption()
    MQ_InqOption,        // InqOption()
    MQ_ImplementOptions, // ImplementOptions()
    MQ_AllowReceives,    // AllowReceives()
    MQ_InquireAuthClient
};
#endif // NCADG_MQ_ON


const RPC_DATAGRAM_TRANSPORT *
DG_TransportLoad (
    IN PROTOCOL_ID index
    )
/*++

Routine Description:

    Loads a datagram protocol and returns the transport interface
    information for the protocol.

Arguments:

    index - the PROTOCOL_ID value of the protocol to load.

Return Value:

    0 - failure
    !0 - success

--*/
{
    const RPC_DATAGRAM_TRANSPORT *pInfo;

    if (fWinsockLoaded == FALSE)
        {
        if (RPC_WSAStartup() == FALSE)
            {
            return(0);
            }
        fWinsockLoaded = TRUE;
        }

    switch(index)
        {
        case UDP:
            pInfo = &UDP_TransportInterface;
            break;

#ifdef IPX_ON
        case IPX:
            if (InitializeIpxNameCache() != RPC_S_OK)
                {
                pInfo = 0;
                }
            else
                {
                pInfo = &IPX_TransportInterface;
                }
            break;
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
            if (!MQ_Initialize())
                {
                return(0);
                }
            else
                {
                pInfo = &MQ_TransportInterface;
                }
            break;
#endif  // NCADG_MQ_ON

        case CDP:
            pInfo = &CDP_TransportInterface;
            break;

        default:
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "DG_TransportLoad called with index: %d\n",
                           index));

            ASSERT(0);
            pInfo = 0;
            break;
        }

    // PERFBUG: Add code to lookup real PDU sizes

    return(pInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\cookie.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    Cookie.cxx

Abstract:

    HTTP2 Cookie management functions.

Author:

    KamenM      09-18-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <Cookie.hxx>

CookieCollection *g_pServerCookieCollection = NULL;

CookieCollection *g_pInProxyCookieCollection = NULL;

CookieCollection *g_pOutProxyCookieCollection = NULL;

HTTP2VirtualConnection *CookieCollection::FindElement (
    IN HTTP2ServerCookie *Cookie
    )
/*++

Routine Description:

    Finds an element in the cookie collection.

Arguments:

    Cookie - element to find. Only the Cookie part of it
        is looked at.

Return Value:

    NULL - the element was not found.
    non-NULL - pointer to the found element

--*/
{
    LIST_ENTRY *CurrentListElement;
    HTTP2ServerCookie *CurrentCookie;
    ULONG *CurrentCookieNumber;
    ULONG *CookieNumberToLookFor;

    Mutex.VerifyOwned();

    CookieNumberToLookFor = (ULONG *)Cookie->GetCookie();

    CurrentListElement = ListHead.Flink;
    while (CurrentListElement != &ListHead)
        {
        CurrentCookie = CONTAINING_RECORD(CurrentListElement, HTTP2ServerCookie, ListEntry);
        CurrentCookieNumber = (ULONG *)CurrentCookie->GetCookie();
        // the cookies are cryptographically strong numbers. From a performance
        // perspective, the chances that the first comparison will succeed and
        // the others will fail are extremely slim
        if ((*(CurrentCookieNumber + 0) == *(CookieNumberToLookFor + 0))
            && (*(CurrentCookieNumber + 1) == *(CookieNumberToLookFor + 1))
            && (*(CurrentCookieNumber + 2) == *(CookieNumberToLookFor + 2))
            && (*(CurrentCookieNumber + 3) == *(CookieNumberToLookFor + 3)) )
            {
            return CurrentCookie->Connection;
            }
        CurrentListElement = CurrentListElement->Flink;
        }
    return NULL;
}

RPC_STATUS CookieCollection::InitializeCookieCollection (
    IN OUT CookieCollection **CookieCollectionPtr
    )
/*++

Routine Description:

    Initializes a given cookie collection.

    N.B. This method is not thread safe. Callers
    must synchronize before calling it.

Arguments:

    CookieCollectionPtr - on input verified to point to NULL.
        If the function succeeds, on output it will contain
        the collection. If the function fails, on output it
        is guaranteed to contain NULL.

Return Value:

    RPC_S_OK for success or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (*CookieCollectionPtr == NULL)
        {
        *CookieCollectionPtr = new CookieCollection(&RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            delete *CookieCollectionPtr;
            *CookieCollectionPtr = NULL;
            }
        }

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\httprts.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    HttpRTS.cxx

Abstract:

    HTTP2 RTS packets support functions.

Author:

    KamenM      09-07-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <HttpRTS.hxx>


const int TunnelSettingsCommandTypeSizes[LAST_RTS_COMMAND + 1] = 
    {
    sizeof(ULONG),    // tsctReceiveWindowSize
    sizeof(FlowControlAck),    // tsctFlowControlAck
    sizeof(ULONG),    // tsctConnectionTimeout
    sizeof(ChannelSettingCookie),    // tsctCookie
    sizeof(ULONG),    // tsctChannelLifetime
    sizeof(ULONG),    // tsctClientKeepalive
    sizeof(ULONG),    // tsctVersion
    0,    // tsctEmpty
    sizeof(ULONG),    // tsctPadding - size is variable. This is only for the conformance count
    0,    // tsctNANCE - no operands
    0,    // tsctANCE - no operands
    sizeof(ChannelSettingClientAddress),     // tsctClientAddress
    sizeof(ChannelSettingCookie),    // tsctAssociationGroupId
    sizeof(ULONG),      // tsctDestination
    sizeof(ULONG)       // tsctPingTrafficSentNotify
    };

const int ClientAddressSizes[] = 
    {
    FIELD_OFFSET(ChannelSettingClientAddress, u) + sizeof(SOCKADDR_IN),
    FIELD_OFFSET(ChannelSettingClientAddress, u) + sizeof(SOCKADDR_IN6)
    };

BYTE *ValidateRTSPacketCommon (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Validates the common portions of an RTS packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    A pointer to the location after the common part if successful.
    NULL is validation failed.

--*/
{
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;

    if (PacketLength < BaseRTSSizeAndPadding)
        {
        ASSERT(0);
        return NULL;
        }

    if (RTS->common.frag_length != (unsigned short) PacketLength)
        {
        ASSERT(0);
        return NULL;
        }

    if (   (RTS->common.rpc_vers != OSF_RPC_V20_VERS)
        || (RTS->common.rpc_vers_minor > OSF_RPC_V20_VERS_MINOR))
        {
        ASSERT(0);
        return NULL;
        }

    if (RTS->common.pfc_flags != (PFC_FIRST_FRAG | PFC_LAST_FRAG))
        {
        ASSERT(0);
        return NULL;
        }

    if (RTS->common.drep[0] != NDR_LITTLE_ENDIAN)
        {
        ASSERT(0);
        return NULL;
        }

    if ((RTS->common.auth_length != 0)
        || (RTS->common.call_id != 0))
        {
        ASSERT(0);
        return NULL;
        }

    return (Packet + BaseRTSSizeAndPadding);
}

RPC_STATUS CheckPacketForForwarding (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations CurrentLocation
    )
/*++

Routine Description:

    Checks whether a packet needs forwarding, and if yes,
    patches up the protocol version if it is present.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

    CurrentLocation - the current location we're in. This is how
        this routine knows whether to forward.

Return Value:

    RPC_S_OK for success (means the packet is for us)
    RPC_P_PACKET_NEEDS_FORWARDING - success, but packet is not for us
    RPC_S_PROTOCOL_ERROR - packet is garbled and cannot be processed

--*/
{
    BYTE *CurrentPosition;
    ULONG CurrentLength;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    TunnelSettingsCommand *CurrentCommand;
    int i;
    BOOL ForwardingNeeded;
    ULONG *ProtocolPosition;
    
    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return RPC_S_PROTOCOL_ERROR;

    ForwardingNeeded = FALSE;
    ProtocolPosition = NULL;
    CurrentLength = CurrentPosition - Packet;
    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;
    for (i = 0; i < RTS->NumberOfSettingCommands; i ++)
        {
        // check if there is enough to read the command after this
        CurrentLength += BaseRTSCommandSize;
        if (CurrentLength > PacketLength)
            return RPC_S_PROTOCOL_ERROR;

        if (CurrentCommand->CommandType == tsctDestination)
            {
            CurrentLength += SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination);
            if (CurrentLength > PacketLength)
                return RPC_S_PROTOCOL_ERROR;
            if (CurrentCommand->u.Destination == CurrentLocation)
                return RPC_S_OK;

            ForwardingNeeded = TRUE;
            // if we have found the protocol as well, we're done - break
            // out of here
            if (ProtocolPosition)
                break;
            }
        else if (CurrentCommand->CommandType == tsctVersion)
            {
            CurrentLength += SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion);
            if (CurrentLength > PacketLength)
                return RPC_S_PROTOCOL_ERROR;

            ProtocolPosition = &CurrentCommand->u.Version;
            // if we have already found the destination as well, we're done -
            // get out of here
            if (ForwardingNeeded)
                break;
            }
        else
            {
            if (CurrentCommand->CommandType > LAST_RTS_COMMAND)
                return RPC_S_PROTOCOL_ERROR;

            CurrentLength += SIZE_OF_RTS_CMD_AND_PADDING(CurrentCommand->CommandType);
            }
        
        CurrentCommand = (TunnelSettingsCommand *)(Packet + CurrentLength);
        }

    if (ForwardingNeeded)
        {
        if (ProtocolPosition)
            *ProtocolPosition = HTTP2ProtocolVersion;

        return RPC_P_PACKET_NEEDS_FORWARDING;
        }

    return RPC_S_OK;
}

BOOL UntrustedIsPingPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Checks if a packet coming from an untrusted source is a
    ping packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    non-zero if it is a valid ping packet.
    zero if it is a valid non-ping packet or if it is an
    invalid packet.

--*/
{
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;

    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return FALSE;

    RTS = (rpcconn_tunnel_settings *)Packet;

    return (RTS->Flags & RTS_FLAG_PING);
}

BOOL IsEchoPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Checks if a packet is an echo packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    non-zero if it is a valid echo packet.
    zero if it is a valid non-echo packet or if it is an
    invalid packet.

--*/
{
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;

    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return FALSE;

    RTS = (rpcconn_tunnel_settings *)Packet;

    return (RTS->Flags & RTS_FLAG_ECHO);
}

BOOL IsOtherCmdPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Checks if a packet coming from an untrusted source is a
    other cmd packet.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    non-zero if it is a valid other cmd packet.
    zero if it is not a valid other cmd packet.

--*/
{
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;

    CurrentPosition = ValidateRTSPacketCommon(Packet,
        PacketLength);

    if (CurrentPosition == NULL)
        return FALSE;

    RTS = (rpcconn_tunnel_settings *)Packet;

    return (RTS->Flags & RTS_FLAG_OTHER_CMD);
}

HTTP2SendContext *AllocateAndInitializePingPacket (
    void
    )
/*++

Routine Description:

    Allocates and initializes an RTS ping packet

Arguments:

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        0
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_PING;
        RTS->NumberOfSettingCommands = 0;
        }

    return SendContext;
}

HTTP2SendContext *AllocateAndInitializePingPacketWithSize (
    IN ULONG TotalPacketSize
    )
/*++

Routine Description:

    Allocates and initializes an RTS ping packet padding
    the packet until a certain size.

Arguments:

    TotalPacketSize - the total desired size of the packet.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;
    BOOL UseEmpty;
    ULONG ExtraSize;

    // the size of empty must be 0 for the calculation below to work
    ASSERT(SIZE_OF_RTS_CMD_AND_PADDING(tsctEmpty) == 0);

    ASSERT(TotalPacketSize >= BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctEmpty));

    // reduce the TotalPacketSize to the size of the actual padding
    // We subtract the base packet size + the padding command itself
    TotalPacketSize -= BaseRTSCommandSize * 1
        + BaseRTSSizeAndPadding;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + TotalPacketSize
        );

    if (SendContext)
        {
        // if we were required to use larger size, we'll use the padding.
        // if it was smaller, we'll use the empty command
        if (TotalPacketSize >= SIZE_OF_RTS_CMD_AND_PADDING(tsctPadding))
            {
            TotalPacketSize -= SIZE_OF_RTS_CMD_AND_PADDING(tsctPadding);
            UseEmpty = FALSE;
            }
        else
            {
            TotalPacketSize -= SIZE_OF_RTS_CMD_AND_PADDING(tsctEmpty);
            UseEmpty = TRUE;
            }

        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_PING;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        if (UseEmpty)
            {
            // set empty command
            CurrentCommand->CommandType = tsctEmpty;
            }
        else
            {
            // set padding command
            CurrentCommand->CommandType = tsctPadding;
            CurrentCommand->u.ConformanceCount = TotalPacketSize;
            CurrentCommand = SkipCommand(CurrentCommand, tsctPadding);

            // clean out the padding bytes
            RpcpMemorySet(CurrentCommand, 0, TotalPacketSize);
            }
        }

    return SendContext;
}

RPC_STATUS ParseAndFreePingPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a ping packet.
    N.B.: UntrustedIsPingPacket must have
    already been called and returned non-zero
    for this function to be used.

Arguments:

    Packet - the packet to be validated.

    PacketLength - the length of the packet.

Return Value:

    RPC_S_OK for success
    RPC_S_PROTOCOL_ERROR for garbled packet

--*/
{
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    RPC_STATUS RpcStatus;

    if (RTS->NumberOfSettingCommands != 0)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_PING)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

ULONG GetD1_A1TotalLength (
    void
    )
/*++

Routine Description:

    Calculates the length of a D1/A1 RTS packet

Arguments:

Return Value:

    The length of the D1/A1 RTS packet.

--*/
{
    return (BaseRTSSizeAndPadding
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );
}

HTTP2SendContext *AllocateAndInitializeEmptyRTS (
    void
    )
/*++

Routine Description:

    Allocates and initializes an empty RTS packet

Arguments:

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set empty command
        CurrentCommand->CommandType = tsctEmpty;
        }

    return SendContext;
}

RPC_STATUS ParseEmptyRTS (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses an empty RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify empty
    if (CurrentCommand->CommandType != tsctEmpty)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}


RPC_STATUS ParseAndFreeEmptyRTS (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees an empty RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseEmptyRTS(Packet,
        PacketLength
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeEmptyRTSWithDestination (
    IN ForwardDestinations Destination
    )
/*++

Routine Description:

    Allocates and initializes an empty RTS packet

Arguments:

    Destination - where to forward this to.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        }

    return SendContext;
}

RPC_STATUS ParseEmptyRTSWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses an empty RTS packet with destination

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeEmptyRTSWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses and frees an empty RTS packet with destination

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseEmptyRTSWithDestination (Packet,
        PacketLength,
        ExpectedDestination
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_A1 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ClientReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D1/A1 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 4;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set client receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ClientReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_A1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ClientReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 4)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get client receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ClientReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_A2 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ChannelLifetime,
    IN ULONG ProxyReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D1/A2 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 5;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel lifetime
        CurrentCommand->CommandType = tsctChannelLifetime;
        CurrentCommand->u.ChannelLifetime = ChannelLifetime;
        CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

        // set proxy receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ProxyReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseD1_A2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ChannelLifetime,
    OUT ULONG *ProxyReceiveWindow
    )
/*++

Routine Description:

    Parses D1/A2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 5)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel lifetime
    if (CurrentCommand->CommandType != tsctChannelLifetime)
        goto AbortAndExit;
    *ChannelLifetime = CurrentCommand->u.ChannelLifetime;
    CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

    // get proxy receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ProxyReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_B1 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ChannelLifetime,
    IN ULONG ClientKeepAliveInterval,
    IN HTTP2Cookie *AssociationGroupId
    )
/*++

Routine Description:

    Allocates and initializes a D1/B1 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ChannelLifetime - the lifetime of the channel

    ClientKeepAliveInterval - the client receive window

    AssociationGroupId - the association group id

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctAssociationGroupId)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 6;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel lifetime
        CurrentCommand->CommandType = tsctChannelLifetime;
        CurrentCommand->u.ChannelLifetime = ChannelLifetime;
        CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

        // set client receive window
        CurrentCommand->CommandType = tsctClientKeepalive;
        CurrentCommand->u.ClientKeepalive = ClientKeepAliveInterval;
        CurrentCommand = SkipCommand(CurrentCommand, tsctClientKeepalive);

        // set association group id
        CurrentCommand->CommandType = tsctAssociationGroupId;
        RpcpMemoryCopy(CurrentCommand->u.AssociationGroupId.Cookie, AssociationGroupId->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_B1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ChannelLifetime,
    OUT HTTP2Cookie *AssociationGroupId,
    OUT ULONG *ClientKeepAliveInterval
    )
/*++

Routine Description:

    Parses and frees a D1/B1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - on output, the version of the HTTP tunnelling protocol
        Success only.

    ConnectionCookie - on output, the connection cookie. Success only.

    ChannelCookie - on output, the channel cookie. Success only.

    ChannelLifetime - on output, the lifetime of the channel. Success only.

    AssociationGroupId - on output, the client association group id.
        Success only.

    ClientKeepAliveInterval - on output, the client receive window.
        Success only.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctAssociationGroupId)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 6)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel lifetime
    if (CurrentCommand->CommandType != tsctChannelLifetime)
        goto AbortAndExit;
    *ChannelLifetime = CurrentCommand->u.ChannelLifetime;
    CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

    // get client keep alive
    if (CurrentCommand->CommandType != tsctClientKeepalive)
        goto AbortAndExit;
    *ClientKeepAliveInterval = CurrentCommand->u.ClientKeepalive;
    CurrentCommand = SkipCommand(CurrentCommand, tsctClientKeepalive);

    // get association group id
    if (CurrentCommand->CommandType != tsctAssociationGroupId)
        goto AbortAndExit;
    AssociationGroupId->SetCookie((BYTE *)CurrentCommand->u.AssociationGroupId.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_B2 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *ChannelCookie,
    IN ULONG ReceiveWindowSize,
    IN ULONG ConnectionTimeout,
    IN HTTP2Cookie *AssociationGroupId,
    IN ChannelSettingClientAddress *ClientAddress
    )
/*++

Routine Description:

    Allocates and initializes a D1/B2 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

    ClientAddress - client address of the client as seen by the in proxy

    AssociationGroupId - the association group id

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctAssociationGroupId)
        + ClientAddressSizes[ClientAddress->AddressType]
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_IN_CHANNEL;
        RTS->NumberOfSettingCommands = 7;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set receive window size
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

        // set association group id
        CurrentCommand->CommandType = tsctAssociationGroupId;
        RpcpMemoryCopy(CurrentCommand->u.AssociationGroupId.Cookie, AssociationGroupId->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctAssociationGroupId);

        // set client address.
        CurrentCommand->CommandType = tsctClientAddress;
        CurrentCommand->u.ClientAddress.AddressType = ClientAddress->AddressType;
        RpcpMemorySet(&CurrentCommand->u, 0, ClientAddressSizes[ClientAddress->AddressType]);
        if (ClientAddress->AddressType == catIPv4)
            {
            RpcpCopyIPv4Address((SOCKADDR_IN *)ClientAddress->u.IPv4Address,
                (SOCKADDR_IN *) CurrentCommand->u.ClientAddress.u.IPv4Address);
            }
        else
            {
            RpcpCopyIPv6Address((SOCKADDR_IN6 *)ClientAddress->u.IPv4Address,
                (SOCKADDR_IN6 *) CurrentCommand->u.ClientAddress.u.IPv4Address);
            }
        }

    return SendContext;
}

RPC_STATUS ParseD1_B2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *ChannelCookie,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout,
    OUT HTTP2Cookie *AssociationGroupId,
    OUT ChannelSettingClientAddress *ClientAddress
    )
/*++

Routine Description:

    Parses a D1/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    ChannelCookie - the channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

    AssociationGroupId - the association group id

    ClientAddress - client address of the client as seen by the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        + FIELD_OFFSET(ChannelSettingClientAddress, u)      // check for enough space to read the
                                                            // address type
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 7)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_IN_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get receive window size
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    if (CurrentCommand->CommandType != tsctAssociationGroupId)
        goto AbortAndExit;
    AssociationGroupId->SetCookie((BYTE *)CurrentCommand->u.AssociationGroupId.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctAssociationGroupId);

    // get client address. Note that we have checked the length only up to
    // the address type. Everything after that must be validated separately
    if (CurrentCommand->CommandType != tsctClientAddress)
        goto AbortAndExit;
    ClientAddress->AddressType = CurrentCommand->u.ClientAddress.AddressType;

    // We have already calculated the size of the AddressType field. Add the
    // size for the body of the client address
    MemorySize += 
        ClientAddressSizes[ClientAddress->AddressType] 
        - FIELD_OFFSET(ChannelSettingClientAddress, u);
    if (PacketLength < MemorySize)
        goto AbortAndExit;

    if (ClientAddress->AddressType == catIPv4)
        {
        RpcpCopyIPv4Address((SOCKADDR_IN *)CurrentCommand->u.ClientAddress.u.IPv4Address,
            (SOCKADDR_IN *)ClientAddress->u.IPv4Address);
        }
    else
        {
        RpcpCopyIPv6Address((SOCKADDR_IN6 *)CurrentCommand->u.ClientAddress.u.IPv4Address,
            (SOCKADDR_IN6 *)ClientAddress->u.IPv4Address);
        }

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS GetFirstServerPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2FirstServerPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of the first server packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    if (RTS->Flags & RTS_FLAG_OUT_CHANNEL)
        {
        if (RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL)
            *PacketType = http2fsptD4_A4;
        else
            *PacketType = http2fsptD1_A2;
        return RPC_S_OK;
        }
    else if (RTS->Flags & RTS_FLAG_IN_CHANNEL)
        {
        if (RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL)
            *PacketType = http2fsptD2_A2;
        else
            *PacketType = http2fsptD1_B2;
        return RPC_S_OK;
        }
    else
        return RPC_S_PROTOCOL_ERROR;
}

RPC_STATUS GetClientOpenedPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2ClientOpenedPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of the packet in client opened (or one of
    the opened states)

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    // here we expect D2/A4, D3/A4, D4/A2, D4/A6, D5/A6
    // and D5/B3
    if (RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL)
        {
        *PacketType = http2coptD4_A2;
        }
    else if (RTS->Flags & RTS_FLAG_OUT_CHANNEL)
        {
        *PacketType = http2coptD4_A6;
        }
    else if (RTS->Flags & RTS_FLAG_EOF)
        {
        // D5/B3 has the EOF flag
        *PacketType = http2coptD5_B3;
        }
    else if (IsD4_A10(Packet, PacketLength))
        {
        // D4/A10 is an ANCE packet.
        *PacketType = http2coptD4_A10;
        }
    else if (IsD5_A6(Packet, PacketLength, fdClient))
        {
        // D5/A6 is an ANCE packet with forward destination.
        *PacketType = http2coptD5_A6;
        }
    else if (IsD2_A4OrD3_A4(Packet, PacketLength))
        {
        *PacketType = http2coptD2_A4;
        }
    else
        {
        *PacketType = http2coptD3_A4;
        }

    return RPC_S_OK;
}

RPC_STATUS GetServerOpenedPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2ServerOpenedPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of the packet in server opened (or one of
    the opened states)

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    // here we expect D2/A6, D2/B1, D3/A2, D4/A8 and D5/A8
    if (RTS->Flags & RTS_FLAG_OUT_CHANNEL)
        {
        // D4/A8 and D5/A8 are differentiated by state only
        *PacketType = http2soptD4_A8orD5_A8;
        }
    else if (IsEmptyRTS (Packet, PacketLength))
        {
        *PacketType = http2soptD2_B1;
        }
    else
        {
        *PacketType = http2soptD2_A6orD3_A2;
        }

    return RPC_S_OK;
}

RPC_STATUS GetOtherCmdPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2OtherCmdPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of a packet containing other cmd flag

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    rpcconn_tunnel_settings *RTS;

    if (PacketLength < BaseRTSSizeAndPadding)
        return RPC_S_PROTOCOL_ERROR;

    RTS = (rpcconn_tunnel_settings *)Packet;

    // right now we only expect KeepAliveChange
    *PacketType = http2ocptKeepAliveChange;

    return RPC_S_OK;
}

RPC_STATUS GetServerOutChannelOtherCmdPacketType (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2ServerOutChannelOtherCmdPacketType *PacketType
    )
/*++

Routine Description:

    Determines the type of a packet containing other cmd flag

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PacketType - one of the members of the enumeration

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;

    // tsctPingTrafficSentNotify is shorter than tsctFlowControlAck
    // This is how we differentiate them
    ASSERT(SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck) 
        > SIZE_OF_RTS_CMD_AND_PADDING(tsctPingTrafficSentNotify));

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        ;

    if (PacketLength < MemorySize)
        *PacketType = http2sococptPingTrafficSentNotify;
    else
        *PacketType = http2sococptFlowControl;

    return RPC_S_OK;
}

const char *ResponseHeaderFragment1 = "HTTP/1.1 200 Success\r\nContent-Type:application/rpc\r\nContent-Length:";
const int ResponseHeaderFragment1Length = 67;    // length of "HTTP/1.1 200 Success\r\nContent-Type:application/rpc\r\nContent-Length:"
const char *ResponseHeaderFragment2 = "\r\n\r\n";
const int ResponseHeaderFragment2Length = 4;     // length of "\r\n\r\n"

HTTP2SendContext *AllocateAndInitializeResponseHeader (
    void
    )
/*++

Routine Description:

    Allocates and initializes the out channel response header.

Arguments:

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    ULONG MemorySize;
    char *Buffer;
    char *OriginalBuffer;
    HTTP2SendContext *SendContext;

    MemorySize = ResponseHeaderFragment1Length
        + DefaultChannelLifetimeStringLength
        + ResponseHeaderFragment2Length
        ;

    Buffer = (char *)RpcAllocateBuffer(HTTPSendContextSizeAndPadding + MemorySize);
    if (Buffer == NULL)
        return NULL;

    OriginalBuffer = Buffer;

    SendContext = (HTTP2SendContext *)Buffer;
    Buffer += HTTPSendContextSizeAndPadding;

#if DBG
    SendContext->ListEntryUsed = FALSE;
#endif
    SendContext->maxWriteBuffer = MemorySize;
    SendContext->pWriteBuffer = (BUFFER)Buffer;
    SendContext->TrafficType = http2ttRaw;
    SendContext->u.SyncEvent = NULL;
    SendContext->Flags = 0;
    SendContext->UserData = 0;

    RpcpMemoryCopy(Buffer, ResponseHeaderFragment1, ResponseHeaderFragment1Length);
    Buffer += ResponseHeaderFragment1Length;

    RpcpMemoryCopy(Buffer, DefaultChannelLifetimeString, DefaultChannelLifetimeStringLength);
    Buffer += DefaultChannelLifetimeStringLength;

    RpcpMemoryCopy(Buffer, ResponseHeaderFragment2, ResponseHeaderFragment2Length);

    return (HTTP2SendContext *)OriginalBuffer;
}

HTTP2SendContext *AllocateAndInitializeD1_A3 (
    IN ULONG ProxyConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes an D1_A3 packet.

Arguments:

    ProxyConnectionTimeout - the proxy connection timeout.

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ProxyConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_A3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D1/A3 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProxyConnectionTimeout - the proxy connection timeout is returned
        here (success only).

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ProxyConnectionTimeout = CurrentCommand->u.ConnectionTimeout;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_B3 (
    IN ULONG ReceiveWindowSize,
    IN ULONG UpdatedProtocolVersion
    )
/*++

Routine Description:

    Allocates and initializes an D1_B3 packet.

Arguments:

    ReceiveWindowSize - the server receive window size.

    UpdatedProtocolVersion - the updated protocol version.

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ConnectionTimeout = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = UpdatedProtocolVersion;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD1_B3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *UpdatedProtocolVersion
    )
/*++

Routine Description:

    Parses and frees a D1/A3 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ReceiveWindowSize - the receive window size is returned
        here (success only).

    UpdatedProtocolVersion - the updated protocol version from the
        server (success only)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *UpdatedProtocolVersion = CurrentCommand->u.Version;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD1_C1 (
    IN ULONG UpdatedProtocolVersion,
    IN ULONG InProxyReceiveWindowSize,
    IN ULONG InProxyConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D1_C1 packet.

Arguments:

    UpdatedProtocolVersion - the updated protocol version.

    InProxyReceiveWindowSize - the in proxy receive window size.

    InProxyConnectionTimeout - the in proxy connection timeout

Return Value:

    The allocated and initialized send context on success. NULL on
    failure.

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->NumberOfSettingCommands = 3;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = UpdatedProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = InProxyReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = InProxyConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseD1_C1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *UpdatedProtocolVersion,
    OUT ULONG *InProxyReceiveWindowSize,
    OUT ULONG *InProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses a D1_C1 packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    UpdatedProtocolVersion - the updated protocol version.

    InProxyReceiveWindowSize - the in proxy receive window size.

    InProxyConnectionTimeout - the in proxy connection timeout

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 3)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *UpdatedProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *InProxyReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *InProxyConnectionTimeout = CurrentCommand->u.ConnectionTimeout;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD1_C2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *UpdatedProtocolVersion,
    OUT ULONG *InProxyReceiveWindowSize,
    OUT ULONG *InProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D1_C2 packet.

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    UpdatedProtocolVersion - the updated protocol version.

    InProxyReceiveWindowSize - the in proxy receive window size.

    InProxyConnectionTimeout - the in proxy connection timeout

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    // D1/C1 has the same format as D1/C2
    RpcStatus = ParseD1_C1(Packet,
        PacketLength,
        UpdatedProtocolVersion,
        InProxyReceiveWindowSize,
        InProxyConnectionTimeout
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A1 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Allocates and initializes a D2/A1 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_RECYCLE_CHANNEL;
        RTS->NumberOfSettingCommands = 4;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}


RPC_STATUS ParseAndFreeD2_A1 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses and frees a D2/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - on output, the version of the HTTP tunnelling protocol
        Success only.

    ConnectionCookie - on output, the connection cookie. Success only.

    OldChannelCookie - on output, the old channel cookie. Success only.

    NewChannelCookie - on output, the new channel cookie. Success only.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 4)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_RECYCLE_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A2 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ReceiveWindowSize,
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D2/A2 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_IN_CHANNEL | RTS_FLAG_RECYCLE_CHANNEL;
        RTS->NumberOfSettingCommands = 6;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set receive window size
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        }

    return SendContext;
}


RPC_STATUS ParseD2_A2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses a D1/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 6
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 6)
        goto AbortAndExit;

    if (RTS->Flags != (RTS_FLAG_IN_CHANNEL | RTS_FLAG_RECYCLE_CHANNEL))
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get receive window size
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A3 (
    IN ForwardDestinations Destination,
    IN ULONG ProtocolVersion,
    IN ULONG ReceiveWindowSize,
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D2/A3 RTS packet

Arguments:

    Destination - where to forward this to.

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 4;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set receive window size
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ReceiveWindowSize;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD2_A4 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *ProtocolVersion,
    OUT ULONG *ReceiveWindowSize,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D2/A4 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ReceiveWindowSize - the receive window size of the in proxy

    ConnectionTimeout - connection timeout of the in proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 4
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 4)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get receive window size
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ReceiveWindowSize = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_A5 (
    IN HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Allocates and initializes a D2/A5 RTS packet

Arguments:

    NewChannelCookie - the new channel cookie

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseD2_A5 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses a D2/A5 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewChannelCookie - the new channel cookie

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD2_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses and frees a D2/A6 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewChannelCookie - the new channel cookie

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    // D2/A6 is the same as D2/A5
    RpcStatus = ParseD2_A5(Packet,
        PacketLength,
        NewChannelCookie);

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD2_B2 (
    IN ULONG ServerReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D2/B2 RTS packet

Arguments:

    ServerReceiveWindow - the server receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set server receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ServerReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD2_B2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ServerReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D2/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ServerReceiveWindow - the server receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get server receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ServerReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A3 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ClientReceiveWindow
    )
/*++

Routine Description:

    Allocates and initializes a D4/A3 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_RECYCLE_CHANNEL;
        RTS->NumberOfSettingCommands = 5;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set client receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ClientReceiveWindow;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD4_A2 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a D4/A2 packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_RECYCLE_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (fdClient != CurrentCommand->u.Destination)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

ULONG GetD4_A3TotalLength (
    void
    )
/*++

Routine Description:

    Calculates the length of a D1/A1 RTS packet

Arguments:

Return Value:

    The length of the D1/A1 RTS packet.

--*/
{
    return (BaseRTSSizeAndPadding
        + BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        );
}

ULONG GetD4_A11TotalLength (
    void
    )
/*++

Routine Description:

    Calculates the length of a D4/A11 RTS packet

Arguments:

Return Value:

    The length of the D4/A11 RTS packet.

--*/
{
    return (BaseRTSSizeAndPadding
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );
}

RPC_STATUS ParseD4_A3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ClientReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 5
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize);

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 5)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_RECYCLE_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get client receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ClientReceiveWindow = CurrentCommand->u.ReceiveWindowSize;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD4_A3 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ClientReceiveWindow
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ClientReceiveWindow - the client receive window

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD4_A3 (Packet,
        PacketLength,
        ProtocolVersion,
        ConnectionCookie,
        OldChannelCookie,
        NewChannelCookie,
        ClientReceiveWindow
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A4 (
    IN ULONG ProtocolVersion,
    IN HTTP2Cookie *ConnectionCookie,
    IN HTTP2Cookie *OldChannelCookie,
    IN HTTP2Cookie *NewChannelCookie,
    IN ULONG ChannelLifetime,
    IN ULONG ProxyReceiveWindow,
    IN ULONG ProxyConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D4/A4 RTS packet

Arguments:

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

    ProxyConnectionTimeout - the proxy connection timeout

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_RECYCLE_CHANNEL | RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 7;

        CurrentCommand = RTS->Cmd;

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, ConnectionCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set old channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, OldChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

        // set channel lifetime
        CurrentCommand->CommandType = tsctChannelLifetime;
        CurrentCommand->u.ChannelLifetime = ChannelLifetime;
        CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

        // set proxy receive window
        CurrentCommand->CommandType = tsctReceiveWindowSize;
        CurrentCommand->u.ReceiveWindowSize = ProxyReceiveWindow;
        CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

        // set proxy connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ProxyConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseD4_A4 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *ProtocolVersion,
    OUT HTTP2Cookie *ConnectionCookie,
    OUT HTTP2Cookie *OldChannelCookie,
    OUT HTTP2Cookie *NewChannelCookie,
    OUT ULONG *ChannelLifetime,
    OUT ULONG *ProxyReceiveWindow,
    OUT ULONG *ProxyConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D1/A1 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionCookie - the connection cookie

    OldChannelCookie - the old channel cookie

    NewChannelCookie - the new channel cookie

    ChannelLifetime - the lifetime of the channel

    ProxyReceiveWindow - the proxy receive window

    ProxyConnectionTimeout - the proxy connection timeout

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 7
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctChannelLifetime)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctReceiveWindowSize)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 7)
        goto AbortAndExit;

    if (RTS->Flags != (RTS_FLAG_RECYCLE_CHANNEL | RTS_FLAG_OUT_CHANNEL))
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    ConnectionCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get old channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    OldChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);
    CurrentCommand = SkipCommand(CurrentCommand, tsctCookie);

    // get channel lifetime
    if (CurrentCommand->CommandType != tsctChannelLifetime)
        goto AbortAndExit;
    *ChannelLifetime = CurrentCommand->u.ChannelLifetime;
    CurrentCommand = SkipCommand(CurrentCommand, tsctChannelLifetime);

    // get proxy receive window
    if (CurrentCommand->CommandType != tsctReceiveWindowSize)
        goto AbortAndExit;
    *ProxyReceiveWindow = CurrentCommand->u.ReceiveWindowSize;
    CurrentCommand = SkipCommand(CurrentCommand, tsctReceiveWindowSize);

    // get proxy connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ProxyConnectionTimeout = CurrentCommand->u.ConnectionTimeout;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A5 (
    IN ForwardDestinations Destination,
    IN ULONG ProtocolVersion,
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Allocates and initializes a D4/A5 RTS packet

Arguments:

    Destination - where to forward this to.

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionTimeout - connection timeout of the out proxy

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 3;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set version
        CurrentCommand->CommandType = tsctVersion;
        CurrentCommand->u.Version = ProtocolVersion;
        CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

        // set connection timeout
        CurrentCommand->CommandType = tsctConnectionTimeout;
        CurrentCommand->u.ConnectionTimeout = ConnectionTimeout;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD4_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *ProtocolVersion,
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Parses and frees a D4/A6 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

    ProtocolVersion - the version of the HTTP tunnelling protocol

    ConnectionTimeout - connection timeout of the out proxy

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 3
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctVersion)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctConnectionTimeout)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 3)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get version
    if (CurrentCommand->CommandType != tsctVersion)
        goto AbortAndExit;
    *ProtocolVersion = CurrentCommand->u.Version;
    CurrentCommand = SkipCommand(CurrentCommand, tsctVersion);

    // get connection timeout
    if (CurrentCommand->CommandType != tsctConnectionTimeout)
        goto AbortAndExit;
    *ConnectionTimeout = CurrentCommand->u.ConnectionTimeout;
    CurrentCommand = SkipCommand(CurrentCommand, tsctConnectionTimeout);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A7 (
    IN ForwardDestinations Destination,
    IN HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Allocates and initializes a D4/A7 RTS packet

Arguments:

    Destination - the destination for the packet.

    NewChannelCookie - the new channel cookie

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OUT_CHANNEL;
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set new channel cookie
        CurrentCommand->CommandType = tsctCookie;
        RpcpMemoryCopy(CurrentCommand->u.Cookie.Cookie, NewChannelCookie->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD4_A8 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT HTTP2Cookie *NewChannelCookie
    )
/*++

Routine Description:

    Parses a D2/A5 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewChannelCookie - the new channel cookie

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctCookie)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OUT_CHANNEL)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // get new channel cookie
    if (CurrentCommand->CommandType != tsctCookie)
        goto AbortAndExit;
    NewChannelCookie->SetCookie((BYTE *)CurrentCommand->u.Cookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD4_A9 (
    void
    )
/*++

Routine Description:

    Allocates and initializes a D4/A9 RTS packet

Arguments:

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ANCE command
        CurrentCommand->CommandType = tsctANCE;
        }

    return SendContext;
}

RPC_STATUS ParseD4_A9 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses a D4/A10 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify ANCE
    if (CurrentCommand->CommandType != tsctANCE)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD4_A9 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a D4/A10 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD4_A10(Packet,
        PacketLength
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD5_A5 (
    IN ForwardDestinations Destination
    )
/*++

Routine Description:

    Allocates and initializes a D4/A9 RTS packet

Arguments:

    Destination - destination for forwarding

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)        
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set empty command
        CurrentCommand->CommandType = tsctANCE;
        }

    return SendContext;
}

RPC_STATUS ParseD5_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses a D5/A6 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for the target location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)        
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // verify ANCE
    if (CurrentCommand->CommandType != tsctANCE)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD5_A6 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination
    )
/*++

Routine Description:

    Parses and frees a D5/A5 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    ExpectedDestination - the destination code for this location (client)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseD5_A6(Packet,
        PacketLength,
        ExpectedDestination
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeD5_B1orB2 (
    IN BOOL IsAckOrNak
    )
/*++

Routine Description:

    Allocates and initializes a D5/B1 or D5/B2 RTS packet

Arguments:

    IsAckOrNack - non-zero if this is an ACK and D5/B1 needs
        to go out. If 0, this is a NACK and D5/B2 will go out.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    ASSERT(SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE) == SIZE_OF_RTS_CMD_AND_PADDING(tsctNANCE));

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = 0;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ANCE or NANCE command
        if (IsAckOrNak)
            CurrentCommand->CommandType = tsctANCE;
        else
            CurrentCommand->CommandType = tsctNANCE;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeD5_B1orB2 (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT BOOL *IsAckOrNak
    )
/*++

Routine Description:

    Parses and frees a D5/B1 or D2/B2 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    IsAckOrNak - if success, on output it will contain
        non-zero if the packet was ACK (ANCE or D5/B1)
        or zero if the packet was NACK (NANCE or D5/B2)

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != 0)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify ANCE
    if (CurrentCommand->CommandType == tsctANCE)
        *IsAckOrNak = TRUE;
    else if (CurrentCommand->CommandType == tsctNANCE)
        *IsAckOrNak = FALSE;
    else
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

RPC_STATUS ParseAndFreeD5_B3 (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Parses and frees a D5/B3 RTS packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctANCE)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_EOF)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify ANCE
    if (CurrentCommand->CommandType != tsctANCE)
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeKeepAliveChangePacket (
    IN ULONG NewKeepAliveInterval
    )
/*++

Routine Description:

    Allocates and initializes a keep alive change packet.

Arguments:

    NewKeepAliveInterval - the new keep alive interval in
        milliseconds

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctClientKeepalive;
        CurrentCommand->u.ClientKeepalive = NewKeepAliveInterval;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeKeepAliveChangePacket (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *NewKeepAliveInterval
    )
/*++

Routine Description:

    Parses and frees a keep alive change packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    NewKeepAliveInterval - the new keep alive interval

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctClientKeepalive)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get new client keep alive
    if (CurrentCommand->CommandType != tsctClientKeepalive)
        goto AbortAndExit;
    *NewKeepAliveInterval = CurrentCommand->u.ClientKeepalive;

    if ((*NewKeepAliveInterval < MinimumClientNewKeepAliveInterval)
        && (*NewKeepAliveInterval != 0))
        goto AbortAndExit;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;
}

HTTP2SendContext *AllocateAndInitializeFlowControlAckPacket (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck,
    IN HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Allocates and initializes a flow control ack packet

Arguments:

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we ack to.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ack command
        CurrentCommand->CommandType = tsctFlowControlAck;
        CurrentCommand->u.Ack.BytesReceived = BytesReceivedForAck;
        CurrentCommand->u.Ack.AvailableWindow = WindowForAck;
        RpcpMemoryCopy(CurrentCommand->u.Ack.ChannelCookie.Cookie, CookieForChannel->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

HTTP2SendContext *AllocateAndInitializeFlowControlAckPacketWithDestination (
    IN ForwardDestinations Destination,
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck,
    IN HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Allocates and initializes a flow control ack packet with a forward
        destination

Arguments:

    Destination - the destination to which to forward the packet

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we ack to.

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)        
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 2;

        CurrentCommand = RTS->Cmd;

        // set destination
        CurrentCommand->CommandType = tsctDestination;
        CurrentCommand->u.Destination = Destination;
        CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

        // set ack command
        CurrentCommand->CommandType = tsctFlowControlAck;
        CurrentCommand->u.Ack.BytesReceived = BytesReceivedForAck;
        CurrentCommand->u.Ack.AvailableWindow = WindowForAck;
        RpcpMemoryCopy(CurrentCommand->u.Ack.ChannelCookie.Cookie, CookieForChannel->GetCookie(), COOKIE_SIZE_IN_BYTES);
        }

    return SendContext;
}

RPC_STATUS ParseAndFreeFlowControlAckPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck,
    OUT HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Parses and frees a flow control ack packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we received ack for.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get ack values
    if (CurrentCommand->CommandType != tsctFlowControlAck)
        goto AbortAndExit;

    *BytesReceivedForAck = CurrentCommand->u.Ack.BytesReceived;
    *WindowForAck = CurrentCommand->u.Ack.AvailableWindow;
    CookieForChannel->SetCookie((BYTE *)CurrentCommand->u.Ack.ChannelCookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;    
}

RPC_STATUS ParseAndFreeFlowControlAckPacketWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck,
    OUT HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Parses and frees a flow control ack packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    Destination - the expected destination

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we received ack for.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ParseFlowControlAckPacketWithDestination (
        Packet,
        PacketLength,
        ExpectedDestination,
        BytesReceivedForAck,
        WindowForAck,
        CookieForChannel
        );

    RpcFreeBuffer(Packet);

    return RpcStatus;
}

RPC_STATUS ParseFlowControlAckPacketWithDestination (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN ForwardDestinations ExpectedDestination,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck,
    OUT HTTP2Cookie *CookieForChannel
    )
/*++

Routine Description:

    Parses a flow control ack packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    Destination - the expected destination

    BytesReceivedForAck - the bytes received at the time the
        ack was issued.

    WindowForAck - the available window at the time the ack was
        issued.

    CookieForChannel - the cookie of the channel we received ack for.

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 2
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctDestination)
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctFlowControlAck)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 2)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // verify destination
    if (CurrentCommand->CommandType != tsctDestination)
        goto AbortAndExit;
    if (ExpectedDestination != CurrentCommand->u.Destination)
        goto AbortAndExit;
    CurrentCommand = SkipCommand(CurrentCommand, tsctDestination);

    // get ack values
    if (CurrentCommand->CommandType != tsctFlowControlAck)
        goto AbortAndExit;
    *BytesReceivedForAck = CurrentCommand->u.Ack.BytesReceived;
    *WindowForAck = CurrentCommand->u.Ack.AvailableWindow;
    CookieForChannel->SetCookie((BYTE *)CurrentCommand->u.Ack.ChannelCookie.Cookie);

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    return RpcStatus;    
}

HTTP2SendContext *AllocateAndInitializePingTrafficSentNotifyPacket (
    IN ULONG PingTrafficSentBytes
    )
/*++

Routine Description:

    Allocates and initializes a ping traffic sent packet

Arguments:

    PingTrafficSentBytes - the number of bytes sent in ping traffic

Return Value:

    The allocated send context or NULL for out-of-memory

--*/
{
    HTTP2SendContext *SendContext;
    TunnelSettingsCommand *CurrentCommand;
    rpcconn_tunnel_settings *RTS;

    SendContext = AllocateAndInitializeRTSPacket(
        BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctPingTrafficSentNotify)
        );

    if (SendContext)
        {
        RTS = GetRTSPacketFromSendContext(SendContext);
        RTS->Flags = RTS_FLAG_OTHER_CMD;
        RTS->NumberOfSettingCommands = 1;

        CurrentCommand = RTS->Cmd;

        // set ping traffic sent
        CurrentCommand->CommandType = tsctPingTrafficSentNotify;
        CurrentCommand->u.PingTrafficSent = PingTrafficSentBytes;
        }

    return SendContext;
}

RPC_STATUS ParseAndFreePingTrafficSentNotifyPacket (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    OUT ULONG *PingTrafficSentBytes
    )
/*++

Routine Description:

    Parses a ping traffic sent packet

Arguments:

    Packet - the packet received.

    PacketLength - the length of the packet

    PingTrafficSentBytes - the number of bytes sent in ping traffic

Return Value:

    RPC_S_OK if the packet was successfully parsed and RPC_S_PROTOCOL_ERROR
    otherwise.

--*/
{
    ULONG MemorySize;
    rpcconn_tunnel_settings *RTS = (rpcconn_tunnel_settings *)Packet;
    BYTE *CurrentPosition;
    TunnelSettingsCommand *CurrentCommand;
    RPC_STATUS RpcStatus;

    MemorySize = BaseRTSSizeAndPadding 
        + BaseRTSCommandSize * 1
        + SIZE_OF_RTS_CMD_AND_PADDING(tsctPingTrafficSentNotify)
        ;

    if (PacketLength < MemorySize)
        goto AbortAndExit;

    CurrentPosition = ValidateRTSPacketCommon(Packet, PacketLength);
    if (CurrentPosition == NULL)
        goto AbortAndExit;

    if (RTS->NumberOfSettingCommands != 1)
        goto AbortAndExit;

    if (RTS->Flags != RTS_FLAG_OTHER_CMD)
        goto AbortAndExit;

    CurrentCommand = (TunnelSettingsCommand *)CurrentPosition;

    // get ping traffic sent values
    if (CurrentCommand->CommandType != tsctPingTrafficSentNotify)
        goto AbortAndExit;
    *PingTrafficSentBytes = CurrentCommand->u.PingTrafficSent;

    RpcStatus = RPC_S_OK;
    goto CleanupAndExit;

AbortAndExit:
    RpcStatus = RPC_S_PROTOCOL_ERROR;

CleanupAndExit:
    RpcFreeBuffer(Packet);
    return RpcStatus;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\http2.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    HTTP2.cxx

Abstract:

    HTTP2 transport-specific functions.

Author:

    KamenM      08-30-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <rpcssl.h>
#include <CharConv.hxx>
#include <HttpRTS.hxx>
#include <sdict.hxx>
#include <binding.hxx>
#include <Cookie.hxx>
#include <Http2Log.hxx>
#include <WHttpImp.hxx>

// external definition
TRANS_INFO  *
GetLoadedClientTransportInfoFromId (
    IN unsigned short TransportId
    );

BOOL DefaultChannelLifetimeStringRead = FALSE;
#if DBG
ULONG DefaultChannelLifetime = 128 * 1024;  // 128K for now
char *DefaultChannelLifetimeString = "131072";
ULONG DefaultChannelLifetimeStringLength = 6;   // does not include null terminator
#else
ULONG DefaultChannelLifetime = 1024 * 1024 * 1024;  // 1GB for now
char *DefaultChannelLifetimeString = "1073741824";
ULONG DefaultChannelLifetimeStringLength = 11;   // does not include null terminator
#endif

ULONG DefaultReceiveWindowSize = 64 * 1024;      // 64K

const ULONG ClientReservedChannelLifetime = 4 * 1024;   // 4K
const ULONG ServerReservedChannelLifetime = 8 * 1024;   // 8K

const ULONG DefaultReplacementChannelCallTimeout = 3 * 60 * 1000;   // 3 minutes in milliseconds

const ULONG MinimumConnectionTimeout = 30 * 1000;   // 30 seconds in milliseconds

BOOL ActAsSeparateMachinesOnWebFarm = FALSE;

BOOL AlwaysUseWinHttp = FALSE;

long ChannelIdCounter = 0;

ULONG HTTP2ClientReceiveWindow = HTTP2DefaultClientReceiveWindow;
ULONG HTTP2InProxyReceiveWindow = HTTP2DefaultInProxyReceiveWindow;
ULONG HTTP2OutProxyReceiveWindow = HTTP2DefaultOutProxyReceiveWindow;
ULONG HTTP2ServerReceiveWindow = HTTP2DefaultServerReceiveWindow;

ULONG OverrideMinimumConnectionTimeout = 0;

RPC_CHAR *InChannelTargetTestOverride = NULL;
RPC_CHAR *OutChannelTargetTestOverride = NULL;

/*********************************************************************
    Global Functions and utility classes
 *********************************************************************/

static const RPC_CHAR *HTTP_DEF_CHANNEL_LIFE_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeDefaultChannelLifetime (
    void
    )
/*++

Routine Description:

    Read the default channel lifetime from the registry and
    initialize the default global variable

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    if (DefaultChannelLifetimeStringRead)
        return RPC_S_OK;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_DEF_CHANNEL_LIFE_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"DefaultChannelLifetime",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        DefaultChannelLifetime = Result;
        RpcpItoa(Result, Buffer, 10);
        DefaultChannelLifetimeStringLength = RpcpStringLengthA(Buffer);

        DefaultChannelLifetimeString = new char [DefaultChannelLifetimeStringLength + 1];
        if (DefaultChannelLifetimeString == NULL)
            Status = RPC_S_OUT_OF_MEMORY;
        else
            {
            RpcpMemoryCopy(DefaultChannelLifetimeString, Buffer, DefaultChannelLifetimeStringLength + 1);
            DefaultChannelLifetimeStringRead = TRUE;
            }
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

static const RPC_CHAR *HTTP_ACT_AS_WEB_FARM_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeActAsWebFarm (
    void
    )
/*++

Routine Description:

    Read the act as web farm variable. Used as a test hook to emulate
        web farm on single machine

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_ACT_AS_WEB_FARM_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"ActAsWebFarm",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        ActAsSeparateMachinesOnWebFarm = Result;
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

static const RPC_CHAR *HTTP_USE_HTTP_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeUseWinHttp (
    void
    )
/*++

Routine Description:

    Read the use WinHttp variable. Used as a test hook to force
        WinHttp usage regardless of security

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
#if 1
    // always use WinHttp for now
    return RPC_S_OK;
#else
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_ACT_AS_WEB_FARM_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"UseWinHttp",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        AlwaysUseWinHttp = Result;
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
#endif
}

static const RPC_CHAR *HTTP_RECEIVE_WINDOWS_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc");

RPC_STATUS InitializeReceiveWindows (
    void
    )
/*++

Routine Description:

    Read the receive windows.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];
    RPC_CHAR *Keys[4];
    ULONG *Values[4];
    int i;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)HTTP_RECEIVE_WINDOWS_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Keys[0] = L"ClientReceiveWindow";
    Keys[1] = L"InProxyReceiveWindow";
    Keys[2] = L"OutProxyReceiveWindow";
    Keys[3] = L"ServerReceiveWindow";

    Values[0] = &HTTP2ClientReceiveWindow;
    Values[1] = &HTTP2InProxyReceiveWindow;
    Values[2] = &HTTP2OutProxyReceiveWindow;
    Values[3] = &HTTP2ServerReceiveWindow;

    for (i = 0; i < 4; i ++)
        {
        DwordSize = sizeof(DWORD);

        Status = RegQueryValueExW(
                        h,
                        Keys[i],
                        0,
                        &Type,
                        (LPBYTE) &Result,
                        &DwordSize
                        );

        if (Status == ERROR_SUCCESS
            && Type == REG_DWORD)
            {
            *(Values[i]) = Result;
            }
        }

    // if the type was not REG_DWORD, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return RPC_S_OK;
}

// N.B. This value must agree with the key specified in the system.adm file
static const RPC_CHAR *HTTP_MIN_CONN_TIMEOUT_KEY = 
    L"Software\\Policies\\Microsoft\\Windows NT\\Rpc\\MinimumConnectionTimeout";

RPC_STATUS InitializeMinConnectionTimeout (
    void
    )
/*++

Routine Description:

    Read the minimum connection timeout from the registry/policy.
    An admin may set a lower timeout than the IIS timeout.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  HTTP_MIN_CONN_TIMEOUT_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed with static defaults
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"MinimumConnectionTimeout",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed with static defaults
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD
        && Result >= 90
        && Result <= 14400)
        {
        OverrideMinimumConnectionTimeout = Result * 1000;
        }

    // if the type was not REG_DWORD or out of range, probably registry is corrupted
    // in this case, simply return success, since we don't want a corrupted
    // registry to hose the whole machine

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

// N.B. This value must agree with the key specified in the system.adm file
static const RPC_CHAR *LM_COMPATIBILITY_LEVEL_KEY = 
    L"System\\Currentcontrolset\\Control\\Lsa";

RPC_STATUS IsLanManHashDisabled (
    OUT BOOL *Disabled
    )
/*++

Routine Description:

    Check in the registry whether the lan man hash was disabled.

Arguments:

    Disabled - on successful output, if true, the lan man hash was disabled.
        Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    *Disabled = FALSE;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  LM_COMPATIBILITY_LEVEL_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed as if the hash is enabled
        return RPC_S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"lmcompatibilitylevel",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed as if hash is enabled
        return RPC_S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD
        && Result >= 2)
        {
        *Disabled = TRUE;
        }

    // if the type was not REG_DWORD or out of range, probably registry is corrupted
    // in this case, assume hash is enabled

    if (h)
        {
        RegCloseKey(h);
        }

    return Status;
}

BOOL g_fHttpClientInitialized = FALSE;

BOOL g_fHttpServerInitialized = FALSE;

TRANS_INFO *HTTPTransInfo = NULL;

RPC_STATUS InitializeHttpCommon (
    void
    )
/*++

Routine Description:

    Initialize the common (b/n client & server) Http transport
    if not done already

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    GlobalMutexVerifyOwned();

    if (HTTPTransInfo == NULL)
        {
        HTTPTransInfo = GetLoadedClientTransportInfoFromId(HTTP_TOWER_ID);
        // the TCP transport should have been initialized by now
        ASSERT(HTTPTransInfo);
        }

    return InitializeReceiveWindows();
}

RPC_STATUS InitializeHttpClient (
    void
    )
/*++

Routine Description:

    Initialize the Http client if not done already

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    GlobalMutexRequest();

    if (g_fHttpClientInitialized == FALSE)
        {
        RpcStatus = InitializeHttpCommon();

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = InitializeDefaultChannelLifetime();

            if (RpcStatus == RPC_S_OK)
                {
                RpcStatus = InitializeUseWinHttp();
                if (RpcStatus == RPC_S_OK)
                    {
                    RpcStatus = InitializeMinConnectionTimeout();
                    if (RpcStatus == RPC_S_OK)
                        {
                        g_fHttpClientInitialized = TRUE;
                        }
                    }
                }
            }
        }
    else
        {
        RpcStatus = RPC_S_OK;
        }
    GlobalMutexClear();

    return RpcStatus;
}

RPC_STATUS InitializeHttpServer (
    void
    )
/*++

Routine Description:

    Initialize the Http server if not done already

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    GlobalMutexRequest();

    if (g_fHttpServerInitialized == FALSE)
        {
        RpcStatus = InitializeHttpCommon();

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = CookieCollection::InitializeServerCookieCollection();

            if (RpcStatus == RPC_S_OK)
                {
                g_fHttpServerInitialized = TRUE;
                }
            }
        }
    else
        {
        RpcStatus = RPC_S_OK;
        }
    GlobalMutexClear();

    return RpcStatus;
}

#if 1

#define ShouldUseWinHttp(x)        (TRUE)

#else
BOOL ShouldUseWinHttp (
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials
    )
/*++

Routine Description:

    Based on http credentials determines whether WinHttp
    should be used or raw sockets.

Arguments:

    HttpCredentials - transport credentials

Return Value:

    non-zero - WinHttp should be used. 0 means it is not
    necessary to use WinHttp.

--*/
{
    RPC_STATUS RpcStatus;

    if (AlwaysUseWinHttp)
        return 1;

    if (HttpCredentials == NULL)
        return 0;

    if (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
        return 1;

    if (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME)
        return 1;

    if (HttpCredentials->TransportCredentials)
        return 1;

    if (HttpCredentials->NumberOfAuthnSchemes)
        return 1;

    if (HttpCredentials->AuthnSchemes)
        return 1;

    if (HttpCredentials->ServerCertificateSubject)
        return 1;

    return 0;
}
#endif

void CALLBACK HTTP2TimerCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired  // reason
    )
/*++

Routine Description:

    A periodic timer fired. Reference it, and dispatch to
    the appropriate object.

Arguments:

    lpParameter - the parameter supplied when the timer was
        registered. In our case the HTTP2PingOriginator object

    TimerOrWaitFired - the reason for the callback. Must be timer
        in our case.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2PingOriginator *PingOriginator;
    RPC_STATUS RpcStatus;
    THREAD *Thread;

    ASSERT(TimerOrWaitFired);

    Thread = ThreadSelf();
    // if we can't initialize the thread object, we just return. Worst case
    // the connection will fall apart due to the timeout. That's ok.
    if (Thread == NULL)
        return;

    PingOriginator = (HTTP2PingOriginator *)lpParameter;
    RpcStatus = PingOriginator->ReferenceFromCallback();

    if (RpcStatus == RPC_S_OK)
        PingOriginator->TimerCallback();
}

void CALLBACK HTTP2TimeoutTimerCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired  // reason
    )
/*++

Routine Description:

    A one time timer fired. Dispatch to
    the appropriate object.

Arguments:

    lpParameter - the parameter supplied when the timer was
        registered. In our case the HTTP2TimeoutTargetConnection object

    TimerOrWaitFired - the reason for the callback. Must be timer
        in our case.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2TimeoutTargetConnection *TimerTarget;
    RPC_STATUS RpcStatus;

    ASSERT(TimerOrWaitFired);

    // REVIEW - if this fails, offload to an RPC worker thread?
    ThreadSelf();

    TimerTarget = (HTTP2TimeoutTargetConnection *)lpParameter;

    TimerTarget->TimeoutExpired();
}

void CALLBACK WinHttpCallback (
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    )
/*++

Routine Description:

    The WinHttp callback routine.

Arguments:

    hInternet - The hSession handle specified in a call to WinHttpSetStatusCallback.

    dwContext - Depends on the callback.  May be the Context argument to WinHttpSendRequest

    dwInternetStatus - Status with which an async IO completed.

    lpvStatusInformation - Additional info depending on the callback.

    dwStatusInformationLength - Additional info depending on the callback.

Return Value:

--*/
{
    HTTP2WinHttpTransportChannel *TransportChannel = (HTTP2WinHttpTransportChannel *) dwContext;
    WINHTTP_ASYNC_RESULT *AsyncResult;
    void *SendContext;
    BYTE *Buffer;
    RPC_STATUS RpcStatus;
    ULONG Api;
    BOOL HttpResult;
    ULONG StatusCode;
    ULONG StatusCodeLength;

    // WinHttp bug #541722 - bogus handles can be signalled if we do SSL through proxy. Ignore them
    if (dwContext == NULL)
        return;

    LOG_FN_OPERATION_ENTRY2(HTTP2LOG_OPERATION_WINHTTP_CALLBACK, HTTP2LOG_OT_WINHTTP_CALLBACK, TransportChannel, dwInternetStatus);

    // N.B. After setting the event or posting a runtime event, do not touch
    // the TransportChannel - it could be gone
    switch (dwInternetStatus)
        {
        case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:
            if (TransportChannel->State == whtcsSendingRequest)
                TransportChannel->VerifyServerCredentials();
            break;

        case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
            ASSERT(TransportChannel->State == whtcsSendingRequest);

            // This signals the async completion of WinHttpSendRequest.
            TransportChannel->State = whtcsSentRequest;
            TransportChannel->AsyncError = RPC_S_OK;
            ASSERT(TransportChannel->SyncEvent);
            SetEvent(TransportChannel->SyncEvent);
            break;

        case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
            ASSERT(TransportChannel->State == whtcsReceivingResponse);

            // This signals the async completion of WinHttpReceiveResponse.
            TransportChannel->State = whtcsReceivedResponse;
            TransportChannel->AsyncError = RPC_S_OK;
            TransportChannel->DelayedReceive();
            break;

        case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
            ASSERT(TransportChannel->State == whtcsReceivedResponse);

            // This signals the async completion of WinHttpRead.
            ASSERT(TransportChannel->SyncEvent);
            SetEvent(TransportChannel->SyncEvent);
            break;

        case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
            if (TransportChannel->State == whtcsDraining)
                {
                TransportChannel->ContinueDrainChannel();
                }
            else
                {
                ASSERT(TransportChannel->State == whtcsReading);

                TransportChannel->State = whtcsReceivedResponse;

                // A read has completed asyncronously - issue a callback.
                TransportChannel->AsyncError = RPC_S_OK;
                // harvest the bytes available
                TransportChannel->NumberOfBytesTransferred = *(ULONG *)lpvStatusInformation;
                (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                    TransportChannel
                    );
                }
            break;

        case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:
            ASSERT(TransportChannel->State == whtcsWriting);

            TransportChannel->AsyncError = RPC_S_OK;

            // get the bytes written
            TransportChannel->NumberOfBytesTransferred = *(ULONG *)lpvStatusInformation;
            // A write has completed asyncronously - issue a callback.
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                TransportChannel
                );
            break;

        case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
            // An async IO has failed.  The async IO that can be outstanding is
            // from the following APIs:
            //
            // WinHttpSendRequest, WinHttpReceiveResponse, WinHttpReadData,
            // WinHttpWriteData.
            //
            // Conditions when async IO is outstanding for these APIs correpsond to the
            // states of: whtcsSendingRequest, whtcsReceivingResponse, whtcsReading, 
            // whtcsWriting respectively.
            //
            // We are also notified of the failed API via dwResult field of WINHTTP_ASYNC_RESULT.
            //
            // WinHttpSendRequest and WinHttpReceiveResponse will wait for SyncEvent
            // to be raised.  We will notify them of the failure by setting AsyncError.
            // WinHttpReadData and WinHttpWriteData failures will be propagated to the upper layers
            // via an async callback.
            //
            AsyncResult = (WINHTTP_ASYNC_RESULT *) lpvStatusInformation;
            Api = AsyncResult->dwResult;

            LOG_FN_OPERATION_ENTRY2(HTTP2LOG_OPERATION_WHTTP_ERROR, HTTP2LOG_OT_WINHTTP_CALLBACK, UlongToPtr(Api), AsyncResult->dwError);

            switch (Api)
                {
                case API_SEND_REQUEST:
                    ASSERT(TransportChannel->State == whtcsSendingRequest);
                    // the only two values allowed here are ok or access denied
                    // (which means we didn't like the server certificate name).
                    ASSERT((TransportChannel->AsyncError == RPC_S_OK)
                        || (TransportChannel->AsyncError == RPC_S_INTERNAL_ERROR)
                        || (TransportChannel->AsyncError == RPC_S_ACCESS_DENIED) );
                    TransportChannel->State = whtcsSentRequest;
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_NAME_NOT_RESOLVED,
                        ERROR_NOT_ENOUGH_MEMORY,
                        ERROR_WINHTTP_OPERATION_CANCELLED
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        ASSERT(0);
                        }

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        ASSERT(TransportChannel->AsyncError == RPC_S_ACCESS_DENIED);
                        }

                    // if not access denied, make it send failed
                    if (TransportChannel->AsyncError != RPC_S_ACCESS_DENIED)
                        TransportChannel->AsyncError = RPC_P_SEND_FAILED;
                    ASSERT(TransportChannel->SyncEvent);
                    SetEvent(TransportChannel->SyncEvent);
                    break;

                case API_RECEIVE_RESPONSE:
                    ASSERT(TransportChannel->State == whtcsReceivingResponse);
                    TransportChannel->State = whtcsReceivedResponse;
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_OPERATION_CANCELLED,
                        ERROR_NOT_ENOUGH_MEMORY
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        TransportChannel->AsyncError = RPC_P_AUTH_NEEDED;
                    else
                        TransportChannel->AsyncError = RPC_P_RECEIVE_FAILED;

                    TransportChannel->DelayedReceive();
                    break;

                case API_QUERY_DATA_AVAILABLE:
                    // if we get closed while receiving data, we can be
                    // in draining state
                    ASSERT((TransportChannel->State == whtcsReading)
                        || (TransportChannel->State == whtcsDraining));
                    TransportChannel->State = whtcsReceivedResponse;
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_OPERATION_CANCELLED
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        ASSERT(0);
                        }

                    TransportChannel->AsyncError = RPC_P_RECEIVE_FAILED;
                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                        TransportChannel
                        );
                    break;

                case API_WRITE_DATA:
                    ASSERT(TransportChannel->State == whtcsWriting);
                    VALIDATE(AsyncResult->dwError)
                        {
                        ERROR_WINHTTP_CANNOT_CONNECT,
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_OUT_OF_HANDLES,
                        ERROR_WINHTTP_REDIRECT_FAILED,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SECURE_FAILURE,
                        ERROR_WINHTTP_SHUTDOWN,
                        ERROR_WINHTTP_TIMEOUT,
                        ERROR_WINHTTP_OPERATION_CANCELLED
                        } END_VALIDATE;

                    if (AsyncResult->dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        ASSERT(0);
                        }

                    TransportChannel->AsyncError = RPC_P_SEND_FAILED;
                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                        TransportChannel
                        );
                    break;

                default:
                    ASSERT(0);
                }

            break;

        default:
            // don't care about the other notifications
            break;
        }

    LOG_FN_OPERATION_EXIT2(HTTP2LOG_OPERATION_WINHTTP_CALLBACK, HTTP2LOG_OT_WINHTTP_CALLBACK, TransportChannel, dwInternetStatus);
};
            
RPC_STATUS WaitForSyncSend (
    IN BASE_ASYNC_OBJECT *Connection,
    IN HTTP2SendContext *SendContext,
    IN HTTP2VirtualConnection *Parent,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Waits for a synchronous send to complete.

Arguments:

    Connection - run time view of the transport connection

    SendContext - the send context

    Parent - the parent virtual connection (used to abort)

    fDisableCancelCheck - don't do checks for cancels. Can be
        used as optimization

    Timeout - the call timeout

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2Channel *ThisChannel;

    // the IO was submitted. Wait for it.
    // If fDisableCancelCheck, make the thread wait non-alertably,
    // otherwise, make it wait alertably.
    RpcStatus = UTIL_GetOverlappedHTTP2ResultEx(Connection,
                                        &SendContext->Write.ol,
                                        SendContext->u.SyncEvent,
                                        !fDisableCancelCheck,   // bAlertable
                                        Timeout);

    if (RpcStatus != RPC_S_OK)
        {
        Parent->AbortChannels(RpcStatus);

        if ((RpcStatus == RPC_S_CALL_CANCELLED) || (RpcStatus == RPC_P_TIMEOUT))
            {
            // Wait for the write to finish.  Since we closed the
            // connection this won't take very long.
            UTIL_WaitForSyncHTTP2IO(&SendContext->Write.ol,
                               SendContext->u.SyncEvent,
                               FALSE,   // fAlertable
                               INFINITE     // Timeout
                               );
            }
        }

    return(RpcStatus);
}

void
AddBufferQueueToChannel (
    IN LIST_ENTRY *NewBufferHead,
    IN HTTP2Channel *Channel
    )
/*++

Routine Description:

    Adds all the send contexts from the queue to the front of given channel.
    Presumably the channel has a plug channel down somewhere which does
    the actual ordering work

Arguments:

    NewBufferHead - the list head of the buffer queue. They are assumed to
        be in order.

    Channel - the channel to make the sends on

Return Value:

Notes:

    The new channel must still be plugged.

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *PrevListEntry;
    RPC_STATUS RpcStatus;

    // Queue the sends to the front of the new channel
    // walk the queue in reverse order and add it to the plug channel
    CurrentListEntry = NewBufferHead->Blink;
    while (CurrentListEntry != NewBufferHead)
        {
        QueuedSendContext 
            = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        PrevListEntry = CurrentListEntry->Blink;
        QueuedSendContext->Flags = SendContextFlagPutInFront;
        RpcStatus = Channel->Send(QueuedSendContext);
        // since we know the channel is plugged yet, this cannot fail
        ASSERT(RpcStatus == RPC_S_OK);
        CurrentListEntry = PrevListEntry;
        }

}

void
RPC_CLIENT_PROCESS_IDENTIFIER::SetHTTP2ClientIdentifier (
    IN void *Buffer,
    IN size_t BufferSize,
    IN BOOL fLocal
    )
/*++

Routine Description:

    sets an HTTP2 client identifier

Arguments:

    Buffer - the buffer with the client identifier.

    BufferSize - the number of bytes containg valid 
        info in the buffer.

    fLocal - non-zero if client is local. 0 otherwise.

Return Value:

--*/
{
    BYTE *CurrentPosition;

    this->fLocal = fLocal;
    this->ZeroPadding = 0;
    RpcpMemorySet(u.ULongClientId, 0, sizeof(u.ULongClientId) - BufferSize);
    CurrentPosition = ((BYTE *)u.ULongClientId) + sizeof(u.ULongClientId) - BufferSize;
    RpcpMemoryCopy(CurrentPosition, Buffer, BufferSize);    
}


RPC_STATUS
HttpSendIdentifyResponse(
    IN SOCKET Socket
    )
/*++

Routine Description:

    <TBS>

Arguments:

    Socket -

Return Value:

    None

--*/
{
    RPC_STATUS  Status = RPC_S_OK;
    int         iBytes;
    char        *pszId = HTTP_SERVER_ID_STR;
    DWORD       dwSize;

    iBytes = send(
                Socket,
                pszId,
                HTTP_SERVER_ID_STR_LEN,
                0
                );

    if (iBytes == SOCKET_ERROR)
        {
        VALIDATE(GetLastError())
            {
            WSAENETDOWN,
            WSAECONNREFUSED,
            WSAECONNRESET,
            WSAENETRESET,
            WSAETIMEDOUT
            } END_VALIDATE;

        Status = RPC_S_OUT_OF_RESOURCES;
        }

    return Status;
}

RPC_STATUS
HTTP_TryConnect( SOCKET Socket,
                 char  *pszProxyMachine,
                 USHORT iPort             )
/*++

Routine Description:

    Used by HTTP_Open() to actually call the connect(). HTTP_Open() will try
    first to reach the RPC Proxy directly, if it can't then it will call this
    routine again to try to reach an HTTP proxy (i.e. MSProxy for example).

Arguments:

    Socket          - The socket to use in the connect().
    pszProxyMachine - The name of the machine to try to connect() to.
    iPort           - The port to connect() on.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS  Status = RPC_S_OK;
    WS_SOCKADDR ProxyServer;
    RPC_CHAR pwszBuffer[MAX_HTTP_COMPUTERNAME_SIZE+1];

    //
    // Check for empty proxy machine name:
    //
    if ( (!pszProxyMachine) || (*pszProxyMachine == 0))
        {
        return RPC_S_SERVER_UNAVAILABLE;
        }

    memset((char *)&ProxyServer, 0, sizeof(ProxyServer));

    //
    // Resolve the machine name (or dot-notation address) into
    // a network address. If that works then try to connect
    // using the supplied port.
    //
    SimpleAnsiToPlatform(pszProxyMachine,pwszBuffer);
    IP_ADDRESS_RESOLVER resolver(pwszBuffer, 
        cosClient,
        ipvtuIPv4       // IP version to use
        );

    Status = resolver.NextAddress(&ProxyServer.inetaddr);
    if (Status == RPC_S_OK)
        {
        ProxyServer.inetaddr.sin_family = AF_INET;
        ProxyServer.inetaddr.sin_port   = htons(iPort);

        //
        // Try to connect...
        //
        if (SOCKET_ERROR == connect(Socket,
                                    (struct sockaddr *)&ProxyServer.inetaddr,
                                    sizeof(ProxyServer.inetaddr)))
            {
            #if DBG_ERROR
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "HTTP_Open(): connect() failed: %d\n",
                           WSAGetLastError()));

            #endif // DBG_ERROR

            VALIDATE(GetLastError())
                {
                WSAENETDOWN,
                WSAEADDRNOTAVAIL,
                WSAECONNREFUSED,
                WSAECONNABORTED,
                WSAENETUNREACH,
                WSAEHOSTUNREACH,
                WSAENOBUFS,
                WSAETIMEDOUT
                } END_VALIDATE;

            Status = RPC_S_SERVER_UNAVAILABLE;
            }
        }

    return Status;
}

RPC_STATUS HTTP2Cookie::Create (
    void
    )
/*++

Routine Description:

    Create a cryptographically strong HTTP2 cookie

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* failure

--*/
{
    return GenerateRandomNumber(Cookie, sizeof(Cookie));
}

void HTTPResolverHint::VerifyInitialized (
    void
    )
/*++

Routine Description:

    Verify that the resolver hint is properly initialized and consistent

Arguments:

Return Value:

--*/
{
    ASSERT(RpcServer);
    ASSERT(ServerPort != 0);
    ASSERT(RpcProxy);
    ASSERT(RpcProxyPort != 0);
    if (HTTPProxy)
        {
        ASSERT(HTTPProxyPort != 0);
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_Initialize (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * /* NetworkAddress */,
    IN RPC_CHAR * /* NetworkOptions */,
    IN BOOL /* fAsync */
    )
/*++

Routine Description:

    Called by the runtime to do initial initialization of the transport
    object. The purpose of this initialization is to allow the transport
    to do some minimal initialization sufficient to ensure ordely 
    destruction in case of failure.

Arguments:

    ThisConnection - an uninitialized connection allocated by the runtime
    NetworkAddress - ignored
    NetworkOptions - ignored
    fAsync - ignored

Return Value:

    RPC_S_OK for success of RPC_S_* / Win32 error for error.

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;

    BaseObject->id = INVALID_PROTOCOL_ID;

    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
HTTP_CheckIPAddressForDirectConnection (
    IN HTTPResolverHint *Hint
    )
/*++

Routine Description:

    Checks if the rpc proxy server address given in the hint should be used
    for direct connection based on registry settings

Arguments:

    Hint - the resolver hint

Return Value:

    RPC_S_OK or RPC_S_* / win32 error code

--*/
{
    HKEY RpcOptionsKey;
    DWORD Status;
    DWORD KeyType;
    const RPC_CHAR *UseProxyForIPAddrIfRDNSFailsRegKey = RPC_CONST_STRING("UseProxyForIPAddrIfRDNSFails");
    const RPC_CHAR *RpcRegistryOptions =
                RPC_CONST_STRING("Software\\Microsoft\\Rpc");
    DWORD UseProxyForIPAddrIfRDNSFails;
    DWORD RegKeySize;
    int err;
    ADDRINFO AddrHint;
    ADDRINFO *AddrInfo;

    RpcpMemorySet(&AddrHint, 0, sizeof(ADDRINFO));
    AddrHint.ai_flags = AI_NUMERICHOST;

    err = getaddrinfo(Hint->RpcProxy, 
        NULL, 
        &AddrHint,
        &AddrInfo
        );

    ASSERT((err != EAI_BADFLAGS)
        && (err != EAI_SOCKTYPE));

    if (err)
        {
        // the address was not numeric. It's not up to us to tell
        // where this should go
        return RPC_S_OK;
        }

    // assume direct connection for now    
    Hint->AccessType = rpcpatDirect;

    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         (const RPC_SCHAR *)RpcRegistryOptions,
                         &RpcOptionsKey );

    if (Status != ERROR_SUCCESS)
        {
        // direct connection is already set
        goto CleanupAndExit;
        }

    RegKeySize = sizeof(DWORD);
    Status = RegQueryValueEx(RpcOptionsKey,
                             (const RPC_SCHAR *)UseProxyForIPAddrIfRDNSFailsRegKey,
                             NULL,
                             &KeyType,
                             (LPBYTE)&UseProxyForIPAddrIfRDNSFails,
                             &RegKeySize);

    RegCloseKey(RpcOptionsKey);

    if ( (Status != ERROR_SUCCESS) ||
         (KeyType != REG_DWORD) )
        {
        // direct connection is already set
        goto CleanupAndExit;
        }

    if (UseProxyForIPAddrIfRDNSFails != 1)
        {
        // direct connection is already set
        goto CleanupAndExit;
        }

    err = getnameinfo(AddrInfo->ai_addr,
        AddrInfo->ai_addrlen,
        NULL,
        0,
        NULL,
        0,
        NI_NAMEREQD
        );

    if (err)
        {
        Hint->AccessType = rpcpatHTTPProxy;
        }
    // else
    // direct connection is already set

CleanupAndExit:
    freeaddrinfo(AddrInfo);

    return RPC_S_OK;
}

void
RPC_ENTRY HTTP_FreeResolverHint (
    IN void *ResolverHint
    )
/*++

Routine Description:

    Called by the runtime to free the resolver hint.

Arguments:

    ResolverHint - the resolver hint created by the transport.

Return Value:

--*/
{
    HTTPResolverHint *Hint = (HTTPResolverHint *)ResolverHint;

    Hint->FreeHTTPProxy();
    Hint->FreeRpcProxy();
    Hint->FreeRpcServer();
}

RPC_STATUS
RPC_ENTRY HTTP_CopyResolverHint (
    IN void *TargetResolverHint,
    IN void *SourceResolverHint,
    IN BOOL SourceWillBeAbandoned
    )
/*++

Routine Description:

    Tells the transport to copy the resolver hint from Source to Target

Arguments:

    TargetResolverHint - pointer to the target resolver hint

    SourceResolverHint - pointer to the source resolver hint

    SourceWillBeAbandoned - non-zero if the source hint was in temporary
        location and will be abandoned. Zero otherwise.

Return Value:

    if SourceWillBeAbandoned is specified, this function is guaranteed
    to return RPC_S_OK. Otherwise, it may return RPC_S_OUT_OF_MEMORY as well.

--*/
{
    HTTPResolverHint *TargetHint = (HTTPResolverHint *)TargetResolverHint;
    HTTPResolverHint *SourceHint = (HTTPResolverHint *)SourceResolverHint;
    ULONG HTTPProxyNameLength;

    ASSERT(TargetHint != SourceHint);

    // bulk copy most of the stuff, and then hand copy few items
    RpcpMemoryCopy(TargetHint, SourceHint, sizeof(HTTPResolverHint));

    if (SourceWillBeAbandoned)
        {
        // the source hint will be abandoned - just hijack all
        // embedded pointers
        if (SourceHint->RpcServer == SourceHint->RpcServerName)
            TargetHint->RpcServer = TargetHint->RpcServerName;
        SourceHint->HTTPProxy = NULL;
        SourceHint->RpcProxy = NULL;
        SourceHint->RpcServer = NULL;
        }
    else
        {
        TargetHint->HTTPProxy = NULL;
        TargetHint->RpcProxy = NULL;
        TargetHint->RpcServer = NULL;
        if (SourceHint->HTTPProxy)
            {
            HTTPProxyNameLength = RpcpStringLengthA(SourceHint->HTTPProxy) + 1;
            TargetHint->HTTPProxy = new char [HTTPProxyNameLength];
            if (TargetHint->HTTPProxy == NULL)
                goto FreeTargetHintAndExit;
            RpcpMemoryCopy(TargetHint->HTTPProxy, SourceHint->HTTPProxy, HTTPProxyNameLength);
            }

        TargetHint->RpcProxy = new char [SourceHint->ProxyNameLength + 1];
        if (TargetHint->RpcProxy == NULL)
            goto FreeTargetHintAndExit;
        RpcpMemoryCopy(TargetHint->RpcProxy, SourceHint->RpcProxy, SourceHint->ProxyNameLength + 1);

        if (SourceHint->RpcServer == SourceHint->RpcServerName)
            TargetHint->RpcServer = TargetHint->RpcServerName;
        else
            {
            TargetHint->RpcServer = new char [SourceHint->ServerNameLength + 1];
            if (TargetHint->RpcServer == NULL)
                goto FreeTargetHintAndExit;
            RpcpMemoryCopy(TargetHint->RpcServer, SourceHint->RpcServer, SourceHint->ServerNameLength + 1);
            }
        }

    return RPC_S_OK;

FreeTargetHintAndExit:
    TargetHint->FreeHTTPProxy();
    TargetHint->FreeRpcProxy();
    TargetHint->FreeRpcServer();

    return RPC_S_OUT_OF_MEMORY;
}

int
RPC_ENTRY HTTP_CompareResolverHint (
    IN void *ResolverHint1,
    IN void *ResolverHint2
    )
/*++

Routine Description:

    Tells the transport to compare the given 2 resolver hints

Arguments:

    ResolverHint1 - pointer to the first resolver hint

    ResolverHint2 - pointer to the second resolver hint

Return Value:

    (same semantics as memcmp)
    0 - the resolver hints are equal
    non-zero - the resolver hints are not equal

--*/
{
    HTTPResolverHint *Hint1 = (HTTPResolverHint *)ResolverHint1;
    HTTPResolverHint *Hint2 = (HTTPResolverHint *)ResolverHint2;

    if (Hint1->Version != Hint2->Version)
        return 1;

    if (Hint1->ServerPort != Hint2->ServerPort)
        return 1;

    if (Hint1->ServerNameLength != Hint2->ServerNameLength)
        return 1;

    return RpcpMemoryCompare(Hint1->RpcServer, Hint2->RpcServer, Hint1->ServerNameLength);
}

RPC_STATUS RPC_ENTRY 
HTTP_SetLastBufferToFree (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN void *Buffer
    )
/*++

Routine Description:

    Tells the transport what buffer to free when it is done with the last send

Arguments:

    ThisConnection - connection to act on.

    Buffer - pointer of the buffer to free. Must be freed using 
        RpcFreeBuffer/I_RpcTransConnectionFreePacket

Return Value:

    RPC_S_OK - the last buffer to free was accepted by the transport

    RPC_S_CANNOT_SUPPORT - the transport does not support this functionality

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2ServerVirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    if (BaseObject->id == HTTPv2)
        {
        // this must be called on server connections only
        ASSERT(BaseObject->type == (COMPLEX_T | CONNECTION | SERVER));
        VirtualConnection = (HTTP2ServerVirtualConnection *) ThisConnection;

        VirtualConnection->SetLastBufferToFree(Buffer);

        return RPC_S_OK;
        }
    else
        {
        return RPC_S_CANNOT_SUPPORT;
        }
}
    

RPC_STATUS
RPC_ENTRY
HTTP_Open (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN PVOID ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection

    ProtocolSeqeunce - "ncacn_http"

    NetworkAddress - The name of the server, either a dot address or DNS name

    NetworkOptions - the http binding handle options (e.g. HttpProxy/RpcProxy)

    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite

    SendBufferSize - ignored

    RecvBufferSize - ignored

    ResolverHint - pointer to the resolver hint object

    fHintInitialized - non-zero if the ResolverHint points to previously
        initialized memory. 0 otheriwse.

    CallTimeout - call timeout in milliseconds

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given

    AdditionalCredentials - additional credentials that we were given.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    HTTPResolverHint *Hint = (HTTPResolverHint *)ResolverHint;
    char *RpcProxyPort = NULL;
    char *HttpProxyPort = NULL;
    BOOL NetworkAddressAllocated;
    BOOL Result;
    char PortString[20];
    ULONG   StringLength;
    RPC_STATUS Status;
    RPC_STATUS RetValue;
    PWS_CCONNECTION p = (PWS_CCONNECTION) ThisConnection;
    HTTP2ClientVirtualConnection *VirtualConnection = (HTTP2ClientVirtualConnection *) ThisConnection;
    BOOL Retry;
    BOOL fUserModeConnection;
    BOOL HintNeedsCleanup;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
    BOOL UseSSLPort;
    ULONG HostAddr;
    BOOL LocalDirect;

    ASSERT(NetworkAddress);
    ASSERT(Endpoint);

    ASSERT(RpcpStringCompare(ProtocolSequence, L"ncacn_http") == 0);

    if (AdditionalTransportCredentialsType != 0)
        {
        if (AdditionalTransportCredentialsType != RPC_C_AUTHN_INFO_TYPE_HTTP)
            {
            ASSERT(0);
            return RPC_S_CANNOT_SUPPORT;
            }
        ASSERT(AdditionalCredentials != NULL);
        }

    HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *) AdditionalCredentials;

    Status = InitializeHttpClientIfNecessary();
    if (Status != RPC_S_OK)
        return Status;

    HintNeedsCleanup = FALSE;

    // Check the resolver hint. If not initialized, initialize all
    // fields in the hint
    if (fHintInitialized == FALSE)
        {
        RpcProxyPort = NULL;
        HttpProxyPort = NULL;
        Hint->HTTPProxy = NULL;
        Hint->RpcProxy = NULL;
        Hint->RpcServer = NULL;

        Status = Hint->AssociationGroupId.Create();
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        // the TCP transport should have been initialized by now
        ASSERT(HTTPTransInfo);

        Status = HTTPTransInfo->StartServerIfNecessary();
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        StringLength = RpcpStringLength(NetworkAddress);

        //
        // RPC Server Name
        //
        if (StringLength == 0)
            {
            // no server name was specified. Use local machine name
            NetworkAddress = AllocateAndGetComputerName(cnaNew, 
                ComputerNamePhysicalDnsFullyQualified,
                0,      // ExtraBytes
                0,      // Starting offset
                &StringLength
                );

            if (NetworkAddress == NULL)
                return RPC_S_OUT_OF_MEMORY;
            NetworkAddressAllocated = TRUE;
            }
        else
            {
            // make space for terminating NULL
            StringLength += 1;
            NetworkAddressAllocated = FALSE;
            }

        // StringLength is in characters and includes terminating null
        if (StringLength <= sizeof(Hint->RpcServerName))
            {
            Hint->RpcServer = Hint->RpcServerName;
            LogEvent(SU_HTTPv2, EV_SET, &Hint->RpcServer, Hint->RpcServer, 0, 1, 0);
            }
        else
            {
            Hint->RpcServer = new char [StringLength];
            LogEvent(SU_HTTPv2, EV_SET, &Hint->RpcServer, Hint->RpcServer, 1, 1, 0);
            if (Hint->RpcServer == NULL)
                {
                if (NetworkAddressAllocated)
                    delete NetworkAddress;
                return RPC_S_OUT_OF_MEMORY;
                }
            }

        SimplePlatformToAnsi(NetworkAddress, Hint->RpcServer);

        // subtract 1 to eliminate terminating NULL
        Hint->ServerNameLength = StringLength - 1;

        if (NetworkAddressAllocated)
            {
            delete NetworkAddress;
            NetworkAddress = NULL;
            }

        // by now Hint->RpcServer points to the ascii name for the server
        ASSERT(Hint->RpcServer);

        //
        // At this point, we know the destination server/port, but don't yet know
        // if we need to go through an HTTP proxy, and what the IIS RPC proxy
        // machine is. We'll get these, if specified from the network options
        // and the registry.
        //
        if (HttpCredentials && (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL))
            UseSSLPort = TRUE;
        else
            UseSSLPort = FALSE;

        Result = HttpParseNetworkOptions(
                 NetworkOptions,
                 Hint->RpcServer,
                 &(Hint->RpcProxy),
                 &RpcProxyPort,
                 UseSSLPort,
                 &(Hint->HTTPProxy),
                 &HttpProxyPort,
                 &(Hint->AccessType),
                 (unsigned long *) &Status
                 );

        if (Result == FALSE)
            {
            ASSERT(Status != RPC_S_OK);
            Hint->FreeRpcServer();
            return Status;
            }
        else
            {
            if (Hint->AccessType != rpcpatDirect)
                {
                ASSERT(Hint->HTTPProxy);
                // if the proxy name is empty, set the method to direct
                if (Hint->HTTPProxy[0] == 0)
                    Hint->AccessType = rpcpatDirect;
                }
            ASSERT(Status == RPC_S_OK);
            HintNeedsCleanup = TRUE;
            }

        Status = EndpointToPortNumber(Endpoint, Hint->ServerPort);
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        Status = EndpointToPortNumberA(RpcProxyPort, Hint->RpcProxyPort);
        if (Status != RPC_S_OK)
            {
            RetValue = Status;
            goto AbortAndCleanup;
            }

        Hint->ProxyNameLength = RpcpStringLengthA(Hint->RpcProxy);

        if (Hint->HTTPProxy)
            {
            Status = EndpointToPortNumberA(HttpProxyPort, Hint->HTTPProxyPort);
            if (Status != RPC_S_OK)
                {
                RetValue = Status;
                goto AbortAndCleanup;
                }
            }

        // we will optimistically presume that we can talk HTTP2
        // until proven wrong
        Hint->Version = httpvHTTP2;

        // by now the resolver hint is fully initialized. fall through
        // the case that has initialized resolver hint
        }

    Hint->VerifyInitialized();

    // disable retries by default. If we have to loop around, we will set it to TRUE
    Retry = FALSE;

    do
        {
        // we have it all now.
        if (Hint->Version == httpvHTTP2)
            {
            // use explicit placement
            VirtualConnection = new (ThisConnection) HTTP2ClientVirtualConnection (
                (RPC_HTTP_TRANSPORT_CREDENTIALS *)AdditionalCredentials,
                &Status);
            if (Status != RPC_S_OK)
                {
                VirtualConnection->HTTP2ClientVirtualConnection::~HTTP2ClientVirtualConnection();
                RetValue = Status;
                goto AbortAndCleanup;
                }

            Status = VirtualConnection->ClientOpen(Hint,
                fHintInitialized,
                ConnTimeout,
                CallTimeout
                );

            // if we got a protocol error or a receive failed, and
            // we don't have credentials, fall back to old protocol.
            if (
                (
                 (Status == RPC_S_PROTOCOL_ERROR)
                 || 
                 (Status == RPC_P_RECEIVE_FAILED)
                )
                &&
                (HttpCredentials == NULL)
               )
                {
                // cause the loop to start over.
                // make sure next iteration it tries old http
                Hint->Version = httpvHTTP;
                Retry = TRUE;
                }
            else
                {
                if ((Status == RPC_S_PROTOCOL_ERROR)
                    || 
                    (Status == RPC_P_RECEIVE_FAILED))
                    {
                    Status = RPC_S_SERVER_UNAVAILABLE;
                    }

                ASSERT(Status != RPC_P_PACKET_CONSUMED);
                RetValue = Status;
                VirtualConnection->id = HTTPv2;
                if (Status == RPC_S_OK)
                    goto CleanupAndExit;
                else
                    goto AbortAndCleanup;
                }
            }
        else
            {
            ASSERT(Hint->Version == httpvHTTP);

            // HTTP1 doesn't support proxy discovery. If we don't know
            // just assume local and hope it works.
            if (Hint->AccessType == rpcpatUnknown)
                Hint->AccessType = rpcpatDirect;

            // we need to re-initialize the connection object with old
            // format connection
            WS_Initialize(p, 0, 0, 0);

            // use explicit placement to initialize the vtable. We need this to
            // be able to use the virtual functions
            p = new (p) WS_CLIENT_CONNECTION;

            p->id = HTTP;

            // Call common open function. Note that for http connection
            // WS_Open will just open a socket. That's all we need right now.
            Status = WS_Open(p, 
                NULL, 
                ConnTimeout, 
                SendBufferSize, 
                RecvBufferSize, 
                CallTimeout,
                FALSE       // fHTTP2Open
                );
            if (Status != RPC_S_OK)
                {
                RetValue = Status;
                goto AbortAndCleanup;
                }

            //
            // WS_Open has been successfully called. Do connect() work here...
            //

            // If AccessType is direct, then we are going to try to directly
            // connect to the IIS that is the RPC Proxy first. If that suceeds,
            // then we will just tunnel to the RPC server from there. If it fails,
            // then we will try to go through an HTTP proxy (i.e. MSProxy server)
            // if one is available...
            if (Hint->AccessType != rpcpatHTTPProxy)
                {
                Status = HTTP_CheckIPAddressForDirectConnection(Hint);
                if (Status != RPC_S_OK)
                    {
                    RetValue = RPC_S_OUT_OF_MEMORY;
                    goto AbortAndCleanup;
                    }

                if (Hint->AccessType == rpcpatDirect)
                    {
                    Status = HTTP_TryConnect( p->Conn.Socket, Hint->RpcProxy, Hint->RpcProxyPort );
                    }
                }

            if ((Status != RPC_S_OK) || (Hint->AccessType != rpcpatDirect))
                {
                //
                // If we get here, then we are going to try to use an HTTP proxy first...
                //
                Status = HTTP_TryConnect( p->Conn.Socket, Hint->HTTPProxy, Hint->HTTPProxyPort );

                //
                // If we successfully connected to the HTTP proxy, then let's go on and
                // tunnel through to the RPC proxy:
                //
                if (Status != RPC_S_OK)
                    {
                    RetValue = RPC_S_SERVER_UNAVAILABLE;
                    goto Abort;
                    }

                PortNumberToEndpointA(Hint->RpcProxyPort, PortString);

                if (!HttpTunnelToRpcProxy(p->Conn.Socket,
                                          Hint->RpcProxy,
                                          PortString))
                    {
                    RetValue = RPC_S_SERVER_UNAVAILABLE;
                    goto Abort;
                    }
                }

            //
            // Finally, negotiate with the RPC proxy to get the connection through to
            // the RPC server.
            //

            PortNumberToEndpointA(Hint->ServerPort, PortString);

            if (!HttpTunnelToRpcServer( p->Conn.Socket,
                                        Hint->RpcServer,
                                        PortString ))
                {
                RetValue = RPC_S_SERVER_UNAVAILABLE;
                goto Abort;
                }

            fUserModeConnection = IsUserModeSocket(p->Conn.Socket, &RetValue);
            if (RetValue != RPC_S_OK)
                goto Abort;

            // if this is SAN or loadable transport not using true handles, go through Winsock
            if (fUserModeConnection)
                p = new (p) WS_SAN_CLIENT_CONNECTION;

            Retry = FALSE;
            }
        }
    while (Retry);

    RetValue = RPC_S_OK;
    goto CleanupAndExit;

Abort:
    p->WS_CONNECTION::Abort();

AbortAndCleanup:
    if (HintNeedsCleanup)
        {
        ASSERT(RetValue != RPC_S_OK);
        Hint->FreeRpcServer();
        Hint->FreeRpcProxy();
        Hint->FreeHTTPProxy();
        }

CleanupAndExit:

    VALIDATE (RetValue)
        {
        RPC_S_OK,
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_SERVER_UNAVAILABLE,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_SERVER_TOO_BUSY,
        RPC_S_INVALID_NETWORK_OPTIONS,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_INVALID_NET_ADDR,
        RPC_S_ACCESS_DENIED,
        RPC_S_INTERNAL_ERROR,
        RPC_S_SERVER_OUT_OF_MEMORY,
        RPC_S_CALL_CANCELLED
        } END_VALIDATE;

    if (RpcProxyPort != NULL)
        delete RpcProxyPort;

    if (HttpProxyPort != NULL)
        delete HttpProxyPort;

    if (Hint->ServerNameLength <= sizeof(Hint->RpcServerName))
        {
        ASSERT(Hint->RpcServer == Hint->RpcServerName);
        }

    return (RetValue);
}




RPC_STATUS
HTTP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
{
    RPC_STATUS RpcStatus;

    RpcStatus = InitializeHttpServerIfNecessary();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    return (TCP_ServerListenEx(
                ThisAddress,
                NetworkAddress,
                pEndpoint,
                PendingQueueSize,
                SecurityDescriptor,
                EndpointFlags,
                NICFlags,
                TRUE,           // HTTP!
                ppAddressVector
                ));
}

void WINAPI ProxyIoCompletionCallback (
    IN LPEXTENSION_CONTROL_BLOCK lpECB,
    IN PVOID pContext,
    IN DWORD cbIO,
    IN DWORD dwError
    )
/*++

Routine Description:

    IIS io completion callback function

Arguments:

    lpECB - extension control block

    pContext - the IISChannel pointer.

    cbIO - Bytes transferred in the last operation

    dwError - status of the operation

Return Value:

--*/
{
    HTTP2IISTransportChannel *IISChannel;
    THREAD *Thread;

    Thread = ThreadSelf();
    if (Thread == NULL)
        return;     // abandon the completion if worse comes to worse.

    IISChannel = (HTTP2IISTransportChannel *)pContext;

    IISChannel->IOCompleted(cbIO, dwError);
}

BOOL RPCTransInitialized = FALSE;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN ULONG ConnectionType,
    IN USHORT *ServerAddress,
    IN USHORT *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    )
/*++

Routine Description:

    Entry point from the ISAPI extension. Called when a new
    connection request arrives at an in or out proxy.

Arguments:

    ConnectionType - currently RPC_PROXY_CONNECTION_TYPE_IN_PROXY or
        RPC_PROXY_CONNECTION_TYPE_OUT_PROXY to indicate the type of
        connection establishment request we have received
    ServerAddress - unicode network address of the server
    ServerPort - unicode port of the server
    ConnectionParameter - the Extension Control Block in this case.
    ProxyCallbackInterface - a callback interface to the proxy to perform
        various proxy specific functions

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    EXTENSION_CONTROL_BLOCK *ECB;
    void *IISContext;
    BOOL Result;
    RPC_TRANSPORT_INTERFACE TransInterface;
    TRANS_INFO *TransInfo;
    THREAD *ThisThread;
    HTTP2ProxyVirtualConnection *ProxyVirtualConnection;

    if (RPCTransInitialized == FALSE)
        {
        InitializeIfNecessary();

        GlobalMutexRequest();

        // all of the initialization here is idempotent.
        // If we fail midway, we don't have to un-initialize - 
        // next initialization attempt will pick up where we left.

        RpcStatus = OsfMapRpcProtocolSequence(FALSE,
            L"ncacn_http",
            &TransInfo);

        if (RpcStatus == RPC_S_OK)
            {
            ASSERT(TransInfo);

            if (HTTPTransInfo == NULL)
                HTTPTransInfo = TransInfo;

            RpcStatus = TransInfo->StartServerIfNecessary();

            if (RpcStatus == RPC_S_OK)
                {
                RpcStatus = InitializeDefaultChannelLifetime();

                if (RpcStatus == RPC_S_OK)
                    {
                    RpcStatus = InitializeActAsWebFarm();
                    if (RpcStatus == RPC_S_OK)
                        {
                        RpcStatus = InitializeMinConnectionTimeout();
                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = CookieCollection::InitializeInProxyCookieCollection();
                            if (RpcStatus == RPC_S_OK)
                                {
                                RpcStatus = CookieCollection::InitializeOutProxyCookieCollection();
                                if (RpcStatus == RPC_S_OK)
                                    {
                                    RpcStatus = InitializeReceiveWindows();
                                    }
                                }
                            }
                        }
                    }
                }
            }

        RPCTransInitialized = (RpcStatus == RPC_S_OK);
        GlobalMutexClear();

        if (RpcStatus != RPC_S_OK)
            {
            return RPC_S_OK;
            }
        }

    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (ConnectionType == RPC_PROXY_CONNECTION_TYPE_IN_PROXY)
        {
        ProxyVirtualConnection = new HTTP2InProxyVirtualConnection(&RpcStatus);
        }
    else
        {
        ASSERT(ConnectionType == RPC_PROXY_CONNECTION_TYPE_OUT_PROXY);
        ProxyVirtualConnection = new HTTP2OutProxyVirtualConnection(&RpcStatus);
        }

    if (ProxyVirtualConnection == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (RpcStatus != RPC_S_OK)
        {
        delete ProxyVirtualConnection;
        return RpcStatus;
        }

    RpcStatus = ProxyVirtualConnection->InitializeProxyFirstLeg(ServerAddress,
        ServerPort,
        ConnectionParameter,
        ProxyCallbackInterface,
        &IISContext
        );

    if (RpcStatus != RPC_S_OK)
        {
        delete ProxyVirtualConnection;
        return RpcStatus;
        }

    // we have initialized far enough. Associate callback
    // with this connection
    ECB = (EXTENSION_CONTROL_BLOCK *) ConnectionParameter;

    Result = ECB->ServerSupportFunction (ECB->ConnID,
        HSE_REQ_IO_COMPLETION,
        ProxyIoCompletionCallback,
        NULL,
        (LPDWORD)IISContext
        );

    if (Result == FALSE)
        {
        ProxyVirtualConnection->Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcStatus = ProxyVirtualConnection->StartProxy();
    if (RpcStatus != RPC_S_OK)
        {
        ProxyVirtualConnection->Abort();
        // fall through to the end of the function
        }

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2IISDirectReceive (
    IN void *Context
    )
/*++

Routine Description:

    Direct notification from the thread pool to an IIS channel
    for a receive. The proxy stacks use that to post receives
    to themselves.

Arguments:

    Context - the HTTP2IISTransportChannel

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ((HTTP2IISTransportChannel *)Context)->DirectReceive();

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2DirectReceive (
    IN void *Context,
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection,
    OUT BOOL *IsServer
    )
/*++

Routine Description:

    Direct notification from the thread pool to a receiver
    for a receive. The stacks use that to post receives
    to themselves.

Arguments:

    Context - an instance of the HTTP2EndpointReceiver

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

    IsServer - true if this is the server 

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_RECV_COMPLETE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)Context);

    RpcStatus = ((HTTP2EndpointReceiver *)Context)->DirectReceiveComplete(
        ReceivedBuffer,
        ReceivedBufferLength,
        RuntimeConnection,
        IsServer
        );

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_RECV_COMPLETE, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2WinHttpDirectReceive (
    IN void *Context,
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection
    )
/*++

Routine Description:

    Direct notification from the thread pool to a receiver
    for a receive. The stacks use that to post receives
    to themselves.

Arguments:

    Context - an instance of HTTP2WinHttpTransportChannel

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_WHTTP_DRECV_COMPLETE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)Context);

    RpcStatus = ((HTTP2WinHttpTransportChannel *)Context)->DirectReceiveComplete(
        ReceivedBuffer,
        ReceivedBufferLength,
        RuntimeConnection
        );

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_WHTTP_DRECV_COMPLETE, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2WinHttpDirectSend (
    IN void *Context,
    OUT BYTE **SentBuffer,
    OUT void **SendContext
    )
/*++

Routine Description:

    Direct notification from the thread pool to a sender
    for a send. The stacks use that to post sends
    to themselves.

Arguments:

    Context - an instance of HTTP2WinHttpTransportChannel

    SentBuffer - the buffer that we sent.

    SendContext - the send context to return to the runtime
        if the packet is not consumed.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_OPERATION_WHTTP_DSEND_COMPLETE, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)Context);

    RpcStatus = ((HTTP2WinHttpTransportChannel *)Context)->DirectSendComplete(
        SentBuffer,
        SendContext
        );

    LOG_FN_OPERATION_EXIT(HTTP2LOG_OPERATION_WHTTP_DSEND_COMPLETE, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2PlugChannelDirectSend (
    IN void *Context
    )
/*++

Routine Description:

    Direct notification from the thread pool to the plug channel
    for a send. The plug channel uses that to post sends
    to itself. Usable only on proxies (i.e. doesn't return to runtime)

Arguments:

    Context - an instance of HTTP2PlugChannel

Return Value:

    RPC_S_OK

--*/
{
    return ((HTTP2PlugChannel *)Context)->DirectSendComplete();
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2FlowControlChannelDirectSend (
    IN void *Context,
    OUT BOOL *IsServer,
    OUT BOOL *SendToRuntime,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct notification from the thread pool to the flow control channel
    for a send. The flow control channel uses that to post sends
    to itself.

Arguments:

    Context - an instance of HTTP2FlowControlSender

    IsServer - on both success and failure MUST be set by this function.

    SendToRuntime - on both success and failure MUST be set by this function.

    SendContext - the send context as needs to be seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK

--*/
{
    RPC_STATUS RpcStatus;

#if DBG
    *IsServer = 0xBAADBAAD;
    *SendToRuntime = 0xBAADBAAD;
#endif  // DBG

    RpcStatus = ((HTTP2FlowControlSender *)Context)->DirectSendComplete(IsServer,
        SendToRuntime,
        SendContext,
        Buffer,
        BufferLength);

    // make sure DirectSendComplete didn't forget to set it
    ASSERT(*IsServer != 0xBAADBAAD);
    ASSERT(*SendToRuntime != 0xBAADBAAD);

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2ChannelDataOriginatorDirectSend (
    IN void *Context,
    OUT BOOL *IsServer,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct notification from the thread pool to the channel data originator
    for a send complete. The channel data originator uses that to post send
    compeltes to itself. Usable only on endpoints (i.e. does return to runtime)

Arguments:

    Context - an instance of HTTP2ChannelDataOriginator

    IsServer - on both success and failure MUST be set by this function.

    SendContext - the send context as needs to be seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK

--*/
{
    RPC_STATUS RpcStatus;

#if DBG
    *IsServer = 0xBAADBAAD;
#endif  // DBG

    RpcStatus = ((HTTP2ChannelDataOriginator *)Context)->DirectSendComplete(IsServer,
        SendContext,
        Buffer,
        BufferLength);

    // make sure DirectSendComplete didn't forget to set it
    ASSERT(*IsServer != 0xBAADBAAD);

    return RpcStatus;
}

RPCRTAPI
void
RPC_ENTRY
HTTP2TimerReschedule (
    IN void *Context
    )
/*++

Routine Description:

    A timer reschedule notification came in.

Arguments:

    Context - actually a ping channel pointer for the channel
        that asked for rescheduling

Return Value:

--*/
{
    HTTP2PingOriginator *PingChannel;

    PingChannel = (HTTP2PingOriginator *)Context;

    PingChannel->RescheduleTimer();
}

RPCRTAPI
void
RPC_ENTRY
HTTP2AbortConnection (
    IN void *Context
    )
/*++

Routine Description:

    A request to abort the connection was posted on a worker thread.

Arguments:

    Context - actually a top channel pointer for the connection to abort.

Return Value:

--*/
{
    HTTP2Channel *TopChannel;

    TopChannel = (HTTP2Channel *)Context;

    TopChannel->AbortConnection(RPC_P_CONNECTION_SHUTDOWN);
    TopChannel->RemoveReference();
}

RPCRTAPI
void
RPC_ENTRY
HTTP2RecycleChannel (
    IN void *Context
    )
/*++

Routine Description:

    A request to recycle the channel was posted on a worker thread.

Arguments:

    Context - actually a top channel pointer for the channel to
        recycle.

Return Value:

--*/
{
    HTTP2Channel *TopChannel;

    TopChannel = (HTTP2Channel *)Context;

    // don't care about return code. See rule 29.
    (void) TopChannel->HandleSendResultFromNeutralContext(RPC_P_CHANNEL_NEEDS_RECYCLING);
    TopChannel->RemoveReference();
}

RPC_STATUS 
HTTP2ProcessComplexTReceive (
    IN OUT void **Connection,
    IN RPC_STATUS EventStatus,
    IN ULONG Bytes,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    A receive notification came from the completion port.

Arguments:

    Connection - a pointer to a pointer to a connection.
        On input it will be the raw connection. On output
        it needs to be the virtual connection so that
        runtime can find its object off there. This out
        parameter must be set on both success and failure.

    EventStatus - status of the operation

    Bytes - bytes received

    Buffer - on output (success only), the received buffer

    BufferLength - on output (success only), the length of the
        received buffer.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure
    RPC_P_PARTIAL_RECEIVE allowed for partial receives.
    RPC_P_PACKET_CONSUMED must be returned for all transport
        traffic (success or failure). Anything else will AV the
        runtime.

--*/
{
    WS_HTTP2_CONNECTION *RawConnection = (WS_HTTP2_CONNECTION *)*Connection;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_COMPLEX_T_RECV, HTTP2LOG_OT_CALLBACK, EventStatus);

    // in rare cases a receive can be consumed within the transport
    // outside the ComplexT mechanism (server connection establishment is
    // the only example). Ignore such packets.
    if (EventStatus == RPC_P_PACKET_CONSUMED)
        return EventStatus;

    // stick the runtime idea of the transport connection
    *Connection = RawConnection->RuntimeConnectionPtr;

    if (Bytes && (EventStatus == RPC_S_OK))
        {
        EventStatus = RawConnection->ProcessReceiveComplete(Bytes,
                                          Buffer,
                                          BufferLength);

        if (EventStatus == RPC_P_PARTIAL_RECEIVE)
            {
            // Message is not complete, submit the next read and continue.
            EventStatus = CO_SubmitRead(RawConnection);

            if (EventStatus != RPC_S_OK)
                {
                EventStatus = RawConnection->ProcessReceiveFailed(RPC_P_CONNECTION_SHUTDOWN);
                if (EventStatus != RPC_P_PACKET_CONSUMED)
                    {
                    ASSERT(EventStatus == RPC_P_RECEIVE_FAILED);
                    }
                }
            else
                EventStatus = RPC_P_PARTIAL_RECEIVE;
            }
        else
            {
            ASSERT(   (EventStatus == RPC_P_RECEIVE_FAILED)
                   || (EventStatus == RPC_S_OK)
                   || (EventStatus == RPC_P_PACKET_CONSUMED));
            }
        }
    else
        {
        // in other rare case (again server connection establishment), the connection
        // can be the virtual connection, not the transport connection. In such cases,
        // let the error fall through back to the runtime. Since this happens only during
        // connection establishment, and the receive did not go through the channels,
        // we should not complete it through the channels.
        if ((RawConnection->id == HTTPv2) 
            && (RawConnection->type == (COMPLEX_T | CONNECTION | SERVER)))
            {
            // this is a server virtual connecton. Read the connection from there
            *Connection = RawConnection;
            }
        else
            {
            if (EventStatus != RPC_S_OK)
                EventStatus = RawConnection->ProcessReceiveFailed(EventStatus);
            else
                EventStatus = RawConnection->ProcessReceiveFailed(RPC_P_RECEIVE_FAILED);

            if (EventStatus == RPC_P_CONNECTION_SHUTDOWN)
                EventStatus = RPC_P_RECEIVE_FAILED;
            }

        ASSERT(   (EventStatus == RPC_P_RECEIVE_FAILED)
               || (EventStatus == RPC_S_OK)
               || (EventStatus == RPC_P_PACKET_CONSUMED));
        }

    LOG_FN_OPERATION_EXIT(HTTP2LOG_COMPLEX_T_RECV, HTTP2LOG_OT_CALLBACK, EventStatus);

    return EventStatus;
}

RPC_STATUS 
HTTP2ProcessComplexTSend (
    IN void *SendContext,
    IN RPC_STATUS EventStatus,
    OUT BUFFER *Buffer
    )
/*++

Routine Description:

    A send notification came from the completion port.

Arguments:

    SendContext - the send context

    EventStatus - status of the operation

    Buffer - if the packet is not consumed, must be the sent
        buffer.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure
    RPC_P_PACKET_CONSUMED must be returned for all transport
        traffic (success or failure). Anything else will AV the
        runtime.

--*/
{
    HTTP2SendContext *HttpSendContext = (HTTP2SendContext *)SendContext;
    WS_HTTP2_CONNECTION *RawConnection;
    RPC_STATUS RpcStatus;

    LOG_FN_OPERATION_ENTRY(HTTP2LOG_COMPLEX_T_SEND, HTTP2LOG_OT_CALLBACK, (ULONG_PTR)HttpSendContext);

    *Buffer = HttpSendContext->pWriteBuffer;
    RawConnection = (WS_HTTP2_CONNECTION *)HttpSendContext->Write.pAsyncObject;

    RpcStatus = RawConnection->ProcessSendComplete(EventStatus, HttpSendContext);

    LOG_FN_OPERATION_EXIT(HTTP2LOG_COMPLEX_T_SEND, HTTP2LOG_OT_CALLBACK, RpcStatus);

    return RpcStatus;
}

RPC_STATUS ProxyAsyncCompleteHelper (
    IN HTTP2Channel *TopChannel,
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    A helper function that completes an async io.

Arguments:

    TopChannel - the top channel for the stack
    
    CurrentStatus - the status with which the complete
        notification completed.

Return Value:

    RPC_S_OK.

--*/
{
    ASSERT(CurrentStatus != RPC_S_CANNOT_SUPPORT);
    ASSERT(CurrentStatus != RPC_S_INTERNAL_ERROR);

    if ((CurrentStatus != RPC_S_OK)
        &&
        (CurrentStatus != RPC_P_PACKET_CONSUMED))
        {
        // if this failed, abort the whole connection
        TopChannel->AbortAndDestroyConnection(CurrentStatus);
        }

    TopChannel->RemoveReference();

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
HTTP2TestHook (
    IN SystemFunction001Commands FunctionCode,
    IN void *InData,
    OUT void *OutData
    )
/*++

Routine Description:

    Test hook for the http functions

Arguments:

    FunctionCode - which test function to perform

    InData - input data from the test function

    OutData - output data from the test function

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_CHAR *NewTarget;

    switch (FunctionCode)
        {
        case sf001cHttpSetInChannelTarget:
            NewTarget = (RPC_CHAR *)InData;

            if (InChannelTargetTestOverride)
                {
                delete [] InChannelTargetTestOverride;
                InChannelTargetTestOverride = NULL;
                }

            if (NewTarget)
                {
                InChannelTargetTestOverride = DuplicateString(NewTarget);
                if (InChannelTargetTestOverride == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                }
            break;

        case sf001cHttpSetOutChannelTarget:
            NewTarget = (RPC_CHAR *)InData;

            if (OutChannelTargetTestOverride)
                {
                delete [] OutChannelTargetTestOverride;
                OutChannelTargetTestOverride = NULL;
                }

            if (NewTarget)
                {
                OutChannelTargetTestOverride = DuplicateString(NewTarget);
                if (OutChannelTargetTestOverride == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                }
            break;

        default:
            // we should never be called with a value we can't handle
            ASSERT(0);
            return RPC_S_INTERNAL_ERROR;
        }

    return RPC_S_OK;
}

/*********************************************************************
    HTTP2TransportChannel
 *********************************************************************/

RPC_STATUS HTTP2TransportChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    VerifyValidSendContext(SendContext);

    return LowerLayer->Send(SendContext);
}

RPC_STATUS HTTP2TransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return LowerLayer->Receive(TrafficType);
}

RPC_STATUS HTTP2TransportChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send
    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return UpperLayer->SendComplete(EventStatus,
        SendContext
        );
}

RPC_STATUS HTTP2TransportChannel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return UpperLayer->ReceiveComplete(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );
}

void HTTP2TransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    LowerLayer->Abort(RpcStatus);
}

void HTTP2TransportChannel::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.
    Most channels don't care as they don't account for or hang on to sends.
    Called only in submission context.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    UpperLayer->SendCancelled(SendContext);
}

void HTTP2TransportChannel::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->Reset();
}

RPC_STATUS HTTP2TransportChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Helper routine that helps complete an async operation

Arguments:
    
    CurrentStatus - the current status of the operation

Return Value:

    The status to return to the runtime.

--*/
{
    return TopChannel->AsyncCompleteHelper(CurrentStatus);
}

RPC_STATUS HTTP2TransportChannel::HandleSendResultFromNeutralContext (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Handles the result code from send from a neutral context.
    This includes checking for channel recycling and intiating
    one if necessary. This routine simply delegates to the top channel

Arguments:

    CurrentStatus - the status from the send operation

Return Value:

    RPC_S_OK or RPC_S_*. Callers may ignore it since all cleanup was
    done.

Notes: 

    This must be called in upcall or neutral context only

--*/
{
    return TopChannel->HandleSendResultFromNeutralContext(CurrentStatus);
}

/*********************************************************************
    WS_HTTP2_CONNECTION
 *********************************************************************/

RPC_STATUS WS_HTTP2_CONNECTION::Send(HANDLE hFile, LPCVOID lpBuffer,
                               DWORD nNumberOfBytesToWrite,
                               LPDWORD lpNumberOfBytesWritten,
                               LPOVERLAPPED lpOverlapped)
/*++

Routine Description:

    Does an asynchronous send on the connection.

Arguments:

    hFile - file to send on

    lpBuffer - buffer to send

    nNumberOfBytesToWrite - number of bytes to send

    lpNumberOfBytesWritten - number of bytes written. Will never get filled
        in this code path because it is async.

    lpOverlapped - overlapped to use for the operation

Return Value:

    WSA Error Code

--*/
{
    // See Rule 32.
    return UTIL_WriteFile2(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped);
}

RPC_STATUS WS_HTTP2_CONNECTION::Receive(HANDLE hFile, 
    LPVOID lpBuffer, 
    DWORD nNumberOfBytesToRead, 
    LPDWORD lpNumberOfBytesRead, 
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Does an asynchronous receive on the connection.

Arguments:

    hFile - file to receive on

    lpBuffer - buffer to receive into

    nNumberOfBytesToRead - number of bytes to receive

    lpNumberOfBytesRead - number of bytes read. Will never get filled
        in this code path because it is async.

    lpOverlapped - overlapped to use for the operation

Return Value:

    WSA Error Code

--*/
{
    return SANReceive(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessReceiveFailed (
    IN RPC_STATUS EventStatus
    )
/*++

Routine Description:

    Notifies a raw connection of receive failure.

Arguments:

    EventStatus - error with which the receive failed

Return Value:

    RPC_S_OK to return packet to runtime 
    or RPC_P_PACKET_CONSUMED to hide it.

--*/
{
    // if we failed before we parsed the header, chances are the problem
    // was with the header format. Treat it as protocol error.
    if ((HeaderRead == FALSE) && (EventStatus == RPC_P_CONNECTION_SHUTDOWN))
        EventStatus = RPC_S_PROTOCOL_ERROR;

    return Channel->ReceiveComplete(EventStatus, http2ttRaw, pReadBuffer, 0);
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessSendComplete (
    IN RPC_STATUS EventStatus,
    IN CO_SEND_CONTEXT *SendContext
    )
/*++

Routine Description:

    Notifies a raw connection of send completion (fail or succeed).

Arguments:

    EventStatus - error with which the send failed

Return Value:

    RPC_S_OK to return packet to runtime 
    or RPC_P_PACKET_CONSUMED to hide it.

--*/
{
    HTTP2SendContext *HttpSendContext = (HTTP2SendContext *)SendContext;
    VerifyValidSendContext(HttpSendContext);

    return Channel->SendComplete(EventStatus, HttpSendContext);
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessRead(
    IN  DWORD bytes, 
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength
    )
/*++

Routine Description:

    Processes a connection oriented receive
    complete. But in HTTP2 we no-op this and do all read
    processing through the COMPLEX_T mechanism.

Arguments:

    bytes - the number of read (not including those in iLastRead).

    pBuffer - when returning RPC_S_OK will contain the message.

    pBufferLength - when return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK

--*/
{
    return RPC_S_OK;
}

RPC_STATUS WS_HTTP2_CONNECTION::ProcessReceiveComplete(
    IN  DWORD bytes, 
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength
    )
/*++

Routine Description:

    Processes a connection oriented receive
    complete. It takes care of fragmentation.

Arguments:

    bytes - the number of read (not including those in iLastRead).

    pBuffer - when returning RPC_S_OK will contain the message.

    pBufferLength - when return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK to return packet to runtime 
    or RPC_P_PACKET_CONSUMED to hide it.

--*/
{
    RPC_STATUS RpcStatus;

    if (HeaderRead)
        {
        RpcStatus = BASE_CONNECTION::ProcessRead(bytes, pBuffer, pBufferLength);

        if (RpcStatus == RPC_P_PARTIAL_RECEIVE)
            return RpcStatus;
        }
    else if (bytes != 0)
        {
        ASSERT(ReadHeaderFn);

        RpcStatus = ReadHeaderFn(this,
            bytes,
            (ULONG *)pBufferLength
            );

        if (RpcStatus == RPC_P_PARTIAL_RECEIVE)
            return RpcStatus;

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = BASE_CONNECTION::ProcessRead(*pBufferLength, pBuffer, pBufferLength);
            }

        if (RpcStatus == RPC_P_PARTIAL_RECEIVE)
            return RpcStatus;
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    if (RpcStatus == RPC_S_OK)
        {
        RpcStatus = Channel->ReceiveComplete(RpcStatus,
            http2ttRaw,
            (BYTE *)*pBuffer,
            *pBufferLength);
        }
    else
        {
        RpcStatus = Channel->ReceiveComplete(RpcStatus,
            http2ttRaw,
            NULL,
            0);
        }

    return RpcStatus;
}

RPC_STATUS WS_HTTP2_CONNECTION::Abort (
    void
    )
/*++

Routine Description:

    No-op. This is called from common
    transport code. We don't abort HTTP2
    connections from common transport code. Ignore
    this call.

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    return RPC_S_OK;
}

void WS_HTTP2_CONNECTION::Free (
    void
    )
/*++

Routine Description:

    Acts like destructor. All memory needs to
    be freed.

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    if (pReadBuffer)
        {
        RpcFreeBuffer(pReadBuffer);
        pReadBuffer = NULL;
        }

    // make sure we don't free the connection without closing the socket.
    // When we close the socket, we set it to NULL.
    ASSERT(Conn.Socket == NULL);
}

void WS_HTTP2_CONNECTION::RealAbort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP2 connection.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_RAW_CONNECTION, 0);

    (void)WS_CONNECTION::Abort();

    if (!RpcpIsListEmpty(&ObjectList))
        {
        TransportProtocol::RemoveObjectFromProtocolList(this);
        }
}

void WS_HTTP2_CONNECTION::Initialize (
    void
    )
/*++

Routine Description:

    Initializes a raw connection

Arguments:

Return Value:

--*/
{
    BASE_CONNECTION::Initialize();
#if DBG
    // client and server virtual connections must initialize this. In debug
    // builds toast anybody who forgets. Proxies don't care
    type = 0xC0C0C0C0;
#endif
    pAddress = NULL;
    RpcpInitializeListHead(&ObjectList);

    // use explicit placement to initialize the vtable. We need this to
    // be able to use the virtual functions
    (void) new (this) WS_HTTP2_CONNECTION;
}

/*********************************************************************
    WS_HTTP2_INITIAL_CONNECTION
 *********************************************************************/

C_ASSERT(sizeof(rpcconn_common) == sizeof(CONN_RPC_HEADER));

RPC_STATUS WS_HTTP2_INITIAL_CONNECTION::ProcessRead(
    IN  DWORD BytesRead, 
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength
    )
/*++

Routine Description:

    Processes a connection oriented receive
    complete. It determines whether HTTP2 or HTTP will be
    used and initializes the stack accordingly.

Arguments:

    BytesRead - the number of read (not including those in iLastRead).

    pBuffer - when returning RPC_S_OK will contain the message.

    pBufferLength - when return RPC_S_OK will contain the message length.

Return Value:

    RPC_S_OK for successful processing
    RPC_PARTIAL_RECEIVE - not enough was received to tell
    RPC_P_PACKET_CONSUMED - the packet was consumed.
    RPC_P_RECEIVE_FAILED - error occurred.

--*/
{
    RPC_STATUS RpcStatus;
    BYTE *Packet;
    ULONG PacketLength;
    BOOL IsD1_A2Packet;
    WS_HTTP2_INITIAL_CONNECTION *ThisConnection;
    HTTP2ServerVirtualConnection *ServerVirtualConnection;
    BOOL VirtualConnectionCreated;

    RpcStatus = BASE_CONNECTION::ProcessRead(BytesRead,
        pBuffer,
        pBufferLength
        );

    if (RpcStatus == RPC_S_OK)
        {
        // ProcessRead guarantees that on return value of RPC_S_OK
        // we have at least rpcconn_common bytes read successfully
        Packet = (BYTE *)*pBuffer;
        PacketLength = *pBufferLength;
        if (IsRTSPacket(Packet))
            {
            // HTTP2 traffic. 
            ThisConnection = this;

            // unlink this connection from the PnP list before it is migrated
            TransportProtocol::RemoveObjectFromProtocolList((BASE_ASYNC_OBJECT *) ThisConnection);

            RpcStatus = HTTP2ServerVirtualConnection::InitializeServerConnection (
                Packet,
                PacketLength,
                ThisConnection,
                &ServerVirtualConnection,
                &VirtualConnectionCreated
                );

            if (RpcStatus == RPC_S_OK)
                {
                // N.B. Do not use the this pointer as WS_HTTP2_INITIAL_CONNECTION 
                // pointer after here. It has been migrated to a new location
                // and this actually points to HTTP2ServerVirtualConnection

                // Make sure HTTP2ServerVirtualConnection didn't forget to
                // initialize its type member
                ASSERT(this->id == HTTPv2);
                ASSERT(this->type & COMPLEX_T);

                *pBuffer = NULL;
                *pBufferLength = 0;
                RpcFreeBuffer(Packet);
                RpcStatus = RPC_P_PACKET_CONSUMED;
                }
            else
                {
                if (VirtualConnectionCreated == FALSE)
                    {
                    // failed to create a virtual connection. Link the connection 
                    // back to its protocol list to ensure orderly destruction
                    TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) this);
                    }
                else
                    {
                    // nothing to do. The virtual connection was created but it failed to
                    // initialize. Return failure, and the runtime will turn around and
                    // destroy the connection
                    }
                RpcStatus = RPC_P_RECEIVE_FAILED;
                }
            }
        else
            {
            // morph the connection into WS_CONNECTION to serve
            // HTTP requests. The only thing we need to change is the
            // vtable. We have a little bit of extra goo at the end, but
            // that's ok.
            (void) new (this) WS_CONNECTION;            
            }
        }

    return RpcStatus;
}


RPC_STATUS WS_HTTP2_INITIAL_CONNECTION::Abort(
    void
    )
/*++

Routine Description:

    Aborts an WS_HTTP2_INITIAL_CONNECTION connection.
    Very rare to be called.

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_INITIAL_RAW_CONNECTION, 0);

    WS_HTTP2_CONNECTION::RealAbort();
    return RPC_S_OK;
}

/*********************************************************************
    HTTP2BottomChannel
 *********************************************************************/

RPC_STATUS HTTP2BottomChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, EventStatus);

    RpcStatus = HTTP2TransportChannel::SendComplete(EventStatus,
        SendContext
        );

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, RpcStatus);

    return AsyncCompleteHelper(RpcStatus);
}

RPC_STATUS HTTP2BottomChannel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, EventStatus);

    RpcStatus = HTTP2TransportChannel::ReceiveComplete(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_BOTTOM_CHANNEL, RpcStatus);

    return AsyncCompleteHelper(RpcStatus);
}

/*********************************************************************
    HTTP2SocketTransportChannel
 *********************************************************************/

RPC_STATUS HTTP2SocketTransportChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request. Forward the send to the raw connection

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    DWORD Ignored;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SOCKET_CHANNEL, (ULONG_PTR)SendContext);

    // route this through the completion port
    SendContext->Write.ol.hEvent = NULL;
    SendContext->Write.pAsyncObject = RawConnection;

    // N.B. The Winsock provider will touch the overlapped on the return path. We need
    // to make sure that either the overlapped is around (in which case we can use WSASend), 
    // or otherwise use UTIL_WriteFile2 which does not touch the overlapped on return.
    // We know the overlapped may not be around when this is a proxy data send, any type
    // of RTS send, or abandoned send. All non-proxy, not-abandoned data sends will have 
    // the overlapped around.
    if ((SendContext->TrafficType == http2ttData) 
        && (((SendContext->Flags & (SendContextFlagAbandonedSend | SendContextFlagProxySend)) == 0)))
        {
        RpcStatus = RawConnection->WS_HTTP2_CONNECTION::SANSend(
                                RawConnection->Conn.Handle,
                                SendContext->pWriteBuffer,
                                SendContext->maxWriteBuffer,
                                &Ignored,
                                &SendContext->Write.ol
                                );
        }
    else
        {
        RpcStatus = RawConnection->WS_HTTP2_CONNECTION::Send(
                                RawConnection->Conn.Handle,
                                SendContext->pWriteBuffer,
                                SendContext->maxWriteBuffer,
                                &Ignored,
                                &SendContext->Write.ol
                                );
        }

    if (   (RpcStatus != RPC_S_OK)
        && (RpcStatus != ERROR_IO_PENDING) )
        {
        VALIDATE(RpcStatus)
            {
            ERROR_NETNAME_DELETED,
            ERROR_GRACEFUL_DISCONNECT,
            ERROR_NO_DATA,
            ERROR_NO_SYSTEM_RESOURCES,
            ERROR_WORKING_SET_QUOTA,
            ERROR_BAD_COMMAND,
            ERROR_OPERATION_ABORTED,
            ERROR_WORKING_SET_QUOTA,
            WSAECONNABORTED,
            WSAECONNRESET
            } END_VALIDATE;

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SOCKET_CHANNEL, RPC_P_SEND_FAILED);

        return(RPC_P_SEND_FAILED);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_SOCKET_CHANNEL, RPC_S_OK);

    return RPC_S_OK;
}

RPC_STATUS HTTP2SocketTransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_SOCKET_CHANNEL, TrafficType);

    ASSERT(TrafficType == http2ttRaw);

    RpcStatus = CO_Recv(RawConnection);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_SOCKET_CHANNEL, RpcStatus);

    return RpcStatus;
}

void HTTP2SocketTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_SOCKET_CHANNEL, RpcStatus);

    RawConnection->RealAbort();
}

void HTTP2SocketTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_SOCKET_CHANNEL, 0);

    RawConnection->Free();

    HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
}

void HTTP2SocketTransportChannel::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    RawConnection->HeaderRead = FALSE;
}

/*********************************************************************
    HTTP2FragmentReceiver
 *********************************************************************/

RPC_STATUS HTTP2FragmentReceiver::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (iLastRead && iLastRead == MaxReadBuffer)
        {
        ASSERT(pReadBuffer);

        // This means we received a coalesced read of a complete
        // message. (Or that we received a coalesced read < header size)
        // We should complete that as it's own IO in neutral context. 
        // This is very rare.
        (void) COMMON_PostRuntimeEvent(GetPostRuntimeEvent(),
            this
            );

        return(RPC_S_OK);
        }

    ASSERT(iLastRead == 0 || (iLastRead < MaxReadBuffer));

    return(PostReceive());
};

RPC_STATUS HTTP2FragmentReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN OUT BYTE **Buffer,
    IN OUT UINT *BufferLength
    )
/*++

Routine Description:

    Processes a receive complete notification.

Arguments:

    EventStatus - the status code of the operation.

    TrafficType - the type of traffic we have received

    Buffer - the buffer. Must be NULL at this level on input. On
        output contains the buffer for the current receive. If NULL
        on output, we did not have a full packet. Undefined on failure.

    BufferLength - the actual number of bytes received. On output the
        number of bytes for the current packet. If 0 on output,
        we did not have a complete packet. Undefined on failure.

Return Value:

--*/
{
    BYTE *LocalReadBuffer;
    ULONG MessageSize;
    ULONG ExtraSize;
    ULONG AllocSize;
    BYTE *NewBuffer;
    BOOL DoNotComplete;
    ULONG LocalBufferLength = *BufferLength;

    DoNotComplete = FALSE;
    if (EventStatus == RPC_S_OK)
        {
        ASSERT(pReadBuffer);

        LocalBufferLength += iLastRead;

        ASSERT(LocalBufferLength <= MaxReadBuffer);

        if (LocalBufferLength < sizeof(CONN_RPC_HEADER))
            {
            // Not a whole header, resubmit the read and continue.

            iLastRead = LocalBufferLength;

            EventStatus = PostReceive();

            if (EventStatus == RPC_S_OK)
                DoNotComplete = TRUE;
            else
                LocalReadBuffer = NULL;
            }
        else
            {
            MessageSize = MessageLength((PCONN_RPC_HEADER)pReadBuffer);

            if (MessageSize < sizeof(CONN_RPC_HEADER))
                {
                ASSERT(MessageSize >= sizeof(CONN_RPC_HEADER));
                EventStatus = RPC_P_RECEIVE_FAILED;
                }
            else if (LocalBufferLength == MessageSize)
                {
                // All set, have a complete request.
                LocalReadBuffer = pReadBuffer;
                LocalBufferLength = MessageSize;

                iLastRead = 0;
                pReadBuffer = 0;
                }
            else if (MessageSize > LocalBufferLength)
                {
                // Don't have a complete message, realloc if needed and
                // resubmit a read for the remaining bytes.

                if (MaxReadBuffer < MessageSize)
                    {
                    // Buffer too small for the message.
                    EventStatus = TransConnectionReallocPacket(NULL,
                                                          &pReadBuffer,
                                                          LocalBufferLength,
                                                          MessageSize);

                    if (EventStatus == RPC_S_OK)
                        {
                        // increase the post size, but not if we are in paged
                        // buffer mode.
                        if (fPagedBCacheMode == FALSE)
                            iPostSize = MessageSize;
                        }
                    }

                if (EventStatus == RPC_S_OK)
                    {
                    // Setup to receive exactly the remaining bytes of the message.
                    iLastRead = LocalBufferLength;
                    MaxReadBuffer = MessageSize;

                    EventStatus = PostReceive();

                    if (EventStatus == RPC_S_OK)
                        DoNotComplete = TRUE;
                    else
                        LocalReadBuffer = NULL;
                    }
                }
            else
                {
                // Coalesced read, save extra data.  Very uncommon

                ASSERT(LocalBufferLength > MessageSize);

                // The first message and size will be returned

                LocalReadBuffer = pReadBuffer;

                ExtraSize = LocalBufferLength - MessageSize;

                LocalBufferLength = MessageSize;

                // Try to find a good size of the extra PDU(s)
                if (ExtraSize < sizeof(CONN_RPC_HEADER))
                    {
                    // Not a whole header, we'll assume gPostSize;

                    AllocSize = gPostSize;
                    }
                else
                    {
#ifdef _M_IA64
                    // The first packet may not contain a number of bytes
                    // that align the second on an 8-byte boundary.  Hence, the
                    // structure may end up unaligned. 
                    AllocSize = MessageLengthUnaligned((PCONN_RPC_HEADER)(pReadBuffer
                                                                           + MessageSize));
#else
                    AllocSize = MessageLength((PCONN_RPC_HEADER)(pReadBuffer
                                                                  + MessageSize));
#endif
                    }

                if (AllocSize < ExtraSize)
                    {
                    // This can happen if there are more than two PDUs coalesced together
                    // in the buffer.  Or if the PDU is invalid. Or if the iPostSize is
                    // smaller than the next PDU.
                    AllocSize = ExtraSize;
                    }

                // Allocate a new buffer to save the extra data for the next read.
                NewBuffer = (BYTE *)RpcAllocateBuffer(AllocSize);

                if (0 == NewBuffer)
                    {
                    // We have a complete request.  We could process the request and
                    // close the connection only after trying to send the reply.

                    LocalReadBuffer = NULL;
                    LocalBufferLength = 0;

                    EventStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(pReadBuffer);

                    // Save away extra data for the next receive
                    RpcpMemoryCopy(NewBuffer,
                                   pReadBuffer + LocalBufferLength,
                                   ExtraSize);
                    pReadBuffer = NewBuffer;
                    iLastRead = ExtraSize;
                    MaxReadBuffer = AllocSize;

                    ASSERT(iLastRead <= MaxReadBuffer);

                    EventStatus = RPC_S_OK;
                    }
                }
            }
        }
    else
        {
        // in failure cases we keep the buffer. We will 
        // free it on Abort.
        LocalReadBuffer = NULL;
        }

    if (DoNotComplete == FALSE)
        {
        *Buffer = LocalReadBuffer;
        *BufferLength = LocalBufferLength;

        EventStatus = UpperLayer->ReceiveComplete(EventStatus,
            TrafficType,
            LocalReadBuffer,
            LocalBufferLength
            );

        return AsyncCompleteHelper(EventStatus);
        // don't touch the this pointer after AsyncCompleteHelper.
        // It could be gone.
        }
    else
        {
        *Buffer = NULL;
        *BufferLength = 0;
        return RPC_S_OK;
        }
}

/*********************************************************************
    HTTP2WinHttpTransportChannel
 *********************************************************************/

// our public constants are aligned with HTTP constants. Even though it is
// unlikely for either to change, make sure they don't. If they do, we need
// a remapping function as we use them interchangeably in the code
C_ASSERT(WINHTTP_AUTH_SCHEME_BASIC == RPC_C_HTTP_AUTHN_SCHEME_BASIC);
C_ASSERT(WINHTTP_AUTH_SCHEME_NTLM == RPC_C_HTTP_AUTHN_SCHEME_NTLM);
C_ASSERT(WINHTTP_AUTH_SCHEME_PASSPORT == RPC_C_HTTP_AUTHN_SCHEME_PASSPORT);
C_ASSERT(WINHTTP_AUTH_SCHEME_DIGEST == RPC_C_HTTP_AUTHN_SCHEME_DIGEST);
C_ASSERT(WINHTTP_AUTH_SCHEME_NEGOTIATE == RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE);

HTTP2WinHttpTransportChannel::HTTP2WinHttpTransportChannel (
    OUT RPC_STATUS *RpcStatus
    ) : Mutex (RpcStatus)
/*++

Routine Description:

    HTTP2WinHttpTransportChannel constructor.

Arguments:
    
    RpcStatus - on output will contain the result of the
        initialization.

Return Value:

--*/
{
    hSession = NULL;
    hConnect = NULL;
    hRequest = NULL;
    SyncEvent = NULL;

    RpcpInitializeListHead(&BufferQueueHead);

    pReadBuffer = NULL;
    MaxReadBuffer = 0;
    iLastRead = 0;
    SendsPending = 0;

    State = whtcsNew;

    AsyncError = RPC_S_INTERNAL_ERROR;

    HttpCredentials = NULL;

    KeepAlive = FALSE;

    CredentialsSetForScheme = 0;

    PreviousRequestContentLength = -1;

    ChosenAuthScheme = 0;

    DelayedReceiveTrafficType = http2ttNone;

    CurrentSendContext = NULL;
}

const RPC_CHAR ContentLengthHeader[] = L"Content-Length:";

RPC_STATUS HTTP2WinHttpTransportChannel::Open (
    IN HTTPResolverHint *Hint,
    IN const RPC_CHAR *Verb,
    IN const RPC_CHAR *Url,
    IN const RPC_CHAR *AcceptType,
    IN ULONG ContentLength,
    IN ULONG CallTimeout,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,
    IN ULONG ChosenAuthScheme,
    IN const BYTE *AdditionalData OPTIONAL
    )
/*++

Routine Description:

    Opens the connection to the proxy. We know that a failed Open
    will be followed by Abort.

Arguments:
    
    Hint - the resolver hint

    Verb - the verb to use.

    Url - the url to connect to.

    AcceptType - string representation of the accept type.

    ContentLength - the content length for the request (i.e. the
        channel lifetime)

    CallTimeout - the timeout for the operation

    HttpCredentials - the HTTP transport credentials

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

Return Value:

    RPC_S_OK or RPC_S_* error.

--*/
{
    BOOL HttpResult = FALSE;
    DWORD dwReadBufferSizeSize = sizeof(ULONG);
    ULONG WinHttpAccessType;
    LPCWSTR AcceptTypes[2];
    ULONG LastError;
    RPC_CHAR *UnicodeString;
    ULONG UnicodeStringSize;    // in characters including null terminated NULL
    RPC_STATUS RpcStatus;
    ULONG FlagsToAdd;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *TransHttpCredentials;
    ULONG AdditionalDataLengthToUse;
    ULONG ContentLengthToUse;
    ULONG BytesAvailable;
    RPC_CHAR ContentLengthString[40];   // enough space for "Content-Length:" + channel lifetime
    BOOL IsInChannel;
    BOOL TestOverrideUsed;
    RPC_CHAR *User;
    RPC_CHAR *Password;
    RPC_CHAR *Domain;
    HANDLE LocalEvent = NULL;
    ULONG SecLevel;
    BOOL LanManHashDisabled;
    ULONG DomainAndUserLength;      // length in characters not including null terminator
    ULONG DomainLength;             // length in characters not including null terminator
    ULONG UserLength;               // length in characters not including null terminator
    RPC_CHAR *DomainAndUserName;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        (ULONG_PTR)ContentLength);

    this->HttpCredentials = HttpCredentials;

    // Open can be called multiple times to send opening requests.
    // Make sure general initialization is done only once.
    if (hSession == NULL)
        {
        ASSERT(hConnect == NULL);

        State = whtcsOpeningRequest;

        ASSERT(Hint->AccessType != rpcpatUnknown);
        if (Hint->AccessType == rpcpatDirect)
            {
            WinHttpAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
            UnicodeString = NULL;
            UnicodeStringSize = 0;
            }
        else
            {
            WinHttpAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;

            UnicodeStringSize = RpcpStringLengthA(Hint->HTTPProxy) + 1;
            UnicodeString = new RPC_CHAR [UnicodeStringSize];

            if (UnicodeString == NULL)
                {
                LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                    RPC_S_OUT_OF_MEMORY);
                return RPC_S_OUT_OF_MEMORY;
                }

            FullAnsiToUnicode(Hint->HTTPProxy, UnicodeString);
            }

        // Use WinHttpOpen to obtain a session handle.
        hSession = WinHttpOpenImp( L"MSRPC",
                                WinHttpAccessType,
                                UnicodeString,
                                WINHTTP_NO_PROXY_BYPASS,
                                WINHTTP_FLAG_ASYNC
                                );
        if (!hSession)
            {
            VALIDATE(GetLastError())
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            if (UnicodeString)
                delete [] UnicodeString;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Set the callback to be used by WinHttp to notify us of IO completion.
        WinHttpSetStatusCallbackImp( hSession,
                                  WinHttpCallback,
                                  WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
                                  NULL   // Reserved: must be NULL
                                  );

        // Set the communication timeout.
        HttpResult = WinHttpSetOptionImp( hSession,
                                       WINHTTP_OPTION_CONNECT_TIMEOUT,
                                       (LPVOID)&CallTimeout,
                                       sizeof(ULONG)
                                       );

        // this function cannot fail unless we give it invalid parameters
        ASSERT(HttpResult == TRUE);

        // Set the send/receive timeout.
        CallTimeout = 30 * 60 * 1000;
        HttpResult = WinHttpSetOptionImp( hSession,
                                       WINHTTP_OPTION_SEND_TIMEOUT,
                                       (LPVOID)&CallTimeout,
                                       sizeof(ULONG)
                                       );

        // this function cannot fail unless we give it invalid parameters
        ASSERT(HttpResult == TRUE);

        CallTimeout = 30 * 60 * 1000;
        HttpResult = WinHttpSetOptionImp( hSession,
                                       WINHTTP_OPTION_RECEIVE_TIMEOUT,
                                       (LPVOID)&CallTimeout,
                                       sizeof(ULONG)
                                       );

        // this function cannot fail unless we give it invalid parameters
        ASSERT(HttpResult == TRUE);

        RpcStatus = TopChannel->IsInChannel(&IsInChannel);
        // this cannot fail here. We're opening the channel
        ASSERT(RpcStatus == RPC_S_OK);

        if (IsInChannel && InChannelTargetTestOverride)
            {
            TestOverrideUsed = TRUE;
            UnicodeString = InChannelTargetTestOverride;
            }
        else if (!IsInChannel && OutChannelTargetTestOverride)
            {
            TestOverrideUsed = TRUE;
            UnicodeString = OutChannelTargetTestOverride;
            }
        else
            {
            TestOverrideUsed = FALSE;

            if (Hint->ProxyNameLength + 1 > UnicodeStringSize)
                {
                if (UnicodeString)
                    delete [] UnicodeString;
                UnicodeString = new RPC_CHAR [Hint->ProxyNameLength + 1];
                if (UnicodeString == NULL)
                    {
                    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                        RPC_S_OUT_OF_MEMORY);
                    return RPC_S_OUT_OF_MEMORY;
                    }
                }

            FullAnsiToUnicode(Hint->RpcProxy, UnicodeString);
            }

        // Specify an HTTP server to talk to.
        hConnect = WinHttpConnectImp( hSession,
                                   UnicodeString,
                                   Hint->RpcProxyPort,
                                   NULL    // Reserved: must be NULL
                                   );

        if (TestOverrideUsed == FALSE)
            delete [] UnicodeString;

        if (!hConnect)
            {
            VALIDATE(GetLastError())
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Create an HTTP Request handle.
        AcceptTypes[0] = AcceptType;
        AcceptTypes[1] = NULL;

        if (HttpCredentials && (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL))
            FlagsToAdd = WINHTTP_FLAG_SECURE;
        else
            FlagsToAdd = 0;
        hRequest = WinHttpOpenRequestImp( hConnect,
                                       Verb,
                                       Url,
                                       NULL, // Version: HTTP/1.1
                                       WINHTTP_NO_REFERER, // Referer: none
                                       AcceptTypes, // AcceptTypes: all
                                       WINHTTP_FLAG_REFRESH | FlagsToAdd  // Flags
                                       );
        if (!hRequest)
            {
            VALIDATE(GetLastError())
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Query the optimal read buffer size.
        // We can only query the buffer size from the request handle.
        HttpResult = WinHttpQueryOptionImp( hRequest,
                                         WINHTTP_OPTION_READ_BUFFER_SIZE,
                                         (LPVOID)&iPostSize,
                                         &dwReadBufferSizeSize
                                         );
        // this cannot fail unless we give it invalid parameters
        ASSERT (HttpResult == TRUE);

        ASSERT(dwReadBufferSizeSize != 0);
        }
    else
        {
        ASSERT(hConnect != NULL);
        ASSERT(hRequest != NULL);
        }

    // do we have a winner? If yes, have we already set the credentials for
    // this scheme? Note that for Basic we need to set them every time.
    if (ChosenAuthScheme 
        && 
        (
         (ChosenAuthScheme != CredentialsSetForScheme)
         || 
         (ChosenAuthScheme == RPC_C_HTTP_AUTHN_SCHEME_BASIC)
        )
       )
        {
        // yes. Just use it
        ASSERT(HttpCredentials);

        // we will set the auto logon policy to low (i.e. send NTLM credentials)
        // in two cases. One is if SSL & mutual auth are used. The second is if LM
        // hash is disabled (i.e. the NTLM negotiate leg does not expose user credentials)
        // first, check whether the hash is enabled
        RpcStatus = IsLanManHashDisabled(&LanManHashDisabled);
        if (RpcStatus != RPC_S_OK)
            {
            VALIDATE(RpcStatus)
                {
                RPC_S_OUT_OF_MEMORY
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RpcStatus);
            return RpcStatus;
            }

        if (
            (
             (HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
              &&
             (HttpCredentials->ServerCertificateSubject)
            )
            ||
            (LanManHashDisabled)
           )
            {
            SecLevel = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;
            HttpResult = WinHttpSetOptionImp( hRequest,
                                            WINHTTP_OPTION_AUTOLOGON_POLICY,
                                            &SecLevel, 
                                            sizeof(ULONG)
                                            );

            // this function cannot fail unless we give it invalid parameters
            ASSERT(HttpResult == TRUE);
            }

        TransHttpCredentials = I_RpcTransGetHttpCredentials(HttpCredentials);
        if (TransHttpCredentials == NULL)
            {
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        if (TransHttpCredentials->TransportCredentials)
            {
            User = TransHttpCredentials->TransportCredentials->User;
            Domain = TransHttpCredentials->TransportCredentials->Domain;
            Password = TransHttpCredentials->TransportCredentials->Password;
            DomainLength = RpcpStringLength(Domain);
            UserLength = RpcpStringLength(User);

            // add 1 for '\'
            DomainAndUserLength = DomainLength + 1 + UserLength;
            // add 1 for terminator
            DomainAndUserName = new RPC_CHAR [DomainAndUserLength + 1];
            if (DomainAndUserName == NULL)
                {
                I_RpcTransFreeHttpCredentials(TransHttpCredentials);
                LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                    RPC_S_OUT_OF_MEMORY);
                return RPC_S_OUT_OF_MEMORY;
                }

            RpcpMemoryCopy(DomainAndUserName, Domain, DomainLength * 2);
            DomainAndUserName[DomainLength] = '\\';
            RpcpMemoryCopy(DomainAndUserName + DomainLength + 1, User, UserLength * 2);
            DomainAndUserName[DomainLength + 1 + UserLength] = '\0';
            }
        else
            {
            if (ChosenAuthScheme == RPC_C_HTTP_AUTHN_SCHEME_BASIC)
                {
                // Basic does not support implicit credentials
                LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                    RPC_S_ACCESS_DENIED);
                return RPC_S_ACCESS_DENIED;
                }
            User = NULL;
            Password = NULL;
            DomainAndUserName = NULL;
            }

        HttpResult = WinHttpSetCredentialsImp (hRequest,
            WINHTTP_AUTH_TARGET_SERVER,
            ChosenAuthScheme,
            DomainAndUserName,
            Password,
            NULL
            );

        // success or error, free the domain and user name
        if (DomainAndUserName)
            {
            // technically speaking, we don't have to zero out user and domain name
            // since they are not secret. However, the way the heap works it is likely
            // that they will be next to our credentials, which are not encrypted very
            // strongly. So wipe out the domain and user to prevent an attacker from
            // using them to locate the credentials
            RpcpMemorySet(DomainAndUserName, 0, DomainAndUserLength);
            delete [] DomainAndUserName;
            }

        if (!HttpResult)
            {
            LastError = GetLastError();

            VALIDATE(LastError)
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;
            }

        I_RpcTransFreeHttpCredentials(TransHttpCredentials);

        if (!HttpResult)
            {
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        // remember that we have already set credentials for this scheme
        CredentialsSetForScheme = ChosenAuthScheme;
        }

    LocalEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (LocalEvent == NULL)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    SyncEvent = LocalEvent;
    LastError = RPC_S_OK;

    // Send a Request.
    if (AdditionalData)
        {
        // if additional data to append, send them immediately
        AdditionalDataLengthToUse = ContentLength;
        ContentLengthToUse = ContentLength;
        }
    else
        {
        AdditionalDataLengthToUse = 0;
        ContentLengthToUse = ContentLength;
        }

    if ((PreviousRequestContentLength != -1) && (ContentLengthToUse != PreviousRequestContentLength))
        {
        // WinHttp normally doesn't update the content-length header if you reuse the
        // request. Do that now.
        RpcpMemoryCopy(ContentLengthString, ContentLengthHeader, sizeof(ContentLengthHeader));
        RpcpItow(ContentLengthToUse, ContentLengthString + sizeof(ContentLengthHeader), 10);
        HttpResult = WinHttpAddRequestHeadersImp (hRequest,
            ContentLengthString,
            -1, // dwHeadersLength - have WinHttp calculate it
            WINHTTP_ADDREQ_FLAG_REPLACE
            );

        if (!HttpResult)
            {
            LastError = GetLastError();

            VALIDATE(LastError)
                {
                ERROR_NOT_ENOUGH_MEMORY
                } END_VALIDATE;

            RpcStatus = LastError;
            goto CleanupAndExit;
            }
        }

    PreviousRequestContentLength = ContentLengthToUse;

    State = whtcsSendingRequest;

    HttpResult = WinHttpSendRequestImp( hRequest,
                                     WINHTTP_NO_ADDITIONAL_HEADERS, // Additional headers
                                     0, // Length of the additional headers
                                     (LPVOID)AdditionalData, // Optional data to append to the request
                                     AdditionalDataLengthToUse, // Length of the optional data
                                     ContentLengthToUse, // Length in bytes of the total data sent
                                     (DWORD_PTR) this  // Application-specified context for this request
                                     );
    if (!HttpResult)
        {
        SyncEvent = NULL;

        LastError = GetLastError();
        }
    else
        {
        // Sleep waiting for the send request to be completed.
        LastError = WaitForSingleObject(SyncEvent, INFINITE);
        SyncEvent = NULL;
        ASSERT(State == whtcsSentRequest);
        ASSERT(AsyncError != RPC_S_INTERNAL_ERROR);
        LastError = AsyncError;
        AsyncError = RPC_S_INTERNAL_ERROR;
        }

    if (LastError != RPC_S_OK)
        {
        VALIDATE(LastError)
            {
            ERROR_WINHTTP_CANNOT_CONNECT,
            ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_INVALID_URL,
            ERROR_WINHTTP_LOGIN_FAILURE,
            ERROR_WINHTTP_NAME_NOT_RESOLVED,
            ERROR_WINHTTP_OUT_OF_HANDLES,
            ERROR_WINHTTP_REDIRECT_FAILED,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SECURE_FAILURE,
            ERROR_WINHTTP_SHUTDOWN,
            ERROR_WINHTTP_TIMEOUT,
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_NOT_SUPPORTED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_SEND_FAILED,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_ACCESS_DENIED,
            ERROR_NO_SYSTEM_RESOURCES,
            ERROR_COMMITMENT_LIMIT
            } END_VALIDATE;

        switch (LastError)
            {
            case ERROR_WINHTTP_CANNOT_CONNECT:
            case ERROR_WINHTTP_CONNECTION_ERROR:
            case ERROR_WINHTTP_INVALID_URL:
            case ERROR_WINHTTP_NAME_NOT_RESOLVED:
            case ERROR_WINHTTP_REDIRECT_FAILED:
            case ERROR_WINHTTP_RESEND_REQUEST:
            case ERROR_WINHTTP_SHUTDOWN:
            case RPC_P_RECEIVE_FAILED:
            case RPC_P_SEND_FAILED:
                RpcStatus = RPC_S_SERVER_UNAVAILABLE;
                break;

            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
            case ERROR_WINHTTP_SECURE_FAILURE:
                RpcStatus = RPC_S_ACCESS_DENIED;
                break;

            case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                break;

            case ERROR_WINHTTP_OUT_OF_HANDLES:
            case ERROR_NOT_ENOUGH_MEMORY:
            case RPC_S_OUT_OF_MEMORY:
            case ERROR_NO_SYSTEM_RESOURCES:
            case ERROR_COMMITMENT_LIMIT:
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;

            case ERROR_NOT_SUPPORTED:
                RpcStatus = RPC_S_CANNOT_SUPPORT;
                break;

            case ERROR_WINHTTP_TIMEOUT:
                RpcStatus = RPC_S_CALL_CANCELLED;
                break;

            default:
                // acess denied doesn't get remapped
                ASSERT(LastError == RPC_S_ACCESS_DENIED);
                RpcStatus = LastError;
                break;
            }
        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
            RpcStatus);

        goto CleanupAndExit;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_OPEN, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RPC_S_OK);

    RpcStatus = RPC_S_OK;

CleanupAndExit:
    if (LocalEvent != NULL)
        CloseHandle(LocalEvent);

    return RpcStatus;
}
                                      
RPC_STATUS HTTP2WinHttpTransportChannel::Send (
        IN OUT HTTP2SendContext *SendContext
        )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL HttpResult = TRUE;
    ULONG LastError;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        (ULONG_PTR)SendContext);

    Mutex.Request();
    SendsPending ++;
    ASSERT(SendsPending >= 0);
    if (SendsPending > 1)
        {
        // queue and exit
        SendContext->SetListEntryUsed();
        RpcpInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
        Mutex.Clear();

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_WINHTTP_CHANNEL, 
            SendsPending);

        return RPC_S_OK;
        }
    Mutex.Clear();

    ASSERT(State == whtcsSentRequest);

    State = whtcsWriting;

    CurrentSendContext = SendContext;

    HttpResult = WinHttpWriteDataImp(hRequest,
                                  SendContext->pWriteBuffer,
                                  SendContext->maxWriteBuffer,
                                  &NumberOfBytesTransferred
                                  );
    if (HttpResult == FALSE)
        {
        LastError = GetLastError();

        VALIDATE(LastError)
            {
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SHUTDOWN
            } END_VALIDATE;

        RpcStatus = RPC_P_SEND_FAILED;
        }
    else
        RpcStatus = RPC_S_OK;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
};

RPC_STATUS HTTP2WinHttpTransportChannel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL HttpResult;
    ULONG LastError;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        TrafficType);

    //
    // Before we can do any receives, we need to do a WinHttpReceiveResponse
    // if it has not been issued yet.
    //
    // This call only needs to be done before the first Receive.
    //

    if (State != whtcsReceivedResponse)
        {
        Mutex.Request();

        // if there are still sends, we have indicated our
        // traffic type in the DelayedReceiveTrafficType.
        // Just exit, and the last send will do the receive
        // work.
        if (SendsPending > 0)
            {
            if (TrafficType == http2ttRTS)
                DelayedReceiveTrafficType = http2ttRTSWithSpecialBit;
            else if (TrafficType == http2ttData)
                DelayedReceiveTrafficType = http2ttDataWithSpecialBit;
            else
                {
                ASSERT(TrafficType == http2ttRaw);
                DelayedReceiveTrafficType = http2ttRawWithSpecialBit;
                }
            Mutex.Clear();
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                SendsPending);

            return RPC_S_OK;
            }
        Mutex.Clear();

        DelayedReceiveTrafficType = TrafficType;

        ASSERT(State == whtcsSentRequest);

        State = whtcsReceivingResponse;

        HttpResult = WinHttpReceiveResponseImp(hRequest, NULL);

        // If the function returned FALSE, then it has failed syncronously.
        if (!HttpResult)
            {
            DelayedReceiveTrafficType = http2ttNone;

            LastError = GetLastError();

            VALIDATE(LastError)
                    {
                    ERROR_WINHTTP_CANNOT_CONNECT,
                    ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                    ERROR_WINHTTP_CONNECTION_ERROR,
                    ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                    ERROR_WINHTTP_INVALID_URL,
                    ERROR_WINHTTP_LOGIN_FAILURE,
                    ERROR_WINHTTP_NAME_NOT_RESOLVED,
                    ERROR_WINHTTP_OUT_OF_HANDLES,
                    ERROR_WINHTTP_REDIRECT_FAILED,
                    ERROR_WINHTTP_RESEND_REQUEST,
                    ERROR_WINHTTP_SECURE_FAILURE,
                    ERROR_WINHTTP_SHUTDOWN,
                    ERROR_WINHTTP_TIMEOUT,
                    ERROR_NOT_SUPPORTED
                    } END_VALIDATE;

            switch (LastError)
                {
                case ERROR_WINHTTP_CONNECTION_ERROR:
                case ERROR_WINHTTP_REDIRECT_FAILED:
                case ERROR_WINHTTP_RESEND_REQUEST:
                case ERROR_WINHTTP_SHUTDOWN:
                case ERROR_WINHTTP_SECURE_FAILURE:
                    RpcStatus = RPC_P_RECEIVE_FAILED;
                    break;

                case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
                    RpcStatus = RPC_S_PROTOCOL_ERROR;
                    break;

                case ERROR_NOT_SUPPORTED:
                    RpcStatus = RPC_S_CANNOT_SUPPORT;
                    break;

                case ERROR_WINHTTP_TIMEOUT:
                    RpcStatus = RPC_S_CALL_CANCELLED;
                    break;

                default:
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    break;
                }

            VALIDATE(RpcStatus)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES,
                RPC_P_RECEIVE_FAILED,
                RPC_S_CALL_CANCELLED,
                RPC_P_SEND_FAILED,
                RPC_P_CONNECTION_SHUTDOWN,
                RPC_P_TIMEOUT
                } END_VALIDATE;

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RpcStatus);

            return RpcStatus;
            }
        else
            {
            // If the function returned TRUE, then it will complete asyncronously.
            // We should return. All additional work will be done on a separate thread

            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
                RPC_S_OK);

            return RPC_S_OK;
            }
        }

    RpcStatus = HTTP2FragmentReceiver::Receive(TrafficType);

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
};

RPC_STATUS HTTP2WinHttpTransportChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    ULONG LocalSendsPending;
    BOOL HttpResult;
    ULONG LastError;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        EventStatus);

    CurrentSendContext = NULL;

    Mutex.Request();
    // decrement this in advance so that if we post another send on send
    // complete, it doesn't get queued
    LocalSendsPending = -- SendsPending;
    ASSERT(SendsPending >= 0);

    Mutex.Clear();

    // If we are processing a failed send-complete, this call may abort
    // the channels and complete pending sends.
    EventStatus = HTTP2TransportChannel::SendComplete(EventStatus, SendContext);

    if ((EventStatus == RPC_S_OK)
        || (EventStatus == RPC_P_PACKET_CONSUMED) )
        {
        QueuedSendContext = NULL;

        // Check if we have a queued send context.
        // Because we pre-decremented SendsPending, we have "borrowed"
        // a count and there is a queued context iff the count is above 0.
        if (LocalSendsPending > 0)
            {
            Mutex.Request();
            QueuedListEntry = RpcpRemoveHeadList(&BufferQueueHead);
            ASSERT(QueuedListEntry);
            ASSERT(QueuedListEntry != &BufferQueueHead);
            QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);
            Mutex.Clear();
            QueuedSendContext->SetListEntryUnused();
            }

        if (QueuedSendContext)
            {
            ASSERT(State == whtcsSentRequest);

            State = whtcsWriting;

            // need to synchronize with aborts (rule 9)
            RpcStatus = TopChannel->BeginSimpleSubmitAsync();

            CurrentSendContext = QueuedSendContext;
            NumberOfBytesTransferred = QueuedSendContext->maxWriteBuffer;

            if (RpcStatus == RPC_S_OK)
                {
                HttpResult = WinHttpWriteDataImp(hRequest,
                                              QueuedSendContext->pWriteBuffer,
                                              QueuedSendContext->maxWriteBuffer,
                                              &NumberOfBytesTransferred
                                              );

                TopChannel->FinishSubmitAsync();

                if (HttpResult == FALSE)
                    {
                    LastError = GetLastError();

                    VALIDATE(LastError)
                        {
                        ERROR_WINHTTP_CONNECTION_ERROR,
                        ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
                        ERROR_WINHTTP_RESEND_REQUEST,
                        ERROR_WINHTTP_SHUTDOWN
                        } END_VALIDATE;

                    // the send failed. We don't get a notification for it
                    // so we must issue one. We do this by posting direct send
                    AsyncError = RPC_P_SEND_FAILED;
                    ASSERT(CurrentSendContext == QueuedSendContext);

                    (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                        this
                        );
                    }
                else
                    {
                    // nothing to do - notification will come asynchronously
                    }
                }
            else
                {
                AsyncError = RPC_P_SEND_FAILED;
                ASSERT(CurrentSendContext == QueuedSendContext);

                (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_SEND,
                    this
                    );
                }
            }
        }

    // if a receive has registered itself and we're the one who finished the
    // sends, do the receive
    if (
        (
         (DelayedReceiveTrafficType == http2ttRTSWithSpecialBit)
         || (DelayedReceiveTrafficType == http2ttDataWithSpecialBit)
         || (DelayedReceiveTrafficType == http2ttRawWithSpecialBit)
        )
        && 
        (LocalSendsPending == 0)
       )
        {
        if (DelayedReceiveTrafficType == http2ttRTSWithSpecialBit)
            DelayedReceiveTrafficType = http2ttRTS;
        else if (DelayedReceiveTrafficType == http2ttRawWithSpecialBit)
            DelayedReceiveTrafficType = http2ttRaw;
        else
            {
            ASSERT(DelayedReceiveTrafficType == http2ttDataWithSpecialBit);
            DelayedReceiveTrafficType = http2ttData;
            }

        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = Receive(DelayedReceiveTrafficType);

            TopChannel->FinishSubmitAsync();
            }

        if (RpcStatus != RPC_S_OK)
            {
            // offload the result as direct receive. We use the refcount of the receive
            // to complete the operation on the worker thread.
            AsyncError = RpcStatus;

            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            }
        else
            {
            // when it completes, it will issue its own notification
            }
        }

    // don't call AsyncCompleteHelper here. We will always be called from DirectSendComplete
    // which will call AsyncCompleteHelper for us

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        EventStatus);

    return EventStatus;
}

void HTTP2WinHttpTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

Notes:

    This method must be idempotent. It may be called multiple times.

--*/
{
    BOOL HttpResult;
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_WINHTTP_CHANNEL, RpcStatus);

    if (hRequest)
        {
        HttpResult = WinHttpCloseHandleImp(hRequest);
        ASSERT(HttpResult);
        hRequest = NULL;
        }

    if (hConnect)
        {
        HttpResult = WinHttpCloseHandleImp(hConnect);
        ASSERT(HttpResult);
        hConnect = NULL;
        }

    if (hSession)
        {
        HttpResult = WinHttpCloseHandleImp(hSession);
        ASSERT(HttpResult);
        hSession = NULL;
        }

    Mutex.Request();
    // If there are more then 1 pending sends, then some sends must have been queued.
    // We will abort the queued sends.
    for (; SendsPending > 1; )
        {
        ASSERT(!RpcpIsListEmpty(&BufferQueueHead));
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

        -- SendsPending;
        ASSERT(SendsPending > 0);
        HTTP2TransportChannel::SendComplete(RpcStatus, QueuedSendContext);
        AsyncCompleteHelper(RpcStatus);
        }
    Mutex.Clear();
}

void HTTP2WinHttpTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_WINHTTP_CHANNEL, 0);

    if (pReadBuffer)
        {
        RpcFreeBuffer(pReadBuffer);
        pReadBuffer = NULL;
        }

    HTTP2WinHttpTransportChannel::~HTTP2WinHttpTransportChannel();
}

RPC_STATUS HTTP2WinHttpTransportChannel::DirectReceiveComplete (
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection
    )
/*++

Routine Description:

    Direct receive completion (i.e. we posted a receive
    to ourselves)

Arguments:

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

Return Value:

    RPC_S_OK, RPC_P_PACKET_CONSUMED or RPC_S_* errors.

--*/
{
    RPC_STATUS RpcStatus;
    BOOL HttpResult;
    ULONG WaitResult;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        AsyncError);

    *RuntimeConnection = TopChannel->GetRuntimeConnection();

    // two cases - previous coalesced read and a real read
    if (iLastRead && iLastRead == MaxReadBuffer)
        {
        // previous coalesced read
        *ReceivedBufferLength = MaxReadBuffer;
        iLastRead = 0;
        RpcStatus = RPC_S_OK;
        }
    else
        {
        // real read
        ASSERT(AsyncError != RPC_S_INTERNAL_ERROR);

        if ((AsyncError == RPC_S_OK) 
            && (NumberOfBytesTransferred == 0))
            {
            // zero bytes transferred indicates end of request.
            AsyncError = RPC_P_RECEIVE_FAILED;
            }

        RpcStatus = AsyncError;
        AsyncError = RPC_S_INTERNAL_ERROR;

        if (RpcStatus == RPC_S_OK)
            {
            if (pReadBuffer == NULL)
                {
                if (NumberOfBytesTransferred > iPostSize)
                    MaxReadBuffer = NumberOfBytesTransferred;
                else
                    MaxReadBuffer = iPostSize;
                pReadBuffer = (BYTE *)RpcAllocateBuffer(MaxReadBuffer);
                // fall through for error check below
                }
            else if (MaxReadBuffer - iLastRead < NumberOfBytesTransferred)
                {
                ASSERT(iLastRead < MaxReadBuffer);

                // Buffer too small for the message.
                RpcStatus = TransConnectionReallocPacket(NULL,
                                                      &pReadBuffer,
                                                      iLastRead,
                                                      iLastRead + NumberOfBytesTransferred
                                                      );

                if (RpcStatus != RPC_S_OK)
                    {
                    RpcFreeBuffer(pReadBuffer);
                    pReadBuffer = NULL;
                    }

                MaxReadBuffer = iLastRead + NumberOfBytesTransferred;
                }
            else
                {
                // buffer should be enough - no need to reallocate
                ASSERT(iLastRead < MaxReadBuffer);
                }
    
            if (pReadBuffer == NULL)
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                NumberOfBytesTransferred = 0;
                }
            else
                {
                // we need to temporarily get into submission context to synchronize
                // with Aborts
                RpcStatus = TopChannel->BeginSimpleSubmitAsync();
                if (RpcStatus == RPC_S_OK)
                    {
                    ASSERT(SyncEvent == NULL);
                    SyncEvent = I_RpcTransGetThreadEvent();
                    ResetEvent(SyncEvent);

                    HttpResult = WinHttpReadDataImp(hRequest,
                                                 pReadBuffer + iLastRead,
                                                 NumberOfBytesTransferred,
                                                 &NumberOfBytesTransferred
                                                 );

                    // wait for read complete to finish
                    WaitResult = WaitForSingleObject(SyncEvent, INFINITE);
                    // this cannot fail
                    ASSERT(WaitResult == WAIT_OBJECT_0);
                    SyncEvent = NULL;

                    // the data are available. We cannot possibly fail
                    ASSERT(HttpResult);
                    TopChannel->FinishSubmitAsync();
                    }
                else
                    {
                    // fall through with the error.
                    }
                }
            }

        *ReceivedBufferLength = NumberOfBytesTransferred;
        }

    RpcStatus = HTTP2WinHttpTransportChannel::ReceiveComplete(RpcStatus,
        http2ttRaw,
        ReceivedBuffer,
        (UINT *)ReceivedBufferLength
        );

    // did we receive an incomplete buffer?
    if ((RpcStatus == RPC_S_OK) && (*ReceivedBuffer == NULL))
        {
        // hide it from the runtime
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }

    // AsyncCompleteHelper has already been called in ReceiveComplete

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
}

RPC_STATUS HTTP2WinHttpTransportChannel::DirectSendComplete (
    OUT BYTE **SentBuffer,
    OUT void **SendContext
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us). 

Arguments:

    SentBuffer - on output the buffer that we tried to send

    SendContext - on output contains the send context as 
        seen by the runtime

Return Value:

    RPC_S_OK to return error to runtime
    RPC_P_PACKET_CONSUMED - to hide packet from runtime
    RPC_S_* error - return error to runtime

--*/
{
    HTTP2SendContext *LocalCurrentSendContext;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        AsyncError);

    ASSERT(AsyncError != RPC_S_INTERNAL_ERROR);

    ASSERT(CurrentSendContext);

    State = whtcsSentRequest;

    LocalCurrentSendContext = CurrentSendContext;

    // CurrentSendContext is zeroed out by the call.
    RpcStatus = HTTP2WinHttpTransportChannel::SendComplete(AsyncError, LocalCurrentSendContext);

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        // this will return to the runtime. Make sure it is valid
        I_RpcTransVerifyClientRuntimeCallFromContext(LocalCurrentSendContext);
        *SendContext = LocalCurrentSendContext;
        *SentBuffer = LocalCurrentSendContext->pWriteBuffer;
        }
    else
        {
        // the packet was a transport packet - it won't be seen by the runtime
        *SendContext = NULL;
        *SentBuffer = NULL;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);
    // do not touch this pointer after here unless the list was not-empty
    // (which implies we still have refcounts)

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);

    return RpcStatus;
}

void HTTP2WinHttpTransportChannel::DelayedReceive (
    void
    )
/*++

Routine Description:

    Performs a delayed receive. The first receive on an WinHttp
    channel is delayed because we must receive the headers before
    we can do the actual receive.

Arguments:

Return Value:

Note: Will be called from upcall context

--*/
{
    BOOL HttpResult;
    ULONG LastError;
    RPC_STATUS RpcStatus;
    BOOL InSubmissionContext;
    BYTE *Ignored;
    UINT BufferLength;
    ULONG StatusCode;
    ULONG StatusCodeLength;
    ULONG HttpStatus;
    RPC_CHAR ConnectionOptions[40];
    RPC_CHAR *ConnectionOptionsToUse;
    ULONG ConnectionOptionsLength;
    int i;
    RPC_CHAR *KeepAliveString;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_WHTTP_DELAYED_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        AsyncError);

    // Check if we have received an async failure.
    LastError = AsyncError;
    AsyncError = RPC_S_INTERNAL_ERROR;
    RpcStatus = RPC_S_OK;
    InSubmissionContext = FALSE;

    if (LastError == RPC_S_OK)
        {
        // get into submission context
        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            InSubmissionContext = TRUE;

            StatusCodeLength = sizeof(StatusCode);
            HttpResult = WinHttpQueryHeadersImp (
                hRequest,
                WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                WINHTTP_HEADER_NAME_BY_INDEX,
                &StatusCode,
                &StatusCodeLength,
                WINHTTP_NO_HEADER_INDEX
                );

            if (!HttpResult)
                {
                LastError = GetLastError();
                }
            else
                {
                if (StatusCode != HTTP_STATUS_OK)
                    {
                    if ((StatusCode >= RPC_S_INVALID_STRING_BINDING) && (StatusCode <= RPC_X_BAD_STUB_DATA))
                        {
                        // if it is an RPC error code, just return it.
                        RpcStatus = StatusCode;
                        }
                    else if ((StatusCode == HTTP_STATUS_NOT_FOUND)
                        || (StatusCode == HTTP_STATUS_BAD_METHOD)
                        || (StatusCode == HTTP_STATUS_BAD_METHOD)
                        || (StatusCode == HTTP_STATUS_SERVER_ERROR)
                        || (StatusCode == HTTP_STATUS_NOT_SUPPORTED)
                        || (StatusCode == HTTP_STATUS_SERVICE_UNAVAIL) )
                        {
                        RpcStatus = RPC_S_SERVER_UNAVAILABLE;
                        }
                    else if (StatusCode == HTTP_STATUS_REQUEST_TOO_LARGE)
                        RpcStatus = RPC_S_SERVER_OUT_OF_MEMORY;
                    else if (StatusCode == HTTP_STATUS_PROXY_AUTH_REQ)
                        {
                        if ((HttpCredentials == NULL) 
                            || (HttpCredentials->AuthenticationTarget & RPC_C_HTTP_AUTHN_TARGET_PROXY) == 0)
                            {
                            // we were not asked to authenticate against a proxy. Just fail
                            RpcStatus = RPC_S_ACCESS_DENIED;
                            }
                        else
                            {
                            ChosenAuthScheme = NegotiateAuthScheme();
                            if (ChosenAuthScheme == 0)
                                RpcStatus = RPC_S_ACCESS_DENIED;
                            else
                                {
                                State = whtcsDraining;
                                HttpResult = WinHttpQueryDataAvailableImp(hRequest,
                                    &NumberOfBytesTransferred
                                    );

                                ASSERT(HttpResult);
                                RpcStatus = RPC_S_OK;
                                goto CleanupAndExit;
                                }
                            }
                        }
                    else if (StatusCode == HTTP_STATUS_DENIED)
                        {
                        if ((HttpCredentials == NULL) 
                            || (HttpCredentials->AuthenticationTarget & RPC_C_HTTP_AUTHN_TARGET_SERVER) == 0)
                            {
                            // we were not asked to authenticate against a server. Just fail
                            RpcStatus = RPC_S_ACCESS_DENIED;
                            }
                        else
                            {
                            ChosenAuthScheme = NegotiateAuthScheme();
                            if (ChosenAuthScheme == 0)
                                RpcStatus = RPC_S_ACCESS_DENIED;
                            else
                                {
                                State = whtcsDraining;
                                HttpResult = WinHttpQueryDataAvailableImp(hRequest,
                                    &NumberOfBytesTransferred
                                    );

                                ASSERT(HttpResult);

                                RpcStatus = RPC_S_OK;
                                goto CleanupAndExit;
                                }
                            }
                        }
                    else
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                    }
                else
                    {
                    // RpcStatus is already set above
                    ASSERT(RpcStatus == RPC_S_OK);

                    ConnectionOptionsLength = sizeof(ConnectionOptions);
                    ConnectionOptionsToUse = ConnectionOptions;

                    for (i = 0; i < 2; i ++)
                        {
                        HttpResult = WinHttpQueryHeadersImp (
                            hRequest,
                            WINHTTP_QUERY_CONNECTION,
                            WINHTTP_HEADER_NAME_BY_INDEX,
                            ConnectionOptionsToUse,
                            &ConnectionOptionsLength,
                            WINHTTP_NO_HEADER_INDEX
                            );

                        if (!HttpResult)
                            {
                            LastError = GetLastError();
                            if (LastError == ERROR_INSUFFICIENT_BUFFER)
                                {
                                ConnectionOptionsToUse = new RPC_CHAR[ConnectionOptionsLength];
                                if (ConnectionOptionsToUse == NULL)
                                    {
                                    LastError = RPC_S_OUT_OF_MEMORY;
                                    // fall through with the error below
                                    break;
                                    }
                                }
                            else if (LastError == ERROR_WINHTTP_HEADER_NOT_FOUND)
                                {
                                // we did not get keep alives. This is ok
                                LastError = RPC_S_OK;
                                KeepAlive = FALSE;
                                break;
                                }
                            else
                                {
                                LastError = RPC_S_OUT_OF_MEMORY;
                                // fall through with the error below
                                break;
                                }
                            }
                        else
                            {
                            LastError = RPC_S_OK;
                            break;
                            }
                        }   // for (i ...

                    ASSERT(LastError != ERROR_INSUFFICIENT_BUFFER);
                    if (LastError == RPC_S_OK)
                        {
                        // we got the connection options. Do we have keep alive?
                        KeepAliveString = RpcpStrStr(ConnectionOptionsToUse, L"Keep-Alive");
                        if (KeepAliveString)
                            KeepAlive = TRUE;
                        }

                    if (ConnectionOptionsToUse != ConnectionOptions)
                        delete [] ConnectionOptionsToUse;

                    }   // StatusCode == HTTP_STATUS_OK
                }   // WinHttpQueryHeadersImp succeeded
            }   // BeginSimpleSubmitAsync succeeded
        else
            {
            // BeginSimpleSubmitAsync failed - fall through with the error
            // RpcStatus and success LastError
            ASSERT(LastError == RPC_S_OK);
            }
        }

    if (LastError != RPC_S_OK)
        {
        VALIDATE(LastError)
            {
            ERROR_WINHTTP_CANNOT_CONNECT,
            ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_INVALID_URL,
            ERROR_WINHTTP_LOGIN_FAILURE,
            ERROR_WINHTTP_NAME_NOT_RESOLVED,
            ERROR_WINHTTP_OUT_OF_HANDLES,
            ERROR_WINHTTP_REDIRECT_FAILED,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SECURE_FAILURE,
            ERROR_WINHTTP_SHUTDOWN,
            ERROR_WINHTTP_TIMEOUT,
            ERROR_NOT_SUPPORTED,
            RPC_P_SEND_FAILED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_AUTH_NEEDED
            } END_VALIDATE;

        switch (LastError)
            {
            case ERROR_WINHTTP_CONNECTION_ERROR:
            case ERROR_WINHTTP_REDIRECT_FAILED:
            case ERROR_WINHTTP_RESEND_REQUEST:
            case ERROR_WINHTTP_SHUTDOWN:
            case ERROR_WINHTTP_CANNOT_CONNECT:
            case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
            case ERROR_WINHTTP_INVALID_URL:
            case ERROR_WINHTTP_LOGIN_FAILURE:
            case ERROR_WINHTTP_NAME_NOT_RESOLVED:
            case ERROR_WINHTTP_SECURE_FAILURE:
            case RPC_P_AUTH_NEEDED:
                RpcStatus = RPC_P_RECEIVE_FAILED;
                break;

            case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                break;

            case ERROR_NOT_SUPPORTED:
                RpcStatus = RPC_S_CANNOT_SUPPORT;
                break;

            case ERROR_WINHTTP_TIMEOUT:
                RpcStatus = RPC_S_CALL_CANCELLED;
                break;

            case RPC_P_SEND_FAILED:
            case RPC_P_RECEIVE_FAILED:
                RpcStatus = LastError;
                break;

            default:
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;
            }

        VALIDATE(RpcStatus)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_RECEIVE_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_TIMEOUT
            } END_VALIDATE;
        }

    if (RpcStatus == RPC_S_OK)
        {
        ASSERT(InSubmissionContext);

        RpcStatus = HTTP2FragmentReceiver::Receive(DelayedReceiveTrafficType);
        }

CleanupAndExit:
    if (InSubmissionContext)
        {
        TopChannel->FinishSubmitAsync();
        }

    DelayedReceiveTrafficType = http2ttNone;

    if (RpcStatus != RPC_S_OK)
        {
        // we got a failure. Issue receive complete. Since DelayedReceive
        // happens only on channel recycling, and then we know we
        // issue RTS receive, we don't need to indicate this to the runtime
        BufferLength = 0;
        RpcStatus = ReceiveComplete(RpcStatus, 
            DelayedReceiveTrafficType,
            &Ignored,
            &BufferLength
            );

        ASSERT(RpcStatus == RPC_P_PACKET_CONSUMED);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_WHTTP_DELAYED_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 
        RpcStatus);
}

void HTTP2WinHttpTransportChannel::VerifyServerCredentials (
    void
    )
/*++

Routine Description:

    Verifies that the server credentials match the subject info we
    were given.

Arguments:
    
Return Value:

--*/
{
    BOOL HttpResult;
    PCERT_CONTEXT CertContext;
    ULONG OptionSize;
    RPC_STATUS RpcStatus;
    RPC_CHAR *StringSPN;
    RPC_STATUS AbortError;

    // make sure nobody has touched the async error after open
    ASSERT((AsyncError == RPC_S_OK)
        || ((AsyncError == RPC_S_INTERNAL_ERROR)));

    // if no credentials, nothing to verify
    if ((HttpCredentials == NULL) 
        || (HttpCredentials->ServerCertificateSubject == NULL))
        return;

    OptionSize = sizeof(PCERT_CONTEXT);
    HttpResult = WinHttpQueryOptionImp(hRequest,
        WINHTTP_OPTION_SERVER_CERT_CONTEXT,
        &CertContext,
        &OptionSize
        );

    if (!HttpResult)
        {
        AsyncError = GetLastError();
        VALIDATE(AsyncError)
            {
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_INVALID_OPERATION
            } END_VALIDATE;

        switch (AsyncError)
            {
            case ERROR_INVALID_OPERATION:
                // we will get this when we ask for the certificate of non
                // SSL connection
                AsyncError = RPC_S_ACCESS_DENIED;
                break;

            default:
                AbortError = RPC_S_OUT_OF_MEMORY;
            }

        goto AbortAndExit;
        }

    RpcStatus = I_RpcTransCertMatchPrincipalName(CertContext, HttpCredentials->ServerCertificateSubject);
    if (RpcStatus != RPC_S_OK)
        {
        AbortError = AsyncError = RpcStatus;
        goto AbortAndExit;
        }

    return;

AbortAndExit:
    ASSERT(AsyncError != ERROR_SUCCESS);
    // HTTP2WinHttpTransportChannel::Abort is idempotent. We'll call it now to
    // tell WinHttp to abort, and ClientOpen will call it again. This is ok.
    Abort(AbortError);
}

RPC_STATUS HTTP2WinHttpTransportChannel::PostReceive (
    void
    )
/*++

Routine Description:

    Posts a receive to WinHttp.

Arguments:
    
Return Value:

    RPC_S_OK or RPC_S_* error

Note: May be called from both submission and upcall context

--*/
{
    BOOL HttpResult;
    RPC_STATUS RpcStatus;
    ULONG LastError;
    ULONG AvailableLength;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, 0);

    ASSERT(State == whtcsReceivedResponse);

    State = whtcsReading;

    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    HttpResult = WinHttpQueryDataAvailableImp (hRequest,
        &NumberOfBytesTransferred
        );

    TopChannel->FinishSubmitAsync();

    if (!HttpResult)
        {
        LastError = GetLastError();

        VALIDATE(LastError)
            {
            ERROR_NOT_ENOUGH_MEMORY,
            ERROR_WINHTTP_CONNECTION_ERROR,
            ERROR_WINHTTP_INVALID_SERVER_RESPONSE,
            ERROR_WINHTTP_RESEND_REQUEST,
            ERROR_WINHTTP_SHUTDOWN
            } END_VALIDATE;

        RpcStatus = RPC_P_RECEIVE_FAILED;
        }
    else
        {
        // If the function returned non-zero,
        // then it will complete asyncronously.
        // Nothing to do here, we will receive async notification.
        RpcStatus = RPC_S_OK;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_WINHTTP_CHANNEL, RpcStatus);
    
    return RpcStatus;
}

ULONG HTTP2WinHttpTransportChannel::GetPostRuntimeEvent (
    void
    )
/*++

Routine Description:

    Gets the message to be posted to the runtime.

Arguments:

Return Value:

    The message to post to the runtime

--*/
{
    return HTTP2_WINHTTP_DIRECT_RECV;
}

ULONG HTTP2WinHttpTransportChannel::NegotiateAuthScheme (
    void
    )
/*++

Routine Description:

    Negotiates an auth scheme supported by client and server/proxy
    according to preference rules.

Arguments:

Return Value:

    The negotiated scheme or 0 if no scheme could be negotiated.

Notes:

    The actual server/proxy supported/preferred schemes will be retrieved
    from hRequest.

--*/
{
    BOOL HttpResult;
    ULONG Ignored;
    ULONG ServerSupportedSchemes;   // we use Server for brevity, but this
    ULONG ServerPreferredScheme;   // applies to proxies as well
    ULONG *ClientSupportedSchemes;
    ULONG CountOfClientSupportedSchemes;
    int i;
    
    HttpResult = WinHttpQueryAuthSchemesImp (hRequest,
        &ServerSupportedSchemes,
        &ServerPreferredScheme,
        &Ignored        // pdwAuthTarget - we have already determined this
                        // from the error code - ignore now.
        );

    if (!HttpResult)
        return 0;

    // first, if we support the server preference, we just choose
    // that.
    CountOfClientSupportedSchemes = HttpCredentials->NumberOfAuthnSchemes;
    ClientSupportedSchemes = HttpCredentials->AuthnSchemes;

    ASSERT(CountOfClientSupportedSchemes > 0);
    ASSERT(ClientSupportedSchemes != NULL);

    for (i = 0; i < CountOfClientSupportedSchemes; i ++)
        {
        if (ServerPreferredScheme == ClientSupportedSchemes[i])
            return ServerPreferredScheme;
        }

    // client doesn't support what the server asks for. Try whether the server
    // supports what the client prefers
    for (i = 0; i < CountOfClientSupportedSchemes; i ++)
        {
        if (ServerSupportedSchemes & ClientSupportedSchemes[i])
            return ClientSupportedSchemes[i];
        }

    return 0;
}


void HTTP2WinHttpTransportChannel::ContinueDrainChannel (
    void
    )
/*++

Routine Description:

    Continue draining the channel after authentication challenge. We
    need to drain the channel before we can proceed with the next
    request. The number of bytes received is in NumberOfBytesTransferred.
    If the channel was aborted in the meantime, issue receive
    complete.

Arguments:

Return Value:

--*/
{
    BYTE *Buffer;
    RPC_STATUS RpcStatus;
    BOOL HttpResult;

    // read the reported bytes. Then query again. If the
    // number of bytes reported is 0, issue a receive
    // for RPC_P_AUTH_NEEDED
    if (NumberOfBytesTransferred > 0)
        {
        Buffer = (BYTE *)RpcAllocateBuffer(NumberOfBytesTransferred);
        if (Buffer == NULL)
            {
            AsyncError = RPC_S_OUT_OF_MEMORY;
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            return;
            }

        // get into submissions context in order to safely access the
        // request
        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus != RPC_S_OK)
            {
            RpcFreeBuffer(Buffer);
            AsyncError = RpcStatus;
            (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
                this
                );
            return;
            }

        HttpResult = WinHttpReadDataImp (hRequest,
            Buffer,
            NumberOfBytesTransferred,
            &NumberOfBytesTransferred
            );

        // the data are here. This cannot fail
        ASSERT(HttpResult);

        RpcFreeBuffer(Buffer);

        // ask for more
        HttpResult = WinHttpQueryDataAvailableImp (hRequest,
            &NumberOfBytesTransferred
            );

        ASSERT(HttpResult);

        TopChannel->FinishSubmitAsync();
        }
    else
        {
        AsyncError = RPC_P_AUTH_NEEDED;
        (void) COMMON_PostRuntimeEvent(HTTP2_WINHTTP_DIRECT_RECV,
            this
            );
        }
}

/*********************************************************************
    HTTP2ProxySocketTransportChannel
 *********************************************************************/

RPC_STATUS HTTP2ProxySocketTransportChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Helper routine that helps complete an async operation

Arguments:
    
    CurrentStatus - the current status of the operation

Return Value:

    The status to return to the runtime.

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_COMPLETE_HELPER, HTTP2LOG_OT_PROXY_SOCKET_CHANNEL, CurrentStatus);

    ProxyAsyncCompleteHelper(TopChannel, CurrentStatus);

    return RPC_P_PACKET_CONSUMED;
}

/*********************************************************************
    HTTP2IISTransportChannel
 *********************************************************************/

const char ServerErrorString[] = "HTTP/1.0 503 RPC Error: %X\r\n\r\n";

DWORD 
ReplyToClientWithStatus (
    IN EXTENSION_CONTROL_BLOCK *pECB,
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Sends a reply to the client with the given error code as error.

Arguments:

    pECB - extension control block
    RpcStatus - error code to be returned to client

Return Value:

    Return value appropriate for return to IIS (i.e. HSE_STATUS_*)

--*/
{
    // size is the error string + 10 space for the error code
    char Buffer[sizeof(ServerErrorString) + 10];
    ULONG Size;
    ULONG Status;
    BOOL Result;
    DWORD  dwFlags = (HSE_IO_SYNC | HSE_IO_NODELAY);

    sprintf (Buffer,
        ServerErrorString,
        RpcStatus
        );

    Size = RpcpStringLengthA(Buffer);

    if (!pECB->WriteClient(pECB->ConnID, Buffer, &Size, dwFlags))
        {
        Status = GetLastError();
        #ifdef DBG_ERROR
        DbgPrint("ReplyToClientWithStatus(): failed: %d\n", Status);
        #endif
        return RPC_S_OUT_OF_MEMORY;
        }
    else
        return RPC_S_OK;
}


RPC_STATUS HTTP2IISTransportChannel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // make sure nobody gets here. Everybody should be using the internal
    // version
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2IISTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    BOOL Result;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_IIS_CHANNEL, RpcStatus);

    ReplyToClientWithStatus(ControlBlock, RpcStatus);

    // must abort the IIS session
    Result = ControlBlock->ServerSupportFunction( ControlBlock->ConnID,
                                          HSE_REQ_CLOSE_CONNECTION,
                                          NULL, 
                                          NULL, 
                                          NULL);

    ASSERT(Result);
}

void HTTP2IISTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_IIS_CHANNEL, 0);

    FreeIISControlBlock();

    if (pReadBuffer)
        {
        RpcFreeBuffer(pReadBuffer);
        pReadBuffer = NULL;
        }

    HTTP2IISTransportChannel::~HTTP2IISTransportChannel();
}

void HTTP2IISTransportChannel::IOCompleted (
    IN ULONG Bytes,
    DWORD Error
    )
/*++

Routine Description:

    An IO completed. Figure out what IO and what to do with it.

Arguments:

Return Value:

--*/
{
    RPC_STATUS RpcStatus;
    BYTE *Ignored;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_IIS_IO_COMPLETED, HTTP2LOG_OT_IIS_CHANNEL, Error);

    if (Direction == iistcdReceive)
        {
        (void) ReceiveCompleteInternal(Error ? RPC_P_RECEIVE_FAILED : RPC_S_OK, 
            http2ttRaw, 
            TRUE,   // ReadCompleted
            &Ignored, 
            (UINT *)&Bytes
            );
        }
    else
        {
        if (Error == ERROR_SUCCESS)
            {
            ASSERT(Bytes == CurrentSendContext->maxWriteBuffer);
            }

        (void) SendComplete(Error ? RPC_P_SEND_FAILED : RPC_S_OK, CurrentSendContext);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_IIS_IO_COMPLETED, HTTP2LOG_OT_IIS_CHANNEL, 0);
}

void HTTP2IISTransportChannel::DirectReceive (
    void
    )
/*++

Routine Description:

    Direct receive callback from the thread pool

Arguments:

Return Value:

--*/
{
    ULONG Bytes;
    RPC_STATUS RpcStatus;
    BYTE *Ignored;

    Bytes = iLastRead;
    iLastRead = 0;

    RpcStatus = ReceiveCompleteInternal(RPC_S_OK,
        http2ttRaw,
        FALSE,      // ReadCompleted
        &Ignored,
        (UINT *)&Bytes
        );

    ASSERT(RpcStatus != RPC_S_INTERNAL_ERROR);
    ASSERT(RpcStatus != RPC_P_PARTIAL_RECEIVE);
}

RPC_STATUS HTTP2IISTransportChannel::ReceiveCompleteInternal (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BOOL ReadCompleted,
    IN OUT BYTE **Buffer,
    IN OUT UINT *BufferLength
    )
/*++

Routine Description:

    Receive complete notification for the IIS transport channel. Somewhat
    different signature than normal receive complete.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    ReadCompleted - non-zero if a read completed. FALSE if it hasn't.

    Buffer - the buffer. Must be NULL at this level on input. On
        output contains the buffer for the current receive. If NULL
        on output, we did not have a full packet. Undefined on failure.

    BufferLength - the actual number of bytes received. On output the
        number of bytes for the current packet. If 0 on output,
        we did not have a complete packet. Undefined on failure.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (ReadCompleted)
        ReadsPending --;
    ASSERT(ReadsPending == 0);

    return HTTP2FragmentReceiver::ReceiveComplete (EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );
}

void HTTP2IISTransportChannel::FreeIISControlBlock (
    void
    )
/*++

Routine Description:

    Frees the IIS control block associated with this channel

Arguments:

Return Value:

--*/
{
    BOOL Result;

    Result = ControlBlock->ServerSupportFunction( ControlBlock->ConnID,
                                          HSE_REQ_DONE_WITH_SESSION,
                                          NULL, 
                                          NULL, 
                                          NULL);

    ASSERT(Result);

    ControlBlock = NULL;
}

RPC_STATUS HTTP2IISTransportChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    A helper function that completes an async io.

Arguments:
    
    CurrentStatus - the status with which the complete
        notification completed.

Return Value:

--*/
{
    return ProxyAsyncCompleteHelper(TopChannel, CurrentStatus);
}

RPC_STATUS HTTP2IISTransportChannel::PostReceive (
    void
    )
/*++

Routine Description:

    Posts a receive to IIS.

Arguments:
    
Return Value:

    RPC_S_OK or RPC_S_* error

Note: May be called from both submission and upcall context

--*/
{
    BOOL Result;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_IIS_CHANNEL, 0);

    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    ASSERT (Direction == iistcdReceive);

    if (pReadBuffer == NULL)
        {
        pReadBuffer = (BYTE *)RpcAllocateBuffer(gPostSize);
        if (pReadBuffer == NULL)
            {
            TopChannel->FinishSubmitAsync();
            LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_IIS_CHANNEL, RPC_S_OUT_OF_MEMORY);
            return RPC_S_OUT_OF_MEMORY;
            }

        MaxReadBuffer = gPostSize;
        }
    else
        {
        ASSERT(iLastRead < MaxReadBuffer);
        }

    ReadsPending ++;
    ASSERT(ReadsPending == 1);

    BytesToTransfer = MaxReadBuffer - iLastRead;

    Result = ControlBlock->ServerSupportFunction(ControlBlock->ConnID,
                                    HSE_REQ_ASYNC_READ_CLIENT,
                                    pReadBuffer + iLastRead,
                                    &BytesToTransfer,
                                    &IISIoFlags
                                    );

    TopChannel->FinishSubmitAsync();

    if (Result == FALSE)
        {
        ReadsPending --;
        ASSERT(ReadsPending == 0);

        ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);

        RpcStatus = RPC_P_RECEIVE_FAILED;
        }
    else
        RpcStatus = RPC_S_OK;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_IIS_CHANNEL, RpcStatus);
    
    return RpcStatus;
}

ULONG HTTP2IISTransportChannel::GetPostRuntimeEvent (
    void
    )
/*++

Routine Description:

    Gets the message to be posted to the runtime.

Arguments:

Return Value:

    The message to post to the runtime

--*/
{
    return IN_PROXY_IIS_DIRECT_RECV;
}

/*********************************************************************
    HTTP2IISSenderTransportChannel
 *********************************************************************/

RPC_STATUS HTTP2IISSenderTransportChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL Result;
    ULONG LocalSendsPending;
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_IIS_SENDER_CHANNEL, (ULONG_PTR)SendContext);

    Mutex.Request();
    LocalSendsPending = SendsPending.Increment();
    if ((LocalSendsPending > 1) || ReadsPending)
        {
        // queue and exit
        SendContext->SetListEntryUsed();
        RpcpInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
        Mutex.Clear();

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_IIS_SENDER_CHANNEL, 1);

        return RPC_S_OK;
        }
    Mutex.Clear();

    if (Direction == iistcdReceive)
        ReverseDirection();

    CurrentSendContext = SendContext;
    BytesToTransfer = SendContext->maxWriteBuffer;
    Result = ControlBlock->WriteClient(ControlBlock->ConnID,
                                    SendContext->pWriteBuffer,
                                    &BytesToTransfer,
                                    IISIoFlags
                                    );

    if (Result == FALSE)
        {
        ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
        RpcStatus = RPC_P_SEND_FAILED;
        }
    else
        RpcStatus = RPC_S_OK;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_IIS_SENDER_CHANNEL, RpcStatus);

    return RpcStatus;
}

RPC_STATUS HTTP2IISSenderTransportChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ULONG LocalSendsPending;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_IIS_SENDER_CHANNEL, EventStatus);

    CurrentSendContext = NULL;

    // decrement this in advance so that if we post another send on send
    // complete, it doesn't get queued
    LocalSendsPending = SendsPending.Decrement();

    EventStatus = HTTP2TransportChannel::SendComplete(EventStatus, SendContext);

    if ((EventStatus == RPC_S_OK)
        || (EventStatus == RPC_P_PACKET_CONSUMED) )
        {
        EventStatus = SendQueuedContextIfNecessary (LocalSendsPending, EventStatus);
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND_COMPLETE, HTTP2LOG_OT_IIS_SENDER_CHANNEL, EventStatus);

    return AsyncCompleteHelper(EventStatus);
}

void HTTP2IISSenderTransportChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_IIS_SENDER_CHANNEL, RpcStatus);

    HTTP2IISTransportChannel::Abort(RpcStatus);

    Mutex.Request();
    if (SendsPending.GetInteger() > 1)
        {
        ASSERT(!RpcpIsListEmpty(&BufferQueueHead));
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
        do
            {
            QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

            SendsPending.Decrement();
            HTTP2TransportChannel::SendComplete(RpcStatus, QueuedSendContext);
            TopChannel->RemoveReference();

            QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
            }
        while (QueuedListEntry != &BufferQueueHead);
        }
    Mutex.Clear();
}

void HTTP2IISSenderTransportChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_FREE_OBJECT, HTTP2LOG_OT_IIS_SENDER_CHANNEL, 0);

    FreeIISControlBlock();

    HTTP2IISSenderTransportChannel::~HTTP2IISSenderTransportChannel();
}

RPC_STATUS HTTP2IISSenderTransportChannel::ReceiveCompleteInternal (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BOOL ReadCompleted,
    IN OUT BYTE **Buffer,
    IN OUT UINT *BufferLength
    )
/*++

Routine Description:

    Receive complete notification for the IIS sender transport channel. Somewhat
    different signature than normal receive complete.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    ReadCompleted - non-zero if a read completed. FALSE if it hasn't.

    Buffer - the buffer. Must be NULL at this level on input. On
        output contains the buffer for the current receive. If NULL
        on output, we did not have a full packet. Undefined on failure.

    BufferLength - the actual number of bytes received. On output the
        number of bytes for the current packet. If 0 on output,
        we did not have a complete packet. Undefined on failure.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    ULONG LocalSendsPending;

    Mutex.Request();
    // decrease the reads pending and check the sends within the mutex -
    // this ensures atomicity with respect to the send path's (which is
    // the only path we race with) increase of the sends and check of the
    // reads
    if (ReadCompleted)
        ReadsPending --;
    ASSERT(ReadsPending == 0);

    LocalSendsPending = SendsPending.GetInteger();
    Mutex.Clear();

    RpcStatus = HTTP2FragmentReceiver::ReceiveComplete (EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );

    if ((RpcStatus == RPC_S_OK)
        || (RpcStatus == RPC_P_PACKET_CONSUMED) )
        {
        RpcStatus = SendQueuedContextIfNecessary (LocalSendsPending, RpcStatus);
        }

    return RpcStatus;
}

RPC_STATUS HTTP2IISSenderTransportChannel::SendQueuedContextIfNecessary (
    IN ULONG LocalSendsPending,
    IN RPC_STATUS EventStatus
    )
/*++

Routine Description:

    Checks if any send contexts are queued for sending, and if yes, sends
    the first one (which on completion will send the next, etc).

Arguments:

    LocalSendsPending - the number of sends pending at the time the current
    operation completed save for the count of the current operation (if it
    was send)

    EventStatus - the RPC Status so far. Must be a success error status
    (RPC_S_OK or RPC_P_PACKET_CONSUMED)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    BOOL Result;

    if (LocalSendsPending != 0)
        {
        Mutex.Request();

        if (Direction == iistcdReceive)
            ReverseDirection();

        QueuedListEntry = RpcpRemoveHeadList(&BufferQueueHead);
        // it is possible that if an abort executed between getting LocalSendsPending
        // in caller and grabbing the mutex here that the list is empty.
        ASSERT(QueuedListEntry);
        if (QueuedListEntry == &BufferQueueHead)
            {
            Mutex.Clear();
            return EventStatus;
            }
        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);
        Mutex.Clear();
        QueuedSendContext->SetListEntryUnused();

        // need to synchronize with aborts (rule 9)
        EventStatus = TopChannel->BeginSimpleSubmitAsync();
        if (EventStatus == RPC_S_OK)
            {
            CurrentSendContext = QueuedSendContext;
            BytesToTransfer = QueuedSendContext->maxWriteBuffer;
            Result = ControlBlock->WriteClient(ControlBlock->ConnID,
                                            QueuedSendContext->pWriteBuffer,
                                            &BytesToTransfer,
                                            IISIoFlags
                                            );

            if (Result == FALSE)
                {
                EventStatus = RPC_P_SEND_FAILED;
                ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
                // the send failed. We don't get a notification for it
                // so we must issue one. Reference for the send we
                // failed to post is already added
                EventStatus = HTTP2TransportChannel::SendComplete(EventStatus, QueuedSendContext);
                TopChannel->RemoveReference();
                }
            else
                {
                // must already be ok
                ASSERT(EventStatus == RPC_S_OK);
                }

            TopChannel->FinishSubmitAsync();
            }
        }

    return EventStatus;
}

/*********************************************************************
    HTTP2GenericReceiver
 *********************************************************************/

void HTTP2GenericReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2GenericReceiver::~HTTP2GenericReceiver();
}

void HTTP2GenericReceiver::TransferStateToNewReceiver (
    OUT HTTP2GenericReceiver *NewReceiver
    )
/*++

Routine Description:

    Transfers all the settings from this receiver (i.e. the state
        of the receive) to a new one.

Arguments:

    NewReceiver - the new receiver to transfer the settings to

Return Value:

Notes:

    This must be called in an upcall context (i.e. no real receives
    pending) and the channel on which this is called must be non-default
    by now.

--*/
{
    NewReceiver->ReceiveWindow = ReceiveWindow;
}

RPC_STATUS HTTP2GenericReceiver::BytesReceivedNotification (
    IN ULONG Bytes
    )
/*++

Routine Description:

    Notifies channel that bytes have been received.

Arguments:

    Bytes - the number of data bytes received.

Return Value:

    RPC_S_OK if the received bytes did not violate the
        flow control protocol. RPC_S_PROTOCOL error otherwise.

--*/
{
    Mutex.VerifyOwned();

    BytesReceived += Bytes;
    BytesInWindow += Bytes;
    ASSERT(BytesInWindow <= ReceiveWindow);
    FreeWindowAdvertised -= Bytes;

    if (FreeWindowAdvertised < 0)
        {
        ASSERT(0);
        // sender sent data even though
        // we told it we don't have enough window
        // to receive it - protocol violation
        return RPC_S_PROTOCOL_ERROR;
        }

    return RPC_S_OK;
}

void HTTP2GenericReceiver::BytesConsumedNotification (
    IN ULONG Bytes,
    IN BOOL OwnsMutex,
    OUT BOOL *IssueAck,
    OUT ULONG *BytesReceivedForAck,
    OUT ULONG *WindowForAck
    )
/*++

Routine Description:

    Notifies channel that bytes have been consumed and can
    be freed from the receive window of the channel.

Arguments:

    Bytes - the number of data bytes consumed.

    OwnsMutex - non-zero if the mutex for the channel is
        already owned.

    IssueAck - must be FALSE on input. If the caller needs
        to issue an Ack, it will be set to non-zero on
        output.

    BytesReceivedForAck - on output, if IssueAck is non-zero,
        it will contain the bytes received to put in the
        ack packet. If IssueAck is FALSE, it is undefined.

    WindowForAck - on output, if IssueAck is non-zero,
        it will contain the window available to put in the
        ack packet. If IssueAck is FALSE, it is undefined.

Return Value:

--*/
{
    ULONG ReceiveWindowThreshold;

    if (OwnsMutex)
        {
        Mutex.VerifyOwned();
        }
    else
        {
        Mutex.Request();
        }

    ASSERT(*IssueAck == FALSE);

    BytesInWindow -= Bytes;
    // make sure we don't wrap
    ASSERT(BytesInWindow <= ReceiveWindow);
    ReceiveWindowThreshold = ReceiveWindow >> 1;
    if (FreeWindowAdvertised < (LONG)ReceiveWindowThreshold)
        {
        // we fell below the threshold. ACK our current window
        *IssueAck = TRUE;
        FreeWindowAdvertised = ReceiveWindow - BytesInWindow;
        ASSERT(FreeWindowAdvertised >= 0);
        *BytesReceivedForAck = BytesReceived;
        *WindowForAck = FreeWindowAdvertised;
        }

    if (OwnsMutex == FALSE)
        {
        Mutex.Clear();
        }
}

RPC_STATUS HTTP2GenericReceiver::SendFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Sends a flow control Ack packet.

Arguments:

    BytesReceivedForAck - the number of bytes received while
        we were issuing the Ack

    WindowForAck - the window available when BytesReceivedForAck
        bytes have been received

Return Value:

    RPC_S_OK or RPC_S_* for error

Notes:

    This must be called in a neutral context.

--*/
{
    return TopChannel->ForwardFlowControlAck (BytesReceivedForAck,
        WindowForAck
        );
}

/*********************************************************************
    HTTP2EndpointReceiver
 *********************************************************************/

RPC_STATUS HTTP2EndpointReceiver::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BOOL PostReceive;
    RPC_STATUS RpcStatus;
    BOOL DequeuePacket;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, TrafficType);

    DequeuePacket = FALSE;
    PostReceive = FALSE;
    Mutex.Request();

    switch (TrafficType)
        {
        case http2ttNone:
            ASSERT(0);
            RpcStatus = RPC_S_INTERNAL_ERROR;
            Mutex.Clear();
            return RpcStatus;

        case http2ttRTS:
            // we cannot issue two RTS receives.
            ASSERT((ReceivesPosted & http2ttRTS) == 0);
            // if we have RTS receives queued, dequeue one and
            // complete it
            if (ReceivesQueued == http2ttRTS)
                {
                ASSERT(DirectCompletePosted == FALSE);
                DirectCompletePosted = TRUE;
                DequeuePacket = TRUE;
                }
            else
                {
                // we have no packets queued, or only data packets
                // queued. If we have no data request pending, create
                // a request pending. Otherwise just add ourselves to
                // the map
                if (ReceivesPosted)
                    {
                    ASSERT(ReceivesPosted == http2ttData);
                    ReceivesPosted = http2ttAny;
                    }
                else
                    {
                    PostReceive = TRUE;
                    ReceivesPosted = http2ttRTS;
                    }
                }
            break;

        case http2ttData:
            // we cannot issue two Data receives.
            ASSERT((ReceivesPosted & http2ttData) == 0);
            // if we have Data receives queued, dequeue one and
            // complete it
            if (ReceivesQueued == http2ttData)
                {
                ASSERT(DirectCompletePosted == FALSE);
                DirectCompletePosted = TRUE;
                DequeuePacket = TRUE;
                }
            else
                {
                // we have no packets queued, or only RTS packets
                // queued. If we have no RTS request pending, create
                // a request pending. Otherwise just add ourselves to
                // the map
                if (ReceivesPosted)
                    {
                    ASSERT(ReceivesPosted == http2ttRTS);
                    ReceivesPosted = http2ttAny;
                    }
                else
                    {
                    PostReceive = TRUE;
                    ReceivesPosted = http2ttData;
                    }
                }
            break;

        default:
            ASSERT(0);
            RpcStatus = RPC_S_INTERNAL_ERROR;
            Mutex.Clear();
            return RpcStatus;
        }

    // only one of PostReceive and DequeuePacket can be set here.
    // Neither is ok too.
    ASSERT((PostReceive ^ DequeuePacket) 
        || ((PostReceive == FALSE)
             &&
            (DequeuePacket == FALSE)
           )
          );

    Mutex.Clear();

    if (DequeuePacket)
        {
        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, 0);
        (void) COMMON_PostRuntimeEvent(HTTP2_DIRECT_RECEIVE,
            this
            );
        return RPC_S_OK;
        }

    if (PostReceive == FALSE)
        {
        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, 1);
        return RPC_S_OK;
        }

    RpcStatus = HTTP2TransportChannel::Receive(http2ttRaw);
    if (RpcStatus != RPC_S_OK)
        {
        // we have indicated our receive as pending, yet we
        // couldn't submit it. Not good. Must attempt to
        // remove it from the pending variable unless somebody
        // else already did (which is possible if we wanted
        // to submit data and there was already pending RTS).
        Mutex.Request();

        switch (ReceivesPosted)
            {
            case http2ttNone:
                // should not be possible
                ASSERT(FALSE);
                RpcStatus = RPC_S_INTERNAL_ERROR;
                Mutex.Clear();
                return RpcStatus;

            case http2ttData:
                if (TrafficType == http2ttData)
                    ReceivesPosted = http2ttNone;
                else
                    {
                    // not possible that we submitted RTS
                    // and have data pending but not RTS
                    ASSERT(0);
                    Mutex.Clear();
                    return RPC_S_INTERNAL_ERROR;
                    }
                break;

            case http2ttRTS:
                if (TrafficType == http2ttRTS)
                    ReceivesPosted = http2ttNone;
                else
                    {
                    // possible that we attempted to submit data,
                    // but while we were trying, an async RTS submission
                    // failed, and we indicated it asynchronously. In this
                    // case we must not indicate the failure synchronously
                    RpcStatus = RPC_S_OK;
                    }
                break;

            case http2ttAny:
                if (TrafficType == http2ttRTS)
                    ReceivesPosted = http2ttData;
                else
                    ReceivesPosted = http2ttRTS;
                break;

            default:
                ASSERT(0);
                Mutex.Clear();
                return RPC_S_INTERNAL_ERROR;
            }

        Mutex.Clear();
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV, HTTP2LOG_OT_ENDPOINT_RECEIVER, 3);
    return RpcStatus;
}

RPC_STATUS HTTP2EndpointReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2TrafficType NewReceivesPosted;
    HTTP2TrafficType ThisCompleteTrafficType;
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    BOOL BufferQueued;
    RPC_STATUS RTSStatus;
    RPC_STATUS DataStatus;
    BOOL ReceiveCompletesFailed;
    BYTE *CurrentPosition;
    USHORT PacketFlags;
    BOOL IssueAck;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, EventStatus);

    BufferQueued = FALSE;
    Mutex.Request();

    if (EventStatus == RPC_S_OK)
        {
        if (IsRTSPacket(Buffer))
            ThisCompleteTrafficType = http2ttRTS;
        else
            {
            ThisCompleteTrafficType = http2ttData;
            EventStatus = BytesReceivedNotification(BufferLength
                );

            if (EventStatus != RPC_S_OK)
                {
                // fall through with an error. Don't free the buffer
                // (Rule 34).
                }
            }
        }

    if (EventStatus != RPC_S_OK)
        {
        if (ReceivesPosted == http2ttAny)
            ThisCompleteTrafficType = http2ttData;
        else
            ThisCompleteTrafficType = ReceivesPosted;
        }

    ReceiveCompletesFailed = FALSE;

    switch (ThisCompleteTrafficType)
        {
        case http2ttData:
            if ((ReceivesPosted & http2ttData) == FALSE)
                {
                // we haven't asked for data, but we get some. We'll
                // have to queue it
                ASSERT(ReceivesQueued != http2ttRTS);
                ReceivesQueued = http2ttData;
                if (BufferQueue.PutOnQueue(Buffer, BufferLength))
                    {
                    ReceiveCompletesFailed = TRUE;
                    RpcFreeBuffer(Buffer);
                    }
                BufferQueued = TRUE;
                }
            else
                {
                ReceivesPosted = (HTTP2TrafficType)(ReceivesPosted ^ http2ttData);
                NewReceivesPosted = ReceivesPosted;
                }
            break;

        case http2ttRTS:
            if ((ReceivesPosted & http2ttRTS) == FALSE)
                {
                // we haven't asked for RTS, but we get some. We'll
                // have to queue it
                ASSERT(ReceivesQueued != http2ttData);
                ReceivesQueued = http2ttRTS;
                if (BufferQueue.PutOnQueue(Buffer, BufferLength))
                    {
                    ReceiveCompletesFailed = TRUE;
                    RpcFreeBuffer(Buffer);
                    }
                BufferQueued = TRUE;
                }
            else
                {
                ReceivesPosted = (HTTP2TrafficType)(ReceivesPosted ^ http2ttRTS);
                NewReceivesPosted = ReceivesPosted;
                }
            break;

        default:
            ASSERT(0);
            break;
        }

    IssueAck = FALSE;

    if ((BufferQueued == FALSE) 
        && (ReceiveCompletesFailed == FALSE)
        && (ThisCompleteTrafficType == http2ttData)
        && (EventStatus == RPC_S_OK))
        {
        // we know the data will be consumed immediately
        BytesConsumedNotification (BufferLength,
            TRUE,       // OwnsMutex
            &IssueAck,
            &BytesReceivedForAck,
            &WindowForAck
            );
        }

    Mutex.Clear();

    if (IssueAck)
        {
        RpcStatus = SendFlowControlAck (BytesReceivedForAck,
            WindowForAck
            );

        if (RpcStatus != RPC_S_OK)
            {
            // turn this into a failure
            EventStatus = RpcStatus;
            // fall through to issuing the notification
            if (EventStatus == RPC_P_SEND_FAILED)
                EventStatus = RPC_P_RECEIVE_FAILED;
            }
        }

    if (ReceiveCompletesFailed)
        {
        // we got an unwanted receive, and couldn't queue it.
        // Abort the connection
        TopChannel->AbortConnection(RPC_S_OUT_OF_MEMORY);
        return RPC_P_PACKET_CONSUMED;
        }

    if (BufferQueued)
        {
        ASSERT(ReceivesPosted != http2ttNone);

        // the packet was not of the type we wanted.
        // Submit another receive hoping to get what we want
        RpcStatus = TopChannel->BeginSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            // we know we have one type of receive in the map. Nobody
            // can post another. Just post ours
            RpcStatus = HTTP2TransportChannel::Receive(http2ttRaw);
            TopChannel->FinishSubmitAsync();
            if (RpcStatus != RPC_S_OK)
                {
                TopChannel->RemoveReference();
                }
            }

        if (RpcStatus != RPC_S_OK)
            {
            // we failed to submit the receive. We have to issue notification for it
            RpcStatus = HTTP2TransportChannel::ReceiveComplete(RpcStatus, 
                ReceivesPosted,
                NULL,   // Buffer
                0       // BufferLength
                );

            TopChannel->AbortConnection(RpcStatus);
            }

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, RPC_P_PACKET_CONSUMED);

        // if we have queued, this means the runtime did not
        // ask for this packet. Don't let it see it.
        return RPC_P_PACKET_CONSUMED;
        }

    // The buffer was not queued - pass it up
    RpcStatus = HTTP2TransportChannel::ReceiveComplete(EventStatus,
        ThisCompleteTrafficType,
        Buffer,
        BufferLength
        );

    if (NewReceivesPosted != http2ttNone)
        {
        // if we left something in the map, nobody could have
        // posted a raw receive - they would have just upgraded the
        // map. It could still have been aborted though
        ASSERT((NewReceivesPosted == http2ttRTS)
            ||
            (NewReceivesPosted == http2ttData));

        // see what was left as pending recieve, and
        // actually submit that. We do that only if we didn't
        // fail before. If we did, don't bother
        if (EventStatus == RPC_S_OK)
            {
            RpcStatus2 = TopChannel->BeginSimpleSubmitAsync();
            if (RpcStatus2 == RPC_S_OK)
                {
                RpcStatus2 = HTTP2TransportChannel::Receive(http2ttRaw);

                TopChannel->FinishSubmitAsync();
                }
            }
        else
            {
            // transfer the error code
            RpcStatus2 = EventStatus;
            }

        if (RpcStatus2 != RPC_S_OK)
            {
            // we failed to submit the receive. We have to issue notification for it
            RpcStatus2 = HTTP2TransportChannel::ReceiveComplete(RpcStatus2, 
                NewReceivesPosted,
                NULL,   // Buffer
                0       // BufferLength
                );

            if (NewReceivesPosted == http2ttRTS)
                {
                ASSERT(RpcStatus2 != RPC_S_OK);
                }

            TopChannel->RemoveReference();  // remove reference for the receive complete
            }
        }

    // here, ThisCompleteTrafficType is the type of completed receive and
    // RpcStatus is the status for it. NewReceivesPosted is the next submit we received
    // (http2ttNone if none) and RpcStatus2 is the status for it.

    // make sure nobody has left unconsumed success RTS packets
    if (ThisCompleteTrafficType == http2ttRTS)
        {
        ASSERT(RpcStatus != RPC_S_OK);
        }

    // if there is only one receive type, no merging is necessary - just return
    if (NewReceivesPosted == http2ttNone)
        {
        // consume RTS receives
        if (ThisCompleteTrafficType == http2ttRTS)
            RpcStatus = RPC_P_PACKET_CONSUMED;

        LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, RpcStatus);

        return RpcStatus;
        }

    // Process them and determine the appropriate return code. If we
    // have two receives, we merge them as per the table below
    // N    First Receive        Second Receive      Return value    Note
    // --   --------------       -----------------   -------------   ---------
    // 1    DS                   RS                  S
    // 2    DS                   RC                  S
    // 3    DS                   RF                  S               Abort
    // 4    DF                   RS                  F
    // 5    DF                   RC                  F
    // 6    DF                   RF                  F               Choose first receive error
    // 7    RS                   DS                  Invalid combination (first RTS should have been consumed)
    // 8    RC                   DS                  C
    // 9    RF                   DS                  S              Abort
    // 10   RS                   DF                  Invalid combination (first RTS should have been consumed)
    // 11   RC                   DF                  C              Abort
    // 12   RF                   DF                  F              Choose first receive error

    if (ThisCompleteTrafficType == http2ttData)
        {
        ASSERT(NewReceivesPosted == http2ttRTS);
        DataStatus = RpcStatus;
        RTSStatus = RpcStatus2;
        }
    else
        {
        ASSERT(NewReceivesPosted == http2ttData);
        DataStatus = RpcStatus2;
        RTSStatus = RpcStatus;
        }

    if (DataStatus == RPC_S_OK)
        {
        if (RTSStatus == RPC_S_OK)
            {
            // case 1 - just return ok
            RpcStatus = RTSStatus;
            }
        else if (RTSStatus == RPC_P_PACKET_CONSUMED)
            {
            // case 2
            if (ThisCompleteTrafficType == http2ttData)
                {
                RpcStatus = DataStatus;
                }
            else
                {
                // case 8
                RpcStatus = RTSStatus;
                }
            }
        else
            {
            // cases 3 & 9
            TopChannel->AbortConnection(RTSStatus);
            }
        }
    else
        {
        if (RTSStatus == RPC_S_OK)
            {
            // case 4
            RpcStatus = DataStatus;
            }
        else if (RTSStatus == RPC_P_PACKET_CONSUMED)
            {
            // case 5 
            if (ThisCompleteTrafficType == http2ttData)
                {
                RpcStatus = DataStatus;
                }
            else
                {
                // case 11
                TopChannel->AbortConnection(DataStatus);
                RpcStatus = RTSStatus;
                }
            }
        else
            {
            // cases 6 & 12
            // nothing to do. First error is already in RpcStatus
            }
        }

    if (RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
        RpcStatus = RPC_P_RECEIVE_FAILED;

    VALIDATE (RpcStatus)
        {
        RPC_S_OK,
        RPC_P_PACKET_CONSUMED,
        RPC_P_RECEIVE_FAILED
        } END_VALIDATE;

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_ENDPOINT_RECEIVER, RpcStatus);

    return RpcStatus;
}

void HTTP2EndpointReceiver::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    BYTE *CurrentBuffer;
    UINT Ignored;
    ULONG SizeOfQueueToLeave;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_ENDPOINT_RECEIVER, RpcStatus);

    HTTP2TransportChannel::Abort(RpcStatus);

    Mutex.Request();

    // if there is a direct complete posted, we have to
    // leave one element in the queue, because the
    // direct complete routine will need it
    if (DirectCompletePosted)
        SizeOfQueueToLeave = 1;
    else
        SizeOfQueueToLeave = 0;

    while (BufferQueue.Size() > SizeOfQueueToLeave)
        {
        CurrentBuffer = (BYTE *) BufferQueue.TakeOffEndOfQueue(&Ignored);
        // the elements in the queue are unwanted anyway -
        // they don't have refcounts or anything else - just
        // free them
        RpcFreeBuffer(CurrentBuffer);
        }
    Mutex.Clear();
}

void HTTP2EndpointReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2EndpointReceiver::~HTTP2EndpointReceiver();
}

RPC_STATUS HTTP2EndpointReceiver::DirectReceiveComplete (
    OUT BYTE **ReceivedBuffer,
    OUT ULONG *ReceivedBufferLength,
    OUT void **RuntimeConnection,
    OUT BOOL *IsServer
    )
/*++

Routine Description:

    Direct receive completion (i.e. we posted a receive
    to ourselves). We can be called in only one case -
    a receive was submitted and there were already
        queued receives.

Arguments:

    ReceivedBuffer - the buffer that we received.

    ReceivedBufferLength - the length of the received
        buffer

    RuntimeConnection - the connection to return to the runtime
        if the packet is not consumed.

    IsServer - non-zero if the server

Return Value:

    RPC_S_OK, RPC_P_PACKET_CONSUMED or RPC_S_* errors.

Notes:

    The directly posted receive carries a reference count

--*/
{
    BYTE *Buffer;
    ULONG BufferLength;
    RPC_STATUS RpcStatus;
    HTTP2TrafficType QueuedPacketsType;
    BOOL IssueAck;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    BOOL PacketNeedsFlowControl;

    *IsServer = this->IsServer;
    *RuntimeConnection = TopChannel->GetRuntimeConnection();

    // dequeue a packet
    // we cannot have a queue and a posted receive at the same time
    ASSERT((ReceivesPosted & ReceivesQueued) == FALSE);

    Mutex.Request();

    ASSERT(DirectCompletePosted);
    ASSERT(DirectReceiveInProgress == FALSE);
    // they must be set in this order, because if a thread in 
    // TransferStateToNewReceiver synchronizes with us, it will check
    // them in reverse order.
    InterlockedIncrement((long *)&DirectReceiveInProgress);
    DirectCompletePosted = FALSE;

    QueuedPacketsType = ReceivesQueued;

    Buffer = (BYTE *)BufferQueue.TakeOffQueue((UINT *)&BufferLength);
    // even if aborted, at least one buffer must have been left for us
    // because we had the DirectCompletePosted flag set
    ASSERT (Buffer);

    if (BufferQueue.IsQueueEmpty())
        ReceivesQueued = http2ttNone;

    PacketNeedsFlowControl = (((ULONG_PTR)Buffer & 1) == 0);
    Buffer = (BYTE *)(((ULONG_PTR)Buffer) & (~(ULONG_PTR)1));

    RpcStatus = RPC_S_OK;
    *ReceivedBuffer = Buffer;
    *ReceivedBufferLength = BufferLength;

    // we know the data will be consumed.
    IssueAck = FALSE;
    if ((QueuedPacketsType == http2ttData) && PacketNeedsFlowControl)
        {
        BytesConsumedNotification (BufferLength,
            TRUE,       // OwnsMutex
            &IssueAck,
            &BytesReceivedForAck,
            &WindowForAck
            );
        }

    Mutex.Clear();

    if (IssueAck)
        {
        RpcStatus = SendFlowControlAck (BytesReceivedForAck,
            WindowForAck
            );

        if (RpcStatus != RPC_S_OK)
            {
            // turn this into a failure. Note that we must supply a buffer
            // on failure, hence we don't free it (Rule 34)
            // fall through to issuing the notification
            }
        }

    // decrement if before receive complete. In receive complete
    // we may post another receive and cause a race
    InterlockedDecrement((long *)&DirectReceiveInProgress);

    RpcStatus = HTTP2TransportChannel::ReceiveComplete(RpcStatus,
        QueuedPacketsType,
        Buffer,
        BufferLength
        );

    if (QueuedPacketsType == http2ttRTS)
        {
        ASSERT(RpcStatus != RPC_S_OK);
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }
    else
        {
        if (RpcStatus == RPC_P_SEND_FAILED)
            RpcStatus = RPC_P_RECEIVE_FAILED;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);

    VALIDATE(RpcStatus)
        {
        RPC_P_CONNECTION_CLOSED,
        RPC_P_RECEIVE_FAILED,
        RPC_P_CONNECTION_SHUTDOWN,
        RPC_P_PACKET_CONSUMED,
        RPC_S_OK
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS HTTP2EndpointReceiver::TransferStateToNewReceiver (
    OUT HTTP2EndpointReceiver *NewReceiver
    )
/*++

Routine Description:

    Transfers all the settings from this receiver (i.e. the state
        of the receive) to a new one.

Arguments:

    NewReceiver - the new receiver to transfer the settings to

Return Value:

    RPC_S_OK or RPC_S_* errors.

Notes:

    This must be called in an upcall context (i.e. no real receives
    pending) and the channel on which this is called must be non-default
    by now.

--*/
{
    void *Buffer;
    UINT BufferLength;
    void *QueueElement;
    int Result;
    BOOL QueueTransferred;

    // this channel is not a default channel by now. We know that
    // there may be receives in progress, but no new receives will be
    // submitted.
    while (TRUE)
        {
        Mutex.Request();
        if (DirectCompletePosted || DirectReceiveInProgress)
            {
            Mutex.Clear();
            Sleep(5);
            }
        else
            break;
        }

    NewReceiver->Mutex.Request();

    // transfer the settings for the base class
    HTTP2GenericReceiver::TransferStateToNewReceiver(NewReceiver);

    if (NewReceiver->BufferQueue.IsQueueEmpty() == FALSE)
        {
        // the only way we can end up here is if the channel replacement
        // took so long that the peer started pinging us. This is a protocol
        // error.
        NewReceiver->Mutex.Clear();
        Mutex.Clear();
        return RPC_S_PROTOCOL_ERROR;
        }

    QueueTransferred = FALSE;
    while (TRUE)
        {
        QueueElement = BufferQueue.TakeOffEndOfQueue(&BufferLength);
        if (QueueElement == 0)
            {
            QueueTransferred = TRUE;
            break;
            }

        if (NewReceiver->BufferQueue.PutOnFrontOfQueue((void *)((ULONG_PTR)QueueElement | 1), BufferLength) != 0)
            {
            // guaranteed to succeed since we never decrease buffers
            BufferQueue.PutOnFrontOfQueue(QueueElement, BufferLength);
            break;
            }
        }

    if (QueueTransferred == FALSE)
        {
        // failure - out of memory. Since the buffers are unwanted
        // we can just return failure. Both channels will be
        // aborted
        NewReceiver->Mutex.Clear();
        Mutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    NewReceiver->ReceivesQueued = ReceivesQueued;

    // we never transfer data receives. They will be transferred by our caller
    // We also preserve existing receives on the new receiver. There is a race where
    // data receives may have ended up on the new channel. That's ok as long as they
    // are off the old.
    ASSERT(((NewReceiver->ReceivesPosted & http2ttData) == 0)
        || ((ReceivesPosted & http2ttData) == 0));
    NewReceiver->ReceivesPosted 
        = (HTTP2TrafficType)(NewReceiver->ReceivesPosted | (ReceivesPosted & (~http2ttData)));

    // direct complete posted cannot be true here
    ASSERT(DirectCompletePosted == FALSE);

    NewReceiver->Mutex.Clear();

    Mutex.Clear();

    return RPC_S_OK;
}

/*********************************************************************
    HTTP2ProxyReceiver
 *********************************************************************/

RPC_STATUS HTTP2ProxyReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if ((EventStatus == RPC_S_OK) && (IsRTSPacket(Buffer) == FALSE))
        {
        Mutex.Request();
        EventStatus = BytesReceivedNotification(BufferLength
            );
        Mutex.Clear();

        if (EventStatus != RPC_S_OK)
            {
            // consume the packet and fall through with an error
            RpcFreeBuffer(Buffer);
            }
        }

    return HTTP2TransportChannel::ReceiveComplete(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );
}

void HTTP2ProxyReceiver::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel.

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    BYTE *CurrentBuffer;
    UINT Ignored;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_PROXY_RECEIVER, RpcStatus);

    HTTP2TransportChannel::Abort(RpcStatus);

    Mutex.Request();

    while (BufferQueue.Size() > 0)
        {
        CurrentBuffer = (BYTE *) BufferQueue.TakeOffQueue(&Ignored);
        // the elements in the queue are unwanted anyway -
        // they don't have refcounts or anything else - just
        // free them
        RpcFreeBuffer(CurrentBuffer);
        }
    Mutex.Clear();
}

void HTTP2ProxyReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2ProxyReceiver::~HTTP2ProxyReceiver();
}

/*********************************************************************
    HTTP2PlugChannel
 *********************************************************************/

C_ASSERT(http2plRTSPlugged == http2ttRTS);
C_ASSERT(http2plDataPlugged == http2ttData);

RPC_STATUS HTTP2PlugChannel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2TrafficType SendType;

#if DBG
    TrafficSentOnChannel = TRUE;
#endif // DBG

    SendType = SendContext->TrafficType;

    ASSERT((SendType == http2ttData)
        || (SendType == http2ttRTS)
        || (SendType == http2ttRaw) );

    // if the plug level says this packet should not go through, queue it
    // This means the traffic is no raw, and the plug level is less than
    // the send type. Since the constants are ordered this comparison is
    // sufficient
    if ((SendType != http2ttRaw) && (PlugLevel <= SendType))
        {
        SendContext->SetListEntryUsed();
        Mutex.Request();
        // queue and exit
        if (SendContext->Flags & SendContextFlagPutInFront)
            {
            RpcpfInsertHeadList(&BufferQueueHead, &SendContext->ListEntry);
            }
        else
            {
            RpcpfInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
            }
        Mutex.Clear();
        return RPC_S_OK;
        }
    else
        {
        // can't put in front on unplugged channel
        ASSERT((SendContext->Flags & SendContextFlagPutInFront) == 0);
        return HTTP2TransportChannel::Send(SendContext);
        }
}

void HTTP2PlugChannel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

Note: All sends carry a refcount. We must fully complete the sends

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_PLUG_CHANNEL, RpcStatus);

    HTTP2TransportChannel::Abort(RpcStatus);

    SendFailedStatus = RpcStatus;

    // Abort is made from submission context. We
    // know it is synchronized with other submissions
    // and we cannot issue upcalls for it. We will just post
    // as many direct send completions as there are buffers in 
    // the queue. When the post comes around, it will dequeue
    // and free one buffer for every post.
    // We know that after abort there will be no more submissions,
    // so not dequeuing them is fine

    if (BufferQueueHead.Flink != &BufferQueueHead)
        {
        (void) COMMON_PostRuntimeEvent(PLUG_CHANNEL_DIRECT_SEND,
            this
            );
        }
}

void HTTP2PlugChannel::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2PlugChannel::~HTTP2PlugChannel();
}

void HTTP2PlugChannel::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    ASSERT(SendFailedStatus);
    ASSERT(RpcpIsListEmpty(&BufferQueueHead));
    PlugLevel = http2plDataPlugged;
    LowerLayer->Reset();
}

RPC_STATUS HTTP2PlugChannel::DirectSendComplete (
    void
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us)

Arguments:

Return Value:

    RPC_S_OK

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    LIST_ENTRY *NextListEntry;
    RPC_STATUS RpcStatus;

    ASSERT(SendFailedStatus != RPC_S_INTERNAL_ERROR);

    QueuedListEntry = BufferQueueHead.Flink;

    // we wouldn't have a post if there wasn't something
    // in the list.
    ASSERT(QueuedListEntry != &BufferQueueHead);

    do
        {
        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

        // capture the next field before we issue send complete
        NextListEntry = QueuedListEntry->Flink;

        RpcStatus = HTTP2TransportChannel::SendComplete(SendFailedStatus, QueuedSendContext);

        QueuedListEntry = NextListEntry;

        // we don't care about the return code.
        (void) AsyncCompleteHelper(RpcStatus);
        }
    while (QueuedListEntry != &BufferQueueHead);

    return RPC_S_OK;
}

RPC_STATUS HTTP2PlugChannel::Unplug (
    void
    )
/*++

Routine Description:

    Unplugs the channel. This means that all bottled up traffic 
    starts flowing forward.

Arguments:
    
Return Value:

    RPC_S_OK or RPC_S_* errors

--*/
{
    HTTP2SendContext *QueuedSendContext;
    LIST_ENTRY *QueuedListEntry;
    RPC_STATUS RpcStatus;

    // first, send pending traffic. Then open the channel. Otherwise
    // traffic may get out of order

    while (TRUE)
        {
        Mutex.Request();
        QueuedListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
        // if we had non-zero elements ...
        if (QueuedListEntry != &BufferQueueHead)
            {
            Mutex.Clear();
            }
        else
            {
            // we have zero elements - just unplug the channel
            PlugLevel = http2plUnplugged;
            Mutex.Clear();
            RpcStatus = RPC_S_OK;
            break;
            }

        QueuedSendContext = CONTAINING_RECORD(QueuedListEntry, HTTP2SendContext, ListEntry);

        QueuedSendContext->SetListEntryUnused();

        // get into submission context - rule 9.
        RpcStatus = TopChannel->BeginSimpleSubmitAsync();
        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = HTTP2TransportChannel::Send(QueuedSendContext);
            TopChannel->FinishSubmitAsync();
            }

        if (RpcStatus != RPC_S_OK)
            {
            QueuedSendContext->SetListEntryUsed();
            Mutex.Request();
            RpcpfInsertHeadList(&BufferQueueHead, QueuedListEntry);
            Mutex.Clear();
            break;
            }
        }

    return RpcStatus;    
}

void HTTP2PlugChannel::SetStrongPlug (
    void
    )
/*++

Routine Description:

    Upgrades the default plug level (http2plDataPlugged) to
    RTS (http2plRTSPlugged)

Arguments:
    
Return Value:

--*/
{
    // make sure we haven't done any sending on the channel. The
    // channel cannot change plug levels after the first send
    ASSERT(TrafficSentOnChannel == FALSE);
    PlugLevel = http2plRTSPlugged;
}

/*********************************************************************
    HTTP2ProxyPlugChannel
 *********************************************************************/

RPC_STATUS HTTP2ProxyPlugChannel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    A helper function that completes an async io.

Arguments:
    
    CurrentStatus - the status with which the complete
        notification completed.

Return Value:

--*/
{
    return ProxyAsyncCompleteHelper(TopChannel, CurrentStatus);
}

/*********************************************************************
    HTTP2FlowControlSender
 *********************************************************************/

RPC_STATUS HTTP2FlowControlSender::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure
    if SendContextFlagSendLast is set, the following semantics applies:
    RPC_S_OK - no sends are pending. Last context directly sent
    ERROR_IO_PENDING - sends were pending. When they are all drained
        top channel and virtual connection will be notified through
        the LastPacketSentNotification mechanism
    RPC_S_* errors occured during synchronous send


--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *LocalSendContext;

    if (SendContext->TrafficType == http2ttData)
        {
        // we can't send data without knowing the receive window
        // of the peer
        ASSERT(PeerReceiveWindow != 0);
        }

    if (SendContext->Flags & SendContextFlagSendLast)
        {
        // register the last send. We know if this is called, no
        // new sends will be submitted. However, we race with the
        // send complete thread
        InterlockedExchangePointer((PVOID *)&SendContextOnDrain, SendContext);

        if (SendsPending.GetInteger() == 0)
            {
            // no sends are pending. Attempt to grab back the context
            // and do it synchronously
            LocalSendContext = 
                (HTTP2SendContext *)InterlockedExchangePointer((PVOID *)&SendContextOnDrain, NULL);
            if (LocalSendContext)
                {
                // we managed to grab it back. We have won the right to
                // synchronously submit the last context.
                RpcStatus = HTTP2TransportChannel::Send(LocalSendContext);
                // return ok or an error
                return RpcStatus;
                }
            }

        // either there are sends pending, or we lost the race and we have to
        // rely on asynchronous notifications
        return ERROR_IO_PENDING;
        }

    SendsPending.Increment();

    return SendInternal(SendContext,
        FALSE       // IgnoreQueuedPackets
        );
}

RPC_STATUS HTTP2FlowControlSender::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send
    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    int LocalSendsPending;
    HTTP2SendContext *LocalSendContextOnDrain;

    LocalSendsPending = SendsPending.Decrement();
    // in the case of Last packet to send completing, the counter will wrap to -1 here because
    // the last send is not present in SendsPending. That's ok.

    RpcStatus = HTTP2TransportChannel::SendComplete(EventStatus, SendContext);

    if (LocalSendsPending == 0)
        {
        LocalSendContextOnDrain = (HTTP2SendContext *) SendContextOnDrain;
        if (LocalSendContextOnDrain)
            {
            // try to consume the SendContextOnDrain in a thread safe manner
            // in respect to a thread that is setting it. In the cases where SendContextOnDrain
            // will be called the channel is already detached, so we know no new sends will
            // be submitted and we don't need to worry about the race with SendsPending going
            // up again
            LocalSendContextOnDrain = 
                (HTTP2SendContext *)InterlockedCompareExchangePointer((PVOID *)&SendContextOnDrain,
                NULL, 
                LocalSendContextOnDrain
                );

            if (LocalSendContextOnDrain)
                {
                // remove the reference for the previous send
                TopChannel->RemoveReference();

                // last packet must be RTS.
                ASSERT(LocalSendContextOnDrain->TrafficType == http2ttRTS);
                RpcStatus = TopChannel->LastPacketSentNotification(LocalSendContextOnDrain);
                // don't care about return code. This channel is dying anyway
                RpcStatus2 = TopChannel->Send(LocalSendContextOnDrain);

                // the second error takes precedence here
                if (RpcStatus2 != RPC_S_OK)
                    RpcStatus = RpcStatus2;
                }
            }
        }

    return RpcStatus;
}


void HTTP2FlowControlSender::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    // we have a bunch of sends carrying ref-counts, etc.
    // We must make sure they are completed.

    HTTP2TransportChannel::Abort(RpcStatus);

    // we know we are synchronized with everybody else
    if (!RpcpIsListEmpty(&BufferQueueHead))
        {
        AbortStatus = RpcStatus;
        (void) COMMON_PostRuntimeEvent(HTTP2_FLOW_CONTROL_DIRECT_SEND,
            this
            );
        }
}

void HTTP2FlowControlSender::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2FlowControlSender::~HTTP2FlowControlSender();
}

void HTTP2FlowControlSender::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

Note:

    The channel must not be receiving new requests by now (i.e.
    it must be non-default and fully drained)

--*/
{
    SendsPending.Decrement();
    UpperLayer->SendCancelled(SendContext);
}

RPC_STATUS HTTP2FlowControlSender::FlowControlAckNotify (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Notifies the channel that a flow control ack has arrived.

Arguments:

    BytesReceivedForAck - the bytes received from the ack packet

    WindowForAck - the available window advertised in the ack

Return Value:

    RPC_S_OK or RPC_S_PROTOCOL_ERROR if the received values are bogus

--*/
{
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *NextListEntry;
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;
    BOOL ChannelNeedsRecycling;

#if 0
    DbgPrint("%X: Flow control ack notify received: %d; %d\n",
        GetCurrentProcessId(), 
        BytesReceivedForAck,
        WindowForAck
        );
#endif

    RpcStatus = RPC_S_OK;
    ChannelNeedsRecycling = FALSE;

    Mutex.Request();
    ASSERT((DataBytesSent - BytesReceivedForAck) <= PeerReceiveWindow);
    if ((DataBytesSent - BytesReceivedForAck) > PeerReceiveWindow)
        {
        Mutex.Clear();
        return RPC_S_PROTOCOL_ERROR;
        }
    
    PeerAvailableWindow = WindowForAck - (DataBytesSent - BytesReceivedForAck);
    ASSERT(PeerAvailableWindow <= PeerReceiveWindow);
    if (PeerAvailableWindow > PeerReceiveWindow)
        {
        Mutex.Clear();
        return RPC_S_PROTOCOL_ERROR;
        }

    // did we free up enough window to send some of our queued buffers?
    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        if (SendContext->maxWriteBuffer <= PeerAvailableWindow)
            {
            SendContext->SetListEntryUnused();
            RpcpfRemoveHeadList(&BufferQueueHead);
            // set the CurrentListEntry for the next iteration of the loop
            CurrentListEntry = BufferQueueHead.Flink;
            // send it through this channel. This will update DataBytesSent
            // and PeerAvailableWindow
            RpcStatus = SendInternal(SendContext,
                TRUE    // IgnoreQueuedPackets
                );
            if (RpcStatus != RPC_S_OK)
                {
                if (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING)
                    {
                    // we failed to send - stick back the current context and
                    // return error. This will cause caller to abort and
                    // this will complete all queued sends
                    SendContext->SetListEntryUsed();
                    RpcpfInsertHeadList(&BufferQueueHead, &SendContext->ListEntry);
                    break;
                    }
                else
                    {
                    // remeber that we need to return RPC_P_CHANNEL_NEEDS_RECYCLING at
                    // the end
                    ChannelNeedsRecycling = TRUE;
                    }
                }
            }
        else
            {
            // we don't have enough space to send more. Break out of the loop
            break;
            }
        }
    Mutex.Clear();

    if (ChannelNeedsRecycling)
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
    else
        return RpcStatus;
}

void HTTP2FlowControlSender::GetBufferQueue (
    OUT LIST_ENTRY *NewQueueHead
    )
/*++

Routine Description:

    Grab all queued buffers and pile them on the list head
        that we passed to it. All refcounts must be removed (i.e.
        undone).

Arguments:

    NewQueueHead - new queue heads to pile buffers on

Return Value:

--*/
{
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *NextListEntry;
    HTTP2SendContext *SendContext;

    ASSERT(RpcpIsListEmpty(NewQueueHead));

    Mutex.Request();
    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        SendContext->SetListEntryUnused();
        NextListEntry = CurrentListEntry->Flink;
        RpcpfInsertHeadList(NewQueueHead, CurrentListEntry);
        UpperLayer->SendCancelled(SendContext);
        CurrentListEntry = NextListEntry;
        }
    RpcpInitializeListHead(&BufferQueueHead);
    Mutex.Clear();
}

RPC_STATUS HTTP2FlowControlSender::DirectSendComplete (
    OUT BOOL *IsServer,
    OUT BOOL *SendToRuntime,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us). Note that we will get one notification for
    all buffered sends. We must empty the whole queue, and post
    one notification for each buffer in the queue

Arguments:

    IsServer - in all cases MUST be set to TRUE or FALSE.

    SendToRuntime - in all cases MUST be set to TRUE or FALSE. If FALSE,
        it won't be sent to the runtime (used by proxies)

    SendContext - on output contains the send context as 
        seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK to return error to runtime
    RPC_P_PACKET_CONSUMED - to hide packet from runtime
    RPC_S_* error - return error to runtime

--*/
{
    LIST_ENTRY *CurrentListEntry;
    HTTP2SendContext *CurrentSendContext;
    RPC_STATUS RpcStatus;
    BOOL PostAnotherReceive;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_FLOW_CONTROL_SENDER, 
        !RpcpIsListEmpty(&BufferQueueHead));
    *IsServer = (BOOL)(this->IsServer);
    *SendToRuntime = (BOOL)(this->SendToRuntime);

    // this should only get called when we are aborted. This
    // ensures that we are single threaded in the code
    // below
    TopChannel->VerifyAborted();

    CurrentListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
    ASSERT(CurrentListEntry != &BufferQueueHead);
    
    CurrentSendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
    CurrentSendContext->SetListEntryUnused();

    ASSERT(AbortStatus != RPC_S_OK);

    RpcStatus = HTTP2TransportChannel::SendComplete(AbortStatus, CurrentSendContext);

    PostAnotherReceive = !(RpcpIsListEmpty(&BufferQueueHead));

    if ((RpcStatus != RPC_P_PACKET_CONSUMED) && this->SendToRuntime)
        {
        // this will return to the runtime. Make sure it is valid
        if (this->IsServer)
            I_RpcTransVerifyServerRuntimeCallFromContext(CurrentSendContext);
        else
            I_RpcTransVerifyClientRuntimeCallFromContext(CurrentSendContext);
        *SendContext = CurrentSendContext;
        *Buffer = CurrentSendContext->pWriteBuffer;
        *BufferLength = CurrentSendContext->maxWriteBuffer;
        }
    else
        {
        // the packet was a transport packet - it won't be seen by the runtime
        *SendContext = NULL;
        *Buffer = NULL;
        *BufferLength = 0;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);
    // do not touch this pointer after here unless the list was not-empty
    // (which implies we still have refcounts)

    if (PostAnotherReceive)
        {
        (void) COMMON_PostRuntimeEvent(HTTP2_FLOW_CONTROL_DIRECT_SEND,
            this
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_FLOW_CONTROL_SENDER, 
        PostAnotherReceive);

    return RpcStatus;
}

RPC_STATUS HTTP2FlowControlSender::SendInternal (
    IN OUT HTTP2SendContext *SendContext,
    IN BOOL IgnoreQueuedBuffers
    )
/*++

Routine Description:

    Send request without incrementing SendsPending counter
    and without handling SendContextFlagSendLast

Arguments:

    SendContext - the send context

    IgnoreQueuedBuffers - if non-zero, the send will proceed even if
        there are queued buffers. If FALSE, the send will be queued
        if there are queued buffers.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *LocalSendContext;

    if (SendContext->TrafficType == http2ttData)
        {
        Mutex.Request();
        // if the peer doesn't have enough window to accept this packet
        // or there are queued packets and we were told not to ignore them, 
        // we have to queue it. Otherwise we can send it
        if (
            (PeerAvailableWindow < SendContext->maxWriteBuffer) 
            || 
            (
               (IgnoreQueuedBuffers == FALSE)
               &&
               (BufferQueueHead.Flink != &BufferQueueHead)
            )
           )
            {
            // either the receiver doesn't have enough window or
            // we have pending buffers
            SendContext->SetListEntryUsed();
            RpcpfInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
            Mutex.Clear();
#if DBG_ERROR
            DbgPrint("Flow controlling sends ...%p\n", this);
#endif
            return RPC_S_OK;
            }
        else
            {
            // yes, update counters and continue with send
            DataBytesSent += SendContext->maxWriteBuffer;
            PeerAvailableWindow -= SendContext->maxWriteBuffer;
            }
        Mutex.Clear();
        }

    return HTTP2TransportChannel::Send(SendContext);
}

/*********************************************************************
    HTTP2PingOriginator
 *********************************************************************/

RPC_STATUS HTTP2PingOriginator::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ConsecutivePingsOnInterval = 0;

    return SendInternal(SendContext);
}

RPC_STATUS HTTP2PingOriginator::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification. Consume packets generated by us
    and forward everything else up.

Arguments:

    EventStatus - the status of the send

    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if ((SendContext->TrafficType == http2ttRTS) 
        && (TrustedIsPingPacket(SendContext->pWriteBuffer)))
        {
        // this is a packet we generated. Eat it up
        FreeRTSPacket(SendContext);
        return RPC_P_PACKET_CONSUMED;
        }

    return HTTP2TransportChannel::SendComplete(EventStatus, SendContext);
}

RPC_STATUS HTTP2PingOriginator::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection. Ignored for this function since we are always
        protected when we start a new submit.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives. Ignored in this
        function.

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    ULONG LocalNewPingInterval;

    // technically the time stamp can be 0, but this would
    // be extremely rare
    ASSERT(LastPacketSentTimestamp);
    ASSERT(Units == tuMilliseconds);

    if (TurnOn == FALSE)
        KeepAliveInterval = 0;
    else
        KeepAliveInterval = KAInterval;

    LocalNewPingInterval = GetPingInterval(ConnectionTimeout,
        KeepAliveInterval
        );

    return SetNewPingInterval(LocalNewPingInterval);
}

void HTTP2PingOriginator::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Abort the channel

Arguments:

    RpcStatus - the error code with which we abort

Return Value:

--*/
{
    HTTP2TransportChannel::Abort(RpcStatus);

    // we are already synchronized with everybody. Just
    // call the internal function
    DisablePingsInternal();
}

void HTTP2PingOriginator::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2PingOriginator::~HTTP2PingOriginator();
}

void HTTP2PingOriginator::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    RPC_STATUS RpcStatus;

    // a call was cancelled. We don't know what was the last sent
    // time before that, so the only safe thing to do is send another
    // ping. This should be extremely rare as it happens only sometimes
    // during channel recycling.
    
    RpcStatus = ReferenceFromCallback();

    // if already aborted, don't bother
    if (RpcStatus != RPC_S_OK)
        return;

    // we don't care about the result. The channel is dying. If we
    // managed to submit the ping, it's better. If not, we hope the
    // channel will last for long enough in order to complete the
    // recycle process
    RpcStatus = SendPingPacket();

    // SendCancelled will be called only when the channel is close to the
    // end of its recycling. We cannot get another recycling request here.
    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    TopChannel->FinishSubmitAsync();

    UpperLayer->SendCancelled(SendContext);
}

void HTTP2PingOriginator::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
    LastPacketSentTimestamp = 0;

    LowerLayer->Reset();
}

RPC_STATUS HTTP2PingOriginator::SetConnectionTimeout (
    IN ULONG ConnectionTimeout
    )
/*++

Routine Description:

    Sets the connection timeout for the ping channel. The ping channel
    does not ping when initialized. This call starts the process. It is
    synchronized with DisablePings but not with Aborts.

Arguments:

    ConnectionTimeout - the connection timeout in milliseconds

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    ULONG LocalNewPingInterval;

    // we don't accept anything less than the minimum timeout
    if (ConnectionTimeout <= MinimumConnectionTimeout)
        return RPC_S_PROTOCOL_ERROR;

    // technically the time stamp can be 0, but this would
    // be extremely rare
    ASSERT(LastPacketSentTimestamp);

    if (OverrideMinimumConnectionTimeout)
        this->ConnectionTimeout = min(ConnectionTimeout, OverrideMinimumConnectionTimeout);
    else
        this->ConnectionTimeout = ConnectionTimeout;

    LocalNewPingInterval = GetPingInterval(ConnectionTimeout,
        KeepAliveInterval
        );

    return SetNewPingInterval(LocalNewPingInterval);
}

void HTTP2PingOriginator::DisablePings (
    void
    )
/*++

Routine Description:

    Disables the pings for the channel. Synchronized with
    SetConnectionTimeout but not with Aborts

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    // synchronize with aborts and then call internal
    // routine
    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus == RPC_S_OK)
        {
        DisablePingsInternal();
        TopChannel->FinishSubmitAsync();
        }
}

void HTTP2PingOriginator::TimerCallback (
    void
    )
/*++

Routine Description:

    Timer callback routine - a periodic timer fired.
    Figure out what type of timer it was, and take
    appropriate action.
    N.B. We enter this routine with BeginSubmitAsync
    called on this channel

Arguments:

Return Value:

--*/
{
    ULONG CurrentTickCount;
    ULONG LocalLastSentTickCount;
    RPC_STATUS RpcStatus;
    ULONG LocalPingInterval;
    BOOL PingPacketSent;

    LocalLastSentTickCount = LastPacketSentTimestamp;
    CurrentTickCount = NtGetTickCount();

    // if less than the grace period has expired since the last
    // packet was sent, don't bother to send a ping
    if (CurrentTickCount - LocalLastSentTickCount >= GetGracePeriod())
        {
        PingPacketSent = TRUE;
        ConsecutivePingsOnInterval ++;

#if DBG_ERROR
        DbgPrint("Timer expired. No recent activity - sending ping ...\n");
#endif
        RpcStatus = SendPingPacket();

        if ((RpcStatus != RPC_S_OK)
            && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
            {
#if DBG_ERROR
            DbgPrint("Ping failed. Aborting connection.\n");
#endif
            TopChannel->FinishSubmitAsync();
            // offload the aborting to a worker thread (rule 33)
            (void) COMMON_PostRuntimeEvent(HTTP2_ABORT_CONNECTION,
                TopChannel
                );
            return;
            }

        if (ConsecutivePingsOnInterval >= ThresholdConsecutivePingsOnInterval)
            {
            LocalPingInterval = ScaleBackPingInterval();

            if (LocalPingInterval > PingInterval)
                {
                // we need to scale back. We can't do it from the timer callback, so we
                // need to offload to a worker thread for this

                ConsecutivePingsOnInterval = 0;

                // add a reference for the offloaded work item
                TopChannel->AddReference();

                (void) COMMON_PostRuntimeEvent(HTTP2_RESCHEDULE_TIMER,
                    this
                    );
                }
            }
        }
    else
        {
        PingPacketSent = FALSE;
#if DBG_ERROR
        DbgPrint("Timer expired. Recent activity on channel detected - no ping necessary\n");
#endif
        }

    TopChannel->FinishSubmitAsync();

    if ((PingPacketSent != FALSE) && (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING))
        {
        // we have the timer callback reference here which protects us. Once we
        // offload to a worker thread, the reference doesn't hold. Add another
        // reference for this.
        TopChannel->AddReference();

        // offload the recycling to a worker thread. This is necessary because
        // the recycling will abort on failure which violates rule 33.
        (void) COMMON_PostRuntimeEvent(HTTP2_RECYCLE_CHANNEL,
            TopChannel
            );
        }
}

RPC_STATUS HTTP2PingOriginator::ReferenceFromCallback (
    void
    )
/*++

Routine Description:

    References a ping originator object from the callback
    routine.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return TopChannel->BeginSubmitAsync();
}

RPC_STATUS HTTP2PingOriginator::SetNewPingInterval (
    IN ULONG NewPingInterval
    )
/*++

Routine Description:

    Puts into effect the new ping interval. This means
    cancelling the old interval (if any) and setting
    the timer for the new. Must NOT be called from
    timer callbacks or we will deadlock.

Arguments:

    NewPingInterval - the new ping interval to use

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    BOOL Result;

    // the new interval is different than the old. Need to update
    // and reschedule
    PingInterval = NewPingInterval;
    ConsecutivePingsOnInterval = 0;

    // synchronize with Aborts
    RpcStatus = TopChannel->BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    if (PingTimer)
        {
        DisablePingsInternal();
        }

    Result = CreateTimerQueueTimer(&PingTimer,
        NULL,
        HTTP2TimerCallback,
        this,
        PingInterval,  // time to first fire
        PingInterval,  // periodic interval
        WT_EXECUTELONGFUNCTION
        );

    if (Result == FALSE)
        {
        PingTimer = NULL;
        TopChannel->FinishSubmitAsync();
        return RPC_S_OUT_OF_MEMORY;
        }

    // add one reference for the timer callback we have set up
    TopChannel->AddReference();

    TopChannel->FinishSubmitAsync();

    return RPC_S_OK;
}

void HTTP2PingOriginator::RescheduleTimer (
    void
    )
/*++

Routine Description:

    Reschedules a timer. This means scale back a timer.

Arguments:

Return Value:

--*/
{
    ULONG LocalPingInterval;

    LocalPingInterval = ScaleBackPingInterval();

    if (LocalPingInterval > PingInterval)
        {
        // ignore the result. Scaling back is a best effort.
        // If it fails, that's ok.
        (void) SetNewPingInterval(LocalPingInterval);
        }

    // remove the reference for the work item
    TopChannel->RemoveReference();
}

void HTTP2PingOriginator::DisablePingsInternal (
    void
    )
/*++

Routine Description:

    Disables the pings for the channel. Must be synchronized with
    SetConnectionTimeout, Abort and DisablePings

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    BOOL Result;

    if (PingTimer)
        {
        Result = DeleteTimerQueueTimer(NULL,
            PingTimer,
            INVALID_HANDLE_VALUE    // tell the timer function to wait for all callbacks
                                    // to complete before returning
            );

#if DBG
        // during process shutdown the loader termination code will
        // shutdown threads (including the NTDLL thread pool threads)
        // before it indicates to anybody that it is doing so. This ASSERT
        // will fire in such cases causing random stress breaks. Disable it.
        // ASSERT(Result);     
#endif  // DBG

        // we added one reference for the timer callback. Remove it
        TopChannel->RemoveReference();

        PingTimer = NULL;
        }
}

RPC_STATUS HTTP2PingOriginator::SendPingPacket (
    void
    )
/*++

Routine Description:

    Sends a ping packet on this channel. Must be called with AsyncSubmit
        started.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *PingPacket;
    ULONG PingPacketSize;

    PingPacket = AllocateAndInitializePingPacket();
    if (PingPacket == NULL)
        return RPC_S_OUT_OF_MEMORY;

    PingPacketSize = PingPacket->maxWriteBuffer;

    RpcStatus = SendInternal(PingPacket);
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        FreeRTSPacket(PingPacket);
    else if (NotifyTopChannelForPings)
        TopChannel->PingTrafficSentNotify(PingPacketSize);

    return RpcStatus;
}

RPC_STATUS HTTP2PingOriginator::SendInternal (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    LastPacketSentTimestamp = NtGetTickCount();
    
    return HTTP2TransportChannel::Send(SendContext);
}

/*********************************************************************
    HTTP2PingReceiver
 *********************************************************************/

RPC_STATUS HTTP2PingReceiver::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (EventStatus == RPC_S_OK)
        {
        if (IsRTSPacket(Buffer) && UntrustedIsPingPacket(Buffer, BufferLength))
            {
            // this is a ping packet. Consume it and post another receive if
            // necessary
            if (PostAnotherReceive)
                {
                EventStatus = TopChannel->BeginSubmitAsync();
                if (EventStatus == RPC_S_OK)
                    {
                    EventStatus = HTTP2TransportChannel::Receive(http2ttRaw);
                    TopChannel->FinishSubmitAsync();
                    if (EventStatus != RPC_S_OK)
                        TopChannel->RemoveReference();
                    }
                }

            if (EventStatus == RPC_S_OK)
                {
                // we free the buffer only in success case. In failure case
                // we need a buffer to pass to receive complete down.
                RpcFreeBuffer(Buffer);
                return RPC_P_PACKET_CONSUMED;
                }
            else
                {
                // fall through to indicating a receive failure below
                }
            }
        }

    return HTTP2TransportChannel::ReceiveComplete(EventStatus, TrafficType, Buffer, BufferLength);
}

void HTTP2PingReceiver::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2PingReceiver::~HTTP2PingReceiver();
}

/*********************************************************************
    HTTP2ChannelDataOriginator
 *********************************************************************/

HTTP2ChannelDataOriginator::HTTP2ChannelDataOriginator (
    IN ULONG ChannelLifetime,
    IN BOOL IsServer,
    OUT RPC_STATUS *Status
    ) : Mutex(Status,
    FALSE,  // pre-allocate semaphore
    5000    // spin count
    )
/*++

Routine Description:

    HTTP2ChannelDataOriginator constructor

Arguments:

    ChannelLifetime - the lifetime read from the registry

    IsServer - non-zero if this is a server side data originator.
        0 otherwise.

    Status - on input RPC_S_OK. On output, the result of the constructor.

Return Value:

--*/
{
    RpcpInitializeListHead(&BufferQueueHead);

    this->ChannelLifetime = ChannelLifetime;
    NonreservedLifetime = ChannelLifetime;
    if (IsServer)
        NonreservedLifetime -= ServerReservedChannelLifetime;
    else
        NonreservedLifetime -= ClientReservedChannelLifetime;
    this->IsServer = IsServer;
    BytesSentOnChannel = 0;
    ChannelReplacementTriggered = FALSE;
    AbortStatus = RPC_S_OK;
#if DBG
    RawDataAlreadySent = FALSE;
#endif  // DBG
}


RPC_STATUS HTTP2ChannelDataOriginator::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    ULONG NewBytesSentOnChannel;
    BOOL ChannelReplacementNeeded;
    RPC_STATUS RpcStatus;
    ULONG LocalBytesSentOnChannel;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CDATA_ORIGINATOR, BytesSentOnChannel);

    ChannelReplacementNeeded = FALSE;

    // if this is raw traffic, don't count it
    if (SendContext->TrafficType == http2ttRaw)
        {
        RawDataBeingSent();
        }
    // otherwise, count it only if the traffic is not specifically exempt
    else if ((SendContext->Flags & SendContextFlagNonChannelData) == 0)
        {
        // we don't always take the mutex. We know that the bytes sent will only
        // grow. If we think it is a good time to recycle the channel, the fact that
        // another thread is also sending in a race condition with us makes it even
        // more so. We just need to be careful to properly update the BytesSendOnChannel
        // at the end
        LocalBytesSentOnChannel = BytesSentOnChannel;
        NewBytesSentOnChannel = LocalBytesSentOnChannel + SendContext->maxWriteBuffer;
        if ((NewBytesSentOnChannel > NonreservedLifetime) || ChannelReplacementTriggered)
            {
            Mutex.Request();

            // now that we have the mutex, check again. Sometimes the channel
            // can start sending from 0 again (e.g. out proxy negotiates a new
            // out channel with the client and server is ready to start from 0)
            // This can happen in restart channel, which is also protected by the
            // mutex

            LocalBytesSentOnChannel = BytesSentOnChannel;
            NewBytesSentOnChannel = LocalBytesSentOnChannel + SendContext->maxWriteBuffer;
            if ((NewBytesSentOnChannel > NonreservedLifetime) || ChannelReplacementTriggered)
                {
                if (ChannelReplacementTriggered == FALSE)
                    {
                    ChannelReplacementNeeded = TRUE;
                    ChannelReplacementTriggered = TRUE;
                    }

                // if this is data, queue it
                if (SendContext->TrafficType == http2ttData)
                    {
                    SendContext->SetListEntryUsed();
                    RpcpfInsertTailList(&BufferQueueHead, &SendContext->ListEntry);
                    Mutex.Clear();

                    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CDATA_ORIGINATOR, BytesSentOnChannel);

                    if (ChannelReplacementNeeded)
                        {
                        LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_CHANNEL_RECYCLE, HTTP2LOG_OT_CDATA_ORIGINATOR, NewBytesSentOnChannel);
                        return RPC_P_CHANNEL_NEEDS_RECYCLING;
                        }
                    else
                        return RPC_S_OK;
                    }
                else
                    {
                    ASSERT(SendContext->TrafficType == http2ttRTS);
                    // fall through to sending below
                    }
                }

            Mutex.Clear();
            // either channel got reset or this was RTS traffic. Fall through to
            // sending
            }

        // update BytesSentOnChannel in thread safe manner
        do
            {
            LocalBytesSentOnChannel = BytesSentOnChannel;
            NewBytesSentOnChannel = LocalBytesSentOnChannel + SendContext->maxWriteBuffer;
            }
        while (InterlockedCompareExchange((LONG *)&BytesSentOnChannel, 
            NewBytesSentOnChannel, 
            LocalBytesSentOnChannel) != LocalBytesSentOnChannel);
        }

    RpcStatus = HTTP2TransportChannel::Send(SendContext);

    if (ChannelReplacementNeeded && (RpcStatus == RPC_S_OK))
        {
#if DBG        
        DbgPrintEx(DPFLTR_RPCPROXY_ID,
                       DPFLTR_TRACE_LEVEL,
                       "RPCRT4: Indicating channel needs recycling %p %d\n",
                       this, 
                       IsServer);
#endif  // DBG

        LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_CHANNEL_RECYCLE, HTTP2LOG_OT_CDATA_ORIGINATOR, NewBytesSentOnChannel);
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SEND, HTTP2LOG_OT_CDATA_ORIGINATOR, BytesSentOnChannel);

    return RpcStatus;
}

void HTTP2ChannelDataOriginator::Abort (
    IN RPC_STATUS RpcStatus
    )
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CDATA_ORIGINATOR, RpcStatus);

    // we have a bunch of sends carrying ref-counts, etc.
    // We must make sure they are completed.

    HTTP2TransportChannel::Abort(RpcStatus);

    // we know we are synchronized with everybody else
    if (!RpcpIsListEmpty(&BufferQueueHead))
        {
        AbortStatus = RpcStatus;
        (void) COMMON_PostRuntimeEvent(CHANNEL_DATA_ORIGINATOR_DIRECT_SEND,
            this
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CDATA_ORIGINATOR, RpcStatus);
}

void HTTP2ChannelDataOriginator::FreeObject (
    void
    )
/*++

Routine Description:

    Frees the object. Acts like a destructor for the
    channel.

Arguments:

Return Value:

--*/
{
    if (LowerLayer)
        LowerLayer->FreeObject();

    HTTP2ChannelDataOriginator::~HTTP2ChannelDataOriginator();
}

void HTTP2ChannelDataOriginator::Reset (
    void
    )
/*++

Routine Description:

    Reset the channel for next open/send/receive. This is
    used in submission context only and implies there are no
    pending operations on the channel. It is used on the client
    during opening the connection to do quick negotiation on the
    same connection instead of opening a new connection every time.

Arguments:

Return Value:

--*/
{
#if DBG
    RawDataAlreadySent = FALSE;
#endif  // DBG
    ASSERT(RpcpIsListEmpty(&BufferQueueHead));
    LowerLayer->Reset();
}

void HTTP2ChannelDataOriginator::GetBufferQueue (
    OUT LIST_ENTRY *NewQueueHead
    )
/*++

Routine Description:

    Grab all queued buffers and pile them on the list head
    that we passed to it. All refcounts must be removed (i.e.
    undone). Called in submission context only and we know there
    will be no more sends. Therefore we are single threaded.

Arguments:

    NewQueueHead - new queue heads to pile buffers on

Return Value:

--*/
{
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *NextListEntry;
    HTTP2SendContext *SendContext;

    ASSERT(RpcpIsListEmpty(NewQueueHead));

    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        SendContext->SetListEntryUnused();
        NextListEntry = CurrentListEntry->Flink;
        RpcpfInsertHeadList(NewQueueHead, CurrentListEntry);
        UpperLayer->SendCancelled(SendContext);
        CurrentListEntry = NextListEntry;
        }
    RpcpInitializeListHead(&BufferQueueHead);
}

RPC_STATUS HTTP2ChannelDataOriginator::DirectSendComplete (
    OUT BOOL *IsServer,
    OUT void **SendContext,
    OUT BUFFER *Buffer,
    OUT UINT *BufferLength
    )
/*++

Routine Description:

    Direct send complete notification. Complete the send
    passing it only through channels that have seen it (i.e.
    above us). Note that we will get one notification for
    all buffered sends. We must empty the whole queue, and post
    one notification for each buffer in the queue

Arguments:

    IsServer - in all cases MUST be set to TRUE or FALSE.

    SendContext - on output contains the send context as 
        seen by the runtime

    Buffer - on output the buffer that we tried to send

    BufferLength - on output the length of the buffer we tried to send

Return Value:

    RPC_S_OK to return error to runtime
    RPC_P_PACKET_CONSUMED - to hide packet from runtime
    RPC_S_* error - return error to runtime

--*/
{
    LIST_ENTRY *CurrentListEntry;
    HTTP2SendContext *CurrentSendContext;
    RPC_STATUS RpcStatus;
    BOOL PostAnotherReceive;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_CDATA_ORIGINATOR, 
        !RpcpIsListEmpty(&BufferQueueHead));
    *IsServer = this->IsServer;

    // this should only get called when we are aborted. This
    // ensures that we are single threaded in the code
    // below
    TopChannel->VerifyAborted();

    CurrentListEntry = RpcpfRemoveHeadList(&BufferQueueHead);
    ASSERT(CurrentListEntry != &BufferQueueHead);
    
    CurrentSendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
    CurrentSendContext->SetListEntryUnused();

    ASSERT(AbortStatus != RPC_S_OK);

    RpcStatus = HTTP2TransportChannel::SendComplete(AbortStatus, CurrentSendContext);

    PostAnotherReceive = !(RpcpIsListEmpty(&BufferQueueHead));

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        // this will return to the runtime. Make sure it is valid
        if (this->IsServer)
            I_RpcTransVerifyServerRuntimeCallFromContext(CurrentSendContext);
        else
            I_RpcTransVerifyClientRuntimeCallFromContext(CurrentSendContext);
        *SendContext = CurrentSendContext;
        *Buffer = CurrentSendContext->pWriteBuffer;
        *BufferLength = CurrentSendContext->maxWriteBuffer;
        }
    else
        {
        // the packet was a transport packet - it won't be seen by the runtime
        *SendContext = NULL;
        *Buffer = NULL;
        *BufferLength = 0;
        }

    RpcStatus = AsyncCompleteHelper(RpcStatus);
    // do not touch this pointer after here unless the list was not-empty
    // (which implies we still have refcounts)

    if (PostAnotherReceive)
        {
        (void) COMMON_PostRuntimeEvent(CHANNEL_DATA_ORIGINATOR_DIRECT_SEND,
            this
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_DIRECT_SEND_COMPLETE, HTTP2LOG_OT_CDATA_ORIGINATOR, 
        PostAnotherReceive);

    return RpcStatus;
}

RPC_STATUS HTTP2ChannelDataOriginator::RestartChannel (
    void
    )
/*++

Routine Description:

    Restart the channel. Somehow the channel lifetime became
    fully available again, and we can start from 0. This happens
    when the out proxy renegotiates the out channel with the client
    and we can keep using the server channels again.

Arguments:

Return Value:

    RPC_S_OK
    RPC_S_* error

--*/
{
    LIST_ENTRY *CurrentListEntry;
    HTTP2SendContext *SendContext;
    ULONG NewBytesSentOnChannel = 0;
    ULONG BytesForThisSend;
    RPC_STATUS RpcStatus;

    // the channel must have been plugged
    ASSERT(BytesSentOnChannel > NonreservedLifetime);

    Mutex.Request();
    // grab all queued packets and send them out
    CurrentListEntry = BufferQueueHead.Flink;
    while (CurrentListEntry != &BufferQueueHead)
        {
        SendContext = CONTAINING_RECORD(CurrentListEntry, HTTP2SendContext, ListEntry);
        SendContext->SetListEntryUnused();
        ASSERT(SendContext->TrafficType == http2ttData);

        BytesForThisSend = SendContext->maxWriteBuffer;

        // assume success of the send and remove the element from the queue.
        // This is necessary because if the send succeeds, there is a race
        // condition with the send complete path
        (void) RpcpfRemoveHeadList(&BufferQueueHead);

        RpcStatus = HTTP2TransportChannel::Send(SendContext);

        ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

        if (RpcStatus != RPC_S_OK)
            {
            // failure. We should issue send complete for all queued sends
            // including the current one. However, it is easier for us to add back
            // the currently failed send and return failure to caller. Caller will
            // abort and there we will issue send complete for all pending sends.
            SendContext->SetListEntryUsed();
            RpcpfInsertHeadList(&BufferQueueHead, CurrentListEntry);
            Mutex.Clear();
            // return failure to the caller. This will cause the caller to abort the
            // channel, and all sends will be completed.
            return RpcStatus;
            }

        NewBytesSentOnChannel += BytesForThisSend;

        ASSERT(NewBytesSentOnChannel < NonreservedLifetime);

        // process the next element (which by now has become the first since
        // we removed the successfully sent one).
        CurrentListEntry = BufferQueueHead.Flink;
        }

    // reset the counters
    ChannelReplacementTriggered = FALSE;
    BytesSentOnChannel = NewBytesSentOnChannel;

    Mutex.Clear();

    return RPC_S_OK;
}

RPC_STATUS HTTP2ChannelDataOriginator::NotifyTrafficSent (
    IN ULONG TrafficSentSize
    )
/*++

Routine Description:

    Notifies the channel that bytes were sent on the wire. Channel
    reports back whether channel recycling should occur.

Arguments:

    TrafficSentSize - the number of bytes sent.

Return Value:

    RPC_S_OK or RPC_P_CHANNEL_NEEDS_RECYCLING.

--*/
{
    ULONG LocalBytesSentOnChannel;
    ULONG NewBytesSentOnChannel;
    BOOL ChannelReplacementNeeded;

    ChannelReplacementNeeded = FALSE;

    // this is very rare. Don't bother to take the mutex opportunistically.
    // Just make sure that we do use interlocks because no all paths take
    // the mutex. The mutex synchronizes us with Restart
    Mutex.Request();

    LocalBytesSentOnChannel = BytesSentOnChannel;
    NewBytesSentOnChannel = LocalBytesSentOnChannel + TrafficSentSize;
    if (NewBytesSentOnChannel > NonreservedLifetime)
        {
        if (ChannelReplacementTriggered == FALSE)
            {
            ChannelReplacementNeeded = TRUE;
            ChannelReplacementTriggered = TRUE;
            }
        }

    Mutex.Clear();

    // update BytesSentOnChannel in thread safe manner
    do
        {
        LocalBytesSentOnChannel = BytesSentOnChannel;
        NewBytesSentOnChannel = LocalBytesSentOnChannel + TrafficSentSize;
        }
    while (InterlockedCompareExchange((LONG *)&BytesSentOnChannel, 
        NewBytesSentOnChannel, 
        LocalBytesSentOnChannel) != LocalBytesSentOnChannel);

    if (ChannelReplacementNeeded)
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
    else
        return RPC_S_OK;
}

/*********************************************************************
    HTTP2Channel
 *********************************************************************/

RPC_STATUS HTTP2Channel::Send (
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send request

Arguments:

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = BeginSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RpcStatus = LowerLayer->Send(SendContext);

    FinishSubmitAsync();

    if ((RpcStatus != RPC_S_OK) 
        && (RpcStatus != ERROR_IO_PENDING) 
        && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        {
        RemoveReference();  // remove the reference for the async send
        }

    return(RpcStatus);
}

RPC_STATUS HTTP2Channel::Receive (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Receive request

Arguments:

    TrafficType - the type of traffic we want to receive

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = BeginSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RpcStatus = LowerLayer->Receive(TrafficType);

    FinishSubmitAsync();

    if (RpcStatus != RPC_S_OK)
        RemoveReference();  // remove the reference for the async receive

    return(RpcStatus);
}

RPC_STATUS HTTP2Channel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - status of the operation
    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = CheckSendCompleteForSync(EventStatus,
        SendContext
        );

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        RpcStatus = ForwardUpSendComplete(EventStatus,
            SendContext
            );
        }

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification complete notification

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we have received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_CHANNEL, (ULONG_PTR)EventStatus);

    RpcStatus = CheckReceiveCompleteForSync(EventStatus,
        TrafficType,
        Buffer,
        BufferLength
        );

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        RpcStatus = ForwardUpReceiveComplete(EventStatus,
            Buffer,
            BufferLength
            );
        }

    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_RECV_COMPLETE, HTTP2LOG_OT_CHANNEL, (ULONG_PTR)RpcStatus);

    return RpcStatus;
}


RPC_STATUS HTTP2Channel::SyncSend (
    IN HTTP2TrafficType TrafficType,
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout,
    IN BASE_ASYNC_OBJECT *Connection,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Emulate a sync send using lower level async primitives

Arguments:

    TrafficType - the type of traffic

    BufferLength - the length of the buffer

    Buffer - the buffer to send

    fDisableCancelCheck - don't do checks for cancels. Can be
        used as optimization

    Timeout - the call timeout

    Connection - the transport connection object. Used for cancelling.

    SendContext - a memory block of sufficient size to initialize a send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;

    SendContext->u.SyncEvent = I_RpcTransGetThreadEvent();
    ResetEvent(SendContext->u.SyncEvent);
    SendContext->SetListEntryUnused();
    SendContext->maxWriteBuffer = BufferLength;
    SendContext->pWriteBuffer = Buffer;
    // SendContext->Write.pAsyncObject = NULL; // this will be initialized in the bottom layer
    SendContext->Write.ol.Internal = STATUS_PENDING;
    SendContext->TrafficType = http2ttData;
    SendContext->Write.ol.OffsetHigh = 0;
    SendContext->Flags = 0;
    SendContext->UserData = 0;

    RpcStatus = HTTP2Channel::Send(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::ForwardTraffic (
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    On receiving channels forwards to the sending channel.
    On sending channels sends down. This implementation
    is for a sending channel (since all sending channels
    are the same). Receiving channels must override it.

Arguments:

    Packet - the packet to forward

    PacketLength - the length of the packet

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeContextFromPacket(Packet,
        PacketLength
        );

    if (SendContext != NULL)
        {
        return Send(SendContext);
        }
    else
        return RPC_S_OUT_OF_MEMORY;
}

RPC_STATUS HTTP2Channel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack. Receiving channels don't 
        need this. Sending channels must override to forward
        to the right place.

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    // we should never be here
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2Channel::AsyncCompleteHelper (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Helper routine that helps complete an async operation

Arguments:
    
    CurrentStatus - the current status of the operation

Return Value:

    The status to return to the runtime.

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    ASSERT(CurrentStatus != RPC_S_CANNOT_SUPPORT);
    ASSERT(CurrentStatus != RPC_S_INTERNAL_ERROR);

    if (CurrentStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // recycle the parent connection
        VirtualConnection = LockParentPointer();
        if (VirtualConnection)
            {
            CurrentStatus = VirtualConnection->RecycleChannel(
                TRUE    // IsFromUpcall
                );
            UnlockParentPointer();
            }
        else
            {
            CurrentStatus = RPC_S_OK;
            }
        }
    else if ((CurrentStatus != RPC_S_OK)
        &&
        (CurrentStatus != RPC_P_PACKET_CONSUMED))
        {
        // if this failed, abort the whole connection
        AbortConnection(CurrentStatus);
        }

    RemoveReference();

    return CurrentStatus;
}

void HTTP2Channel::Abort (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Aborts the channel and all of the stack below it. The
    request must come from above or from neutral context -
    never from submit context from below. Otherwise we
    will deadlock when we drain the upcalls

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    BOOL Result;

    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CHANNEL, RpcStatus);

    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    Result = InitiateAbort();
    if (Result)
        {
        SetAbortReason(RpcStatus);
        // forward it down
        LowerLayer->Abort(RpcStatus);
        }
}

void HTTP2Channel::AbortConnection (
    IN RPC_STATUS AbortReason
    )
/*++

Routine Description:

    Aborts the virtual connection.

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    // abort the parent connection
    VirtualConnection = LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->AbortChannels(AbortReason);
        UnlockParentPointer();
        }
    else
        {
        // abort this channel at least
        Abort(AbortReason);
        }
}

void HTTP2Channel::AbortAndDestroyConnection (
    IN RPC_STATUS AbortStatus
    )
/*++

Routine Description:

    Aborts and destroys the virtual connection.

Arguments:
    
    AbortStatus - the status to abort the connection
        with.

Return Value:

Note: The method is idempotent

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    BOOL Result;

    // first, tell connection to destroy itself (almost entirely)
    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        {
        // abort ourselves at least
        Abort(AbortStatus);
        return;
        }

    Result = VirtualConnection->AbortAndDestroy(TRUE,   // IsFromChannel
        ChannelId, 
        AbortStatus);

    UnlockParentPointer();

    // if somebody is already destroying it, just return
    if (Result == FALSE)
        return;

    // because we have called AbortAndDestroy, we know the connection
    // will stay for us. Synchronize with upcalls from this channel
    DrainUpcallsAndFreeParent();

    // now VirtualConnection is a pointer disconnected from everybody
    // that we can destroy at our leisure
    delete VirtualConnection;
}

RPC_STATUS HTTP2Channel::CheckSendCompleteForSync (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification. Checks for sync operation,
    and if yes, completes the sync send anc consumes
    the packet.

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // was this a sync send?
    if (SendContext->u.SyncEvent)
        {
        // yes, consume it
        SendContext->Write.ol.Internal = (ULONG)EventStatus;
        SendContext->Write.ol.OffsetHigh = 1;
        SetEvent(SendContext->u.SyncEvent);
        return RPC_P_PACKET_CONSUMED;
        }

    return RPC_S_OK;
}

RPC_STATUS HTTP2Channel::ForwardUpSendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification. Forwards the send complete to the 
    virtual connection.

Arguments:

    EventStatus - status of the operation

    SendContext - the send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;
    BOOL IsRTSPacket;

    VirtualConnection = LockParentPointer();
    // if parent has already detached, just return back
    if (VirtualConnection == NULL)
        {
        // in some cases the parent will detach without aborting
        if (EventStatus == RPC_S_OK)
            {
            if (SendContext->TrafficType == http2ttRTS)
                RpcStatus = RPC_P_PACKET_CONSUMED;
            else
                RpcStatus = EventStatus;    // already ok
            }
        else
            {
            // Abort in these cases (Abort is idempotent)
            Abort(EventStatus);
            RpcStatus = EventStatus;
            }
        IsRTSPacket = (SendContext->TrafficType == http2ttRTS);
        FreeSendContextAndPossiblyData(SendContext);
        if (IsRTSPacket)
            return RPC_P_PACKET_CONSUMED;
        else
            return RpcStatus;
        }

    RpcStatus = VirtualConnection->SendComplete(EventStatus,
        SendContext,
        ChannelId
        );

    UnlockParentPointer();

    return RpcStatus;
}


RPC_STATUS HTTP2Channel::CheckReceiveCompleteForSync (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification. Checks if the receive was
    sync, and if yes, fires event and consumes the packet. For
    base class it's always not for us (base class does not
    support sync receives)

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // not for us after all. Let it continue
    return RPC_S_OK;
}

RPC_STATUS HTTP2Channel::ForwardUpReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification. Forwards the receive
    complete to the virtual connection

Arguments:

    EventStatus - status of the operation

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    VirtualConnection = LockParentPointer();
    // if parent has already detached, just return back
    if (VirtualConnection == NULL)
        {
        // in some cases the parent will detach without aborting
        // Abort in these cases (Abort is idempotent)
        Abort(RPC_P_CONNECTION_SHUTDOWN);
        return RPC_P_PACKET_CONSUMED;
        }

    RpcStatus = VirtualConnection->ReceiveComplete(EventStatus,
        Buffer,
        BufferLength,
        ChannelId
        );

    UnlockParentPointer();

    if (RpcStatus == RPC_P_ABORT_NEEDED)
        {
        // in some cases the parent cannot abort because the channel
        // is already detached from the parent. In such cases it will
        // tell us to abort. (Abort is idempotent)
        Abort(RPC_P_CONNECTION_SHUTDOWN);
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    // many channels don't support this and
    // shouldn't be called with it. Those who do support it
    // should override it.

    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2Channel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support past packet notifications

Arguments:

    LastSendContext - the context we're sending

Return Value:

    The value to return to the bottom channel/runtime.

--*/
{
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2Channel::SendCancelled (
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    A lower channel cancelled a send already passed through this channel.

Arguments:

    SendContext - the send context of the send that was cancelled

Return Value:

--*/
{
    RemoveReference();
}

void HTTP2Channel::PingTrafficSentNotify (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Notifies a channel that ping traffic has been sent.

Arguments:

    PingTrafficSize - the size of the ping traffic sent.

--*/
{
    // nobody should be here. Channels that use that must
    // override.
    ASSERT(0);
}

void HTTP2Channel::FreeObject (
        void
        )
/*++

Routine Description:

    Frees a client in channel object

Arguments:

Return Value:

--*/
{
    // make sure we have been aborted
    ASSERT(Aborted.GetInteger() > 0);

    LowerLayer->FreeObject();

    // the client channel is the top of the stack. Just free us
    // which will free the whole stack
    delete this;
}

RPC_STATUS HTTP2Channel::ForwardFlowControlAckOnDefaultChannel (
    IN BOOL IsInChannel,
    IN ForwardDestinations Destination,
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack on the default channel

Arguments:

    IsInChannel - non-zero if the IN channel is to be used. FALSE
        otherwise

    Destination - where to forward to.

    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

Notes:

    If on an endpoint, called from a neutral context only. Proxies
    call it in submission context.

--*/
{
    HTTP2VirtualConnection *VirtualConnection;
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;

    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        return RPC_P_CONNECTION_SHUTDOWN;

    // allocate and initalize the flow control ACK packet
    SendContext = AllocateAndInitializeFlowControlAckPacketWithDestination (
        Destination,
        BytesReceivedForAck,
        WindowForAck,
        VirtualConnection->MapChannelIdToCookie(ChannelId)
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = VirtualConnection->SendTrafficOnDefaultChannel(IsInChannel,
        SendContext
        );

    UnlockParentPointer();

    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::ForwardFlowControlAckOnThisChannel (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck,
    IN BOOL NonChannelData
    )
/*++

Routine Description:

    Forwards a flow control ack on this channel

Arguments:

    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

    NonChannelData - non-zero if the data being sent don't go on the HTTP
    channel. FALSE if they do

Return Value:

    RPC_S_OK or RPC_S_*

Notes: 

    This must be called in upcall or neutral context only

--*/
{
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;
    HTTP2VirtualConnection *VirtualConnection;

    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        return RPC_P_CONNECTION_SHUTDOWN;

    // allocate and initalize the flow control ACK packet
    SendContext = AllocateAndInitializeFlowControlAckPacket (
        BytesReceivedForAck,
        WindowForAck,
        VirtualConnection->MapChannelIdToCookie(ChannelId)
        );

    UnlockParentPointer();

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (NonChannelData)
        SendContext->Flags |= SendContextFlagNonChannelData;

    RpcStatus = Send(SendContext);

    // this can be called on the server, or on the proxy. If on the server,
    // it will be called with NonChannelData. This means we cannot have
    // channel recycle indication here.
    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    if (RpcStatus != RPC_S_OK)
        {
        FreeRTSPacket(SendContext);
        }

    return RpcStatus;
}

RPC_STATUS HTTP2Channel::HandleSendResultFromNeutralContext (
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Handles the result code from send from a neutral context.
    This includes checking for channel recycling and intiating
    one if necessary.

Arguments:

    CurrentStatus - the status from the send operation

Return Value:

    RPC_S_OK or RPC_S_*. Callers may ignore it since all cleanup was
    done.

Notes: 

    This must be called in upcall or neutral context only

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2VirtualConnection *VirtualConnection;

    ASSERT(CurrentStatus != RPC_S_CANNOT_SUPPORT);
    ASSERT(CurrentStatus != RPC_S_INTERNAL_ERROR);

    if (CurrentStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // recycle the parent connection
        VirtualConnection = LockParentPointer();
        if (VirtualConnection)
            {
            RpcStatus = VirtualConnection->RecycleChannel(
                TRUE    // IsFromUpcall
                );
            UnlockParentPointer();

            if (RpcStatus != RPC_S_OK)
                {
                // if this failed, abort the whole connection
                AbortConnection(CurrentStatus);
                }

            CurrentStatus = RpcStatus;
            }
        else
            {
            // nothing to do - the channel is dying anyway
            CurrentStatus = RPC_P_CONNECTION_SHUTDOWN;
            }
        }

    return CurrentStatus;
}

RPC_STATUS HTTP2Channel::IsInChannel (
    OUT BOOL *InChannel
    )
/*++

Routine Description:

    Checks if the current channel is an in channel or an
    out channel.

Arguments:

    InChannel - on output will be set to non-zero if this is an
    in channel. It will be set to 0 if this is an out channel.
    Undefined on failure.

Return Value:

    RPC_S_OK or RPC_P_CONNECTION_SHUTDOWN. If the parent has detached, 
    RPC_P_CONNECTION_SHUTDOWN will be returned. In all other cases 
    success is returned.

--*/
{
    HTTP2VirtualConnection *VirtualConnection;

    VirtualConnection = LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->VerifyValidChannelId(ChannelId);
        *InChannel = VirtualConnection->IsInChannel(ChannelId);
        UnlockParentPointer();
        return RPC_S_OK;
        }
    else
        return RPC_P_CONNECTION_SHUTDOWN;
}

/*********************************************************************
    HTTP2VirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2VirtualConnection::Send (
    IN UINT Length,
    IN BUFFER Buffer,
    IN PVOID SendContext
    )
/*++

Routine Description:

    Send on an HTTP client virtual connection. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer of at least SendContextSize bytes
        which will be used during the call and returned
        when the send completes.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

Note:

    Can be called from runtime/neutral context only.

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2Channel *Channel;
    HTTP2SendContext *HttpSendContext;
    RPC_STATUS RpcStatus;

    HttpSendContext = (HTTP2SendContext *)SendContext;
    HttpSendContext->SetListEntryUnused();
    HttpSendContext->maxWriteBuffer = Length;
    HttpSendContext->pWriteBuffer = Buffer;
    HttpSendContext->TrafficType = http2ttData;
    HttpSendContext->u.SyncEvent = NULL;
    HttpSendContext->Flags = 0;
    HttpSendContext->UserData = 0;

    Channel = LockDefaultSendChannel(&ChannelPtr);
    if (Channel)
        {
        RpcStatus = Channel->Send(HttpSendContext);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_SEND_FAILED;
        }

    RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
        FALSE       // IsFromUpcall
        );

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        if (RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
            RpcStatus = RPC_P_SEND_FAILED;
        }

    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::Receive (
    void
    )
/*++

Routine Description:

    Post a receive on a HTTP client virtual connection.

Arguments:

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = LockDefaultReceiveChannel(&ChannelPtr);
    if (Channel)
        {
        RpcStatus = Channel->Receive(http2ttData);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::SyncSend (
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Do a sync send on an HTTP connection.

Arguments:

    BufferLength - the length of the data to send.

    Buffer - the data to send.

    fDisableShutdownCheck - ignored

    fDisableCancelCheck - runtime indicates no cancel
        will be attempted on this send. Can be used
        as optimization hint by the transport

    Timeout - send timeout (call timeout)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    HTTP2SendContext LocalSendContext;
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;

    // we will convert a sync send to an async send
    // make sure there is a thread to pick up the completion
    RpcStatus = HTTPTransInfo->CreateThread();
    if (RpcStatus != RPC_S_OK)
        {
        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_SEND_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_COMPLETE,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        return RpcStatus;
        }

    Channel = LockDefaultSendChannel (&ChannelPtr);
    if (Channel == NULL)
        {
        return RPC_P_SEND_FAILED;
        }

    RpcStatus = Channel->SyncSend(http2ttData,
        BufferLength,
        Buffer,
        fDisableCancelCheck,
        Timeout,
        this,
        &LocalSendContext
        );

    ChannelPtr->UnlockChannelPointer();

    if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // get the ball rolling with the recycle
        RpcStatus = RecycleChannel(
            FALSE    // IsFromUpcall
            );

        // ok or not, we have to wait for IO to complete
        RpcStatus2 = WaitForSyncSend(this,
            &LocalSendContext,
            this,
            fDisableCancelCheck,
            Timeout
            );

        if ((RpcStatus2 == RPC_S_OK) && (RpcStatus != RPC_S_OK))
            RpcStatus2 = RpcStatus;

        if ((RpcStatus2 == RPC_P_CONNECTION_SHUTDOWN)
            || (RpcStatus2 == RPC_P_RECEIVE_FAILED)
            || (RpcStatus2 == RPC_P_CONNECTION_CLOSED) )
            RpcStatus2 = RPC_P_SEND_FAILED;

        VALIDATE(RpcStatus2)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_SEND_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_COMPLETE,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        return RpcStatus2;
        }
    else
        {
        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = WaitForSyncSend(this,
                &LocalSendContext,
                this,
                fDisableCancelCheck,
                Timeout
                );
            }

        if (RpcStatus != RPC_S_OK)
            {
            if ((RpcStatus == RPC_P_RECEIVE_FAILED)
                || (RpcStatus == RPC_P_CONNECTION_CLOSED)
                || (RpcStatus == RPC_P_CONNECTION_SHUTDOWN) )
                RpcStatus = RPC_P_SEND_FAILED;
            }

        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_SEND_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_COMPLETE,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        return RpcStatus;
        }
}

RPC_STATUS HTTP2VirtualConnection::SyncRecv (
    IN BYTE **Buffer,
    IN ULONG *BufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Do a sync receive on an HTTP connection.

Arguments:

    Buffer - if successful, points to a buffer containing the next PDU.
    BufferLength -  if successful, contains the length of the message.
    Timeout - the amount of time to wait for the receive. If -1, we wait
        infinitely.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    // nobody should be calling SyncRecv on the base connection
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2VirtualConnection::Close (
    IN BOOL DontFlush
    )
/*++

Routine Description:

    Closes an HTTP connection. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

--*/
{
    Abort();
}

RPC_STATUS HTTP2VirtualConnection::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN BOOL IsFromUpcall,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for HTTP. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    IsFromUpcall - non-zero if called from upcall context. Zero otherwise.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we use it on the server, we must protect
        the connection against async aborts.

--*/
{
    // The server doesn't support this for Whistler. Think
    // about it for Longhorn. Client overrides it.
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryClientAddress (
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryLocalAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(FALSE);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::QueryClientId(
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is supposed to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

void HTTP2VirtualConnection::AbortChannels (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Aborts an HTTP connection but does not disconnect
    the channels. Can be called from above, upcall, or
    neutral context, but not from submit context!

Arguments:

    RpcStatus - the error to abort the channels with

Return Value:

--*/
{
    HTTP2ChannelPointer *Channels[4];
    HTTP2Channel *CurrentChannel;
    int i;

    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    // quick optimization. Don't abort already aborted channels
    // All channels are protected against double abortion - this
    // is just an optimization
    if (Aborted.GetInteger() > 0)
        return;

    Channels[0] = &InChannels[0];
    Channels[1] = &InChannels[1];
    Channels[2] = &OutChannels[0];
    Channels[3] = &OutChannels[1];

    for (i = 0; i < 4; i ++)
        {
        CurrentChannel = Channels[i]->LockChannelPointer();
        if (CurrentChannel)
            {
            CurrentChannel->Abort(RpcStatus);
            Channels[i]->UnlockChannelPointer();
            }
        }
}

BOOL HTTP2VirtualConnection::AbortAndDestroy (
    IN BOOL IsFromChannel,
    IN int CallingChannelId,
    IN RPC_STATUS AbortStatus
    )
/*++

Routine Description:

    Aborts and destroys a connection. This is safe to
    call from an upcall, as long as the calling channel
    passes in its channel id. Actually the destruction
    does not happen here. The caller has the obligation
    to destroy it after synchronizing its upcalls.

Arguments:

    IsFromChannel - non-zero if the call comes from a channel.
        Zero otherwise.

    CallingChannelId - the id of the calling channel. If IsFromChannel
        is FALSE, this argument should be ignored.

    AbortStatus - the error to abort the connection with.

Return Value:

    non-zero - caller may destroy the connection.
    FALSE - destruction is already in progress. Caller
        must not destroy the connection.

--*/
{
    if (IsFromChannel)
        {
        VerifyValidChannelId(CallingChannelId);
        }

    // abort the channels themselves
    AbortChannels(AbortStatus);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return FALSE;

    DisconnectChannels(IsFromChannel, CallingChannelId);

    // we have disconnected all but the channel on which we received
    // this call.
    return TRUE;
}

void HTTP2VirtualConnection::LastPacketSentNotification (
    IN int ChannelId,
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a channel wants to notify the virtual connection
    that the last packet has been sent, they call this function. 
    Must be called from an upcall/neutral context. Only flow control
    senders generated past packet notifications

Arguments:

    ChannelId - the channelfor which this notification is.

    LastSendContext - the send context for the last send

Return Value:

--*/
{
    ASSERT(0);
}

RPC_STATUS HTTP2VirtualConnection::PostReceiveOnChannel (
    IN HTTP2ChannelPointer *ChannelPtr,
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Posts a receceive on specified channel

Arguments:

    ChannelPtr - the channel pointer to post the receive on

    TrafficType - the type of traffic we wish to receive

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = ChannelPtr->LockChannelPointer();
    if (Channel)
        {
        RpcStatus = Channel->Receive(TrafficType);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        RpcStatus = RPC_P_CONNECTION_CLOSED;

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::PostReceiveOnDefaultChannel (
    IN BOOL IsInChannel,
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Posts a receceive on the default channel for the specified type

Arguments:

    IsInChannel - if non-zero, post a receive on default in channel.
        If 0, post a receive on default out channel

    TrafficType - the type of traffic we wish to receive

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    if (IsInChannel)
        Channel = LockDefaultInChannel(&ChannelPtr);
    else
        Channel = LockDefaultOutChannel(&ChannelPtr);

    if (Channel)
        {
        RpcStatus = Channel->Receive(TrafficType);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        RpcStatus = RPC_P_CONNECTION_CLOSED;

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::ForwardTrafficToChannel (
    IN HTTP2ChannelPointer *ChannelPtr,
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Forwards the given packet on the given channel

Arguments:

    ChannelPtr - the channel pointer

    Packet - the packet to forward

    PacketLength - the length of the packet to forward

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = ChannelPtr->LockChannelPointer();
    if (Channel)
        {
        RpcStatus = Channel->ForwardTraffic(Packet, PacketLength);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::ForwardTrafficToDefaultChannel (
    IN BOOL IsInChannel,
    IN BYTE *Packet,
    IN ULONG PacketLength
    )
/*++

Routine Description:

    Forwards the given packet on the given channel

Arguments:

    IsInChannel - if non-zero, forward to default in channel.
        If 0, forward to default out channel

    Packet - the packet to forward

    PacketLength - the length of the packet to forward

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    if (IsInChannel)
        Channel = LockDefaultInChannel(&ChannelPtr);
    else
        Channel = LockDefaultOutChannel(&ChannelPtr);

    if (Channel)
        {
        RpcStatus = Channel->ForwardTraffic(Packet, PacketLength);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::SendTrafficOnChannel (
    IN HTTP2ChannelPointer *ChannelPtr,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Sends the given packet on the given channel

Arguments:

    ChannelPtr - the channel pointer on which to send.

    SendContext - context to send

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    RPC_STATUS RpcStatus;

    Channel = ChannelPtr->LockChannelPointer();

    if (Channel)
        {
        RpcStatus = Channel->Send(SendContext);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::SendTrafficOnDefaultChannel (
    IN BOOL IsInChannel,
    IN HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Sends the given packet on the given channel

Arguments:

    IsInChannel - if non-zero, send on default in channel.
        If 0, send on default out channel

    SendContext - context to send

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HTTP2Channel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    if (IsInChannel)
        Channel = LockDefaultInChannel(&ChannelPtr);
    else
        Channel = LockDefaultOutChannel(&ChannelPtr);

    if (Channel)
        {
        RpcStatus = Channel->Send(SendContext);
        ChannelPtr->UnlockChannelPointer();
        }
    else
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        }

    return RpcStatus;
}

RPC_STATUS HTTP2VirtualConnection::RecycleChannel (
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Initiates channel recycling. Each endpoint supports
    initiating recycling of only one channel, so it knows
    which one it is.
    Endpoints override that. On proxies it shouldn't be called
    at all.

Arguments:

    IsFromUpcall - non-zero if it comes from upcall. Zero otherwise.

Return Value:

    RPC_S_OK of the recycling operation started successfully.
    RPC_S_* error for errors.

--*/
{
    ASSERT(0);
    return RPC_S_INTERNAL_ERROR;
}

RPC_STATUS HTTP2VirtualConnection::StartChannelRecyclingIfNecessary (
    IN RPC_STATUS RpcStatus,
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Checks the result of the send for channel recycle indication, and if one
    is present, initiate channel recycle

Arguments:

    RpcStatus - the return code from the Send operation.

    IsFromUpcall - non-zero if this was called from an upcall. Zero otherwise.

Return Value:

    RPC_S_* errors - the channel recycling failed to start.
    any success code will be the passed in success code turned around.
    If this function starts with a failure, the failure will be turned around

Notes:

    May be called in an upcall or runtime context only.

--*/
{
    if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        RpcStatus = RecycleChannel(IsFromUpcall);

    return RpcStatus;
}

HTTP2Channel *HTTP2VirtualConnection::MapCookieToChannelPointer (
    IN HTTP2Cookie *ChannelCookie,
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Maps a channel cookie to a channel pointer. A channel will be selected only if
    it is the default channel as well. The returned channel is locked.

Arguments:

    ChannelCookie - the cookie for the channel.

    ChannelPtr - the channel pointer. On NULL return value this is undefined.

Return Value:

    The channel if the channel was found or NULL
    if the channel was not found. During some recycling scenarios
    the channel may not be there, or the returning channel pointer
    may have a detached channel

--*/
{
    volatile int *DefaultChannelSelector;
    int TargetChannelSelector;
    HTTP2ChannelPointer *LocalChannelPtr;
    HTTP2Channel *Channel;

    if (InChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[0];
        DefaultChannelSelector = &DefaultInChannelSelector;
        TargetChannelSelector = 0;
        }
    else if (InChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[1];
        DefaultChannelSelector = &DefaultInChannelSelector;
        TargetChannelSelector = 1;
        }
    else if (OutChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[0];
        DefaultChannelSelector = &DefaultOutChannelSelector;
        TargetChannelSelector = 0;
        }
    else if (OutChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[1];
        DefaultChannelSelector = &DefaultOutChannelSelector;
        TargetChannelSelector = 1;
        }
    else 
        return NULL;

    Channel = LocalChannelPtr->LockChannelPointer();
    if (Channel)
        {
        if (*DefaultChannelSelector == TargetChannelSelector)
            {
            // if we locked the channel and it is the right channel,
            // use it
            *ChannelPtr = LocalChannelPtr;
            return Channel;
            }
        LocalChannelPtr->UnlockChannelPointer();
        }

    return NULL;
}

HTTP2Channel *HTTP2VirtualConnection::MapCookieToAnyChannelPointer (
    IN HTTP2Cookie *ChannelCookie,
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Maps a channel cookie to a channel pointer. Unlike MapCookieToChannelPointer,
    channel will be selected regardless of whether it is default.The returned 
    channel is locked.

Arguments:

    ChannelCookie - the cookie for the channel.

    ChannelPtr - the channel pointer. On NULL return value this is undefined.

Return Value:

    The channel if the channel was found or NULL
    if the channel was not found. During some recycling scenarios
    the channel may not be there, or the returning channel pointer
    may have a detached channel

--*/
{
    HTTP2ChannelPointer *LocalChannelPtr;
    HTTP2Channel *Channel;

    if (InChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[0];
        }
    else if (InChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &InChannels[1];
        }
    else if (OutChannelCookies[0].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[0];
        }
    else if (OutChannelCookies[1].Compare(ChannelCookie) == 0)
        {
        LocalChannelPtr = &OutChannels[1];
        }
    else 
        return NULL;

    Channel = LocalChannelPtr->LockChannelPointer();
    if (Channel)
        {
        // if we locked the channel and it is the right channel,
        // use it
        *ChannelPtr = LocalChannelPtr;
        return Channel;
        }

    return NULL;
}

HTTP2Channel *HTTP2VirtualConnection::LockDefaultSendChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the send channel. Most connections don't override that.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultOutChannel)

--*/
{
    return LockDefaultOutChannel(ChannelPtr);
}

HTTP2Channel *HTTP2VirtualConnection::LockDefaultReceiveChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the receive channel. Most connections don't override that.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultInChannel)

--*/
{
    return LockDefaultInChannel(ChannelPtr);
}

void HTTP2VirtualConnection::SetFirstInChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the passed in channel as first default in channel.
    Typically used during building a stack.

Arguments:

    NewChannel - new in channel.

Return Value:

--*/
{
    int InChannelId;

    InChannelId = AllocateChannelId();

    DefaultInChannelSelector = 0;
    NewChannel->SetChannelId(InChannelId);
    InChannels[0].SetChannel(NewChannel);
    InChannelIds[0] = InChannelId;
}

void HTTP2VirtualConnection::SetFirstOutChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the passed in channel as first default out channel.
    Typically used during building a stack.

Arguments:

    NewChannel - new out channel.

Return Value:

--*/
{
    int OutChannelId;

    OutChannelId = AllocateChannelId();

    DefaultOutChannelSelector = 0;
    NewChannel->SetChannelId(OutChannelId);
    OutChannels[0].SetChannel(NewChannel);
    OutChannelIds[0] = OutChannelId;
}

void HTTP2VirtualConnection::SetNonDefaultInChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the non default in channel. Used during channel
    recycling. Note that this MUST be called by the code
    that received RPC_P_CHANNEL_NEEDS_RECYCLING, because
    it is not thread safe.

Arguments:

    NewChannel - new in channel.

Return Value:

--*/
{
    int InChannelId;
    int NonDefaultInChannelSelector;

    InChannelId = AllocateChannelId();
    NonDefaultInChannelSelector = GetNonDefaultInChannelSelector();

    NewChannel->SetChannelId(InChannelId);
    InChannels[NonDefaultInChannelSelector].SetChannel(NewChannel);
    InChannelIds[NonDefaultInChannelSelector] = InChannelId;
}

void HTTP2VirtualConnection::SetNonDefaultOutChannel (
    IN HTTP2Channel *NewChannel
    )
/*++

Routine Description:

    Sets the non default out channel. Used during channel
    recycling. Note that this MUST be called by the code
    that received RPC_P_CHANNEL_NEEDS_RECYCLING, because
    it is not thread safe.

Arguments:

    NewChannel - new out channel.

Return Value:

--*/
{
    int OutChannelId;
    int NonDefaultOutChannelSelector;

    OutChannelId = AllocateChannelId();
    NonDefaultOutChannelSelector = GetNonDefaultOutChannelSelector();

    NewChannel->SetChannelId(OutChannelId);
    OutChannels[NonDefaultOutChannelSelector].SetChannel(NewChannel);
    OutChannelIds[NonDefaultOutChannelSelector] = OutChannelId;
}

void HTTP2VirtualConnection::DisconnectChannels (
    IN BOOL ExemptChannel,
    IN int ExemptChannelId
    )
/*++

Routine Description:

    Disconnects all channels. Must be called from runtime
    or neutral context. Cannot be called from upcall or
    submit context unless an exempt channel is given
    Note that call must synchronize to ensure we're the only
    thread doing the disconnect

Arguments:

    ExemptChannel - non-zero if ExemptChannelId contains a
        valid exempt channel id. FALSE otherwise.

    ExemptChannelId - if ExemptChannel is non-zero, this argument
        is the id of a channel that will be disconnected, but not
        synchronized with up calls.
        If ExampleChannel is FALSE, this argument is undefined

Return Value:

--*/
{
    HTTP2ChannelPointer *Channels[4];
    int ChannelIds[4];
    HTTP2Channel *CurrentChannel;
    int i;

    // we should be the only thread aborting - just disconnect everybody
    Channels[0] = &InChannels[0];
    ChannelIds[0] = InChannelIds[0];

    Channels[1] = &InChannels[1];
    ChannelIds[1] = InChannelIds[1];

    Channels[2] = &OutChannels[0];
    ChannelIds[2] = OutChannelIds[0];

    Channels[3] = &OutChannels[1];
    ChannelIds[3] = OutChannelIds[1];

    for (i = 0; i < 4; i ++)
        {
        if ((ExemptChannel == FALSE)
            || ((ExemptChannel != FALSE) && (ExemptChannelId != ChannelIds[i])))
            {
            // disconnect the channel
            Channels[i]->FreeChannelPointer(TRUE,
                FALSE,  // CalledFromUpcallContext
                FALSE,  // Abort
                RPC_S_OK
                );
            }
        else
            {
            Channels[i]->FreeChannelPointer(FALSE,
                FALSE,  // CalledFromUpcallContext
                FALSE,  // Abort
                RPC_S_OK
                );
            }
        }

}


/*********************************************************************
    HTTP2ClientChannel
 *********************************************************************/

const char *HeaderFragment1 = " http://";
const int HeaderFragment1Length = 8;    // length of " http://"
const char *HeaderFragment2 = "/rpc/rpcproxy.dll?";
const int HeaderFragment2Length = 18;    // length of /rpc/rpcproxy.dll?
const RPC_CHAR *HeaderFragment2W = L"/rpc/rpcproxy.dll?";
const int HeaderFragment2WLength = 36;    // length of wide /rpc/rpcproxy.dll?
const char *HeaderFragment3 = ":";
const int HeaderFragment3Length = 1;     // length of :
const RPC_CHAR *HeaderFragment3W = L":";
const int HeaderFragment3WLength = 2;     // length of wide :
const char *HeaderFragment4 = " HTTP/1.1\r\nAccept:application/rpc\r\nUser-Agent:MSRPC\r\nHost:";
const int HeaderFragment4Length = 58;    // length of " HTTP/1.1\r\nAccept:application/rpc\r\nUser-Agent:MSRPC\r\nHost:"
const char *HeaderFragment5 = "\r\nContent-Length:";
const int HeaderFragment5Length = 17;    // "\r\nlength of Content-Length:"
const char *HeaderFragment6 = "\r\nConnection: Keep-Alive\r\nCache-control:no-cache\r\nPragma:no-cache\r\n\r\n";
const int HeaderFragment6Length = 69;    // length of \r\nConnection: Keep-Alive\r\nCache-control:no-cache\r\nPragma:no-cache\r\n\r\n

const RPC_CHAR *HeaderAcceptType = L"application/rpc";

RPC_STATUS HTTP2ClientChannel::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN const char *Verb,
    IN int VerbLength,
    IN BOOL InChannel,
    IN BOOL ReplacementChannel,
    IN BOOL UseWinHttp,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,   OPTIONAL
    IN ULONG ChosenAuthScheme,      OPTIONAL
    IN HTTP2WinHttpTransportChannel *WinHttpChannel, OPTIONAL
    IN ULONG CallTimeout,
    IN const BYTE *AdditionalData, OPTIONAL
    IN ULONG AdditionalDataLength OPTIONAL
    )
/*++

Routine Description:

    Sends the HTTP establishment header on 
    the in/out channel.

Arguments:

    Hint - the resolver hint

    Verb - the verb to use.

    VerbLength - the length of the verb (in characters, not including
        null terminator).

    InChannel - non-zero if this is an in channel open. In such case we use 
        the channel lifetime as the content length. If 0, this is an out 
        channel and we use the real content length + some additional space.
        The additional space depends on the ReplacementChannel parameter

    ReplacementChannel - non-zero if this is a replacement channel. Zero 
        otherwise. If it is a replacement channel, we add the size of D4/A3.
        Else, we use the size of D1/A1. This is valid only for out channels

    UseWinHttp - non-zero if we should use WinHttp for bottom level communications

    HttpCredentials - the encrypted Http Credentials to use. Ignored unless UseWinHttp
        is non-zero.

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    WinHttpChannel - the winhttp channel to use for opening. Ignored unless UseWinHttp
        is non-zero.

    CallTimeout - the call timeout for this call.

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

    AdditionalDataLength - the length of the additional data to send with the header.
        Must be set iff AdditionalLength != NULL

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ULONG MemorySize;
    char *Buffer;
    RPC_CHAR *BufferW;
    RPC_CHAR *OriginalBufferW;
    RPC_CHAR *VerbW;
    char *Header;
    char ServerPortString[6];
    ULONG ServerPortStringLength;
    HTTP2SendContext *SendContext;
    RPC_STATUS RpcStatus;
    char ContentLengthString[6];
    ULONG AdditionalLength;
    ULONG ContentLengthStringLength;     // without terminating NULL
    char *ContentLengthToUse;

    // we have plenty of parameters. Verify them
    // We can't have chosen auth scheme without credentials
    // or WinHttpChannel
    if (ChosenAuthScheme)
        {
        ASSERT(HttpCredentials);
        ASSERT(WinHttpChannel);
        }

    // we can't have additional data without data and vice versa
    if (AdditionalData)
        {
        ASSERT(AdditionalDataLength);
        }
    else
        {
        ASSERT(AdditionalDataLength == 0);
        }

    PortNumberToEndpointA(Hint->ServerPort, ServerPortString);
    ServerPortStringLength = RpcpStringLengthA(ServerPortString);

    // determine the content length
    if (AdditionalData)
        {
        AdditionalLength = AdditionalDataLength;
        if (!UseWinHttp)
            {
            RpcpItoa(AdditionalLength, ContentLengthString, 10);
            ContentLengthStringLength = RpcpStringLengthA(ContentLengthString);
            ContentLengthToUse = ContentLengthString;
            }
        }
    else
        {
        if (InChannel == FALSE)
            {
            if (ReplacementChannel)
                AdditionalLength = GetD4_A3TotalLength() + GetD4_A11TotalLength();
            else
                AdditionalLength = GetD1_A1TotalLength();
            if (!UseWinHttp)
                {
                RpcpItoa(AdditionalLength, ContentLengthString, 10);
                ContentLengthStringLength = RpcpStringLengthA(ContentLengthString);
                ContentLengthToUse = ContentLengthString;
                }
            }
        else
            {
            if (UseWinHttp)
                {
                AdditionalLength = DefaultChannelLifetime;
                }
            else
                {
                ContentLengthStringLength = DefaultChannelLifetimeStringLength;
                ContentLengthToUse = DefaultChannelLifetimeString;
                }
            }
        }

    if (UseWinHttp)
        {
        ASSERT(WinHttpChannel != NULL);

        VerbW = new RPC_CHAR[VerbLength + 1];
        if (VerbW == NULL)
            return RPC_S_OUT_OF_MEMORY;

        FullAnsiToUnicode((char *)Verb, VerbW);

        MemorySize = HeaderFragment2Length
            + Hint->ServerNameLength
            + HeaderFragment3Length
            + ServerPortStringLength
            + 1
            ;

        BufferW = (RPC_CHAR *)RpcAllocateBuffer(MemorySize * sizeof(RPC_CHAR));
        if (BufferW == NULL)
            {
            delete [] VerbW;
            return RPC_S_OUT_OF_MEMORY;
            }

        OriginalBufferW = BufferW;

        RpcpMemoryCopy(BufferW, HeaderFragment2W, HeaderFragment2WLength);
        BufferW += HeaderFragment2Length;

        FullAnsiToUnicode(Hint->RpcServer, BufferW);
        BufferW += Hint->ServerNameLength;

        RpcpMemoryCopy(BufferW, HeaderFragment3W, HeaderFragment3WLength);
        BufferW += HeaderFragment3Length;

        FullAnsiToUnicode(ServerPortString, BufferW);

        RpcStatus = WinHttpChannel->Open (Hint,
            VerbW,
            OriginalBufferW,    // Url
            HeaderAcceptType,
            AdditionalLength,
            CallTimeout,
            HttpCredentials,
            ChosenAuthScheme,
            AdditionalData
            );

        delete [] VerbW;
        RpcFreeBuffer(OriginalBufferW);
        }
    else
        {
        MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2SendContext)
            + VerbLength
            + HeaderFragment1Length
            + Hint->ProxyNameLength
            + HeaderFragment2Length
            + Hint->ServerNameLength
            + HeaderFragment3Length
            + ServerPortStringLength
            + HeaderFragment4Length
            + Hint->ProxyNameLength
            + HeaderFragment5Length
            + ContentLengthStringLength
            + HeaderFragment6Length
            ;

        if (AdditionalDataLength)
            MemorySize += AdditionalDataLength;

        Buffer = (char *)RpcAllocateBuffer(MemorySize);
        if (Buffer == NULL)
            return RPC_S_OUT_OF_MEMORY;

        SendContext = (HTTP2SendContext *)Buffer;
        Buffer += SIZE_OF_OBJECT_AND_PADDING(HTTP2SendContext);
        Header = Buffer;

        RpcpMemoryCopy(Buffer, Verb, VerbLength);
        Buffer += VerbLength;

        RpcpMemoryCopy(Buffer, HeaderFragment1, HeaderFragment1Length);
        Buffer += HeaderFragment1Length;

        RpcpMemoryCopy(Buffer, Hint->RpcProxy, Hint->ProxyNameLength);
        Buffer += Hint->ProxyNameLength;

        RpcpMemoryCopy(Buffer, HeaderFragment2, HeaderFragment2Length);
        Buffer += HeaderFragment2Length;

        RpcpMemoryCopy(Buffer, Hint->RpcServer, Hint->ServerNameLength);
        Buffer += Hint->ServerNameLength;

        RpcpMemoryCopy(Buffer, HeaderFragment3, HeaderFragment3Length);
        Buffer += HeaderFragment3Length;

        RpcpMemoryCopy(Buffer, ServerPortString, ServerPortStringLength);
        Buffer += ServerPortStringLength;

        RpcpMemoryCopy(Buffer, HeaderFragment4, HeaderFragment4Length);
        Buffer += HeaderFragment4Length;

        RpcpMemoryCopy(Buffer, Hint->RpcProxy, Hint->ProxyNameLength);
        Buffer += Hint->ProxyNameLength;

        RpcpMemoryCopy(Buffer, HeaderFragment5, HeaderFragment5Length);
        Buffer += HeaderFragment5Length;

        RpcpMemoryCopy(Buffer, ContentLengthToUse, ContentLengthStringLength);
        Buffer += ContentLengthStringLength;

        RpcpMemoryCopy(Buffer, HeaderFragment6, HeaderFragment6Length);

        if (AdditionalDataLength)
            {
            Buffer += HeaderFragment6Length;
            RpcpMemoryCopy(Buffer, AdditionalData, AdditionalDataLength);
            }

#if DBG
        SendContext->ListEntryUsed = FALSE;
#endif
        SendContext->maxWriteBuffer = MemorySize - SIZE_OF_OBJECT_AND_PADDING(HTTP2SendContext);
        SendContext->pWriteBuffer = (BUFFER)Header;
        SendContext->u.SyncEvent = NULL;
        SendContext->TrafficType = http2ttRaw;
        SendContext->Flags = 0;
        SendContext->UserData = 0;

        RpcStatus = BeginSubmitAsync();
        if (RpcStatus != RPC_S_OK)
            {
            RpcFreeBuffer(SendContext);
            return RpcStatus;
            }

        RpcStatus = LowerLayer->Send(SendContext);
    
        FinishSubmitAsync();

        if (RpcStatus != RPC_S_OK)
            {
            RpcFreeBuffer(SendContext);
            RemoveReference();
            }
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send

    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2VirtualConnection *VirtualConnection;

    RpcStatus = HTTP2Channel::CheckSendCompleteForSync(EventStatus,
        SendContext
        );

    if (RpcStatus != RPC_P_PACKET_CONSUMED)
        {
        // is this our client open packet?
        if (SendContext->TrafficType == http2ttRaw)
            {
            if (EventStatus != RPC_S_OK)
                {
                VirtualConnection = (HTTP2VirtualConnection *)LockParentPointer();
                if (VirtualConnection != NULL)
                    {
                    VirtualConnection->Abort();
                    UnlockParentPointer();
                    }
                }

            RpcFreeBuffer(SendContext);

            RpcStatus = RPC_P_PACKET_CONSUMED;
            }
        else if (RpcStatus == RPC_S_OK)
            {
            // doesn't seem like our traffic. Forward it up.
            RpcStatus = ForwardUpSendComplete(EventStatus,
                SendContext
                );
            }
        else
            {
            // must be an error - just fall through
            }
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientChannel::CheckReceiveCompleteForSync (
    IN RPC_STATUS EventStatus,
    IN HTTP2TrafficType TrafficType,
    IN BYTE *Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    Receive complete notification. Checks if the receive was
    sync, and if yes, fires event and consumes the packet.

Arguments:

    EventStatus - status of the operation

    TrafficType - the type of traffic we received

    Buffer - the received buffer (success only)

    BufferLength - the length of the received buffer (success only)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HANDLE hEvent;

    // RTS receives are never sync even if there
    // is a sync waiter
    if (TrafficType == http2ttRTS)
        return RPC_S_OK;

    // was this a sync receive?
    if (Ol.ReceiveOverlapped.hEvent)
        {
        LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_CHECK_RECV_COMPLETE, HTTP2LOG_OT_CLIENT_CHANNEL, (ULONG_PTR)Buffer);

        // yes, consume it
        if (EventStatus == RPC_S_OK)
            {
            ASSERT(Buffer != NULL);
            }
        Ol.ReceiveOverlapped.Buffer = Buffer;
        Ol.ReceiveOverlapped.BufferLength = BufferLength;
        hEvent = Ol.ReceiveOverlapped.hEvent;
        Ol.ReceiveOverlapped.Internal = (ULONG)EventStatus;
        Ol.ReceiveOverlapped.IOCompleted = TRUE;
        SetEvent(hEvent);
        return RPC_P_PACKET_CONSUMED;
        }

    // wasn't for us after all. Let it continue
    return RPC_S_OK;
}

void HTTP2ClientChannel::WaitInfiniteForSyncReceive (
    void
    )
/*++

Routine Description:

    Waits infinitely for a sync recv to complete.
    Channel must be aborted before this is called.

Arguments:

Return Value:

--*/
{
    ASSERT(Aborted.GetInteger() > 0);

    UTIL_WaitForSyncHTTP2IO(&Ol.Overlapped,
                       Ol.ReceiveOverlapped.hEvent,
                       FALSE,   // Alertable
                       INFINITE);
}

RPC_STATUS HTTP2ClientChannel::SubmitSyncRecv (
    IN HTTP2TrafficType TrafficType
    )
/*++

Routine Description:

    Submits a sync recv.

Arguments:

    TrafficType - the type of traffic

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{    
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_SYNC_RECV, HTTP2LOG_OT_CLIENT_CHANNEL, TrafficType);

    // transfer the settings from parameters to the receive overlapped
    Ol.ReceiveOverlapped.hEvent = I_RpcTransGetThreadEvent();
    ResetEvent(Ol.ReceiveOverlapped.hEvent);
    Ol.ReceiveOverlapped.IOCompleted = FALSE;

    // submit the actual receive
    return HTTP2Channel::Receive(TrafficType);
}

RPC_STATUS HTTP2ClientChannel::WaitForSyncRecv (
    IN BYTE **Buffer,
    IN ULONG *BufferLength,
    IN ULONG Timeout,
    IN ULONG ConnectionTimeout,
    IN BASE_ASYNC_OBJECT *Connection,
    OUT BOOL *AbortNeeded,
    OUT BOOL *IoPending
    )
/*++

Routine Description:

    Waits for a sync receive to complete.

Arguments:

    Buffer - on success will contain the received buffer. On failure
        is undefined.

    BufferLength - on success will contain the length of the buffer.
        On failure is undefined.

    Timeout - the call timeout

    ConnectionTimeout - the connection timeout

    Connection - the transport connection object

    AbortNeeded - must be FALSE on entry. This function will set it to
        non-zero if abort and wait are needed.

    WaitPending - must be FALSE on entry. If on return there is an Io
        pending, it will be set to non-zero

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{    
    RPC_STATUS RpcStatus;
    DWORD dwActualTimeout;
    BOOL fWaitOnConnectionTimeout;
    BOOL fSetKeepAliveVals;
    KEEPALIVE_TIMEOUT KATimeout;
    RPC_STATUS RpcStatus2;

    ASSERT(*AbortNeeded == FALSE);
    ASSERT(*IoPending == FALSE);

    // if there's a per operation timeout, use the lesser of the operation
    // and connection timeout
    ASSERT(ConnectionTimeout);

    if (Timeout != INFINITE)
        {
        if (Timeout <= ConnectionTimeout)
            {
            dwActualTimeout = Timeout;
            fWaitOnConnectionTimeout = FALSE;
            }
        else
            {
            dwActualTimeout = ConnectionTimeout;
            fWaitOnConnectionTimeout = TRUE;
            }
        }
    else
        {
        // wait on the connection timeout
        dwActualTimeout = ConnectionTimeout;
        fWaitOnConnectionTimeout = TRUE;
        }

    fSetKeepAliveVals = FALSE;

    do
        {

        //
        // Wait for the pending receive to complete
        //

        RpcStatus = UTIL_GetOverlappedHTTP2ResultEx(Connection,
                                            &Ol.Overlapped,
                                            Ol.ReceiveOverlapped.hEvent,
                                            TRUE, // Alertable
                                            dwActualTimeout);


        if (RpcStatus != RPC_S_OK)
            {
            // if we timed out ...
            if (RpcStatus == RPC_P_TIMEOUT)
                {
                ASSERT(dwActualTimeout != INFINITE);

                // if we waited on the per connection timeout ...
                if (fWaitOnConnectionTimeout)
                    {
                    ASSERT(ConnectionTimeout != INFINITE);
                    if (Timeout == INFINITE)
                        {
                        // enable keep alives and wait forever
                        dwActualTimeout = INFINITE;
                        }
                    else
                        {
                        ASSERT(ConnectionTimeout < Timeout);

                        // enable keep alives and wait the difference
                        dwActualTimeout = Timeout - ConnectionTimeout;
                        fWaitOnConnectionTimeout = FALSE;
                        }
                    // Enable aggressive keepalives on the socket if lower layers
                    // support it. 
                    KATimeout.Milliseconds = ConnectionTimeout;
                    RpcStatus2 = SetKeepAliveTimeout (
                        TRUE,       // TurnOn
                        FALSE,      // bProtectIO
                        tuMilliseconds,
                        KATimeout,
                        KATimeout.Milliseconds
                        ); 

                    if (RpcStatus2 != RPC_S_OK)
                        {
                        *AbortNeeded = TRUE;
                        *IoPending = TRUE;
                        goto CleanupAndExit;
                        }

                    fSetKeepAliveVals = TRUE;

                    continue;
                    }
                // else we have chosen the per operation timeout and
                // have timed out on that - time to bail out
                }

            // Normal error path
            if ((RpcStatus == RPC_S_CALL_CANCELLED) || (RpcStatus == RPC_P_TIMEOUT))
                {
                if ((RpcStatus == RPC_P_TIMEOUT) && fWaitOnConnectionTimeout)
                    {
                    RpcStatus = RPC_P_RECEIVE_FAILED;
                    }
                *AbortNeeded = TRUE;
                *IoPending = TRUE;
                goto CleanupAndExit;
                }

            *AbortNeeded = TRUE;
            // connection was aborted - no need to turn off keep alives
            goto CleanupAndExit;
            }
        }
    while (RpcStatus == RPC_P_TIMEOUT);

    if (fSetKeepAliveVals)
        {
        // Call completed, clear keep alives. Turning off is a best
        // effort. Ignore failures
        KATimeout.Milliseconds = 0;
        (void) SetKeepAliveTimeout(
            FALSE,      // TurnOn
            FALSE,      // bProtectIO
            tuMilliseconds,
            KATimeout,
            KATimeout.Milliseconds
            );
        }

    *Buffer = Ol.ReceiveOverlapped.Buffer;
    *BufferLength = Ol.ReceiveOverlapped.BufferLength;

    if (RpcStatus == RPC_S_OK)
        {
        ASSERT(*Buffer != NULL);
        }

CleanupAndExit:
    LOG_OPERATION_EXIT(HTTP2LOG_OPERATION_SYNC_RECV, HTTP2LOG_OT_CLIENT_CHANNEL, RpcStatus);

    if (*IoPending == FALSE)
        {
        // consume the event if there will be no wait
        Ol.ReceiveOverlapped.hEvent = NULL;
        }
    return RpcStatus;
}

void HTTP2ClientChannel::AbortConnection (
    IN RPC_STATUS AbortReason
    )
/*++

Routine Description:

    Aborts the client virtual connection. The only
    difference from HTTP2Channel::AbortConnection
    is that it specifically calls AbortChannels on
    the client virtual connection. This is necessary
    because AbortChannels is not virtual.

Arguments:

    RpcStatus - the error to abort with

Return Value:

--*/
{
    HTTP2ClientVirtualConnection *VirtualConnection;

    // abort the parent connection
    VirtualConnection = (HTTP2ClientVirtualConnection *)LockParentPointer();
    if (VirtualConnection)
        {
        VirtualConnection->AbortChannels(AbortReason);
        UnlockParentPointer();
        }
    else
        {
        // abort this channel at least
        Abort(AbortReason);
        }
}

/*********************************************************************
    HTTP2ClientInChannel
 *********************************************************************/

RPC_STATUS HTTP2ClientInChannel::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN const char *Verb,
    IN int VerbLength,
    IN BOOL UseWinHttp,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,
    IN ULONG ChosenAuthScheme,
    IN ULONG CallTimeout,
    IN const BYTE *AdditionalData, OPTIONAL
    IN ULONG AdditionalDataLength OPTIONAL
    )
/*++

Routine Description:

    Sends the HTTP establishment header on 
    the in channel.

Arguments:

    Hint - the resolver hint

    Verb - the verb to use.

    VerbLength - the length of the verb (in characters, not including
        null terminator).

    UseWinHttp - non-zero if WinHttp needs to be used. 0 otherwise

    HttpCredentials - encrypted transport credentials

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    CallTimeout - the call timeout for this call

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

    AdditionalDataLength - the length of the additional data to send with the header.
        Must be set iff AdditionalLength != NULL

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return HTTP2ClientChannel::ClientOpen(Hint,
        Verb,
        VerbLength,
        TRUE,    // InChannel
        FALSE,    // ReplacementChannel
        UseWinHttp,
        HttpCredentials,
        ChosenAuthScheme,
        GetWinHttpConnection(),
        CallTimeout,
        AdditionalData,
        AdditionalDataLength
        );
}

RPC_STATUS HTTP2ClientInChannel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error.
    May return RPC_P_CHANNEL_NEEDS_RECYCLING - caller needs to handle.

--*/
{
    HTTP2SendContext *KeepAliveChangeContext;
    RPC_STATUS RpcStatus;
    BOOL WasChannelRecyclingTriggered;

    ASSERT(Units == tuMilliseconds);

    // HTTP keep alives are heavy weight. Moderate the caller's
    // settings
    if (TurnOn)
        {
        if (KAInterval < MinimumClientSideKeepAliveInterval)
            KAInterval = MinimumClientSideKeepAliveInterval;
        }
    else
        {
        KAInterval = 0;
        }

    // tell the proxy to change it's keepalives and then
    // ask our ping originator to change its keepalives as well
    KeepAliveChangeContext = AllocateAndInitializeKeepAliveChangePacket (KAInterval);
    if (KeepAliveChangeContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = Send(KeepAliveChangeContext);

    WasChannelRecyclingTriggered = FALSE;
    if (RpcStatus != RPC_S_OK)
        {
        if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
            WasChannelRecyclingTriggered = TRUE;
        else
            {
            FreeRTSPacket(KeepAliveChangeContext);
            return RpcStatus;
            }
        }

    // get into submission context
    RpcStatus = BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    // ask our ping channel to change as well
    RpcStatus = GetPingOriginatorChannel()->SetKeepAliveTimeout (
        TurnOn,
        bProtectIO,
        Units,
        KATime,
        KAInterval
        );

    FinishSubmitAsync();

    // if we failed for other reasons or channel recycling was not triggered
    // at all, return the current status
    if ((WasChannelRecyclingTriggered == FALSE) || (RpcStatus != RPC_S_OK))
        return RpcStatus;
    else
        return RPC_P_CHANNEL_NEEDS_RECYCLING;
}

/*********************************************************************
    HTTP2ClientOutChannel
 *********************************************************************/

RPC_STATUS HTTP2ClientOutChannel::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN const char *Verb,
    IN int VerbLength,
    IN BOOL ReplacementChannel,
    IN BOOL UseWinHttp,
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials,
    IN ULONG ChosenAuthScheme,
    IN ULONG CallTimeout,
    IN const BYTE *AdditionalData, OPTIONAL
    IN ULONG AdditionalDataLength OPTIONAL
    )
/*++

Routine Description:

    Sends the HTTP establishment header on 
    the out channel.

Arguments:

    Hint - the resolver hint

    Verb - the verb to use.

    VerbLength - the length of the verb (in characters, not including
        null terminator).

    ReplacementChannel - non-zero if this is a replacement channel.
        Zero if it is not.

    UseWinHttp - non-zero if WinHttp needs to be used. 0 otherwise

    HttpCredentials - encrypted transport credentials

    ChosenAuthScheme - the chosen auth scheme. 0 if no auth scheme is chosen.

    CallTimeout - the call timeout for this call.

    AdditionalData - additional data to send with the header. Must be set iff 
        AdditionalDataLength != 0

    AdditionalDataLength - the length of the additional data to send with the header.
        Must be set iff AdditionalLength != NULL

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return HTTP2ClientChannel::ClientOpen(Hint,
        Verb,
        VerbLength,
        FALSE,       // InChannel
        ReplacementChannel,
        UseWinHttp,
        HttpCredentials,
        ChosenAuthScheme,
        GetWinHttpConnection(),
        CallTimeout,
        AdditionalData,
        AdditionalDataLength
        );
}

RPC_STATUS HTTP2ClientOutChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack to the out proxy through the in proxy

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

Notes:

    Must be called from neutral context only.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ForwardFlowControlAckOnDefaultChannel(TRUE,    // IsInChannel
        fdOutProxy,
        BytesReceivedForAck,
        WindowForAck
        );

    RpcStatus = HandleSendResultFromNeutralContext(RpcStatus);

    return RpcStatus;
}

RPC_STATUS HTTP2ClientOutChannel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    HTTP2ClientVirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    // turn around the request through the connection
    VirtualConnection = LockParentPointer();
    if (VirtualConnection == NULL)
        return RPC_P_CONNECTION_SHUTDOWN;

    RpcStatus = VirtualConnection->TurnOnOffKeepAlives(
        TurnOn,
        bProtectIO,
        TRUE,   // IsFromUpcall
        Units,
        KATime,
        KAInterval
        );

    UnlockParentPointer();

    return RpcStatus;
}

/*********************************************************************
    HTTP2ClientVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2ClientVirtualConnection::ClientOpen (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN UINT ConnTimeout,
    IN ULONG CallTimeout
    )
/*++

Routine Description:

    Opens a client side virtual connection.

Arguments:

    Hint - the resolver hint

    HintWasInitialized - the hint was initialized on input.

    ConnTimeout - connection timeout

    CallTimeout - operation timeout

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    return ClientOpenInternal (
        Hint,
        HintWasInitialized,
        ConnTimeout,
        CallTimeout,
        TRUE,       // OpenInChannel
        TRUE,       // OpenOutChannel
        FALSE,      // IsReplacementChannel
        FALSE       // IsFromUpcall
        );
}

RPC_STATUS HTTP2ClientVirtualConnection::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate send complete.

Arguments:

    EventStatus - status of the operation

    SendContext - the context for the send complete

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    HTTP2TrafficType TrafficType;
    
    VerifyValidChannelId(ChannelId);

    if (EventStatus == RPC_S_OK)
        {
        // successful sends are always no-ops on the
        // client. Just cleanup if necessary and
        // return
        if (SendContext->TrafficType == http2ttRTS)
            {
            FreeSendContextAndPossiblyData(SendContext);
            return RPC_P_PACKET_CONSUMED;
            }
        else
            return RPC_S_OK;
        }

    // we know the send failed
    if (IsDefaultInChannel(ChannelId) || IsDefaultOutChannel(ChannelId))
        {
        // on a default channel such error is fatal
        AbortChannels(EventStatus);

        if (SendContext->TrafficType == http2ttRTS)
            {
            FreeSendContextAndPossiblyData(SendContext);
            return RPC_P_PACKET_CONSUMED;
            }

        ASSERT(SendContext->TrafficType == http2ttData);

        return EventStatus;
        }
    else
        {
        // all data sends go on default channels. RTS sends
        // may go either way. If this is RTS, this is fatal.
        // Otherwise, ignore.
        if (SendContext->TrafficType == http2ttRTS)
            {
            FreeSendContextAndPossiblyData(SendContext);
            AbortChannels(EventStatus);
            return RPC_P_PACKET_CONSUMED;
            }
        else
            return RPC_S_OK;
        }
}

RPC_STATUS HTTP2ClientVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error
    Buffer - buffer received
    BufferLength - length of buffer received
    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_P_ABORT_NEEDED - if the channel needs to be aborted but
        couldn't be aborted in this function because it was detached.
        After aborting, the semantics is same as RPC_P_PACKET_CONSUMED.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    RPC_STATUS RpcStatus;
    ULONG ProxyConnectionTimeout;
    BOOL BufferFreed = FALSE;
    BOOL WakeOpenThread;
    HTTP2ClientInChannel *InChannel;
    HTTP2ClientOutChannel *OutChannel;
    HTTP2ClientOutChannel *OutChannel2;
    HTTP2ClientInChannel *NewInChannel;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *NewChannelPtr;
    LIST_ENTRY NewBufferHead;
    LIST_ENTRY *CurrentListEntry;
    LIST_ENTRY *PrevListEntry;
    HTTP2SendContext *QueuedSendContext;
    BOOL MutexReleased;
    HTTP2SendContext *A5Context;    // may be D2/A5 or D3/A5
    HTTP2SendContext *D4_A7Context;
    HTTP2SendContext *PingContext;
    BOOL IsD2_A4;
    HTTP2ClientOpenedPacketType ClientPacketType;
    BOOL DataReceivePosted;
    HTTP2StateValues NewState;
    HTTP2StateValues ExpectedState;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2Cookie CookieForChannel;
    ULONG InProxyReceiveWindow;
    BOOL UseWinHttp;
    KEEPALIVE_TIMEOUT KATimeout;

    VerifyValidChannelId(ChannelId);

    if (
        (InChannelState.State == http2svSearchProxy) 
        && 
        (
         (EventStatus != RPC_S_OK) 
         || 
         IsEchoPacket(Buffer, BufferLength)
        )
       )
        {
        InChannelState.Mutex.Request();
        if (InChannelState.State == http2svSearchProxy)
            {
            InChannelState.Mutex.Clear();

            if (IsInChannel(ChannelId))
                {
                InOpenStatus = EventStatus;
                }
            else
                {
                OutOpenStatus = EventStatus;
                }

            // we won the race. Wake up the open thread
            WakeOpenThread = TRUE;

            RpcStatus = RPC_P_PACKET_CONSUMED;

            goto CleanupAndExit;
            }

        InChannelState.Mutex.Clear();
        }

    WakeOpenThread = FALSE;
    if (IsInChannel(ChannelId))
        {
        if (EventStatus != RPC_P_AUTH_NEEDED)
            {
            // we shouldn't really be receiving stuff on the in channel
            // unless there is an error
            if (EventStatus != RPC_S_OK)
                {
                if (IsDefaultInChannel(ChannelId) == FALSE)
                    {
                    InChannelState.Mutex.Request();
                    if (InChannelState.State == http2svOpened)
                        {
                        // close on the non-default channel in open
                        // state is not an error for the connection
                        // just abort the channel in question
                        InChannelState.Mutex.Clear();
                        ChannelPtr = GetChannelPointerFromId(ChannelId);
                        InChannel = (HTTP2ClientInChannel *)ChannelPtr->LockChannelPointer();
                        if (InChannel)
                            {
                            InChannel->Abort(EventStatus);
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_P_PACKET_CONSUMED;
                            }
                        else
                            RpcStatus = RPC_P_ABORT_NEEDED;

                        BufferFreed = TRUE;
                        return RpcStatus;
                        }
                    else
                        InChannelState.Mutex.Clear();
                    }
                RpcStatus = EventStatus;
                // in failed receives, we don't own the buffer
                BufferFreed = TRUE;
                }
            else
                {
                if (IsEchoPacket(Buffer, BufferLength))
                    {
                    InOpenStatus = EventStatus;
                    WakeOpenThread = TRUE;
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                }

            AbortChannels(RpcStatus);
            }
        else
            {
            // turn around the error code and fall through
            RpcStatus = EventStatus;
            }

        // the runtime never posted a receive on the in
        // channel. Don't let it see the packet
        InOpenStatus = RpcStatus;
        WakeOpenThread = TRUE;
        RpcStatus = RPC_P_PACKET_CONSUMED;
        }
    else
        {
        // this is an out channel
        if (EventStatus != RPC_S_OK)
            {
            if (EventStatus != RPC_P_AUTH_NEEDED)
                {
                AbortChannels(EventStatus);
                RpcStatus = EventStatus;

                if (RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
                    RpcStatus = RPC_P_RECEIVE_FAILED;

                OutOpenStatus = RpcStatus;
                }
            else
                {
                OutOpenStatus = EventStatus;

                RpcStatus = RPC_P_RECEIVE_FAILED;
                }

            WakeOpenThread = TRUE;

            // in failed receives we don't own the buffer
            BufferFreed = TRUE;
            }
        else
            {
            // verify state and act upon it if RTS
            // for data we don't care
            if (IsRTSPacket(Buffer))
                {
                if (IsOtherCmdPacket(Buffer, BufferLength))
                    {
                    // the only cmd packet we expect is flow control ack
                    // try to interpret it as such
                    RpcStatus = ParseAndFreeFlowControlAckPacketWithDestination (
                        Buffer,
                        BufferLength,
                        fdClient,
                        &BytesReceivedForAck,
                        &WindowForAck,
                        &CookieForChannel
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_OK)
                        {
                        // notify the flow control sender about the ack
                        InChannel = (HTTP2ClientInChannel *)MapCookieToChannelPointer(
                            &CookieForChannel, 
                            &ChannelPtr
                            );
                        if (InChannel)
                            {
                            RpcStatus = InChannel->FlowControlAckNotify(BytesReceivedForAck,
                                WindowForAck
                                );
                            ChannelPtr->UnlockChannelPointer();

                            RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                                TRUE        // IsFromUpcall
                                );
                            }

                        if (RpcStatus == RPC_S_OK)
                            {
                            // post another receive
                            RpcStatus = PostReceiveOnChannel (GetChannelPointerFromId(ChannelId),
                                http2ttRTS
                                );
                            }
                        }

                    if (RpcStatus != RPC_S_OK)
                        {
                        AbortChannels(RpcStatus);

                        OutOpenStatus = RpcStatus;
                        WakeOpenThread = TRUE;
                        }

                    // This is an RTS packet - consume it
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }
                else if (IsEchoPacket(Buffer, BufferLength))
                    {
                    OutOpenStatus = EventStatus;
                    WakeOpenThread = TRUE;
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }

                RpcStatus = HTTPTransInfo->CreateThread();

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);

                    // This is an RTS packet - consume it
                    RpcFreeBuffer(Buffer);
                    BufferFreed = TRUE;
                    OutOpenStatus = RpcStatus;
                    WakeOpenThread = TRUE;
                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    goto CleanupAndExit;
                    }

                MutexReleased = FALSE;
                InChannelState.Mutex.Request();
                switch (InChannelState.State)
                    {
                    case http2svA3W:
                        RpcStatus = ParseAndFreeD1_A3(Buffer,
                            BufferLength,
                            &ProxyConnectionTimeout
                            );

                        // we don't really do anything with the ProxyConnectionTimeout - it's
                        // for debugging purposes only

                        BufferFreed = TRUE;

                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = PostReceiveOnChannel(&OutChannels[0], http2ttRTS);
                            if (RpcStatus == RPC_S_OK)
                                {
                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svC2W, 1, 0);
                                InChannelState.State = http2svC2W;
                                RpcStatus = RPC_P_PACKET_CONSUMED;
                                }
                            else
                                OutOpenStatus = RpcStatus;
                            }
                        break;

                    case http2svC2W:
                        RpcStatus = ParseAndFreeD1_C2(Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &InProxyReceiveWindow,
                            &InProxyConnectionTimeout
                            );

                        BufferFreed = TRUE;

                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = PostReceiveOnChannel(&OutChannels[0], http2ttRTS);
                            if (RpcStatus == RPC_S_OK)
                                {
                                // Set the in proxy timeout to the channel
                                InChannel = LockDefaultInChannel(&ChannelPtr);
                                if (InChannel != NULL)
                                    {
                                    InChannel->SetPeerReceiveWindow(InProxyReceiveWindow);
                                    RpcStatus = InChannel->SetConnectionTimeout(InProxyConnectionTimeout);
                                    ChannelPtr->UnlockChannelPointer();
                                    }
                                else
                                    RpcStatus = RPC_P_CONNECTION_CLOSED;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    OutOpenStatus = RpcStatus;
                                    break;
                                    }

                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                                InChannelState.State = http2svOpened;

                                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                                OutChannelState.State = http2svOpened;

                                InOpenStatus = OutOpenStatus = RPC_S_OK;
                                SetClientOpenInEvent();

                                RpcStatus = RPC_P_PACKET_CONSUMED;
                                }
                            }
                        break;

                    default:
                        // all the opened states are handled here
                        ASSERT((InChannelState.State == http2svOpened)
                            || (InChannelState.State == http2svOpened_A4W) );
                        ASSERT((OutChannelState.State == http2svOpened)
                            || (OutChannelState.State == http2svOpened_A6W)
                            || (OutChannelState.State == http2svOpened_A10W) 
                            || (OutChannelState.State == http2svOpened_B3W) );

                        RpcStatus = GetClientOpenedPacketType (Buffer,
                            BufferLength,
                            &ClientPacketType
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RpcStatus);
                            break;
                            }

                        switch (ClientPacketType)
                            {
                            case http2coptD2_A4:
                            case http2coptD3_A4:
                                // in channel must be in Opened_A4W
                                // out channel can be in any state
                                ASSERT(InChannelState.State == http2svOpened_A4W);

                                InChannelState.Mutex.Clear();
                                MutexReleased = TRUE;

                                IsD2_A4 = IsD2_A4OrD3_A4(Buffer,
                                    BufferLength
                                    );

                                if (IsD2_A4)
                                    {
                                    RpcStatus = ParseAndFreeD2_A4(Buffer,
                                        BufferLength,
                                        fdClient,
                                        &ProtocolVersion,
                                        &InProxyReceiveWindow,
                                        &InProxyConnectionTimeout
                                        );
                                    }
                                else
                                    {
                                    // This must be a D3/A4
                                    RpcStatus = ParseAndFreeD3_A4 (Buffer,
                                        BufferLength
                                        );
                                    }

                                BufferFreed = TRUE;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    break;
                                    }

                                RpcStatus = PostReceiveOnChannel(&OutChannels[DefaultOutChannelSelector], 
                                    http2ttRTS);
                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    break;
                                    }

                                // lock the old channel
                                InChannel = LockDefaultInChannel(&ChannelPtr);
                                if (InChannel == NULL)
                                    {
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                if (IsD2_A4 == FALSE)
                                    {
                                    // capture the receive window from the old channel.
                                    // We know the proxy is the same so the window must be
                                    // the same as well
                                    InProxyReceiveWindow = InChannel->GetPeerReceiveWindow();
                                    }

                                // switch channels (new channel is still plugged)
                                SwitchDefaultInChannelSelector();

                                // wait for everybody that is in the process of using 
                                // the old channel to get out
                                InChannel->DrainPendingSubmissions();

                                // leave 1 for our lock
                                ChannelPtr->DrainPendingLocks(1);

                                // lock new channel (by now it is default)
                                NewInChannel = LockDefaultInChannel(&NewChannelPtr);
                                if (NewInChannel == NULL)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                NewInChannel->SetPeerReceiveWindow(InProxyReceiveWindow);

                                // Set the in proxy timeout to the new channel
                                RpcStatus = NewInChannel->SetConnectionTimeout(InProxyConnectionTimeout);

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    NewChannelPtr->UnlockChannelPointer();
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // if old flow control channel was queuing, grab all its buffers
                                // We must do this before the channel data originator to make sure
                                // the buffers end up behind the ones from the channel data
                                // originator
                                RpcpInitializeListHead(&NewBufferHead);
                                InChannel->GetFlowControlSenderBufferQueue(&NewBufferHead);

                                AddBufferQueueToChannel(&NewBufferHead, NewInChannel);

                                // GetChannelOriginatorBufferQueue can be called in submission
                                // context only. Get into submission context
                                RpcStatus = InChannel->BeginSimpleSubmitAsync();
                                if (RpcStatus != RPC_S_OK)
                                    {
                                    NewChannelPtr->UnlockChannelPointer();
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // if old channel channel data originator was queuing, grab all its buffers
                                RpcpInitializeListHead(&NewBufferHead);
                                InChannel->GetChannelOriginatorBufferQueue(&NewBufferHead);

                                InChannel->FinishSubmitAsync();

                                AddBufferQueueToChannel(&NewBufferHead, NewInChannel);

                                InChannelState.Mutex.Request();
                                // move channel state to opened
                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                                InChannelState.State = http2svOpened;
                                InChannelState.Mutex.Clear();

                                if (IsD2_A4)
                                    {
                                    // register the last packet to send with the old channel
                                    A5Context = AllocateAndInitializeD2_A5 (
                                        &InChannelCookies[DefaultInChannelSelector]
                                        );
                                    }
                                else
                                    {
                                    A5Context = AllocateAndInitializeD3_A5 (
                                        &InChannelCookies[DefaultInChannelSelector]
                                        );
                                    }

                                if (A5Context == NULL)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    NewChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // make sure the packet is sent last
                                RpcStatus = InChannel->Send(A5Context);

                                if (RpcStatus == RPC_S_OK)
                                    {
                                    UseWinHttp = ShouldUseWinHttp(HttpCredentials);
                                    if (UseWinHttp)
                                        {
                                        InChannel->DisablePings();
                                        RpcStatus = InChannel->Receive(http2ttRaw);
                                        }
                                    }
                                else
                                    {
                                    FreeRTSPacket(A5Context);
                                    }

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    NewChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // D2_A5 was sent. We must switch the
                                // default loopback and detach the channel.
                                // Note that we don't abort the channel - we
                                // just release the lifetime reference
                                // When the proxy closes the connection, then
                                // we will abort.
                                SwitchDefaultLoopbackChannelSelector();
                                ChannelPtr->UnlockChannelPointer();
                                ChannelPtr->FreeChannelPointer(
                                    TRUE,    // DrainUpcalls
                                    FALSE,   // CalledFromUpcallContext
                                    FALSE,   // Abort
                                    RPC_S_OK
                                    );

                                RpcStatus = NewInChannel->Unplug();
                                if (RpcStatus != RPC_S_OK)
                                    {
                                    NewChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                NewChannelPtr->UnlockChannelPointer();

                                RpcStatus = RPC_P_PACKET_CONSUMED;

                                break;

                            case http2coptD4_A2:
                                // in channel can be in any opened state
                                // out channel must be in http2svOpened
                                ASSERT(OutChannelState.State == http2svOpened);

                                if (OutChannelState.State != http2svOpened)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }
                                InChannelState.Mutex.Clear();
                                MutexReleased = TRUE;

                                RpcStatus = ParseAndFreeD4_A2(Buffer,
                                    BufferLength
                                    );

                                BufferFreed = TRUE;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = OpenReplacementOutChannel();

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = PostReceiveOnDefaultChannel(FALSE,  // IsInChannel
                                    http2ttRTS);
                                if (RpcStatus != RPC_S_OK)
                                    AbortChannels(RpcStatus);

                                RpcStatus = RPC_P_PACKET_CONSUMED;

                                break;

                            case http2coptD4_A6:
                            case http2coptD5_A6:
                                // in channel can be in any opened state
                                // out channel must be in http2svOpened_A6W
                                ASSERT(OutChannelState.State == http2svOpened_A6W);

                                if (OutChannelState.State != http2svOpened_A6W)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                if (ClientPacketType == http2coptD4_A6)
                                    NewState = http2svOpened_A10W;
                                else
                                    NewState = http2svOpened_B3W;

                                // move channel state to new state
                                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, NewState, 1, 0);
                                OutChannelState.State = NewState;

                                InChannelState.Mutex.Clear();
                                MutexReleased = TRUE;

                                if (ClientPacketType == http2coptD4_A6)
                                    {
                                    RpcStatus = ParseAndFreeD4_A6 (Buffer,
                                        BufferLength,
                                        fdClient,
                                        &ProtocolVersion,
                                        &ProxyConnectionTimeout
                                        );

                                    // we don't really do anything with ProxyConnectionTimeout. That's
                                    // ok. It's there mostly for debugging.
                                    }
                                else
                                    {
                                    RpcStatus = ParseAndFreeD5_A6 (Buffer,
                                        BufferLength,
                                        fdClient
                                        );
                                    }

                                BufferFreed = TRUE;

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RpcStatus);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                if (ClientPacketType == http2coptD5_A6)
                                    {
                                    // in the D5 case, we won't send A11. Since
                                    // some proxies are picky about sending all
                                    // the declared data before allowing receiving
                                    // data to come in, we need to send an empty packet
                                    // of the necessary size to keep the proxy happy.
                                    PingContext = AllocateAndInitializePingPacketWithSize (
                                        GetD4_A11TotalLength()
                                        );

                                    if (PingContext == NULL)
                                        {
                                        AbortChannels(RPC_S_OUT_OF_MEMORY);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    RpcStatus = SendTrafficOnChannel(
                                        &OutChannels[GetNonDefaultOutChannelSelector()],
                                        PingContext
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        FreeRTSPacket(PingContext);
                                        AbortChannels(RpcStatus);
                                        break;
                                        }
                                    }

                                D4_A7Context = AllocateAndInitializeD4_A7 (
                                    fdServer,
                                    &OutChannelCookies[GetNonDefaultOutChannelSelector()]
                                    );

                                if (D4_A7Context == NULL)
                                    {
                                    AbortChannels(RPC_S_OUT_OF_MEMORY);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                RpcStatus = SendTrafficOnDefaultChannel(TRUE,   //IsInChannel
                                    D4_A7Context
                                    );

                                RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                                    TRUE        // IsFromUpcall
                                    );

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    FreeRTSPacket(D4_A7Context);
                                    AbortChannels(RpcStatus);
                                    break;
                                    }

                                RpcStatus = PostReceiveOnDefaultChannel (FALSE,     // IsInChannel
                                    http2ttRTS);

                                if (RpcStatus != RPC_S_OK)
                                    AbortChannels(RpcStatus);

                                RpcStatus = RPC_P_PACKET_CONSUMED;

                                break;

                            case http2coptD4_A10:
                            case http2coptD5_B3:
                                // in channel can be in any opened state
                                if (ClientPacketType == http2coptD4_A10)
                                    {
                                    // out channel must be in http2svOpened_A10W
                                    ASSERT(OutChannelState.State == http2svOpened_A10W);

                                    if (OutChannelState.State != http2svOpened_A10W)
                                        {
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    InChannelState.Mutex.Clear();
                                    MutexReleased = TRUE;

                                    RpcStatus = ParseD4_A10 (Buffer,
                                        BufferLength
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        AbortChannels(RpcStatus);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }
                                    }
                                else
                                    {
                                    // out channel must be in http2svOpened_B3W
                                    ASSERT(OutChannelState.State == http2svOpened_B3W);

                                    if (OutChannelState.State != http2svOpened_B3W)
                                        {
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    InChannelState.Mutex.Clear();
                                    MutexReleased = TRUE;

                                    RpcStatus = ParseAndFreeD5_B3 (Buffer,
                                        BufferLength
                                        );

                                    BufferFreed = TRUE;

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        AbortChannels(RpcStatus);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }
                                    }

                                ChannelPtr = GetChannelPointerFromId(ChannelId);
                                OutChannel = (HTTP2ClientOutChannel *)ChannelPtr->LockChannelPointer();
                                if (OutChannel == NULL)
                                    {
                                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                NewChannelPtr = &OutChannels[GetNonDefaultOutChannelSelector()];
                                OutChannel2 = (HTTP2ClientOutChannel *)NewChannelPtr->LockChannelPointer ();
                                if (OutChannel2 == NULL)
                                    {
                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                OutChannel2->BlockDataReceives();

                                // we're done with this channel. We want to switch
                                // channels and destroy
                                // and detach the channel.
                                // In the D5 case we can't switch earlier, because we
                                // have a race condition where folks may receive data
                                // on the new channel before they have drained the old,
                                // which may result in out-of-order delivery. Since
                                // data receives are blocked here, switching and draining
                                // is atomical in respect to the new channel
                                SwitchDefaultOutChannelSelector();

                                // make sure everybody who was submitting is out
                                OutChannel->DrainPendingSubmissions();

                                // 1 is for the lock that we have
                                ChannelPtr->DrainPendingLocks(1);

                                RpcStatus = OutChannel->TransferReceiveStateToNewChannel(OutChannel2);

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    OutChannel2->UnblockDataReceives();
                                    NewChannelPtr->UnlockChannelPointer();

                                    ChannelPtr->UnlockChannelPointer();
                                    AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // if there is recv pending, but it is not an sync recv,
                                // make a note of that - we will resubmit it later. If it is
                                // sync, we will use the ReissueRecv mechanism to transfer
                                // the recv to the new channel
                                DataReceivePosted = FALSE;
                                if (OutChannel->IsDataReceivePosted())
                                    {
                                    if (OutChannel->IsSyncRecvPending())
                                        {
                                        // before we destroy, tell any pending recv to re-issue
                                        // itself upon failure.
                                        ReissueRecv = TRUE;
                                        }
                                    else
                                        {
                                        DataReceivePosted = TRUE;
                                        }
                                    }

                                ChannelPtr->UnlockChannelPointer();


                                if (ClientPacketType == http2coptD4_A10)
                                    {
                                    // after having transfered the receive settings,
                                    // we can send D4/A11 to open the pipeline
                                    RpcStatus = ForwardTrafficToDefaultChannel(FALSE,    // IsInChannel
                                        Buffer,
                                        BufferLength
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        NewChannelPtr->UnlockChannelPointer();
                                        OutChannel2->UnblockDataReceives();
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        RpcStatus = RPC_P_PACKET_CONSUMED;
                                        break;
                                        }

                                    // we no longer own the buffer
                                    BufferFreed = TRUE;
                                    }

                                // we couldn't unblock receives earlier because new receives
                                // must be synchronized w.r.t. D4/A11 - we can't post
                                // real receives before D4/A11 because it will switch WinHttp
                                // into receiveing mode. We also can't send D4/A11 before we
                                // have transferred the settings
                                OutChannel2->UnblockDataReceives();
                                NewChannelPtr->UnlockChannelPointer();

                                RpcStatus = PostReceiveOnDefaultChannel (FALSE,     // IsInChannel
                                    http2ttRTS);

                                if (RpcStatus != RPC_S_OK)
                                    {
                                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                    break;
                                    }

                                // detach, abort and free lifetime reference
                                ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                                    TRUE,   // CalledFromUpcallContext
                                    TRUE,   // Abort
                                    RPC_P_CONNECTION_SHUTDOWN
                                    );

                                InChannelState.Mutex.Request();
                                // we haven't posted a receive yet - there is no
                                // way the state of the channel will change
                                if (ClientPacketType == http2coptD4_A10)
                                    ExpectedState = http2svOpened_A10W;
                                else
                                    ExpectedState = http2svOpened_B3W;

                                ASSERT(OutChannelState.State == ExpectedState);
                                // move channel state to opened
                                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                                OutChannelState.State = http2svOpened;
                                InChannelState.Mutex.Clear();

                                if (DataReceivePosted)
                                    {
                                    RpcStatus = PostReceiveOnDefaultChannel (
                                        FALSE,   // IsInChannel
                                        http2ttData
                                        );

                                    if (RpcStatus != RPC_S_OK)
                                        {
                                        AbortChannels(RPC_S_PROTOCOL_ERROR);
                                        }
                                    }

                                RpcStatus = RPC_P_PACKET_CONSUMED;
                                break;

                            default:
                                ASSERT(0);
                                RpcStatus = RPC_S_INTERNAL_ERROR;
                            }
                    }
                if (MutexReleased == FALSE)
                    {
                    InChannelState.Mutex.Clear();
                    }
                }
            else
                {
                RpcStatus = RPC_S_OK;
                // data packet - ownership of the buffer passes to the runtime
                BufferFreed = TRUE;
                }
            }
        }

CleanupAndExit:
    if (((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_PACKET_CONSUMED))
        || WakeOpenThread)
        {
        if ((InChannelState.State == http2svA3W)
            || (InChannelState.State == http2svC2W)
            || (InChannelState.State == http2svSearchProxy)
            || WakeOpenThread
            )
            {
            if (ClientOpenInEvent && (InOpenStatus != ERROR_IO_PENDING))
                SetClientOpenInEvent();
            else if (ClientOpenOutEvent && (OutOpenStatus != ERROR_IO_PENDING))
                SetClientOpenOutEvent();
            }
        }

    if (BufferFreed == FALSE)
        RpcFreeBuffer(Buffer);

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::SyncRecv (
    IN BYTE **Buffer,
    IN ULONG *BufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Do a sync receive on an HTTP connection.

Arguments:

    Buffer - if successful, points to a buffer containing the next PDU.
    BufferLength -  if successful, contains the length of the message.
    Timeout - the amount of time to wait for the receive. If -1, we wait
        infinitely.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ClientChannel *Channel;
    RPC_STATUS RpcStatus;
    BOOL AbortNeeded;
    BOOL IoPending;

    while (TRUE)
        {
        Channel = LockDefaultOutChannel(&ChannelPtr);
        if (Channel)
            {
            RpcStatus = Channel->SubmitSyncRecv(http2ttData);

            // keep a reference for the operations below
            Channel->AddReference();

            ChannelPtr->UnlockChannelPointer();

            IoPending = FALSE;

            if (RpcStatus == RPC_S_OK)
                {
                AbortNeeded = FALSE;
                RpcStatus = Channel->WaitForSyncRecv(Buffer,
                    BufferLength,
                    Timeout,
                    ConnectionTimeout,
                    this,
                    &AbortNeeded,
                    &IoPending
                    );
                }
            else
                {
                AbortNeeded = TRUE;
                }

            if (AbortNeeded)
                {
                Channel->Abort(RpcStatus);
                }

            if (IoPending)
                {
                Channel->WaitInfiniteForSyncReceive();
                Channel->RemoveEvent();
                }

            if (AbortNeeded)
                {
                if (ReissueRecv)
                    {
                    ReissueRecv = FALSE;
                    // we don't re-issue on time outs
                    if (RpcStatus != RPC_S_CALL_CANCELLED)
                        {
                        Channel->RemoveReference();
                        continue;
                        }
                    }
                else
                    {
//                    ASSERT(!"This test should not have failing receives\n");
                    }
                }

            Channel->RemoveReference();

            if (RpcStatus == RPC_S_OK)
                {
                ASSERT(*Buffer != NULL);
                ASSERT(IsBadWritePtr(*Buffer, 4) == FALSE);
                }

            if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
                || (RpcStatus == RPC_P_SEND_FAILED)
                || (RpcStatus == RPC_S_SERVER_UNAVAILABLE)
                || (RpcStatus == RPC_P_CONNECTION_CLOSED) )
                {
                RpcStatus = RPC_P_RECEIVE_FAILED;
                }

            break;
            }
        else
            {
            RpcStatus = RPC_P_RECEIVE_FAILED;
            break;
            }
        }

    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_RECEIVE_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_SEND_FAILED,
        RPC_P_CONNECTION_SHUTDOWN,
        RPC_P_TIMEOUT
        } END_VALIDATE;

    return RpcStatus;
}

void HTTP2ClientVirtualConnection::Abort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP connection and disconnects the channels.
    Must only come from the runtime.
    Note: Don't call any virtual methods in this function. It
    may be called in an environment without fully initialized
    vtable.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_CLIENT_VC, 0);

    // abort the channels themselves
    AbortChannels(RPC_P_CONNECTION_CLOSED);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return;

    HTTP2VirtualConnection::DisconnectChannels(FALSE, 0);

    // call destructor without freeing memory
    HTTP2ClientVirtualConnection::~HTTP2ClientVirtualConnection();
}

void HTTP2ClientVirtualConnection::Close (
    IN BOOL DontFlush
    )
/*++

Routine Description:

    Closes a client HTTP connection.
    Note: Don't call virtual functions in this method.
    It may be called in an environment without fully
    initialized vtable.

Arguments:

    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

--*/
{
    HTTP2ClientVirtualConnection::Abort();
}

RPC_STATUS HTTP2ClientVirtualConnection::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN BOOL IsFromUpcall,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for HTTP.

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    IsFromUpcall - non-zero if called from upcall context. Zero otherwise.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we were to use it on the server, we must protect
        the connection against async aborts.
    Called in upcall or runtime context only.

--*/
{
    HTTP2ClientInChannel *InChannel;
    int i;
    RPC_STATUS RpcStatus;

    if (TurnOn)
        CurrentKeepAlive = KAInterval;
    else
        CurrentKeepAlive = 0;

    // convert the timeout from runtime scale to transport scale
    if (Units == tuRuntime)
        {
        ASSERT(KATime.RuntimeUnits != RPC_C_BINDING_INFINITE_TIMEOUT);
        KATime.Milliseconds = ConvertRuntimeTimeoutToWSTimeout(KATime.RuntimeUnits);
        Units = tuMilliseconds;
        }

    // make the change on both channels
    for (i = 0; i < 2; i ++)
        {
        InChannel = (HTTP2ClientInChannel *)InChannels[i].LockChannelPointer();
        if (InChannel != NULL)
            {
            RpcStatus = InChannel->SetKeepAliveTimeout (
                TurnOn,
                bProtectIO,
                Units,
                KATime,
                KATime.Milliseconds
                );

            InChannels[i].UnlockChannelPointer();

            RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                IsFromUpcall
                );

            if (RpcStatus != RPC_S_OK)
                break;
            }
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::RecycleChannel (
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    An in channel recycle is initiated. This may be called
    in an upcall or runtime context.

Arguments:

    IsFromUpcall - non-zero if it comes from upcall. Zero otherwise.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2ClientInChannel *NewInChannel;
    int NonDefaultInChannelSelector;
    HTTP2ChannelPointer *NewInChannelPtr;
    HTTP2SendContext *D2_A1Context;
    BOOL UseWinHttp;

#if DBG
    DbgPrint("RPCRT4: %d Recycling IN channel\n", GetCurrentProcessId());
#endif

    UseWinHttp = ShouldUseWinHttp(HttpCredentials);

    // we shouldn't get recycle unless we're in an opened state
    ASSERT(InChannelState.State == http2svOpened);

    // create a new in channel
    RpcStatus = ClientOpenInternal (&ConnectionHint,
        TRUE,       // HintWasInitialize
        ConnectionTimeout,
        DefaultReplacementChannelCallTimeout,
        TRUE,       // ClientOpenInChannel,
        FALSE,      // ClientOpenOutChannel
        TRUE,       // IsReplacementChannel
        IsFromUpcall
        );

    if (RpcStatus != RPC_S_OK)
        {
        // ClientOpenInternal Aborts on failure. No need to abort
        // here
        return RpcStatus;
        }

    NonDefaultInChannelSelector = GetNonDefaultInChannelSelector();

    NewInChannelPtr = &InChannels[NonDefaultInChannelSelector];
    NewInChannel = (HTTP2ClientInChannel *)NewInChannelPtr->LockChannelPointer();

    if (NewInChannel == NULL)
        {
        Abort();
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    InChannelState.Mutex.Request();
    if (InChannelState.State != http2svOpened)
        {
        InChannelState.Mutex.Clear();
        NewInChannelPtr->UnlockChannelPointer();
        Abort();
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    // move to Opened_A4W in anticipation of the send we will make.
    InChannelState.State = http2svOpened_A4W;
    InChannelState.Mutex.Clear();

    D2_A1Context = AllocateAndInitializeD2_A1(HTTP2ProtocolVersion,
        &EmbeddedConnectionCookie,
        &InChannelCookies[DefaultInChannelSelector],
        &InChannelCookies[NonDefaultInChannelSelector]
        );
    if (D2_A1Context == NULL)
        {
        NewInChannelPtr->UnlockChannelPointer();
        Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcStatus = NewInChannel->Send(D2_A1Context);
    if (RpcStatus != RPC_S_OK)
        {
        NewInChannelPtr->UnlockChannelPointer();
        FreeRTSPacket(D2_A1Context);
        Abort();
        return RpcStatus;
        }

    if (!UseWinHttp)
        {
        RpcStatus = NewInChannel->Receive(http2ttRaw);
        }
    NewInChannelPtr->UnlockChannelPointer();

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        }

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::OpenReplacementOutChannel (
    void
    )
/*++

Routine Description:

    Opens a replacement out channel. Used during out channel
    recycling.

Arguments:

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2ClientOutChannel *NewOutChannel;
    int NonDefaultOutChannelSelector;
    HTTP2ChannelPointer *NewOutChannelPtr;
    HTTP2SendContext *D4_A3Context;
    KEEPALIVE_TIMEOUT KATime;

    // create a new out channel
    RpcStatus = ClientOpenInternal (&ConnectionHint,
        TRUE,       // HintWasInitialize
        ConnectionTimeout,
        DefaultReplacementChannelCallTimeout,
        FALSE,      // ClientOpenInChannel,
        TRUE,       // ClientOpenOutChannel
        TRUE,       // IsReplacementChannel
        TRUE        // IsFromUpcall
        );

    if (RpcStatus != RPC_S_OK)
        {
        // ClientOpenInternal has already aborted the connection
        return RpcStatus;
        }

    NonDefaultOutChannelSelector = GetNonDefaultOutChannelSelector();

    NewOutChannelPtr = &OutChannels[NonDefaultOutChannelSelector];
    NewOutChannel = (HTTP2ClientOutChannel *)NewOutChannelPtr->LockChannelPointer();

    if (NewOutChannel == NULL)
        {
        AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    InChannelState.Mutex.Request();
    if (OutChannelState.State != http2svOpened)
        {
        InChannelState.Mutex.Clear();
        NewOutChannelPtr->UnlockChannelPointer();
        AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
        return RPC_P_CONNECTION_SHUTDOWN;
        }

    // move to Opened_A6W in anticipation of the send we will make.
    OutChannelState.State = http2svOpened_A6W;
    InChannelState.Mutex.Clear();

    D4_A3Context = AllocateAndInitializeD4_A3(HTTP2ProtocolVersion,
        &EmbeddedConnectionCookie,
        &OutChannelCookies[DefaultOutChannelSelector],
        &OutChannelCookies[NonDefaultOutChannelSelector],
        HTTP2DefaultClientReceiveWindow
        );

    if (D4_A3Context == NULL)
        {
        NewOutChannelPtr->UnlockChannelPointer();
        AbortChannels(RPC_S_OUT_OF_MEMORY);
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcStatus = NewOutChannel->Send(D4_A3Context);
    if (RpcStatus != RPC_S_OK)
        {
        NewOutChannelPtr->UnlockChannelPointer();
        FreeRTSPacket(D4_A3Context);
        AbortChannels(RpcStatus);
        return RpcStatus;
        }

    if (CurrentKeepAlive)
        {
        KATime.Milliseconds = 0;
        RpcStatus = NewOutChannel->SetKeepAliveTimeout (
            TRUE,       // TurnOn
            FALSE,      // bProtectIO
            tuMilliseconds,
            KATime,
            CurrentKeepAlive
            );

        ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);
        }

    NewOutChannelPtr->UnlockChannelPointer();

    if (RpcStatus != RPC_S_OK)
        {
        AbortChannels(RpcStatus);
        }

    return RpcStatus;
}

void HTTP2ClientVirtualConnection::AbortChannels (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Aborts an HTTP connection but does not disconnect
    the channels. Can be called from above, upcall, or
    neutral context, but not from submit context!

Arguments:

    RpcStatus - the error to abort the channels with

Return Value:

--*/
{
    if (IgnoreAborts == FALSE)
        HTTP2VirtualConnection::AbortChannels (RpcStatus);
}

HTTP2Channel *HTTP2ClientVirtualConnection::LockDefaultSendChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the send channel. For client connections this is the in channel.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultOutChannel)

--*/
{
    return LockDefaultInChannel(ChannelPtr);
}

HTTP2Channel *HTTP2ClientVirtualConnection::LockDefaultReceiveChannel (
    OUT HTTP2ChannelPointer **ChannelPtr
    )
/*++

Routine Description:

    Locks the receive channel. For client connections this is the out channel.

Arguments:

    ChannelPtr - on success, the channel pointer to use.

Return Value:

    The locked channel or NULL (same semantics as LockDefaultInChannel)

--*/
{
    return LockDefaultOutChannel(ChannelPtr);
}

const int MaxOutChannelHeader = 300;

RPC_STATUS
RPC_ENTRY 
HTTP2ClientReadChannelHeader (
    IN WS_HTTP2_CONNECTION *Connection,
    IN ULONG BytesRead,
    OUT ULONG *NewBytesRead
    )
/*++

Routine Description:

    Read a channel HTTP header (usually some string). In success
    case, there is real data in Connection->pReadBuffer. The
    number of bytes there is in NewBytesRead

Arguments:

    Connection - the connection on which the header arrived.

    BytesRead - the bytes received from the net

    NewBytesRead - the bytes read from the channel (success only)

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    DWORD message_size;
    RPC_STATUS RpcStatus;
    char *CurrentPosition;
    char *LastPosition;     // first position after end
    char *LastPosition2;    // first position after end + 4
                            // useful for end-of-loop comparison
    char *StartPosition;
    char *HeaderEnd;        // first character after header end
    ULONG HTTPResponse;
    BYTE *NewBuffer;

    BytesRead += Connection->iLastRead;

    // we have read something. Let's process it now.
    // search for double CR-LF (\r\n\r\n)
    StartPosition = (char *)(Connection->pReadBuffer);
    LastPosition = StartPosition + BytesRead;
    LastPosition2 = LastPosition + 4;
    HeaderEnd = NULL;
    CurrentPosition = (char *)(Connection->pReadBuffer);

    while (CurrentPosition < LastPosition2)
        {
        if ((*CurrentPosition == '\r')
            && (*(CurrentPosition + 1) == '\n')
            && (*(CurrentPosition + 2) == '\r')
            && (*(CurrentPosition + 3) == '\n')
           )
            {
            // we have a full header
            HeaderEnd = CurrentPosition + 4;
            break;
            }

        CurrentPosition ++;
        }

    if (CurrentPosition - StartPosition >= MaxOutChannelHeader)
        {
        // we should have seen the header by now. Abort. Returning
        // failure is enough - we know the caller will abort
        return RPC_S_PROTOCOL_ERROR;
        }

    if (HeaderEnd == NULL)
        {
        // we didn't find the end of the header. Submit another receive
        // for the rest
        RpcStatus = TransConnectionReallocPacket(Connection,
                                              &Connection->pReadBuffer,
                                              BytesRead,
                                              MaxOutChannelHeader);

        if (RpcStatus != RPC_S_OK)
            {
            ASSERT(RpcStatus == RPC_S_OUT_OF_MEMORY);
            return(RpcStatus);
            }

        Connection->iLastRead = BytesRead;
        Connection->maxReadBuffer = MaxOutChannelHeader;
        return RPC_P_PARTIAL_RECEIVE;
        }

    // we have found the header end. Grab the status code
    HTTPResponse = HttpParseResponse(StartPosition);
    if ((HTTPResponse >= RPC_S_INVALID_STRING_BINDING) && (HTTPResponse <= RPC_X_BAD_STUB_DATA))
        {
        // if it is an RPC error code, just return it.
        return HTTPResponse;
        }

    if (HTTPResponse != 200)
        return RPC_S_PROTOCOL_ERROR;

    // check whether we have something else besides the HTTP header
    if (HeaderEnd < LastPosition)
        {
        NewBuffer = TransConnectionAllocatePacket(Connection,
                                                   LastPosition - HeaderEnd);

        if (0 == NewBuffer)
            return RPC_S_OUT_OF_MEMORY;

        RpcpMemoryCopy(NewBuffer, HeaderEnd, LastPosition - HeaderEnd);
        *NewBytesRead = LastPosition - HeaderEnd;

        RpcFreeBuffer(Connection->pReadBuffer);
        Connection->pReadBuffer = NewBuffer;
        Connection->maxReadBuffer = LastPosition - HeaderEnd;
        Connection->iLastRead = 0;
        Connection->HeaderRead = TRUE;

        return RPC_S_OK;
        }

    // reset the pointer. By doing so we forget all we have 
    // read so far (which is only the HTTP header anyway)
    Connection->iLastRead = 0;
    Connection->HeaderRead = TRUE;
    return RPC_P_PARTIAL_RECEIVE;
}

// this is a bit mask. For any particular scheme, AND it with the constant
// Non-zero means it is multillegged. Schemes are:
// Scheme                             Value             Multilegged
// RPC_C_HTTP_AUTHN_SCHEME_BASIC      0x00000001        0
// RPC_C_HTTP_AUTHN_SCHEME_NTLM       0x00000002        1
// RPC_C_HTTP_AUTHN_SCHEME_PASSPORT   0x00000004        1
// RPC_C_HTTP_AUTHN_SCHEME_DIGEST     0x00000008        1
// RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE  0x00000010        1

const ULONG MultiLeggedSchemeMap = 
    RPC_C_HTTP_AUTHN_SCHEME_NTLM
    | RPC_C_HTTP_AUTHN_SCHEME_PASSPORT
    | RPC_C_HTTP_AUTHN_SCHEME_DIGEST
    | RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE;

/*
    All client opened types are valid initial states. The transitions are:

    cotSearchProxy ------+----> cotUknownAuth
                         |
        +----------------+---------------+
        |                |               |
    cotMLAuth       cotSLAuth       cotNoAuth
        |
    cotMLAuth2

 */

typedef enum tagClientOpenTypes
{
    cotSearchProxy,
    cotNoAuth,
    cotMLAuth,
    cotMLAuth2,
    cotSLAuth,
    cotUnknownAuth,
    cotInvalid
} ClientOpenTypes;

const char *InHeaderVerb = "RPC_IN_DATA";
const int InHeaderVerbLength = 11;    // length of RPC_IN_DATA

const char *OutHeaderVerb = "RPC_OUT_DATA";
const int OutHeaderVerbLength = 12;    // length of RPC_OUT_DATA

const BYTE EchoData[4] = {0xF8, 0xE8, 0x18, 0x08};
const ULONG EchoDataLength = sizeof(EchoData);

RPC_STATUS HTTP2ClientVirtualConnection::ClientOpenInternal (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN UINT ConnTimeout,
    IN ULONG CallTimeout,
    IN BOOL ClientOpenInChannel,
    IN BOOL ClientOpenOutChannel,
    IN BOOL IsReplacementChannel,
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Opens a client side virtual connection.

Arguments:

    Hint - the resolver hint

    HintWasInitialized - the hint was initialized on input.

    ConnTimeout - connection timeout

    CallTimeout - operation timeout

    ClientOpenInChannel - non-zero if the in channel is to be opened.

    ClientOpenOutChannel - non-zero if the out channel is to be
        opened.

    IsReplacementChannel - non-zero if this is channel recycling

    IsFromUpcall - non-zero if this is called from an upcall. Zero otherwise.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2ClientInChannel *NewInChannel;
    HTTP2ClientOutChannel *NewOutChannel;
    BOOL InChannelLocked;
    BOOL OutChannelLocked;
    HTTP2SendContext *OutChannelSendContext = NULL;
    HTTP2SendContext *InChannelSendContext = NULL;
    ULONG WaitResult;
    HANDLE LocalClientOpenEvent;
    BOOL UseWinHttp;
    KEEPALIVE_TIMEOUT KATimeout;
    BOOL RebuildInChannel;
    BOOL RebuildOutChannel;
    BOOL NukeInChannel;
    BOOL NukeOutChannel;
    BOOL ResetInChannel;
    BOOL ResetOutChannel;
    BOOL SendInChannel;
    BOOL SendOutChannel;
    BOOL OpenInChannel;
    BOOL OpenOutChannel;
    BOOL ReceiveInChannel;
    BOOL ReceiveOutChannel;
    RPCProxyAccessType StoredAccessType;
    const char *VerbToUse;
    int VerbLengthToUse;
    const BYTE *AdditionalDataToUse;
    ULONG AdditionalDataLengthToUse;
    HTTP2StateValues NewConnectionState = http2svInvalid;
    BOOL SetNewConnectionState;
    RPC_STATUS LocalInOpenStatus;
    RPC_STATUS LocalOutOpenStatus;
    ULONG InChosenAuthScheme;
    ULONG OutChosenAuthScheme;
    BOOL IsKeepAlive;
    BOOL IsDone;
    int NonDefaultInChannelSelector;
    int NonDefaultOutChannelSelector;
    HTTP2ChannelPointer *InChannelPtr;
    HTTP2ChannelPointer *OutChannelPtr;
    ClientOpenTypes InOpenType;
    ClientOpenTypes OutOpenType;
    ClientOpenTypes OldOpenType;
    ClientOpenTypes OldInOpenType;
    ClientOpenTypes OldOutOpenType;
    int CurrentCase;
#if DBG
    int NumberOfRetries = 0;
#endif

    if (IsReplacementChannel == FALSE)
        {
        if (ConnTimeout != RPC_C_BINDING_INFINITE_TIMEOUT)
            {
            ASSERT(   ((long)ConnTimeout >= RPC_C_BINDING_MIN_TIMEOUT)
                   && (ConnTimeout <= RPC_C_BINDING_MAX_TIMEOUT));

            // convert the timeout from runtime scale to transport scale
            ConnectionTimeout = ConvertRuntimeTimeoutToWSTimeout(ConnTimeout);
            }
        else
            {
            ConnectionTimeout = INFINITE;
            }
        }

    UseWinHttp = ShouldUseWinHttp(HttpCredentials);

    if (UseWinHttp)
        {
        RpcStatus = InitWinHttpIfNecessary();
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }

    InOpenType = OutOpenType = cotInvalid;

    InChosenAuthScheme = 0;
    OutChosenAuthScheme = 0;

    IsDone = FALSE;

    if (HttpCredentials)
        {
        // WinHttp5.x does not support pre-auth for digest. This means that even if
        // you know that digest is your scheme, you have to pretend that you don't
        // and wait for the challenge before you choose it. Otherwise WinHttp5.x will
        // complain and fail.
        if ((HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME)
            && (*(HttpCredentials->AuthnSchemes) != RPC_C_HTTP_AUTHN_SCHEME_DIGEST))
            {
            OutChosenAuthScheme = InChosenAuthScheme = *(HttpCredentials->AuthnSchemes);
            if (ClientOpenInChannel)
                {
                if (InChosenAuthScheme & MultiLeggedSchemeMap)
                    InOpenType = cotMLAuth;
                else
                    InOpenType = cotSLAuth;
                }

            if (ClientOpenOutChannel)
                {
                if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                    OutOpenType = cotMLAuth;
                else
                    OutOpenType = cotSLAuth;
                }
            }
        }
    else if (IsReplacementChannel == FALSE)
        {
        ASSERT(OutOpenType == cotInvalid);

        InOpenType = OutOpenType = cotNoAuth;
        }
    else if (ClientOpenInChannel)
        {
        InOpenType = cotNoAuth;
        IsDone = TRUE;
        }
    else
        {
        OutOpenType = cotNoAuth;
        IsDone = TRUE;
        }

    LocalClientOpenEvent = CreateEvent(NULL,        // lpEventAttributes
        FALSE,      // bManualReset
        FALSE,      // bInitialState
        NULL        // lpName
        );

    if (LocalClientOpenEvent == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (IsReplacementChannel == FALSE)
        {
        RpcStatus = EmbeddedConnectionCookie.Create();

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;
        }
    else
        {
        if (ClientOpenInChannel)
            NonDefaultInChannelSelector = GetNonDefaultInChannelSelector();
        else
            {
            ASSERT(ClientOpenOutChannel);
            NonDefaultOutChannelSelector = GetNonDefaultOutChannelSelector();
            }
        }

    if (ClientOpenInChannel)
        {
        if (IsReplacementChannel)
            RpcStatus = InChannelCookies[NonDefaultInChannelSelector].Create();
        else
            RpcStatus = InChannelCookies[0].Create();

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;
        }

    if (ClientOpenOutChannel)
        {
        if (IsReplacementChannel)
            RpcStatus = OutChannelCookies[NonDefaultOutChannelSelector].Create();
        else
            RpcStatus = OutChannelCookies[0].Create();

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;
        }

    if (ClientOpenInChannel)
        {
        RebuildInChannel = TRUE;
        NukeInChannel = FALSE;
        ResetInChannel = FALSE;
        OpenInChannel = TRUE;
        InOpenStatus = ERROR_IO_PENDING;
        }
    else
        {
        RebuildInChannel = FALSE;
        NukeInChannel = FALSE;
        ResetInChannel = FALSE;
        OpenInChannel = FALSE;
        ReceiveInChannel = FALSE;
        }

    InChannelLocked = FALSE;

    if (ClientOpenOutChannel)
        {
        RebuildOutChannel = TRUE;
        NukeOutChannel = FALSE;
        ResetOutChannel = FALSE;
        OpenOutChannel = TRUE;
        // receive is done below
        OutOpenStatus = ERROR_IO_PENDING;
        }
    else
        {
        RebuildOutChannel = FALSE;
        NukeOutChannel = FALSE;
        ResetOutChannel = FALSE;
        OpenOutChannel = FALSE;
        ReceiveOutChannel = FALSE;
        }

    OutChannelLocked = FALSE;

    SetNewConnectionState = FALSE;

    ClientOpenInEvent = ClientOpenOutEvent = LocalClientOpenEvent;

    ASSERT(InChosenAuthScheme == OutChosenAuthScheme);

    // do we know whether to use a proxy?
    StoredAccessType = Hint->AccessType;
    if (StoredAccessType == rpcpatUnknown)
        {
        // this should never happen for replacement channels
        ASSERT(IsReplacementChannel == FALSE);

        // we don't.
        InOpenType = OutOpenType = cotSearchProxy;

        // move to http2svSearchProxy
        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svSearchProxy, 1, 0);
        InChannelState.State = http2svSearchProxy;

        SendInChannel = FALSE;
        SendOutChannel = FALSE;

        ReceiveInChannel = TRUE;
        ReceiveOutChannel = TRUE;
        }
    else
        {
        // we know. Do we know what authentication to use?
        if (InChosenAuthScheme)
            {
            ASSERT(InChosenAuthScheme == OutChosenAuthScheme);
            if (InChosenAuthScheme & MultiLeggedSchemeMap)
                {
                if (ClientOpenInChannel)
                    InOpenType = cotMLAuth;
                else
                    InOpenType = cotInvalid;

                if (ClientOpenOutChannel)
                    {
                    OutOpenType = cotMLAuth;
                    ReceiveOutChannel = TRUE;
                    }
                else
                    {
                    OutOpenType = cotInvalid;
                    ReceiveOutChannel = FALSE;
                    }
                }
            else
                {
                if (ClientOpenInChannel)
                    {
                    InOpenType = cotSLAuth;
                    if (IsReplacementChannel)
                        IsDone = TRUE;
                    }
                else
                    InOpenType = cotInvalid;

                if (ClientOpenOutChannel)
                    {
                    OutOpenType = cotSLAuth;
                    if (IsReplacementChannel)
                        {
                        ReceiveOutChannel = FALSE;
                        IsDone = TRUE;
                        }
                    else
                        ReceiveOutChannel = TRUE;
                    }
                else
                    {
                    OutOpenType = cotInvalid;
                    ReceiveOutChannel = FALSE;
                    }
                }
            }
        else
            {
            if (ClientOpenInChannel)
                {
                if (InOpenType != cotNoAuth)
                    InOpenType = cotUnknownAuth;
                }
            else 
                InOpenType = cotInvalid;

            if (ClientOpenOutChannel)
                {
                if (OutOpenType != cotNoAuth)
                    {
                    OutOpenType = cotUnknownAuth;
                    ReceiveOutChannel = TRUE;
                    }
                else if (IsReplacementChannel)
                    ReceiveOutChannel = FALSE;
                else
                    ReceiveOutChannel = TRUE;
                }
            else
                {
                OutOpenType = cotInvalid;
                ReceiveOutChannel = FALSE;
                }
            }

        if (IsReplacementChannel == FALSE)
            {
            // move to http2svA3W
            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svA3W, 1, 0);
            InChannelState.State = http2svA3W;
            }

        if (
            (
             (InOpenType == cotSLAuth)
             || 
             (InOpenType == cotNoAuth)
            )
            &&
            (IsReplacementChannel == FALSE)
           )
            {
            SendInChannel = TRUE;
            }
        else
            SendInChannel = FALSE;

        if (
            (
             (OutOpenType == cotSLAuth)
             || 
             (OutOpenType == cotNoAuth)
            )
            &&
            (IsReplacementChannel == FALSE)
           )
            {
            SendOutChannel = TRUE;
            }
        else
            SendOutChannel = FALSE;

        // 3 cases for the receive on the in channel
        // 1. If we don't use WinHttp and this is the first open or is in channel replacement, 
        //    we post a receive on this channel
        // 2. If this is a single legged operation, or this is a replacement channel we don't
        //    post a receive.
        // 3. All other cases (we use WinHttp and this is MLAuth/UnknownAuth) we post a receive
        if (ClientOpenInChannel)
            {
            if (!UseWinHttp)
                ReceiveInChannel = TRUE;
            else if ((InOpenType == cotNoAuth) || (InOpenType == cotSLAuth))
                ReceiveInChannel = FALSE;
            else
                ReceiveInChannel = TRUE;
            }
        else
            ReceiveInChannel = FALSE;
        }

    IgnoreAborts = TRUE;

    while (TRUE)
        {
#if DBG_ERROR
        DbgPrint("Starting loop iteration ....\n");
        NumberOfRetries ++;
        ASSERT (NumberOfRetries < 10);
#endif
        if (ClientOpenInChannel == FALSE)
            {
            // if we were told not to touch the in channel, make
            // sure we don't
            ASSERT(RebuildInChannel == FALSE
                && NukeInChannel == FALSE
                && ResetInChannel == FALSE
                && SendInChannel == FALSE
                && OpenInChannel == FALSE
                && ReceiveInChannel == FALSE);
            }

        if (ClientOpenOutChannel == FALSE)
            {
            // if we were told not to touch the out channel, make 
            // sure we don't
            ASSERT(RebuildOutChannel == FALSE
                && NukeOutChannel == FALSE
                && ResetOutChannel == FALSE
                && SendOutChannel == FALSE
                && OpenOutChannel == FALSE
                && ReceiveOutChannel == FALSE);
            }

        if (NukeInChannel)
            {
            if (IsReplacementChannel)
                InChannelPtr = &InChannels[NonDefaultInChannelSelector];
            else
                InChannelPtr = &InChannels[0];

            InChannelPtr->FreeChannelPointer(TRUE,      // DrainUpCalls
                IsReplacementChannel,      // CalledFromUpcallContext
                TRUE,       // Abort
                RPC_P_CONNECTION_SHUTDOWN   // AbortStatus
                );

            InOpenStatus = ERROR_IO_PENDING;
            }

        if (NukeOutChannel)
            {
            if (IsReplacementChannel)
                OutChannelPtr = &OutChannels[NonDefaultOutChannelSelector];
            else
                OutChannelPtr = &OutChannels[0];

            OutChannelPtr->FreeChannelPointer(TRUE,      // DrainUpCalls
                IsReplacementChannel,      // CalledFromUpcallContext
                TRUE,       // Abort
                RPC_P_CONNECTION_SHUTDOWN   // AbortStatus
                );

            OutOpenStatus = ERROR_IO_PENDING;
            }

        // after both channels are nuked, see whether we need to change the
        // connection state. We have to do this after nuking the channels
        // to avoid a race in ReceiveComplete where late receives may
        // see a different state
        if (SetNewConnectionState)
            {
            ASSERT(NewConnectionState != http2svInvalid);
            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, NewConnectionState, 1, 0);
            InChannelState.State = NewConnectionState;
            SetNewConnectionState = FALSE;
            }

        if (RebuildInChannel)
            {
            if (StoredAccessType == rpcpatUnknown)
                {
                ASSERT((InOpenType == cotSearchProxy)
                    || (InOpenType == cotMLAuth)
                    || (InOpenType == cotSLAuth)
                    );
                // if we don't know the type yet, try
                // direct for the in, proxy for the out.
                // One of them will work.
                Hint->AccessType = rpcpatDirect;
                }

            // initialize in channel
            RpcStatus = AllocateAndInitializeInChannel(Hint,
                HintWasInitialized,
                CallTimeout,
                UseWinHttp,
                &NewInChannel
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                {
                goto AbortAndExit;
                }

            if (IsReplacementChannel)
                SetNonDefaultInChannel(NewInChannel);
            else
                SetFirstInChannel(NewInChannel);
            }

        if (RebuildOutChannel)
            {
            if (StoredAccessType == rpcpatUnknown)
                {
                ASSERT((OutOpenType == cotSearchProxy)
                    || (OutOpenType == cotMLAuth)
                    || (OutOpenType == cotSLAuth)
                    );
                // if we don't know the type yet, try
                // direct for the in, proxy for the out.
                // One of them will work.
                Hint->AccessType = rpcpatHTTPProxy;
                }

            // initialize out channel
            RpcStatus = AllocateAndInitializeOutChannel(Hint,
                TRUE,   // HintWasInitialized
                CallTimeout,
                UseWinHttp,
                &NewOutChannel
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                {
                goto AbortAndExit;
                }

            if (IsReplacementChannel)
                SetNonDefaultOutChannel(NewOutChannel);
            else
                SetFirstOutChannel(NewOutChannel);
            }

        // at least one channel must wait for something to happen
        if (IsReplacementChannel == FALSE)
            {
            ASSERT((InOpenStatus == ERROR_IO_PENDING)
                || (OutOpenStatus == ERROR_IO_PENDING));
            }
        else if (ClientOpenInChannel)
            {
            ASSERT(InOpenStatus == ERROR_IO_PENDING);
            }
        else
            {
            ASSERT(ClientOpenOutChannel);
            ASSERT(OutOpenStatus == ERROR_IO_PENDING);
            }

        if (ResetInChannel || OpenInChannel || SendInChannel)
            {
            // Lock channel

            // after calling ClientOpen, we may be aborted asynchronously at any moment.
            // we will have pending async operations soon. Do the channel access by the
            // book. 
            if (IsReplacementChannel)
                InChannelPtr = &InChannels[NonDefaultInChannelSelector];
            else
                InChannelPtr = &InChannels[0];

            NewInChannel = (HTTP2ClientInChannel *)InChannelPtr->LockChannelPointer();

            if (NewInChannel == NULL)
                {
                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                goto AbortAndExit;
                }

            InChannelLocked = TRUE;
            }

        // Nuke and rebuild are mutually exclusive with Reset
        if (ResetInChannel)
            {
            ASSERT(NukeInChannel == FALSE);
            ASSERT(RebuildInChannel == FALSE);

            NewInChannel->Reset();
            }

        if (OpenInChannel)
            {
            // do we do in_data or echo's?
            if ((InOpenType == cotSearchProxy)
                || (InOpenType == cotMLAuth)
                || (InOpenType == cotUnknownAuth)
                )
                {
                AdditionalDataToUse = EchoData;
                AdditionalDataLengthToUse = EchoDataLength;
                if (StoredAccessType == rpcpatUnknown)
                    {
                    // if we don't know the type yet, try
                    // direct for the in, proxy for the out.
                    // One of them will work.
                    Hint->AccessType = rpcpatDirect;
                    }
                }
            else
                {
                ASSERT((InOpenType == cotSLAuth)
                    || (InOpenType == cotNoAuth)
                    || (InOpenType == cotMLAuth2)
                    );
                ASSERT(StoredAccessType != rpcpatUnknown);
                if (IsReplacementChannel == FALSE)
                    {
                    ASSERT(SendInChannel);
                    }
                else
                    {
                    ASSERT(SendInChannel == FALSE);
                    }
                AdditionalDataToUse = NULL;
                AdditionalDataLengthToUse = 0;
                }

            if (IsReplacementChannel == FALSE)
                {
                RpcStatus = NewInChannel->Unplug();
                // since no sends have been done yet, unplugging cannot fail here
                ASSERT(RpcStatus == RPC_S_OK);
                }

            RpcStatus = NewInChannel->ClientOpen(Hint,
                InHeaderVerb,
                InHeaderVerbLength,
                UseWinHttp,
                HttpCredentials,
                InChosenAuthScheme,
                CallTimeout,
                AdditionalDataToUse,
                AdditionalDataLengthToUse
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;
            }

        if (ResetOutChannel || OpenOutChannel || SendOutChannel)
            {
            if (IsReplacementChannel)
                OutChannelPtr = &OutChannels[NonDefaultOutChannelSelector];
            else
                OutChannelPtr = &OutChannels[0];

            NewOutChannel = (HTTP2ClientOutChannel *)OutChannelPtr->LockChannelPointer();

            if (NewOutChannel == NULL)
                {
                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                goto AbortAndExit;
                }

            OutChannelLocked = TRUE;
            }

        // Nuke and rebuild are mutually exclusive with Reset
        if (ResetOutChannel)
            {
            ASSERT(NukeOutChannel == FALSE);
            ASSERT(RebuildOutChannel == FALSE);

            NewOutChannel->Reset();
            }

        if (OpenOutChannel)
            {
            // do we do out_data or echo's?
            if ((OutOpenType == cotSearchProxy)
                || (OutOpenType == cotMLAuth)
                || (OutOpenType == cotUnknownAuth)
                )
                {
                AdditionalDataToUse = EchoData;
                AdditionalDataLengthToUse = 0;
                AdditionalDataLengthToUse = EchoDataLength;
                if (StoredAccessType == rpcpatUnknown)
                    {
                    // if we don't know the type yet, try
                    // direct for the in, proxy for the out.
                    // One of them will work.
                    Hint->AccessType = rpcpatHTTPProxy;
                    }
                }
            else
                {
                ASSERT((OutOpenType == cotNoAuth)
                    || (OutOpenType == cotSLAuth)
                    || (OutOpenType == cotMLAuth2)
                    );
                ASSERT(StoredAccessType != rpcpatUnknown);
                if (IsReplacementChannel == FALSE)
                    {
                    ASSERT(SendOutChannel);
                    }
                else
                    {
                    ASSERT(SendOutChannel == FALSE);
                    }
                AdditionalDataToUse = NULL;
                AdditionalDataLengthToUse = 0;
                }

            RpcStatus = NewOutChannel->ClientOpen(Hint,
                OutHeaderVerb,
                OutHeaderVerbLength,
                IsReplacementChannel,   // ReplacementChannel
                UseWinHttp,
                HttpCredentials,
                OutChosenAuthScheme,
                CallTimeout,
                AdditionalDataToUse,
                AdditionalDataLengthToUse
                );

            // restore the access type
            if (StoredAccessType == rpcpatUnknown)
                {
                Hint->AccessType = StoredAccessType;
                }

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;
            }

        if (SendInChannel)
            {
            // should not happen during replacement
            ASSERT(IsReplacementChannel == FALSE);

            InChannelSendContext = AllocateAndInitializeD1_B1(HTTP2ProtocolVersion,
                &EmbeddedConnectionCookie,
                &InChannelCookies[0],
                DefaultChannelLifetime,
                DefaultClientKeepAliveInterval,
                &Hint->AssociationGroupId
                );

            if (InChannelSendContext == NULL)
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                goto AbortAndExit;
                }

            RpcStatus = NewInChannel->Send(InChannelSendContext);

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;

            // we don't own this buffer now
            InChannelSendContext = NULL;
            }

        if (SendOutChannel)
            {
            // should not happen during replacement
            ASSERT(IsReplacementChannel == FALSE);

            OutChannelSendContext = AllocateAndInitializeD1_A1(HTTP2ProtocolVersion,
                &EmbeddedConnectionCookie,
                &OutChannelCookies[0],
                HTTP2DefaultClientReceiveWindow
                );

            if (OutChannelSendContext == NULL)
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                goto AbortAndExit;
                }

            RpcStatus = NewOutChannel->Send(OutChannelSendContext);

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;

            // we don't own this buffer anymore
            OutChannelSendContext = NULL;
            }

        // post receives on both channels
        if (ReceiveOutChannel)
            {
            RpcStatus = NewOutChannel->Receive(http2ttRTS);

            if (RpcStatus != RPC_S_OK)
                {
                goto AbortAndExit;
                }
            }

        if (ReceiveInChannel)
            {
            RpcStatus = NewInChannel->Receive(http2ttRaw);

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;
            }

        if (ResetInChannel || OpenInChannel || SendInChannel)
            {
            ASSERT(InChannelLocked);

            InChannelPtr->UnlockChannelPointer();

            InChannelLocked = FALSE;
            // channel is unlocked. Can't touch it
            NewInChannel = NULL;
            }

        if (ResetOutChannel || OpenOutChannel || SendOutChannel)
            {
            ASSERT(OutChannelLocked);

            OutChannelPtr->UnlockChannelPointer();

            OutChannelLocked = FALSE;
            // channel is unlocked. Can't touch it
            NewOutChannel = NULL;
            }

        if (IsDone)
            {
            RpcStatus = RPC_S_OK;
            break;
            }

        // no authentication and single leg authentication are
        // completed in one leg. Make sure we don't loop around
        // with them for replacement case
        if (ClientOpenInChannel && IsReplacementChannel)
            {
            ASSERT(InOpenType != cotNoAuth);
            ASSERT(InOpenType != cotSLAuth);
            ASSERT(InOpenType != cotMLAuth2);
            }

        if (ClientOpenOutChannel && IsReplacementChannel)
            {
            ASSERT(OutOpenType != cotNoAuth);
            ASSERT(OutOpenType != cotSLAuth);
            ASSERT(OutOpenType != cotMLAuth2);
            }
WaitAgain:
        // wait for something to happen
        WaitResult = WaitForSingleObject(LocalClientOpenEvent, CallTimeout);

        if (WaitResult == WAIT_TIMEOUT)
            {
            RpcStatus = RPC_S_CALL_CANCELLED;
            goto AbortAndExit;
            }

        ASSERT(WaitResult == WAIT_OBJECT_0);

        // there is race where we could have picked up a channel's event
        // after we waited (e.g. two channels completed immediately after each
        // other). In such case, there wouldn't be anything on any channel - wait
        // again. This race exists only if we do initial connect.
        if (IsReplacementChannel == FALSE)
            {
            if ((InOpenStatus == ERROR_IO_PENDING)
                && (OutOpenStatus == ERROR_IO_PENDING))
                {
                goto WaitAgain;
                }
            }

        OldInOpenType = InOpenType;
        OldOutOpenType = OutOpenType;

        // analyze what happened

        // If we are in a non-terminal state, check what transitions we
        // need to make to a terminal state
        if (ClientOpenOutChannel 
            &&
            (
             (OutOpenType == cotSearchProxy) 
             || 
             (OutOpenType == cotUnknownAuth)
            )
           )
            {
            OldOpenType = OutOpenType;

            // We can be here in 3 cases:
            // 1. We're searching for a proxy during initial open
            // 2. We don't know the auth type during initial open
            // 3. We recycle the out channel with unknown auth type

            // The events of interest are:
            // 1. If we are in case 2, and the channel is still pending,
            // skip the channel.
            // 2. If we're in the remainder of case 2 or we're in 3, or
            // (we're in 1 and the in channel is not positive yet and we
            // have given it enough time to come in, and we have a positive
            // response on this channel), the result is final.
            // 3. In case 1, if this channel has a negative response, fall through
            // to both channel check
            // 4. In case 1, if the other channel has come in, fall through

            // capture the out open status to get a consistent view of it in
            // the ifs below
            LocalOutOpenStatus = OutOpenStatus;

            if (OutOpenType == cotSearchProxy)
                {
                ASSERT(IsReplacementChannel == FALSE);
                CurrentCase = 1;
                }
            else if (IsReplacementChannel == FALSE)
                {
                ASSERT(OutOpenType == cotUnknownAuth);
                CurrentCase = 2;
                }
            else
                {
                ASSERT(IsReplacementChannel);
                ASSERT(OutOpenType == cotUnknownAuth);
                CurrentCase = 3;
                }

            if ((CurrentCase == 2)
                && (LocalOutOpenStatus == ERROR_IO_PENDING))
                {
                NukeOutChannel = FALSE;
                RebuildOutChannel = FALSE;
                ResetOutChannel = FALSE;
                OpenOutChannel = FALSE;
                ReceiveOutChannel = FALSE;
                SendOutChannel = FALSE;
                }
            else if 
                (
                 (CurrentCase == 2)
                 ||
                 (CurrentCase == 3)
                 || 
                 (
                  // positive response on case 1
                  (CurrentCase == 1)
                  &&
                  (!IsInChannelPositiveWithWait())
                  &&
                  (
                   (LocalOutOpenStatus == RPC_S_OK)
                   ||
                   (LocalOutOpenStatus == RPC_P_AUTH_NEEDED)
                  )
                 )
                )
                {
                // We'll be here in 3 cases
                // 1. We don't know the auth type during initial open and we have
                // a response on the channel
                // 2. We recycle the out channel with unknown auth type
                // 3. We search for a proxy and this channel will be chosen

                // the status is final
                if ((LocalOutOpenStatus != RPC_S_OK)
                    && (LocalOutOpenStatus != RPC_P_AUTH_NEEDED))
                    {
                    RpcStatus = LocalOutOpenStatus;
                    goto AbortAndExit;
                    }

                // In all cases the auth scheme is final for the new channel and we
                // need to continue authentication

                // if we haven't chosen a scheme yet, choose it now
                if (OutChosenAuthScheme == 0)
                    {
                    OutChosenAuthScheme = GetOutChannelChosenScheme(IsReplacementChannel);
                    }

                if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                    {
                    // milti legged authentication implies keep alives
                    IsKeepAlive = TRUE;
                    OutOpenType = cotMLAuth;

                    // we need only reset, open, send and receive
                    NukeOutChannel = FALSE;
                    RebuildOutChannel = FALSE;
                    ResetOutChannel = TRUE;
                    OpenOutChannel = TRUE;
                    SendOutChannel = FALSE;
                    ReceiveOutChannel = TRUE;
                    }
                else
                    {
                    // SSL always supports keep alives
                    if (HttpCredentials && HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
                        IsKeepAlive = TRUE;
                    else
                        {
                        IsKeepAlive = IsOutChannelKeepAlive(IsReplacementChannel);
                        }

                    if (OutChosenAuthScheme)
                        OutOpenType = cotSLAuth;
                    else
                        OutOpenType = cotNoAuth;
                    if (IsKeepAlive)
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeOutChannel = FALSE;
                        RebuildOutChannel = FALSE;
                        ResetOutChannel = TRUE;
                        }
                    else
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeOutChannel = TRUE;
                        RebuildOutChannel = TRUE;
                        ResetOutChannel = FALSE;
                        }

                    OpenOutChannel = TRUE;
                    if (IsReplacementChannel)
                        {
                        ReceiveOutChannel = FALSE;

                        // should be done on next iteration
                        IsDone = TRUE;
                        }
                    else
                        {
                        SendOutChannel = TRUE;
                        ReceiveOutChannel = TRUE;
                        }

                    }
                OutOpenStatus = ERROR_IO_PENDING;

                if (InOpenType == cotSearchProxy)
                    {
                    // we need to nuke, rebuild, open, send, possibly receive in channel
                    NukeInChannel = TRUE;
                    RebuildInChannel = TRUE;
                    ResetInChannel = FALSE;
                    OpenInChannel = TRUE;
                    SendInChannel = FALSE;
                    ReceiveInChannel = TRUE;

                    // if we have already chosen an auth scheme, presumably
                    // because of RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME, set it
                    if (InChosenAuthScheme)
                        {
                        ASSERT(IsReplacementChannel == FALSE);
                        ASSERT(HttpCredentials);
                        ASSERT(HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME);

                        if (InChosenAuthScheme & MultiLeggedSchemeMap)
                            InOpenType = cotMLAuth;
                        else
                            {
                            InOpenType = cotSLAuth;
                            SendInChannel = TRUE;
                            }
                        }
                    else
                        InOpenType = cotUnknownAuth;

                    StoredAccessType = rpcpatHTTPProxy;
                    Hint->AccessType = rpcpatHTTPProxy;
                    }

                if (IsReplacementChannel == FALSE)
                    {
                    // change the connection and channel state
                    SetNewConnectionState = TRUE;
                    NewConnectionState = http2svA3W;
                    }

                if ((OldOpenType == cotSearchProxy) || IsReplacementChannel)
                    continue;
                else
                    {
                    // we were doing initial open with cotUnknownAuth
                    // fall through to the in channel handling code to see
                    // what is it up to
                    }
                }
            else
                {
                // events 3 and 4. We're searching for the proxy and
                // either this channel came with a negative response or
                // the other channel came in
                ASSERT(CurrentCase == 1);
                ASSERT(IsReplacementChannel == FALSE);
                ASSERT(OutOpenType == cotSearchProxy);
                ASSERT(
                       (
                        (LocalOutOpenStatus != RPC_S_OK)
                        && 
                        (LocalOutOpenStatus != RPC_P_AUTH_NEEDED)
                       )
                       ||
                       (
                        (InOpenStatus == RPC_S_OK)
                        ||
                        (InOpenStatus == RPC_P_AUTH_NEEDED)
                       )
                      );

                // fall through to the in channel check
                }
            }

        if (
            ClientOpenInChannel
            &&
            (
             (InOpenType == cotSearchProxy) 
             || 
             (InOpenType == cotUnknownAuth)
            )
           )
            {
            OldOpenType = InOpenType;

            // We can be here in 3 cases:
            // 1. We do initial open and we search for proxy
            // 2. We do initial open with unknown auth.
            // 3. We do in channel recycling with unknown auth

            // The events of interest are:
            // 1. If the channel is still pending and we are in case 2,
            // skip the channel.
            // 2. If we're in case 3, or the remainder of 2, or (we're in 1 and
            // the result is positive), the result is final.
            // 3. If we're in case 1, and the result is negative, fall 
            // through below to both channels checks

            if (InOpenType == cotSearchProxy)
                {
                ASSERT(IsReplacementChannel == FALSE);
                CurrentCase = 1;
                }
            else if (IsReplacementChannel == FALSE)
                {
                ASSERT(InOpenType == cotUnknownAuth);
                CurrentCase = 2;
                }
            else
                {
                ASSERT(IsReplacementChannel);
                ASSERT(InOpenType == cotUnknownAuth);
                CurrentCase = 3;
                }

            // capture the InOpenStatus to get a consistent view
            LocalInOpenStatus = InOpenStatus;
            if ((CurrentCase == 2) && (LocalInOpenStatus == ERROR_IO_PENDING))
                {
                NukeInChannel = FALSE;
                RebuildInChannel = FALSE;
                ResetInChannel = FALSE;
                OpenInChannel = FALSE;
                ReceiveInChannel = FALSE;
                SendInChannel = FALSE;
                // the wait must have been woken by the out channel. Loop around
                continue;
                }
            else if 
                (
                 (CurrentCase == 2)
                 ||
                 (CurrentCase == 3)
                 ||
                 (
                  (CurrentCase == 1)
                  &&
                  (
                   (LocalInOpenStatus == RPC_S_OK)
                   ||
                   (LocalInOpenStatus == RPC_P_AUTH_NEEDED)
                  )
                 )
                )
                {
                if ((LocalInOpenStatus != RPC_S_OK)
                    && (LocalInOpenStatus != RPC_P_AUTH_NEEDED))
                    {
                    RpcStatus = LocalInOpenStatus;
                    goto AbortAndExit;
                    }

                // if we haven't chosen a scheme yet, choose it now
                if (InChosenAuthScheme == 0)
                    {
                    InChosenAuthScheme = GetInChannelChosenScheme(IsReplacementChannel);
                    }

                if (InChosenAuthScheme & MultiLeggedSchemeMap)
                    {
                    // milti legged authentication implies keep alives
                    IsKeepAlive = TRUE;
                    InOpenType = cotMLAuth;

                    // we need only reset, open, send and receive
                    NukeInChannel = FALSE;
                    RebuildInChannel = FALSE;
                    ResetInChannel = TRUE;
                    OpenInChannel = TRUE;
                    SendInChannel = FALSE;
                    ReceiveInChannel = TRUE;
                    }
                else
                    {
                    // SSL always supports keep alives
                    if (HttpCredentials && HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_SSL)
                        IsKeepAlive = TRUE;
                    else
                        {
                        IsKeepAlive = IsInChannelKeepAlive(IsReplacementChannel);
                        }
                    if (InChosenAuthScheme)
                        InOpenType = cotSLAuth;
                    else
                        InOpenType = cotNoAuth;
                    if (IsKeepAlive)
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeInChannel = FALSE;
                        RebuildInChannel = FALSE;
                        ResetInChannel = TRUE;
                        }
                    else
                        {
                        // we need nuke, rebuild, open, send, receive
                        NukeInChannel = TRUE;
                        RebuildInChannel = TRUE;
                        ResetInChannel = FALSE;
                        }

                    OpenInChannel = TRUE;
                    if (IsReplacementChannel)
                        IsDone = TRUE;
                    else
                        SendInChannel = TRUE;

                    if (UseWinHttp || (IsReplacementChannel == FALSE))
                        ReceiveInChannel = FALSE;
                    else
                        ReceiveInChannel = TRUE;
                    }

                InOpenStatus = ERROR_IO_PENDING;

                if (OutOpenType == cotSearchProxy)
                    {
                    // we need to nuke, rebuild, open, send, possibly receive in channel
                    NukeOutChannel = TRUE;
                    RebuildOutChannel = TRUE;
                    ResetOutChannel = FALSE;
                    OpenOutChannel = TRUE;
                    SendOutChannel = FALSE;
                    ReceiveOutChannel = TRUE;

                    // if we have already chosen an auth scheme, presumably
                    // because of RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME, set it
                    if (OutChosenAuthScheme)
                        {
                        ASSERT(IsReplacementChannel == FALSE);
                        ASSERT(HttpCredentials);
                        ASSERT(HttpCredentials->Flags & RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME);

                        if (OutChosenAuthScheme & MultiLeggedSchemeMap)
                            OutOpenType = cotMLAuth;
                        else
                            {
                            OutOpenType = cotSLAuth;

                            SendOutChannel = TRUE;
                            }
                        }
                    else
                        OutOpenType = cotUnknownAuth;

                    StoredAccessType = rpcpatDirect;
                    Hint->AccessType = rpcpatDirect;
                    }

                if (IsReplacementChannel == FALSE)
                    {
                    // change the connection and channel state
                    SetNewConnectionState = TRUE;
                    NewConnectionState = http2svA3W;
                    }

                if ((OldOpenType == cotSearchProxy) || IsReplacementChannel)
                    continue;
                else
                    {
                    // fall through to code that handles both channels
                    }
                }
            else
                {
                ASSERT(CurrentCase == 1);
                ASSERT((LocalInOpenStatus != RPC_S_OK)
                    && (LocalInOpenStatus != RPC_P_AUTH_NEEDED) );
                // fall through below
                }
            }

        // did we get to an opened state? This should be checked only
        // when we open both (initial open).
        if ((IsReplacementChannel == FALSE) 
            && (InChannelState.State == http2svOpened))
            {

            RpcStatus = RPC_S_OK;

            ASSERT(InChannelState.State == http2svOpened);
            ASSERT(OutChannelState.State == http2svOpened);

            RpcStatus = HTTP_CopyResolverHint(&ConnectionHint,
                Hint,
                FALSE   // SourceWillBeAbandoned
                );

            if (RpcStatus != RPC_S_OK)
                goto AbortAndExit;

            break;
            }

        // if we are in a non-transitional state and we're doing an
        // initial open, this means one of the channels didn't come in.
        // Loop around
        if ((IsReplacementChannel == FALSE)
            && (
                (InOpenType == cotUnknownAuth)
                ||
                (OutOpenType == cotUnknownAuth)
               )
              )
            {
            ASSERT((LocalInOpenStatus == ERROR_IO_PENDING)
                || (LocalOutOpenStatus == ERROR_IO_PENDING));
            continue;
            }

        // we're probably authenticating the individual channels
        // see which channel is actionable and what to do with it
        if (ClientOpenInChannel && (OldInOpenType == cotMLAuth))
            {
            // capture the InOpenStatus in a local variable for consistent
            // view
            LocalInOpenStatus = InOpenStatus;
            if (LocalInOpenStatus != ERROR_IO_PENDING)
                {
                // something happened on the in channel. Process it
                if (LocalInOpenStatus == RPC_S_OK)
                    {
                    // we have successfully completed
                    // authentication. Open the connection on the RTS
                    // level
                    InOpenStatus = ERROR_IO_PENDING;
                    // we need to reset, open, send, receive out channel
                    NukeInChannel = FALSE;
                    RebuildInChannel = FALSE;
                    ResetInChannel = TRUE;
                    OpenInChannel = TRUE;

                    ReceiveInChannel = FALSE;

                    if (IsReplacementChannel)
                        {
                        SendInChannel = FALSE;
                        IsDone = TRUE;
                        }
                    else
                        SendInChannel = TRUE;

                    InOpenType = cotMLAuth2;
                    }
                else
                    {
                    // if after all the auth we still get a challenge, this means
                    // we couldn't auth and this is access denied.
                    if (LocalInOpenStatus == RPC_P_AUTH_NEEDED)
                        RpcStatus = RPC_S_ACCESS_DENIED;
                    else
                        RpcStatus = LocalInOpenStatus;
                    goto AbortAndExit;
                    }
                }
            else
                {
                // fall through. Below we will detect the state
                // hasn't changed and we won't do any operations
                // on this channel
                }
            }

        if (ClientOpenOutChannel && (OldOutOpenType == cotMLAuth))
            {
            // capture the OutOpenStatus in a local variable for consistent
            // view
            LocalOutOpenStatus = OutOpenStatus;
            if (LocalOutOpenStatus != ERROR_IO_PENDING)
                {
                // something happened on the in channel. Process it
                if (LocalOutOpenStatus == RPC_S_OK)
                    {
                    // we have successfully completed multi-legged
                    // authentication. Open the connection on the RTS
                    // level
                    OutOpenStatus = ERROR_IO_PENDING;
                    // we need to reset, open, send, receive out channel
                    NukeOutChannel = FALSE;
                    RebuildOutChannel = FALSE;
                    ResetOutChannel = TRUE;
                    OpenOutChannel = TRUE;
                    if (IsReplacementChannel)
                        {
                        ReceiveOutChannel = FALSE;
                        SendOutChannel = FALSE;
                        IsDone = TRUE;
                        }
                    else
                        {
                        ReceiveOutChannel = TRUE;
                        SendOutChannel = TRUE;
                        }

                    OutOpenType = cotMLAuth2;
                    }
                else
                    {
                    // if after all the auth we still get a challenge, this means
                    // we couldn't auth and this is access denied.
                    if (LocalOutOpenStatus == RPC_P_AUTH_NEEDED)
                        RpcStatus = RPC_S_ACCESS_DENIED;
                    else
                        RpcStatus = LocalOutOpenStatus;
                    goto AbortAndExit;
                    }
                }
            else
                {
                // fall through. Below we will detect the state
                // hasn't changed and we won't do any operations
                // on this channel
                }
            }

        if ((IsReplacementChannel == FALSE) && (InOpenType == cotSearchProxy))
            {
            // none of the channels came in positive so far. If at least one
            // is still pending, wait for it
            if ((LocalInOpenStatus == ERROR_IO_PENDING)
                || (LocalOutOpenStatus == ERROR_IO_PENDING))
                {
#if DBG_ERROR
                DbgPrint("Waiting again ....\n");
#endif
                goto WaitAgain;
                }

            // both channels came in negative. The server is not
            // available
            if ((LocalInOpenStatus == RPC_S_ACCESS_DENIED)
                || (LocalOutOpenStatus == RPC_S_ACCESS_DENIED))
                RpcStatus = RPC_S_ACCESS_DENIED;
            else
                RpcStatus = RPC_S_SERVER_UNAVAILABLE;
            goto AbortAndExit;
            }

        // if we came in with a terminal state and the server responded
        // with an error, bail out
        // first, capture the InOpenStatus in a local variable for consistent
        // view
        LocalInOpenStatus = InOpenStatus;
        if (ClientOpenInChannel
            && 
            (
             (OldInOpenType == cotSLAuth)
             ||
             (OldInOpenType == cotNoAuth)
             ||
             (OldInOpenType == cotMLAuth2)
            )
            &&
            (LocalInOpenStatus != RPC_S_OK)
            &&
            (LocalInOpenStatus != ERROR_IO_PENDING)
           )
            {
            if (LocalInOpenStatus == RPC_P_AUTH_NEEDED)
                RpcStatus = RPC_S_ACCESS_DENIED;
            else
                RpcStatus = LocalInOpenStatus;
            goto AbortAndExit;
            }

        // capture the OutOpenStatus in a local variable for consistent
        // view
        LocalOutOpenStatus = OutOpenStatus;
        if (ClientOpenOutChannel
            && 
            (
             (OldOutOpenType == cotSLAuth)
             ||
             (OldOutOpenType == cotNoAuth)
             ||
             (OldOutOpenType == cotMLAuth2)
            )
            &&
            (LocalOutOpenStatus != RPC_S_OK)
            &&
            (LocalOutOpenStatus != ERROR_IO_PENDING)
           )
            {
            if (LocalOutOpenStatus == RPC_P_AUTH_NEEDED)
                RpcStatus = RPC_S_ACCESS_DENIED;
            else
                RpcStatus = LocalOutOpenStatus;
            goto AbortAndExit;
            }

        // if state hasn't changed, don't do anything on this channel
        if (OldInOpenType == InOpenType)
            {
            NukeInChannel = FALSE;
            RebuildInChannel = FALSE;
            ResetInChannel = FALSE;
            OpenInChannel = FALSE;
            ReceiveInChannel = FALSE;
            SendInChannel = FALSE;
            }

        if (OldOutOpenType == OutOpenType)
            {
            NukeOutChannel = FALSE;
            RebuildOutChannel = FALSE;
            ResetOutChannel = FALSE;
            OpenOutChannel = FALSE;
            ReceiveOutChannel = FALSE;
            SendOutChannel = FALSE;
            }
        // loop around for further processing
        }

    IgnoreAborts = FALSE;

    ASSERT(RpcStatus == RPC_S_OK);

    if (IsReplacementChannel == FALSE)
        {
        ASSERT(InChannelState.State == http2svOpened);
        }

    ASSERT(LocalClientOpenEvent);
    InChannelState.Mutex.Request();
    ClientOpenInEvent = NULL;
    ClientOpenOutEvent = NULL;
    InChannelState.Mutex.Clear();
    CloseHandle(LocalClientOpenEvent);

    return RpcStatus;

AbortAndExit:
    if (InChannelLocked)
        {
        InChannelPtr->UnlockChannelPointer();
        }

    if (OutChannelLocked)
        {
        OutChannelPtr->UnlockChannelPointer();
        }

    if (InChannelSendContext)
        {
        FreeRTSPacket(InChannelSendContext);
        }

    if (OutChannelSendContext)
        {
        FreeRTSPacket(OutChannelSendContext);
        }

    if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
        || (RpcStatus == RPC_P_CONNECTION_CLOSED)
        || (RpcStatus == RPC_P_SEND_FAILED))
        RpcStatus = RPC_S_SERVER_UNAVAILABLE;
    else if ((RpcStatus == RPC_P_RECEIVE_FAILED) && IsReplacementChannel)
        {
        // RPC_P_RECEIVE_FAILED is also mapped to server unavailable, but only
        // during channel recycling. The reason is that the old crappy RPC Proxy
        // will just close the connection if we directly access the RPC Proxy,
        // so all that we will get will be RPC_P_RECEIVE_FAILED. Not mapping it
        // during initial conneciton establishment allows upper layers to try the old
        // HTTP thus preserving interop
        RpcStatus = RPC_S_SERVER_UNAVAILABLE;
        }

    ASSERT(LocalClientOpenEvent);
    InChannelState.Mutex.Request();
    ClientOpenInEvent = NULL;
    ClientOpenOutEvent = NULL;
    InChannelState.Mutex.Clear();
    CloseHandle(LocalClientOpenEvent);

    VALIDATE (RpcStatus)
        {
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_SERVER_UNAVAILABLE,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_SERVER_TOO_BUSY,
        RPC_S_INVALID_NETWORK_OPTIONS,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_INVALID_NET_ADDR,
        RPC_S_ACCESS_DENIED,
        RPC_S_INTERNAL_ERROR,
        RPC_S_SERVER_OUT_OF_MEMORY,
        RPC_S_CALL_CANCELLED,
        RPC_S_PROTOCOL_ERROR,
        RPC_P_RECEIVE_FAILED
        } END_VALIDATE;

    IgnoreAborts = FALSE;

    // If we are not from upcall, abort. Else, caller will
    // abort 
    if (IsFromUpcall == FALSE)
        Abort();

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::AllocateAndInitializeInChannel (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN ULONG CallTimeout,
    IN BOOL UseWinHttp,
    OUT HTTP2ClientInChannel **ReturnInChannel
    )
/*++

Routine Description:

    Allocate and initialize the in channel stack

Arguments:

    Hint - the resolver hint

    HintWasInitialized - true if the hint was initialized on input

    CallTimeout - the timeout for the operation

    ReturnInChannel - on success the pointer to the allocated in channel.
        Undefined on failure.

    UseWinHttp - non-zero if WinHttp should be used for the bottom channel.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ClientInChannel *InChannel;
    HTTP2PlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2PingOriginator *PingOriginator;
    HTTP2ChannelDataOriginator *ChannelDataOriginator;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    HTTP2WinHttpTransportChannel *WinHttpConnection;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL PingOriginatorNeedsCleanup;
    BOOL ChannelDataOriginatorNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    BOOL WinHttpConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator)
        ;

    if (UseWinHttp)
        MemorySize += sizeof(HTTP2WinHttpTransportChannel);
    else
        {
        MemorySize += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
            + sizeof(WS_HTTP2_CONNECTION);
        }

    CurrentBlock = MemoryBlock = (BYTE *) new char [MemorySize];
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2ClientInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientInChannel);

    PlugChannel = (HTTP2PlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    PingOriginator = (HTTP2PingOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator);

    ChannelDataOriginator = (HTTP2ChannelDataOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator);

    if (UseWinHttp)
        {
        WinHttpConnection = (HTTP2WinHttpTransportChannel *)CurrentBlock;
        }
    else
        {
        RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
        CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

        RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
        RawConnection->HeaderRead = FALSE;
        RawConnection->ReadHeaderFn = HTTP2ClientReadChannelHeader;
        }

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    PingOriginatorNeedsCleanup = FALSE;
    ChannelDataOriginatorNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;
    WinHttpConnectionNeedsCleanup = FALSE;

    if (UseWinHttp)
        {
        RpcStatus = RPC_S_OK;
        WinHttpConnection = new (WinHttpConnection) HTTP2WinHttpTransportChannel (&RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            WinHttpConnection->HTTP2WinHttpTransportChannel::~HTTP2WinHttpTransportChannel();
            goto AbortAndExit;
            }

        WinHttpConnectionNeedsCleanup = TRUE;
        }
    else
        {
        RpcStatus = InitializeRawConnection (RawConnection,
            Hint,
            HintWasInitialized,
            CallTimeout
            );

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;

        RawConnection->RuntimeConnectionPtr = this;
        RawConnectionNeedsCleanup = TRUE;

        RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
            goto AbortAndExit;
            }

        RawConnection->Channel = RawChannel;

        RawChannelNeedsCleanup = TRUE;
        }

    ChannelDataOriginator = new (ChannelDataOriginator) HTTP2ChannelDataOriginator (DefaultChannelLifetime,
        FALSE,      // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ChannelDataOriginator->HTTP2ChannelDataOriginator::~HTTP2ChannelDataOriginator();
        goto AbortAndExit;
        }

    if (UseWinHttp)
        {
        WinHttpConnection->SetUpperChannel(ChannelDataOriginator);
        ChannelDataOriginator->SetLowerChannel(WinHttpConnection);
        }
    else
        {
        RawChannel->SetUpperChannel(ChannelDataOriginator);
        ChannelDataOriginator->SetLowerChannel(RawChannel);
        }

    ChannelDataOriginatorNeedsCleanup = TRUE;

    PingOriginator = new (PingOriginator) HTTP2PingOriginator (
        FALSE       // NotifyTopChannelForPings
        );

    ChannelDataOriginator->SetUpperChannel(PingOriginator);
    PingOriginator->SetLowerChannel(ChannelDataOriginator);

    PingOriginatorNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (FALSE,      // IsServer
        TRUE,        // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    PingOriginator->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(PingOriginator);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2PlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2PlugChannel::~HTTP2PlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2ClientInChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2ClientInChannel::~HTTP2ClientInChannel();
        goto AbortAndExit;
        }

    if (UseWinHttp)
        WinHttpConnection->SetTopChannel(InChannel);
    else
        RawChannel->SetTopChannel(InChannel);
    ChannelDataOriginator->SetTopChannel(InChannel);
    PingOriginator->SetTopChannel(InChannel);
    FlowControlSender->SetTopChannel(InChannel);
    PlugChannel->SetTopChannel(InChannel);

    PlugChannel->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(PlugChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnInChannel = InChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (PingOriginatorNeedsCleanup)
        {
        PingOriginator->Abort(RpcStatus);
        PingOriginator->FreeObject();
        }
    else if (ChannelDataOriginatorNeedsCleanup)
        {
        ChannelDataOriginator->Abort(RpcStatus);
        ChannelDataOriginator->FreeObject();
        }
    else if (UseWinHttp)
        {
        if (WinHttpConnectionNeedsCleanup)
            {
            WinHttpConnection->Abort(RpcStatus);
            WinHttpConnection->FreeObject();
            }
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS
RPC_ENTRY 
HTTP2ReadHttpLegacyResponse (
    IN WS_HTTP2_CONNECTION *Connection,
    IN ULONG BytesRead,
    OUT ULONG *NewBytesRead
    )
/*++

Routine Description:

    Read a channel HTTP header (usually some string). In success
    case, there is real data in Connection->pReadBuffer. The
    number of bytes there is in NewBytesRead

Arguments:

    Connection - the connection on which the header arrived.

    BytesRead - the bytes received from the net

    NewBytesRead - the bytes read from the channel (success only)

Return Value:

    RPC_S_OK or other RPC_S_* errors for error
    RPC_P_PARTIAL_RECEIVE will cause another loop.
    Any other error will cause processing of NewBuffer

--*/
{
    RPC_STATUS RpcStatus;
    BYTE *NewBuffer;

    BytesRead += Connection->iLastRead;

    // check whether what we have is a legacy response
    // legacy response is ncacn_http/1.0
    if (*(ULONG *)Connection->pReadBuffer == (ULONG)'cacn')
        {
        // Let's process it now.
        // see if we have sufficient length
        if (BytesRead < HTTP_SERVER_ID_STR_LEN)
            {
            Connection->iLastRead = BytesRead;
            return RPC_P_PARTIAL_RECEIVE;
            }
        else if (BytesRead == HTTP_SERVER_ID_STR_LEN)
            {
            // reset the pointer. By doing so we forget all we have 
            // read so far
            Connection->iLastRead = 0;
            Connection->HeaderRead = TRUE;
            return RPC_P_PARTIAL_RECEIVE;
            }
        else
            {
            // we have what we expect, and something more (coalesced read)
            // Process it. First make sure it is what we expect
            if (RpcpMemoryCompare(Connection->pReadBuffer, HTTP_SERVER_ID_STR, HTTP_SERVER_ID_STR_LEN) != 0)
                {
                return RPC_S_PROTOCOL_ERROR;
                }

            NewBuffer = TransConnectionAllocatePacket(Connection,
                   max(Connection->iPostSize, BytesRead - HTTP_SERVER_ID_STR_LEN));

            if (0 == NewBuffer)
                return RPC_S_OUT_OF_MEMORY;

            RpcpMemoryCopy(NewBuffer, 
                ((BYTE *)Connection->pReadBuffer) + HTTP_SERVER_ID_STR_LEN, 
                BytesRead - HTTP_SERVER_ID_STR_LEN);
            *NewBytesRead = BytesRead - HTTP_SERVER_ID_STR_LEN;

            RpcFreeBuffer(Connection->pReadBuffer);
            Connection->pReadBuffer = NewBuffer;
            Connection->iLastRead = 0;
            Connection->HeaderRead = TRUE;

            return RPC_S_OK;
            }
        }
    else
        {
        *NewBytesRead = BytesRead;
        Connection->iLastRead = 0;
        Connection->HeaderRead = TRUE;
        return RPC_S_OK;
        }
}

RPC_STATUS HTTP2ClientVirtualConnection::AllocateAndInitializeOutChannel (
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN ULONG CallTimeout,
    IN BOOL UseWinHttp,
    OUT HTTP2ClientOutChannel **ReturnOutChannel
    )
/*++

Routine Description:

    Allocate and initialize the out channel stack

Arguments:

    Hint - the resolver hint

    HintWasInitialized - true if the hint was initialized on input

    CallTimeout - the timeout for the operation

    ReturnInChannel - on success the pointer to the allocated in channel.
        Undefined on failure.

    UseWinHttp - non-zero if WinHttp should be used for the bottom channel.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ClientOutChannel *OutChannel;
    HTTP2EndpointReceiver *EndpointReceiver;
    HTTP2PingReceiver *PingReceiver;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    HTTP2WinHttpTransportChannel *WinHttpConnection;
    BOOL EndpointReceiverNeedsCleanup;
    BOOL PingReceiverNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    BOOL WinHttpConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the out channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver)
        ;

    if (UseWinHttp)
        MemorySize += sizeof(HTTP2WinHttpTransportChannel);
    else
        {
        MemorySize += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
            + sizeof(WS_HTTP2_CONNECTION);
        }

    CurrentBlock = MemoryBlock = (BYTE *) new char [MemorySize];
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2ClientOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ClientOutChannel);

    EndpointReceiver = (HTTP2EndpointReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver);

    PingReceiver = (HTTP2PingReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver);

    if (UseWinHttp)
        {
        WinHttpConnection = (HTTP2WinHttpTransportChannel *)CurrentBlock;
        }
    else
        {
        RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
        CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

        RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
        RawConnection->HeaderRead = FALSE;
        RawConnection->ReadHeaderFn = HTTP2ClientReadChannelHeader;
        }

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    EndpointReceiverNeedsCleanup = FALSE;
    PingReceiverNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;
    WinHttpConnectionNeedsCleanup = FALSE;

    if (UseWinHttp)
        {
        RpcStatus = RPC_S_OK;
        WinHttpConnection = new (WinHttpConnection) HTTP2WinHttpTransportChannel (&RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            WinHttpConnection->HTTP2WinHttpTransportChannel::~HTTP2WinHttpTransportChannel();
            goto AbortAndExit;
            }

        WinHttpConnectionNeedsCleanup = TRUE;
        }
    else
        {
        RpcStatus = InitializeRawConnection (RawConnection,
            Hint,
            HintWasInitialized,
            CallTimeout
            );

        if (RpcStatus != RPC_S_OK)
            goto AbortAndExit;

        RawConnection->RuntimeConnectionPtr = this;
        RawConnectionNeedsCleanup = TRUE;

        RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
        if (RpcStatus != RPC_S_OK)
            {
            RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
            goto AbortAndExit;
            }

        RawConnection->Channel = RawChannel;

        RawChannelNeedsCleanup = TRUE;
        }

    PingReceiver = new (PingReceiver) HTTP2PingReceiver(TRUE);

    if (UseWinHttp)
        {
        WinHttpConnection->SetUpperChannel(PingReceiver);
        PingReceiver->SetLowerChannel(WinHttpConnection);
        }
    else
        {
        RawChannel->SetUpperChannel(PingReceiver);
        PingReceiver->SetLowerChannel(RawChannel);
        }

    PingReceiverNeedsCleanup = TRUE;

    EndpointReceiver = new (EndpointReceiver) HTTP2EndpointReceiver(HTTP2ClientReceiveWindow,
        FALSE,      // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        EndpointReceiver->HTTP2EndpointReceiver::~HTTP2EndpointReceiver();
        goto AbortAndExit;
        }

    PingReceiver->SetUpperChannel(EndpointReceiver);
    EndpointReceiver->SetLowerChannel(PingReceiver);

    EndpointReceiverNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2ClientOutChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2ClientOutChannel::~HTTP2ClientOutChannel();
        goto AbortAndExit;
        }

    EndpointReceiver->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(EndpointReceiver);

    if (UseWinHttp)
        WinHttpConnection->SetTopChannel(OutChannel);
    else
        RawChannel->SetTopChannel(OutChannel);
    PingReceiver->SetTopChannel(OutChannel);
    EndpointReceiver->SetTopChannel(OutChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnOutChannel = OutChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (EndpointReceiverNeedsCleanup)
        {
        EndpointReceiver->Abort(RpcStatus);
        EndpointReceiver->FreeObject();
        }
    else if (PingReceiverNeedsCleanup)
        {
        PingReceiver->Abort(RpcStatus);
        PingReceiver->FreeObject();
        }
    else if (UseWinHttp)
        {
        if (WinHttpConnectionNeedsCleanup)
            {
            WinHttpConnection->Abort(RpcStatus);
            WinHttpConnection->FreeObject();
            }
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2ClientVirtualConnection::InitializeRawConnection (
    IN OUT WS_HTTP2_CONNECTION *RawConnection,
    IN HTTPResolverHint *Hint,
    IN BOOL HintWasInitialized,
    IN ULONG CallTimeout
    )
/*++

Routine Description:

    Initialize a raw client connection

Arguments:

    RawConnection - memory for the connection. It is uninitialized

    Hint - the resolver hint

    HintWasInitialized - true if the hint was initialized on input

    CallTimeout - the timeout for the operation

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    RPC_CHAR *ConnectionTargetName;
    USHORT PortToUse;

    RawConnection->Initialize();
    RawConnection->type = COMPLEX_T | CONNECTION | CLIENT;

    // initialize raw connection
    if (Hint->AccessType == rpcpatHTTPProxy)
        {
        ConnectionTargetName = new RPC_CHAR [RpcpStringLengthA(Hint->HTTPProxy) + 2];
        if (ConnectionTargetName == NULL)
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            return RpcStatus;
            }

        FullAnsiToUnicode(Hint->HTTPProxy, ConnectionTargetName);

        PortToUse = Hint->HTTPProxyPort;
        }
    else
        {
        ASSERT(Hint->AccessType == rpcpatDirect);

        ConnectionTargetName = new RPC_CHAR [RpcpStringLengthA(Hint->RpcProxy) + 1];
        if (ConnectionTargetName == NULL)
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            return RpcStatus;
            }

        FullAnsiToUnicode(Hint->RpcProxy, ConnectionTargetName);

        PortToUse = Hint->RpcProxyPort;
        }

    RpcStatus = TCPOrHTTP_Open(RawConnection,
        ConnectionTargetName,
        PortToUse,
        ConnectionTimeout,
        0,      // SendBufferSize
        0,      // RecvBufferSize
        Hint,
        HintWasInitialized,
        CallTimeout,
        TRUE,    // fHTTP2Open
        NULL     // IsValidMachineFn
        );

    delete [] ConnectionTargetName;

    return RpcStatus;
}

BOOL HTTP2ClientVirtualConnection::IsInChannelKeepAlive (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Checks whether the an in channel supports keep alives.
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    non-zero - the channel supports keep alives
    0 - the channel doesn't support keep alives

--*/
{
    HTTP2ClientInChannel *InChannel;
    BOOL IsKeepAlive;
    HTTP2ChannelPointer *InChannelPtr;

    if (IsReplacementChannel)
        InChannelPtr = &InChannels[GetNonDefaultInChannelSelector()];
    else
        InChannelPtr = &InChannels[0];

    InChannel = (HTTP2ClientInChannel *)InChannelPtr->LockChannelPointer();

    // nobody can abort the connection here
    ASSERT (InChannel != NULL);

    IsKeepAlive = InChannel->IsKeepAlive();

    InChannelPtr->UnlockChannelPointer();

    return IsKeepAlive;
}

BOOL HTTP2ClientVirtualConnection::IsOutChannelKeepAlive (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Checks whether an out channel supports keep alives
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    non-zero - the channel supports keep alives
    0 - the channel doesn't support keep alives

--*/
{
    HTTP2ClientOutChannel *OutChannel;
    BOOL IsKeepAlive;
    HTTP2ChannelPointer *OutChannelPtr;

    if (IsReplacementChannel)
        OutChannelPtr = &OutChannels[GetNonDefaultOutChannelSelector()];
    else
        OutChannelPtr = &OutChannels[0];

    OutChannel = (HTTP2ClientOutChannel *)OutChannelPtr->LockChannelPointer();
    // nobody can abort the connection here
    ASSERT (OutChannel != NULL);

    IsKeepAlive = OutChannel->IsKeepAlive();

    OutChannelPtr->UnlockChannelPointer();

    return IsKeepAlive;
}

ULONG HTTP2ClientVirtualConnection::GetInChannelChosenScheme (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Gets the chosen scheme for the an in channel
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    Chosen scheme

--*/
{
    HTTP2ClientInChannel *InChannel;
    ULONG ChosenScheme;
    HTTP2ChannelPointer *InChannelPtr;

    if (IsReplacementChannel)
        InChannelPtr = &InChannels[GetNonDefaultInChannelSelector()];
    else
        InChannelPtr = &InChannels[0];

    InChannel = (HTTP2ClientInChannel *)InChannelPtr->LockChannelPointer();
    // nobody can abort the connection here
    ASSERT (InChannel != NULL);

    ChosenScheme = InChannel->GetChosenAuthScheme();

    InChannelPtr->UnlockChannelPointer();

    return ChosenScheme;
}

ULONG HTTP2ClientVirtualConnection::GetOutChannelChosenScheme (
    IN BOOL IsReplacementChannel
    )
/*++

Routine Description:

    Gets the chosen scheme for an out channel
    Which channel depends on the arguments - see below.

Arguments:

    IsReplacementInChannel - if non-zero, this is a replacement
    channel and the non-default channel will be checked. If 0,
    this is a first channel, and the zero'th channel will be
    checked.

Return Value:

    Chosen scheme

--*/
{
    HTTP2ClientOutChannel *OutChannel;
    ULONG ChosenScheme;
    HTTP2ChannelPointer *OutChannelPtr;

    if (IsReplacementChannel)
        OutChannelPtr = &OutChannels[GetNonDefaultOutChannelSelector()];
    else
        OutChannelPtr = &OutChannels[0];

    OutChannel = (HTTP2ClientOutChannel *)OutChannelPtr->LockChannelPointer();
    // nobody can abort the connection here
    ASSERT (OutChannel != NULL);

    ChosenScheme = OutChannel->GetChosenAuthScheme();

    OutChannelPtr->UnlockChannelPointer();

    return ChosenScheme;
}

BOOL HTTP2ClientVirtualConnection::IsInChannelPositiveWithWait (
    void
    )
/*++

Routine Description:

    Checks if the in channel has come in with positive result. If
    not, it waits a bit and tries again. If not again, return FALSE.

Arguments:

Return Value:

    non-zero if the in channel came in positive.
    0 otherwise.

--*/
{
    if ((InOpenStatus == RPC_S_OK)
        || (InOpenStatus == RPC_P_AUTH_NEEDED))
        return TRUE;

    Sleep(100);

    return ((InOpenStatus == RPC_S_OK)
        || (InOpenStatus == RPC_P_AUTH_NEEDED));
}

/*********************************************************************
    Switching Layer
 *********************************************************************/

RPC_STATUS
RPC_ENTRY
HTTP_SyncRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Perform a sync recv on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - transport connection
    Buffer - if successful, points to a buffer containing the next PDU.
    BufferLength -  if successful, contains the length of the message.
    Timeout - the amount of time to wait for the receive. If -1, we wait
        infinitely.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    if (BaseObject->id == HTTP)
        {
        return WS_SyncRecv(ThisConnection,
            pBuffer,
            pBufferLength,
            dwTimeout
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        RpcStatus = VirtualConnection->SyncRecv((BYTE **)pBuffer,
            (ULONG *)pBufferLength,
            dwTimeout);

        VALIDATE(RpcStatus)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_RECEIVE_FAILED,
            RPC_S_CALL_CANCELLED,
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        return RpcStatus;
        }
}

RPC_STATUS 
RPC_ENTRY 
HTTP_Abort (
    IN RPC_TRANSPORT_CONNECTION Connection
    )
/*++

Routine Description:

    Aborts an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    Connection - transport connection

Return Value:

    RPC_S_OK

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) Connection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return WS_Abort(Connection);
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)Connection;

        if ((VirtualConnection->type & TYPE_MASK) == CLIENT)
            {
            ((HTTP2ClientVirtualConnection *)VirtualConnection)->HTTP2ClientVirtualConnection::Abort();
            }
        else
            {
            ASSERT((VirtualConnection->type & TYPE_MASK) == SERVER);
            ((HTTP2ServerVirtualConnection *)VirtualConnection)->HTTP2ServerVirtualConnection::Abort();
            }
        return RPC_S_OK;
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_Close (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Aborts an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - transport connection
    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

    RPC_S_OK

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return WS_Close(ThisConnection,
            fDontFlush
            );
        }
    else if (BaseObject->id == INVALID_PROTOCOL_ID)
        {
        // object was never completely initialized - just return
        return RPC_S_OK;
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        // the object may have been destroyed by now - cannot use
        // virtual functions. Determine statically the type
        // and call the function to cleanup (it knows how to
        // deal with destroyed objects)
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        if ((VirtualConnection->type & TYPE_MASK) == CLIENT)
            {
            ((HTTP2ClientVirtualConnection *)VirtualConnection)->HTTP2ClientVirtualConnection::Close(fDontFlush);
            }
        else
            {
            ASSERT((VirtualConnection->type & TYPE_MASK) == SERVER);
            ((HTTP2ServerVirtualConnection *)VirtualConnection)->HTTP2ServerVirtualConnection::Close(fDontFlush);
            }
        return RPC_S_OK;
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_Send(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Length,
    BUFFER Buffer,
    PVOID SendContext
    )
/*++

Routine Description:

    Does a send on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - The connection to send the data on.
    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer to use as the HTTP2SendContext for
        this operation.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return CO_Send(ThisConnection,
            Length,
            Buffer,
            SendContext
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->Send(Length,
            Buffer,
            SendContext
            );
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_Recv(
    RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    Does a receive on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - A connection without a read pending on it.

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return CO_Recv(ThisConnection);
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->Receive();
        }
}

RPC_STATUS
RPC_ENTRY
HTTP_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Does a sync send on an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    Connection - The connection to send on.
    BufferLength - The size of the buffer.
    Buffer - The data to sent.
    fDisableShutdownCheck - Normally FALSE, when true this disables
        the transport check for async shutdown PDUs.
    fDisableCancelCheck - runtime indicates no cancel
        will be attempted on this send. Can be used
        as optimization hint by the transport
    Timeout - send timeout (call timeout)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) Connection;
    HTTP2VirtualConnection *VirtualConnection;
    RPC_STATUS RpcStatus;

    if (BaseObject->id == HTTP)
        {
        RpcStatus = WS_SyncSend(Connection,
            BufferLength,
            Buffer,
            fDisableShutdownCheck,
            fDisableCancelCheck,
            Timeout
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)Connection;

        RpcStatus = VirtualConnection->SyncSend(BufferLength,
            Buffer,
            fDisableShutdownCheck,
            fDisableCancelCheck,
            Timeout
            );
        }

    VALIDATE(RpcStatus)
        {
         RPC_S_OK,
         RPC_S_OUT_OF_MEMORY,
         RPC_S_OUT_OF_RESOURCES,
         RPC_P_RECEIVE_FAILED,
         RPC_S_CALL_CANCELLED,
         RPC_P_SEND_FAILED,
         RPC_P_CONNECTION_SHUTDOWN,
         RPC_P_TIMEOUT
         } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS
RPC_ENTRY 
HTTP_TurnOnOffKeepAlives (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for an HTTP connection. Part of the HTTP switching
    layer between old mode and new mode.

Arguments:

    ThisConnection - The connection to turn keep alives on on.
    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.
    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.
    Units - in what units is KATime
    KATime - how much to wait before turning on keep alives
    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we use it on the server, we must protect
        the connection against async aborts.

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return WS_TurnOnOffKeepAlives(ThisConnection,
            TurnOn,
            bProtectIO,
            Units,
            KATime,
            KAInterval
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->TurnOnOffKeepAlives(TurnOn,
            bProtectIO,
            FALSE,      // IsFromUpcall
            Units,
            KATime,
            KAInterval
            );
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_QueryClientAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.

Arguments:

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryClientAddress(ThisConnection,
            pNetworkAddress
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryClientAddress(pNetworkAddress);
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_QueryLocalAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryLocalAddress(ThisConnection,
            Buffer,
            BufferSize,
            AddressFormat
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryLocalAddress(Buffer,
            BufferSize,
            AddressFormat
            );
        }
}


RPC_STATUS
RPC_ENTRY
HTTP_QueryClientId(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is supposed to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

Arguments:

    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    BASE_ASYNC_OBJECT *BaseObject = (BASE_ASYNC_OBJECT *) ThisConnection;
    HTTP2VirtualConnection *VirtualConnection;

    if (BaseObject->id == HTTP)
        {
        return TCP_QueryClientId(ThisConnection,
            ClientProcess
            );
        }
    else
        {
        ASSERT(BaseObject->id == HTTPv2);
        VirtualConnection = (HTTP2VirtualConnection *)ThisConnection;

        return VirtualConnection->QueryClientId(ClientProcess);
        }
}

/*********************************************************************
    HTTP Transport Interface
 *********************************************************************/

const int HTTPClientConnectionSize = max(sizeof(WS_CLIENT_CONNECTION), sizeof(WS_SAN_CLIENT_CONNECTION));
const int HTTP2ClientConnectionSize = sizeof(HTTP2ClientVirtualConnection);

const int HTTPServerConnectionSize = max(sizeof(WS_CONNECTION), sizeof(WS_SAN_CONNECTION));
const int HTTP2ServerConnectionSize = max(sizeof(HTTP2ServerVirtualConnection), sizeof(WS_HTTP2_INITIAL_CONNECTION));

const RPC_CONNECTION_TRANSPORT
HTTP_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    HTTP_TOWER_ID,
    HTTP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_http"),
    "593",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    max(HTTPClientConnectionSize, HTTP2ClientConnectionSize),
    max(HTTPServerConnectionSize, HTTP2ServerConnectionSize),
    sizeof(HTTP2SendContext),
    sizeof(HTTPResolverHint),
    HTTP_MAX_SEND,
    HTTP_Initialize,
    0, // InitComplete,
    HTTP_Open,
    0, // No SendRecv on winsock
    HTTP_SyncRecv,
    HTTP_Abort,
    HTTP_Close,
    HTTP_Send,
    HTTP_Recv,
    HTTP_SyncSend,
    HTTP_TurnOnOffKeepAlives,
    HTTP_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    HTTP_QueryClientAddress,
    HTTP_QueryLocalAddress,
    HTTP_QueryClientId,
    0, // Impersonate
    0, // Revert
    HTTP_FreeResolverHint,
    HTTP_CopyResolverHint,
    HTTP_CompareResolverHint,
    HTTP_SetLastBufferToFree
    };


/*********************************************************************
    HTTP2ProxyServerSideChannel
 *********************************************************************/

RPC_STATUS HTTP2ProxyServerSideChannel::InitializeRawConnection (
    IN RPC_CHAR *ServerName,
    IN USHORT ServerPort,
    IN ULONG ConnectionTimeout,
    IN I_RpcProxyIsValidMachineFn IsValidMachineFn
    )
/*++

Routine Description:

    Initializes a raw connection.

Arguments:

    ServerName - the server to connect to.

    ServerPort - which port on that server to use

    ConnectionTimeout - the connection timeout to use.

    IsValidMachineFn - a callback function to verify if the
        target machine/port are not blocked

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTPResolverHint DummyHint;

    RpcStatus = TCPOrHTTP_Open(RawConnection,
        ServerName,
        ServerPort,
        ConnectionTimeout,
        0,      // SendBufferSize
        0,      // RecvBufferSize
        &DummyHint,
        FALSE,      // HintWasInitialized
        10 * 60 * 60,   // 10 minutes
        TRUE,    // fHTTP2Open
        IsValidMachineFn
        );

    return RpcStatus;    
}

/*********************************************************************
    HTTP2TimeoutTargetConnection
 *********************************************************************/

RPC_STATUS HTTP2TimeoutTargetConnection::SetTimeout (
    IN ULONG Timeout,
    IN ULONG TimerIndex
    )
/*++

Routine Description:

    Called to setup a one time timer. Caller must make
    sure this function is synchronized with CancelTimeout and
    must make sure we don't schedule a timer behind an aborting
    thread (i.e. a timer fires after the object goes away).

Arguments:

    Timeout - interval before the timer fires

    TimerIndex - which timer do we refer to.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    BOOL Result;

    VerifyValidTimerIndex(TimerIndex);

    ASSERT(TimerHandle[TimerIndex] == NULL);

    Result = CreateTimerQueueTimer(&TimerHandle[TimerIndex],
        NULL,
        HTTP2TimeoutTimerCallback,
        this,
        Timeout,  // time to first fire
        0,  // periodic interval
        WT_EXECUTELONGFUNCTION
        );

    if (Result == FALSE)
        return RPC_S_OUT_OF_MEMORY;

    return RPC_S_OK;
}

void HTTP2TimeoutTargetConnection::CancelTimeout (
    IN ULONG TimerIndex
    )
/*++

Routine Description:

    Called to cancel a timer. The function will not return until
    the timer callbacks have been drained. Caller must ensure
    that this method is synchronized with SetTimeout

Arguments:

    TimerIndex - which timer do we refer to.

Return Value:

--*/
{
    HANDLE LocalTimerHandle;
    BOOL Result;

    VerifyValidTimerIndex(TimerIndex);

    LocalTimerHandle = InterlockedExchangePointer(&TimerHandle[TimerIndex], NULL);

    // if the timer already fired there is nothing to do here.
    if (LocalTimerHandle == NULL)
        return;

    Result = DeleteTimerQueueTimer(NULL,
        LocalTimerHandle,
        INVALID_HANDLE_VALUE    // tell the timer function to wait for all callbacks
                                // to complete before returning
        );

    // this cannot fail unless we give it invalid parameters
    ASSERT(Result);
}

/*********************************************************************
    HTTP2ProxyVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2ProxyVirtualConnection::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate send complete.

Arguments:

    EventStatus - status of the operation

    SendContext - the context for the send complete

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyInChannel *InProxyInChannel;
    HTTP2OutProxyInChannel *OutProxyInChannel;
    BOOL LocalIsInProxy;
    BOOL IssueAck;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    BOOL UnlockPointer;

    VerifyValidChannelId(ChannelId);

    if ((EventStatus == RPC_S_OK)
        && (SendContext->TrafficType == http2ttData))
        {
        ChannelPtr = MapSendContextUserDataToChannelPtr(SendContext->UserData);
        if (ChannelPtr)
            {
            UnlockPointer = FALSE;
            IssueAck = FALSE;
            LocalIsInProxy = IsInProxy();
            if (LocalIsInProxy)
                {
                InProxyInChannel = (HTTP2InProxyInChannel *)ChannelPtr->LockChannelPointer();
                if (InProxyInChannel)
                    {
                    UnlockPointer = TRUE;
                    InProxyInChannel->BytesConsumedNotification (SendContext->maxWriteBuffer,
                        FALSE,      // OwnsMutex
                        &IssueAck,
                        &BytesReceivedForAck,
                        &WindowForAck
                        );
                    }
                }
            else
                {
                OutProxyInChannel = (HTTP2OutProxyInChannel *)ChannelPtr->LockChannelPointer();
                if (OutProxyInChannel)
                    {
                    UnlockPointer = TRUE;
                    OutProxyInChannel->BytesConsumedNotification (SendContext->maxWriteBuffer,
                        FALSE,      // OwnsMutex
                        &IssueAck,
                        &BytesReceivedForAck,
                        &WindowForAck
                        );
                    }
                }

            if (IssueAck)
                {
                // we need to issue a flow control ack to the peer. InProxy uses
                // forwarding, out proxy sends ack directly
                if (LocalIsInProxy)
                    {
                    EventStatus = InProxyInChannel->ForwardFlowControlAck(
                        BytesReceivedForAck,
                        WindowForAck
                        );
                    }
                else
                    {
                    EventStatus = OutProxyInChannel->ForwardFlowControlAck(
                        BytesReceivedForAck,
                        WindowForAck
                        );
                    }

#if DBG_ERROR
                DbgPrint("%s proxy issuing flow control ack: %d, %d\n", 
                    LocalIsInProxy ? "IN" : "OUT",
                    BytesReceivedForAck, WindowForAck);
#endif
                }

            if (UnlockPointer)
                ChannelPtr->UnlockChannelPointer();
            }
        else
            {
#if DBG
            DbgPrint("RPCRT4: %d: Channel for User Data %d on connection %p not found\n", 
                GetCurrentProcessId(),
                SendContext->UserData,
                this
                );
#endif
            }
        }

    // successful sends are no-op. Failed sends cause abort. Just
    // turn around the operation status after freeing the packet
    FreeSendContextAndPossiblyData(SendContext);

    // ok to return any error code. See Rule 12
    return EventStatus;
}

void HTTP2ProxyVirtualConnection::Abort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP connection and disconnects the channels.
    Must only come from neutral context.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_PROXY_VC, 0);

    // abort the channels themselves
    AbortChannels(RPC_P_CONNECTION_SHUTDOWN);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return;

    DisconnectChannels(FALSE, 0);
}

void HTTP2ProxyVirtualConnection::DisconnectChannels (
    IN BOOL ExemptChannel,
    IN int ExemptChannelId
    )
/*++

Routine Description:

    Disconnects all channels. Must be called from runtime
    or neutral context. Cannot be called from upcall or
    submit context unless an exempt channel is given
    Note that call must synchronize to ensure we're the only
    thread doing the disconnect

Arguments:

    ExemptChannel - non-zero if ExemptChannelId contains a
        valid exempt channel id. FALSE otherwise.

    ExemptChannelId - if ExemptChannel is non-zero, this argument
        is the id of a channel that will be disconnected, but not
        synchronized with up calls.
        If ExampleChannel is FALSE, this argument is undefined

Return Value:

--*/
{
    while (RundownBlock.GetInteger() > 0)
        {
        Sleep(2);
        }

    RemoveConnectionFromCookieCollection();

    HTTP2VirtualConnection::DisconnectChannels(ExemptChannel,
        ExemptChannelId
        );

    // cancel the timeouts after we have disconnected the channels.
    // Since all timeouts are setup within upcalls
    CancelAllTimeouts();
}

RPC_STATUS HTTP2ProxyVirtualConnection::AddConnectionToCookieCollection (
    void
    )
/*++

Routine Description:

    Adds this virtual connection to the cookie collection

Arguments:

Return Value:

--*/
{
    CookieCollection *ProxyCookieCollection;
    HTTP2VirtualConnection *ExistingConnection;

    if (IsInProxy())
        ProxyCookieCollection = GetInProxyCookieCollection();
    else
        ProxyCookieCollection = GetOutProxyCookieCollection();

    ProxyConnectionCookie = new HTTP2ServerCookie(EmbeddedConnectionCookie);
    if (ProxyConnectionCookie == NULL)
        return RPC_S_OUT_OF_MEMORY;

    ProxyConnectionCookie->SetConnection(this);
    IsConnectionInCollection = TRUE;

    ProxyCookieCollection->LockCollection();
    ExistingConnection = ProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);

    if (ExistingConnection == NULL)
        ProxyCookieCollection->AddElement(ProxyConnectionCookie);

    ProxyCookieCollection->UnlockCollection();

    if (ExistingConnection)
        return RPC_S_PROTOCOL_ERROR;
    else
        return RPC_S_OK;
}

void HTTP2ProxyVirtualConnection::RemoveConnectionFromCookieCollection (
    void
    )
/*++

Routine Description:

    Removes this virtual connection from the cookie collection

Arguments:

Return Value:

Note:

    This function must be called exactly once and is not thread safe.

--*/
{
    CookieCollection *ProxyCookieCollection;

    if (IsConnectionInCollection)
        {
        ASSERT(ProxyConnectionCookie);
        if (ProxyConnectionCookie->RemoveRefCount())
            {
            if (IsInProxy())
                ProxyCookieCollection = GetInProxyCookieCollection();
            else
                ProxyCookieCollection = GetOutProxyCookieCollection();

            ProxyCookieCollection->LockCollection();
            ProxyCookieCollection->RemoveElement(ProxyConnectionCookie);
            ProxyCookieCollection->UnlockCollection();
            delete ProxyConnectionCookie;
            }
        else
            {
            // the only we we can have a non-zero refcount is if the same
            // machine fakes a web farm.
            ASSERT(ActAsSeparateMachinesOnWebFarm);
            }
        }
}

void HTTP2ProxyVirtualConnection::TimeoutExpired (
    void
    )
/*++

Routine Description:

    A timeout expired before we cancelled the timer. Abort the connection.

Arguments:

Return Value:

--*/
{
    BOOL Result;

    TimerExpiredNotify();

    Result = AbortAndDestroy(FALSE,      // IsFromChannel
        0,      // CallingChannelId
        RPC_P_TIMEOUT
        );

    // if somebody is already destroying it, just return
    if (Result == FALSE)
        return;

    // now 'this' is a pointer disconnected from everybody
    // that we can destroy at our leisure
    delete this;
}

/*********************************************************************
    HTTP2InProxyInChannel
 *********************************************************************/

RPC_STATUS HTTP2InProxyInChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack to the client through the server

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    return ForwardFlowControlAckOnDefaultChannel(FALSE,    // IsInChannel
        fdClient,
        BytesReceivedForAck,
        WindowForAck
        );
}

/*********************************************************************
    HTTP2InProxyOutChannel
 *********************************************************************/

RPC_STATUS HTTP2InProxyOutChannel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support last packet notifications

Arguments:

    LastSendContext - the context for the last send

Return Value:

    The value to return to the bottom channel

--*/
{
    // just return ok to caller. When the server aborts the connection,
    // we will abort too.
    return RPC_S_OK;
}

RPC_STATUS HTTP2InProxyOutChannel::SetRawConnectionKeepAlive (
    IN ULONG KeepAliveInterval      // in milliseconds
    )
/*++

Routine Description:

    Sets the raw connection keep alive. On abort connections
    failures are ignored.

Arguments:

    KeepAliveInterval - keep alive interval in milliseconds

Return Value:

    The value to return to the bottom channel

--*/
{
    RPC_STATUS RpcStatus;
    WS_HTTP2_CONNECTION *RawConnection;
    KEEPALIVE_TIMEOUT KATimeout;

    RpcStatus = BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RPC_S_OK;
    
    RawConnection = GetRawConnection();
    KATimeout.Milliseconds = KeepAliveInterval;

    // turn off the old interval
    RpcStatus = WS_TurnOnOffKeepAlives(RawConnection,
        FALSE,      // TurnOn
        FALSE,      // bProtectIO
        tuMilliseconds,
        KATimeout,
        DefaultClientNoResponseKeepAliveInterval
        );

    // turning off should always succeed
    ASSERT(RpcStatus == RPC_S_OK);

    // turn on the new interval
    // start with the keep alives immediately and proceed until the specified interval
    RpcStatus = WS_TurnOnOffKeepAlives(RawConnection,
        TRUE,       // TurnOn
        FALSE,      // bProtectIO
        tuMilliseconds,
        KATimeout,
        KeepAliveInterval
        );

    FinishSubmitAsync();

    return RpcStatus;
}

/*********************************************************************
    HTTP2InProxyVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2InProxyVirtualConnection::InitializeProxyFirstLeg (
    IN USHORT *ServerAddress,
    IN USHORT *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface,
    void **IISContext
    )
/*++

Routine Description:

    Initialize the proxy (first leg - second leg will happen when we
        receive first RTS packet).

Arguments:

    ServerAddress - unicode pointer string to the server network address.

    ServerPort - unicode pointer string to the server port

    ConnectionParameter - the extension control block in this case

    ProxyCallbackInterface - a callback interface to the proxy to perform
        various proxy specific functions

    IISContext - on output (success only) it must be initialized to
        the bottom IISChannel for the InProxy.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2InProxyInChannel *NewInChannel;
    int InChannelId;
    int ServerAddressLength;    // in characters + terminating 0

    // initialize in channel
    RpcStatus = AllocateAndInitializeInChannel(ConnectionParameter,
        &NewInChannel,
        IISContext
        );

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    SetFirstInChannel(NewInChannel);

    this->ProxyCallbackInterface = ProxyCallbackInterface;
    this->ConnectionParameter = ConnectionParameter;

    ServerAddressLength = RpcpStringLength(ServerAddress) + 1;
    ServerName = new RPC_CHAR [ServerAddressLength];

    if (ServerName == NULL)
        {
        Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpMemoryCopy(ServerName, ServerAddress, ServerAddressLength * 2);

    RpcStatus = EndpointToPortNumber(ServerPort, this->ServerPort);

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::StartProxy (
    void
    )
/*++

Routine Description:

    Kicks off listening on the proxy

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2InProxyInChannel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svClosed, 1, 0);
    State.State = http2svClosed;    // move to closed state expecting the opening RTS packet

    Channel = LockDefaultInChannel(&ChannelPtr);

    ASSERT(Channel != NULL);  // we cannot be disconnected now

    RpcStatus = Channel->Receive(http2ttRaw);

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::InitializeProxySecondLeg (
    void
    )
/*++

Routine Description:

    Initialize the proxy (second leg - first leg has happened when we
        received the HTTP establishment header).

Arguments:

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2InProxyOutChannel *NewOutChannel;
    int OutChannelId;
    int ServerAddressLength;    // in characters + terminating 0
    char ClientIpAddress[16];
    ULONG ClientIpAddressSize;
    ADDRINFO DnsHint;
    ADDRINFO *AddrInfo;
    int err;

    // initialize out channel
    RpcStatus = AllocateAndInitializeOutChannel(
        &NewOutChannel
        );

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        return RpcStatus;
        }

    SetFirstOutChannel(NewOutChannel);

    RpcStatus = ProxyCallbackInterface->GetConnectionTimeoutFn(&IISConnectionTimeout);
    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        return RpcStatus;
        }

    // convert it from seconds to milliseconds
    IISConnectionTimeout *= 1000;

    ClientIpAddressSize = sizeof(ClientIpAddress);
    RpcStatus = ProxyCallbackInterface->GetClientAddressFn(
        ConnectionParameter,
        ClientIpAddress,
        &ClientIpAddressSize
        );

    ASSERT(RpcStatus != ERROR_INSUFFICIENT_BUFFER);

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        return RpcStatus;
        }

    RpcpMemorySet(&DnsHint, 0, sizeof(ADDRINFO));

    DnsHint.ai_flags = AI_NUMERICHOST;
    DnsHint.ai_family = PF_UNSPEC;

    err = getaddrinfo(ClientIpAddress, 
        NULL, 
        &DnsHint,
        &AddrInfo);

    // make sure IIS doesn't feed us garbage IP address
    if (err != ERROR_SUCCESS)
        {
        ASSERT(GetLastError() == ERROR_OUTOFMEMORY);
        Abort();
        return RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(AddrInfo->ai_family == AF_INET);

    ClientAddress.AddressType = catIPv4;
    RpcpCopyIPv4Address((SOCKADDR_IN *)AddrInfo->ai_addr, (SOCKADDR_IN *)&ClientAddress.u);

    freeaddrinfo(AddrInfo);

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error

    Buffer - buffer received

    BufferLength - length of buffer received

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    RPC_STATUS RpcStatus;
    BOOL BufferFreed = FALSE;
    BOOL MutexCleared;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *ChannelPtr2;
    HTTP2InProxyOutChannel *OutChannel;
    HTTP2InProxyInChannel *InChannel;
    HTTP2InProxyInChannel *InChannel2;
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;
    CookieCollection *InProxyCookieCollection;
    HTTP2InProxyVirtualConnection *ExistingConnection;
    HTTP2Cookie NewChannelCookie;
    HTTP2SendContext *EmptyRTS;
    int NonDefaultSelector;
    int DefaultSelector;
    HTTP2SendContext *D3_A2Context;
    HTTP2OtherCmdPacketType PacketType;
    int i;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2Cookie CookieForChannel;
    ULONG ServerReceiveWindowSize;
    HTTP2SendContext *SendContext;

    VerifyValidChannelId(ChannelId);

    if (EventStatus == RPC_S_OK)
        {
        // N.B. All recieve packets are guaranteed to be
        // validated up to the common conn packet size
        if (IsRTSPacket(Buffer))
            {
            RpcStatus = CheckPacketForForwarding(Buffer,
                BufferLength,
                fdInProxy
                );
            }

        if (IsRTSPacket(Buffer) && (RpcStatus != RPC_P_PACKET_NEEDS_FORWARDING))
            {
            // RTS packet - check what we need to do with it
            if (IsOtherCmdPacket(Buffer, BufferLength))
                {
                if (IsOutChannel(ChannelId))
                    {
                    // the only other cmd we expect on the out channel in the proxy are
                    // flow control acks
                    RpcStatus = ParseAndFreeFlowControlAckPacket (Buffer,
                        BufferLength,
                        &BytesReceivedForAck,
                        &WindowForAck,
                        &CookieForChannel
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus != RPC_S_OK)
                        return RpcStatus;

                    // notify the channel
                    ChannelPtr = GetChannelPointerFromId(ChannelId);
                    OutChannel = (HTTP2InProxyOutChannel *)ChannelPtr->LockChannelPointer();
                    if (OutChannel == NULL)
                        return RPC_P_CONNECTION_SHUTDOWN;

                    RpcStatus = OutChannel->FlowControlAckNotify(BytesReceivedForAck,
                        WindowForAck
                        );

                    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus != RPC_S_OK)
                        return RpcStatus;

                    // post another receive
                    RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                        http2ttRaw
                        );

                    if (RpcStatus != RPC_S_OK)
                        return RpcStatus;

                    return RPC_P_PACKET_CONSUMED;
                    }

                RpcStatus = GetOtherCmdPacketType(Buffer, 
                    BufferLength,
                    &PacketType
                    );

                if (RpcStatus == RPC_S_OK)
                    {
                    switch (PacketType)
                        {
                        case http2ocptKeepAliveChange:
                            RpcStatus = ParseAndFreeKeepAliveChangePacket(Buffer,
                                BufferLength,
                                &CurrentClientKeepAliveInterval
                                );

                            BufferFreed = TRUE;

                            if (RpcStatus == RPC_S_OK)
                                {
                                if (CurrentClientKeepAliveInterval == 0)
                                    CurrentClientKeepAliveInterval = DefaultClientKeepAliveInterval;

                                // by now the keep alive interval has been set on the connection.
                                // Any new channels will be taken care of by the virtual connection
                                // We need to go in and effect this change on the existing channels
                                for (i = 0; i < 2; i ++)
                                    {
                                    OutChannel = (HTTP2InProxyOutChannel *)OutChannels[0].LockChannelPointer();
                                    if (OutChannel)
                                        {
                                        RpcStatus = OutChannel->SetRawConnectionKeepAlive(CurrentClientKeepAliveInterval);
                                        OutChannels[0].UnlockChannelPointer();
                                        if (RpcStatus != RPC_S_OK)
                                            break;
                                        }
                                    }
                                }

                            if (RpcStatus == RPC_S_OK)
                                {
                                // post another receive
                                RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                                    http2ttRaw
                                    );

                                if (RpcStatus == RPC_S_OK)
                                    RpcStatus = RPC_P_PACKET_CONSUMED;
                                }
                            // return the status code - success or error, both get
                            // handled below us
                            return RpcStatus;
                            break;

                        default:
                            ASSERT(0);
                            return RPC_S_INTERNAL_ERROR;
                        }
                    }
                }

            MutexCleared = FALSE;
            State.Mutex.Request();
            switch (State.State)
                {
                case http2svClosed:
                    // for closed states, we must receive
                    // stuff only on the default in channel
                    ASSERT(IsDefaultInChannel(ChannelId));

                    CurrentPosition = ValidateRTSPacketCommon(Buffer,
                        BufferLength
                        );

                    if (CurrentPosition == NULL)
                        {
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RTS = (rpcconn_tunnel_settings *)Buffer;
                    if ((RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL) == 0)
                        {
                        RpcStatus = ParseAndFreeD1_B1(Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &InChannelCookies[0],
                            &ChannelLifetime,
                            &AssociationGroupId,
                            &CurrentClientKeepAliveInterval
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            break;

                        if (CurrentClientKeepAliveInterval < MinimumClientKeepAliveInterval)
                            {
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svB3W, 1, 0);
                        State.State = http2svB3W;
                        State.Mutex.Clear();
                        MutexCleared = TRUE;

                        RpcStatus = InitializeProxySecondLeg();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = ConnectToServer();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = SendD1_B2ToServer();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);

                        if (RpcStatus != RPC_S_OK)
                            break;

                        DefaultClientKeepAliveInterval = CurrentClientKeepAliveInterval;

                        OutChannel = LockDefaultOutChannel(&ChannelPtr);
                        if (OutChannel == NULL)
                            {
                            RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                            break;
                            }

                        RpcStatus = OutChannel->SetRawConnectionKeepAlive(CurrentClientKeepAliveInterval);
                        ChannelPtr->UnlockChannelPointer();

                        // fall through with the error code
                        }
                    else
                        {
                        RpcStatus = ParseAndFreeD2_A1 (Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &InChannelCookies[1],   // Old cookie - use InChannelCookies[1] 
                                                    // as temporary storage only
                            &InChannelCookies[0]    // New cookie
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            break;

                        // caller claims this is recycling for an already existing connection
                        // find out this connection
                        InProxyCookieCollection = GetInProxyCookieCollection();
                        InProxyCookieCollection->LockCollection();
                        ExistingConnection = (HTTP2InProxyVirtualConnection *)
                            InProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);
                        if (ExistingConnection == NULL || ActAsSeparateMachinesOnWebFarm)
                            {
                            // no dice. Probably we executed on a different machine on the web farm
                            // proceed as a standalone connection
                            InProxyCookieCollection->UnlockCollection();

                            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svB2W, 1, 0);
                            State.State = http2svB2W;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            RpcStatus = InitializeProxySecondLeg();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = ConnectToServer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            // posts receive on the server channel as
                            // well
                            RpcStatus = SendD2_A2ToServer();
                            if (RpcStatus != RPC_S_OK)
                                break;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            if (OutChannel == NULL)
                                {
                                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                                break;
                                }

                            RpcStatus = OutChannel->SetRawConnectionKeepAlive(CurrentClientKeepAliveInterval);
                            ChannelPtr->UnlockChannelPointer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);
                            }
                        else
                            {
                            // detach the in channel from this connection and attach
                            // it to the found connection. Grab a reference to it
                            // to prevent the case where it goes away underneath us
                            // we know that in its current state the connection is single
                            // threaded because we are in the completion path of the 
                            // only async operation

                            RpcStatus = ExistingConnection->SetTimeout(DefaultNoResponseTimeout,
                                InChannelTimer
                                );

                            if (RpcStatus != RPC_S_OK)
                                break;

                            ChannelPtr = GetChannelPointerFromId(ChannelId);
                            InChannel = (HTTP2InProxyInChannel *)ChannelPtr->LockChannelPointer();
                            // there is no way that somebody detached the channel here
                            ASSERT(InChannel);

                            // add a reference to keep the channel alive while we disconnect it
                            InChannel->AddReference();

                            ChannelPtr->UnlockChannelPointer();

                            // no need to drain the upcalls - we know we are the only
                            // upcall
                            ChannelPtr->FreeChannelPointer(
                                FALSE,      // DrainUpCalls
                                FALSE,      // CalledFromUpcallContext
                                FALSE,      // Abort
                                RPC_S_OK
                                );

                            DefaultSelector = ExistingConnection->DefaultInChannelSelector;
                            NonDefaultSelector = ExistingConnection->GetNonDefaultInChannelSelector();
                            if (ExistingConnection->InChannelCookies[DefaultSelector].Compare (&InChannelCookies[1]))
                                {
                                // nice try - cookies are different. Ditch the newly established channel
                                InProxyCookieCollection->UnlockCollection();
                                InChannel->RemoveReference();
                                RpcStatus = RPC_S_PROTOCOL_ERROR;
                                break;
                                }

                            InChannel->SetParent(ExistingConnection);
                            ExistingConnection->InChannels[NonDefaultSelector].SetChannel(InChannel);
                            ExistingConnection->InChannelCookies[NonDefaultSelector].SetCookie(InChannelCookies[0].GetCookie());
                            ExistingConnection->InChannelIds[NonDefaultSelector] = ChannelId;

                            // check if connection is aborted
                            if (ExistingConnection->Aborted.GetInteger() > 0)
                                {
                                InChannel->Abort(RPC_P_CONNECTION_SHUTDOWN);
                                }

                            // the extra reference that we added above passes to the existing connection
                            // However, below we party on the existing connection and we need to keep it alive
                            ExistingConnection->BlockConnectionFromRundown();
                            InProxyCookieCollection->UnlockCollection();

                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            // nuke the rest of the old connection

                            // we got to the destructive phase of the abort
                            // guard against double aborts
                            if (Aborted.Increment() > 1)
                                return FALSE;

                            // abort the channels
                            AbortChannels(RPC_P_CONNECTION_SHUTDOWN);

                            DisconnectChannels(FALSE,       // ExemptChannel
                                0                           // ExemptChannel id
                                );

                            delete this;
                            // N.B. don't touch the this pointer after here (Duh!)

                            ExistingConnection->State.Mutex.Request();
                            LogEvent(SU_HTTPv2, EV_STATE, ExistingConnection, IN_CHANNEL_STATE, http2svOpened_A5W, 1, 0);
                            ExistingConnection->State.State = http2svOpened_A5W;
                            ExistingConnection->State.Mutex.Clear();

                            // send D3/A2 to server
                            D3_A2Context = AllocateAndInitializeD3_A2(&ExistingConnection->InChannelCookies[NonDefaultSelector]);
                            if (D3_A2Context == NULL)
                                {
                                ExistingConnection->UnblockConnectionFromRundown();
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                break;
                                }

                            RpcStatus = ExistingConnection->SendTrafficOnDefaultChannel (
                                FALSE,  // IsInChannel
                                D3_A2Context
                                );

                            if (RpcStatus != RPC_S_OK)
                                {
                                FreeRTSPacket(D3_A2Context);
                                break;
                                }

                            RpcStatus = ExistingConnection->PostReceiveOnChannel(
                                &ExistingConnection->InChannels[NonDefaultSelector],
                                http2ttRaw
                                );
                            ExistingConnection->UnblockConnectionFromRundown();

                            // fall through with the obtained RpcStatus
                            }
                        }
                    break;

                case http2svOpened:
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // the only RTS packets we expect in opened state is D2/A5
                    RpcStatus = ParseD2_A5 (Buffer,
                        BufferLength,
                        &NewChannelCookie
                        );

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        {
                        RpcFreeBuffer(Buffer);
                        break;
                        }

                    // send D2/A6 immediately, and queue D2/B1 for sending
                    // Since D2/A6 is the same as D2/A5 (the packet we just
                    // received), we can just forward it
                    RpcStatus = ForwardTrafficToDefaultChannel (
                        FALSE,  // IsInChannel
                        Buffer,
                        BufferLength
                        );

                    if (RpcStatus != RPC_S_OK)
                        break;

                    // we don't own the buffer after a successful send
                    BufferFreed = TRUE;

                    OutChannel = LockDefaultOutChannel (&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    // Allocate D1/B1
                    EmptyRTS = AllocateAndInitializeEmptyRTS ();
                    if (EmptyRTS == NULL)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        break;
                        }

                    EmptyRTS->Flags = SendContextFlagSendLast;
                    RpcStatus = OutChannel->Send(EmptyRTS);
                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus == RPC_S_OK)
                        {
                        // we're done. There were no queued buffers and D1/B1
                        // was sent immediately. When the server aborts its
                        // end of the connection, we will close down
                        break;
                        }
                    else if (RpcStatus == ERROR_IO_PENDING)
                        {
                        // D1/B1 was not sent immediately. When it is sent,
                        // the LastPacketSentNotification mechanism will
                        // destroy the connection. Return success for know
                        RpcStatus = RPC_S_OK;
                        }
                    else
                        {
                        // an error occurred during sending. Free the packet and 
                        // return it back to the caller
                        FreeRTSPacket(EmptyRTS);
                        }
                    break;

                case http2svOpened_A5W:

                    // the only RTS packets we expect in opened_A5W state is D3/A5
                    RpcStatus = ParseAndFreeD3_A5 (Buffer,
                        BufferLength,
                        &NewChannelCookie
                        );

                    BufferFreed = TRUE;

                    CancelTimeout(InChannelTimer);

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    ASSERT(InChannels[0].IsChannelSet() && InChannels[1].IsChannelSet());

                    if (InChannelCookies[GetNonDefaultInChannelSelector()].Compare(&NewChannelCookie))
                        {
                        // abort
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    // switch channels and get rid of the old channel
                    SwitchDefaultInChannelSelector();

                    // drain the queue of buffers received on the non-default
                    // channel (new channel) and actually send them on the new default channel
                    while ((Buffer = (BYTE *) NonDefaultChannelBufferQueue.TakeOffQueue(&BufferLength)) != NULL)
                        {
                        RpcStatus = ForwardTrafficToDefaultChannel(FALSE,   // IsInChannel
                            Buffer,
                            BufferLength
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            RpcFreeBuffer(Buffer);
                            // just exit. During abort the rest of the buffers
                            // will be freed
                            break;
                            }
                        }

                    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;

                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    ChannelPtr = GetChannelPointerFromId(ChannelId);

                    InChannel2 = LockDefaultInChannel(&ChannelPtr2);
                    if (InChannel2 == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    InChannel = (HTTP2InProxyInChannel *)ChannelPtr->LockChannelPointer();
                    if (InChannel == NULL)
                        {
                        ChannelPtr2->UnlockChannelPointer();
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    InChannel->TransferReceiveStateToNewChannel(InChannel2);

                    ChannelPtr2->UnlockChannelPointer();
                    ChannelPtr->UnlockChannelPointer();

                    // detach, abort, and release lifetime reference
                    ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                        TRUE,       // CalledFromUpcallContext
                        TRUE,       // Abort
                        RPC_P_CONNECTION_SHUTDOWN   // AbortStatus
                        );

                    // return success. When the reference for this receive
                    // is removed, the channel will go away
                    RpcStatus = RPC_S_OK;
                    break;

                case http2svB2W:
                    if (IsOutChannel(ChannelId) == FALSE)
                        {
                        ASSERT(0);
                        // make sure client doesn't rush things
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RpcStatus = ParseAndFreeD2_B2(Buffer,
                        BufferLength,
                        &ServerReceiveWindowSize
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    // we know the connection is legitimate - add ourselves
                    // to the collection
                    InProxyCookieCollection = GetInProxyCookieCollection();
                    InProxyCookieCollection->LockCollection();
                    ExistingConnection = (HTTP2InProxyVirtualConnection *)
                        InProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);

                    if (ExistingConnection != NULL)
                        {
                        // the only way we will be in this protocol is if
                        // we were faking a web farm
                        ASSERT (ActAsSeparateMachinesOnWebFarm);
                        ProxyConnectionCookie = ExistingConnection->GetCookie();
                        ProxyConnectionCookie->AddRefCount();
                        }
                    else
                        {
                        // we truly didn't find anything - add ourselves.
                        RpcStatus = AddConnectionToCookieCollection ();
                        if (RpcStatus != RPC_S_OK)
                            {
                            InProxyCookieCollection->UnlockCollection();
                            break;
                            }
                        }

                    InProxyCookieCollection->UnlockCollection();

                    // remember that we are part of the cookie collection now
                    IsConnectionInCollection = TRUE;

                    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // unplug the out channel to get the flow going
                    OutChannel = LockDefaultOutChannel (&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    OutChannel->SetPeerReceiveWindow(ServerReceiveWindowSize);
                    RpcStatus = OutChannel->Unplug();

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus != RPC_S_OK)
                        break;

                    RpcStatus = PostReceiveOnDefaultChannel(FALSE,  // IsInChannel
                        http2ttRaw
                        );
                    break;

                case http2svB3W:
                    ASSERT(IsDefaultOutChannel(ChannelId));
                    RpcStatus = ParseAndFreeD1_B3(Buffer,
                        BufferLength,
                        &ServerReceiveWindowSize,
                        &ProtocolVersion
                        );

                    ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_OK)
                        {
                        RpcStatus = PostReceiveOnChannel(&OutChannels[0], http2ttRaw);
                        if (RpcStatus == RPC_S_OK)
                            {
                            RpcStatus = AddConnectionToCookieCollection();

                            if (RpcStatus == RPC_S_OK)
                                {
                                LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                                State.State = http2svOpened;
                                State.Mutex.Clear();
                                MutexCleared = TRUE;

                                OutChannel = (HTTP2InProxyOutChannel *)OutChannels[0].LockChannelPointer();
                                if (OutChannel)
                                    {
                                    OutChannel->SetPeerReceiveWindow(ServerReceiveWindowSize);
                                    RpcStatus = OutChannel->Unplug();
                                    OutChannels[0].UnlockChannelPointer();
                                    }
                                else
                                    {
                                    RpcStatus = RPC_P_CONNECTION_CLOSED;
                                    }
                                }
                            }
                        }

                    break;

                default:
                    ASSERT(0);
                }
            if (MutexCleared == FALSE)
                State.Mutex.Clear();
            }
        else
            {
            // data packet or RTS packet that needs forwarding. Just forward it
            if (IsDefaultOutChannel(ChannelId))
                {
                // non-RTS packet in any state from out channel
                // is a protocol error
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                }
            else
                {
                if ((State.State == http2svOpened_A5W) 
                    && (IsDefaultInChannel(ChannelId) == FALSE) 
                    && (!IsRTSPacket(Buffer)))
                    {
                    // sends on non-default channel in Opened_A5W state get queued until we
                    // receive D3/A5
                    State.Mutex.Request();
                    if (State.State == http2svOpened_A5W)
                        {
                        if (NonDefaultChannelBufferQueue.PutOnQueue(Buffer, BufferLength))
                            {
                            State.Mutex.Clear();
                            return RPC_S_OUT_OF_MEMORY;
                            }
                        State.Mutex.Clear();

                        // post a receive for the next buffer
                        ChannelPtr = GetChannelPointerFromId(ChannelId);

                        RpcStatus = PostReceiveOnChannel(ChannelPtr, http2ttRaw);

                        return RPC_S_OK;
                        }
                    State.Mutex.Clear();
                    }

                SendContext = AllocateAndInitializeContextFromPacket(Buffer,
                    BufferLength
                    );

                // the buffer is converted to send context. We can't free
                // it directly - we must make sure we free it on failure before exit.
                BufferFreed = TRUE;

                if (SendContext == NULL)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(SendContext->Flags == 0);
                    SendContext->Flags = SendContextFlagProxySend;
                    SendContext->UserData = ConvertChannelIdToSendContextUserData(ChannelId);
                    // make sure we can find it after that
                    ASSERT(MapSendContextUserDataToChannelPtr(SendContext->UserData) != NULL);
                    RpcStatus = SendTrafficOnDefaultChannel(FALSE,  // IsInChannel 
                        SendContext
                        );
                    if (RpcStatus == RPC_S_OK)
                        {
                        ChannelPtr = GetChannelPointerFromId(ChannelId);

                        RpcStatus = PostReceiveOnChannel(ChannelPtr, http2ttRaw);
                        }
                    else
                        {
                        FreeSendContextAndPossiblyData(SendContext);
                        }
                    }
                }
            }
        }
    else
        {
        if (IsInChannel(ChannelId) && !IsDefaultInChannel(ChannelId))
            {
            // ignore errors on non-default in channels. They can go
            // away while we are still sending data to the server.
            // We will destroy the connection when the server is done
            RpcStatus = RPC_S_OK;
            }
        else
            {
            // just turn around the error code
            RpcStatus = EventStatus;
            }
        // in failure cases we don't own the buffer
        BufferFreed = TRUE;
        }

    if (BufferFreed == FALSE)
        RpcFreeBuffer(Buffer);

    return RpcStatus;
}

void HTTP2InProxyVirtualConnection::DisconnectChannels (
    IN BOOL ExemptChannel,
    IN int ExemptChannelId
    )
/*++

Routine Description:

    Disconnects all channels. Must be called from runtime
    or neutral context. Cannot be called from upcall or
    submit context unless an exempt channel is given
    Note that call must synchronize to ensure we're the only
    thread doing the disconnect

Arguments:

    ExemptChannel - non-zero if ExemptChannelId contains a
        valid exempt channel id. FALSE otherwise.

    ExemptChannelId - if ExemptChannel is non-zero, this argument
        is the id of a channel that will be disconnected, but not
        synchronized with up calls.
        If ExampleChannel is FALSE, this argument is undefined

Return Value:

--*/
{
    BYTE *Buffer;
    UINT BufferLength;

    State.Mutex.Request();
    if (State.State == http2svOpened_A5W)
        {
        while ((Buffer = (BYTE *) NonDefaultChannelBufferQueue.TakeOffQueue(&BufferLength)) != NULL)
            {
            RpcFreeBuffer(Buffer);
            }
        }
    State.Mutex.Clear();

    HTTP2ProxyVirtualConnection::DisconnectChannels(ExemptChannel,
        ExemptChannelId
        );
}

RPC_STATUS HTTP2InProxyVirtualConnection::AllocateAndInitializeInChannel (
    IN void *ConnectionParameter,
    OUT HTTP2InProxyInChannel **ReturnInChannel,
    OUT void **IISContext
    )
/*++

Routine Description:

    Allocates and initializes the in proxy in channel.

Arguments:

    ConnectionParameter - really an EXTENSION_CONTROL_BLOCK

    ReturnInChannel - on success the created in channel.

    IISContext - on output, the IISChannel pointer used as 
        connection context with IIS.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2InProxyInChannel *InChannel;
    HTTP2ProxyReceiver *ProxyReceiver;
    HTTP2PingReceiver *PingReceiver;
    HTTP2IISTransportChannel *IISChannel;
    BOOL ProxyReceiverNeedsCleanup;
    BOOL PingReceiverNeedsCleanup;
    BOOL IISChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2IISTransportChannel);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2InProxyInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyInChannel);

    ProxyReceiver = (HTTP2ProxyReceiver *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver);

    PingReceiver = (HTTP2PingReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver);

    IISChannel = (HTTP2IISTransportChannel *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    ProxyReceiverNeedsCleanup = FALSE;
    PingReceiverNeedsCleanup = FALSE;
    IISChannelNeedsCleanup = FALSE;
    RpcStatus = RPC_S_OK;

    IISChannel = new (IISChannel) HTTP2IISTransportChannel (ConnectionParameter);

    IISChannelNeedsCleanup = TRUE;

    ProxyReceiver = new (ProxyReceiver) HTTP2ProxyReceiver (HTTP2InProxyReceiveWindow,
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ProxyReceiver->HTTP2ProxyReceiver::~HTTP2ProxyReceiver();
        goto AbortAndExit;
        }

    IISChannel->SetUpperChannel(ProxyReceiver);
    ProxyReceiver->SetLowerChannel(IISChannel);

    ProxyReceiverNeedsCleanup = TRUE;

    PingReceiver = new (PingReceiver) HTTP2PingReceiver(TRUE);
    if (RpcStatus != RPC_S_OK)
        {
        PingReceiver->HTTP2PingReceiver::~HTTP2PingReceiver();
        goto AbortAndExit;
        }

    ProxyReceiver->SetUpperChannel(PingReceiver);
    PingReceiver->SetLowerChannel(ProxyReceiver);

    PingReceiverNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2InProxyInChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2InProxyInChannel::~HTTP2InProxyInChannel();
        goto AbortAndExit;
        }

    PingReceiver->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(PingReceiver);

    IISChannel->SetTopChannel(InChannel);
    ProxyReceiver->SetTopChannel(InChannel);
    PingReceiver->SetTopChannel(InChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnInChannel = InChannel;
    *IISContext = IISChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PingReceiverNeedsCleanup)
        {
        PingReceiver->Abort(RpcStatus);
        PingReceiver->FreeObject();
        }
    else if (ProxyReceiverNeedsCleanup)
        {
        ProxyReceiver->Abort(RpcStatus);
        ProxyReceiver->FreeObject();
        }
    else if (IISChannelNeedsCleanup)
        {
        IISChannel->Abort(RpcStatus);
        IISChannel->FreeObject();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::AllocateAndInitializeOutChannel (
    OUT HTTP2InProxyOutChannel **ReturnOutChannel
    )
/*++

Routine Description:

    Allocates and initializes the in proxy out channel.

Arguments:

    ReturnInChannel - on success the created in channel.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2InProxyOutChannel *OutChannel;
    HTTP2ProxyPlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2ProxySocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel)
        + sizeof(WS_HTTP2_CONNECTION);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2InProxyOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2InProxyOutChannel);

    PlugChannel = (HTTP2ProxyPlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    RawChannel = (HTTP2ProxySocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
    RawConnection->HeaderRead = FALSE;
    RawConnection->ReadHeaderFn = HTTP2ReadHttpLegacyResponse;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;

    RawConnection->Initialize();
    RawConnection->type = COMPLEX_T | CONNECTION | CLIENT;

    RawConnectionNeedsCleanup = TRUE;

    RpcStatus = RPC_S_OK;
    RawChannel = new (RawChannel) HTTP2ProxySocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2ProxySocketTransportChannel::~HTTP2ProxySocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (FALSE,  // IsServer
        FALSE,      // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(RawChannel);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2ProxyPlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2ProxyPlugChannel::~HTTP2ProxyPlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2InProxyOutChannel (this, 
        RawConnection, 
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2InProxyOutChannel::~HTTP2InProxyOutChannel();
        goto AbortAndExit;
        }

    PlugChannel->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(PlugChannel);

    RawChannel->SetTopChannel(OutChannel);
    FlowControlSender->SetTopChannel(OutChannel);
    PlugChannel->SetTopChannel(OutChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnOutChannel = OutChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::ConnectToServer (
    void
    )
/*++

Routine Description:

    Connects to the server

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyOutChannel *OutChannel;
    RPC_STATUS RpcStatus;

    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    // we don't have any async operations to abort the connection
    // yet - the out channel must be there
    ASSERT(OutChannel);
    RpcStatus = OutChannel->InitializeRawConnection(ServerName,
        ServerPort,
        ConnectionTimeout,
        ProxyCallbackInterface->IsValidMachineFn
        );

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::SendD1_B2ToServer (
    void
    )
/*++

Routine Description:

    Sends D1/B2 to server

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyOutChannel *OutChannel;
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;
    BOOL SendSucceeded = FALSE;

    SendContext = AllocateAndInitializeD1_B2(ProtocolVersion,
        &EmbeddedConnectionCookie,
        &InChannelCookies[0],
        HTTP2InProxyReceiveWindow,
        IISConnectionTimeout,
        &AssociationGroupId,
        &ClientAddress
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    // we don't have any async operations to abort the connection
    // yet - the out channel must be there
    ASSERT(OutChannel);
    RpcStatus = OutChannel->Send(SendContext);
    if (RpcStatus == RPC_S_OK)
        {
        SendSucceeded = TRUE;
        RpcStatus = OutChannel->Receive(http2ttRaw);
        }
    ChannelPtr->UnlockChannelPointer();

    if (SendSucceeded == FALSE)
        {
        FreeRTSPacket(SendContext);
        }

    return RpcStatus;
}

RPC_STATUS HTTP2InProxyVirtualConnection::SendD2_A2ToServer (
    void
    )
/*++

Routine Description:

    Sends D2/A2 to server

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2InProxyOutChannel *OutChannel;
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;
    BOOL SendSucceeded = FALSE;

    SendContext = AllocateAndInitializeD2_A2(ProtocolVersion,
        &EmbeddedConnectionCookie,
        &InChannelCookies[1],
        &InChannelCookies[0],
        HTTP2InProxyReceiveWindow,
        IISConnectionTimeout
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = LockDefaultOutChannel(&ChannelPtr);
    // we don't have any async operations to abort the connection
    // yet - the out channel must be there
    ASSERT(OutChannel);
    RpcStatus = OutChannel->Send(SendContext);
    if (RpcStatus == RPC_S_OK)
        {
        SendSucceeded = TRUE;
        RpcStatus = OutChannel->Receive(http2ttRaw);
        }
    ChannelPtr->UnlockChannelPointer();

    if (SendSucceeded == FALSE)
        {
        FreeRTSPacket(SendContext);
        }

    return RpcStatus;
}

/*********************************************************************
    HTTP2OutProxyInChannel
 *********************************************************************/

RPC_STATUS HTTP2OutProxyInChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack back to the server

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    return ForwardFlowControlAckOnThisChannel(BytesReceivedForAck,
        WindowForAck,
        FALSE   // NonChannelData
        );
}

/*********************************************************************
    HTTP2OutProxyOutChannel
 *********************************************************************/

RPC_STATUS HTTP2OutProxyOutChannel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support last packet notifications

Arguments:

    LastSendContext - the context for the last send

Return Value:

    The value to return to the bottom channel

--*/
{
    HTTP2OutProxyVirtualConnection *VirtualConnection;

    ASSERT(LastSendContext->Flags & SendContextFlagSendLast);
    ASSERT((LastSendContext->UserData == oplptD4_A10)
        || (LastSendContext->UserData == oplptD5_B3));

    VirtualConnection = (HTTP2OutProxyVirtualConnection *)LockParentPointer();
    // if the connection was already aborted, nothing to do
    if (VirtualConnection == NULL)
        return RPC_P_PACKET_CONSUMED;

    // we know the parent will disconnect from us in their
    // notification
    VirtualConnection->LastPacketSentNotification(ChannelId,
        LastSendContext);

    if (LastSendContext->UserData == oplptD5_B3)
        {
        // if we are about to send D5_B3, this is the last packet
        // on the channel. Detach from the parent and return an
        // error
        UnlockParentPointer();

        DrainUpcallsAndFreeParent();
        }

    // just shutdown the connection or what has remained of it
    // (only this channel in the D5_B3 case)
    return RPC_P_CONNECTION_SHUTDOWN;
}

void HTTP2OutProxyOutChannel::PingTrafficSentNotify (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Notifies a channel that ping traffic has been sent.

Arguments:

    PingTrafficSize - the size of the ping traffic sent.

--*/
{
    BOOL Result;

    AccumulatedPingTraffic += PingTrafficSize;
    if (AccumulatedPingTraffic >= AccumulatedPingTrafficNotifyThreshold)
        {
        Result = PingTrafficSentNotifyServer (AccumulatedPingTraffic);
        if (Result)
            AccumulatedPingTraffic = 0;
        }
}

BOOL HTTP2OutProxyOutChannel::PingTrafficSentNotifyServer (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Sends a notification to the server that ping traffic originated
    at the out proxy has been sent. This allows to server to do
    proper accounting for when to recycle the out channel.

Arguments:

    PingTrafficSize - the size of the ping traffic to notify the
        server about.

Return Value:

    Non-zero if the notification was sent successfully.
    0 otherwise.

--*/
{
    HTTP2OutProxyVirtualConnection *VirtualConnection;
    BOOL Result;

    VirtualConnection = (HTTP2OutProxyVirtualConnection *)LockParentPointer();
    // if the connection was already aborted, nothing to do
    if (VirtualConnection == NULL)
        return TRUE;

    Result = VirtualConnection->PingTrafficSentNotifyServer(PingTrafficSize);

    UnlockParentPointer();

    return Result;
}

/*********************************************************************
    HTTP2OutProxyVirtualConnection
 *********************************************************************/

RPC_STATUS HTTP2OutProxyVirtualConnection::InitializeProxyFirstLeg (
    IN USHORT *ServerAddress,
    IN USHORT *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface,
    void **IISContext
    )
/*++

Routine Description:

    Initialize the proxy.

Arguments:

    ServerAddress - unicode pointer string to the server network address.

    ServerPort - unicode pointer string to the server port

    ConnectionParameter - the extension control block in this case

    ProxyCallbackInterface - a callback interface to the proxy to perform
        various proxy specific functions.

    IISContext - on output (success only) it must be initialized to
        the bottom IISChannel for the InProxy.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2OutProxyOutChannel *NewOutChannel;
    int OutChannelId;
    int ServerAddressLength;    // in characters + terminating 0

    // initialize out channel
    RpcStatus = AllocateAndInitializeOutChannel(ConnectionParameter,
        &NewOutChannel,
        IISContext
        );

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    SetFirstOutChannel(NewOutChannel);

    this->ProxyCallbackInterface = ProxyCallbackInterface;
    this->ConnectionParameter = ConnectionParameter;

    ServerAddressLength = RpcpStringLength(ServerAddress) + 1;
    ServerName = new RPC_CHAR [ServerAddressLength];

    if (ServerName == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcpMemoryCopy(ServerName, ServerAddress, ServerAddressLength * 2);

    RpcStatus = EndpointToPortNumber(ServerPort, this->ServerPort);

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::StartProxy (
    void
    )
/*++

Routine Description:

    Kicks off listening on the proxy

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2OutProxyOutChannel *Channel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svClosed, 1, 0);
    State.State = http2svClosed;    // move to closed state expecting the opening RTS packet

    Channel = LockDefaultOutChannel(&ChannelPtr);

    ASSERT(Channel != NULL);  // we cannot be disconnected now    

    RpcStatus = Channel->Receive(http2ttRaw);

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::InitializeProxySecondLeg (
    void
    )
/*++

Routine Description:

    Initialize the proxy.

Arguments:

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2OutProxyInChannel *NewInChannel;
    int InChannelId;

    // initialize in channel
    RpcStatus = AllocateAndInitializeInChannel(
        &NewInChannel
        );

    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        return RpcStatus;
        }

    SetFirstInChannel(NewInChannel);

    RpcStatus = ProxyCallbackInterface->GetConnectionTimeoutFn(&IISConnectionTimeout);
    if (RpcStatus != RPC_S_OK)
        {
        Abort();
        return RpcStatus;
        }

    IISConnectionTimeout *= 1000;

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error
    Buffer - buffer received
    BufferLength - length of buffer received
    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    RPC_STATUS RpcStatus;
    BOOL BufferFreed = FALSE;
    BOOL MutexCleared;
    ULONG ChannelLifetime;
    ULONG Ignored;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *ChannelPtr2;
    HTTP2OutProxyOutChannel *OutChannel;
    HTTP2OutProxyOutChannel *OutChannel2;
    CookieCollection *OutProxyCookieCollection;
    BYTE *CurrentPosition;
    rpcconn_tunnel_settings *RTS;
    HTTP2SendContext *D5_A4Context;
    HTTP2OutProxyVirtualConnection *ExistingConnection;
    int NonDefaultSelector;
    int DefaultSelector;
    HTTP2SendContext *D4_A10Context;
    BOOL IsAckOrNak;
    HTTP2SendContext *D5_B3Context;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2Cookie CookieForChannel;
    ULONG ClientReceiveWindowSize;
    HTTP2SendContext *SendContext;

    VerifyValidChannelId(ChannelId);

    if (EventStatus == RPC_S_OK)
        {
        // N.B. All recieve packets are guaranteed to be
        // validated up to the common conn packet size
        if (IsRTSPacket(Buffer))
            {
            RpcStatus = HTTPTransInfo->CreateThread();
            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                return RpcStatus;
                }

            RpcStatus = CheckPacketForForwarding(Buffer,
                BufferLength,
                fdOutProxy
                );
            }

        if (IsRTSPacket(Buffer) && (RpcStatus != RPC_P_PACKET_NEEDS_FORWARDING))
            {
            // RTS packet - check what we need to do with it
            if (IsOtherCmdPacket(Buffer, BufferLength))
                {
                // the only other cmd packets we expect in the proxy are
                // flow control acks
                RpcStatus = ParseAndFreeFlowControlAckPacketWithDestination (Buffer,
                    BufferLength,
                    fdOutProxy,
                    &BytesReceivedForAck,
                    &WindowForAck,
                    &CookieForChannel
                    );

                BufferFreed = TRUE;

                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                // notify the flow control sender about the ack
                OutChannel = (HTTP2OutProxyOutChannel *)MapCookieToAnyChannelPointer(
                    &CookieForChannel, 
                    &ChannelPtr
                    );
                if (OutChannel)
                    {
                    RpcStatus = OutChannel->FlowControlAckNotify(BytesReceivedForAck,
                        WindowForAck
                        );

                    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

                    ChannelPtr->UnlockChannelPointer();
                    }

                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                // post another receive
                RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                    http2ttRaw
                    );

                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                return RPC_P_PACKET_CONSUMED;
                }

            MutexCleared = FALSE;
            State.Mutex.Request();
            switch (State.State)
                {
                case http2svClosed:
                    // for closed states, we must receive
                    // stuff only on the default out (client) channel
                    ASSERT(IsDefaultOutChannel(ChannelId));

                    CurrentPosition = ValidateRTSPacketCommon(Buffer,
                        BufferLength
                        );

                    if (CurrentPosition == NULL)
                        {
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RTS = (rpcconn_tunnel_settings *)Buffer;
                    if ((RTS->Flags & RTS_FLAG_RECYCLE_CHANNEL) == 0)
                        {
                        RpcStatus = ParseAndFreeD1_A1(Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &OutChannelCookies[0],
                            &ClientReceiveWindowSize
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus == RPC_S_OK)
                            {
                            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svC1W, 1, 0);
                            State.State = http2svC1W;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            RpcStatus = InitializeProxySecondLeg();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = ConnectToServer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendHeaderToClient();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            if (OutChannel == NULL)
                                {
                                RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                                break;
                                }

                            OutChannel->SetPeerReceiveWindow(ClientReceiveWindowSize);
                            RpcStatus = OutChannel->SetConnectionTimeout(IISConnectionTimeout);
                            ChannelPtr->UnlockChannelPointer();

                            // zero out the in channel cookie
                            InChannelCookies[0].ZeroOut();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendD1_A3ToClient();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendD1_A2ToServer(DefaultChannelLifetime);
                            }
                        }
                    else
                        {
                        RpcStatus = ParseAndFreeD4_A3 (Buffer,
                            BufferLength,
                            &ProtocolVersion,
                            &EmbeddedConnectionCookie,
                            &OutChannelCookies[1],   // Old cookie - use OutChannelCookies[1] 
                                                    // as temporary storage only
                            &OutChannelCookies[0],   // New cookie
                            &ClientReceiveWindowSize
                            );

                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            break;

                        // caller claims this is recycling for an already existing connection
                        // find out this connection
                        OutProxyCookieCollection = GetOutProxyCookieCollection();
                        OutProxyCookieCollection->LockCollection();
                        ExistingConnection = (HTTP2OutProxyVirtualConnection *)
                            OutProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);
                        if (ExistingConnection == NULL || ActAsSeparateMachinesOnWebFarm)
                            {
                            // no dice. Probably we executed on a different machine on the web farm
                            // proceed as a standalone connection
                            OutProxyCookieCollection->UnlockCollection();

                            LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svA11W, 1, 0);
                            State.State = http2svA11W;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            RpcStatus = InitializeProxySecondLeg();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            // we cannot be aborted here
                            ASSERT(OutChannel);
                            OutChannel->SetPeerReceiveWindow(ClientReceiveWindowSize);
                            // make sure no packets (RTS or other) go out until
                            // we get out D4/A11 and send out the header response
                            OutChannel->SetStrongPlug();
                            ChannelPtr->UnlockChannelPointer();

                            // zero out the in channel cookie
                            InChannelCookies[0].ZeroOut();

                            RpcStatus = ConnectToServer();

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = SendD4_A4ToServer(DefaultChannelLifetime);

                            if (RpcStatus != RPC_S_OK)
                                break;

                            RpcStatus = PostReceiveOnDefaultChannel(FALSE,  // IsInChannel
                                http2ttRaw
                                );
                            }
                        else
                            {
                            // detach the out channel from this connection and attach
                            // it to the found connection. Grab a reference to it
                            // to prevent the case where it goes away underneath us
                            // we know that in its current state the connection is single
                            // threaded because we are in the completion path of the 
                            // only async operation
                            ChannelPtr = GetChannelPointerFromId(ChannelId);
                            OutChannel = (HTTP2OutProxyOutChannel *)ChannelPtr->LockChannelPointer();
                            // there is no way that somebody detached the channel here
                            ASSERT(OutChannel);

                            // add a reference to keep the channel alive while we disconnect it
                            OutChannel->AddReference();

                            ChannelPtr->UnlockChannelPointer();

                            // no need to drain the upcalls - we know we are the only
                            // upcall
                            ChannelPtr->FreeChannelPointer(
                                FALSE,      // DrainUpCalls
                                FALSE,      // CalledFromUpcallContext
                                FALSE,      // Abort
                                RPC_S_OK
                                );

                            DefaultSelector = ExistingConnection->DefaultOutChannelSelector;
                            NonDefaultSelector = ExistingConnection->GetNonDefaultOutChannelSelector();
                            if (ExistingConnection->OutChannelCookies[DefaultSelector].Compare (&OutChannelCookies[1]))
                                {
                                // nice try - cookies are different. Ditch the newly established channel
                                OutProxyCookieCollection->UnlockCollection();
                                OutChannel->RemoveReference();
                                RpcStatus = RPC_S_PROTOCOL_ERROR;
                                break;
                                }

                            OutChannel2 = ExistingConnection->LockDefaultOutChannel(&ChannelPtr2);
                            if (OutChannel2 == NULL)
                                {
                                OutProxyCookieCollection->UnlockCollection();
                                OutChannel->RemoveReference();
                                RpcStatus = RPC_S_PROTOCOL_ERROR;
                                break;
                                }

                            ClientReceiveWindowSize = OutChannel2->GetPeerReceiveWindow();
                            ChannelPtr2->UnlockChannelPointer();

                            OutChannel->SetPeerReceiveWindow(ClientReceiveWindowSize);

                            OutChannel->SetParent(ExistingConnection);
                            ExistingConnection->OutChannels[NonDefaultSelector].SetChannel(OutChannel);
                            ExistingConnection->OutChannelCookies[NonDefaultSelector].SetCookie(OutChannelCookies[0].GetCookie());
                            ExistingConnection->OutChannelIds[NonDefaultSelector] = ChannelId;

                            // check if connection is aborted
                            if (ExistingConnection->Aborted.GetInteger() > 0)
                                {
                                OutChannel->Abort(RPC_P_CONNECTION_SHUTDOWN);
                                }

                            // the extra reference that we added above passes to the existing connection
                            // However, below we party on the existing connection and we need to keep it alive
                            ExistingConnection->BlockConnectionFromRundown();
                            OutProxyCookieCollection->UnlockCollection();

                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            // nuke the rest of the old connection

                            // we got to the destructive phase of the abort
                            // guard against double aborts
                            if (Aborted.Increment() <= 1)
                                {
                                // abort the channels
                                AbortChannels(RPC_P_CONNECTION_SHUTDOWN);

                                DisconnectChannels(FALSE,       // ExemptChannel
                                    0                           // ExemptChannel id
                                    );

                                delete this;
                                // N.B. don't touch the this pointer after here
                                }

                            // post another receive on the new channel
                            RpcStatus = PostReceiveOnChannel (&(ExistingConnection->OutChannels[NonDefaultSelector]),
                                http2ttRaw);
                            if (RpcStatus != RPC_S_OK)
                                {
                                ExistingConnection->UnblockConnectionFromRundown();
                                break;
                                }

                            ExistingConnection->State.Mutex.Request();
                            LogEvent(SU_HTTPv2, EV_STATE, ExistingConnection, OUT_CHANNEL_STATE, http2svOpened_B1W, 1, 0);
                            ExistingConnection->State.State = http2svOpened_B1W;
                            ExistingConnection->State.Mutex.Clear();

                            // send D5/A4 to server
                            D5_A4Context = AllocateAndInitializeD5_A4(&ExistingConnection->OutChannelCookies[NonDefaultSelector]);
                            if (D5_A4Context == NULL)
                                {
                                ExistingConnection->UnblockConnectionFromRundown();
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                break;
                                }

                            RpcStatus = ExistingConnection->SendTrafficOnDefaultChannel (
                                TRUE,  // IsInChannel
                                D5_A4Context
                                );

                            if (RpcStatus != RPC_S_OK)
                                FreeRTSPacket(D5_A4Context);

                            ExistingConnection->UnblockConnectionFromRundown();

                            // fall through with the obtained RpcStatus
                            }
                        }
                    break;

                case http2svOpened:
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // the only RTS packets we expect in opened state is D4/A9
                    RpcStatus = ParseAndFreeD4_A9 (Buffer,
                        BufferLength
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    // queue D4/A10 for sending
                    // First, allocate D4/A10
                    D4_A10Context = AllocateAndInitializeD4_A10 ();
                    if (D4_A10Context == NULL)
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        break;
                        }

                    D4_A10Context->Flags = SendContextFlagSendLast;
                    D4_A10Context->UserData = oplptD4_A10;
                    RpcStatus = SendTrafficOnDefaultChannel (FALSE,     // IsInChannel
                        D4_A10Context);

                    if (RpcStatus == RPC_S_OK)
                        {
                        // we're done. There were no queued buffers and D4/A10
                        // was sent immediately. Close down
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }
                    else if (RpcStatus == ERROR_IO_PENDING)
                        {
                        // D4/A10 was not sent immediately. When it is sent,
                        // the LastPacketSentNotification mechanism will
                        // destroy the connection. Return success for know
                        RpcStatus = RPC_S_OK;
                        }
                    else
                        {
                        // an error occurred during sending. Free the packet and 
                        // return error back to the caller
                        FreeRTSPacket(D4_A10Context);
                        }
                    break;

                case http2svC1W:
                    ASSERT(IsDefaultInChannel(ChannelId));
                    RpcStatus = ParseD1_C1(Buffer,
                        BufferLength,
                        &ProtocolVersion,
                        &Ignored,   // InProxyReceiveWindowSize
                        &Ignored    // InProxyConnectionTimeout
                        );

                    if (RpcStatus == RPC_S_OK)
                        {
                        ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

                        RpcStatus = AddConnectionToCookieCollection();

                        if (RpcStatus == RPC_S_OK)
                            {
                            LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                            State.State = http2svOpened;
                            State.Mutex.Clear();
                            MutexCleared = TRUE;

                            OutChannel = LockDefaultOutChannel(&ChannelPtr);
                            if (OutChannel != NULL)
                                {
                                RpcStatus = OutChannel->ForwardTraffic(Buffer,
                                    BufferLength
                                    );

                                if (RpcStatus == RPC_S_OK)
                                    {
                                    BufferFreed = TRUE;
                                    RpcStatus = PostReceiveOnChannel(&InChannels[0], http2ttRaw);

                                    if (RpcStatus == RPC_S_OK)
                                        {
                                        RpcStatus = OutChannel->Unplug();
                                        }
                                    }

                                ChannelPtr->UnlockChannelPointer();
                                }
                            else
                                RpcStatus = RPC_P_CONNECTION_CLOSED;
                            }
                        }
                    break;

                case http2svOpened_CliW:
                    break;

                case http2svOpened_B1W:
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // the only RTS packets we expect in opened state is D5/B1 or D2/B2
                    RpcStatus = ParseAndFreeD5_B1orB2 (Buffer,
                        BufferLength,
                        &IsAckOrNak
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus != RPC_S_OK)
                        break;

                    OutChannel = LockDefaultOutChannel(&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    // keep an extra reference for after we detach the
                    // channel 
                    OutChannel->AddReference();
                    ChannelPtr->UnlockChannelPointer();

                    if (IsAckOrNak == FALSE)
                        {
                        // Nak - nuke the non-default channel
                        // and move to state opened
                        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                            FALSE,      // CalledFromUpcallContext
                            TRUE,       // Abort
                            RPC_S_PROTOCOL_ERROR
                            );

                        // switch to state opened
                        State.Mutex.Request();
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        State.State = http2svOpened;                    
                        State.Mutex.Clear();

                        break;
                        }

                    SwitchDefaultOutChannelSelector();

                    // Send D5/B3 to client
                    D5_B3Context = AllocateAndInitializeD5_B3();

                    if (D5_B3Context == NULL)
                        {
                        OutChannel->RemoveReference();
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        break;
                        }

                    D5_B3Context->Flags = SendContextFlagSendLast;
                    D5_B3Context->UserData = oplptD5_B3;
                    RpcStatus = OutChannel->Send(D5_B3Context);

                    if (RpcStatus == RPC_S_OK)
                        {
                        // synchronous send. Abort and detach the old channel
                        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                            FALSE,      // CalledFromUpcallContext
                            TRUE,      // Abort
                            RPC_P_CONNECTION_SHUTDOWN
                            );
                        }
                    else if (RpcStatus == ERROR_IO_PENDING)
                        {
                        // async send. Just release our reference
                        // and return success
                        RpcStatus = RPC_S_OK;
                        }
                    else
                        {
                        // failed to send. Abort all
                        FreeRTSPacket(D5_B3Context);
                        OutChannel->Abort(RpcStatus);
                        OutChannel->RemoveReference();
                        break;
                        }

                    // release the extra reference
                    OutChannel->RemoveReference();

                    // switch to state opened
                    State.Mutex.Request();
                    LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;                    
                    State.Mutex.Clear();

                    // unplug the newly created channel
                    OutChannel = LockDefaultOutChannel(&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    RpcStatus = OutChannel->Unplug();

                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    // send the header response to the client
                    RpcStatus = SendHeaderToClient();
                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    // set the connection timeout

                    RpcStatus = OutChannel->SetConnectionTimeout(IISConnectionTimeout);

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus != RPC_S_OK)
                        break;

                    // post another receive on the channel
                    RpcStatus = PostReceiveOnDefaultChannel(TRUE,   // IsInChannel
                        http2ttRaw);
                    // fall through with the new error code
                    break;

                case http2svA11W:
                    if (IsOutChannel(ChannelId) == FALSE)
                        {
                        ASSERT(0);
                        // make sure client doesn't rush things
                        RpcStatus = RPC_S_PROTOCOL_ERROR;
                        break;
                        }

                    RpcStatus = ParseAndFreeD4_A11(Buffer,
                        BufferLength
                        );

                    BufferFreed = TRUE;

                    if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                        break;

                    // now that we know the new channel is legit, add it to the
                    // collection
                    OutProxyCookieCollection = GetOutProxyCookieCollection();
                    OutProxyCookieCollection->LockCollection();
                    ExistingConnection = (HTTP2OutProxyVirtualConnection *)
                        OutProxyCookieCollection->FindElement(&EmbeddedConnectionCookie);
                    if (ExistingConnection != NULL)
                        {
                        // the only way we will be in this protocol is if
                        // we were faking a web farm
                        ASSERT (ActAsSeparateMachinesOnWebFarm);
                        ProxyConnectionCookie = ExistingConnection->GetCookie();
                        ProxyConnectionCookie->AddRefCount();
                        }
                    else
                        {
                        // we truly didn't find anything - add ourselves.
                        RpcStatus = AddConnectionToCookieCollection ();
                        if (RpcStatus != RPC_S_OK)
                            {
                            OutProxyCookieCollection->UnlockCollection();
                            break;
                            }
                        }
                    OutProxyCookieCollection->UnlockCollection();

                    LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                    State.State = http2svOpened;
                    State.Mutex.Clear();
                    MutexCleared = TRUE;

                    // unplug the out channel to get the flow going
                    OutChannel = LockDefaultOutChannel (&ChannelPtr);
                    if (OutChannel == NULL)
                        {
                        RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                        break;
                        }

                    RpcStatus = SendHeaderToClient();
                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    RpcStatus = OutChannel->SetConnectionTimeout(IISConnectionTimeout);
                    if (RpcStatus != RPC_S_OK)
                        {
                        ChannelPtr->UnlockChannelPointer();
                        break;
                        }

                    RpcStatus = OutChannel->Unplug();

                    ChannelPtr->UnlockChannelPointer();

                    break;

                case http2svOpened_A5W:
                    break;

                case http2svB2W:
                    break;

                default:
                    ASSERT(0);
                }
            if (MutexCleared == FALSE)
                State.Mutex.Clear();
            }
        else
            {
            // data packet or RTS packet that needs forwarding. Just forward it
            ASSERT (IsDefaultInChannel(ChannelId));

            if (State.State == http2svC1W)
                {
                // non-RTS packet or forward RTS packet in C1W state from out channel
                // is a protocol error
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                }
            else
                {
                SendContext = AllocateAndInitializeContextFromPacket(Buffer,
                    BufferLength
                    );

                // the buffer is converted to send context. We can't free
                // it directly - we must make sure we free it on failure before exit.
                BufferFreed = TRUE;

                if (SendContext == NULL)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(SendContext->Flags == 0);
                    SendContext->Flags = SendContextFlagProxySend;
                    SendContext->UserData = ConvertChannelIdToSendContextUserData(ChannelId);
                    RpcStatus = SendTrafficOnDefaultChannel(FALSE,  // IsInChannel 
                        SendContext
                        );
                    if (RpcStatus == RPC_S_OK)
                        {
                        ChannelPtr = GetChannelPointerFromId(ChannelId);

                        RpcStatus = PostReceiveOnChannel(ChannelPtr, http2ttRaw);
                        }
                    else
                        {
                        FreeSendContextAndPossiblyData(SendContext);
                        }
                    }                
                }
            }
        }
    else
        {
        // just turn around the error code
        RpcStatus = EventStatus;
        // in failure cases we don't own the buffer
        BufferFreed = TRUE;
        }

    if (BufferFreed == FALSE)
        RpcFreeBuffer(Buffer);

    return RpcStatus;
}

BOOL HTTP2OutProxyVirtualConnection::PingTrafficSentNotifyServer (
    IN ULONG PingTrafficSize
    )
/*++

Routine Description:

    Sends a notification to the server that ping traffic originated
    at the out proxy has been sent. This allows to server to do
    proper accounting for when to recycle the out channel.
    The function is called from neutral upcall context. It can't
    return an error, and it can't abort.

Arguments:

    PingTrafficSize - the size of the ping traffic to notify the
        server about.

Return Value:

    Non-zero if the notification was sent successfully.
    0 otherwise.

--*/
{
    HTTP2SendContext *PingTrafficSentContext;
    RPC_STATUS RpcStatus;

    PingTrafficSentContext = AllocateAndInitializePingTrafficSentNotifyPacket (PingTrafficSize);
    if (PingTrafficSentContext == NULL)
        return FALSE;

    RpcStatus = SendTrafficOnDefaultChannel (TRUE,      // IsInChannel
        PingTrafficSentContext
        );

    if (RpcStatus != RPC_S_OK)
        {
        FreeRTSPacket(PingTrafficSentContext);
        return FALSE;
        }
    else
        return TRUE;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::AllocateAndInitializeInChannel (
    OUT HTTP2OutProxyInChannel **ReturnInChannel
    )
/*++

Routine Description:

    Allocates and initializes the out proxy in channel.

Arguments:

    ReturnInChannel - on success the created in channel.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2OutProxyInChannel *InChannel;
    HTTP2ProxyReceiver *ProxyReceiver;
    HTTP2ProxySocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL ProxyReceiverNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    BOOL RawConnectionNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel)
        + sizeof(WS_HTTP2_CONNECTION);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2OutProxyInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyInChannel);

    ProxyReceiver = (HTTP2ProxyReceiver *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyReceiver);

    RawChannel = (HTTP2ProxySocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxySocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;
    RawConnection->HeaderRead = FALSE;
    RawConnection->ReadHeaderFn = HTTP2ReadHttpLegacyResponse;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    ProxyReceiverNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;
    RawConnectionNeedsCleanup = FALSE;

    RawConnection->Initialize();
    RawConnection->type = COMPLEX_T | CONNECTION | CLIENT;

    RawConnectionNeedsCleanup = TRUE;

    RpcStatus = RPC_S_OK;
    RawChannel = new (RawChannel) HTTP2ProxySocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2ProxySocketTransportChannel::~HTTP2ProxySocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    ProxyReceiver = new (ProxyReceiver) HTTP2ProxyReceiver (HTTP2OutProxyReceiveWindow,
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ProxyReceiver->HTTP2ProxyReceiver::~HTTP2ProxyReceiver();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(ProxyReceiver);
    ProxyReceiver->SetLowerChannel(RawChannel);

    ProxyReceiverNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2OutProxyInChannel (this, 
        RawConnection, 
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2OutProxyInChannel::~HTTP2OutProxyInChannel();
        goto AbortAndExit;
        }

    ProxyReceiver->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(ProxyReceiver);

    RawChannel->SetTopChannel(InChannel);
    ProxyReceiver->SetTopChannel(InChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnInChannel = InChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (ProxyReceiverNeedsCleanup)
        {
        ProxyReceiver->Abort(RpcStatus);
        ProxyReceiver->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    else if (RawConnectionNeedsCleanup)
        {
        RawConnection->RealAbort();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::AllocateAndInitializeOutChannel (
    IN void *ConnectionParameter,
    OUT HTTP2OutProxyOutChannel **ReturnOutChannel,
    OUT void **IISContext
    )
/*++

Routine Description:

    Allocates and initializes the out proxy out channel.

Arguments:

    ConnectionParameter - really an EXTENSION_CONTROL_BLOCK

    ReturnOutChannel - on success the created out channel.

    IISContext - on output, the IISChannel pointer used as 
        connection context with IIS.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2OutProxyOutChannel *OutChannel;
    HTTP2ProxyPlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2PingOriginator *PingOriginator;
    HTTP2PingReceiver *PingReceiver;
    HTTP2IISSenderTransportChannel *IISChannel;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL PingOriginatorNeedsCleanup;
    BOOL PingReceiverNeedsCleanup;
    BOOL IISChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2IISSenderTransportChannel)
        ;

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2OutProxyOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2OutProxyOutChannel);

    PlugChannel = (HTTP2ProxyPlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ProxyPlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    PingOriginator = (HTTP2PingOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingOriginator);

    PingReceiver = (HTTP2PingReceiver *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PingReceiver);

    IISChannel = (HTTP2IISSenderTransportChannel *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    PingOriginatorNeedsCleanup = FALSE;
    PingReceiverNeedsCleanup = FALSE;
    IISChannelNeedsCleanup = FALSE;
    RpcStatus = RPC_S_OK;

    IISChannel = new (IISChannel) HTTP2IISSenderTransportChannel (ConnectionParameter, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        IISChannel->HTTP2IISSenderTransportChannel::~HTTP2IISSenderTransportChannel();
        goto AbortAndExit;
        }

    IISChannelNeedsCleanup = TRUE;

    PingReceiver = new (PingReceiver) HTTP2PingReceiver (FALSE);

    IISChannel->SetUpperChannel(PingReceiver);
    PingReceiver->SetLowerChannel(IISChannel);

    PingReceiverNeedsCleanup = TRUE;

    PingOriginator = new (PingOriginator) HTTP2PingOriginator (
        TRUE        // NotifyTopChannelForPings
        );

    PingReceiver->SetUpperChannel(PingOriginator);
    PingOriginator->SetLowerChannel(PingReceiver);

    PingOriginatorNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (FALSE,      // IsServer
        FALSE,      // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    PingOriginator->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(PingOriginator);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2ProxyPlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2ProxyPlugChannel::~HTTP2ProxyPlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2OutProxyOutChannel (this, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2OutProxyOutChannel::~HTTP2OutProxyOutChannel();
        goto AbortAndExit;
        }

    PlugChannel->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(PlugChannel);

    IISChannel->SetTopChannel(OutChannel);
    PingOriginator->SetTopChannel(OutChannel);
    PingReceiver->SetTopChannel(OutChannel);
    FlowControlSender->SetTopChannel(OutChannel);
    PlugChannel->SetTopChannel(OutChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    *ReturnOutChannel = OutChannel;
    *IISContext = IISChannel;

    goto CleanupAndExit;

AbortAndExit:
    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (PingOriginatorNeedsCleanup)
        {
        PingOriginator->Abort(RpcStatus);
        PingOriginator->FreeObject();
        }
    else if (PingReceiverNeedsCleanup)
        {
        PingReceiver->Abort(RpcStatus);
        PingReceiver->FreeObject();
        }
    else if (IISChannelNeedsCleanup)
        {
        IISChannel->Abort(RpcStatus);
        IISChannel->FreeObject();
        }

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::ConnectToServer (
    void
    )
/*++

Routine Description:

    Connects to the server and sends D1/A2

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2OutProxyInChannel *InChannel;
    RPC_STATUS RpcStatus;

    InChannel = LockDefaultInChannel(&ChannelPtr);
    // we cannot be aborted right now
    ASSERT(InChannel != NULL);

    RpcStatus = InChannel->InitializeRawConnection(ServerName,
        ServerPort,
        ConnectionTimeout,
        ProxyCallbackInterface->IsValidMachineFn
        );

    if (RpcStatus == RPC_S_OK)
        {
        RpcStatus = InChannel->Receive(http2ttRaw);
        }
    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::SendHeaderToClient (
    void
    )
/*++

Routine Description:

    Sends response header to client

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeResponseHeader();
    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        RpcFreeBuffer(SendContext);

    return RpcStatus;
}


RPC_STATUS HTTP2OutProxyVirtualConnection::SendD1_A3ToClient (
    void
    )
/*++

Routine Description:

    Sends D1/A3 to client

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeD1_A3(IISConnectionTimeout);
    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::SendD1_A2ToServer (
    IN ULONG ChannelLifetime
    )
/*++

Routine Description:

    Sends D1/A3 to client

Arguments:

    ChannelLifetime - the lifetime of the channel as established by
        the client.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeD1_A2 (ProtocolVersion,
        &EmbeddedConnectionCookie,
        &OutChannelCookies[0],
        ChannelLifetime,
        ProxyReceiveWindowSize
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(TRUE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

RPC_STATUS HTTP2OutProxyVirtualConnection::SendD4_A4ToServer (
    IN ULONG ChannelLifetime
    )
/*++

Routine Description:

    Sends D1/A3 to client

Arguments:

    ChannelLifetime - the lifetime of the channel as established by
        the client.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    RPC_STATUS RpcStatus;
    HTTP2SendContext *SendContext;

    SendContext = AllocateAndInitializeD4_A4 (ProtocolVersion,
        &EmbeddedConnectionCookie,
        &OutChannelCookies[1],
        &OutChannelCookies[0],
        ChannelLifetime,
        ProxyReceiveWindowSize,
        IISConnectionTimeout
        );

    if (SendContext == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = SendTrafficOnDefaultChannel(TRUE,      // IsInChannel
        SendContext
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(SendContext);

    return RpcStatus;
}

void HTTP2OutProxyVirtualConnection::LastPacketSentNotification (
    IN int ChannelId,
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a channel wants to notify the virtual connection
    that the last packet has been sent, they call this function. 
    Must be called from an upcall/neutral context. Only flow control
    senders generated past packet notifications

Arguments:

    ChannelId - the channelfor which this notification is.

    LastSendContext - the send context for the last send

Return Value:

--*/
{
    HTTP2ChannelPointer *ChannelPtr;

    ASSERT(LastSendContext->Flags & SendContextFlagSendLast);
    ASSERT((LastSendContext->UserData == oplptD4_A10)
        || (LastSendContext->UserData == oplptD5_B3));

    if (LastSendContext->UserData == oplptD5_B3)
        {
        ChannelPtr = GetChannelPointerFromId(ChannelId);

        // Detach the old channel
        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
            TRUE,      // CalledFromUpcallContext
            FALSE,      // Abort
            RPC_S_OK
            );
        }
}

/*********************************************************************
    HTTP2ServerInChannel
 *********************************************************************/

RPC_STATUS HTTP2ServerInChannel::QueryLocalAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a channel.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    RPC_STATUS RpcStatus;
    WS_HTTP2_CONNECTION *RawConnection;

    RpcStatus = BeginSimpleSubmitAsync();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RawConnection = GetRawConnection();
    RpcStatus = TCP_QueryLocalAddress(RawConnection,
        Buffer,
        BufferSize,
        AddressFormat
        );

    FinishSubmitAsync();

    return RpcStatus;
}

RPC_STATUS HTTP2ServerInChannel::ForwardFlowControlAck (
    IN ULONG BytesReceivedForAck,
    IN ULONG WindowForAck
    )
/*++

Routine Description:

    Forwards a flow control ack back to the in proxy

Arguments:
    
    BytesReceivedForAck - the bytes received when the ACK was issued

    WindowForAck - the free window when the ACK was issued.

Return Value:

    RPC_S_OK or RPC_S_*

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = ForwardFlowControlAckOnThisChannel(BytesReceivedForAck,
        WindowForAck,
        TRUE        // NonChannelData
        );

    // we're sending non-channel data. This cannot lead to channel recycle
    // indication
    ASSERT(RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING);

    return RpcStatus;
}

/*********************************************************************
    HTTP2ServerOutChannel
 *********************************************************************/

RPC_STATUS HTTP2ServerOutChannel::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext
    )
/*++

Routine Description:

    Send complete notification

Arguments:

    EventStatus - the status of the send

    SendContext - send context

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    if (SendContext->Flags & SendContextFlagAbandonedSend)
        {
        // abandoned send. Complete it silently and return back
        ASSERT(SendContext->TrafficType == http2ttData);

        RpcFreeBuffer(SendContext->u.BufferToFree);
        FreeLastSendContext(SendContext);

        return RPC_P_PACKET_CONSUMED;
        }

    return HTTP2Channel::SendComplete (EventStatus, SendContext);
}

RPC_STATUS HTTP2ServerOutChannel::SetKeepAliveTimeout (
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Change the keep alive value on the channel

Arguments:

    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.

    bProtectIO - non-zero if IO needs to be protected against async close
        of the connection.

    Units - in what units is KATime

    KATime - how much to wait before turning on keep alives

    KAInterval - the interval between keep alives

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    // The server channel does not support this for Whistler
    return RPC_S_CANNOT_SUPPORT;
}

RPC_STATUS HTTP2ServerOutChannel::LastPacketSentNotification (
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a lower channel wants to notify the top
    channel that the last packet has been sent,
    they call this function. Must be called from
    an upcall/neutral context. Only flow control
    senders support past packet notifications

Arguments:

    LastSendContext - the context for the last send

Return Value:

    The value to return to the runtime

--*/
{
    HTTP2ServerVirtualConnection *VirtualConnection;

    VirtualConnection = LockParentPointer();
    // if the connection was already aborted, nothing to do
    if (VirtualConnection == NULL)
        return RPC_P_PACKET_CONSUMED;

    // we know the parent will disconnect from us in their
    // notification
    VirtualConnection->LastPacketSentNotification(ChannelId,
        LastSendContext);

    UnlockParentPointer();

    DrainUpcallsAndFreeParent();

    return RPC_P_PACKET_CONSUMED;
}

HTTP2SendContext *HTTP2ServerOutChannel::GetLastSendContext (
    void
    )
/*++

Routine Description:

    Gets (creates if necessary) a last send context.

Arguments:

Return Value:

    The last context created or NULL if there is not enough memory

Notes:

    Since each connection will submit one last send at a time, this
        method can be single threaded.

--*/
{
    if (CachedLastSendContextUsed == FALSE)
        {
        CachedLastSendContextUsed = TRUE;
        return GetCachedLastSendContext();
        }
    else
        {
        return (new HTTP2SendContext);
        }
}

/*********************************************************************
    HTTP2ServerVirtualConnection
 *********************************************************************/

void HTTP2ServerVirtualConnection::Abort (
    void
    )
/*++

Routine Description:

    Aborts an HTTP connection and disconnects the channels.
    Must only come from the runtime.

Arguments:

Return Value:

--*/
{
    LOG_OPERATION_ENTRY(HTTP2LOG_OPERATION_ABORT, HTTP2LOG_OT_SERVER_VC, 0);

    // abort the channels themselves
    AbortChannels(RPC_P_CONNECTION_CLOSED);

    // we got to the destructive phase of the abort
    // guard against double aborts
    if (Aborted.Increment() > 1)
        return;

    DisconnectChannels(FALSE, 0);

    CancelAllTimeouts();

    // call destructor without freeing memory
    HTTP2ServerVirtualConnection::~HTTP2ServerVirtualConnection();
}

void HTTP2ServerVirtualConnection::Close (
    IN BOOL DontFlush
    )
/*++

Routine Description:

    Closes an HTTP connection. Connection may have already been aborted.

Arguments:

    DontFlush - non-zero if all buffers need to be flushed
        before closing the connection. Zero otherwise.

Return Value:

--*/
{
    CookieCollection *ServerCookieCollection = GetServerCookieCollection();

    ServerCookieCollection->LockCollection();
    ServerCookieCollection->RemoveElement(&EmbeddedConnectionCookie);
    ServerCookieCollection->UnlockCollection();

    HTTP2ServerVirtualConnection::Abort();
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryClientAddress (
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG ClientAddressType;

    if (ClientAddress.AddressType == catIPv4)
        ClientAddressType = TCP;
    else
        ClientAddressType = TCP_IPv6;

    return WS_ConvertClientAddress((const SOCKADDR *)&ClientAddress.u,
        ClientAddressType,
        pNetworkAddress
        );
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryLocalAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    HTTP2ServerInChannel *ServerInChannel;
    HTTP2ChannelPointer *ChannelPtr;
    RPC_STATUS RpcStatus;

    ServerInChannel = LockDefaultInChannel(&ChannelPtr);
    if (ServerInChannel == NULL)
        return RPC_S_NO_CONTEXT_AVAILABLE;

    RpcStatus = ServerInChannel->QueryLocalAddress(Buffer,
        BufferSize,
        AddressFormat
        );

    ChannelPtr->UnlockChannelPointer();

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::QueryClientId(
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is supposed to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

    This is a server side function. Assert on the client. Proxies don't
    override that. Other virtual connections may override it.

Arguments:

    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ClientProcess->SetHTTP2ClientIdentifier(AssociationGroupId.GetCookie(),
        COOKIE_SIZE_IN_BYTES,
        FALSE   // fLocal
        );

    return RPC_S_OK;
}

void HTTP2ServerVirtualConnection::LastPacketSentNotification (
    IN int ChannelId,
    IN HTTP2SendContext *LastSendContext
    )
/*++

Routine Description:

    When a channel wants to notify the virtual connection
    that the last packet has been sent, they call this function. 
    Must be called from an upcall/neutral context. Only flow control
    senders generated past packet notifications

Arguments:

    ChannelId - the channelfor which this notification is.

    LastSendContext - the context for the last send

Return Value:

--*/
{
    // this must not be on the default in channel
    ASSERT(IsOutChannel(ChannelId));
    ASSERT(!IsDefaultOutChannel(ChannelId));

    // detach the channel that notified us. Since we're in upcall, we know
    // we hold at least one reference
    OutChannels[GetNonDefaultOutChannelSelector()].FreeChannelPointer(FALSE,  // DrainUpCalls
        FALSE,      // CalledFromUpcallContext
        FALSE,      // Abort
        RPC_S_OK    // AbortStatus
        );
}

RPC_STATUS HTTP2ServerVirtualConnection::RecycleChannel (
    IN BOOL IsFromUpcall
    )
/*++

Routine Description:

    Initiates channel recycling on the server.

Arguments:

    IsFromUpcall - non-zero if it comes from upcall. Zero otherwise.

Return Value:

    RPC_S_OK of the recycling operation started successfully.
    RPC_S_* error for errors.

--*/
{
    HTTP2SendContext *D4_A1Context;
    RPC_STATUS RpcStatus;

#if DBG
    DbgPrint("RPCRT4: %d: Recycling OUT channel\n", GetCurrentProcessId());
#endif

    // Send invitation to the client to start channel recycling
    D4_A1Context = AllocateAndInitializeD4_A1 ();
    if (D4_A1Context == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannelState.Mutex.Request();
    // we shouldn't get recycle unless we're in an opened state
    ASSERT(OutChannelState.State == http2svOpened);

    LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened_A4W, 1, 0);
    OutChannelState.State = http2svOpened_A4W;

    VerifyTimerNotSet (OutChannelTimer);

    OutChannelState.Mutex.Clear();

    RpcStatus = SendTrafficOnDefaultChannel(FALSE,   // IsInChannel
        D4_A1Context
        );

    if (RpcStatus != RPC_S_OK)
        FreeRTSPacket(D4_A1Context);

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::SendComplete (
    IN RPC_STATUS EventStatus,
    IN OUT HTTP2SendContext *SendContext,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate send complete.

Arguments:

    EventStatus - status of the operation

    SendContext - the context for the send complete

    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    VerifyValidChannelId(ChannelId);

    if (SendContext->TrafficType == http2ttRTS)
        {
        FreeSendContextAndPossiblyData(SendContext);
        if (EventStatus != RPC_S_OK)
            {
            // any send failures on the server are cause for connection abortion
            AbortChannels(EventStatus);
            }
        return RPC_P_PACKET_CONSUMED;
        }
    else
        return EventStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::ReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BYTE *Buffer,
    IN UINT BufferLength,
    IN int ChannelId
    )
/*++

Routine Description:

    Called by lower layers to indicate receive complete

Arguments:

    EventStatus - RPC_S_OK for success or RPC_S_* for error
    Buffer - buffer received
    BufferLength - length of buffer received
    ChannelId - which channel completed the operation

Return Value:

    RPC_P_PACKET_CONSUMED if the packet was consumed and should
    be hidden from the runtime.
    RPC_S_OK if the packet was processed successfully.
    RPC_S_* error if there was an error while processing the
        packet.

--*/
{
    HTTP2ServerOutChannel *OutChannel;
    HTTP2ServerOutChannel *NewOutChannel;
    HTTP2ServerInChannel *InChannel;
    HTTP2ServerInChannel *InChannel2;
    HTTP2ChannelPointer *ChannelPtr;
    HTTP2ChannelPointer *NewChannelPtr;
    HTTP2Cookie ChannelCookie;
    RPC_STATUS RpcStatus;
    HTTP2SendContext *EmptyRTS;
    BOOL BufferFreed;
    BOOL DataReceivePosted;
    HTTP2ServerOpenedPacketType PacketType;
    LIST_ENTRY NewBufferHead;
    HTTP2SendContext *D4_A9Context;
    HTTP2SendContext *D5_A5Context;
    HTTP2SendContext *D5_B1OrB2Context;
    HTTP2SendContext *D2_B2Context;
    ULONG BytesReceivedForAck;
    ULONG WindowForAck;
    HTTP2ServerOutChannelOtherCmdPacketType OutChannelPacketType;
    BOOL IsOtherCmd;
    ULONG PingTrafficSent;
    BOOL ChannelNotSet;

    VerifyValidChannelId(ChannelId);

    if (IsInChannel(ChannelId))
        {
        // in channel has an endpoint receiver. Delegate RTS and data failures to it
        if (EventStatus != RPC_S_OK)
            return EventStatus;

        if (IsRTSPacket(Buffer))
            {
            RpcStatus = HTTPTransInfo->CreateThread();

            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                AbortChannels(RPC_S_PROTOCOL_ERROR);
                return RPC_P_PACKET_CONSUMED;
                }

            BufferFreed = FALSE;

            RpcStatus = CheckPacketForForwarding(Buffer,
                BufferLength,
                fdServer
                );

            if (RpcStatus == RPC_P_PACKET_NEEDS_FORWARDING)
                {
                // flow control acks have some weird routing. Handle
                // them separately. First, test for other cmd, since it's
                // cheaper
                if (IsOtherCmdPacket(Buffer, BufferLength))
                    {
                    // we know this is a other cmd command. Now check for
                    // forwarded flow control ack
                    RpcStatus = ParseFlowControlAckPacketWithDestination (Buffer,
                        BufferLength,
                        fdOutProxy,
                        &BytesReceivedForAck,
                        &WindowForAck,
                        &ChannelCookie
                        );

                    if (RpcStatus == RPC_S_OK)
                        {
                        ChannelNotSet = FALSE;
                        // flow control ack. Route it based on which out channel has
                        // a matching cookie. It is possible that none has. That's ok -
                        // just drop the packet in these cases
                        if (OutChannelCookies[0].Compare(&ChannelCookie) == 0)
                            {
                            if (OutChannels[0].IsChannelSet())
                                {
                                RpcStatus = ForwardTrafficToChannel (
                                    &OutChannels[0],
                                    Buffer,
                                    BufferLength
                                    );
                                }
                            else
                                {
                                // see comment below where we check ChannelNotSet
                                ChannelNotSet = TRUE;
                                ASSERT(DefaultOutChannelSelector == 1);
                                }
                            }
                        else if (OutChannelCookies[1].Compare(&ChannelCookie) == 0)
                            {
                            if (OutChannels[1].IsChannelSet())
                                {
                                RpcStatus = ForwardTrafficToChannel (
                                    &OutChannels[1],
                                    Buffer,
                                    BufferLength
                                    );
                                }
                            else
                                {
                                // see comment below where we check ChannelNotSet
                                ChannelNotSet = TRUE;
                                ASSERT(DefaultOutChannelSelector == 0);
                                }
                            }
                        else
                            {
                            // fake failure - this will be handled below
                            RpcStatus = RPC_P_SEND_FAILED;
                            }

                        if (ChannelNotSet)
                            {
                            // we could have a match on a channel that does not exist
                            // if we are in D5 after D5/B1. The old channel still needs
                            // flow control, but the new channel cookie is current by
                            // now. In these cases the old channel cookie will be moved
                            // to the location of the cookie for the non-default channel
                            // Make sure this is the case. After that forward to the out proxy
                            // on the default channel. The out proxy will again compare cookies
                            // and will know which channel to forward the flow control ack to.
                            ASSERT(OutChannelState.State == http2svOpened);

                            RpcStatus = ForwardTrafficToDefaultChannel (
                                FALSE,  // IsInChannel
                                Buffer,
                                BufferLength
                                );
                            }

                        // handle a recycling request if necessary
                        RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                            TRUE        // IsFromUpcall
                            );

                        // since forwarding may fail if channels are discarded, consume
                        // the packet and ignore the failure
                        if (RpcStatus != RPC_S_OK)
                            {
                            RpcFreeBuffer(Buffer);
                            RpcStatus = RPC_S_OK;
                            }
                        }
                    else
                        {
                        // not a forwarded flow control ack after all. Just
                        // forward it using normal methods
                        RpcStatus = ForwardTrafficToDefaultChannel(
                            FALSE,  // IsInChannel
                            Buffer,
                            BufferLength
                            );
                        }
                    }
                else
                    {
                    RpcStatus = ForwardTrafficToDefaultChannel(
                        FALSE,  // IsInChannel
                        Buffer,
                        BufferLength
                        );
                    }

                RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                    TRUE        // IsFromUpcall
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                    RpcFreeBuffer(Buffer);
                    return RPC_P_PACKET_CONSUMED;
                    }

                // we no longer own the buffer
                BufferFreed = TRUE;
                }
            else if (RpcStatus == RPC_S_PROTOCOL_ERROR)
                {
                // RTS packet is for us but is garbled
                AbortChannels(RPC_P_CONNECTION_CLOSED);
                RpcFreeBuffer(Buffer);
                return RPC_P_PACKET_CONSUMED;
                }
            else
                {
                RpcStatus = GetServerOpenedPacketType (Buffer,
                    BufferLength,
                    &PacketType
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                    RpcFreeBuffer(Buffer);
                    return RPC_P_PACKET_CONSUMED;
                    }

                if ((PacketType == http2soptD4_A8orD5_A8) || (PacketType == http2soptD2_A6orD3_A2))
                    {
                    InChannelState.Mutex.Request();
                    if (PacketType == http2soptD4_A8orD5_A8)
                        {
                        // determine whether it is D4/A8 or D5/A8 based on the state
                        // we are in
                        if (OutChannelState.State == http2svOpened_A8W)
                            PacketType = http2soptD4_A8;
                        else if (OutChannelState.State == http2svOpened_D5A8W)
                            PacketType = http2soptD5_A8;
                        else 
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                        }
                    else
                        {
                        // determine whether it is D2/A6 or D3/A2 based on the state
                        // we are in
                        if (InChannelState.State == http2svOpened_A6W)
                            PacketType = http2soptD2_A6;
                        else if (OutChannelState.State == http2svOpened)
                            PacketType = http2soptD3_A2;
                        else 
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                        }
                    InChannelState.Mutex.Clear();
                    }

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_P_CONNECTION_CLOSED);
                    RpcFreeBuffer(Buffer);
                    return RPC_P_PACKET_CONSUMED;
                    }

                switch (PacketType)
                    {
                    case http2soptD2_A6:
                        // this would better be D2/A6
                        RpcStatus = ParseAndFreeD2_A6 (Buffer,
                            BufferLength,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        // we got D2/A6. Cancel the timeout we setup with D2/A2
                        CancelTimeout(InChannelTimer);

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_P_CONNECTION_CLOSED);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        if (InChannelCookies[GetNonDefaultInChannelSelector()].Compare(&ChannelCookie))
                            {
                            // cookies don't match - nuke the channel
                            AbortChannels(RPC_P_CONNECTION_CLOSED);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        InChannelState.Mutex.Request();
                        // we haven't posted a receive yet - there is no
                        // way the state of the channel will change
                        ASSERT(InChannelState.State == http2svOpened_A6W);
                        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened_B1W, 1, 0);
                        InChannelState.State = http2svOpened_B1W;
                        InChannelState.Mutex.Clear();
                        break;

                    case http2soptD3_A2:
                        if (IsDefaultInChannel(ChannelId) == FALSE)
                            {
                            ASSERT(0);
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            RpcFreeBuffer(Buffer);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        RpcStatus = ParseAndFreeD3_A2 (Buffer,
                            BufferLength,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RpcStatus);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        // update the passed in cookie
                        InChannelCookies[DefaultInChannelSelector].SetCookie(ChannelCookie.GetCookie());

                        // pass D3/A3 back
                        EmptyRTS = AllocateAndInitializeEmptyRTSWithDestination (fdClient);
                        if (EmptyRTS == NULL)
                            {
                            AbortChannels(RpcStatus);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        RpcStatus = SendTrafficOnDefaultChannel (FALSE,     // IsInChannel
                            EmptyRTS
                            );

                        break;

                    case http2soptD2_B1:
                        InChannelState.Mutex.Request();
                        if (InChannelState.State != http2svOpened_B1W)
                            {
                            InChannelState.Mutex.Clear();
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            RpcFreeBuffer(Buffer);
                            return RPC_P_PACKET_CONSUMED;
                            }
                        InChannelState.Mutex.Clear();

                        RpcStatus = ParseAndFreeEmptyRTS(Buffer,
                            BufferLength);

                        // we no longer own the buffer
                        BufferFreed = TRUE;

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;                        
                            }
                        // we're done with this channel. We want to switch
                        // channels and destroy
                        // and detach the channel.
                        SwitchDefaultInChannelSelector();

                        ChannelPtr = GetChannelPointerFromId(ChannelId);
                        InChannel = (HTTP2ServerInChannel *)ChannelPtr->LockChannelPointer();
                        if (InChannel == NULL)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;
                            }

                        InChannel2 = LockDefaultInChannel(&NewChannelPtr);
                        if (InChannel2 == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;
                            }

                        DataReceivePosted = InChannel->IsDataReceivePosted();

                        RpcStatus = InChannel->TransferReceiveStateToNewChannel(InChannel2);

                        NewChannelPtr->UnlockChannelPointer();
                        ChannelPtr->UnlockChannelPointer();

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        D2_B2Context = AllocateAndInitializeD2_B2 (HTTP2ServerReceiveWindow);
                        if (D2_B2Context == NULL)
                            {
                            AbortChannels(RPC_S_OUT_OF_MEMORY);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        // now that we have transferred the settings, we can open
                        // the pipeline from the new in proxy
                        RpcStatus = SendTrafficOnDefaultChannel(TRUE,    // IsInChannel
                            D2_B2Context
                            );

                        if (RpcStatus != RPC_S_OK)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            FreeRTSPacket(D2_B2Context);
                            return RPC_P_PACKET_CONSUMED;                        
                            }

                        // detach, abort and free lifetime reference
                        ChannelPtr->FreeChannelPointer(TRUE,    // DrainUpCalls
                            TRUE,   // CalledFromUpcallContext
                            TRUE,   // Abort
                            RPC_P_CONNECTION_SHUTDOWN
                            );

                        InChannelState.Mutex.Request();
                        // we haven't posted a receive yet - there is no
                        // way the state of the channel will change
                        ASSERT(InChannelState.State == http2svOpened_B1W);
                        LogEvent(SU_HTTPv2, EV_STATE, this, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                        InChannelState.State = http2svOpened;
                        InChannelState.Mutex.Clear();

                        if (DataReceivePosted)
                            {
                            RpcStatus = PostReceiveOnDefaultChannel (
                                TRUE,   // IsInChannel
                                http2ttData
                                );

                            if (RpcStatus != RPC_S_OK)
                                {
                                AbortChannels(RPC_S_PROTOCOL_ERROR);
                                }
                            }

                        return RPC_P_PACKET_CONSUMED;
                        break;

                    case http2soptD4_A8:
                        // verify the new cookie against the old, and execute
                        // the detachment of the old channel after sending D4_A9
                        InChannelState.Mutex.Request();
                        if (OutChannelState.State != http2svOpened_A8W)
                            {
                            InChannelState.Mutex.Clear();
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        // move back to opened state
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        OutChannelState.State = http2svOpened;
                        InChannelState.Mutex.Clear();

                        RpcStatus = ParseAndFreeD4_A8 (Buffer,
                            BufferLength,
                            fdServer,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        // we got D4/A8. Cancel the timeout we setup with D4/A4
                        CancelTimeout(OutChannelTimer);

                        if (RpcStatus != RPC_S_OK)
                            break;

                        if (OutChannelCookies[GetNonDefaultOutChannelSelector()].Compare(&ChannelCookie))
                            {
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        // lock the old channel
                        OutChannel = LockDefaultOutChannel(&ChannelPtr);
                        if (OutChannel == NULL)
                            {
                            RpcStatus = RPC_P_CONNECTION_CLOSED;
                            break;
                            }

                        // switch channels (new channel is still plugged)
                        SwitchDefaultOutChannelSelector();

                        // wait for all submits to get out of old channel
                        OutChannel->DrainPendingSubmissions();

                        // leave 1 for our lock
                        ChannelPtr->DrainPendingLocks(1);

                        // lock new channel (by now it is default)
                        NewOutChannel = LockDefaultOutChannel(&NewChannelPtr);
                        if (NewOutChannel == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_P_CONNECTION_CLOSED;
                            break;
                            }

                        // if flow control sender was queuing, grab all its buffers as well.
                        // Note that the flow control sender is higher in the stack and must
                        // be done first (to preserve packet ordering)
                        RpcpInitializeListHead(&NewBufferHead);
                        OutChannel->GetFlowControlSenderBufferQueue(&NewBufferHead);

                        AddBufferQueueToChannel(&NewBufferHead, NewOutChannel);

                        // GetChannelOriginatorBufferQueue must be called in submission
                        // context only. Get there
                        RpcStatus = OutChannel->BeginSimpleSubmitAsync();
                        if (RpcStatus != RPC_S_OK)
                            {
                            NewChannelPtr->UnlockChannelPointer();
                            ChannelPtr->UnlockChannelPointer();
                            break;
                            }

                        // if old channel was queuing, grab all its buffers. Since it is
                        // below the flow control sender, we must do it second to make sure
                        // they are before the flow control sender's buffers
                        RpcpInitializeListHead(&NewBufferHead);
                        OutChannel->GetChannelOriginatorBufferQueue(&NewBufferHead);

                        OutChannel->FinishSubmitAsync();

                        AddBufferQueueToChannel(&NewBufferHead, NewOutChannel);

                        // register the last packet to send with the old channel
                        D4_A9Context = AllocateAndInitializeD4_A9 ();

                        if (D4_A9Context == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            NewChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_S_OUT_OF_MEMORY;
                            break;
                            }

                        RpcStatus = OutChannel->Send(D4_A9Context);
                        if (RpcStatus != RPC_S_OK)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            NewChannelPtr->UnlockChannelPointer();
                            FreeRTSPacket(D4_A9Context);
                            break;
                            }

                        // D4_A9 was sent. We must switch the
                        // default loopback and detach the channel.
                        // Note that we don't abort the channel - we
                        // just release the lifetime reference
                        // When the proxy closes the connection, then
                        // we will abort
                        ChannelPtr->UnlockChannelPointer();

                        RpcStatus = NewOutChannel->Unplug();

                        NewChannelPtr->UnlockChannelPointer();

                        if (RpcStatus != RPC_S_OK)
                            break;

                        RpcStatus = RPC_P_PACKET_CONSUMED;

                        break;

                    case http2soptD5_A8:
                        // verify the new cookie against the old, and execute
                        // the detachment of the old channel after sending D4_A9
                        InChannelState.Mutex.Request();
                        if (OutChannelState.State != http2svOpened_D5A8W)
                            {
                            InChannelState.Mutex.Clear();
                            RpcStatus = RPC_S_PROTOCOL_ERROR;
                            break;
                            }

                        RpcStatus = ParseAndFreeD5_A8 (Buffer,
                            BufferLength,
                            fdServer,
                            &ChannelCookie
                            );

                        BufferFreed = TRUE;

                        CancelTimeout(OutChannelTimer);

                        if (RpcStatus != RPC_S_OK)
                            {
                            InChannelState.Mutex.Clear();
                            break;
                            }

                        // we use the non-default out channel cookie simply as temporary storage
                        // b/n D5/A4 and D5/A8
                        if (OutChannelCookies[GetNonDefaultOutChannelSelector()].Compare(&ChannelCookie))
                            {
                            // the new channel is fake. Tell the proxy about it, and it will ditch it
                            D5_B1OrB2Context = AllocateAndInitializeD5_B1orB2 (FALSE);
                            if (D5_B1OrB2Context == NULL)
                                {
                                InChannelState.Mutex.Clear();
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                break;
                                }

                            RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
                                D5_B1OrB2Context);
                            if (RpcStatus != RPC_S_OK)
                                {
                                InChannelState.Mutex.Clear();
                                FreeRTSPacket(D5_B1OrB2Context);
                                break;
                                }

                            // move back to opened state
                            LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                            OutChannelState.State = http2svOpened;
                            InChannelState.Mutex.Clear();
                            break;
                            }

                        // the cookie matches. Move the new channel cookie from temporary to permanent
                        // storage and move the old channel cookie to temp storage

                        // move old cookie to temp storage
                        ChannelCookie.SetCookie(
                            OutChannelCookies[DefaultOutChannelSelector].GetCookie());
                        // move new cookie from class temp storage to permanent storage
                        OutChannelCookies[DefaultOutChannelSelector].SetCookie (
                            OutChannelCookies[GetNonDefaultOutChannelSelector()].GetCookie());
                        // move the old cookie from local temporary storage to class temporary storage
                        OutChannelCookies[GetNonDefaultOutChannelSelector()].SetCookie (
                            ChannelCookie.GetCookie());

                        // move back to opened state
                        LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened, 1, 0);
                        OutChannelState.State = http2svOpened;
                        InChannelState.Mutex.Clear();

                        OutChannel = LockDefaultOutChannel(&ChannelPtr);
                        if (OutChannel == NULL)
                            {
                            RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                            break;
                            }

                        OutChannel->PlugDataOriginatorChannel();

                        // Wait for everybody that was in to get out. This way we know
                        // the channel was plugged.

                        // we know that this will complete because eventually the runtime
                        // will flow control itself if there is no lull in sent traffic
                        OutChannel->DrainPendingSubmissions();

                        D5_B1OrB2Context = AllocateAndInitializeD5_B1orB2 (TRUE);
                        if (D5_B1OrB2Context == NULL)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            RpcStatus = RPC_S_OUT_OF_MEMORY;
                            break;
                            }

                        RpcStatus = OutChannel->Send(D5_B1OrB2Context);
                        if (RpcStatus != RPC_S_OK)
                            {
                            ChannelPtr->UnlockChannelPointer();
                            FreeRTSPacket(D5_B1OrB2Context);
                            break;
                            }

                        RpcStatus = OutChannel->RestartDataOriginatorChannel();

                        ChannelPtr->UnlockChannelPointer();

                        // fall through the error code
                        break;

                    default:
                        ASSERT(0);
                        break;
                    }
                }

            RpcStatus = PostReceiveOnDefaultChannel(
                TRUE,      // IsInChannel
                http2ttRTS
                );

            if (RpcStatus != RPC_S_OK)
                AbortChannels(RPC_P_CONNECTION_CLOSED);

            if (BufferFreed == FALSE)
                RpcFreeBuffer(Buffer);

            return RPC_P_PACKET_CONSUMED;                        
            }
        else
            {
            return EventStatus;
            }
        }
    else
        {
        if (EventStatus != RPC_S_OK)
            {
            if (IsDefaultOutChannel(ChannelId) == FALSE)
                {
                InChannelState.Mutex.Request();
                if (OutChannelState.State == http2svOpened)
                    {
                    // close on the non-default channel in open
                    // state is not an error. Just discard the channel
                    InChannelState.Mutex.Clear();

                    ChannelPtr = GetChannelPointerFromId(ChannelId);

                    ChannelPtr->FreeChannelPointer(
                        TRUE,    // DrainUpcalls
                        TRUE,    // CalledFromUpcallContext
                        TRUE,    // Abort
                        RPC_P_CONNECTION_SHUTDOWN
                        );

                    RpcStatus = RPC_P_PACKET_CONSUMED;
                    BufferFreed = TRUE;
                    return RpcStatus;
                    }
                else
                    InChannelState.Mutex.Clear();
                }
            else if (InChannelState.State == http2svB2W)
                {
                // if this is a half open connection, treat
                // this as data receive and indicate it to the
                // runtime
                AbortChannels(EventStatus);

                // if we are still in this state, return error to the
                // runtime. Else, somebody else joined and we can ignore
                // this error
                if (InChannelState.State == http2svB2W)
                    {
                    return EventStatus;
                    }
                else
                    {
                    // consume the receive
                    return RPC_P_PACKET_CONSUMED;
                    }
                }

            AbortChannels(EventStatus);

            // we expect only RTS traffic on this channel. Nobody would post
            // a data receive on this channel. Consume the receive
            return RPC_P_PACKET_CONSUMED;
            }

        if (IsRTSPacket(Buffer))
            {
            RpcStatus = HTTPTransInfo->CreateThread();
            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                AbortChannels(RPC_S_PROTOCOL_ERROR);
                return RPC_P_PACKET_CONSUMED;
                }

            IsOtherCmd = IsOtherCmdPacket(Buffer,
                BufferLength
                );

            RpcStatus = GetServerOutChannelOtherCmdPacketType (
                Buffer,
                BufferLength,
                &OutChannelPacketType
                );

            if (RpcStatus != RPC_S_OK)
                {
                RpcFreeBuffer(Buffer);
                AbortChannels(RPC_S_PROTOCOL_ERROR);
                return RPC_P_PACKET_CONSUMED;
                }

            if (IsOtherCmd && (OutChannelPacketType == http2sococptFlowControl))
                {
                RpcStatus = ParseAndFreeFlowControlAckPacket (Buffer,
                    BufferLength,
                    &BytesReceivedForAck,
                    &WindowForAck,
                    &ChannelCookie
                    );

                if (RpcStatus == RPC_S_OK)
                    {
                    // notify the flow control sender
                    ChannelPtr = GetChannelPointerFromId(ChannelId);
                    OutChannel = (HTTP2ServerOutChannel *)ChannelPtr->LockChannelPointer();
                    // forward acks only on default channels. Non-default channels
                    // will have all their buffers transfered to the new channel in the
                    // immediate future. If we forward to them, we can cause nasty
                    // race conditions as another thread tries to get channels out of them
                    if (IsDefaultOutChannel(ChannelId))
                        {
                        if (OutChannel == NULL)
                            {
                            AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                            return RPC_P_PACKET_CONSUMED;
                            }

                        RpcStatus = OutChannel->FlowControlAckNotify(BytesReceivedForAck,
                            WindowForAck
                            );

                        RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                            TRUE        // IsFromUpcall
                            );
                        }

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus == RPC_S_OK)
                        {
                        // post another receive
                        RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                            http2ttRaw
                            );
                        }
                    }

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);
                    }
                }
            else if (IsOtherCmd && (OutChannelPacketType == http2sococptPingTrafficSentNotify))
                {
                RpcStatus = ParseAndFreePingTrafficSentNotifyPacket (Buffer,
                    BufferLength,
                    &PingTrafficSent
                    );

                if (RpcStatus == RPC_S_OK)
                    {
                    // notify the channel data originator
                    ChannelPtr = GetChannelPointerFromId(ChannelId);
                    OutChannel = (HTTP2ServerOutChannel *)ChannelPtr->LockChannelPointer();
                    if (OutChannel == NULL)
                        {
                        AbortChannels(RPC_P_CONNECTION_SHUTDOWN);
                        return RPC_P_PACKET_CONSUMED;
                        }

                    // prevent bogus values from the proxy. We allow no more than
                    // approximately MaxBytesSentByProxy bytes per BytesSentByProxyTimeInterval.
                    // The exact calculation doesn't matter. This requirement is so much below
                    // the bar necessary to attack the server, that anything close to it makes
                    // us safe
                    if (BytesSentByProxyTimeIntervalStart == 0)
                        BytesSentByProxyTimeIntervalStart = NtGetTickCount();
                    else
                        {
                        if (NtGetTickCount() - BytesSentByProxyTimeIntervalStart > BytesSentByProxyTimeInterval)
                            {
                            // start a new interval
                            BytesSentByProxyTimeIntervalStart = NtGetTickCount();
                            BytesSentByProxyForInterval = PingTrafficSent;
                            }
                        else
                            {
                            BytesSentByProxyForInterval += PingTrafficSent;
                            }

                        if (BytesSentByProxyForInterval > MaxBytesSentByProxy)
                            {
                            AbortChannels(RPC_S_PROTOCOL_ERROR);
                            return RPC_P_PACKET_CONSUMED;
                            }
                        }

                    RpcStatus = OutChannel->NotifyDataOriginatorForTrafficSent (PingTrafficSent);

                    RpcStatus = StartChannelRecyclingIfNecessary(RpcStatus,
                        TRUE        // IsFromUpcall
                        );

                    ChannelPtr->UnlockChannelPointer();

                    if (RpcStatus == RPC_S_OK)
                        {
                        // post another receive
                        RpcStatus = PostReceiveOnChannel(GetChannelPointerFromId(ChannelId),
                            http2ttRaw
                            );
                        }
                    }

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);
                    }
                }
            else
                {
                // the only packet we expect here is D5/A4
                // we must be in Opened_A4W state for it
                InChannelState.Mutex.Request();
                if (OutChannelState.State != http2svOpened_A4W)
                    {
                    InChannelState.Mutex.Clear();
                    RpcFreeBuffer(Buffer);
                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                    return RPC_P_PACKET_CONSUMED;
                    }
                RpcStatus = ParseAndFreeD5_A4 (Buffer,
                    BufferLength,
                    &OutChannelCookies[GetNonDefaultOutChannelSelector()]
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_S_PROTOCOL_ERROR);
                    InChannelState.Mutex.Clear();
                    return RPC_P_PACKET_CONSUMED;
                    }

                // move to Opened_A8W state
                LogEvent(SU_HTTPv2, EV_STATE, this, OUT_CHANNEL_STATE, http2svOpened_D5A8W, 1, 0);
                OutChannelState.State = http2svOpened_D5A8W;
                InChannelState.Mutex.Clear();

                RpcStatus = SetTimeout(DefaultNoResponseTimeout, OutChannelTimer);

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RpcStatus);
                    return RPC_P_PACKET_CONSUMED;
                    }

                // send out D5/A5
                D5_A5Context = AllocateAndInitializeD5_A5 (fdClient);

                if (D5_A5Context == NULL)
                    {
                    AbortChannels(RPC_S_OUT_OF_MEMORY);
                    return RPC_P_PACKET_CONSUMED;
                    }

                RpcStatus = SendTrafficOnDefaultChannel(FALSE,      // IsInChannel
                    D5_A5Context
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    AbortChannels(RPC_S_OUT_OF_MEMORY);
                    FreeRTSPacket(D5_A5Context);
                    return RPC_P_PACKET_CONSUMED;
                    }

                RpcStatus = PostReceiveOnDefaultChannel(FALSE,      // IsInChannel
                    http2ttRaw
                    );

                if (RpcStatus != RPC_S_OK)
                    AbortChannels(RpcStatus);
                }

            return RPC_P_PACKET_CONSUMED;
            }
        else
            return EventStatus;
        }
}

RPC_STATUS HTTP2ServerVirtualConnection::SyncSend (
    IN ULONG BufferLength,
    IN BYTE *Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Does a sync send on a server HTTP connection.

Arguments:

    BufferLength - the length of the data to send.

    Buffer - the data to send.

    fDisableShutdownCheck - ignored

    fDisableCancelCheck - runtime indicates no cancel
        will be attempted on this send. Can be used
        as optimization hint by the transport

    Timeout - send timeout (call timeout)

Return Value:

    RPC_S_OK for success or RPC_S_* / Win32 error for failure

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    HTTP2SendContext *SendContext;
    HTTP2ServerOutChannel *Channel;
    HTTP2ChannelPointer *ChannelPtr;

    OutChannelState.Mutex.Request();
    if (OutChannelState.State == http2svOpened)
        {
        VerifyTimerNotSet(OutChannelTimer);
        }
    OutChannelState.Mutex.Clear();

    // if the caller did not set a last buffer to free, we can't abandon the send
    // because we can't cleanup. Wait for the send to complete.
    if (IsLastBufferToFreeSet() == FALSE)
        {
        return HTTP2VirtualConnection::SyncSend (BufferLength,
            Buffer,
            fDisableShutdownCheck,
            fDisableCancelCheck,
            Timeout
            );
        }

    // we will complete this as an async send behind the covers
    // and we will fake success unless the submission itself
    // fails
    Channel = (HTTP2ServerOutChannel *)LockDefaultSendChannel (&ChannelPtr);
    if (Channel == NULL)
        {        
        return RPC_P_CONNECTION_CLOSED;
        }

    SendContext = Channel->GetLastSendContext();
    if (SendContext == NULL)
        {
        ChannelPtr->UnlockChannelPointer();
        return RPC_S_OUT_OF_MEMORY;
        }

    SendContext->u.BufferToFree = GetAndResetLastBufferToFree();
    SendContext->SetListEntryUnused();
    SendContext->maxWriteBuffer = BufferLength;
    SendContext->pWriteBuffer = Buffer;
    // SendContext->Write.pAsyncObject = NULL; // this will be initialized in the bottom layer
    SendContext->Write.ol.Internal = STATUS_PENDING;
    SendContext->TrafficType = http2ttData;
    SendContext->Write.ol.OffsetHigh = 0;
    SendContext->Flags = SendContextFlagAbandonedSend;
    SendContext->UserData = 0;

    RpcStatus = Channel->Send(SendContext);

    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_P_CHANNEL_NEEDS_RECYCLING))
        {
        // synchronous failure - cleanup
        RpcFreeBuffer(SendContext->u.BufferToFree);
        Channel->FreeLastSendContext(SendContext);
        }

    ChannelPtr->UnlockChannelPointer();

    if (RpcStatus == RPC_P_CHANNEL_NEEDS_RECYCLING)
        {
        // make sure there is a thread to pick up the recycling events
        RpcStatus = HTTPTransInfo->CreateThread();
        if (RpcStatus != RPC_S_OK)
            {
            VALIDATE(RpcStatus)
                {
                RPC_S_OK,
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES,
                RPC_P_SEND_FAILED,
                RPC_S_CALL_CANCELLED,
                RPC_P_RECEIVE_COMPLETE,
                RPC_P_TIMEOUT
                } END_VALIDATE;

            return RpcStatus;
            }

        // get the ball rolling with the recycle
        RpcStatus = RecycleChannel(
            FALSE       // IsFromUpcall
            );
        }

    if ((RpcStatus == RPC_P_CONNECTION_SHUTDOWN)
        || (RpcStatus == RPC_P_RECEIVE_FAILED)
        || (RpcStatus == RPC_P_CONNECTION_CLOSED) )
        RpcStatus = RPC_P_SEND_FAILED;

    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_RECEIVE_COMPLETE,
        RPC_P_TIMEOUT
        } END_VALIDATE;

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::InitializeServerConnection (
    IN BYTE *Packet,
    IN ULONG PacketLength,
    IN WS_HTTP2_INITIAL_CONNECTION *Connection,
    OUT HTTP2ServerVirtualConnection **ServerVirtualConnection,
    OUT BOOL *VirtualConnectionCreated
    )
/*++

Routine Description:

    Initializes a server connection. Based on the content of the
    packet (i.e. D1/A2 or D1/B2), it will either initialize the
    out channel or the in channel respectively, and if it is
    the first leg of the connection establishment, establish the
    virtual connection itself and insert it into the cookie table

    Note: This function must initialize the type member and migrate the
    WS_HTTP2_INITIAL_CONNECTION after morphing it into
    WS_HTTP2_CONNECTION. The VirtualConnectionCreated parameter indicates
    whether this was done.

Arguments:

    Packet - received packet. Guaranteed to be present until PacketLength.
        On second leg, this function must not free the buffer. Ownership
        of the buffer remains with the caller.

    PacketLength - the lenght of the received packet.

    Connection - the received connection. It must be migrated
        and morphed into WS_HTTP2_CONNECTION on success. If the virtual
        connection was already created, then returning failure without
        un-migrating is fine. Cleanup paths will check and recognize this
        as HTTP2ServerVirtualConnection.

    ServerVirtualConnection - on successful return, the created server virtual
        connection

    VirtualConnectionCreated - if non-zero, the WS_HTTP2_INITIAL_CONNECTION
        was morphed into virtual connection. Else, the WS_HTTP2_INITIAL_CONNECTION
        is still around. Must be set on success and failure.

Return Value:

    RPC_S_OK or RPC_S_* for error. If we return RPC_S_OK, the packet will be
    consumed by caller. If we return anything else, it won't be.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_STATUS RpcStatus2;
    HTTP2FirstServerPacketType PacketType;
    WS_HTTP2_INITIAL_CONNECTION *OriginalConnection = Connection;
    HTTP2ServerInChannel *InChannel = NULL;
    HTTP2ServerOutChannel *OutChannel = NULL;
    HTTP2ServerCookie ServerCookie;
    HTTP2Cookie ChannelCookie;
    HTTP2Cookie NewChannelCookie;
    ULONG OutProxyReceiveWindow;
    ULONG ProtocolVersion;
    ULONG OutChannelLifetime;
    ULONG InProxyReceiveWindow;
    ULONG InProxyConnectionTimeout;
    ULONG OutProxyConnectionTimeout;
    HTTP2Cookie AssociationGroupId;
    ChannelSettingClientAddress ClientAddress;
    HTTP2ServerVirtualConnection *LocalServerConnection;
    HTTP2ServerVirtualConnection *VCPlaceHolder;
    BOOL FirstLeg;
    BOOL AbortServerConnection = FALSE;
    HTTP2ServerChannel *ThisChannel;
    HTTP2ChannelPointer *OtherChannelPtr;
    HTTP2SendContext *D1_C1Context;
    HTTP2SendContext *D1_B3Context;
    HTTP2SendContext *D2_A3Context;
    HTTP2SendContext *D4_A4Context;
    HTTP2SendContext *D4_A5Context;
    int NonDefaultChannel;

    *VirtualConnectionCreated = FALSE;

    // First, do a little bit of parsing to
    // determine if this is the first request for this connection
    // cookie. If not, join the other connection and destroy the
    // runtime stuff for this one. If yes, build a virtual connection
    RpcStatus = GetFirstServerPacketType(Packet,
        PacketLength,
        &PacketType
        );

    if (RpcStatus != RPC_S_OK)
        {
        RpcFreeBuffer(Packet);
        return RpcStatus;
        }

    if (PacketType == http2fsptD1_A2)
        {
        RpcStatus = ParseD1_A2(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &OutChannelLifetime,
            &OutProxyReceiveWindow);

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        if (OutChannelLifetime < MinimumChannelLifetime)
            return RPC_S_PROTOCOL_ERROR;

        // a request to establish a new out connection
        RpcStatus = AllocateAndInitializeOutChannel (&Connection,
            OutChannelLifetime,
            &OutChannel);

        if (RpcStatus == RPC_S_OK)
            {
            // unplug the newly created out channel
            RpcStatus2 = OutChannel->Unplug ();
            // we know we can't fail here since there are no data in the pipe line
            ASSERT(RpcStatus2 == RPC_S_OK);

            OutChannel->SetPeerReceiveWindow(OutProxyReceiveWindow);
            }
        }
    else if (PacketType == http2fsptD1_B2)
        {
        RpcpMemorySet(&ClientAddress, 0, sizeof(ClientAddress));

        RpcStatus = ParseD1_B2(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &InProxyReceiveWindow,
            &InProxyConnectionTimeout,
            &AssociationGroupId,
            &ClientAddress
            );

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        // a request to establish a new in connection
        RpcStatus = AllocateAndInitializeInChannel (&Connection,
            &InChannel);
        }
    else if (PacketType == http2fsptD2_A2)
        {
        // in channel replacement
        RpcStatus = ParseD2_A2(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &NewChannelCookie,
            &InProxyReceiveWindow,
            &InProxyConnectionTimeout
            );

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        // a request to establish a replacement in connection
        RpcStatus = AllocateAndInitializeInChannel (&Connection,
            &InChannel);
        }
    else
        {
        ASSERT(PacketType == http2fsptD4_A4);

        // out channel replacement
        RpcStatus = ParseD4_A4(Packet,
            PacketLength,
            &ProtocolVersion,
            &ServerCookie,
            &ChannelCookie,
            &NewChannelCookie,
            &OutChannelLifetime,
            &OutProxyReceiveWindow,
            &OutProxyConnectionTimeout
            );

        if (RpcStatus != RPC_S_OK)
            return RpcStatus;

        // a request to establish a replacement out connection
        RpcStatus = AllocateAndInitializeOutChannel (&Connection,
            OutChannelLifetime,
            &OutChannel);

        if (RpcStatus == RPC_S_OK)
            OutChannel->SetPeerReceiveWindow(OutProxyReceiveWindow);
        }

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    // take the lower of our and reported version
    ProtocolVersion = min(ProtocolVersion, HTTP2ProtocolVersion);

    // figure out whether we arrived first or second
    GetServerCookieCollection()->LockCollection();

    LocalServerConnection = 
        (HTTP2ServerVirtualConnection *)GetServerCookieCollection()->FindElement(&ServerCookie);

    if (((PacketType == http2fsptD2_A2) || (PacketType == http2fsptD4_A4)) 
        && (LocalServerConnection == NULL))
        {
        // we cannot establish a replacement connection if the old one is not around
        OriginalConnection->fAborted = 1;
        OriginalConnection->pReadBuffer = NULL;
        RpcStatus = RPC_P_RECEIVE_FAILED;
        goto AbortFirstLegAndExit;
        }

    if (LocalServerConnection == NULL)
        {
        // we're first. Initialize the server virtual connection
        // we know the server has reserved space for the larger of
        // WS_HTTP2_INITIAL_CONNECTION and HTTP2ServerVirtualConnection.
        // Use the same space.

        VCPlaceHolder = (HTTP2ServerVirtualConnection *)OriginalConnection;
        LocalServerConnection = new (VCPlaceHolder) HTTP2ServerVirtualConnection(&ServerCookie,
            ProtocolVersion,
            &RpcStatus);

        if (RpcStatus == RPC_S_OK)
            {
            // we use the first timer for connection establishment
            RpcStatus = LocalServerConnection->SetTimeout(DefaultNoResponseTimeout, InChannelTimer);
            }

        if (RpcStatus != RPC_S_OK)
            {
            LocalServerConnection->HTTP2ServerVirtualConnection::~HTTP2ServerVirtualConnection();
            OriginalConnection->fAborted = 1;
            OriginalConnection->pReadBuffer = NULL;
            goto AbortFirstLegAndExit;
            }

        *VirtualConnectionCreated = TRUE;
        LocalServerConnection->id = HTTPv2;
        LocalServerConnection->type = COMPLEX_T | SERVER;
        FirstLeg = TRUE;
        }
    else
        {
        // the actual transport connection is by now owned by the channel
        // Create a fake connection in the current location that will no-op on
        // close.
        OriginalConnection->fAborted = 1;
        OriginalConnection->pReadBuffer = NULL;
        if (PacketType == http2fsptD2_A2)
            {
            // if this is a replacement channel, check the cookies
            if (LocalServerConnection->CompareCookieWithDefaultInChannelCookie(&ChannelCookie))
                {
                // cookies don't match. Nuke the newly established channel - it is probably
                // fake
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortFirstLegAndExit;
                }

            // we still hold the cookie collection mutex. This synchronizes with
            // aborts
            RpcStatus = LocalServerConnection->SetTimeout(DefaultNoResponseTimeout, 
                InChannelTimer
                );
            if (RpcStatus != RPC_S_OK)
                goto AbortFirstLegAndExit;
            }
        else if (PacketType == http2fsptD4_A4)
            {
            // if this is a replacement channel, check the cookies
            if (LocalServerConnection->CompareCookieWithDefaultOutChannelCookie(&ChannelCookie))
                {
                // cookies don't match. Nuke the newly established channel - it is probably
                // fake
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortFirstLegAndExit;
                }

            // we still hold the cookie collection mutex. This synchronizes with
            // aborts
            RpcStatus = LocalServerConnection->SetTimeout(DefaultNoResponseTimeout, 
                OutChannelTimer
                );
            if (RpcStatus != RPC_S_OK)
                goto AbortFirstLegAndExit;
            }

        FirstLeg = FALSE;
        }

    // set the runtime connection ptr for the raw connection
    Connection->RuntimeConnectionPtr = LocalServerConnection;
    // add the raw connection to the PnP list
    TransportProtocol::AddObjectToProtocolList(Connection);
    LocalServerConnection->ProtocolVersion = ProtocolVersion;

    if (PacketType == http2fsptD1_A2)
        {
        if (LocalServerConnection->OutChannels[0].IsChannelSet())
            {
            // if we already have a second channel, then this is a protocol error
            RpcStatus = RPC_S_PROTOCOL_ERROR;
            goto AbortSecondLegAndExit;
            }

        LocalServerConnection->OutProxySettings[0].ReceiveWindow = OutProxyReceiveWindow;
        LocalServerConnection->OutProxySettings[0].ChannelLifetime = OutChannelLifetime;
        LocalServerConnection->OutChannelCookies[0].SetCookie(ChannelCookie.GetCookie());

        // attach the newly created stack to the connection
        LocalServerConnection->SetFirstOutChannel(OutChannel);
        OutChannel->SetParent(LocalServerConnection);

        if (FirstLeg)
            {
            ASSERT(LocalServerConnection->InChannelState.State == http2svClosed);
            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svB2W, 1, 0);
            LocalServerConnection->InChannelState.State = http2svB2W;
            GetServerCookieCollection()->AddElement(&LocalServerConnection->EmbeddedConnectionCookie);
            }
        else
            {
            // we got the second leg - cancel the timeout for the second leg
            LocalServerConnection->CancelTimeout(InChannelTimer);

            if (LocalServerConnection->InChannelState.State != http2svA2W)
                {
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortSecondLegAndExit;
                }

            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svOpened, 1, 0);
            LocalServerConnection->InChannelState.State = http2svOpened;
            LocalServerConnection->OutChannelState.State = http2svOpened;

            ASSERT(InChannel == NULL);

            InChannel = LocalServerConnection->LockDefaultInChannel(&OtherChannelPtr);
            if (InChannel == NULL)
                {
                RpcStatus = RPC_P_RECEIVE_FAILED;
                goto AbortSecondLegAndExit;
                }
            InChannel->AddReference();
            OtherChannelPtr->UnlockChannelPointer();

            // for second leg, we need to add one reference before we release
            // the lock. Otherwise the pending receive on the first leg may
            // kill the connection and the channel with it
            OutChannel->AddReference();
            }
        }
    else if ((PacketType == http2fsptD1_B2) || (PacketType == http2fsptD2_A2))
        {
        if (PacketType == http2fsptD1_B2)
            {
            if (FirstLeg == FALSE)
                {
                // we got the second leg - cancel the timeout for the second leg
                LocalServerConnection->CancelTimeout(InChannelTimer);
                }

            CopyClientAddress(&LocalServerConnection->ClientAddress,
                &ClientAddress);
            LocalServerConnection->InProxyReceiveWindows[0] = InProxyReceiveWindow;
            LocalServerConnection->InProxyConnectionTimeout = InProxyConnectionTimeout;
            LocalServerConnection->AssociationGroupId.SetCookie(AssociationGroupId.GetCookie());
            LocalServerConnection->InChannelCookies[0].SetCookie(ChannelCookie.GetCookie());

            // attach the newly created stack to the connection
            LocalServerConnection->SetFirstInChannel(InChannel);
            InChannel->SetParent(LocalServerConnection);
            }
        else
            {
            ASSERT(PacketType == http2fsptD2_A2);
            NonDefaultChannel = LocalServerConnection->GetNonDefaultInChannelSelector();
            LocalServerConnection->InProxyReceiveWindows[NonDefaultChannel] = InProxyReceiveWindow;
            LocalServerConnection->InProxyConnectionTimeout = InProxyConnectionTimeout;
            LocalServerConnection->InChannelCookies[NonDefaultChannel].SetCookie(NewChannelCookie.GetCookie());

            // attach the newly created stack to the connection
            LocalServerConnection->SetNonDefaultInChannel(InChannel);
            InChannel->SetParent(LocalServerConnection);

            if (LocalServerConnection->InChannelState.State != http2svOpened)
                {
                RpcStatus = RPC_S_PROTOCOL_ERROR;
                goto AbortSecondLegAndExit;
                }
            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svOpened_A6W, 1, 0);
            LocalServerConnection->InChannelState.State = http2svOpened_A6W;
            ASSERT(FirstLeg == FALSE);
            }

        if (FirstLeg)
            {
            ASSERT(LocalServerConnection->InChannelState.State == http2svClosed);
            LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svA2W, 1, 0);
            LocalServerConnection->InChannelState.State = http2svA2W;
            GetServerCookieCollection()->AddElement(&LocalServerConnection->EmbeddedConnectionCookie);
            }
        else
            {
            if (PacketType == http2fsptD1_B2)
                {
                if (LocalServerConnection->InChannelState.State != http2svB2W)
                    {
                    RpcStatus = RPC_S_PROTOCOL_ERROR;
                    goto AbortSecondLegAndExit;
                    }
                LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, IN_CHANNEL_STATE, http2svOpened, 1, 0);
                LocalServerConnection->InChannelState.State = http2svOpened;
                LocalServerConnection->OutChannelState.State = http2svOpened;
                }
            else
                {
                ASSERT(PacketType == http2fsptD2_A2);
                }

            ASSERT(OutChannel == NULL);

            OutChannel = LocalServerConnection->LockDefaultOutChannel(&OtherChannelPtr);
            if (OutChannel == NULL)
                {
                RpcStatus = RPC_P_RECEIVE_FAILED;
                goto AbortSecondLegAndExit;
                }
            OutChannel->AddReference();
            OtherChannelPtr->UnlockChannelPointer();

            // for second leg, we need to add one reference before we release
            // the lock. Otherwise the pending receive on the first leg may
            // kill the connection and the channel with it
            InChannel->AddReference();
            }
        }
    else if (PacketType == http2fsptD4_A4)
        {
        NonDefaultChannel = LocalServerConnection->GetNonDefaultOutChannelSelector();
        LocalServerConnection->OutProxySettings[NonDefaultChannel].ReceiveWindow = OutProxyReceiveWindow;
        LocalServerConnection->OutChannelCookies[NonDefaultChannel].SetCookie(NewChannelCookie.GetCookie());

        // attach the newly created stack to the connection
        LocalServerConnection->SetNonDefaultOutChannel(OutChannel);
        OutChannel->SetParent(LocalServerConnection);

        if (LocalServerConnection->OutChannelState.State != http2svOpened_A4W)
            {
            RpcStatus = RPC_S_PROTOCOL_ERROR;
            goto AbortSecondLegAndExit;
            }
        LogEvent(SU_HTTPv2, EV_STATE, LocalServerConnection, OUT_CHANNEL_STATE, http2svOpened_A8W, 1, 0);
        LocalServerConnection->OutChannelState.State = http2svOpened_A8W;
        ASSERT(FirstLeg == FALSE);

        ASSERT(InChannel == NULL);

        InChannel = LocalServerConnection->LockDefaultInChannel(&OtherChannelPtr);
        if (InChannel == NULL)
            {
            RpcStatus = RPC_P_RECEIVE_FAILED;
            goto AbortSecondLegAndExit;
            }
        InChannel->AddReference();
        OtherChannelPtr->UnlockChannelPointer();

        // for second leg, we need to add one reference before we release
        // the lock. Otherwise the pending receive on the first leg may
        // kill the connection and the channel with it
        OutChannel->AddReference();
        }
    else
        {
        ASSERT(0);
        }

    // N.B. It is safe to release the lock without having sent packets
    // If caller sends data packets without these being sent, we don't care.
    // During the second leg we have an extra reference on both channels, so 
    // we can party outside the lock.
    GetServerCookieCollection()->UnlockCollection();

    // we have a virtual connection and at least one of its channels
    // attached to it. We have a no-op connection in OriginalConnection
    // by now. Any failure paths on the second leg must abort the virtual connection

    if ((PacketType == http2fsptD1_A2) || (PacketType == http2fsptD4_A4))
        {
        // out channel
        RpcStatus = OutChannel->Receive(http2ttRaw);
        ThisChannel = OutChannel;
        }
    else
        {
        ASSERT((PacketType == http2fsptD1_B2)
            || (PacketType == http2fsptD2_A2) );
        // in channel
        RpcStatus = InChannel->Receive(http2ttRTS);
        if ((PacketType == http2fsptD1_B2) && (RpcStatus == RPC_S_OK))
            {
            // naturally, we're also interested in data receives
            RpcStatus = InChannel->Receive(http2ttData);
            }
        ThisChannel = InChannel;
        }

    if (FirstLeg)
        {
        // this is the first leg. We know we are the only ones parting on
        // the connection. In case of error just return it back. The runtime
        // will turn around and close the connection
        }
    else
        {
        if ((PacketType == http2fsptD1_B2) || (PacketType == http2fsptD1_A2))
            {
            // the connection is fully fleshed out and both channels are plugged. Some
            // additional activity remains. We need to abort the runtime connection
            // for the second leg and remove the extra refcount
            if (RpcStatus == RPC_S_OK)
                {
                // we need to re-obtain the local server connection pointer through a safe mechanism. 
                // After we released the collection mutex, it may have been destroyed
                LocalServerConnection = (HTTP2ServerVirtualConnection *) InChannel->LockParentPointer();
                if (LocalServerConnection)
                    {                    
                    // we successfully submitted receives. Now send out D1/C1 and D1/B3
                    D1_C1Context = AllocateAndInitializeD1_C1(LocalServerConnection->ProtocolVersion,
                        LocalServerConnection->InProxyReceiveWindows[0],
                        LocalServerConnection->InProxyConnectionTimeout
                        );

                    if (D1_C1Context != NULL)
                        {
                        // we don't need to lock it, because we have a reference to it
                        RpcStatus = OutChannel->Send(D1_C1Context);

                        if (RpcStatus == RPC_S_OK)
                            {
                            D1_B3Context = AllocateAndInitializeD1_B3(HTTP2DefaultServerReceiveWindow,
                                LocalServerConnection->ProtocolVersion
                                );
                            if (D1_B3Context != NULL)
                                {
                                RpcStatus = InChannel->Send(D1_B3Context);
                                if (RpcStatus != RPC_S_OK)
                                    FreeRTSPacket(D1_B3Context);
                                }
                            else
                                {
                                RpcStatus = RPC_S_OUT_OF_MEMORY;
                                }
                            }
                        else
                            {
                            FreeRTSPacket(D1_C1Context);
                            }
                        }
                    else
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        }

                    InChannel->UnlockParentPointer();
                    }
                else
                    RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                }
            }
        else if (PacketType == http2fsptD2_A2)
            {
            // We have added the second channel to the connection. Keep the ball
            // rolling
            if (RpcStatus == RPC_S_OK)
                {
                // After we released the collection mutex, it may have been destroyed
                LocalServerConnection = (HTTP2ServerVirtualConnection *) OutChannel->LockParentPointer();
                if (LocalServerConnection)
                    {                    
                    // we successfully submitted receives. Now send out D2/A3
                    D2_A3Context = AllocateAndInitializeD2_A3(fdClient,
                        LocalServerConnection->ProtocolVersion,
                        LocalServerConnection->InProxyReceiveWindows[NonDefaultChannel],
                        LocalServerConnection->InProxyConnectionTimeout
                        );

                    if (D2_A3Context != NULL)
                        {
                        // we don't need to lock it, because we have a reference to it.
                        RpcStatus = OutChannel->Send(D2_A3Context);
                        if (RpcStatus != RPC_S_OK)
                            FreeRTSPacket(D2_A3Context);
                        }
                    else
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        }

                    OutChannel->UnlockParentPointer();
                    }
                else
                    RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                }
            }
        else
            {
            ASSERT(PacketType == http2fsptD4_A4);

            // We have added the second channel to the connection. Keep the ball
            // rolling
            if (RpcStatus == RPC_S_OK)
                {
                // After we released the collection mutex, it may have been destroyed
                LocalServerConnection = (HTTP2ServerVirtualConnection *) OutChannel->LockParentPointer();
                if (LocalServerConnection)
                    {                    
                    // we successfully submitted receives. Now send out D4/A5
                    D4_A5Context = AllocateAndInitializeD4_A5(fdClient,
                        LocalServerConnection->ProtocolVersion,
                        OutProxyConnectionTimeout
                        );

                    if (D4_A5Context != NULL)
                        {
                        // We still need to send on the default channel. Obtain
                        // a pointer through the virtual connection
                        RpcStatus = LocalServerConnection->SendTrafficOnDefaultChannel(FALSE,   // IsInChannel
                            D4_A5Context
                            );
                        if (RpcStatus != RPC_S_OK)
                            FreeRTSPacket(D4_A5Context);
                        }
                    else
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        }

                    OutChannel->UnlockParentPointer();
                    }
                else
                    RpcStatus = RPC_P_CONNECTION_SHUTDOWN;
                }
            }

        if (RpcStatus != RPC_S_OK)
            {
            // we can't directly access the connection because we don't have
            // a way to prevent it from going away underneath us. We do it through
            // the channels instead (on which we do have a refcount)
            LocalServerConnection = (HTTP2ServerVirtualConnection *)ThisChannel->LockParentPointer();
            if (LocalServerConnection)
                {
                LocalServerConnection->AbortChannels(RpcStatus);
                ThisChannel->UnlockParentPointer();
                }
            }

        InChannel->RemoveReference();
        OutChannel->RemoveReference();

        if (RpcStatus == RPC_S_OK)
            {
            // fake failure to the runtime. We have migrated our transport connection
            // to the virtual connection and we don't need this one anymore
            RpcStatus = RPC_P_RECEIVE_FAILED;
            }
        }

    return RpcStatus;

AbortSecondLegAndExit:
    ASSERT(FirstLeg == FALSE);

    // make sure we have no-op'ed the OriginalConnection
    ASSERT(OriginalConnection->fAborted > 0);
    ASSERT(OriginalConnection->pReadBuffer == NULL);

    LocalServerConnection->Abort();

    GetServerCookieCollection()->UnlockCollection();

    // unlink the added connection from the PnP list
    TransportProtocol::RemoveObjectFromProtocolList(Connection);

    // the original connection must be WS_HTTP2_INITIAL_CONNECTION
    ASSERT(OriginalConnection->id == HTTP);

    ASSERT(RpcStatus != RPC_S_OK);

    return RpcStatus;

AbortFirstLegAndExit:
    // we failed to create a server connection. Release all locks and fail
    GetServerCookieCollection()->UnlockCollection();

    // the original connection must be WS_HTTP2_INITIAL_CONNECTION
    ASSERT(OriginalConnection->id == HTTP);

    // destroy the channel created during the first leg
    if ((PacketType == http2fsptD1_A2) || (PacketType == http2fsptD4_A4))
        {
        OutChannel->Abort(RpcStatus);
        OutChannel->RemoveReference();
        }
    else
        {
        ASSERT((PacketType == http2fsptD1_B2) || (PacketType == http2fsptD2_A2));
        InChannel->Abort(RpcStatus);
        InChannel->RemoveReference();
        }

    ASSERT(RpcStatus != RPC_S_OK);

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::AllocateAndInitializeInChannel (
    IN OUT WS_HTTP2_INITIAL_CONNECTION **Connection,
    OUT HTTP2ServerInChannel **ReturnInChannel
    )
/*++

Routine Description:

    Initializes a server in channel. 

    Note: This function must migrate the WS_HTTP2_INITIAL_CONNECTION after 
    morphing it into WS_HTTP2_CONNECTION

Arguments:

    Connection - on input, the received connection. It must be migrated
        and morphed into WS_HTTP2_CONNECTION on success. All failure paths
        must be sure to move the WS_HTTP2_INITIAL_CONNECTION back to its
        original location.

    ReturnInChannel - on successful return, the created server in channel

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ServerInChannel *InChannel;
    HTTP2EndpointReceiver *EndpointReceiver;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL EndpointReceiverNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the in channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerInChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
        + sizeof(WS_HTTP2_CONNECTION);

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    InChannel = (HTTP2ServerInChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerInChannel);

    EndpointReceiver = (HTTP2EndpointReceiver *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2EndpointReceiver);

    RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    EndpointReceiverNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;

    // Wait for any pending IO to get out.
    while((*Connection)->IsIoStarting())
        Sleep(1);

    RpcpMemoryCopy(RawConnection, *Connection, sizeof(WS_HTTP2_CONNECTION));
    RawConnection->HeaderRead = TRUE;
    RawConnection->ReadHeaderFn = NULL;
    RawConnection->Read.pAsyncObject = RawConnection;
    RawConnection->type = COMPLEX_T | CONNECTION | SERVER;
    RawConnection->fAborted = 1;    // this connection must not be aborted
                                    // unless we successfully initialize
                                    // the channel. Therefore, artificially
                                    // abort the connection (preventing real
                                    // aborts) until we initialize the channel

    RawConnection = new (RawConnection) WS_HTTP2_CONNECTION;

    RpcStatus = RPC_S_OK;

    RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    EndpointReceiver = new (EndpointReceiver) HTTP2EndpointReceiver (HTTP2ServerReceiveWindow,
        TRUE,   // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        EndpointReceiver->HTTP2EndpointReceiver::~HTTP2EndpointReceiver();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(EndpointReceiver);
    EndpointReceiver->SetLowerChannel(RawChannel);

    EndpointReceiverNeedsCleanup = TRUE;

    InChannel = new (InChannel) HTTP2ServerInChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        InChannel->HTTP2ServerInChannel::~HTTP2ServerInChannel();
        goto AbortAndExit;
        }

    EndpointReceiver->SetUpperChannel(InChannel);
    InChannel->SetLowerChannel(EndpointReceiver);

    RawChannel->SetTopChannel(InChannel);
    EndpointReceiver->SetTopChannel(InChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    RawConnection->fAborted = 0;
    *ReturnInChannel = InChannel;
    *Connection = (WS_HTTP2_INITIAL_CONNECTION *)RawConnection;

    goto CleanupAndExit;

AbortAndExit:
    ASSERT(RpcStatus != RPC_S_OK);

    if (EndpointReceiverNeedsCleanup)
        {
        EndpointReceiver->Abort(RpcStatus);
        EndpointReceiver->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    // no need to clean up the raw connection.
    // If we failed, the virtual connection
    // is not created, and the caller will abort
    // the original conneciton

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

RPC_STATUS HTTP2ServerVirtualConnection::AllocateAndInitializeOutChannel (
    IN OUT WS_HTTP2_INITIAL_CONNECTION **Connection,
    IN ULONG OutChannelLifetime,
    OUT HTTP2ServerOutChannel **ReturnOutChannel
    )
/*++

Routine Description:

    Initializes a server out channel. 

    Note: This function must migrate the WS_HTTP2_INITIAL_CONNECTION after 
    morphing it into WS_HTTP2_CONNECTION

Arguments:

    Connection - on input, the received connection. It must be migrated
        and morphed into WS_HTTP2_CONNECTION on success. All failure paths
        must be sure to move the WS_HTTP2_INITIAL_CONNECTION back to its
        original location.

    OutChannelLifetime - the lifetime on the out channel.

    ReturnOutChannel - on successful return, the created server out channel

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG MemorySize;
    BYTE *MemoryBlock, *CurrentBlock;
    HTTP2ServerOutChannel *OutChannel;
    HTTP2PlugChannel *PlugChannel;
    HTTP2FlowControlSender *FlowControlSender;
    HTTP2ChannelDataOriginator *ChannelDataOriginator;
    HTTP2SocketTransportChannel *RawChannel;
    WS_HTTP2_CONNECTION *RawConnection;
    BOOL PlugChannelNeedsCleanup;
    BOOL FlowControlSenderNeedsCleanup;
    BOOL ChannelDataOriginatorNeedsCleanup;
    BOOL RawChannelNeedsCleanup;
    RPC_STATUS RpcStatus;

    // alocate the out channel
    MemorySize = SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerOutChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator)
        + SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel)
        + SIZE_OF_OBJECT_AND_PADDING(WS_HTTP2_CONNECTION)
        + sizeof(HTTP2SendContext)      // send context for the last send
        ;

    MemoryBlock = (BYTE *) new char [MemorySize];
    CurrentBlock = MemoryBlock;
    if (CurrentBlock == NULL)
        return RPC_S_OUT_OF_MEMORY;

    OutChannel = (HTTP2ServerOutChannel *) MemoryBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ServerOutChannel);

    PlugChannel = (HTTP2PlugChannel *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2PlugChannel);

    FlowControlSender = (HTTP2FlowControlSender *) CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2FlowControlSender);

    ChannelDataOriginator = (HTTP2ChannelDataOriginator *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2ChannelDataOriginator);

    RawChannel = (HTTP2SocketTransportChannel *)CurrentBlock;
    CurrentBlock += SIZE_OF_OBJECT_AND_PADDING(HTTP2SocketTransportChannel);

    RawConnection = (WS_HTTP2_CONNECTION *)CurrentBlock;

    // all memory blocks are allocated. Go and initialize them. Use explicit
    // placement
    PlugChannelNeedsCleanup = FALSE;
    FlowControlSenderNeedsCleanup = FALSE;
    ChannelDataOriginatorNeedsCleanup = FALSE;
    RawChannelNeedsCleanup = FALSE;

    // migrate the connection to its new location. Since nobody points to it (we have
    // been unlinked from the PnP list), copying is sufficient

    // Wait for any pending IO to get out.
    while((*Connection)->IsIoStarting())
        Sleep(1);

    RpcpMemoryCopy(RawConnection, *Connection, sizeof(WS_HTTP2_CONNECTION));
    RawConnection->HeaderRead = TRUE;
    RawConnection->Read.pAsyncObject = RawConnection;
    RawConnection->type = COMPLEX_T | CONNECTION | SERVER;
    RawConnection->fAborted = 1;    // this connection must not be aborted
                                    // unless we successfully initialize
                                    // the channel. Therefore, artificially
                                    // abort the connection (preventing real
                                    // aborts) until we initialize the channel

    RawConnection = new (RawConnection) WS_HTTP2_CONNECTION;

    RpcStatus = RPC_S_OK;

    RawChannel = new (RawChannel) HTTP2SocketTransportChannel (RawConnection, &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        RawChannel->HTTP2SocketTransportChannel::~HTTP2SocketTransportChannel();
        goto AbortAndExit;
        }

    RawConnection->Channel = RawChannel;

    RawChannelNeedsCleanup = TRUE;

    ChannelDataOriginator = new (ChannelDataOriginator) HTTP2ChannelDataOriginator (OutChannelLifetime,
        TRUE,   // IsServer
        &RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        ChannelDataOriginator->HTTP2ChannelDataOriginator::~HTTP2ChannelDataOriginator();
        goto AbortAndExit;
        }

    RawChannel->SetUpperChannel(ChannelDataOriginator);
    ChannelDataOriginator->SetLowerChannel(RawChannel);

    ChannelDataOriginatorNeedsCleanup = TRUE;

    FlowControlSender = new (FlowControlSender) HTTP2FlowControlSender (TRUE,       // IsServer
        TRUE,       // SendToRuntime
        &RpcStatus
        );
    if (RpcStatus != RPC_S_OK)
        {
        FlowControlSender->HTTP2FlowControlSender::~HTTP2FlowControlSender();
        goto AbortAndExit;
        }

    ChannelDataOriginator->SetUpperChannel(FlowControlSender);
    FlowControlSender->SetLowerChannel(ChannelDataOriginator);

    FlowControlSenderNeedsCleanup = TRUE;

    PlugChannel = new (PlugChannel) HTTP2PlugChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        PlugChannel->HTTP2PlugChannel::~HTTP2PlugChannel();
        goto AbortAndExit;
        }

    FlowControlSender->SetUpperChannel(PlugChannel);
    PlugChannel->SetLowerChannel(FlowControlSender);

    PlugChannelNeedsCleanup = TRUE;

    OutChannel = new (OutChannel) HTTP2ServerOutChannel (&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        OutChannel->HTTP2ServerOutChannel::~HTTP2ServerOutChannel();
        goto AbortAndExit;
        }

    RawChannel->SetTopChannel(OutChannel);
    ChannelDataOriginator->SetTopChannel(OutChannel);
    FlowControlSender->SetTopChannel(OutChannel);
    PlugChannel->SetTopChannel(OutChannel);

    PlugChannel->SetUpperChannel(OutChannel);
    OutChannel->SetLowerChannel(PlugChannel);

    ASSERT(RpcStatus == RPC_S_OK);

    RawConnection->fAborted = 0;
    *ReturnOutChannel = OutChannel;
    *Connection = (WS_HTTP2_INITIAL_CONNECTION *)RawConnection;

    goto CleanupAndExit;

AbortAndExit:
    if (PlugChannelNeedsCleanup)
        {
        PlugChannel->Abort(RpcStatus);
        PlugChannel->FreeObject();
        }
    else if (FlowControlSenderNeedsCleanup)
        {
        FlowControlSender->Abort(RpcStatus);
        FlowControlSender->FreeObject();
        }
    else if (ChannelDataOriginatorNeedsCleanup)
        {
        ChannelDataOriginator->Abort(RpcStatus);
        ChannelDataOriginator->FreeObject();
        }
    else if (RawChannelNeedsCleanup)
        {
        RawChannel->Abort(RpcStatus);
        RawChannel->FreeObject();
        }
    // no need to clean up the raw connection.
    // If we failed, the virtual connection
    // is not created, and the caller will abort
    // the original conneciton

    if (MemoryBlock)
        delete [] MemoryBlock;

CleanupAndExit:

    return RpcStatus;
}

void HTTP2ServerVirtualConnection::TimeoutExpired (
    void
    )
/*++

Routine Description:

    A timeout expired before we cancelled the timer. Abort the connection.

Arguments:

Return Value:

--*/
{
    TimerExpiredNotify();

    AbortChannels(RPC_P_TIMEOUT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\loader.cxx ===
/*++

  Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    loader.cxx

Abstract:

    Configuration and loading of RPC transports

Revision History:
  MarioGo      03-18-96    Cloned from parts of old common.c
  MarioGo      10-31-96    Async RPC

--*/

#include <precomp.hxx>
#include <loader.hxx>
#include <trans.hxx>
#include <cotrans.hxx>
#include <dgtrans.hxx>

// Globals - see loader.hxx

DWORD     gdwComputerNameLength = 0;
RPC_CHAR  gpstrComputerName[MAX_COMPUTERNAME_LENGTH + 1];

UINT gPostSize = CO_MIN_RECV;

#ifdef _INTERNAL_RPC_BUILD_
RPCLT_PDU_FILTER_FUNC gpfnFilter = NULL;
#endif

//
// Used to convert numbers to hex strings
//

const RPC_CHAR HexDigits[] =
{
    RPC_CONST_CHAR('0'),
    RPC_CONST_CHAR('1'),
    RPC_CONST_CHAR('2'),
    RPC_CONST_CHAR('3'),
    RPC_CONST_CHAR('4'),
    RPC_CONST_CHAR('5'),
    RPC_CONST_CHAR('6'),
    RPC_CONST_CHAR('7'),
    RPC_CONST_CHAR('8'),
    RPC_CONST_CHAR('9'),
    RPC_CONST_CHAR('A'),
    RPC_CONST_CHAR('B'),
    RPC_CONST_CHAR('C'),
    RPC_CONST_CHAR('D'),
    RPC_CONST_CHAR('E'),
    RPC_CONST_CHAR('F')
};

// WARNING: The order of these protocols must be consistent with the
//          definition of PROTOCOL_ID.

const
TRANSPORT_TABLE_ENTRY TransportTable[] = {
    {
    0,
    0,
    0
    },

    // TCP/IP
    {
    TCP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&TCP_TransportInterface
    },

#ifdef SPX_ON
    // SPX
    {
    SPX_TOWER_ID,
    IPX_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&SPX_TransportInterface
    },
#else
    {
    0,
    0,
    NULL
    },
#endif

    // Named pipes
    {
    NMP_TOWER_ID,
    UNC_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NMP_TransportInterface
    },

#ifdef NETBIOS_ON
    // Netbeui
    {
    NB_TOWER_ID,
    NBF_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NBF_TransportInterface
    },

    // Netbios over TCP/IP
    {
    NB_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NBT_TransportInterface
    },

    // Netbios over IPX
    {
    NB_TOWER_ID,
    IPX_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&NBI_TransportInterface
    },
#else
    // Netbeui
    {
    0,
    0,
    NULL
    },

    // Netbios over TCP/IP
    {
    0,
    0,
    NULL
    },

    // Netbios over IPX
    {
    0,
    0,
    NULL
    },
#endif

#ifdef APPLETALK_ON
    // Appletalk Datastream protocol
    {
    DSP_TOWER_ID,
    NBP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&DSP_TransportInterface
    },
#else
    // Appletalk Datastream protocol
    {
    0,
    0,
    NULL
    },
#endif

    // Banyan Vines SSP
    {
    0,
    0,
    NULL
    },

    // Hyper-Text Tranfer Protocol (HTTP)
    {
    HTTP_TOWER_ID,
    HTTP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&HTTP_TransportInterface
    },

    // UDP/IP
    {
    UDP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&UDP_TransportInterface
    },

#ifdef IPX_ON
    // IPX
    {
    IPX_TOWER_ID,
    IPX_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&IPX_TransportInterface
    },
#else
    // IPX
    {
    0,
    0,
    0
    },
#endif

    // CDP/UDP/IP
    {
    CDP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&CDP_TransportInterface
    },

#ifdef NCADG_MQ_ON
    // MSMQ (Falcon/RPC)
    {
    MQ_TOWER_ID,
    MQ_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&MQ_TransportInterface
    },
#else
    // MSMQ (Falcon/RPC)
    {
    0,
    0,
    NULL
    },
#endif

    // TCP over IPv6
    {
    TCP_TOWER_ID,
    IP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&TCP_TransportInterface
    },

    // HTTP2 - same as HTTP in terms of contents.
    {
    HTTP_TOWER_ID,
    HTTP_ADDRESS_ID,
    (RPC_TRANSPORT_INTERFACE)&HTTP_TransportInterface
    }
};

const DWORD cTransportTable = sizeof(TransportTable)/sizeof(TRANSPORT_TABLE_ENTRY);


inline
BOOL CompareProtseqs(
    IN const CHAR *p1,
    IN const RPC_CHAR *p2)
// Note: protseqs use only ANSI characters so this is ok.
{
    while(*p1)
        {
        if (*p1 != *p2)
            {
            return FALSE;
            }
        p1++;
        p2++;
        }

    return(*p2 == 0);
}

PROTOCOL_ID
MapProtseq(
    IN const RPC_CHAR *RpcProtocolSequence
    )
{
    PROTOCOL_ID index;

    for(index = 1; index < cTransportTable; index++)
        {
        if (TransportTable[index].pInfo != NULL)
            {
            if (RpcpStringCompare(RpcProtocolSequence,
                                TransportTable[index].pInfo->ProtocolSequence) == 0)
                {
                return(index);
                }
            }
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "Called with unknown protseq %S\n",
                   RpcProtocolSequence));

    ASSERT(0);
    return(0);
}

PROTOCOL_ID
MapProtseq(
    IN const CHAR *RpcProtocolSequence
    )
{
    PROTOCOL_ID index;

    for(index = 1; index < cTransportTable; index++)
        {
        if (TransportTable[index].pInfo != NULL)
            {
            if (CompareProtseqs(RpcProtocolSequence,
                        TransportTable[index].pInfo->ProtocolSequence))
                {
                return(index);
                }
            }
        }

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "Called with unknown protseq %S\n",
                   RpcProtocolSequence));

    ASSERT(0);
    return(0);
}

// NB: must be called before RpcCompletionPort is zeroed out, because it is used for comparison
void FreeCompletionPortHashTable(void)
{
    DWORD i;
    HANDLE hCurrentHandle;

    // walk through the table, not closing if there is next entry, and it is the same as this
    for (i = 0; i < gNumberOfProcessors * 2; i ++)
        {
        hCurrentHandle = RpcCompletionPorts[i];

        if (hCurrentHandle && (hCurrentHandle != RpcCompletionPort))
            {
            CloseHandle(hCurrentHandle);
            }
        }
}

HANDLE GetCompletionPortHandleForThread(void)
{
    DWORD i;
    DWORD nMinLoad = (DWORD) -1;
    int nMinLoadIndex = -1;

    for (i = 0; i < gNumberOfProcessors * 2; i ++)
        {
        if ((DWORD)CompletionPortHandleLoads[i] < nMinLoad)
            {
            nMinLoadIndex = i;
            nMinLoad = CompletionPortHandleLoads[i];
            }
        }

    ASSERT (nMinLoadIndex >= 0);
    InterlockedIncrement(&CompletionPortHandleLoads[nMinLoadIndex]);
    ASSERT(RpcCompletionPorts[nMinLoadIndex] != 0);
    return RpcCompletionPorts[nMinLoadIndex];
}

void ReleaseCompletionPortHandleForThread(HANDLE h)
{
    DWORD i;

    for (i = 0; i < gNumberOfProcessors * 2; i ++)
        {
        if (h == RpcCompletionPorts[i])
            {
            InterlockedDecrement((long *)&CompletionPortHandleLoads[i]);
            ASSERT(CompletionPortHandleLoads[i] >= 0);
            return;
            }
        }

    ASSERT(0);
}


RPC_TRANSPORT_INTERFACE
TransportLoad (
    IN const RPC_CHAR * RpcProtocolSequence
    )
{
    static fLoaded = FALSE;
    RPC_STATUS RpcStatus;

    PROTOCOL_ID index;
    RPC_STATUS status;
    RPC_TRANSPORT_INTERFACE pInfo;

    if (fLoaded == FALSE)
        {

        RpcStatus = InitTransportProtocols();
        if (RpcStatus != RPC_S_OK)
            return NULL;

        //
        // Query the computer name - used by most protocols.
        //

        gdwComputerNameLength = sizeof(gpstrComputerName)/sizeof(RPC_CHAR);

        if (!GetComputerName((RPC_SCHAR *)gpstrComputerName, &gdwComputerNameLength))
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "RPCTRANS: GetComputerNameW failed: %d\n",
                           GetLastError()));
            return(0);
            }

        gdwComputerNameLength++; // Include the null in the count.

        // Create initial IO completion port.  This saves us from a race
        // assigning the global io completion port.
        ASSERT(RpcCompletionPort == 0);
        RpcCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                                   0,
                                                   0,
                                                   0); // PERF REVIEW

        if (RpcCompletionPort == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL, RPCTRANS "Failed to create initial completion port: %d\n",
                           GetLastError()));

            return(0);
            }

        InactiveRpcCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                                   0,
                                                   0,
                                                   MAXULONG); // PERF REVIEW

        if (InactiveRpcCompletionPort == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL, RPCTRANS "Failed to create initial completion port: %d\n",
                           GetLastError()));

            CloseHandle(RpcCompletionPort);
            return(0);
            }

        HANDLE hCurrentCompletionPortHandle;
        DWORD i;
        BOOL fSuccess = TRUE;
        HANDLE hSourceProcessHandle = GetCurrentProcess();

        RpcCompletionPorts = new HANDLE[gNumberOfProcessors * 2];
        CompletionPortHandleLoads = new long[gNumberOfProcessors * 2];

        if ((RpcCompletionPorts == NULL) || (CompletionPortHandleLoads == NULL))
            {
            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return 0;
            }

        for (i = 0; i < gNumberOfProcessors * 2; i ++)
            {
            RpcCompletionPorts[i] = 0;
            CompletionPortHandleLoads[i] = 0;
            }

        RpcCompletionPorts[0] = RpcCompletionPort;
        for (i = 1; i < gNumberOfProcessors * 2; i ++)
            {
            fSuccess = DuplicateHandle(hSourceProcessHandle, RpcCompletionPort,
                hSourceProcessHandle, &hCurrentCompletionPortHandle, 0, FALSE, DUPLICATE_SAME_ACCESS);
            if (!fSuccess)
                break;

            ASSERT(hCurrentCompletionPortHandle != 0);
            RpcCompletionPorts[i] = hCurrentCompletionPortHandle;
            }

        if (!fSuccess)
            {
            FreeCompletionPortHashTable();
            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return 0;
            }

        //
        // Initalize locks, use Rtl* so we don't need to catch exception.
        //

        NTSTATUS NtStatus;

        NtStatus = RtlInitializeCriticalSectionAndSpinCount(&AddressListLock, PREALLOCATE_EVENT_MASK);
        if (!NT_SUCCESS(NtStatus))
            {
            FreeCompletionPortHashTable();
            CloseHandle(RpcCompletionPort);
            RpcCompletionPort = 0;
            return 0;
            }

        if (fPagedBCacheMode)
            {
            // allocate minimum post size. This guarantees that buffer
            // will always be at the end.
            gPostSize = sizeof(CONN_RPC_HEADER);
            }

        fLoaded = TRUE;
        }

    index = MapProtseq(RpcProtocolSequence);

    if (!index)
        {
        return(0);
        }

    pInfo = 0;

    switch (index)
        {
        case NMP:
            pInfo = (RPC_TRANSPORT_INTERFACE) NMP_TransportLoad();
            break;

#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
            pInfo = (RPC_TRANSPORT_INTERFACE) NB_TransportLoad(index);
            break;
#endif

        case TCP:
#ifdef SPX_ON
        case SPX:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
        case HTTP:
            pInfo = (RPC_TRANSPORT_INTERFACE) WS_TransportLoad(index);
            break;

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif
        case CDP:
        case UDP:
#ifdef IPX_ON
        case IPX:
#endif
            pInfo = (RPC_TRANSPORT_INTERFACE) DG_TransportLoad(index);
            break;
        }

    if (pInfo == 0)
        {
#ifdef UNICODE
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Load of %S failed\n",
                       RpcProtocolSequence));
#else
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Load of %s failed\n",
                       RpcProtocolSequence));
#endif
        return(0);
        }

    ASSERT(pInfo == TransportTable[index].pInfo);

    return(pInfo);
}

void
UnjoinCompletionPort (
    void
    )
{
    DWORD NumberOfBytes;
    ULONG_PTR CompletionKey;
    LPOVERLAPPED Overlapped;
    BOOL b;

    // The kernel today doesn't have the functionality to
    // unjoin a thread from a completion port. Therefore
    // we fake unjoining by joining another completion port which has
    // unlimited concurrency called the inactive completion port. 
    // Thus threads unjoined from the main completion port will not
    // affect its concurrency. One undesirable effect is that each
    // time a thread joined to the inactive completion port blocks,
    // it will try to wake up another thread, and there won't be any
    // there, which is a waste of CPU. Ideally, we should have had
    // a capability to set KTHREAD::Queue to NULL, but we don't
    b = GetQueuedCompletionStatus(InactiveRpcCompletionPort,
        &NumberOfBytes,
        &CompletionKey,
        &Overlapped,
        0
        );

    // this operation should either timeout or fail - it should never
    // succeed. If it does, this means somebody has erroneously posted
    // an IO on the inactive completion port
    ASSERT(b == FALSE);
}

#ifdef _INTERNAL_RPC_BUILD_
void
I_RpcltDebugSetPDUFilter (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    )
{
    gpfnFilter = pfnFilter;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\mqtrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    mqtrans.cxx

Abstract:

    Support for MSMQ (Falcon) datagram transport. Based on MarioGo's
    DG transport code (dgtrans.cxx).

Author:

    Edward Reus (edwardr)    04-Jul-1997

Revision History:

--*/
#include <precomp.hxx>
#include <trans.hxx>
#include <dgtrans.hxx>
#include <wswrap.hxx>
#include "mqtrans.hxx"


////////////////////////////////////////////////////////////////////////
//
// MSMQ datagram routines.
//

//----------------------------------------------------------------
RPC_STATUS
MQ_SubmitReceive( IN MQ_DATAGRAM_ENDPOINT *pEndpoint,
                  IN MQ_DATAGRAM          *pDatagram )
/*++

Arguments:

    pEndpoint - The endpoint on which the receive should be posted.
    pDatagram - The datagram object to manage the receive.

Return Value:

    RPC_P_IO_PENDING - OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/

{
    RPC_STATUS status;
    BOOL       fRetry = TRUE;
    DWORD      dwBytes = 0;
    DWORD      dwStatus;
    HRESULT    hr;


    while (fRetry)
       {
       if (pDatagram->pPacket == 0)
           {
           pDatagram->dwPacketSize = dwBytes;
           status = I_RpcTransDatagramAllocate2( pEndpoint,
                                                 (BUFFER *)&pDatagram->pPacket,
                                                 (PUINT)   &pDatagram->dwPacketSize,
                                                 (PVOID *) &pDatagram->pAddress);

           if (status != RPC_S_OK)
               {
               return RPC_S_OUT_OF_MEMORY;
               }

           ASSERT( pDatagram->pPacket );

           memset(pDatagram->pAddress,0,sizeof(MQ_ADDRESS));
           }

       pDatagram->cRecvAddr = sizeof(MQ_ADDRESS);

       ASSERT(*(PDWORD)pDatagram->pPacket = 0xDEADF00D);

       hr = AsyncReadQueue( pEndpoint,
                            &pDatagram->Read,
                            pDatagram->pAddress,
                            pDatagram->pPacket,
                            pDatagram->dwPacketSize );

       if (!FAILED(hr))
           {
           return RPC_P_IO_PENDING;
           }

       if (hr == MQ_ERROR_BUFFER_OVERFLOW)
          {
          // This can happen if there is already a large sized call on the queue.
          dwBytes = pDatagram->Read.aMsgPropVar[1].ulVal;

          dwStatus = I_RpcTransDatagramFree( pEndpoint,
                                             (BUFFER)pDatagram->pPacket,
                                             (PVOID) pDatagram->pAddress);
          pDatagram->pPacket = 0;
          pDatagram->dwPacketSize = 0;
          if (dwStatus != RPC_S_OK)
              {
              TransDbgPrint((DPFLTR_RPCPROXY_ID,
                             DPFLTR_WARNING_LEVEL,
                             RPCTRANS "MQ_SubmitReceive(): I_RpcTransDatagram() failed: %d\n",
                             dwStatus));

              return RPC_S_OUT_OF_MEMORY;
              }
          }
       else
          {
          fRetry = FALSE;
          TransDbgPrint((DPFLTR_RPCPROXY_ID,
                         DPFLTR_WARNING_LEVEL,
                         RPCTRANS "MQ_SubmitReceive(): AsyncReadQueue() failed: 0x%x\n",
                         hr));
          }
       }

    return RPC_S_OUT_OF_RESOURCES;
}

//----------------------------------------------------------------
void
MQ_SubmitReceives(
    BASE_ADDRESS *ThisEndpoint
    )
/*++

Routine Description:

    Helper function called when the pending IO count
    on an address is too low.

Arguments:

    ThisEndpoint - The address to submit IOs on.

Return Value:

    None

--*/
{
    PMQ_DATAGRAM pDg;
    PMQ_DATAGRAM_ENDPOINT pEndpoint = (PMQ_DATAGRAM_ENDPOINT)ThisEndpoint;

    if ( (!pEndpoint->fAllowReceives) || (!pEndpoint->hQueue) )
        {
        return;
        }

    do
        {
        BOOL fIoSubmitted;

        fIoSubmitted = FALSE;

        // Only one thread should be trying to submit IOs at a time.
        // This saves locking each DATAGRAM object.

        // Simple lock - but requires a loop. See the comment at the end
        // of the loop.

        if (pEndpoint->fSubmittingIos != 0)
            break;

        if (InterlockedIncrement(&pEndpoint->fSubmittingIos) != 1)
            break;

        // Submit new IOs on all the idle datagram objects

        for (int i = 0; i < pEndpoint->cMaximumIos; i++)
            {
            pDg = &pEndpoint->aDatagrams[i];

            if (pDg->Busy)
                {
                continue;
                }

            // Must be all set for the IO to complete before trying
            // to submit the IO.
            InterlockedIncrement(&pEndpoint->cPendingIos);
            pDg->Busy = TRUE;

            if (MQ_SubmitReceive(pEndpoint, pDg) == RPC_P_IO_PENDING)
                {
                fIoSubmitted = TRUE;
                }
            else
                {
                pDg->Busy = FALSE;
                InterlockedDecrement(&pEndpoint->cPendingIos);
                break;
                }
            }

        // Release the "lock" on the endpoint object.
        pEndpoint->fSubmittingIos = 0;

        if (!fIoSubmitted && pEndpoint->cPendingIos == 0)
            {
            // It appears that no IO is pending on the endpoint.
            COMMON_AddressManager(pEndpoint);
            return;
            }

        // Even if we submitted new IOs, they may all have completed
        // already.  Which means we may need to loop and submit more
        // IOs.  This is needed since the thread which completed the
        // last IO may have run into our lock and returned.
        }
    while (pEndpoint->cPendingIos == 0);

    return;
}



BOOL RPC_ENTRY MQ_AllowReceives(
                         IN DG_TRANSPORT_ENDPOINT pvTransEndpoint,
                         IN BOOL                  fAllowReceives,
                         IN BOOL                  fCancelPendingIos )
{
    BOOL        fPrevAllowReceives;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)pvTransEndpoint;

    fPrevAllowReceives = pEndpoint->fAllowReceives;
    pEndpoint->fAllowReceives = fAllowReceives;

    if (!pEndpoint->cPendingIos)
       {
       MQ_SubmitReceives(pEndpoint);
       }

    ASSERT( !fCancelPendingIos );   // Not implemented yet.

    return fPrevAllowReceives;
}



RPC_STATUS RPC_ENTRY
MQ_SendPacket(
    IN DG_TRANSPORT_ENDPOINT        ThisEndpoint,
    IN DG_TRANSPORT_ADDRESS         pvAddress,
    IN BUFFER                       pHeader,
    IN unsigned                     cHeader,
    IN BUFFER                       pBody,
    IN unsigned                     cBody,
    IN BUFFER                       pTrailer,
    IN unsigned                     cTrailer
    )
/*++

Routine Description:

    Sends a packet to an address.

    The routine will send a packet built out of the three buffers supplied.
    All the buffers are optional, the actual packet sent will be built from
    all the buffers actually supplied.  In each call at least buffer should
    NOT be null.

Arguments:

    ThisEndpoint  - Endpoint to send from.
    pAddress      - Address to send to.

    pHeader       - First data buffer
    cHeader       - Size of the first data buffer or 0.

    pBody         - Second data buffer
    cBody         - Size of the second data buffer or 0.

    pTrailer      - Third data buffer.
    cTrailer      - Size of the third data buffer or 0.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY
    RPC_P_SEND_FAILED

--*/
{
    RPC_STATUS            Status;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;
    MQ_ADDRESS           *pAddress = (MQ_ADDRESS*)pvAddress;
    UCHAR                *pBuffer;
    UCHAR                *pTemp;
    DWORD                 dwBytes = cHeader + cBody + cTrailer;
    HRESULT               hr;
    BOOL                  fNeedToFree = FALSE;


    ASSERT(dwBytes);

    //
    // Buffer assembly. I get the data PDU as up to three separate pieces,
    // so it needs to be assembled before being sent. For Falcon (which can't
    // do scatter/gather) this is expensive (allocate() + memcpy()'s). We try
    // to be cheap and avoid the allocation, or do an _alloca() off the stack
    // instead of the heap.
    //
    if ( (cHeader==0) && (cBody > 0) && (cTrailer == 0) )
        {
        pBuffer = pBody;
        }
    else if (  ((cBody == 0) && (cTrailer == 0))
            || ((pHeader+cHeader == pBody) && (pTrailer == 0)) )
        {
        pBuffer = pHeader;
        }
    else
        {
        pBuffer = (UCHAR*)I_RpcAllocate(dwBytes);
        fNeedToFree = TRUE;

        if (!pBuffer)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pTemp = pBuffer;
        if (cHeader)
            {
            memcpy(pTemp,pHeader,cHeader);
            pTemp += cHeader;
            }

        if (cBody)
            {
            memcpy(pTemp,pBody,cBody);
            pTemp += cBody;
            }

        if (cTrailer)
            {
            memcpy(pTemp,pTrailer,cTrailer);
            }

        ASSERT(pTemp != pBuffer);
        }

    #ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "MQ_SendPacket():\n"));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    To: %S: %S\n",
                   pAddress->wsMachine,
                   pAddress->wsQName));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    Size: %d\n",
                   dwBytes));

    DG_DbgPrintPacket(pBuffer);
    #endif

    hr = MQ_SendToQueue( pEndpoint, pAddress, pBuffer, dwBytes );
    Status = MQ_MapStatusCode(hr,RPC_P_SEND_FAILED);

    if (Status != RPC_S_OK)
       {
       if (fNeedToFree)
          {
          I_RpcFree(pBuffer);
          }

       return Status;
       }

    if ( (pEndpoint->cMinimumIos)
         && (pEndpoint->cPendingIos <= pEndpoint->cMaximumIos) )
        {
        MQ_SubmitReceives(pEndpoint);
        }

    if (fNeedToFree)
       {
       I_RpcFree(pBuffer);
       }

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
MQ_ForwardPacket(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BUFFER                pHeader,
    IN unsigned              cHeader,
    IN BUFFER                pBody,
    IN unsigned              cBody,
    IN BUFFER                pTrailer,
    IN unsigned              cTrailer,
    IN CHAR *                pszPort
    )

/*++

Routine Description:

    Sends a packet to the server it was originally destined for (that
    is, the client had a dynamic endpoint it wished the enpoint mapper
    to resolve and forward the packet to).

Arguments:

    ThisEndpoint      - The endpoint to forward the packet from.

    // Buffer like DG_SendPacket

    pszPort           - Pointer to the server port num to forward to.
                        This is in an Ansi string.

Return Value:

    RPC_S_CANT_CREATE_ENDPOINT - pEndpoint invalid.

    results of MQ_SendPacket().

--*/

{
    PMQ_DATAGRAM_ENDPOINT pEndpoint = (PMQ_DATAGRAM_ENDPOINT)ThisEndpoint;
    MQ_ADDRESS            Address;
    MQ_ADDRESS           *pAddress = &Address;
    RPC_CHAR              wsPort[MQ_MAX_Q_NAME_LEN];
    UNICODE_STRING        UnicodePort;
    ANSI_STRING           AsciiPort;
    DWORD                 Status;
    NTSTATUS              NtStatus;

    //
    // Convert pszPort to Unicode:
    //
    RtlInitAnsiString(&AsciiPort, pszPort);

    UnicodePort.Buffer = wsPort;
    UnicodePort.Length = 0;
    UnicodePort.MaximumLength = MQ_MAX_Q_NAME_LEN * sizeof(RPC_CHAR);

    NtStatus = RtlAnsiStringToUnicodeString(&UnicodePort,
                                            &AsciiPort,
                                            FALSE);

    if (!NT_SUCCESS(NtStatus))
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }

    //
    // Try to connect to the server (to forward the packet to):
    //
    Status = ConnectToServerQueue(pAddress, NULL, wsPort );
    if (Status != RPC_S_OK)
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }


    //
    // Forward the packet on:
    //
    Status = MQ_SendPacket(ThisEndpoint,
                           pAddress,
                           pHeader,
                           cHeader,
                           pBody,
                           cBody,
                           pTrailer,
                           cTrailer );

    //
    // Release the connection, we shouldn't need it any more:
    //
    DisconnectFromServer(pAddress);

    return Status;
}


RPC_STATUS
RPC_ENTRY
MQ_ResizePacket(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer
    )
{
    RPC_STATUS Status = RPC_P_TIMEOUT;
    DWORD      dwBytes = 0;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;
    MQ_DATAGRAM          *pDatagram = &pEndpoint->aDatagrams[0];


    dwBytes = pDatagram->Read.aMsgPropVar[1].ulVal;

    ASSERT(dwBytes);

    #ifdef DBG
    DbgPrint("MQ_ResizePacket(): dwBytes: %d\n",dwBytes);
    #endif

    if ( (pDatagram->pPacket) && (pDatagram->dwPacketSize < dwBytes) )
        {
        Status = I_RpcTransDatagramFree( pEndpoint,
                                         (BUFFER)pDatagram->pPacket,
                                         (PVOID) pDatagram->pAddress);
        pDatagram->pPacket = 0;
        pDatagram->dwPacketSize = 0;
        if (Status != RPC_S_OK)
            {
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    if (!pDatagram->pPacket)
        {
        pDatagram->dwPacketSize = dwBytes;
        Status = I_RpcTransDatagramAllocate2( pEndpoint,
                                              (BUFFER *)&pDatagram->pPacket,
                                              (PUINT)   &pDatagram->dwPacketSize,
                                              (PVOID *) &pDatagram->pAddress);
        if (Status != RPC_S_OK)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pDatagram->cRecvAddr = sizeof(MQ_ADDRESS);

        ASSERT( pDatagram->pPacket );
        }

    #ifdef DBG
    DbgPrint("MQ_ResizePacket(): Ok\n");
    #endif

    return RPC_P_TIMEOUT;
}

RPC_STATUS
RPC_ENTRY
MQ_ReceivePacket(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_TRANSPORT_ADDRESS *pReplyAddress,
    OUT PUINT pBufferLength,
    OUT BUFFER *pBuffer,
    IN  LONG    Timeout
    )
/*++

Routine Description:

    Used to wait for a datagram from a server.  Returns the data
    returned and the address of the machine which replied.

    This is a blocking API. It should only be called during sync
    client RPC threads.

Arguments:

    Endpoint - The endpoint to receive from.
    ReplyAddress - Contain the source address of the datagram if
        successful.
    BufferLength - The size of Buffer on input, the size of the
        datagram received on output.
    Timeout - Milliseconds to wait for a datagram.

Return Value:

    RPC_S_OK

    RPC_P_OVERSIZE_PACKET - Datagram > BufferLength arrived,
        first BufferLength bytes of Buffer contain the partial datagram.

    RPC_P_RECEIVE_FAILED

    RPC_P_TIMEOUT

--*/
{
    RPC_STATUS Status = RPC_P_TIMEOUT;
    DWORD      dwBytes;
    BOOL       fRetry = TRUE;
    HRESULT    hr;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;
    MQ_DATAGRAM          *pDatagram = &pEndpoint->aDatagrams[0];

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->aDatagrams[0].Read.ol.hEvent);

#if TRUE
    while (fRetry)
       {
       fRetry = FALSE;

       if (pDatagram->Busy == 0)
          {
          Status = MQ_SubmitReceive(pEndpoint,pDatagram);
          if (Status != RPC_P_IO_PENDING)
             {
             return Status;
             }

          pDatagram->Busy = TRUE;
          }
       else
          {
          ASSERT(pDatagram->Busy);
          ASSERT(pDatagram->pPacket);

          Status = RPC_P_IO_PENDING;
          }


       if (Status == RPC_P_IO_PENDING)
          {
          Status = WaitForSingleObjectEx(pDatagram->Read.ol.hEvent,
                                         Timeout,
                                         TRUE);

          if (Status != STATUS_WAIT_0)
             {
             // In the timeout case we just want to return.
             if (Status == WAIT_IO_COMPLETION)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "MQ_ReceivePacket() cancelled.\n"));
                }
             else
                {
                ASSERT(Status == STATUS_TIMEOUT);
                }

             ASSERT(pDatagram->Busy);

             return RPC_P_TIMEOUT;
             }
          }


       MQ_FillInAddress(pDatagram->pAddress,pDatagram->Read.aMsgPropVar);
       }

    ASSERT((Status == RPC_S_OK)||(Status == RPC_P_OVERSIZE_PACKET));

    ASSERT(pDatagram->Busy);
    ASSERT(pDatagram->pPacket);
    // ASSERT(dwBytes <= pDatagram->dwPacketSize);

    *pBuffer = (BUFFER)pDatagram->pPacket;
    *pBufferLength = pDatagram->Read.aMsgPropVar[1].ulVal;
                     // dwBytes;
    *pReplyAddress = pDatagram->pAddress;

    pDatagram->pPacket = 0;
    pDatagram->dwPacketSize = 0;
    pDatagram->Busy = 0;

    return Status;

#else
    if (pDatagram->Busy == 0)
        {
        hr = PeekQueue( pEndpoint, Timeout, &dwBytes );

        Status = MQ_MapStatusCode(hr,RPC_P_RECEIVE_FAILED);

        if (Status != RPC_S_OK)
            {
            return Status;
            }

        if ( (pDatagram->pPacket) && (pDatagram->dwPacketSize < dwBytes) )
            {
            Status = I_RpcTransDatagramFree( pEndpoint,
                                             (BUFFER)pDatagram->pPacket,
                                             (PVOID) pDatagram->pAddress);
            pDatagram->pPacket = 0;
            pDatagram->dwPacketSize = 0;
            if (Status != RPC_S_OK)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            }

        if (!pDatagram->pPacket)
            {
            pDatagram->dwPacketSize = dwBytes;
            Status = I_RpcTransDatagramAllocate2( pEndpoint,
                                                  (BUFFER *)&pDatagram->pPacket,
                                                  (PUINT)   &pDatagram->dwPacketSize,
                                                  (PVOID *) &pDatagram->pAddress);
            if (Status != RPC_S_OK)
                {
                return RPC_S_OUT_OF_MEMORY;
                }

            pDatagram->cRecvAddr = sizeof(MQ_ADDRESS);

            ASSERT( pDatagram->pPacket );
            }

        pDatagram->Busy = TRUE;
        dwBytes = pDatagram->dwPacketSize;
        hr = ReadQueue( pEndpoint, Timeout, pDatagram->pAddress, pDatagram->pPacket, &dwBytes );
        Status = MQ_MapStatusCode(hr,RPC_P_RECEIVE_FAILED);
        if (FAILED(hr))
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "ReadQueue() failed: 0x%x\n",
                           hr));

            pDatagram->Busy = FALSE;
            return Status;
            }
        }

    #ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "MQ_ReceivePacket():\n"));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    Receive on: %S\n",
                   pEndpoint->wsQName));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    From: %S\n",
                   pDatagram->pAddress->wsQName));

    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "    Size: %d\n",
                   dwBytes));

    DG_DbgPrintPacket(pDatagram->pPacket);
    #endif

    ASSERT((Status == RPC_S_OK)||(Status == RPC_P_OVERSIZE_PACKET));

    ASSERT(pDatagram->Busy);
    ASSERT(pDatagram->pPacket);
    ASSERT(dwBytes <= pDatagram->dwPacketSize);

    *pBuffer = (BUFFER)pDatagram->pPacket;
    *pBufferLength = dwBytes;
    *pReplyAddress = pDatagram->pAddress;

    pDatagram->pPacket = 0;
    pDatagram->dwPacketSize = 0;
    pDatagram->Busy = 0;

    return Status;
#endif
}


RPC_STATUS
MQ_CreateEndpoint(
    OUT MQ_DATAGRAM_ENDPOINT *pEndpoint,
    IN  MQ_ADDRESS           *pAddress,
    IN  void                 *pSecurityDescriptor,
    IN  DWORD                 dwEndpointFlags,
    IN  PROTOCOL_ID           id,
    IN  BOOL                  fClient,
    IN  BOOL                  fAsync
    )
/*++

Routine Description:

    Creates a new endpoint.

Arguments:

    pEndpoint - The runtime allocated endpoint structure to
        filled in.

    pSockAddr - An initialized sockaddr with the correct
        (or no) endpoint.

    id - The id of the protocol to use in creating the address.

    fClient - If TRUE this is a client endpoint

    fAsync  - If TRUE this endpoint is "async" which means that
        a) It should be added to the IO completion port and
        b) that the transport should pend a number of receives
        on the endpoint automatically.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    MQ_DATAGRAM *pDatagram;
    int        i;
    int        err;
    int        length;
    RPC_STATUS Status = RPC_S_OK;
    HRESULT    hr;
    UUID       uuid;
    DWORD      dwSize;
    RPC_CHAR     *pwsUuid;
    RPC_CHAR      wsQName[MQ_MAX_Q_NAME_LEN];
    RPC_CHAR      wsMachine[MAX_COMPUTERNAME_LEN];


    pEndpoint->type = DATAGRAM | ADDRESS;
    pEndpoint->id = id;
    pEndpoint->pAddressVector = 0;
    pEndpoint->SubmitListen = MQ_SubmitReceives;
    pEndpoint->InAddressList = NotInList;
    pEndpoint->pNext = 0;
    pEndpoint->fSubmittingIos = 0;
    pEndpoint->cPendingIos = 0;
    pEndpoint->cMinimumIos = 0;
    pEndpoint->cMaximumIos = 0;
    pEndpoint->aDatagrams  = 0;
    pEndpoint->pFirstAddress = pEndpoint;
    pEndpoint->pNextAddress = 0;

    pEndpoint->hQueue = 0;
    pEndpoint->hAdminQueue = 0;

    // If we're told not to listen, then we won't allow receives
    // until we are specifically told to do so...
    #ifdef RPC_C_MQ_DONT_LISTEN
    pEndpoint->fAllowReceives = !(dwEndpointFlags & RPC_C_MQ_DONT_LISTEN);
    #else
    pEndpoint->fAllowReceives = TRUE;
    #endif

    pEndpoint->fAck     = FALSE;
    pEndpoint->ulDelivery = RPC_C_MQ_EXPRESS;
    pEndpoint->ulPriority = DEFAULT_PRIORITY;
    pEndpoint->ulJournaling = RPC_C_MQ_JOURNAL_NONE;
    pEndpoint->ulTimeToReachQueue = INFINITE;
    pEndpoint->ulTimeToReceive = INFINITE;

    pEndpoint->fAuthenticate = FALSE;
    pEndpoint->fEncrypt = FALSE;
    pEndpoint->ulPrivacyLevel = 0;

    // Machine name:
    dwSize = sizeof(wsMachine);
    if (!GetComputerName((RPC_SCHAR *)wsMachine,&dwSize))
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    // Get the name of the machine that the QM (mqsvc.exe)
    // is running on:
    dwSize = sizeof(pEndpoint->wsMachine);
    hr = QueryQM(pEndpoint->wsMachine,&dwSize);
    if (FAILED(hr))
       {
       Status = MQ_MapStatusCode(hr,RPC_S_CANT_CREATE_ENDPOINT);
       return Status;
       }

    //
    // See if this is a call from an RPC server or RPC client:
    //
    if (fClient)
        {
        pEndpoint->type |= CLIENT;

        // Queue name (a unique string...):
        Status = UuidCreate(&uuid);
        if ((Status != RPC_S_OK) && (Status != RPC_S_UUID_LOCAL_ONLY))
            {
            return Status;
            }

        if (UuidToString(&uuid,&pwsUuid) != RPC_S_OK)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpStringCopy(wsQName,TEXT("RpcCl-"));
        RpcpStringCat(wsQName,pwsUuid);

        // Function UuidCreate() allocated a string, free it:
        RpcStringFree(&pwsUuid);

        //
        // Create the queue for this endpoint:
        //
        hr = ClientSetupQueue( pEndpoint, pEndpoint->wsMachine, wsQName );
        Status = MQ_MapStatusCode(hr,RPC_S_CANT_CREATE_ENDPOINT);

        if (Status == RPC_S_OK)
           {
           MQ_RegisterQueueToDelete(pEndpoint->wsQFormat,wsMachine);
           }
        }
    else
        {
        pEndpoint->type |= SERVER;

        //
        // Create the queue for this server endpoint:
        //
        hr = ServerSetupQueue( pEndpoint,
                               pEndpoint->wsMachine,
                               pEndpoint->wsQName,
                               pSecurityDescriptor,
                               dwEndpointFlags );

        Status = MQ_MapStatusCode(hr,RPC_S_CANT_CREATE_ENDPOINT);

        //
        // Check to see if this queue is temporary. If so, then
        // register it with RPCSS to delete.
        //
        if ((Status == RPC_S_OK) && !(RPC_C_MQ_PERMANENT & dwEndpointFlags))
           {
           MQ_RegisterQueueToDelete(pEndpoint->wsQFormat,wsMachine);
           }
        }

    //
    // If the endpoint is going to async initialize async part
    // and add the socket to the IO completion port.
    //

    if (Status == RPC_S_OK)
        {
        int cMaxIos;
        int cMinIos;

        ASSERT(fAsync || fClient);

        // Step one, figure out the high and low mark for ios.

        if (fAsync)
            {
            // PERF REVIEW these parameters.
            cMaxIos = 2
                      + (gfServerPlatform == TRUE) * 2
                      + (fClient == FALSE) * gNumberOfProcessors;

            // This should be larger than zero so that we'll generally submit new
            // recvs during idle time rather then just after receiving a datagram.
            cMinIos = 1 + (fClient == FALSE ) * (gNumberOfProcessors/2);

            cMinIos = 1;
            cMaxIos = 1;
            }
        else
            {
            // For sync endpoints we need to allocate a single datagram
            // object for the receive.
            cMinIos = 0;
            cMaxIos = 1;
            }

        // ASSERT(cMinIos < cMaxIos); Not currently true...

        pEndpoint->cMinimumIos = cMinIos;
        pEndpoint->cMaximumIos = cMaxIos;

        // Allocate a chunk on memory to hold the array of datagrams

        // PERF: For clients, allocate larger array but don't submit all
        // the IOs unless we determine that the port is "really" active.

        pEndpoint->aDatagrams = new MQ_DATAGRAM[cMaxIos];

        if (pEndpoint->aDatagrams)
            {
            UINT type;
            type = DATAGRAM | RECEIVE;
            type |= (fClient) ? CLIENT : SERVER;

            for (i = 0; i < cMaxIos; i++)
                {
                pDatagram = &pEndpoint->aDatagrams[i];

                pDatagram->id = id;
                pDatagram->type = type;
                pDatagram->pEndpoint = pEndpoint;
                pDatagram->Busy = 0;
                pDatagram->pPacket = 0;
                pDatagram->dwPacketSize = 0;
                memset(&pDatagram->Read, 0, sizeof(pDatagram->Read));
                pDatagram->Read.pAsyncObject = pDatagram;
                }

            if (fAsync)
                {
                Status = COMMON_PrepareNewHandle((HANDLE)pEndpoint->hQueue);
                }
            else
                {
                // The receive operation on sync endpoints will may span
                // several receives.  This means it can't use the thread
                // event, so allocate an event for the receive.
                HANDLE hEvent = CreateEvent(0, TRUE, FALSE, 0);
                if (!hEvent)
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                else
                    {
                    ASSERT(pDatagram == &pEndpoint->aDatagrams[0]);
                    pDatagram->Read.ol.hEvent = hEvent;
                    }
                }
            }
        else
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        }

    // If adding a new failure case here, add code to close the sync receive event.

    if (Status != RPC_S_OK)
        {
        delete pEndpoint->aDatagrams;

        return Status;
        }

    return(RPC_S_OK);
}


void RPC_ENTRY
MQ_ServerAbortListen(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Callback after DG_CreateEndpoint has completed successfully
    but the runtime for some reason is not going to be able to
    listen on the endpoint.

--*/
{
    HRESULT     hr;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;

    #ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   RPCTRANS "MQ_ServerAbortListen(): %S\n",
                   pEndpoint->wsQName));
    #endif

    ASSERT(pEndpoint->cPendingIos == 0);
    ASSERT(pEndpoint->hQueue);
    ASSERT(pEndpoint->pNext == 0);
    ASSERT(pEndpoint->type & SERVER);

    if (pEndpoint->pAddressVector)
        {
        delete pEndpoint->pAddressVector;
        }

    if (pEndpoint->aDatagrams)
        {
        delete pEndpoint->aDatagrams;
        }

    hr = ServerCloseQueue(pEndpoint);

    return;
}


RPC_STATUS RPC_ENTRY
MQ_ClientCloseEndpoint(
    IN DG_TRANSPORT_ENDPOINT ThisEndpoint
    )
/*++

Routine Description:

    Called on sync client endpoints when they are no longer needed.

Arguments:

    ThisEndpoint

Return Value:

    RPC_S_OK

--*/
{
    HRESULT      hr;
    PMQ_DATAGRAM_ENDPOINT pEndpoint = (PMQ_DATAGRAM_ENDPOINT)ThisEndpoint;
    PMQ_DATAGRAM pDatagram = &pEndpoint->aDatagrams[0];

    ASSERT((pEndpoint->type & TYPE_MASK) == CLIENT);
    ASSERT(pEndpoint->hQueue);           // MQOpenQueue must have worked
    ASSERT(pEndpoint->cMinimumIos == 0);
    ASSERT(pEndpoint->cMaximumIos == 1); // Must not be async!
    ASSERT(pEndpoint->aDatagrams);
    // ASSERT(pEndpoint->Endpoint == 0);
    ASSERT(pEndpoint->pAddressVector == 0);
    // ASSERT(pEndpoint->pNext == 0);

    // Close & delete the client queue:
    hr = ClientCloseQueue(pEndpoint);

    // Free the receive buffer if allocated
    if (pDatagram->pPacket)
        {
        I_RpcTransDatagramFree(pEndpoint,
                               (BUFFER)pDatagram->pPacket,
                               pDatagram->pAddress
                               );
        }

    if (pDatagram->Read.ol.hEvent)
        {
        CloseHandle(pDatagram->Read.ol.hEvent);
        }

    delete pDatagram;

    pEndpoint->aDatagrams = 0;

    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
MQ_ServerListen(
    IN OUT DG_TRANSPORT_ENDPOINT    ThisEndpoint,
    IN     RPC_CHAR                *NetworkAddress,
    IN OUT RPC_CHAR               **ppEndpoint,
    IN     void                    *pSecurityDescriptor,
    IN     ULONG                    EndpointFlags,
    IN     ULONG                    NICFlags,
    OUT    NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
    )
/*++

Routine Description:

    Creates a server endpoint object to receive packets.  New
    packets won't actually arrive until CompleteListen is
    called.

Arguments:

    ThisEndpoint - Storage for the server endpoint object.
    ppEndpoint - The RPC_CHAR name of the endpoint to listen
        on or a pointer to 0 if the transport should choose
        the address. Contains the endpoint listened to on
        output. The caller should free this.
    EndpointFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    NICFlags - Application flags passed into RPC via
        RpcServerUseProtseq*Ex.
    pNetworkAddresses - A vector of the network addresses
        listened on by this call.  This vector does
        not need to be freed.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS  Status;
    DWORD       dwSize;
    UUID        uuid;
    RPC_CHAR   *pUuidStr;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;


    *ppNetworkAddressVector = 0;

    if (*ppEndpoint)
        {
        // Known Endpoint:
        RpcpStringCopy(pEndpoint->wsQName,*ppEndpoint);
        }
    else
        {
        // Dynamic Endpoint:
        Status = UuidCreate(&uuid);
        if ((Status != RPC_S_OK) && (Status != RPC_S_UUID_LOCAL_ONLY))
           {
           return Status;
           }

        Status = UuidToString(&uuid,&pUuidStr);
        if (Status != RPC_S_OK)
           {
           return Status;
           }

        RpcpStringCopy(pEndpoint->wsQName,TEXT("RpcSvr-"));
        RpcpStringCat(pEndpoint->wsQName,pUuidStr);
        RpcStringFree(&pUuidStr);

        dwSize = (1+RpcpStringLength(pEndpoint->wsQName))*(sizeof(RPC_CHAR));
        *ppEndpoint = (RPC_CHAR*)I_RpcAllocate(dwSize);
        if (!*ppEndpoint)
           {
           return RPC_S_OUT_OF_MEMORY;
           }

        RpcpStringCopy(*ppEndpoint,pEndpoint->wsQName);
        }

    //
    // Actually create the endpoint
    //
    Status = MQ_CreateEndpoint( pEndpoint,
                                NULL,
                                pSecurityDescriptor,
                                EndpointFlags,
                                MSMQ,
                                FALSE,     // Server
                                TRUE   );  // Async

    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = MQ_BuildAddressVector(&pEndpoint->pAddressVector);

    if (Status != RPC_S_OK)
        {
        MQ_ServerAbortListen(ThisEndpoint);
        return Status;
        }

    *ppNetworkAddressVector = pEndpoint->pAddressVector;

    #if FALSE
    // If needed, figure out the dynamically allocated endpoint.

    if (!*pPort)
        {
        *pPort = new RPC_CHAR[IP_MAXIMUM_ENDPOINT];
        if (!*pPort)
            {
            MQ_ServerAbortListen(ThisEndpoint);
            return(RPC_S_OUT_OF_MEMORY);
            }

        port = ntohs(addr.inetaddr.sin_port);

        PortNumberToEndpoint(port, *pPort);
        }

    // Figure out the network addresses

    status = IP_BuildAddressVector(&pEndpoint->pAddressVector);

    if (status != RPC_S_OK)
        {
        MQ_ServerAbortListen(ThisEndpoint);
        return(status);
        }

    *ppNetworkAddressVector = pEndpoint->pAddressVector;
    #endif

    return RPC_S_OK;
}


RPC_STATUS
MQ_QueryEndpoint
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientEndpoint
    )
{
    MQ_ADDRESS *pAddress = (MQ_ADDRESS*)pOriginalEndpoint;

    if (!RpcpStringLength(pAddress->wsQName))
        {
        ParseQueuePathName(pAddress->wsMsgLabel,
                           pAddress->wsMachine,
                           pAddress->wsQName);
        }

    RpcpStringCopy(pClientEndpoint,pAddress->wsQName);

    return RPC_S_OK;
}


RPC_STATUS
MQ_QueryAddress
    (
    IN  void *     pOriginalEndpoint,
    OUT RPC_CHAR * pClientAddress
    )
{
    MQ_ADDRESS *pAddress = (MQ_ADDRESS*)pOriginalEndpoint;

    if (!RpcpStringLength(pAddress->wsMachine))
        {
        ParseQueuePathName(pAddress->wsMsgLabel,
                           pAddress->wsMachine,
                           pAddress->wsQName);
        }

    RpcpStringCopy(pClientAddress,pAddress->wsMachine);

    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
MQ_ClientInitializeAddress
     (
     OUT DG_TRANSPORT_ADDRESS pvAddress,
     IN  RPC_CHAR *pNetworkAddress,
     IN  RPC_CHAR *pEndpoint,
     IN  BOOL fUseCache,
     IN  BOOL fBroadcast
     )
/*++

Routine Description:

    Initializes a address object for sending to a server.

Arguments:

    pvAddress - Storage for the address
    pNetworkAddress - The address of the server or 0 if local
    pEndpoint - The endpoint of the server
    fUseCache - If TRUE then the transport may use a cached
        value from a previous call on the same NetworkAddress.
    fBroadcast - If TRUE, NetworkAddress is ignored and a broadcast
        address is used.

Return Value:

    RPC_S_OK - Success, name resolved and, optionally, added to cache.
    RPC_P_FOUND_IN_CACHE - Success, returned only if fUseCache is TRUE
        and the was name found in local cache.
    RPC_P_MATCHED_CACHE - Partial success, fUseCache is FALSE and the
        result of the lookup was the same as the value previously
        in the cache.

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_SERVER_UNAVAILABLE

--*/
{
    RPC_STATUS  Status = RPC_S_OK;
    MQ_ADDRESS *pAddress = (MQ_ADDRESS*)pvAddress;

    ASSERT(pvAddress);

    Status = ConnectToServerQueue(pAddress,pNetworkAddress,pEndpoint);

    return Status;
}


RPC_STATUS
RPC_ENTRY
MQ_ClientOpenEndpoint(
    OUT DG_TRANSPORT_ENDPOINT ThisEndpoint,
    IN BOOL fAsync,
    DWORD Flags
    )
{
    RPC_STATUS Status;
    MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)ThisEndpoint;

    Status = MQ_CreateEndpoint(pEndpoint, NULL, NULL, 0, MSMQ, TRUE, fAsync);

    return Status;
}

RPC_STATUS
RPC_ENTRY
MQ_GetEndpointStats(
    IN  DG_TRANSPORT_ENDPOINT ThisEndpoint,
    OUT DG_ENDPOINT_STATS *   pStats
    )
{
    pStats->PreferredPduSize = MQ_PREFERRED_PDU_SIZE;
    pStats->MaxPduSize = MQ_MAX_PDU_SIZE;
    pStats->MaxPacketSize = MQ_MAX_PACKET_SIZE;
    pStats->ReceiveBufferSize = MQ_RECEIVE_BUFFER_SIZE;

    return RPC_S_OK;
}

//----------------------------------------------------------------
//  MQ_InquireAuthClient()
//
//  Fill out security information for the transport.
//
//  NOTE: The returned SID (ppSid) is a pointer to the one in the
//        client endpoint. The caller can't free it and should make
//        its own copy...
//----------------------------------------------------------------
RPC_STATUS
RPC_ENTRY
MQ_InquireAuthClient( void      *pvClientEndpoint,
                      RPC_CHAR **ppPrincipal,
                      SID      **ppSid,
                      ULONG     *pulAuthnLevel,
                      ULONG     *pulAuthnService,
                      ULONG     *pulAuthzService )
{
   RPC_STATUS   Status = RPC_S_OK;
   MQ_ADDRESS  *pClientEndpoint = (MQ_ADDRESS*)(pvClientEndpoint);
   SID         *pClientSid;
   DWORD        dwSize;

   ASSERT(pulAuthnLevel);
   ASSERT(pulAuthnService);
   ASSERT(pulAuthzService);

   if (pClientEndpoint)
      {
      *ppPrincipal = NULL;
      *pulAuthnService = RPC_C_AUTHN_MQ;
      *pulAuthzService = RPC_C_AUTHZ_NONE;

      //
      //  The authentication level:
      //
      if (pClientEndpoint->fAuthenticated)
         {
         if (pClientEndpoint->ulPrivacyLevel == MQMSG_PRIV_LEVEL_BODY)
            *pulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
         else
            *pulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
         }
      else if (pClientEndpoint->ulPrivacyLevel == MQMSG_PRIV_LEVEL_BODY)
         {
         *pulAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
         }
      else
         {
         *pulAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
         }

      if ( IsValidSid((PSID)(pClientEndpoint->aSidBuffer)) )
         *ppSid = (SID*)(pClientEndpoint->aSidBuffer);
      else
         *ppSid = NULL;

      }
   else
      Status = RPC_S_BINDING_HAS_NO_AUTH;

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\ipxname.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ipxname.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    gethost.c

Abstract:

    Maps a server name to SPX address by consulting the Netware Bindery.
    Attach/Detach/FindFileServer, and ReadPropertyValue were all borrowed
    from the SQL 6.0 code base.

Author:

    Jeff Roberts (jroberts)  20-Nov-1995

Revision History:

     20-Nov-1995 (jroberts) Took code from AndreasK of SQL Server, and modified
                            it for RPC.
        
     24-Jan-1997  (MarioGo) C++ and cache cleanup work.

--*/

#include <precomp.hxx>
#include <CharConv.hxx>

const GUID SERVICE_TYPE = { 0x000b0640, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } };

#define CRITICAL_SECTION_WRAPPER RTL_CRITICAL_SECTION

#define MAX_FILESRVS            5               /* try 5 servers (chicago uses this same number) */

/*****  NETWARE MAGIC NUMBERS   *****/

#define NSPROTO_NCP                     (NSPROTO_IPX+0x11)

/* NCP Request Types */
#define CREATE_CONN_REQTYPE             0x1111
#define DESTROY_CONN_REQYPE             0x5555
#define GENERAL_REQTYPE                 0x2222

/* NCP Request Codes */
#define NCP_SCAN_BINDERY                0x17
#define NCP_END_OF_TASK                 0x18
#define NCP_LOGOUT                      0x19
#define NCP_NEG_BUFFER_SIZE             0x21

/* NCP Function codes */
#define SCAN_BINDERY_FUNC               0x37
#define READ_PROP_VALUE_FUNC            0x3D

/* SAP protocol request codes */
#define SAP_GENERAL_QUERY               0x0100  /* general query hi-lo   */
#define SAP_GENERAL_RESPONSE            0x0200  /* general response hi-lo            */
#define SAP_NEAREST_QUERY               0x0300  /* nearest query hi-lo   */
#define SAP_NEAREST_RESPONSE            0x0400  /* nearest response hi-lo   */


/* Socket Numbers       */
#define NCP_SOCKET                      0x5104  /* SAP socket hi-lo              */
#define SAP_SOCKET                      0x5204  /* SAP socket hi-lo              */
#define GUEST_SOCKET                    0x1840

/* SAP Service Types */
#define FILE_SERVER                     0x0400  /* netware file server hi-lo     */
#define SNA_SERVER                      0x4404  /* SNA Server type 0x0444        */
#define BRIDGE_SERVER                   0x2400

#define SAP_SERVICE_STOPPED             0x1000  /* invalid hub count, hi-lo      */
#define SAP_TIMEOUT                     60000   /* SAP timeout, one minute       */
#define NCP_CONNECTION_ERROR            0x15    /* connection error mask         */

#define BINDERY_FAILURE                 0x00FF  /* bindery call failed           */

#define RPC_SAP_TYPE                    0x0640

#define SWAP(x) RpcpByteSwapShort(x)

typedef struct
{
  CSADDR_INFO   info;
  SOCKADDR_IPX  addr1;
  SOCKADDR_IPX  addr2;
} CSADDR_BUFFER;

#pragma pack(1)

typedef struct _sip_entry
{
    char           server_name[48];
    unsigned long  network;
    char           node[6];
    unsigned short socket;
    unsigned short hops;
} SIP_ENTRY;

typedef struct _sip             /* Service Information Packet */
{
    unsigned short response_type;
    unsigned short server_type;
    SIP_ENTRY      entries[7];
} SIP;

typedef struct          /* Service Query Packet */
{
    unsigned short query_type;
    unsigned short server_type;
} SQP;

typedef struct  /* NCP Request Header */
{
    unsigned short req_type;
    unsigned char seq_no;
    unsigned char conn_no_low;
    unsigned char task_no;
    unsigned char conn_no_high;
    unsigned char req_code;

} NCPHDR;

typedef struct  /* NCP Response Header */
{
    unsigned short req_type;
    unsigned char seq_no;
    unsigned char conn_no_low;
    unsigned char task_no;
    unsigned char conn_no_high;
    unsigned char ret_code;
    unsigned char conn_status;
} NCPRSP;

typedef struct  /* Scan Bindery Request */
{
    NCPHDR hdr;
    unsigned short length;
    unsigned char  func_code;
    unsigned long  last_id;
    unsigned short obj_type;
    unsigned char sstring[49];
} SCANREQ;
#define SCANSIZE        56

typedef struct  /* Scan Bindery Response */
{
    NCPRSP hdr;
    unsigned long  obj_id;
    unsigned short obj_type;
    unsigned char  obj_name[48];
    unsigned char  obj_status;
    unsigned char  sec_status;
    unsigned char  status_flags;
} SCANRSP;

typedef struct  /* Read Propery Value */
{
    NCPHDR hdr;
    unsigned short length;
    unsigned char  func_code;
    unsigned short obj_type;
    unsigned char  obj_name[49];
    unsigned char  seg_no;
    unsigned char  prop_name[17];
} RVALREQ;
#define RVALSIZE        70

typedef struct  /* Read Propery Value Response */
{
    NCPRSP hdr;
    unsigned char  prop_value[128];
    unsigned char  more_flag;
    unsigned char  prop_flags;
} RVALRSP;

#pragma pack()

#define BUFFER_SIZE                 1024    /* Size of send and recv buffer         */

struct
{
    SOCKADDR_IPX nsRemote[MAX_FILESRVS];    /* Remote IPX addresses                 */
    unsigned     ServerCount;               /* number of valid entries in nsRemote  */
    unsigned     ActiveServer;              /* index of the the address in use      */
    SOCKET       s;                         /* Socket handle                        */
    unsigned short ConnectionId;
    NCPHDR       *nhHeader;                 /* Last NCP header sent                 */
    char         *RcvBuffer;
}
nsStatus;

typedef struct IPXAddress
{
   char                 network[4];
   char                 node[6];
   unsigned short       socket;
} IPXAddress;


int     FindFileServers();
BOOL    AttachToFileServer();
BOOL    ConnectToActiveServer();
BOOL    DetachFromActiveServer();
int     SendPacket( SOCKET, char *, int, SOCKADDR *, DWORD );
USHORT  ReadPropertyValue( char *, USHORT, char *, USHORT, UCHAR *,
                          UCHAR *, UCHAR * );
int
NcpTransaction(
    int iSize
    );

DWORD
InitializeCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlInitializeCriticalSection(Mutex);

    if (!NT_SUCCESS(NtStatus))
        {
        return RtlNtStatusToDosError(NtStatus);
        }
    return(NO_ERROR);
}

DWORD
DeleteCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlDeleteCriticalSection(Mutex);

    if (!NT_SUCCESS(NtStatus))
        {
        return RtlNtStatusToDosError(NtStatus);
        }
    return(NO_ERROR);
}

DWORD
EnterCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlEnterCriticalSection(Mutex);

    if (!NT_SUCCESS(NtStatus))
        {
        return RtlNtStatusToDosError(NtStatus);
        }
    return(NO_ERROR);
}

DWORD
LeaveCriticalSectionWrapper(
    RTL_CRITICAL_SECTION * Mutex
    )
{
    NTSTATUS NtStatus;

    NtStatus = RtlLeaveCriticalSection(Mutex);
    ASSERT (NT_SUCCESS(NtStatus));

    return(NO_ERROR);
}


BOOL
AttachToFileServer(
    )
//**************************************************************************
//
// This function creates an attachment between an NT workstation and
// a Novell Netware file server.
//
// Params:
//      USHORT *pConectionID - Receives the connection ID for the newly
//                             attached file server
//                             LOBYTE(ConnectionID) = conn_no_low
//                             HIBYTE(ConnectionID) = conn_no_high
//
// Return Values:
//
//      TRUE  - successful
//      FALSE - unsuccessful
//
//***************************************************************************
{
    DWORD IDThread;
    unsigned i;
    char scratch[2];

    SOCKET s;
    SOCKADDR_IPX nsAddr;
    unsigned Timeout;

    s = socket( AF_NS, SOCK_DGRAM, NSPROTO_NCP );
    if ( s == INVALID_SOCKET )
        {
        return FALSE;
        }

    //
    // Set the receive timeout.
    //
    Timeout = 3000;
    if (SOCKET_ERROR == setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout)))
        {
        closesocket(s);
        return FALSE;
        }

    memset( &nsAddr, '\0', sizeof(SOCKADDR_IPX) );
    nsAddr.sa_family = AF_NS;
    if (SOCKET_ERROR == bind(s, (SOCKADDR *)&nsAddr, sizeof(SOCKADDR_IPX)) )
        {
        closesocket(s);
        return FALSE;
        }

    nsStatus.s = s;

    /* Find the nearest file server. */

    if( nsStatus.ServerCount )
        {
        for (i=0; i < nsStatus.ServerCount; i++)
            {
            nsStatus.ActiveServer = i;
            if( ConnectToActiveServer() )
                {
                nsStatus.ConnectionId = nsStatus.nhHeader->conn_no_low + (nsStatus.nhHeader->conn_no_high << 8);
                return TRUE;
                }
            }
        }

    FindFileServers();

    if( nsStatus.ServerCount )
        {
        for (i=0; i < nsStatus.ServerCount; i++)
            {
            nsStatus.ActiveServer = i;
            if( ConnectToActiveServer() )
                {
                nsStatus.ConnectionId = nsStatus.nhHeader->conn_no_low + (nsStatus.nhHeader->conn_no_high << 8);
                return TRUE;
                }
            }
        }

    closesocket(s);
    nsStatus.s = 0;

    return FALSE;
}


int
FindFileServers(
    )
/****************************************************************************/
/*                                                                          */
/* This function uses the SAP (Service Advertise Protocol) Find Nearest     */
/* query to find a netware file server.                                     */
/*                                                                          */
/* Returns:                                                                 */
/*      Number of servers found (0 - MAX_FILESRVS)                          */
/*                                                                          */
/****************************************************************************/
{
    SOCKET s;
    BOOL bBcst;
    SQP sqp;
    SIP sip;
    unsigned Timeout;

    SOCKADDR_IPX raddr;
    SOCKADDR_IPX nsAddr;


    //
    // Create a socket for the SAP broadcast.
    //
    s = socket( AF_NS, SOCK_DGRAM, NSPROTO_IPX );
    if( s == INVALID_SOCKET )
        {
        return 0;
        }

    memset( &nsAddr, '\0', sizeof(SOCKADDR_IPX) );
    nsAddr.sa_family = AF_NS;
    if(SOCKET_ERROR ==  bind(s, (SOCKADDR *)&nsAddr, sizeof(SOCKADDR_IPX)) )
        {
        closesocket(s);
        return 0;
        }

    //
    // Enable broadcasts.
    //
    bBcst = TRUE;
    if (SOCKET_ERROR ==  setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&bBcst, sizeof(BOOL)))
        {
        closesocket(s);
        return 0;
        }

    //
    // Set the receive timeout.
    //
    Timeout = 2000;
    if (SOCKET_ERROR == setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *) &Timeout, sizeof(Timeout)))
        {
        closesocket(s);
        return 0;
        }

    //
    // Build a SAP query packet.
    //
    sqp.query_type = SAP_NEAREST_QUERY;
    sqp.server_type = FILE_SERVER;

    raddr.sa_family = AF_NS;
    *((unsigned long UNALIGNED *) &raddr.sa_netnum) = 0;
    memset( &raddr.sa_nodenum, 0xff, 6 );
    raddr.sa_socket = SAP_SOCKET;

    //
    // Send the SAP request.
    //
    if (SOCKET_ERROR == sendto( s, (char *) &sqp, sizeof(SQP), 0, (SOCKADDR *) &raddr, sizeof(SOCKADDR_IPX) ))
        {
        closesocket(s);
        return 0;
        }

    //
    // Collate responses.
    //
    nsStatus.ServerCount = 0;
    do
        {
        unsigned length;

irrelevant_packet:

        length = recvfrom(s, (char *) &sip, sizeof(sip), 0, 0, 0);
        if (SOCKET_ERROR == length)
            {
            break;
            }

        //
        // IPX router spec says find nearest responses can contain only one
        // entry.
        //
        if (length != sizeof(sip) - sizeof(sip.entries) + sizeof(SIP_ENTRY))
            {
            goto irrelevant_packet;
            }

        if (sip.response_type != SAP_NEAREST_RESPONSE)
            {
            goto irrelevant_packet;
            }

        if (sip.server_type != FILE_SERVER)
            {
            goto irrelevant_packet;
            }

        nsStatus.nsRemote[nsStatus.ServerCount].sa_family = AF_NS;
        nsStatus.nsRemote[nsStatus.ServerCount].sa_socket = NCP_SOCKET;
        memcpy( &nsStatus.nsRemote[nsStatus.ServerCount].sa_netnum,
                &sip.entries[0].network,
                sizeof(sip.entries[0].network)+sizeof(sip.entries[0].node)
                );
        }
    while ( ++nsStatus.ServerCount < MAX_FILESRVS );

    closesocket(s);
    return nsStatus.ServerCount;
}


BOOL
ConnectToActiveServer(
    )
/****************************************************************************/
/*                                                                          */
/* This function creates a NCP connection between the local workstation     */
/* and the specified file server. It sends the following NCP packets to     */
/* the file server:                                                         */
/*      1. Create Connection                                                */
/*      2. Negotiate Buffer Size                                            */
/*                                                                          */
/* Params:                                                                  */
/*      SOCKADDR_IPX *ipxDest     - server's IPX address                    */
/*                                                                          */
/* Returns:                                                                 */
/*      TRUE    - SUCCEEDED                                                 */
/*      FALSE   - FAILED                                                    */
/*                                                                          */
/****************************************************************************/
{
    SOCKADDR_IPX nsAddr;
    NCPHDR *pnhReq;
    NCPRSP *pnrResp;
    USHORT UNALIGNED *pwBufSize;
    BOOL fSuccess;

    //
    // Build a CREATE_CONNECTION request.
    //
    memset( nsStatus.nhHeader, '\0', sizeof(NCPHDR));

    pnhReq = nsStatus.nhHeader;
    pnhReq->req_type = CREATE_CONN_REQTYPE;
    pnhReq->seq_no = 0;                     /* reset sequence number */
    pnhReq->conn_no_low = 0xFF;             /* no connection yet     */
    pnhReq->conn_no_high = 0xFF;            /* no connection yet     */
    pnhReq->task_no = 0;
    pnhReq->req_code = 0;

    //
    // Send the packet and wait for response.
    //
    fSuccess = FALSE;
    if (SOCKET_ERROR != NcpTransaction(sizeof(NCPHDR)) )
        {
        /* Save our connection number, it is used in all the subsequent */
        /* NCP packets.                                                                                                 */
        pnrResp = (NCPRSP *)nsStatus.RcvBuffer;
        if ( pnrResp->ret_code == 0 )
            {
            nsStatus.nhHeader->conn_no_low = pnrResp->conn_no_low;
            nsStatus.nhHeader->conn_no_high = pnrResp->conn_no_high;

            fSuccess = TRUE;
            }
        }

    return fSuccess;
}


BOOL
DetachFromActiveServer(
    )
/****************************************************************************/
/*                                                                          */
/* This function logs out the bindery object and detaches the workstation   */
/* from the specified file server.                                          */
/*                                                                          */
/* Params:                                                                  */
/*      none
/*                                                                          */
/* Returns:                                                                 */
/*      TRUE       - Always                                                    */
/*                                                                          */
/****************************************************************************/
{
    int iret;

    if (0 == nsStatus.s)
        {
        return TRUE;
        }

    nsStatus.nhHeader->req_type = DESTROY_CONN_REQYPE;
    nsStatus.nhHeader->seq_no++;
    nsStatus.nhHeader->req_code = 0;

    NcpTransaction(sizeof(NCPHDR));

    closesocket( nsStatus.s );
    nsStatus.s = 0;

    return TRUE;
}


USHORT
ReadPropertyValue(
    char *ObjectName,
    USHORT ObjectType,
    char *PropertyName,
    USHORT SegmentNumber,
    UCHAR *PropertyValue,
    UCHAR *MoreSegments,
    UCHAR *PropertyFlags
    )
{
/*++

Routine Description:



Arguments:



Return Value:



--*/

    RVALREQ *pReq;
    RVALRSP *pRsp;
    int iRet;

    if ( !nsStatus.s )
        {
        return BINDERY_FAILURE;
        }

    /* Build a SCAN_BINDERY request */
    pReq = (RVALREQ *) nsStatus.nhHeader;
    pReq->hdr.seq_no++;
    pReq->hdr.req_code = NCP_SCAN_BINDERY;
    pReq->hdr.req_type = GENERAL_REQTYPE;
    pReq->func_code = READ_PROP_VALUE_FUNC;
    pReq->length = SWAP(RVALSIZE);

    pReq->obj_type = SWAP(ObjectType);
    memset( pReq->obj_name, '\0', sizeof(pReq->obj_name));
    strcpy((PCHAR)pReq->obj_name+1, ObjectName );
    pReq->obj_name[0] = (UCHAR)(sizeof(pReq->obj_name)-1);
    pReq->seg_no = (UCHAR)SegmentNumber;
    memset( pReq->prop_name, '\0', sizeof(pReq->prop_name));
    strcpy((PCHAR)pReq->prop_name+1, PropertyName );
    pReq->prop_name[0] = (UCHAR)strlen(PropertyName);

    /* Send the request and wait for response */
    iRet = NcpTransaction(sizeof(RVALREQ));

    /* If OK set output parameter values from the response packet */
    if ( iRet != SOCKET_ERROR )
        {
        pRsp = (RVALRSP *) nsStatus.RcvBuffer;
        if ( pRsp->hdr.ret_code == 0 )
            {
            *MoreSegments = pRsp->more_flag;
            *PropertyFlags = pRsp->prop_flags;
            memcpy( PropertyValue, pRsp->prop_value, sizeof(pRsp->prop_value));
            }

        return((USHORT)pRsp->hdr.ret_code);
        }

    return(BINDERY_FAILURE);
}


int
NcpTransaction(
    int iSize
    )
{
/*++

Routine Description:

    Send an NCP request to the active file server and wait for a response.
    Most necessary data has been stored in the nsStatus structure by
    the caller.

Arguments:

    iSize - size of buffer to send.

Return Value:

    SOCKET_ERROR if the fn failed,
    anything else if successful

--*/

    NCPRSP * pRsp;
    SOCKADDR_IPX SockAddr;
    int SockAddrLength;
    int Bytes;
    int Attempts = 0;

    /* Send the packet and retry three times if the response doesn't */
    /* arrive within the specified timeout                           */

    SockAddrLength = sizeof(SOCKADDR_IPX);
    pRsp = (NCPRSP *) nsStatus.RcvBuffer;

    do
        {
        if (SOCKET_ERROR == sendto( nsStatus.s,
                                    (char *) nsStatus.nhHeader,
                                    iSize,
                                    0,
                                    (SOCKADDR *) &nsStatus.nsRemote[nsStatus.ActiveServer],
                                    sizeof(SOCKADDR_IPX)
                                    ))
            {
            return SOCKET_ERROR;
            }

irrelevant_packet:

        Bytes = recvfrom( nsStatus.s,
                         nsStatus.RcvBuffer,
                         BUFFER_SIZE,
                         0,
                         (SOCKADDR *) &SockAddr,
                         &SockAddrLength
                         );

        //
        // If we get a packet, compare the source address and sequence #.
        // We also compare the connection number except on the initial
        // connection request.
        //
        if (Bytes != SOCKET_ERROR)
            {
            if (0 != memcmp(SockAddr.sa_nodenum,
                            nsStatus.nsRemote[nsStatus.ActiveServer].sa_nodenum,
                            6))
                {
                goto irrelevant_packet;
                }

            if (0 != memcmp(SockAddr.sa_netnum,
                            nsStatus.nsRemote[nsStatus.ActiveServer].sa_netnum,
                            4))
                {
                goto irrelevant_packet;
                }

            if (nsStatus.nhHeader->req_type != CREATE_CONN_REQTYPE)
                {
                if (pRsp->conn_no_low != nsStatus.nhHeader->conn_no_low ||
                    pRsp->conn_no_high != nsStatus.nhHeader->conn_no_high)
                    {
                    goto irrelevant_packet;
                    }
                }

            if (pRsp->seq_no != nsStatus.nhHeader->seq_no )
                {
                goto irrelevant_packet;
                }
            }
        }
    while ( Bytes == SOCKET_ERROR && WSAGetLastError() == WSAETIMEDOUT && ++Attempts < 3 );

    return Bytes;
}


CRITICAL_SECTION_WRAPPER FileServerMutex;

BOOL fCsnwCheckCompleted  = FALSE;
BOOL fCsnwInstalled       = FALSE;

DWORD
GetCsnwStatus(
    LPSERVICE_STATUS pServiceStatus
    )
{
    SC_HANDLE ServiceController;
    SC_HANDLE Csnw;
    DWORD status;

    ServiceController = OpenSCManager (NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (NULL == ServiceController)
        {
        return GetLastError();
        }

    Csnw = OpenService(ServiceController, L"NWCWorkstation", SERVICE_QUERY_STATUS);
    
    status = GetLastError();

    CloseServiceHandle(ServiceController);

    if (NULL == Csnw)
        {
        return(status);
        }

    if (FALSE == QueryServiceStatus(Csnw, pServiceStatus))
        {
        status = GetLastError();
        }
    else
        {
        status = 0;
        }

    CloseServiceHandle(Csnw);

    return status;
}


void
CheckForCsnw(
    )
/*++

Routine Description:

   Asks the service controller whether Client Services for Netware is installed.

Arguments:

    none

Return Value:

    no explicit return value

    updates fKnowCsnwInstallState and fCsnwInstalled

--*/

{
    DWORD Status;
    SERVICE_STATUS ServiceStatus;

    Status = GetCsnwStatus(&ServiceStatus);

    if (Status && Status != ERROR_SERVICE_DOES_NOT_EXIST)
        {
        return;
        }

    if (!Status)
        {
        if (ServiceStatus.dwCurrentState == SERVICE_RUNNING          ||
            ServiceStatus.dwCurrentState == SERVICE_START_PENDING    ||
            ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING )
            {
            fCsnwInstalled = TRUE;
            }
        }

    fCsnwCheckCompleted  = TRUE;
}


struct
{
    PCHAR        Name;
    SOCKADDR_IPX Address;
    unsigned     Time;
}
ServerCache[CACHE_SIZE];

CRITICAL_SECTION_WRAPPER CacheMutex;

RPC_STATUS
InitializeIpxNameCache(
    )
{
    static BOOL fInitialized = FALSE;

    if (fInitialized)
        {
        return(RPC_S_OK);
        }

    RPC_STATUS Status;
    PVOID Buffer0, Buffer1;

    Buffer0 = I_RpcAllocate(1024);
    if (Buffer0 == NULL)
        return(RPC_S_OUT_OF_MEMORY);

    Buffer1 = I_RpcAllocate(1024);
    if (Buffer1 == NULL)
        {
        I_RpcFree(Buffer0);
        return(RPC_S_OUT_OF_MEMORY);
        }

    Status = InitializeCriticalSectionWrapper(&CacheMutex);

    if (!Status)
        {
        Status = InitializeCriticalSectionWrapper(&FileServerMutex);

        if (Status)
            {
            DeleteCriticalSectionWrapper(&CacheMutex);
            }
        }

    if (Status)
        {
        I_RpcFree(Buffer0);
        I_RpcFree(Buffer1);
        return(Status);
        }

    nsStatus.nhHeader = (NCPHDR *)Buffer0;
    nsStatus.RcvBuffer = (PCHAR) Buffer1;
    
    ASSERT(nsStatus.ServerCount == 0);
    ASSERT(nsStatus.s == 0);

    ASSERT(!fInitialized);
    fInitialized = TRUE;

    return Status;
}


RPC_STATUS
AddServerToCache(
    IN char  * Name,
    IN SOCKADDR_IPX * Address
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return Status;
        }

    //
    // Check if the name is already in the cache, we might be re-resolving
    // the name or another thread might have put the name in the cache
    // since we last checked.
    //
    for (i=0; i < CACHE_SIZE; ++i)
        {
        if (     ServerCache[i].Name &&
            0 == RpcpStringCompareA(ServerCache[i].Name, Name))
            {
            // Check if entry already matches our address.
            if (   memcmp(Address->sa_netnum, ServerCache[i].Address.sa_netnum, 4)
                || memcmp(Address->sa_nodenum, ServerCache[i].Address.sa_nodenum, 6))
                {
                // New information, update cache.
                memcpy(&ServerCache[i].Address, Address, sizeof(SOCKADDR_IPX));
                Status = RPC_S_OK;
                }
            else
                {
                Status = RPC_P_MATCHED_CACHE;
                }
            LeaveCriticalSectionWrapper(&CacheMutex);
            return(Status);
            }
        }

    //
    // If it is not in the table, try to find an empty entry to fill.
    //
    if (i == CACHE_SIZE)
        {
        for (i=0; i < CACHE_SIZE; ++i)
            {
            if (ServerCache[i].Name == 0)
                {
                break;
                }
            }
        }

    //
    // If all entries are full, overwrite the oldest one.
    //
    if (i == CACHE_SIZE)
        {
        unsigned BestIndex = 0;
        LONG now = GetTickCount();
        LONG BestDiff = now - ServerCache[0].Time;

        ASSERT(CACHE_SIZE > 1);

        for (i = 1; i < CACHE_SIZE; ++i)
            {
            LONG diff = now - ServerCache[i].Time;
            if (diff > BestDiff)
                {
                BestIndex = i;
                BestDiff = diff;
                }
            }

        i = BestIndex;
        }

    //
    // Update the entry's information.
    //

    ASSERT(strlen(Name) <= IPX_MAXIMUM_PRETTY_NAME);

    if (NULL == ServerCache[i].Name)
        {
        ServerCache[i].Name = new CHAR[IPX_MAXIMUM_PRETTY_NAME + 1];
        }

    if (ServerCache[i].Name)
        {
        strcpy(ServerCache[i].Name, Name);
        memcpy(&ServerCache[i].Address, Address, sizeof(SOCKADDR_IPX));

        ServerCache[i].Time = GetTickCount();

        Status = RPC_S_OK;
        }
    else
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return (Status);
}


BOOL
FindServerInCache(
    char  * Name,
    SOCKADDR_IPX * Address,
    unsigned * Time
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return FALSE;
        }

    for (i = 0; i < CACHE_SIZE; ++i)
        {
        if (   ServerCache[i].Name 
            && (0 == RpcpStringCompareA(ServerCache[i].Name, Name)) )
            {
            memcpy(Address, &ServerCache[i].Address, sizeof(SOCKADDR_IPX));
            *Time = ServerCache[i].Time;

            LeaveCriticalSectionWrapper(&CacheMutex);

            return TRUE;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return FALSE;
}


BOOL
CachedServerNotContacted(
    char  * Name
    )
{
    unsigned i;
    BOOL Flushed = FALSE;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return Flushed;
        }

    for (i=0; i < CACHE_SIZE; ++i)
        {
        if (   ServerCache[i].Name
            && 0 == RpcpStringCompareA(ServerCache[i].Name, Name))
            {
            if (GetTickCount() - ServerCache[i].Time > CACHE_EXPIRATION_TIME)
                {
                delete ServerCache[i].Name;
                ServerCache[i].Name = 0;
                Flushed = TRUE;
                }

            break;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);

    return Flushed;
}

void
CachedServerContacted(
    char  * Name
    )
{
    unsigned i;
    RPC_STATUS Status;

    Status = EnterCriticalSectionWrapper(&CacheMutex);
    if (Status)
        {
        return;
        }

    for (i=0; i < CACHE_SIZE; ++i)
        {
        if (   ServerCache[i].Name
            && 0 == RpcpStringCompareA(ServerCache[i].Name, Name))
            {
            ServerCache[i].Time = GetTickCount();
            break;
            }
        }

    LeaveCriticalSectionWrapper(&CacheMutex);
}


RPC_STATUS
LookupViaRnr(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    CSADDR_BUFFER csaddr[2];
    int           num;
    INT           protocol_list[2];
    DWORD         csaddr_size = sizeof(csaddr);

    protocol_list[0] = NSPROTO_IPX ;
    protocol_list[1] = 0;
    num = GetAddressByNameA(NS_SAP,
                            (GUID *)&SERVICE_TYPE,
                            Name,
                            protocol_list,
                            0,
                            FALSE,
                            &csaddr,
                            &csaddr_size,
                            NULL,
                            0);
    if (num <= 0)
        {
        return RPC_S_SERVER_UNAVAILABLE;
        }

    memcpy( Address, csaddr[0].info.RemoteAddr.lpSockaddr, sizeof(SOCKADDR_IPX) );
    
    return(AddServerToCache(Name, Address));
}


RPC_STATUS
LookupViaBindery(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    USHORT      Connection;
    USHORT      NwStatus;
    UCHAR       MoreSegments;
    UCHAR       PropertyFlags;
    UCHAR       buffer[128];

    RPC_STATUS  Status;

    Status = EnterCriticalSectionWrapper(&FileServerMutex);
    if (Status)
        {
        return Status;
        }

    //
    // Find a Netware server and connect to it.
    //
    if (FALSE == AttachToFileServer())
        {
        LeaveCriticalSectionWrapper(&FileServerMutex);

        return RPC_S_SERVER_UNAVAILABLE;
        }

    //
    // Read from the bindery.
    //
    NwStatus = ReadPropertyValue( Name,
                                  RPC_SAP_TYPE,
                                  "NET_ADDRESS",
                                  1,
                                  buffer,
                                  &MoreSegments,
                                  &PropertyFlags
                                  );

    //
    // Disconnect from the file server.
    //
    DetachFromActiveServer();

    LeaveCriticalSectionWrapper(&FileServerMutex);

    if (!NwStatus)
        {
        memcpy(&Address->sa_netnum, buffer, 12);
        return(AddServerToCache(Name, Address));
        }

    return RPC_S_SERVER_UNAVAILABLE;
}


RPC_STATUS
IpxNameToAddress(
    char *          Name,
    SOCKADDR_IPX  * Address,
    unsigned        Timeout
    )
{
    RPC_STATUS Status = RPC_S_OK;

    Status = EnterCriticalSectionWrapper(&FileServerMutex);
    if (Status)
        {
        return Status;
        }

    if (!fCsnwCheckCompleted)
        {
        CheckForCsnw();
        }

    LeaveCriticalSectionWrapper(&FileServerMutex);

    if (fCsnwInstalled)
        {
        Status = LookupViaRnr(Name, Address, Timeout);
        }
    else
        {
        Status = LookupViaBindery(Name, Address, Timeout);
        if (   Status != RPC_S_OK
            && Status != RPC_P_MATCHED_CACHE)
            {
            Status = LookupViaRnr(Name, Address, Timeout);
            }
        }

    return Status;
}

void IPX_AddressToName(
   IN SOCKADDR_IPX *pAddr,
   OUT RPC_CHAR *pName
)
/*++

Routine Description:

    Converts a raw IPX address into the string address format used
    by RPC.
    
    ~NNNNNNNNAAAAAAAAAAAA
    N - network number in hex
    A - network address (IEEE 802) in hex

Arguments:

    pAddr - The sockaddr containing the address to convert
    pName - Will contain the string address on return, assumed
        to be IPX_MAXIMUM_RAW_NAME characters.

Return Value:

    None

--*/
{
    int i;

    *pName++ = '~';
    for (i = 0; i < sizeof(pAddr->sa_netnum); i++)
        {
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_netnum[i]) >> 4 ];
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_netnum[i]) & 0x0F ];
        }
    for (i = 0; i < sizeof(pAddr->sa_nodenum); i++)
        {
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_nodenum[i]) >> 4 ];
        *pName++ = HexDigits[ (UCHAR)(pAddr->sa_nodenum[i]) & 0x0F ];
        }
    *pName = 0;
}


RPC_STATUS
IPX_NameToAddress(
    RPC_CHAR *Name,
    BOOL fUseCache,
    OUT SOCKADDR_IPX *pAddr
    )
/*++

Routine Description:

    Converts a name into an IPX address if possible.  Handles the
    case of ~ names and pretty names.

Arguments:

    Name - The name to convert
    fUseCache - Usually TRUE, if which case a value cached from
        a previous call with the same name maybe used.  If FALSE,
        then full name resolution must be used.
    pAddr - Will overwrite the sa_netnum and sa_nodenum with the
        IPX address if successful.

Return Value:

    RPC_S_OK - Full lookup, completed ok.
    RPC_S_FOUND_IN_CACHE - Lookup completed and found in cache.
    RPC_S_MATCHED_CACHE - Full lookup required (fUseCache == FALSE) but
        results didn't change.
        
    RPC_S_SERVER_UNAVAILABLE - Lookup failed.
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    int length;

    ASSERT(pAddr->sa_family == AF_IPX);
    ASSERT(pAddr->sa_socket == 0);

    //
    // First see if the address is local.
    //
    if (Name == 0 || *Name == 0)
        {
        //
        // Use the cached local address, if valid.
        //
        if (fIpxAddrValid == TRUE)
            {
            memcpy(pAddr->sa_netnum, IpxAddr.sa_netnum, 4);
            memcpy(pAddr->sa_nodenum, IpxAddr.sa_nodenum, 6);
            return(RPC_S_OK);
            }

        //
        // Figure out the loopback address, not a easy task on IPX.
        //

        SOCKET sock;
        sock = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
        if (sock == INVALID_SOCKET)
            {
            //
            switch(GetLastError())
                {
                case WSAEAFNOSUPPORT:
                case WSAEPROTONOSUPPORT:
                    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
                    break;

                case WSAENOBUFS:
                case WSAEMFILE:
                    return(RPC_S_OUT_OF_MEMORY);
                    break;

                default:    
                    ASSERT(0);
                    return(RPC_S_OUT_OF_MEMORY);
                    break;
                }
            }

        // zero-out the netnum and nodenum members
        memset(pAddr->sa_netnum, 0, sizeof(pAddr->sa_netnum));
        memset(pAddr->sa_nodenum, 0, sizeof(pAddr->sa_nodenum));

        if ( bind(sock, (PSOCKADDR)pAddr, sizeof(SOCKADDR_IPX)) == SOCKET_ERROR)
            {
            closesocket(sock);
            return(RPC_S_OUT_OF_RESOURCES);
            }
        int len = sizeof(SOCKADDR_IPX);
        if ( getsockname(sock, (PSOCKADDR)pAddr, &len) == SOCKET_ERROR)
            {
            closesocket(sock);
            return(RPC_S_OUT_OF_RESOURCES);
            }

        // Update cache
        memcpy(IpxAddr.sa_netnum, pAddr->sa_netnum, sizeof(IpxAddr.sa_netnum));
        memcpy(IpxAddr.sa_nodenum, pAddr->sa_nodenum, sizeof(IpxAddr.sa_nodenum));
        fIpxAddrValid = TRUE;

        closesocket(sock);

        return(RPC_S_OK);
        }

    //
    // Must resolve the name, validate and convert to ansi.
    //
    length = RpcpStringLength(Name) + 1;

    if (length > IPX_MAXIMUM_PRETTY_NAME)
        {
        return(RPC_S_SERVER_UNAVAILABLE);
        }

    if (   *Name == RPC_T('~')
        && length != IPX_MAXIMUM_RAW_NAME)
        {
        return(RPC_S_SERVER_UNAVAILABLE);
        }


    CHAR AnsiName[IPX_MAXIMUM_PRETTY_NAME + 1];
    PlatformToAnsi(Name, AnsiName);

    //
    // If the name starts with ~, convert it directly to a network address.
    //
    if (AnsiName[0] == '~')
        {

        ASSERT(Name[0] == RPC_T('~'));

        int i;
        PCHAR p = AnsiName;


        p++; // Skip ~

        for (i = 0; i < 4; i++)
            {
            pAddr->sa_netnum[i] = HexDigitsToBinary(*p, *(p+1));
            p += 2;
            }
        for (i = 0; i < 6; i++)
            {
            pAddr->sa_nodenum[i] = HexDigitsToBinary(*p, *(p+1));
            p += 2;
            }

        if (fUseCache)
            {
            return(RPC_S_OK);
            }
        else
            {
            return(RPC_P_MATCHED_CACHE);
            }
        }

    if (fUseCache)
        {
        UINT t = 0;
        //
        // Look up the server in the name cache.
        //
        if (FindServerInCache(AnsiName, pAddr, &t))
            {
            return(RPC_P_FOUND_IN_CACHE);
            }
        }

    //
    // Gotta go look for it.
    //

    RPC_STATUS status = IpxNameToAddress(AnsiName, pAddr, 0);

    if (   (status == RPC_P_MATCHED_CACHE)
        && fUseCache)
        {
        // Race - another thread added the name to the cache
        // while we did the lookup.
        return(RPC_S_OK);
        }

    return(status);
}

BOOL         fIpxAddrValid = FALSE;
SOCKADDR_IPX IpxAddr;    

RPC_STATUS
IPX_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    Use by both IPX and SPX RPC servers to build the network
    address structure to be returned to the RPC runtime.
    Before calling this the caller must make sure the global
    fIpxAddrValid is TRUE.

Arguments:

    ppAddressVector - The place to store the constructed address
        vector.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + gdwComputerNameLength * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (NULL == pVector)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR*)&pVector->NetworkAddresses[1];
    RpcpStringCopy(pVector->NetworkAddresses[0], gpstrComputerName);

    *ppAddressVector = pVector;

    return(RPC_S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\httpreg.cxx ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  httpreg.c
//
//    HTTP/RPC protocol specific functions.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#define  FD_SETSIZE  1

#include <precomp.hxx>


//-------------------------------------------------------------------------
//  HttpParseServerPort()
//
//  Parse strings of the form:  <svr>[:<port>]
//-------------------------------------------------------------------------
static BOOL HttpParseServerPort( IN  char *pszServerPort,
                                 IN  char *pszDefaultPort,
                                 OUT char *pszServer,
                                 OUT char *pszPort  )
{
   char  ch;
   char *psz;
   char *pszColon;

   if (pszColon=strchr(pszServerPort,':'))
      {
      *pszColon = 0;
      psz = pszColon;
      psz++;
      strcpy(pszServer,pszServerPort);
      *pszColon = ':';
      if (*psz)
         {
         strcpy(pszPort,psz);
         }
      else
         {
         strcpy(pszPort,pszDefaultPort);
         }
      }
   else
      {
      strcpy(pszServer,pszServerPort);
      strcpy(pszPort,pszDefaultPort);
      }

   return TRUE;
}

//-------------------------------------------------------------------------
//  HttpParseProxyName()
//
//-------------------------------------------------------------------------

const char *HttpProxyPrefix = "http://";
const int HttpProxyPrefixSize = sizeof("http://") - 1;

BOOL HttpParseProxyName( IN  char *pszProxyList,
                                OUT char *pszHttpProxy,
                                OUT char *pszHttpProxyPort )
{
   BOOL  fStatus;
   char *psz;
   char *pszSemiColon;
   int StringLength;

   strcpy(pszHttpProxy,"");
   strcpy(pszHttpProxyPort,"");

   // Check for no configured proxy:
   if ((!pszProxyList)||(!*pszProxyList))
      {
      return TRUE;
      }

   // if the string is large enough to contain the prefix, check
   // whether it has a prefix
   StringLength = strlen(pszProxyList);
   if (StringLength >= HttpProxyPrefixSize)
       {
       if (RpcpStringNCompareA(pszProxyList, HttpProxyPrefix, HttpProxyPrefixSize) == 0)
           pszProxyList += HttpProxyPrefixSize;
       }

   if (!strstr(pszProxyList,EQUALS_STR))
      {
      return HttpParseServerPort(pszProxyList,DEF_HTTP_PORT,pszHttpProxy,pszHttpProxyPort);
      }

   if (psz=strstr(pszProxyList,HTTP_EQUALS_STR))
      {
      psz += strlen(HTTP_EQUALS_STR);
      if (pszSemiColon=strstr(psz,SEMICOLON_STR))
         {
         *pszSemiColon = 0;
         fStatus = HttpParseServerPort(psz,DEF_HTTP_PORT,pszHttpProxy,pszHttpProxyPort);
         *pszSemiColon = CHAR_SEMICOLON;
         return fStatus;
         }
      else
         {
         return HttpParseServerPort(psz,DEF_HTTP_PORT,pszHttpProxy,pszHttpProxyPort);
         }
      }
   else
      {
      return TRUE;
      }
}

//-------------------------------------------------------------------------
//  HttpFreeProxyOverrideList()
//
//-------------------------------------------------------------------------
static void HttpFreeProxyOverrideList( IN char **ppszOverrideList )
{
   char **ppszTmp = ppszOverrideList;

   if (ppszOverrideList)
      {
      while (*ppszTmp)
         {
         I_RpcFree(*ppszTmp);
         ppszTmp++;
         }

      I_RpcFree(ppszOverrideList);
      }
}

//-------------------------------------------------------------------------
//  HttpParseProxyOverrideList()
//
//-------------------------------------------------------------------------
static char **HttpParseProxyOverrideList( IN char *pszProxyOverrideList )
{
   int    i;
   int    iLen;
   int    count = 1;
   DWORD  dwSize = 1+strlen(pszProxyOverrideList);
   char  *pszList;
   char  *psz;
   char **ppszPatternList;

   if (!dwSize)
      {
      return NULL;
      }

   // Make a local copy of the pattern list, to work with:
   pszList = (char *) alloca(dwSize);

   strcpy(pszList,pszProxyOverrideList);

   // See how many separate patterns ther are in the override list:
   //
   // NOTE: That count may be too high, if either the list contains
   //       double semicolons or the list ends with a semicolon. If
   //       either/both of these happen that's Ok.
   psz = pszList;
   while (psz=strstr(psz,";"))
      {
      count++;
      psz++;
      }

   ppszPatternList = (char**)RpcpFarAllocate( (1+count)*sizeof(char*) );
   if (!ppszPatternList)
      {
      // Out of memory.
      return NULL;
      }

   memset(ppszPatternList,0,(1+count)*sizeof(char*));

   i = 0;
   while (i<count)
      {
      if (!*pszList)
         {
         // End of list. This happens when the list contained empty
         // patterns.
         break;
         }

      psz = strstr(pszList,";");
      if (psz)
         {
         *psz = 0;

         if ( (iLen=strlen(pszList)) == 0)
            {
            // Zero length pattern.
            pszList = ++psz;
            continue;
            }

         ppszPatternList[i] = (char*)RpcpFarAllocate(1+iLen);
         if (!ppszPatternList[i])
            {
            HttpFreeProxyOverrideList(ppszPatternList);
            return NULL;
            }
         strcpy(ppszPatternList[i++],pszList);
         pszList = ++psz;
         }
      else
         {
         ppszPatternList[i] = (char*)RpcpFarAllocate(1+strlen(pszList));
         if (!ppszPatternList[i])
            {
            HttpFreeProxyOverrideList(ppszPatternList);
            return NULL;
            }
         strcpy(ppszPatternList[i++],pszList);
         }
      }

   return ppszPatternList;
}

//-------------------------------------------------------------------------
//  HttpCheckRegistry()
//
//  With IE and WinInet you can setup a list of proxies to use to go through
//  with an HTTP (or other) internet request. We need to support this as
//  well. There are three registry entries of interest, which are located
//  at:
//
//  \HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings
//
//  They are:
//
//  ProxyEnable: REG_BINARY
//     A flag (TRUE/FALSE) to enable/disable proxies.
//
//  ProxyServer: REG_SZ
//     On of: an empty string (no proxy specified), a single proxy server
//     name (for any format), or a list of proxy servers to use by format.
//     The list is of the form:
//
//     ftp=<svr:port>,gopher=<svr:port>,http=<svr:port>,...
//
//     Note that not all protocols need to be in the list. And the port#
//     does not need to be specifed. If not present then default the port#
//     to the default for that internet protocol (scheme).
//
//  ProxyOverride: REG_SZ
//     A semicolon separated list of server names, internet addresses or
//     patterns which, if specified are used to denote machines that you
//     want to directly access, without using the proxy server. Examples
//     would be:
//
//     12.34.56.78;MySvr*;111.222.*;*green*
//
//-------------------------------------------------------------------------
BOOL HttpCheckRegistry( IN  char  *pszServer,
                        OUT char **ppszHttpProxy,
                        OUT char **ppszHttpProxyPort,
                        OUT RPCProxyAccessType *AccessType
                        )
{
   int    i;
   long   lStatus;
   DWORD  dwType;
   DWORD  dwEnabled;
   DWORD  dwSize;
   HKEY   hKey;
   HKEY   hUserKey;
   char   szProxyList[256];
   char   szProxyOverrideList[256];
   char   szHttpProxy[MAX_HTTP_COMPUTERNAME_SIZE];
   char   szHttpProxyPort[MAX_HTTP_PORTSTRING_SIZE];
   char  *pszDotServer;
   char **ppszOverrideList;
   struct hostent UNALIGNED *pHostEnt;
   struct in_addr   ServerInAddr;
   BOOL LocalDirect;

   *ppszHttpProxy = NULL;
   *ppszHttpProxyPort = NULL;
   *AccessType = rpcpatDirect;

#if TRUE

   lStatus = RegOpenCurrentUser( KEY_READ, &hUserKey );

   if (lStatus != ERROR_SUCCESS)
      {
      return TRUE;
      }

    lStatus = RegOpenKeyEx( hUserKey,
                            REG_PROXY_PATH_STR,
                            0,
                            KEY_READ,
                            &hKey );

    RegCloseKey(hUserKey);

    if (lStatus != ERROR_SUCCESS)
        {
        return TRUE;
        }


#else

    HANDLE  hUserToken;
    HANDLE  hThread = GetCurrentThread(); // Note: don't need to CloseHandle().
    DWORD   dwStatus = 0;
    DWORD   dwSizeNeeded = 0;
    TOKEN_USER *pTokenData;

    //
    // First, try to get the access token from the thread, in case
    // we are impersonating.
    //
    if (!hThread)
       {
       dwStatus = GetLastError();
       return TRUE;
       }

    BOOL b = OpenThreadToken( hThread,
                              TOKEN_READ,
                              FALSE,      // Use context of the thread...
                              &hUserToken );
    if (!b)
       {
       dwStatus = GetLastError();
       if (dwStatus == ERROR_NO_TOKEN)
           {
           // If we get here, then the thread has no access token, so
           // try to get the process's access token.
           //
           HANDLE   hProcess = GetCurrentProcess();  // Never fails.

           dwStatus = NO_ERROR;
           b = OpenProcessToken(hProcess,
                                TOKEN_READ,
                                &hUserToken);
           if (!b)
               {
               dwStatus = GetLastError();
               }
           }
       }

    if (dwStatus)
       {
       #ifdef DBG_REGISTRY
       TransDbgPrint((DPFLTR_RPCPROXY_ID,
                      DPFLTR_WARNING_LEVEL,
                      "HttpCheckRegistry(): OpenThreadToken() Failed: %d\n",
                      dwStatus));
       #endif
       return TRUE;
       }

    GetTokenInformation( hUserToken,
                         TokenUser,
                         0,
                         0,
                         &dwSizeNeeded
                         );

    pTokenData = (TOKEN_USER*)_alloca(dwSizeNeeded);

    if (!GetTokenInformation( hUserToken,
                              TokenUser,
                              pTokenData,
                              dwSizeNeeded,
                              &dwSizeNeeded ))
        {
        CloseHandle(hUserToken);
        return TRUE;
        }

    CloseHandle(hUserToken);

    wchar_t UnicodeBuffer[256];      // Large enough....
    UNICODE_STRING UnicodeString;

    UnicodeString.Buffer        = UnicodeBuffer;
    UnicodeString.Length        = 0;
    UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

    NTSTATUS NtStatus;
    NtStatus = RtlConvertSidToUnicodeString( &UnicodeString,
                                             pTokenData->User.Sid,
                                             FALSE );
    if (!NT_SUCCESS(NtStatus))
        {
        return TRUE;
        }

    UnicodeString.Buffer[UnicodeString.Length] = 0;

    //
    // Open the user key (equivalent to HKCU).
    //
    lStatus = RegOpenKeyEx( HKEY_USERS,
                            UnicodeString.Buffer,
                            0,
                            KEY_READ,
                            &hUserKey );

    if (lStatus != ERROR_SUCCESS)
        {
        return TRUE;
        }

    lStatus = RegOpenKeyEx( hUserKey,
                            REG_PROXY_PATH_STR,
                            0,
                            KEY_READ,
                            &hKey );

    if (lStatus != ERROR_SUCCESS)
        {
        RegCloseKey(hUserKey);
        return TRUE;
        }

    RegCloseKey(hUserKey);

#endif

   dwSize = sizeof(dwEnabled);
   lStatus = RegQueryValueEx(
                 hKey,
                 REG_PROXY_ENABLE_STR,
                 0,
                 &dwType,
                 (LPBYTE)&dwEnabled,
                 &dwSize
                 );
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return TRUE;
      }

#ifdef DBG_REGISTRY
   if (dwType == REG_BINARY)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     "HttpCheckRegistry(): Proxy Enabled: %s\n",
                     (dwEnabled)? "TRUE" : "FALSE"));
      }
#endif // DBG_REGISTRY

   if (!dwEnabled)
      {
      // IE proxies are disabled, no need to go on.
      RegCloseKey(hKey);
      return TRUE;
      }

   dwSize = sizeof(szProxyList);
   lStatus = RegQueryValueExA(  // Needs to be ANSI
                 hKey,
                 REG_PROXY_SERVER_STR,
                 0,
                 &dwType,
                 (LPBYTE)szProxyList,
                 &dwSize
                 );
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return TRUE;
      }

#ifdef DBG_REGISTRY
   if (dwType == REG_SZ)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     "HttpCheckRegistry(): Proxy List: %s\n",
                     szProxyList));
      }
#endif // DBG_REGISTRY

   if (!HttpParseProxyName(szProxyList,szHttpProxy,szHttpProxyPort))
      {
      RegCloseKey(hKey);
      return TRUE;
      }

   dwSize = sizeof(szProxyOverrideList);
   lStatus = RegQueryValueExA(  // Needs to be ANSI
                 hKey,
                 REG_PROXY_OVERRIDE_STR,
                 0,
                 &dwType,
                 (LPBYTE)szProxyOverrideList,
                 &dwSize
                 );
   if (lStatus != ERROR_SUCCESS)
      {
      // Don't quit if the ProxyOverride entry is missing, that's Ok...
      szProxyOverrideList[0] = 0;
      }

#ifdef DBG_REGISTRY
   if (dwType == REG_SZ)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     "HttpCheckRegistry(): Proxy Override List: %s\n",
                     szProxyOverrideList));
      }
#endif // DBG_REGISTRY

   RegCloseKey(hKey);

   ppszOverrideList = HttpParseProxyOverrideList(szProxyOverrideList);

   if (ppszOverrideList)
      {
      LocalDirect = MatchExactList(
                           (unsigned char *) LOCAL_ADDRESSES_STR,
                           (unsigned char **) ppszOverrideList
                           );

      if (!LocalDirect)
          *AccessType = rpcpatHTTPProxy;
      else
          {
          // we don't know. <local> is in the list of overrides,
          // but we don't know whether the server is local
          *AccessType = rpcpatUnknown;
          }

      // Check the server name to see if it's in the override list:
      if (MatchREList(
             (unsigned char *) pszServer,
             (unsigned char **) ppszOverrideList
             ))
         {
         // The server name is in the override list.
         HttpFreeProxyOverrideList(ppszOverrideList);
         *AccessType = rpcpatDirect;
         return TRUE;
         }

      // Convert the server name to dot notation and see if its in
      // the override list:
      pHostEnt = gethostbyname(pszServer);
      if (pHostEnt)
         {
         // Note that the server may actually have several addresses in
         // a (NULL terminated) array. Need to check each one...
         i = 0;
         while (pHostEnt->h_addr_list[i])
            {
            memcpy(&ServerInAddr,pHostEnt->h_addr_list[i++],pHostEnt->h_length);
            pszDotServer = inet_ntoa(ServerInAddr);
#ifdef DBG_REGISTRY
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "HttpCheckRegistry(): Server: %s  Address: %s\n",
                           pszServer,
                           pszDotServer));
#endif // DBG_REGISTRY
            if (   (pszDotServer)
                && MatchREList(
                       (unsigned char *) pszDotServer,
                       (unsigned char **) ppszOverrideList
                       ) )
               {
               // The server name (in dot notation) is in the override list.
               HttpFreeProxyOverrideList(ppszOverrideList);
               *AccessType = rpcpatDirect;
               return TRUE;
               }
            }
         }

      HttpFreeProxyOverrideList(ppszOverrideList);
      }


   *ppszHttpProxy = (char *)RpcpFarAllocate(1+strlen(szHttpProxy));
   if (!*ppszHttpProxy)
      {
      return FALSE;
      }

   strcpy(*ppszHttpProxy,szHttpProxy);

   *ppszHttpProxyPort = (char*)RpcpFarAllocate(1+strlen(szHttpProxyPort));
   if (!*ppszHttpProxyPort)
      {
      I_RpcFree(*ppszHttpProxy);
      *ppszHttpProxy = NULL;
      return FALSE;
      }

   strcpy(*ppszHttpProxyPort,szHttpProxyPort);

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\httptran.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    httptran.cxx

Abstract:

    HTTP transport-specific functions.

Author:

    GopalP      06-25-97    Cloned from EdwardR's NT 4.0 RPC version.

Revision History:

    EdwardR     01-26-98    Rewrite NetworkOptions parsing.


--*/

#define  FD_SETSIZE  1

#include <precomp.hxx>

#include <CharConv.hxx>

#define  SPACE    ' '
#define  TAB      '\t'
#define  EQUALS   '='
#define  COMMA    ','
#define  COLON    ':'
#define  ZERO     '0'
#define  NINE     '9'

#define  KEYWORD_HTTPPROXY  "httpproxy"
#define  KEYWORD_RPCPROXY   "rpcproxy"

#define  KID_NONE            0
#define  KID_HTTPPROXY       1
#define  KID_RPCPROXY        2



//-------------------------------------------------------------
//  SkipWhiteSpace()
//
//  Routine Description:
//
//  Skip over spaces and tabs, return new string position.
//  Return NULL on end-of-string.
//-------------------------------------------------------------
inline static CHAR *SkipWhiteSpace( IN CHAR *psz )
    {
    if (psz)
        {
        while ((*psz)&&((*psz==SPACE)||(*psz==TAB))) psz++;

        if (!*psz)
            {
            psz = NULL;  // Return NULL on end-of-string.
            }
        }

    return psz;
    }



inline static char *
NextToken(
    IN char *psz
    )
/*++

Routine Description:

    This routine skips whitespace characters to the start of the
    next token in the string.

Arguments:

    psz - The string in question.

Return Value:

    NULL, if there is no next token.

    Pointer to the next token, otherwise.

--*/
{
    while ((*psz != CHAR_SPACE) &&
           (*psz != CHAR_TAB)   &&
           (*psz != CHAR_NL)    &&
           (*psz != CHAR_NUL))
        {
        psz++;
        }

    if ((*psz == CHAR_NL) || (*psz == CHAR_NUL))
        {
        return NULL;
        }

    psz = SkipWhiteSpace(psz);

    return psz;
}




inline unsigned int
HttpMessageLength(
    IN char *pBuffer
    )
/*++

--*/
{
    unsigned int len = 0;
    char *p = pBuffer;

    ASSERT(p);
    if (p == NULL)
        {
        return (0);
        }

    //
    // Look for a <CR><LF> sequence.
    //
    while ((*p     != CHAR_CR) &&
           (*(p+1) != CHAR_LF) &&
           (len <= MAX_HTTP_MESSAGE_LENGTH))
        {
        p++;
        len++;
        }

    return (len);
}




DWORD
HttpParseResponse(
    IN char *pBuffer
    )
/*++

Routine Description:

    This routine looks for a string of the form:
        HTTP/1.0 nnnn message_string
    Ex: "HTTP/1.0 200 Connection established"

Arguments:

    pBuffer - The response buffer.

Return Value:

    HTTP status code (nnnn), if successful.

    -1, if there is no next token yet.

     0, otherwise.

--*/
{
    DWORD  dwStatus = 0;
    char  *psz = pBuffer;

    psz = NextToken(psz);

    if (psz)
        {
        dwStatus = atoi(psz);
        }
    else
        {
        return (-1);
        }

    // Make sure a connection is established:
    if ( (dwStatus < 200) || (dwStatus > 299) )
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpParseResponse(): Connection Failed: %d\n",
                       dwStatus));
#endif // DBG
        dwStatus = 0;
        }

    return dwStatus;
}



//-------------------------------------------------------------
//  ParseLiteral()
//
//  Routine Description:
//
//  Check the next non-whitespace literal character to see if
//  its equal to cLiteral. If yes, the advance the string pointer
//  past it to the next character in the string. If no, then
//  return status set to RPC_S_INVALID_NETWORK_OPTIONS and return
//  the string pointer pointing to the invalid character.
//
//-------------------------------------------------------------
CHAR *ParseLiteral( IN  CHAR *psz,
                    IN  CHAR  cLiteral,
                    OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);

    if (psz)
        {
        if (*psz == cLiteral)
            {
            psz++;
            }
        else
            {
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            }
        }

    return psz;
    }


//-------------------------------------------------------------
//  ParsePort()
//
//  Routine Description:
//
//  Parse the next token as a "port-number", return its value
//  in the out parameter ppszPort.
//
//  Note: Use I_RpcFree() to release the memory for ppszPort
//        when you are finished with it.
//-------------------------------------------------------------
CHAR *ParsePort( IN  CHAR  *psz,
                 OUT CHAR **ppszPort,
                 OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);
    if (psz)
        {
        CHAR *p = psz;
        while ((*p >= ZERO) && (*p <= NINE))
            {
            p++;
            }

        if (p == psz)
            {
            // The next token isn't a number...
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            return psz;
            }

        CHAR cSave = *p;
        *p = 0;
        *ppszPort = (CHAR*)RpcpFarAllocate(1+strlen(psz));
        if (!*ppszPort)
            {
            *p = cSave;
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            return psz;
            }
        strcpy(*ppszPort,psz);
        *p = cSave;
        psz = p;
        }

    return psz;
    }


//-------------------------------------------------------------
//  ParseMachine()
//
//  Routine Description:
//
//  Parse the next token as a machine name. The machine name
//  is returned in ppszMachine, and psz is advance to point to
//  the next character after the machine name.
//
//  Note: That the machine name cannot contain any of ':' (colon),
//        ',' (comma), or ' ' (space). These are used in finding
//        the end of the machine name sub-string.
//
//  Note: Use I_RpcFree() to release the memory for ppszMachine
//        when you are finished with it.
//-------------------------------------------------------------
CHAR *ParseMachine( IN  CHAR  *psz,
                    OUT CHAR **ppszMachine,
                    OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);
    if (psz)
        {
        CHAR *p = psz;
        while ((*p) && (*p != COLON) && (*p != COMMA) && (*p != SPACE))
            {
            p++;
            }

        if (p == psz)
            {
            // zero length machine name...
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            return psz;
            }

        CHAR cSave = *p;
        *p = 0;
        *ppszMachine = (CHAR*)RpcpFarAllocate(1+strlen(psz));
        if (!*ppszMachine)
            {
            *p = cSave;
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            return psz;
            }

        strcpy(*ppszMachine,psz);
        *p = cSave;
        psz = p;
        }
    else
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        }

    return psz;
    }


//-------------------------------------------------------------
//  KeywordMatch()
//
//  Routine Description:
//
//  Compare the starting characters of the string (psz) with
//  the specified keyword (pszKeyword). If they match independent
//  of case, then return TRUE. If they don't match, return FALSE.
//-------------------------------------------------------------
BOOL KeywordMatch( CHAR *psz,
                   CHAR *pszKeyword )
    {
    DWORD dwLen1 = strlen( (char*)psz);
    DWORD dwLen2 = strlen( (char*)pszKeyword);
    BOOL  fMatch;

    if (dwLen1 < dwLen2)
        {
        return FALSE;    // String is not long enough to hold
        }                // the keyword.

    CHAR cSave = psz[dwLen2];
    psz[dwLen2] = 0;

    if (!RpcpStringCompareA((char*)psz,(char*)pszKeyword))
        {
        // Keyword matches the start of the string.
        fMatch = TRUE;
        }
    else
        {
        // Not a match.
        fMatch = FALSE;
        }

    psz[dwLen2] = cSave;
    return fMatch;
    }


//-------------------------------------------------------------
//  ParseKeyword()
//
//  Routine Description:
//
//  Parse the next token as a keyword, return its keyword ID
//  in pdwKid. There are currently two keywords to look for
//  "HttpProxy" (ID is KID_HTTPPROXY) and "RpcProxy" (ID is
//  KID_RPCPROXY). If the next text token doesn't match either
//  of these, then return KID_NONE (no match) and status is
//  returned as RPC_S_INVALID_NETWORK_OPTIONS.
//
//  If there is a match return the string pointer (psz) updated
//  to point to the next character after the end of the keyword.
//-------------------------------------------------------------
CHAR *ParseKeyword( IN  CHAR  *psz,
                    OUT DWORD *pdwKid,
                    OUT DWORD *pdwStatus )
    {
    psz = SkipWhiteSpace(psz);
    if (psz)
        {
        if (KeywordMatch(psz,(CHAR*)KEYWORD_HTTPPROXY))
            {
            // Keyword is "HttpProxy".
            *pdwKid = KID_HTTPPROXY;
            psz += strlen(KEYWORD_HTTPPROXY);
            }
        else if (KeywordMatch(psz,(CHAR*)KEYWORD_RPCPROXY))
            {
            // Keyword is "RpcProxy".
            *pdwKid = KID_RPCPROXY;
            psz += strlen(KEYWORD_RPCPROXY);
            }
        else
            {
            *pdwKid = KID_NONE;
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            }
        }

    return psz;
    }

//-------------------------------------------------------------
//  ParseOptValue()
//
//  Routine Description:
//
//  Parse strings of the following form:
//
//     OptValue <- machine ':' port
//              <- machine
//
//  If the parse is successful, then return the machine name
//  in ppszProxy, and the port in ppszPort. These are both new
//  strings allocated via RpcpFarAllocate().
//
//  The production ends with either the end of the string (null
//  terminated), the end of the port number (non-digit), or a
//  comma (which will start the begining of a new OptValue string.
//
//  On successful parse, return updated string position to the
//  next character after the end of the OptValue sub-string.
//-------------------------------------------------------------
CHAR *ParseOptValue( IN  CHAR  *psz,
                     OUT CHAR **ppszProxy,
                     OUT CHAR **ppszPort,
                     OUT DWORD *pdwStatus )
    {
    //
    // Get the machine name:
    //
    psz = ParseMachine(psz,ppszProxy,pdwStatus);
    if (*pdwStatus != NO_ERROR)
        {
        return psz;
        }

    //
    // If we're at the end of the string, or we've run into a
    // comma (start of another option) then we are done.
    //
    if ((!psz) || (*psz == 0) || (*psz == COMMA))
        {
        return psz;
        }

    psz = ParseLiteral(psz,COLON,pdwStatus);
    if (*pdwStatus != NO_ERROR)
        {
        return psz;
        }

    if (!psz)
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        return psz;
        }

    psz = ParsePort(psz,ppszPort,pdwStatus);

    return psz;
    }


//-------------------------------------------------------------
//  ParseOpt()
//
//  Routine Description:
//
//      Opt <- Keyword '=' OptValue
//
//  Parse an option, which is a keywork equals value pair.
//
//  If the parse is successful, then return the machine name
//  in ppszProxy, and the port in ppszPort. These are both new
//  strings allocated via RpcpFarAllocate(), and are represented
//  in the OptValue non-terminal.
//
//  The production ends with either the end of the string (null
//  terminated), the end of the port number (non-digit), or a
//  comma (which will start the begining of a new Opt string.
//
//  On successful parse, return updated string position to the
//  next character after the end of the Opt (option) sub-string.
//-------------------------------------------------------------
CHAR *ParseOpt( IN  CHAR  *psz,
                OUT DWORD *pdwKid,
                OUT CHAR **ppszProxy,
                OUT CHAR **ppszPort,
                OUT DWORD *pdwStatus )
    {
    if (psz)
        {
        psz = ParseKeyword(psz,pdwKid,pdwStatus);
        if (*pdwStatus != NO_ERROR)
            {
            return psz;
            }
        }

    if (!psz)
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        return psz;
        }

    psz = ParseLiteral(psz,EQUALS,pdwStatus);
    if (*pdwStatus != NO_ERROR)
        {
        return psz;
        }

    if (!psz)
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        return psz;
        }

    psz = ParseOptValue(psz,ppszProxy,ppszPort,pdwStatus);

    if ((psz) && (*psz == 0))
        {
        psz = NULL;
        }

    return psz;
    }


//-------------------------------------------------------------
//  ParseOptList()
//
//  Routine Description:
//
//  Parse ncacn_http network options strings. These are of the
//  following form:
//
//  OptList <- Opt
//          <- Opt ',' Opt
//
//  Opt <- Keyword '=' OptValue
//
//  OptValue <- Machine ':' PortNumber
//           <- Machine ':'
//           <- Machine
//
//  Keyword <- 'HttpProxy'
//          <- 'RpcProxy'
//
//  Machine and PortNumber are terminal strings.
//-------------------------------------------------------------
DWORD ParseOptList( IN  CHAR  *pszOptList,
                    OUT CHAR **ppszRpcProxy,
                    OUT CHAR **ppszRpcProxyPort,
                    OUT CHAR **ppszHttpProxy,
                    OUT CHAR **ppszHttpProxyPort )
    {
    DWORD  dwStatus = NO_ERROR;
    DWORD  dwKid = KID_NONE;
    CHAR  *psz = pszOptList;
    CHAR  *pszProxy = NULL;
    CHAR  *pszPort = NULL;

    psz = ParseOpt(psz,&dwKid,&pszProxy,&pszPort,&dwStatus);
    if (dwStatus != NO_ERROR)
        {
        return dwStatus;
        }

    if (dwKid == KID_RPCPROXY)
        {
        *ppszRpcProxy = pszProxy;
        *ppszRpcProxyPort = pszPort;
        }
    else if (dwKid == KID_HTTPPROXY)
        {
        *ppszHttpProxy = pszProxy;
        *ppszHttpProxyPort = pszPort;
        }

    if (psz)
        {
        psz = ParseLiteral(psz,COMMA,&dwStatus);
        if (dwStatus != NO_ERROR)
            {
            return dwStatus;
            }
        }

    if (psz)
        {
        pszProxy = pszPort = NULL;
        psz = ParseOpt(psz,&dwKid,&pszProxy,&pszPort,&dwStatus);
        if (dwStatus != NO_ERROR)
            {
            return dwStatus;
            }

        if (dwKid == KID_RPCPROXY)
            {
            *ppszRpcProxy = pszProxy;
            *ppszRpcProxyPort = pszPort;
            }
        else if (dwKid == KID_HTTPPROXY)
            {
            *ppszHttpProxy = pszProxy;
            *ppszHttpProxyPort = pszPort;
            }
        }

    psz = SkipWhiteSpace(psz);

    if (psz)
        {
        dwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        }

    return dwStatus;
    }




BOOL
HttpParseNetworkOptions(
    IN RPC_CHAR *pNetworkOptions,
    IN char *pszDefaultServer,
    OUT char **ppszRpcProxy,
    OUT char **ppszRpcProxyPort,
    IN BOOL UseSSLProxyPortAsDefault,
    OUT char **ppszHttpProxy,
    OUT char **ppszHttpProxyPort,
    OUT RPCProxyAccessType *AccessType,
    OUT DWORD *pdwStatus
    )
/*++

Routine Description:

    Parse the Http network options specified in the string binding. The
    options would look like:

        HttpProxy=<Server_Name>:<Port>,RpcProxy=<Server_Name>:<Port>

    That is, two separate proxy servers, each with an optional port.

    The HttpProxy=<> specification is optional, if not specified then use
    the specified default server name. Its default Port is 80.

    If RpcProxy is optional as well, if not specified then use the
    default server name and Port 80.

Arguments:

    pNetworkOptions  - Network options string

    pszDefaultServer - Default Server.

    ppszRpcProxy     - RpcProxy, if specified in the options string.

    ppszRpcProxyPort - RpcProxyPort, if specified in the options string.

    UseSSLProxyPortAsDefault - if non-zero, the SSL port will be used as
        default if a port is not specified in the network options.

    ppszHttpProxy    - HttpProxy, if specified in the options string.

    ppszHttpProxyPort- HttpProxyPort, if specified in the options string.

    AccessType       - if we should try direct access, proxy access, or unknown yet.

    pdwStatus - Pointer to a DWORD where the return status will be put.

Notes:

    Returned strings should be free'd with I_RpcFree().

Return Value:

    TRUE, if successful.

    FALSE, otherwise. *pdwStatus will have the exact cause.

--*/
{
    char   szNetworkOptions[MAX_NETWORK_OPTIONS_SIZE];
    char  *pszNetworkOptions;
    char *DefaultRpcProxyPortToUse;

    // OUT variable initialization.
    *ppszRpcProxy = *ppszRpcProxyPort = NULL;
    *ppszHttpProxy = *ppszHttpProxyPort = NULL;
    *AccessType = rpcpatUnknown;
    *pdwStatus = 0;

    // Make sure we have and options string to parse:
    if ( (pNetworkOptions) && (*pNetworkOptions) )
        {
        // Make sure the Network Options is not too long.
        if (RpcpStringLength(pNetworkOptions) > MAX_NETWORK_OPTIONS_SIZE)
            {
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            goto Cleanup;
            }

        // Convert it to ANSI, since HTTP is ANSI (actually ASCII I think...):
		SimplePlatformToAnsi(pNetworkOptions, szNetworkOptions);

        //
        // Parse out the options:
        //
        pszNetworkOptions = szNetworkOptions;

        *pdwStatus = ParseOptList(pszNetworkOptions,
                                  ppszRpcProxy,
                                  ppszRpcProxyPort,
                                  ppszHttpProxy,
                                  ppszHttpProxyPort );
        if (*pdwStatus != RPC_S_OK)
            {
            goto Cleanup;
            }

#if FALSE
        psz = RpcStrTok(pszNetworkOptions, ",", &pszNetworkOptions);
        if (!ParseKeywordEqValue(
                psz,
                HTTP_PROXY_OPTION_STR,
                ppszHttpProxy,
                ppszHttpProxyPort,
                pdwStatus
                ))
            {
            if (*pdwStatus != RPC_S_OK)
                {
                goto Cleanup;
                }
            }

        if (*ppszHttpProxy)
            {
            psz = RpcStrTok(NULL, ",", &pszNetworkOptions);
            }

        if (!ParseKeywordEqValue(
                psz,
                RPC_PROXY_OPTION_STR,
                ppszRpcProxy,
                ppszRpcProxyPort,
                pdwStatus
                ))
            {
            if (*pdwStatus != RPC_S_OK)
                {
                *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
                goto Cleanup;
                }
            }
#endif
        }

    // Make sure that we have an RPC Proxy (IIS machine):
    if (!*ppszRpcProxy)
        {
        *ppszRpcProxy = (char*)RpcpFarAllocate(1+strlen(pszDefaultServer));
        if (!*ppszRpcProxy)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }

        strcpy(*ppszRpcProxy, pszDefaultServer);
        }
    else
        {
        // Length validation for RpcProxy name.
        if (strlen(*ppszRpcProxy) > MAX_HTTP_COMPUTERNAME_SIZE)
            {
            *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
            goto Cleanup;
            }
        }

    // Make sure we have a port for the RPC Proxy.
    if (!*ppszRpcProxyPort)
        {
        if (UseSSLProxyPortAsDefault)
            DefaultRpcProxyPortToUse = DEF_HTTP_SSL_PORT;
        else
            DefaultRpcProxyPortToUse = DEF_HTTP_PORT;
        *ppszRpcProxyPort = (char*)RpcpFarAllocate(1+strlen(DefaultRpcProxyPortToUse));
        if (!*ppszRpcProxyPort)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }

        strcpy(*ppszRpcProxyPort, DefaultRpcProxyPortToUse);
        }

    // If no HTTP proxy was specified in the options string, check the
    // registry to see if IE has configured one:
    if (!*ppszHttpProxy)
        {
        if (!HttpCheckRegistry(
            *ppszRpcProxy,
            ppszHttpProxy,
            ppszHttpProxyPort,
            AccessType
            ) )
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }

    // Length validation for HttpProxy name.
    if ((*ppszHttpProxy) &&
        (strlen(*ppszHttpProxy) > MAX_HTTP_COMPUTERNAME_SIZE))
        {
        *pdwStatus = RPC_S_INVALID_NETWORK_OPTIONS;
        goto Cleanup;
        }

#ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "ParseNetworkOptions(): RpcProxy: %s  RpcProxyPort: %s\n",
                   *ppszRpcProxy,
                   *ppszRpcProxyPort));
#endif // MAJOR_DBG

    if (*AccessType != rpcpatDirect)
        {
        ASSERT(*ppszHttpProxy);
        }

    return TRUE;


Cleanup:

    if (*ppszRpcProxy)
        {
        I_RpcFree(*ppszRpcProxy);
         *ppszRpcProxy = NULL;
        }

    if (*ppszRpcProxyPort)
        {
        I_RpcFree(*ppszRpcProxyPort);
        *ppszRpcProxyPort = NULL;
        }

    if (*ppszHttpProxy)
        {
        I_RpcFree(*ppszHttpProxy);
        *ppszHttpProxy = NULL;
        }

    if (*ppszHttpProxyPort)
        {
        I_RpcFree(*ppszHttpProxyPort);
        *ppszHttpProxyPort = NULL;
        }

    return FALSE;
}




static BOOL
HttpSetupTunnel(
    IN SOCKET Socket,
    IN char *pszConnect
    )
/*++

Routine Description:

    Try to setup a connection to the IIS RPC Proxy.

Arguments:

    Socket - Socket on which to contact the IIS RPC Proxy.

    pszConnect - The message to send.

Return Value:

    TRUE, if successful

    FALSE, otherwise

--*/
{
    int   retval;
    DWORD dwStatus;
    DWORD dwSize;
    char szBuffer[MAX_HTTP_CHAT_BUFFER_SIZE];

    // Ok, try to connect to the IIS RPC proxy process:
    retval = send( Socket, pszConnect, 1+strlen(pszConnect), 0 );
    if (retval == SOCKET_ERROR)
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSetupTunnel(): send() failed: %d\n",
                       WSAGetLastError()));
#endif // DBG
        return FALSE;
        }

    dwSize = sizeof(szBuffer) - 1;
    retval = recv( Socket, szBuffer, dwSize, 0 );
    if ((retval == SOCKET_ERROR)||(retval == 0))
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSetupTunnel(): recv() failed: %d\n",
                       WSAGetLastError()));
#endif
        return FALSE;
        }

    szBuffer[dwSize] = 0;  // Note: dwSize is already sizeof()-1.

    dwStatus = HttpParseResponse(szBuffer);
#ifdef MAJOR_DBG
    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "HttpSetupTunnel(): response: %s",
                   szBuffer));
#endif

    // Make sure a connection is established:
    if ( (dwStatus < 200) || (dwStatus > 299) )
        {
#ifdef DBG
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSetupTunnel(): Connection Failed: %d\n",
                       dwStatus));
#endif
        return FALSE;
        }

    return TRUE;
}




inline BOOL
HttpTunnelToRpcProxy(
    IN SOCKET Socket,
    IN char *pszRpcProxy,
    IN char *pszRpcProxyPort
    )
/*++

Routine Description:

    This function is called to setup the HTTP chat to do a CONNECT
    through a proxy (like MSProxy). This will get you a tunnel to
    the IIS Server that you really want to get to. The call at the
    end, HttpSetupTunnel() does the connection.

Arguments:

    Socket - Socket on which to contact the IIS RPC Proxy.

    pszRpcProxy - The RPC Proxy to connect to.

    pszRpcProxyPort - RPC Proxy's port.

Return Value:

    Status from HttpSetupTunnel()

--*/
{
    char  szBuffer[MAX_HTTP_CHAT_BUFFER_SIZE];

    // make sure strings use \r\n instead of \n only. \n goes on the wire
    // as LF only, and some firewalls drop packets that use LF only
    strcpy(szBuffer, "CONNECT ");
    lstrcatA(szBuffer, pszRpcProxy);
    lstrcatA(szBuffer, ":");
    lstrcatA(szBuffer, pszRpcProxyPort);
    lstrcatA(szBuffer, " HTTP/1.0\r\nUser-Agent: RPC\r\nConnection: Keep-Alive\r\n\r\n");
    // Was:
    //
    // lstrcatA(szBuffer, " HTTP/1.1\nUser-Agent: RPC\nPragma: No-Cache\n\n");
    //
    // Some proxy servers (like MSProxy2.0 don't seem to like the version
    // number to be greater that 1.0.

    ASSERT(strlen(szBuffer) < MAX_HTTP_CHAT_BUFFER_SIZE);

    return HttpSetupTunnel(Socket, szBuffer);
}




inline BOOL
HttpTunnelToRpcServer(
    IN SOCKET Socket,
    IN char *pszRpcServer,
    IN char *pszRpcServerPort
    )
/*++

Routine Description:

    Open the socket to the IIS on which the RpcProxy resides.

Arguments:

    Socket - Socket on which to contact the IIS RPC Proxy.

    pszRpcServer - The RPC Server to connect to.

    pszRpcServerPort - RPC Server's port.

Return Value:

    Status from HttpSetupTunnel()

--*/
{
    int   retval;
    DWORD dwStatus;
    char  szBuffer[MAX_HTTP_CHAT_BUFFER_SIZE];

    strcpy(szBuffer, "RPC_CONNECT ");
    lstrcatA(szBuffer, pszRpcServer);
    lstrcatA(szBuffer, ":");
    lstrcatA(szBuffer, pszRpcServerPort);
    lstrcatA(szBuffer, " HTTP/1.1\nUser-Agent: RPC\nPragma: No-Cache\n\n");

    ASSERT(strlen(szBuffer) < MAX_HTTP_CHAT_BUFFER_SIZE);

    // Ok, try to connect to the RPC server process:
    return HttpSetupTunnel(Socket, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\muteximp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       muteximp.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File: muteximp.cxx

Description:

This file contains the system independent mutex class for NT.

History:

    kamenm - import (include) the mtrt version of mutex to avoid code cut
        and paste
-------------------------------------------------------------------- */

#include <precomp.hxx>

#include <mutex.cxx>

#define LogEvent(a,b,c,d,e,f,g)
#include <eventwrp.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\mq.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    mq.cxx

Abstract:

    This is the code that actually makes Falcon API calls. It is
    used by the Falcon/RPC transport (mqtrans.cxx)

Author:

    Edward Reus (edwardr)    05-Jul-1997

Revision History:

--*/

#include <precomp.hxx>
#include <trans.hxx>
#include <dgtrans.hxx>
#include <wswrap.hxx>
#include <rpc.h>
#include <rpcdce.h>
#include <mqmgr.h>
#include "mqtrans.hxx"

static HINSTANCE   g_hMqRt = 0;
FALCON_API *g_pMqApi = 0;
static CQueueMap  *g_pQueueMap = 0;

char placeHolder[sizeof(MUTEX)];    // provide placeholder for the mutex
MUTEX *gp_csContext = (MUTEX *)placeHolder;    // the mutex itself

#ifdef UNICODE
#define ptszVal     pwszVal
#define VT_LPTSTR   VT_LPWSTR
#else
#define ptszVal     pszVal
#define VT_LPTSTR   VT_LPSTR
#endif

static PCONTEXT_HANDLE       g_pContext = 0;

//  WARNING: the size and ordering of g_arszMqApis is dependent
//  on the definition of the FALCON_API structure in mqtrans.hxx
//  WARNING: When you are freeing Falcon allocated strings, do
//  *not* use MQFreeMemory. Use MQFreeStringFromProperty. Otherwise
//  you will break Win98 code.

const static char *g_arszMqApis[] = {
                                    "MQLocateBegin",
                                    "MQLocateNext",
                                    "MQLocateEnd",
                                    "MQInstanceToFormatName",
                                    "MQOpenQueue",
                                    "MQFreeMemory",
                                    "MQSendMessage",
                                    "MQReceiveMessage",
                                    "MQCloseQueue",
                                    "MQDeleteQueue",
                                    "MQPathNameToFormatName",
                                    "MQCreateQueue",
                                    "MQGetMachineProperties",
                                    "MQGetQueueProperties",
                                    "MQSetQueueProperties",
                                    NULL };

//  Error mappings for MQ_MapStatusCode():

typedef struct _STATUS_MAPPING
   {
   HRESULT    hr;
   RPC_STATUS status;
   } STATUS_MAPPING;

const static STATUS_MAPPING g_StatusMap[] =
   {
      { MQ_OK,                            RPC_S_OK },
      { MQ_ERROR_IO_TIMEOUT,              RPC_P_TIMEOUT },
      { MQ_ERROR_INSUFFICIENT_RESOURCES,  RPC_S_OUT_OF_MEMORY },
      { MQ_ERROR_QUEUE_NOT_FOUND,         RPC_S_SERVER_UNAVAILABLE },
      { MQ_ERROR,                         RPC_S_INTERNAL_ERROR },
      { MQMSG_CLASS_NACK_BAD_DST_Q,       RPC_S_SERVER_UNAVAILABLE },
      { MQMSG_CLASS_NACK_PURGED,          RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_Q_EXCEED_QUOTA,  RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_ACCESS_DENIED,   RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED,  RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_BAD_SIGNATURE,   RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_BAD_ENCRYPTION,  RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT,   RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q, RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG,RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_Q_DELETED,       RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_Q_PURGED,        RPC_S_CALL_FAILED_DNE },
      { MQMSG_CLASS_NACK_RECEIVE_TIMEOUT, RPC_S_CALL_FAILED_DNE },
      { MQ_ERROR_ILLEGAL_QUEUE_PATHNAME,  RPC_S_INVALID_ENDPOINT_FORMAT}
   };


//----------------------------------------------------------------
//  MQ_Initialize()
//
//  Called by DG_TransportLoad() to initialize the ncadg_mq
//  transport. This function does a dynamic load of the Falcon
//  runtime DLL (MQRT.DLL) and creates a call table to access
//  the Falcon API. If successful, return TRUE, else return
//  FALSE.
//----------------------------------------------------------------
BOOL
MQ_Initialize()
{
    BOOL   fStatus = TRUE;
    RPC_STATUS RpcStatus = RPC_S_OK;

    // Make sure the function count is correct...
    ASSERT( sizeof(g_arszMqApis)-sizeof(PVOID) == sizeof(FALCON_API) );

    //
    gp_csContext = new (gp_csContext) MUTEX(&RpcStatus);
    if (RpcStatus != RPC_S_OK)
        {
        return FALSE;
        }

    // Get the MSMQ runtime library:
    g_hMqRt = LoadLibrary(TEXT("mqrt.dll"));
    if (!g_hMqRt)
        {
        fStatus = FALSE;
        }

    // Build up the MSMQ call table that we will use to access
    // the MSMQ C API:
    if (fStatus)
        {
        g_pMqApi = (FALCON_API*)I_RpcAllocate(sizeof(FALCON_API));
        if (!g_pMqApi)
            {
            fStatus = FALSE;
            }
        }

    if (fStatus)
        {
        FARPROC *ppFn = (FARPROC*)g_pMqApi;
        int i = 0;

        while (g_arszMqApis[i])
            {
            *ppFn = GetProcAddress(g_hMqRt,g_arszMqApis[i++]);
            if (!*ppFn)
                {
                fStatus = FALSE;
                break;
                }

            ppFn++;
            }
        }

    if (fStatus)
        {
        g_pQueueMap = new CQueueMap;
        if (!g_pQueueMap)
            {
            fStatus = FALSE;
            }
        else
            {
            fStatus = g_pQueueMap->Initialize();
            }
        }

    if (!fStatus)
        {
        gp_csContext->Free();

        if (g_hMqRt)
            {
            FreeLibrary(g_hMqRt);
            g_hMqRt = 0;
            }

        if (g_pQueueMap)
            {
            delete g_pQueueMap;
            g_pQueueMap = 0;
            }

        if (g_pMqApi)
            {
            I_RpcFree(g_pMqApi);
            g_pMqApi = 0;
            }
        }

    return fStatus;
}

//----------------------------------------------------------------
//  MQ_MapStatusCode()
//
//  Convert a MQ HRESULT status to a RPC_STATUS code.
//----------------------------------------------------------------
RPC_STATUS MQ_MapStatusCode( HRESULT hr, RPC_STATUS defaultStatus )
{
   int         iSize = sizeof(g_StatusMap)/sizeof(STATUS_MAPPING);
   RPC_STATUS  status = defaultStatus;

   for (int i=0; i<iSize; i++)
      {
      if (hr == g_StatusMap[i].hr)
         {
         status = g_StatusMap[i].status;
         break;
         }
      }

   return status;
}

//----------------------------------------------------------------
//  MQ_InitOptions()
//
//  Initialize transport specific binding handle options structure.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_InitOptions( IN void PAPI *pvTransportOptions )
{
  RPC_STATUS  status = RPC_S_OK;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;

  if (pOpts)
     {
     memset(pOpts,0,sizeof(MQ_OPTIONS));
     pOpts->ulPriority = DEFAULT_PRIORITY;
     pOpts->ulTimeToReachQueue = INFINITE;
     pOpts->ulTimeToReceive = INFINITE;
     }
  else
     {
     status = RPC_S_OUT_OF_MEMORY;
     }

  return status;
}


//----------------------------------------------------------------
//  MQ_SetOption()
//
//  Set transport specific binding handle options.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_SetOption( IN void PAPI    *pvTransportOptions,
                                   IN unsigned long option,
                                   IN ULONG_PTR optionValue )
{
  RPC_STATUS  status =  RPC_S_OK;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;

  switch (option)
     {
     case RPC_C_OPT_MQ_DELIVERY:
        if (  (optionValue == RPC_C_MQ_EXPRESS)
           || (optionValue == RPC_C_MQ_RECOVERABLE) )
           pOpts->ulDelivery = (unsigned long) optionValue;
        else
           status = RPC_S_INVALID_ARG;
        break;

     case RPC_C_OPT_MQ_PRIORITY:
        if (optionValue <= MQ_MAX_PRIORITY)
           pOpts->ulPriority = (unsigned long) optionValue;
        else
           pOpts->ulPriority = MQ_MAX_PRIORITY;
        break;

     case RPC_C_OPT_MQ_JOURNAL:
        if (  (optionValue == RPC_C_MQ_JOURNAL_NONE)
           || (optionValue == RPC_C_MQ_JOURNAL_ALWAYS)
           || (optionValue == RPC_C_MQ_JOURNAL_DEADLETTER) )
           pOpts->ulJournaling = (unsigned long) optionValue;
        else
           status = RPC_S_INVALID_ARG;
        break;

     case RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE:
        pOpts->ulTimeToReachQueue = (unsigned long) optionValue;
        break;

     case RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED:
        pOpts->ulTimeToReceive = (unsigned long) optionValue;
        break;

     case RPC_C_OPT_MQ_ACKNOWLEDGE:
        pOpts->fAck = (optionValue != FALSE);
        break;

     case RPC_C_OPT_MQ_AUTHN_SERVICE:
        if (optionValue == RPC_C_AUTHN_MQ)
           {
           status = RPC_S_OK;
           }
        else if (optionValue == RPC_C_AUTHN_NONE)
           {
           pOpts->fAuthenticate = FALSE;
           pOpts->fEncrypt = FALSE;
           status = RPC_S_OK;
           }
        else
           {
           status = RPC_S_UNKNOWN_AUTHN_SERVICE;
           }
        break;

     case RPC_C_OPT_MQ_AUTHN_LEVEL:
        if (optionValue > RPC_C_AUTHN_LEVEL_NONE)
           {
           pOpts->fAuthenticate = TRUE;
           pOpts->fEncrypt = (optionValue == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)? TRUE : FALSE;
           }
        else
           {
           pOpts->fAuthenticate = FALSE;
           pOpts->fEncrypt = FALSE;
           }
        break;

     default:
        status = RPC_S_CANNOT_SUPPORT;
        break;
     }

  // The following is some code to make sure the RPC_C_xxx
  // constants always have the correct values:
  #if  ( (RPC_C_MQ_EXPRESS != MQMSG_DELIVERY_EXPRESS) \
       || (RPC_C_MQ_RECOVERABLE != MQMSG_DELIVERY_RECOVERABLE) )
  #error "RPC constants wrong"
  #endif

  #if (  (RPC_C_MQ_JOURNAL_NONE != MQMSG_JOURNAL_NONE)  \
      || (RPC_C_MQ_JOURNAL_ALWAYS != MQMSG_JOURNAL)     \
      || (RPC_C_MQ_JOURNAL_DEADLETTER != MQMSG_DEADLETTER) )
  #error "RPC constants wrong"
  #endif

  return status;
}


//----------------------------------------------------------------
//  MQ_InqOption()
//
//  Get transport specific binding handle options.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_InqOption( IN  void PAPI     *pvTransportOptions,
                                   IN  unsigned long  option,
                                   OUT ULONG_PTR *pOptionValue )
{
  RPC_STATUS  status =  RPC_S_OK;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;

  switch (option)
     {
     case RPC_C_OPT_MQ_DELIVERY:
        *pOptionValue = pOpts->ulDelivery;
        break;

     case RPC_C_OPT_MQ_PRIORITY:
        *pOptionValue = pOpts->ulPriority;
        break;

     case RPC_C_OPT_MQ_JOURNAL:
        *pOptionValue = pOpts->ulJournaling;
        break;

     case RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE:
        *pOptionValue = pOpts->ulTimeToReachQueue;
        break;

     case RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED:
        *pOptionValue = pOpts->ulTimeToReceive;
        break;

     case RPC_C_OPT_MQ_ACKNOWLEDGE:
        *pOptionValue = pOpts->fAck;
        break;

     default:
        status = RPC_S_INVALID_ARG;
        *pOptionValue = 0;
        break;
     }

  return status;
}



//----------------------------------------------------------------
//  MQ_ImplementOptions()
//
//  Apply transport specific binding handle options to the
//  specified server.
//----------------------------------------------------------------
RPC_STATUS RPC_ENTRY MQ_ImplementOptions(
                         IN DG_TRANSPORT_ENDPOINT pvTransEndpoint,
                         IN void             *pvTransportOptions )
{
  RPC_STATUS  Status =  RPC_S_OK;
  HRESULT     hr;
  MQ_OPTIONS *pOpts = (MQ_OPTIONS*)pvTransportOptions;
  MQ_DATAGRAM_ENDPOINT *pEndpoint = (MQ_DATAGRAM_ENDPOINT*)pvTransEndpoint;

  pEndpoint->fAck     = pOpts->fAck;
  pEndpoint->ulDelivery = pOpts->ulDelivery;
  pEndpoint->ulPriority = pOpts->ulPriority;
  pEndpoint->ulJournaling = pOpts->ulJournaling;
  pEndpoint->ulTimeToReachQueue = pOpts->ulTimeToReachQueue;
  pEndpoint->ulTimeToReceive = pOpts->ulTimeToReceive;
  pEndpoint->fAuthenticate = pOpts->fAuthenticate;
  pEndpoint->fEncrypt = pOpts->fEncrypt;

  //
  // If the fAck flag is set, then we want to get an acknowledgement
  // for each call (message) as it gets to the destination (server)
  // queue. So, setup an admin queue to receive Falcon ACK messages.
  //
  if ( (pEndpoint->fAck) && (pEndpoint->hAdminQueue == 0) )
     {
     hr = SetupAdminQueue(pEndpoint);
     Status = MQ_MapStatusCode(hr,RPC_S_INTERNAL_ERROR);

     if (Status == RPC_S_OK)
        {
        MQ_RegisterQueueToDelete(pEndpoint->wsAdminQFormat,pEndpoint->wsMachine);
        }
     }

  return Status;
}

//----------------------------------------------------------------
//  MQ_BuildAddressVector()
//
//----------------------------------------------------------------
RPC_STATUS MQ_BuildAddressVector( OUT NETWORK_ADDRESS_VECTOR **ppVector )
{
    DWORD  dwSize;
    RPC_CHAR  wsMachine[MAX_COMPUTERNAME_LEN];
    NETWORK_ADDRESS_VECTOR *pVector;


    dwSize = sizeof(wsMachine)/sizeof(RPC_CHAR);
    GetComputerName((RPC_SCHAR *)wsMachine,&dwSize);

    *ppVector = 0;

    pVector = new( sizeof(RPC_CHAR*)
                   + sizeof(RPC_CHAR)*(1+RpcpStringLength(wsMachine)) )
                   NETWORK_ADDRESS_VECTOR;

    if (!pVector)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR*)(&pVector->NetworkAddresses[1]);
    RpcpStringCopy(pVector->NetworkAddresses[0],wsMachine);

    *ppVector = pVector;

    return RPC_S_OK;
}

//----------------------------------------------------------------
//  MQ_FillInAddress()
//
//----------------------------------------------------------------
RPC_STATUS MQ_FillInAddress( MQ_ADDRESS    *pAddress,
                             MQPROPVARIANT *pMsgProps )
{
    pAddress->fAuthenticated = pMsgProps[I_AUTHENTICATED].bVal;
    pAddress->ulPrivacyLevel = pMsgProps[I_PRIVACY_LEVEL].ulVal;

    ParseQueuePathName( (RPC_CHAR *)pMsgProps[I_MESSAGE_LABEL].ptszVal,
                        pAddress->wsMachine,
                        pAddress->wsQName );

    return RPC_S_OK;
}

#ifdef TRANSPORT_DLL
//----------------------------------------------------------------
//  MIDL_user_allocate()
//
//  Used by Mq_RegisterQueueToDelete().
//----------------------------------------------------------------
void __RPC_FAR * __RPC_USER MIDL_user_allocate( size_t len )
{
  return (I_RpcAllocate(len));
}


//----------------------------------------------------------------
//  MIDL_user_free()
//
//  Used by Mq_RegisterQueueToDelete().
//----------------------------------------------------------------
void __RPC_USER MIDL_user_free( void __RPC_FAR *ptr )
{
  I_RpcFree(ptr);
}
#endif


//----------------------------------------------------------------
//  MQ_RegisterQueueToDelete()
//
//----------------------------------------------------------------
RPC_STATUS MQ_RegisterQueueToDelete( RPC_CHAR  *pwsQFormat,
                                     RPC_CHAR  *pwsMachine )
{
   RPC_STATUS  Status;
   RPC_CHAR      *pwsStringBinding;
   RPC_BINDING_HANDLE  hBinding = 0;

   ASSERT(pwsQFormat);

   gp_csContext->Request();

   // This is a long critical section... but only for the first call.

   if (!g_pContext)
      {
      Status = RpcStringBindingCompose( NULL,
                                        Q_SVC_PROTSEQ,
                                        pwsMachine,
                                        Q_SVC_ENDPOINT,
                                        NULL,
                                        &pwsStringBinding );
      if (RPC_S_OK == Status)
         {
         Status = RpcBindingFromStringBinding( pwsStringBinding,
                                               &hBinding );
         if (RPC_S_OK != Status)
            {
            gp_csContext->Clear();
            return Status;
            }

         RpcStringFree(&pwsStringBinding);

         RpcTryExcept
             {
             Status = MqGetContext(hBinding,&g_pContext);
             Status = RpcBindingFree(&hBinding);
             }
         RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
             {
             Status = RpcExceptionCode();
             }
         RpcEndExcept
         }
      }

   gp_csContext->Clear();

   if (g_pContext)
      {
      Status = MqRegisterQueue(g_pContext,pwsQFormat);
      }

   return Status;
}


//----------------------------------------------------------------
//  ConstructQueuePathName()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructQueuePathName( IN  RPC_CHAR *pwsMachine,
                             IN  RPC_CHAR *pwsQName,
                             OUT RPC_CHAR *pwsPathName,
                             IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD len = sizeof(RPC_CHAR) * (1 + RpcpStringLength(pwsMachine)
                                  + RpcpStringLength(WS_SEPARATOR)
                                  + RpcpStringLength(pwsQName) );

   if (*pdwSize < len)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_SEPARATOR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = len;
   return status;
}


//----------------------------------------------------------------
//  ConstructPrivateQueuePathName()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructPrivateQueuePathName( IN  RPC_CHAR *pwsMachine,
                                    IN  RPC_CHAR *pwsQName,
                                    OUT RPC_CHAR *pwsPathName,
                                    IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD dwSize = sizeof(RPC_CHAR) * (1 + RpcpStringLength(pwsMachine)
                                     + RpcpStringLength(WS_PRIVATE_DOLLAR)
                                     + RpcpStringLength(pwsQName) );

   if (*pdwSize < dwSize)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_PRIVATE_DOLLAR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = dwSize;
   return status;
}

#ifdef USE_PRIVATE_QUEUES
//----------------------------------------------------------------
//  ConstructPrivateDirectFormat()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructPrivateDirectFormat( IN  RPC_CHAR *pwsMachine,
                                   IN  RPC_CHAR *pwsQName,
                                   OUT RPC_CHAR *pwsPathName,
                                   IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD dwSize = sizeof(RPC_CHAR) * (1 + RpcpStringLength(WS_DIRECT),
                                     + RpcpStringLength(pwsMachine)
                                     + RpcpStringLength(WS_PRIVATE_DOLLAR)
                                     + RpcpStringLength(pwsQName) );

   if (*pdwSize < dwSize)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,WS_DIRECT);
      RpcpStringCat(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_PRIVATE_DOLLAR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = dwSize;
   return status;
}
#endif

#if FALSE
//----------------------------------------------------------------
//  ConstructDirectFormat()
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Path Name buffer too small).
//----------------------------------------------------------------
BOOL ConstructDirectFormat( IN  RPC_CHAR *pwsMachine,
                            IN  RPC_CHAR *pwsQName,
                            OUT RPC_CHAR *pwsPathName,
                            IN OUT DWORD *pdwSize  )
{
   BOOL  status = TRUE;
   DWORD dwSize = sizeof(RPC_CHAR) * (1 + RpcpStringLength(WS_DIRECT)
                                     + RpcpStringLength(pwsMachine)
                                     + RpcpStringLength(WS_SEPARATOR)
                                     + RpcpStringLength(pwsQName) );

   if (*pdwSize < dwSize)
      {
      status = FALSE;
      }
   else
      {
      RpcpStringCopy(pwsPathName,WS_DIRECT);
      RpcpStringCat(pwsPathName,pwsMachine);
      RpcpStringCat(pwsPathName,WS_SEPARATOR);
      RpcpStringCat(pwsPathName,pwsQName);
      }

   *pdwSize = dwSize;
   return status;
}
#endif

//----------------------------------------------------------------
//  ParseQueuePathName()
//
//  For RPC's use of MQ, a queue path name is of the form:
//  "machine_name\queue_name" or "machine\PRIVATE$\queue_name".
//  This routine extracts the machine name and queue name from
//  a given queue path name.
//
//  Return Value:  TRUE on success.
//                 FALSE on fail (Can't find the "\" separator).
//----------------------------------------------------------------
BOOL ParseQueuePathName(
                    IN  RPC_CHAR *pwsPathName,
                    OUT RPC_CHAR  wsMachineName[MAX_COMPUTERNAME_LEN],
                    OUT RPC_CHAR  wsQueueName[MQ_MAX_Q_NAME_LEN]  )
{
    BOOL   status = TRUE;
    RPC_CHAR *pSlash;

    pSlash = (RPC_CHAR *)RpcpCharacter(pwsPathName,*(WS_SEPARATOR));

    if (pSlash)
        {
        *pSlash = (RPC_CHAR)0;
        RpcpStringCopy(wsMachineName,pwsPathName);
        *pSlash = *(WS_SEPARATOR);
        }
    else
        status = FALSE;

    if (status)
        {
        pSlash = (RPC_CHAR *)RpcpCharacter(pwsPathName,*(WS_SEPARATOR));

        if (pSlash)
            {
            RpcpStringCopy(wsQueueName,++pSlash);
            }
        else
            status = FALSE;
        }

    return status;
}


//--------------------------------------------------------------------
//  LocateQueueViaQName()
//
//  Try to find a MQ queue of type specified by the Queue UUID (the
//  queue type) with the specified queue name. The first one that is
//  found (if any) is returned.
//--------------------------------------------------------------------
HRESULT LocateQueueViaQName( IN OUT MQ_ADDRESS *pAddress )
{
   HRESULT       hr = MQ_OK;
   HANDLE        hEnum;
   int           iSize;
   DWORD         dwSize;
   DWORD         cProps;
   DWORD         cQueue;
   UUID          QUuid;
   QUEUEPROPID   aqPropId[MAX_VAR];
   MQPROPVARIANT aPropVar[MAX_VAR];
   MQPROPERTYRESTRICTION aPropRestrict[MAX_VAR];
   MQRESTRICTION restrict;
   MQCOLUMNSET   column;
   RPC_CHAR         wsMachine[MAX_COMPUTERNAME_LEN];
   RPC_CHAR         wsQName[MQ_MAX_Q_NAME_LEN];

   if (RPC_S_OK != UuidFromString(SVR_QTYPE_UUID_STR,&QUuid))
      {
      return MQ_ERROR;
      }

   // Set up the restriction properties such that we will
   // only find our queue (of type pQUuid):

   cProps = 0;
   aPropRestrict[cProps].rel = PREQ;
   aPropRestrict[cProps].prop = PROPID_Q_TYPE;
   aPropRestrict[cProps].prval.vt = VT_CLSID;
   aPropRestrict[cProps].prval.puuid = &QUuid;
   cProps++;

   ASSERT(cProps < MAX_VAR);

   restrict.cRes = cProps;
   restrict.paPropRes = aPropRestrict;

   cProps = 0;
   aqPropId[cProps++] = PROPID_Q_INSTANCE;
   aqPropId[cProps++] = PROPID_Q_PATHNAME;

   ASSERT(cProps < MAX_VAR);

   column.cCol = cProps;
   column.aCol = aqPropId;

   // Ok, do a locate enumeration:

   hr = MQLocateBegin(NULL,&restrict,&column,NULL,&hEnum);
   if (FAILED(hr))
      {
      return hr;
      }

   cQueue = cProps;
   while (cQueue > 0)
      {
      hr = MQLocateNext( hEnum, &cQueue, aPropVar );
      if (FAILED(hr))
         {
         MQLocateEnd(hEnum);
         return hr;
         }

      if (cQueue > 0)
         {
         // Now extract the queue name from the path name:
         if (ParseQueuePathName((RPC_CHAR *)(aPropVar[1].ptszVal),wsMachine,wsQName))
            {
            if (!RpcpStringCompare(pAddress->wsQName,wsQName))
               {
               // We have a match! Ok, get the format name,
               // cleanup then return...

               // Transform the queue instance UUID into a
               // format name:
               dwSize = sizeof(pAddress->wsQFormat);
               hr = MQInstanceToFormatName( aPropVar[0].puuid, pAddress->wsQFormat, &dwSize);
               if (FAILED(hr))
                  {
                  break;
                  }

               // Free memory allocated by MQLocateNext():
               MQFreeMemory(aPropVar[0].puuid);    // From: PROPID_Q_INSTANCE
               MQFreeStringFromProperty(&aPropVar[1]);  // From: PROPID_Q_PATHNAME

               // Machine name:
               RpcpStringCopy(pAddress->wsMachine,wsMachine);

               break;
               }
            }

         // Free memory allocated by MQLocateNext():
         MQFreeMemory(aPropVar[0].puuid);    // From: PROPID_Q_INSTANCE
         MQFreeStringFromProperty(&aPropVar[1]);  // From: PROPID_Q_PATHNAME
         }
      }


   MQLocateEnd(hEnum);

   if (cQueue == 0)
      {
      return MQ_ERROR_QUEUE_NOT_FOUND;
      }

   return hr;
}


//----------------------------------------------------------------
//  CreateQueue()
//
//  Create a MQ queue of the specified path name.
//
//  Return Value:  MQ HRESULT value.
//
//----------------------------------------------------------------
HRESULT CreateQueue( IN  SECURITY_DESCRIPTOR  *pSecurityDescriptor,
                     IN  UUID     *pQueueUuid,
                     IN  RPC_CHAR *pwsPathName,
                     IN  RPC_CHAR *pwsQueueLabel,
                     IN  ULONG     ulQueueFlags,
                     OUT RPC_CHAR *pwsFormat,
                     IN OUT DWORD *pdwFormatSize )
{
   HRESULT       hr;
   DWORD         cProps;
   DWORD         dwSize;
   MQQUEUEPROPS  qProps;
   MQPROPVARIANT aPropVar[MAX_VAR];
   QUEUEPROPID   aqPropId[MAX_VAR];


   //
   // Setup properties to create a queue on this machine:
   //
   cProps = 0;

   // Set the PathName:
   aqPropId[cProps] = PROPID_Q_PATHNAME;
   aPropVar[cProps].vt =	VT_LPTSTR;
   aPropVar[cProps].ptszVal = (RPC_SCHAR *)pwsPathName;
   cProps++;

   // Set the type of the queue (this is a UUID).
   // This can be used to locate RPC specific queues.
   if (pQueueUuid)
   {
     aqPropId[cProps] = PROPID_Q_TYPE;
     aPropVar[cProps].vt = VT_CLSID;
     aPropVar[cProps].puuid = pQueueUuid;
     cProps++;
   }

   // Do we want to force authentication of messages
   // on the queue?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY)
      {
      aqPropId[cProps] = PROPID_Q_AUTHENTICATE;
      aPropVar[cProps].vt = VT_UI1;
      aPropVar[cProps].bVal = TRUE;
      cProps++;
      }

   // Do we want to force encrypted messages?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY)
      {
      aqPropId[cProps] = PROPID_Q_PRIV_LEVEL;
      aPropVar[cProps].vt = VT_UI4;
      aPropVar[cProps].ulVal = MQ_PRIV_LEVEL_BODY;
      cProps++;
      }

   // Put a description to the queue.
   // Useful for administration purposes (through the MSMQ admin tools).
   aqPropId[cProps] = PROPID_Q_LABEL;
   aPropVar[cProps].vt =	VT_LPTSTR;
   aPropVar[cProps].ptszVal = (RPC_SCHAR *)pwsQueueLabel;
   cProps++;

   ASSERT(cProps < MAX_VAR);

   // Assemble the QUEUEPROPS structure:
   qProps.cProp = cProps;
   qProps.aPropID = aqPropId;
   qProps.aPropVar = aPropVar;
   qProps.aStatus = 0;

   //-------------------------------------------------------
   // Create the queue
   hr = MQCreateQueue( pSecurityDescriptor,// Queue permissions.
                       &qProps,            // Queue properties.
                       pwsFormat,          // Format Name [out].
                       pdwFormatSize );    // Size of Format Name [in,out].

   return hr;
}


//----------------------------------------------------------------
//  ConnectToServerQueue()
//
//----------------------------------------------------------------
RPC_STATUS ConnectToServerQueue( MQ_ADDRESS  *pAddress,
                                 RPC_CHAR    *pNetworkAddress,
                                 RPC_CHAR    *pEndpoint )
{
    HRESULT     hr;
    DWORD       dwSize;
    RPC_CHAR       wsQPathName[MAX_PATHNAME_LEN];


    //
    // First, check the end point:
    //
    if ( (pEndpoint == NULL)
         || (*pEndpoint == '\0')
         || (RpcpStringLength(pEndpoint) >= MQ_MAX_Q_NAME_LEN) )
        {
        return RPC_S_INVALID_ENDPOINT_FORMAT;
        }

    memset(pAddress,0,sizeof(MQ_ADDRESS));

    RpcpStringCopy(pAddress->wsQName,pEndpoint);


    //
    // Now, if the server was specified, then use it as is,
    // otherwise use the local machine name:
    //
    if ( (pNetworkAddress == NULL) || (*pNetworkAddress == '\0') )
        {
        dwSize = sizeof(pAddress->wsMachine);
        GetComputerName((RPC_SCHAR *)pAddress->wsMachine,&dwSize);
        }
    else if (RpcpStringLength(pNetworkAddress) >= MAX_COMPUTERNAME_LEN)
        {
        return RPC_S_INVALID_ENDPOINT_FORMAT;
        }
    else
        {
        RpcpStringCopy(pAddress->wsMachine,pNetworkAddress);
        }


    //
    // If the server name is a "*", then locate a server (andy) that
    // has the specified queue name:
    //
    if (!RpcpStringCompare(pAddress->wsMachine,WS_ASTRISK))
       {
       hr = LocateQueueViaQName(pAddress);
       if (FAILED(hr))
          {
          return RPC_S_SERVER_UNAVAILABLE;
          }
       }

#if FALSE
    //
    // Try to use a direct format to get to the server queue:
    //
    dwSize = sizeof(pAddress->wsQFormat);
    if (!ConstructDirectFormat( pAddress->wsMachine,
                                pAddress->wsQName,
                                pAddress->wsQFormat,
                                &dwSize))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ConnectToServerQueue(): ConstructDirectFormat() failed.\n"));

        return RPC_S_SERVER_UNAVAILABLE;
        }


    hr = MQOpenQueue( pAddress->wsQFormat,
                                MQ_SEND_ACCESS, 0, &(pAddress->hQueue) );

    if (!FAILED(hr))
        {
        return RPC_S_OK;
        }
#endif


    //
    // If we get here, then the direct format failed, so try using
    // a lookup (MQPathNameToFormatName()):
    //
    dwSize = sizeof(wsQPathName);
    if (!ConstructQueuePathName( pAddress->wsMachine,
                                 pAddress->wsQName,
                                 wsQPathName,
                                 &dwSize ))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ConnectToServerQueue(): ConstructQueuePathName() failed.\n"));

        return RPC_S_SERVER_UNAVAILABLE;
        }

    dwSize = sizeof(pAddress->wsQFormat);
    hr = MQPathNameToFormatName( wsQPathName,
                                 pAddress->wsQFormat,
                                 &dwSize );
    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL, RPCTRANS "ConnectToServerQueue(): MQPathNameToFormatName() failed: 0x%x\n",
                       hr));

        return RPC_S_SERVER_UNAVAILABLE;
        }



    hr = MQOpenQueue( pAddress->wsQFormat,
                      MQ_SEND_ACCESS, 0, &(pAddress->hQueue) );

    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ConnectToServerQueue(): MQOpenQueue() failed: 0x%x\n",
                       hr));

        return RPC_S_SERVER_UNAVAILABLE;
        }

    return RPC_S_OK;
}


//----------------------------------------------------------------
//  DisconnectFromServer()
//
//----------------------------------------------------------------
RPC_STATUS DisconnectFromServer( IN OUT MQ_ADDRESS  *pAddress )
{
    DWORD       Status = NO_ERROR;

    if ((pAddress) && (pAddress->hQueue))
        {
        MQCloseQueue(pAddress->hQueue);
        pAddress->hQueue = 0;
        }

    return Status;
}

//----------------------------------------------------------------
//  SetQueueProperties()
//
//  Set the properties for an already existing queue. Currently
//  the only two Falcon queue properties that need to be set are
//  for forcing message authentication and encryption.
//
//  Return Value:  MQ HRESULT value.
//
//----------------------------------------------------------------
HRESULT SetQueueProperties( IN  RPC_CHAR *pwsQFormat,
                            IN  ULONG  ulQueueFlags )
{
   HRESULT       hr = MQ_OK;
   DWORD         cProps = 0;
   DWORD         dwSize;
   MQQUEUEPROPS  qProps;
   MQPROPVARIANT aPropVar[MAX_VAR];
   QUEUEPROPID   aqPropId[MAX_VAR];
   HRESULT       aStatus[MAX_VAR];

   // Do we want to force authentication of messages
   // on the queue?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY)
      {
      aqPropId[cProps] = PROPID_Q_AUTHENTICATE;
      aPropVar[cProps].vt = VT_UI1;
      aPropVar[cProps].bVal = TRUE;
      cProps++;
      }
   else
      {
      aqPropId[cProps] = PROPID_Q_AUTHENTICATE;
      aPropVar[cProps].vt = VT_UI1;
      aPropVar[cProps].bVal = FALSE;
      cProps++;
      }

   // Do we want to force encrypted messages?
   if (ulQueueFlags & RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY)
      {
      aqPropId[cProps] = PROPID_Q_PRIV_LEVEL;
      aPropVar[cProps].vt = VT_UI4;
      aPropVar[cProps].ulVal = MQ_PRIV_LEVEL_BODY;
      cProps++;
      }
   else
      {
      aqPropId[cProps] = PROPID_Q_PRIV_LEVEL;
      aPropVar[cProps].vt = VT_UI4;
      aPropVar[cProps].ulVal = MQ_PRIV_LEVEL_OPTIONAL;
      cProps++;
      }

   // Assemble the QUEUEPROPS structure:
   qProps.cProp = cProps;
   qProps.aPropID = aqPropId;
   qProps.aPropVar = aPropVar;
   qProps.aStatus = 0;

   // Set the new queue properties:
   hr = MQSetQueueProperties(pwsQFormat,&qProps);

   return hr;
}


//--------------------------------------------------------------------
//  ClearQueue()
//
//  Clear out all waiting messages from the specified queue (if
//  any).
//
//--------------------------------------------------------------------
HRESULT ClearQueue( QUEUEHANDLE hQueue )
{
   HRESULT       hr;
   DWORD         cProps = 0;
   MQMSGPROPS    msgProps;
   MSGPROPID     aMsgPropID[MAX_RECV_VAR];
   MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
   RPC_CHAR         wsMsgLabel[MQ_MAX_MSG_LABEL_LEN];


   //
   // MQ doesn't seem to let me clear out the queue (by reading
   // messages) unless we have at least one queue property.
   //
   aMsgPropID[cProps] = PROPID_M_LABEL;
   aMsgPropVar[cProps].vt = VT_LPTSTR;
   aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)wsMsgLabel;
   cProps++;

   aMsgPropID[cProps] = PROPID_M_LABEL_LEN;
   aMsgPropVar[cProps].vt = VT_UI4;
   aMsgPropVar[cProps].ulVal = sizeof(wsMsgLabel);
   cProps++;

   msgProps.cProp = cProps;
   msgProps.aPropID = aMsgPropID;
   msgProps.aPropVar = aMsgPropVar;
   msgProps.aStatus = 0;

   //
   // pull up all pending MQ messages.
   //
   while (TRUE)
      {
      hr = MQReceiveMessage(hQueue,0,MQ_ACTION_RECEIVE,
                                      &msgProps,NULL,NULL,NULL,NULL);
      if (FAILED(hr))
         break;
      }

   //
   // A timeout means the queue is empty:
   //
   if (hr == MQ_ERROR_IO_TIMEOUT)
      hr = MQ_OK;

   return hr;
}


//----------------------------------------------------------------
//  ClientSetupQueue()
//
//  Called by MQ_CreateEndpoint() to create and initialize the
//  client's message queue (to read server responses).
//
//  pEP         -- The structure that will hold information about
//                 the queue being created and setup.
//
//  pwsMachine  -- The machine to create the queue on.
//
//  pwsEndpoint -- RPC_CHAR string name of the endpoint. This will
//                 be used as the queue name.
//
//----------------------------------------------------------------
HRESULT ClientSetupQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint,
                          RPC_CHAR                *pwsMachine,
                          RPC_CHAR                *pwsEndpoint )
{
  HRESULT  hr;
  DWORD    dwSize;


  // The computer name for the server process:
  if (pEndpoint->wsMachine != pwsMachine)
     {
     RpcpStringCopy(pEndpoint->wsMachine,pwsMachine);
     }

  // The endpoint string (RPC_CHAR) is used as the queue name:
  RpcpStringCopy(pEndpoint->wsQName,pwsEndpoint);


  // Build the path name for the server queue:
  dwSize = sizeof(pEndpoint->wsQPathName);
  ConstructQueuePathName( pEndpoint->wsMachine,    // [in]
                          pEndpoint->wsQName,      // [in]
                          pEndpoint->wsQPathName,  // [out]
                          &dwSize );               // [in,out]

  // Try to create the client process's receive queue (for
  // responses back from the RPC server):
  UuidFromString( CLNT_QTYPE_UUID_STR, &(pEndpoint->uuidQType) );
  dwSize = sizeof(pEndpoint->wsQFormat);
  hr = CreateQueue( NULL,                    // [in] No security descriptor.
                    &(pEndpoint->uuidQType), // [in]
                    pEndpoint->wsQPathName,  // [in]
                    pEndpoint->wsQName,      // [in] Use QName as the QLabel.
                    0x00000000,              // [in] Flags
                    pEndpoint->wsQFormat,    // [out]
                    &dwSize );               // [in,out]

    if ( (FAILED(hr)) && (hr != MQ_ERROR_QUEUE_EXISTS) )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ClientSetupQueue(): CreateQueue(): 0x%x\n",
                       hr));

        return hr;
        }

    //
    // If the queue already exists, then locate it.
    //
    // NOTE: Currently client queues are temporary, but if cases
    //       are added in the future where client queues can be
    //       presistent, then this code will be needed.
    //
    if (hr == MQ_ERROR_QUEUE_EXISTS)
       {
       dwSize = sizeof(pEndpoint->wsQFormat);
       hr = MQPathNameToFormatName( pEndpoint->wsQPathName,
                                    pEndpoint->wsQFormat,
                                    &dwSize );
       if (FAILED(hr))
          return hr;
       }

    //
    // Ok, open the receive queue:
    //
    hr = MQOpenQueue( pEndpoint->wsQFormat, MQ_RECEIVE_ACCESS, 0, &(pEndpoint->hQueue));

    #if FALSE
    if (!FAILED(hr))
        {
        pEndpoint->fInitialized = TRUE;
        }
    #endif

    #ifdef DBG
    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ClientSetupQueue(): MQOpenQueueFailed(): 0x%x\n",
                       hr));
        }
    #endif

    return hr;
}

//----------------------------------------------------------------
//  ClientCloseQueue()
//
//----------------------------------------------------------------
HRESULT ClientCloseQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
    ASSERT(pEndpoint);

    if (pEndpoint->hQueue)
        {
        MQCloseQueue(pEndpoint->hQueue);
        pEndpoint->hQueue = 0;
        }

    g_pQueueMap->Remove(pEndpoint->wsQFormat);

    MQDeleteQueue(pEndpoint->wsQFormat);

    return MQ_OK;
}

//----------------------------------------------------------------
//  QueryQM()
//
//----------------------------------------------------------------
HRESULT QueryQM( RPC_CHAR *pwsMachine,
                 DWORD *pdwSize     )
{
  DWORD         cProps = 0;
  HRESULT       hr;
  MQQMPROPS     msgProps;
  MSGPROPID     aMsgPropID[MAX_RECV_VAR];
  MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];


  aMsgPropID[cProps] = PROPID_QM_PATHNAME;                // 0
  aMsgPropVar[cProps].vt = VT_NULL;
  cProps++;

  ASSERT( cProps < MAX_RECV_VAR );

  msgProps.cProp = cProps;
  msgProps.aPropID = aMsgPropID;
  msgProps.aPropVar = aMsgPropVar;
  msgProps.aStatus = 0;

  // The following receive should always fail, we're just calling
  // it to get the size of the message body:
  hr = MQGetMachineProperties( NULL, NULL, &msgProps );

  if (FAILED(hr))
     {
     return hr;
     }

  RpcpStringCopy(pwsMachine,aMsgPropVar[0].pwszVal);

  MQFreeStringFromProperty(&aMsgPropVar[0]);

  #ifdef MAJOR_DBG
  TransDbgPrint((DPFLTR_RPCPROXY_ID,
                 DPFLTR_WARNING_LEVEL,
                 RPCTRANS "QueryQM(): wsMachine: %S\n",
                 pwsMachine));
  #endif

  return hr;
}


//----------------------------------------------------------------
//  ServerSetupQueue()
//
//  Called by MQ_CreateEndpoint() to create and initialize the
//  server process's message queue (endpoint).
//
//  pEP        -- The struct to hold information about the queue
//                that is being set up.
//
//  pwsMachine -- The machine to create the queue on. For RPC this
//                is always the machine that the server process is
//                running on.
//
//  pwsEndpoint - The name of the endpoint. This will be used as
//                the queue name.
//
//  pSecurityDescriptor -- User may specify a security descriptor
//                to apply to this queue (may be NULL).
//
//  dwEndpointFlags -- Flags to control queue properties.
//
//----------------------------------------------------------------
HRESULT ServerSetupQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint,
                          RPC_CHAR   *pwsMachine,
                          RPC_CHAR   *pwsEndpoint,
                          void       *pSecurityDescriptor,
                          DWORD       dwEndpointFlags )
{
  HRESULT  hr;
  DWORD    dwSize;


  // The computer name for the server process:
  if (pEndpoint->wsMachine != pwsMachine)
     {
     RpcpStringCopy(pEndpoint->wsMachine,pwsMachine);
     }

  // The endpoint string (RPC_CHAR) is used as the queue name:
  if (pEndpoint->wsQName != pwsEndpoint)
      {
      RpcpStringCopy(pEndpoint->wsQName,pwsEndpoint);
      }

  // Build the path name for the server queue:
  dwSize = sizeof(pEndpoint->wsQPathName);
  if (!ConstructQueuePathName( pEndpoint->wsMachine,    // [in]
                               pEndpoint->wsQName,      // [in]
                               pEndpoint->wsQPathName,  // [out]
                               &dwSize ))         // [in,out]
     {
     return MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
     }

  // Try to create the server process receive queue;
  UuidFromString( SVR_QTYPE_UUID_STR, &(pEndpoint->uuidQType) );
  dwSize = sizeof(pEndpoint->wsQFormat);
  hr = CreateQueue( (SECURITY_DESCRIPTOR*)pSecurityDescriptor,
                    &(pEndpoint->uuidQType), // [in]
                    pEndpoint->wsQPathName,  // [in]
                    pEndpoint->wsQName,      // [in] Use QName as the QLabel.
                    dwEndpointFlags,         // [in]
                    pEndpoint->wsQFormat,    // [out]
                    &dwSize );               // [in,out]

  // If the queue already exists, then locate it:
  if (hr == MQ_ERROR_QUEUE_EXISTS)
     {
     dwSize = sizeof(pEndpoint->wsQFormat);
     hr = MQPathNameToFormatName( pEndpoint->wsQPathName,
                                            pEndpoint->wsQFormat,
                                            &dwSize );
     if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ServerSetupQueue(): MQPathNameToFormatName() failed: 0x%x\n",
                       hr));

        return hr;
        }

     if ( !(dwEndpointFlags & RPC_C_MQ_USE_EXISTING_SECURITY) )
        {
        hr = SetQueueProperties(pEndpoint->wsQFormat,dwEndpointFlags);
        if (FAILED(hr))
           {
           return hr;
           }
        }
     }
  else if (FAILED(hr))
     {
     TransDbgPrint((DPFLTR_RPCPROXY_ID,
                    DPFLTR_WARNING_LEVEL,
                    RPCTRANS "ServerSetupQueue(): CreateQueue() failed: 0x%x\n",
                    hr));

     return hr;
     }

  //
  // Ok, open the receive queue:
  //
  hr = MQOpenQueue( pEndpoint->wsQFormat, MQ_RECEIVE_ACCESS, 0, &(pEndpoint->hQueue));

  //
  // Does the user want to make sure the queue is empty (in case it
  // was a perminent queue):
  //
  if ( (hr == MQ_OK) && (dwEndpointFlags & RPC_C_MQ_CLEAR_ON_OPEN) )
      {
      hr = ClearQueue(pEndpoint->hQueue);
      }

  #ifdef DBG
  if (FAILED(hr))
     {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     RPCTRANS "ServerSetupQueue(): MQOpenQueue() failed: 0x%x\n",
                     hr));
     }
  #endif

  return hr;
}


//----------------------------------------------------------------
//  ServerCloseQueue()
//
//----------------------------------------------------------------
HRESULT ServerCloseQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
    ASSERT(pEndpoint);

    if (pEndpoint->hQueue)
        {
        MQCloseQueue(pEndpoint->hQueue);
        pEndpoint->hQueue = 0;
        }

    // MQDeleteQueue(pEndpoint->wsQFormat);

    return MQ_OK;
}


//----------------------------------------------------------------
//  AsyncPeekQueue()
//
//----------------------------------------------------------------
HRESULT AsyncPeekQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                        IN  MQ_OVERLAPPED        *pOl      )
{
    DWORD         cProps = 0;
    HRESULT       hr;

    pOl->aMsgPropID[cProps] = PROPID_M_BODY_SIZE;
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = 0;
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    pOl->msgProps.cProp = cProps;
    pOl->msgProps.aPropID = pOl->aMsgPropID;
    pOl->msgProps.aPropVar = pOl->aMsgPropVar;
    pOl->msgProps.aStatus = pOl->aStatus;

    hr = MQReceiveMessage( pEndpoint->hQueue,
                                     INFINITE,
                                     MQ_ACTION_PEEK_CURRENT,
                                     &pOl->msgProps,
                                     &pOl->ol,        // Asynchronous.
                                     NULL,            // No callback.
                                     NULL,            // Message filter.
                                     NULL   );        // Transaction object.
    if (FAILED(hr))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "AsyncPeekQueue() failed: 0x%x\n",
                       hr));
        }

    return hr;
}

//----------------------------------------------------------------
//  AsyncReadQueue()
//
//----------------------------------------------------------------
HRESULT AsyncReadQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                        IN  MQ_OVERLAPPED *pOl,
                        OUT MQ_ADDRESS    *pAddress,
                        OUT UCHAR         *pBuffer,
                        IN  DWORD          dwBufferSize )
{
    DWORD         cProps = 0;
    HRESULT       hr;

    pOl->aMsgPropID[cProps] = PROPID_M_BODY;           // [0]
    pOl->aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
    pOl->aMsgPropVar[cProps].caub.cElems = dwBufferSize;
    pOl->aMsgPropVar[cProps].caub.pElems = pBuffer;
    cProps++;

    ASSERT(cProps == I_MESSAGE_SIZE);
    pOl->aMsgPropID[cProps] = PROPID_M_BODY_SIZE;      // [1]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    cProps++;

    ASSERT(cProps == I_MESSAGE_LABEL);
    pOl->aMsgPropID[cProps] = PROPID_M_LABEL;          // [2]
    pOl->aMsgPropVar[cProps].vt = VT_LPWSTR;
    pOl->aMsgPropVar[cProps].pwszVal = (WCHAR *)pAddress->wsMsgLabel;
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_LABEL_LEN;      // [3]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = sizeof(pAddress->wsMsgLabel);
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_RESP_QUEUE;     // [4]
    pOl->aMsgPropVar[cProps].vt = VT_LPWSTR;
    pOl->aMsgPropVar[cProps].pwszVal = (WCHAR *)pAddress->wsQFormat;
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_RESP_QUEUE_LEN; // [5]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = sizeof(pAddress->wsQFormat);
    cProps++;

    //
    // These message properties are for authentication and privacy:
    //
    ASSERT(cProps == I_AUTHENTICATED);
    pOl->aMsgPropID[cProps] = PROPID_M_AUTHENTICATED;  // [6]
    pOl->aMsgPropVar[cProps].vt = VT_UI1;
    pOl->aMsgPropVar[cProps].bVal = 0;
    cProps++;

    ASSERT(cProps == I_PRIVACY_LEVEL);
    pOl->aMsgPropID[cProps] = PROPID_M_PRIV_LEVEL;     // [7]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = 0;
    cProps++;

    //
    // WARNING: these always need to be the last two properties
    // in the arrays (see the while loop below):
    //
    pOl->aMsgPropID[cProps] = PROPID_M_SENDERID_TYPE;  // [8]
    pOl->aMsgPropVar[cProps].vt = VT_UI4;
    pOl->aMsgPropVar[cProps].ulVal = 0;
    cProps++;

    pOl->aMsgPropID[cProps] = PROPID_M_SENDERID;       // [9]
    pOl->aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
    pOl->aMsgPropVar[cProps].caub.cElems = sizeof(pAddress->aSidBuffer);
    pOl->aMsgPropVar[cProps].caub.pElems = pAddress->aSidBuffer;
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    pOl->msgProps.cProp = cProps;
    pOl->msgProps.aPropID = pOl->aMsgPropID;
    pOl->msgProps.aPropVar = pOl->aMsgPropVar;
    pOl->msgProps.aStatus = pOl->aStatus;

    hr = MQReceiveMessage( pEndpoint->hQueue,
                                     INFINITE,
                                     MQ_ACTION_RECEIVE,
                                     &pOl->msgProps,
                                     &pOl->ol,        // Asynchronous.
                                     NULL,            // No callback.
                                     NULL,            // Message filter.
                                     NULL   );        // Transaction object.
    #ifdef DBG
    if (  (hr != MQ_OK)
          && (hr != MQ_INFORMATION_OPERATION_PENDING)
          && (hr != MQ_ERROR_BUFFER_OVERFLOW) )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "AsyncReadQueue() failed: 0x%x\n",
                       hr));
        }
    #endif

    return hr;
}


//----------------------------------------------------------------
//  MQ_SendToQueue()
//
//  Send a PDU to somebody (specified by pAddress).
//
//  pEndpoint -- My (endpoint) for responses.
//
//  pAddress  -- The destination queue.
//
//  pBuffer   -- The data PDU to send.
//
//  dwBufferSize The size of the PDU (bytes).
//
//----------------------------------------------------------------
HRESULT MQ_SendToQueue( IN MQ_DATAGRAM_ENDPOINT *pEndpoint,
                        IN MQ_ADDRESS           *pAddress,
                        IN UCHAR                *pBuffer,
                        IN DWORD                 dwBufferSize )
{
  HRESULT       hr;
  DWORD         cProps = 0;
  MQMSGPROPS    msgProps;
  MSGPROPID     aMsgPropID[MAX_SEND_VAR];
  MQPROPVARIANT aMsgPropVar[MAX_SEND_VAR];
  HRESULT       aStatus[MAX_SEND_VAR];

  // NOTE: If you add MQ properties to be sent, make sure that
  // MAX_SEND_VAR is large enough...

  // Message body contains the packet being sent:
  aMsgPropID[cProps] = PROPID_M_BODY;
  aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
  aMsgPropVar[cProps].caub.cElems = dwBufferSize;
  aMsgPropVar[cProps].caub.pElems = pBuffer;
  cProps++;

  // The size of the packet:
  #if FALSE
  aMsgPropID[cProps] = PROPID_M_BODY_SIZE;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = dwBufferSize;
  cProps++;
  #endif

  // Pass the sender (me) as the queue label. The queue label
  // holds the my Queue Path Name:
  aMsgPropID[cProps] = PROPID_M_LABEL;
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pEndpoint->wsQPathName;
  cProps++;

  // Delivery (express or recoverable):
  aMsgPropID[cProps] = PROPID_M_DELIVERY;
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = (unsigned char)(pEndpoint->ulDelivery);
  cProps++;

    // Priority (MQ_MIN_PRIORITY to MQ_MAX_PRIORITY):
  aMsgPropID[cProps] = PROPID_M_PRIORITY;
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = (unsigned char)(pEndpoint->ulPriority);
  cProps++;

  // Journaling (none, deadletter or journal):
  aMsgPropID[cProps] = PROPID_M_JOURNAL;
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = (unsigned char)(pEndpoint->ulJournaling);
  cProps++;

  // Time limit to reach destination queue (seconds):
  aMsgPropID[cProps] = PROPID_M_TIME_TO_REACH_QUEUE;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = pEndpoint->ulTimeToReachQueue;
  cProps++;

  // Time limit for call to be received (seconds):
  aMsgPropID[cProps] = PROPID_M_TIME_TO_BE_RECEIVED;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = pEndpoint->ulTimeToReceive;
  cProps++;

  // Response Queue:
  aMsgPropID[cProps] = PROPID_M_RESP_QUEUE;
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pEndpoint->wsQFormat;
  cProps++;

  // Authentication:
  aMsgPropID[cProps] = PROPID_M_AUTH_LEVEL;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = (pEndpoint->fAuthenticate)? MQMSG_AUTH_LEVEL_ALWAYS : MQMSG_AUTH_LEVEL_NONE;
  cProps++;

    // Encryption:
  aMsgPropID[cProps] = PROPID_M_PRIV_LEVEL;
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = (pEndpoint->fEncrypt)? MQMSG_PRIV_LEVEL_BODY : MQMSG_PRIV_LEVEL_NONE;
  cProps++;

  // Call (message) acknowledgment:
  if (pEndpoint->fAck)
      {
      aMsgPropID[cProps] = PROPID_M_ACKNOWLEDGE;
      aMsgPropVar[cProps].vt = VT_UI1;
      aMsgPropVar[cProps].bVal = MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE;
      cProps++;

      aMsgPropID[cProps] = PROPID_M_ADMIN_QUEUE;
      aMsgPropVar[cProps].vt = VT_LPTSTR;
      aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pEndpoint->wsAdminQFormat;
      cProps++;
      }

  ASSERT( cProps < MAX_SEND_VAR );


  msgProps.cProp = cProps;
  msgProps.aPropID = aMsgPropID;
  msgProps.aPropVar = aMsgPropVar;
  msgProps.aStatus = aStatus;

  if ( (!pAddress->hQueue)
       && !(pAddress->hQueue = g_pQueueMap->Lookup(pAddress->wsQFormat)) )
      {
      hr = MQOpenQueue( pAddress->wsQFormat,
                                  MQ_SEND_ACCESS, 0, &(pAddress->hQueue) );
      if (FAILED(hr))
          {
          TransDbgPrint((DPFLTR_RPCPROXY_ID,
                         DPFLTR_WARNING_LEVEL,
                         RPCTRANS "MQ_SendToQueue(): MQOpenQueue() failed: 0x%x\n",
                         hr));

          return hr;
          }

      if (!g_pQueueMap->Add(pAddress->wsQFormat, pAddress->hQueue))
          {
          return MQ_ERROR_INSUFFICIENT_RESOURCES;
          }
      }

  hr = MQSendMessage( pAddress->hQueue, &msgProps, NULL );

  if ( (!FAILED(hr)) && (pEndpoint->fAck) )
     {
     hr = WaitForAck(pEndpoint);

     if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
        {
        MQCloseQueue(pEndpoint->hQueue);
        pEndpoint->hQueue = 0;
        }
     }

  #ifdef DBG
  if (hr != MQ_OK)
      {
      TransDbgPrint((DPFLTR_RPCPROXY_ID,
                     DPFLTR_WARNING_LEVEL,
                     RPCTRANS "MQ_SendToQueue(): MQSendMessage() failed: 0x%x\n",
                     hr));
      }
  #endif

  return hr;
}


//----------------------------------------------------------------
//  ReadQueue()
//
//  Blocking read of the next message from the queue in pEndpoint.
//  If there is no pending message on the queue, wait around for
//  timeoutMsec.
//
//  pInfo       -- Holds information about the queue that we are
//                 doing a read on.
//
//  timeoutMsec -- How long to wait around if there are no messages
//                 pending.
//
//  pAddress    -- Where to replace information about the queue to
//                 respond queue (who sent the message).
//
//  pBuffer     -- The MQ message body is returned in the memory
//                 pointed to by pBuffer. This is the RPC packet.
//
//  pdwBufferSize  On entry it is passed in as the total size of
//                 pBuffer, and it is returned with the actual
//                 number of bytes in the message.
//
//----------------------------------------------------------------
HRESULT ReadQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                   IN  DWORD       timeoutMsec,
                   OUT MQ_ADDRESS *pAddress,
                   OUT UCHAR      *pBuffer,
                   IN OUT DWORD   *pdwBufferSize )
{
  DWORD         cProps = 0;
  HRESULT       hr;
  MQMSGPROPS    msgProps;
  MSGPROPID     aMsgPropID[MAX_RECV_VAR];
  MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
  HRESULT       aStatus[MAX_RECV_VAR];


  aMsgPropID[cProps] = PROPID_M_BODY;                // [0]
  aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
  aMsgPropVar[cProps].caub.cElems = *pdwBufferSize;
  aMsgPropVar[cProps].caub.pElems = pBuffer;
  cProps++;

  ASSERT(cProps == I_MESSAGE_SIZE);
  aMsgPropID[cProps] = PROPID_M_BODY_SIZE;           // [1]
  aMsgPropVar[cProps].vt = VT_UI4;
  cProps++;

  ASSERT(cProps == I_MESSAGE_LABEL);
  aMsgPropID[cProps] = PROPID_M_LABEL;               // [2]
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pAddress->wsMsgLabel;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_LABEL_LEN;           // [3]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = sizeof(pAddress->wsMsgLabel);
  cProps++;

  aMsgPropID[cProps] = PROPID_M_RESP_QUEUE;          // [4]
  aMsgPropVar[cProps].vt = VT_LPTSTR;
  aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)pAddress->wsQFormat;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_RESP_QUEUE_LEN;      // [5]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = MAX_FORMAT_LEN;
  cProps++;

  //
  // These message properties are for authentication and privacy:
  //
  ASSERT(cProps == I_AUTHENTICATED);
  aMsgPropID[cProps] = PROPID_M_AUTHENTICATED;       // [6]
  aMsgPropVar[cProps].vt = VT_UI1;
  aMsgPropVar[cProps].bVal = 0;
  cProps++;

  ASSERT(cProps == I_PRIVACY_LEVEL);
  aMsgPropID[cProps] = PROPID_M_PRIV_LEVEL;          // [7]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = 0;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_SENDERID_TYPE;       // [8]
  aMsgPropVar[cProps].vt = VT_UI4;
  aMsgPropVar[cProps].ulVal = 0;
  cProps++;

  aMsgPropID[cProps] = PROPID_M_SENDERID;            // [9]
  aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
  aMsgPropVar[cProps].caub.cElems = sizeof(pAddress->aSidBuffer);
  aMsgPropVar[cProps].caub.pElems = pAddress->aSidBuffer;
  cProps++;


  ASSERT( cProps < MAX_RECV_VAR );

  msgProps.cProp = cProps;
  msgProps.aPropID = aMsgPropID;
  msgProps.aPropVar = aMsgPropVar;
  msgProps.aStatus = aStatus;

  hr = MQReceiveMessage( pEndpoint->hQueue,
                                   timeoutMsec,
                                   MQ_ACTION_RECEIVE,
                                   &msgProps,
                                   NULL,            // No overlap (synchronous).
                                   NULL,            // No callback.
                                   NULL,            // Message filter.
                                   NULL   );        // Transaction object.

  #ifdef DBG
  if ( (hr != MQ_OK) && (hr != MQ_ERROR_IO_TIMEOUT) )
     {
     DbgPrint("ReadQueue(): ERROR: hr: 0x%x\n",hr);
     }
  #endif

  if (!FAILED(hr))
  {
    pAddress->hQueue = 0;
    *pdwBufferSize = msgProps.aPropVar[I_MESSAGE_SIZE].ulVal;
  }

  return hr;
}


//----------------------------------------------------------------
//  PeekQueue()
//
//  Do a peek on the queue for the specified endpoint in order to
//  find out how big the next message is.  If there are no messages
//  in the queue, wait around for dwTimeoutMsec.  Return the size
//  of the message in *pdwSize.
//
//----------------------------------------------------------------
HRESULT PeekQueue( IN  MQ_DATAGRAM_ENDPOINT *pEndpoint,
                   IN  DWORD       dwTimeoutMsec,
                   OUT DWORD      *pdwSize        )
{
    DWORD         cProps = 0;
    BOOL          bSuccess;
    HRESULT       hr;
    MQMSGPROPS    msgProps;
    MSGPROPID     aMsgPropID[MAX_RECV_VAR];
    MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
    RPC_CHAR         wsMsgLabel[MQ_MAX_MSG_LABEL_LEN];


    aMsgPropID[cProps] = PROPID_M_BODY;                     // 0
    aMsgPropVar[cProps].vt = (VT_UI1 | VT_VECTOR);
    aMsgPropVar[cProps].caub.cElems = 0;
    aMsgPropVar[cProps].caub.pElems = NULL;
    cProps++;

    aMsgPropID[cProps] = PROPID_M_BODY_SIZE;                // 1
    aMsgPropVar[cProps].vt = VT_UI4;
    cProps++;

    aMsgPropID[cProps] = PROPID_M_LABEL;                    // 2
    aMsgPropVar[cProps].vt = VT_LPTSTR;
    aMsgPropVar[cProps].ptszVal = (RPC_SCHAR *)wsMsgLabel;
    cProps++;

    aMsgPropID[cProps] = PROPID_M_LABEL_LEN;                // 3
    aMsgPropVar[cProps].vt = VT_UI4;
    aMsgPropVar[cProps].ulVal = sizeof(wsMsgLabel);
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    msgProps.cProp = cProps;
    msgProps.aPropID = aMsgPropID;
    msgProps.aPropVar = aMsgPropVar;
    msgProps.aStatus = 0;

    // The following receive should always fail, we're just calling
    // it to get the size of the message body:
    hr = MQReceiveMessage( pEndpoint->hQueue,
                                     dwTimeoutMsec,
                                     MQ_ACTION_RECEIVE,
                                     &msgProps,
                                     NULL,            // No overlap (synchronous).
                                     NULL,            // No callback.
                                     NULL,            // Message filter.
                                     NULL   );        // Transaction object.

    if (hr == MQ_ERROR_BUFFER_OVERFLOW)
    {
      *pdwSize = aMsgPropVar[1].ulVal;
      hr = MQ_OK;
    }
    else
      *pdwSize = 0;

    #ifdef DBG
    if ( (hr != MQ_OK) && (hr != MQ_ERROR_IO_TIMEOUT) )
       {
       DbgPrint("ClntPeekQueue(): ERROR: hr: 0x%x (%d)\n",hr,hr);
       }
    #endif

    return hr;
}


//----------------------------------------------------------------
//  EvaluateAckMessage()
//
//----------------------------------------------------------------
HRESULT EvaluateAckMessage( IN USHORT msgClass )
{
  HRESULT  hr = msgClass;

  switch (msgClass)
  {
     case MQMSG_CLASS_ACK_REACH_QUEUE:
     case MQMSG_CLASS_ACK_RECEIVE:
        hr = MQ_OK;
        break;

     case MQMSG_CLASS_NACK_BAD_DST_Q:
        hr = MQ_ERROR_QUEUE_NOT_FOUND;
        break;

     // All other cases are handled in MQ_MapStatusCode()...
  }

  return hr;
}

//----------------------------------------------------------------
//  ClntWaitForAck()
//
//  Used by the client side to wait for a MQ acknowledgement when
//  ClntSendToQueue() sends a call. An ACK is sent when the call
//  message reaches the destination (server) queue.
//
//----------------------------------------------------------------
HRESULT WaitForAck( IN MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
    HRESULT       hr;
    DWORD         cProps = 0;
    UCHAR         msgClass;
    MQMSGPROPS    msgProps;
    MSGPROPID     aMsgPropID[MAX_RECV_VAR];
    MQPROPVARIANT aMsgPropVar[MAX_RECV_VAR];
    HRESULT       aMsgHr[MAX_RECV_VAR];
    RPC_CHAR         wsMsgLabel[MQ_MAX_MSG_LABEL_LEN];


    // The message class will tell us the message acknowledgement:
    aMsgPropID[cProps] = PROPID_M_CLASS;
    aMsgPropVar[cProps].vt = VT_UI2;
    aMsgPropVar[cProps].uiVal = 0;
    aMsgHr[cProps] = MQ_OK;
    cProps++;

    ASSERT( cProps < MAX_RECV_VAR );

    msgProps.cProp = cProps;
    msgProps.aPropID = aMsgPropID;
    msgProps.aPropVar = aMsgPropVar;
    msgProps.aStatus = aMsgHr;

    hr = MQReceiveMessage( pEndpoint->hAdminQueue,
                                     INFINITE,
                                     MQ_ACTION_RECEIVE,
                                     &msgProps,
                                     NULL, NULL, NULL, NULL );

    if (!FAILED(hr))
        {
        hr = EvaluateAckMessage( aMsgPropVar[0].uiVal );
        }
# ifdef DBG
    else
        {
        DbgPrint("WaitForAck(): FAILED: hr: 0x%x  aMsgHr[0]: 0x%x\n", hr, aMsgHr[0] );
        }
# endif

  return hr;
}

//----------------------------------------------------------------
//  SetupAdminQueue()
//
//
//----------------------------------------------------------------
HRESULT SetupAdminQueue( MQ_DATAGRAM_ENDPOINT *pEndpoint )
{
  HRESULT  hr;
  DWORD    dwSize;
  UUID     uuidQType;
  RPC_CHAR    wsQName[MQ_MAX_Q_NAME_LEN];
  RPC_CHAR    wsQPathName[MAX_PATHNAME_LEN];


  RpcpStringCopy(wsQName,TEXT("Admin"));
  RpcpStringCat(wsQName,pEndpoint->wsQName);

  // Build the path name for the admin queue (NOTE: that this
  // is a private queue):
  dwSize = sizeof(pEndpoint->wsQPathName);
  ConstructPrivateQueuePathName( pEndpoint->wsMachine, // [in]
                                 wsQName,              // [in]
                                 wsQPathName,          // [out]
                                 &dwSize );            // [in,out]


  // Try to create the server process receive queue;
  UuidFromString( CLNT_ADMIN_QTYPE_UUID_STR, &uuidQType );
  dwSize = sizeof(pEndpoint->wsAdminQFormat);
  hr = CreateQueue( NULL,                       // [in] No security descriptor.
                    &uuidQType,                 // [in]
                    wsQPathName,                // [in]
                    wsQName,                    // [in] Use QName as the QLabel.
                    0x00000000,                 // [in] Flags
                    pEndpoint->wsAdminQFormat,  // [out]
                    &dwSize );                  // [in,out]

  if ( (FAILED(hr)) && (hr != MQ_ERROR_QUEUE_EXISTS) )
     {
     #ifdef DBG
     DbgPrint("SetupAdminQueue(): %S FAILED: 0x%x (%d)\n", wsQPathName, hr, hr );
     #endif
     return hr;
     }

  //
  // If the queue already exists, then locate it.
  //
  if (hr == MQ_ERROR_QUEUE_EXISTS)
  {
    dwSize = sizeof(pEndpoint->wsQPathName);
    hr = MQPathNameToFormatName( pEndpoint->wsQPathName,
                                           pEndpoint->wsQFormat,
                                           &dwSize );
    if (FAILED(hr))
       {
       #ifdef DBG
       DbgPrint("SetupAdminQueue(): %S FAILED: 0x%x (%d)\n", wsQPathName, hr, hr );
       #endif
       return hr;
       }
  }

  //
  // Ok, open the admin queue for receive:
  //
  hr = MQOpenQueue( pEndpoint->wsAdminQFormat,
                              MQ_RECEIVE_ACCESS, 0, &(pEndpoint->hAdminQueue));

  #ifdef DBG
  if (FAILED(hr))
     {
     DbgPrint("SetupAdminQueue(): %S FAILED: 0x%x (%d)\n", wsQPathName, hr, hr );
     }
  #endif

  return hr;
}


//----------------------------------------------------------------
//  Debug test code -- DG_DbgPrintPacket().
//----------------------------------------------------------------

#ifdef MAJOR_DBG

const static char *packetTypeStrs[] =
  {
    "REQUEST",
    "PING   ",
    "RESP   ",
    "FAULT  ",
    "WORKING",
    "NOCALL ",
    "REJECT ",
    "ACK    ",
    "QUIT   ",
    "FACK   ",
    "QUACK  ",
    "Unknown",
  };

const static char asciiByteChars[] =
  {
    '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'
  };

#define HIGH_NIBBLE(uc)  ((uc) >> 4)
#define LOW_NIBBLE(uc)   ((uc) & 0x0f)

//----------------------------------------------------------------
//  DbgPacketType()
//
//----------------------------------------------------------------
static char *DbgPacketType( unsigned char *pPacket )
{
   if ( (pPacket[1] >= 0) && (pPacket[1] < 11) )
      return packetTypeStrs[pPacket[1]];
   else
      return packetTypeStrs[11];
}

//----------------------------------------------------------------
//  DbgUuidToStr()
//
//----------------------------------------------------------------
static char *DbgUuidToStr( unsigned char *pUuidArg, char *pszUuid )
{
   int  i = 0;
   int  j;
   GUID uuid;
   unsigned char *pUuid;

   // Work with local copy of the UUID:
   pUuid = (unsigned char*)&uuid;
   CopyMemory(pUuid,pUuidArg,sizeof(GUID));

   // Assume this is intel and byte-swap it...
   uuid.Data1 = RpcpByteSwapLong(uuid.Data1);
   uuid.Data2 = RpcpByteSwapShort(uuid.Data2);
   uuid.Data3 = RpcpByteSwapShort(uuid.Data3);

   for (j=0; j<16; j++)
      {
      pszUuid[i++] = asciiByteChars[HIGH_NIBBLE(pUuid[j])];
      pszUuid[i++] = asciiByteChars[LOW_NIBBLE(pUuid[j])];
      if ( (j==3)||(j==5)||(j==7)||(j==9) )
         pszUuid[i++] = '-';
      }

   pszUuid[i] = '\0';
   return pszUuid;
}

//----------------------------------------------------------------
//  DbgPrintPacket()
//
//----------------------------------------------------------------
void DG_DbgPrintPacket( unsigned char *pPacket )
{
   char  szIf[50];
   char  szAct[50];
   ULONG ulSequenceNumber;

   if (pPacket)
      {
      ulSequenceNumber = *((unsigned long*)(&(pPacket[56])));
      ulSequenceNumber = RpcpByteSwapLong(ulSequenceNumber);

      DbgPrint("    Type: %s:0x%x:0x%x:0x%x:0x%x\n    Intferface: %s\n    Activity  : %s\n    SequenceNumber: %d\n",
               DbgPacketType(pPacket),
               pPacket[0], pPacket[1], pPacket[2], pPacket[3],
               DbgUuidToStr(&(pPacket[24]),szIf),
               DbgUuidToStr(&(pPacket[40]),szAct),
               ulSequenceNumber     );
      }
   else
      {
      DbgPrint("    NULL Packet.\n" );
      }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\protocol.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Protocol.cxx

Abstract:

    Transport Protocol abstraction used mainly by PnP.
    The following is a brief description of the current RPC PnP mechanism:
    Whenever a non-local transport level object (a socket, or an address) is opened
        for a given protocol, it is added to the list of objects for the given protocol.
        This alllows all objects for a given protocol to be tracked down and closed if
        the protocol is unloaded. By the same token, objects closed are removed from
        the list of the given protocol.
    When a PnP notification arrives, the lower level transport code call into this PnP module
        to tell it that there may be a change of state. For each PnP protocol, the PnP code
        examines whether the protocol is active, and what was its last state. Depending of
        the outcome of this comparison, it will take appropriate action. Here's the finite
        state automaton with the transitions:

        Currently, RPC differentiates between four networking states of each protocol -
            protocol is not loaded, protocol is partially loaded (i.e. it is active, but
            does not have an address on it yet), it is fully loaded (or functional), and
            it is fully loaded and network address change monitoring is required. The
            fully loaded state with address change monitoring may be abbreviated to
            FunctionalMon for the purpose of this document.
            Note that Partially Loaded, and loaded without address are equivalent terms
            for the purpose of this module. Also, note that currently the networking
            code does not allow reloading of a protocol, so some of the code paths will
            never get exercised.
        RPC in turn maintains the following RPC (as opposed to networking) states:
            ProtocolNotLoaded
            ProtocolLoadedWithoutAddress
            ProtocolWasLoadedOrNeedsActivation
            ProtocolLoaded
            ProtocolWasLoadedOrNeedsActivationWithoutAddress
            ProtocolLoadedAndMonitored
        Depending on the last RPC state, and the new networking state, the following changes
            and state transitions are effected:
    If a PnP notification fails asynchronously, the completion port code will call into PnP
        code to try to resubmit the queries.
    Note that the threads on which overlapped WSAIoctl's are submitted are not protected.
        If a thread dies, the IO will fail, and the thread that picks the failure will resubmit
        the WSAIoctl. This strategy allows up to keep the thread pool smaller.

                                    Networking State        Action
RPC State
ProtocolNotLoaded                   NotLoaded               No-op
                                    PartiallyLoaded         Submit a WSAIoctl to be notified
                                                                when the protocol becomes
                                                                functional.
                                                            State = ProtocolLoadedWithoutAddress
                                    Functional              State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolLoadedWithoutAddress        NotLoaded               Cancel WSAIoctl
                                                            State = ProtocolNotLoaded
                                    PartiallyLoaded         No-op
                                    Functional              CancelWSAIoctl
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl if necessary
                                                            State = ProtocolLoadedAndMonitored
ProtocolWasLoadedOrNeedsActivation  NotLoaded               No-op
                                    PartiallyLoaded         Submit a WSAIoctl to be notified
                                                                when the protocol becomes
                                                                functional.
                                                            State = ProtocolWasLoadedOrNeedsActivationWithoutAddress
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolLoaded                      NotLoaded               Unload protocol
                                                            State = ProtocolWasLoadedOrNeedsActivation
                                    PartiallyLoaded         Invalid
                                    Functional              No-op
                                    FunctionalMon           Invalid transition
ProtocolWasLoadedOrNeedsActivationWithoutAddress     
                                    NotLoaded               Cancel WSAIoctl
                                                            State = ProtocolWasLoadedOrNeedsActivation
                                    PartiallyLoaded         No-op
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolLoadedAndMonitored          NotLoaded               Cancel address change WSAIoctl
                                                            Unload protocol
                                                            State = ProtocolWasLoadedOrNeedsActivation
                                    PartiallyLoaded         Resubmit address change WSAIoclt if necessary
                                    Functional              Invalid transition
                                    FunctionalMon           No-op
ProtocolNeedToLoadWhenReady         NotLoaded               No-op
                                    PartiallyLoaded         Submit a WSAIoctl to be notified
                                                                when the protocol becomes
                                                                functional.
                                                            State = ProtocolNeedToLoadWhenReadyWithoutAddress
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored
ProtocolNeedToLoadWhenReadyWithoutAddress
                                    NotLoaded               Cancel WSAIoctl
                                                            State = ProtocolNeedToLoadWhenReady
                                    PartiallyLoaded         No-op
                                    Functional              Restart protocol
                                                            State = ProtocolLoaded
                                    FunctionalMon           Submit address change WSAIoctl.
                                                            State = ProtocolLoadedAndMonitored



Author:

    Kamen Moutafov    [KamenM]


Revision History:

    KamenM      12/22/1998   Creation
    KamenM      03/05/1999   Adding state ProtocolLoadedAndMonitored and support for it.
    KamenM      07/17/2000   Adding support for ProtocolWasLoadedOrNeedsActivation/
                                ProtocolWasLoadedOrNeedsActivationWithoutAddress

--*/

#include <precomp.hxx>
#include <Protocol.hxx>

void RPC_ENTRY NullAddressChangeFn( PVOID arg )
{
}

RPC_ADDRESS_CHANGE_FN * AddressChangeFn = NullAddressChangeFn;

#ifdef MAJOR_PNP_DEBUG

const char *ProtocolStateNames[];

#endif

void TransportProtocol::DetectedAsFunctional(PROTOCOL_ID ProtocolId)
{
    if (IsAddressChangeMonitoringOn(ProtocolId))
        {
        EnterCriticalSection(&AddressListLock);

        // monitor functional protocols for address change will
        // set the state
        MonitorFunctionalProtocolForAddressChange(ProtocolId);

        LeaveCriticalSection(&AddressListLock);
        }
    else
        {
        // we also need to take the critical section, and cancel any address change
        // notification (if any), to avoid race between a successful listen making
        // the protocol functional, and the address change notification completing
        EnterCriticalSection(&AddressListLock);
        CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
        SetState(ProtocolLoaded, ProtocolId);
        LeaveCriticalSection(&AddressListLock);
        }
}

void TransportProtocol::HandleProtocolChange(IN WSAPROTOCOL_INFO *lpProtocolBuffer,
                                             IN int ProtocolCount,
                                             IN PROTOCOL_ID thisProtocolId)
/*++
Function Name: HandleProtocolChange

Parameters:
    lpProtocolBuffer - an array of WSAPROTOCOL_INFO structures as returned by EnumProtocols
    ProtocolCount - the number of elements in the lpProtocolBuffer array
    thisProtocolId - the ID of the protocol for this object

Description:
    This handles protocol state change for a particular protocol. The function is idempotent - it
    can be called many times safely, regardless of previous calls. It will turn into no-op if
    it is redundant.

Returns:

--*/
{
    int i;
    BOOL fProtocolActive = FALSE;
    const WS_TRANS_INFO *pInfo;

    ASSERT(ProtocolCount >= 0);
    ASSERT(lpProtocolBuffer != NULL);
    ASSERT_TRANSPORT_PROTOCOL_STATE(thisProtocolId);

    if (
#ifdef NETBIOS_ON
        (thisProtocolId == NBF) || (thisProtocolId == NBT) || (thisProtocolId == NBI) ||
#endif

#ifdef NCADG_MQ_ON
        (thisProtocolId == MSMQ) ||
#endif

        (thisProtocolId == CDP)
       )
        return;

    if (IsTrailingProtocol(thisProtocolId))
        return;

    for (i = 0; i < ProtocolCount; i ++)
        {
        // if the enumerated protocol is the current protocol, break out of the loop
        if (MapProtocolId(lpProtocolBuffer[i].iProtocol, lpProtocolBuffer[i].iAddressFamily) == thisProtocolId)
            {
            fProtocolActive = TRUE;
            break;
            }
        }

    pInfo = &WsTransportTable[thisProtocolId];

    switch(State)
        {

        case ProtocolNotLoaded:
        case ProtocolLoadedWithoutAddress:
            // if the protocol was not loaded, but now it is active, attempt to verify
            // it is operational
            if (fProtocolActive)
                {
#ifdef MAJOR_PNP_DEBUG
                if (State == ProtocolNotLoaded)
                    {
                    DbgPrint("Protocol %d was just loaded\n", thisProtocolId);
                    }
#endif
                // If the protocol is not fully functional, we will submit an address change
                // request to get notified when it does
                if (VerifyProtocolIsFunctional(thisProtocolId) == TRUE)
                    {
                    // we succeeded in changing the state of the protocol
                    ASSERT((State == ProtocolLoaded) || (State == ProtocolLoadedAndMonitored));
                    if (IsAddressChangeMonitoringOn(thisProtocolId))
                        {
                        MonitorFunctionalProtocolForAddressChange(thisProtocolId);
                        (*AddressChangeFn)((PVOID) State);
                        }
                    }
#ifdef MAJOR_PNP_DEBUG
                if (State == ProtocolLoadedWithoutAddress)
                    {
                    DbgPrint("Protocol %d was without an address\n", thisProtocolId);
                    }
#endif
                }
            else
                {
                if (State == ProtocolLoadedWithoutAddress)
                    {
                    // a protocol was removed without being fully initialized
                    // cancel the pending query if any, and reset the state to not loaded
                    CancelAddressChangeRequestIfNecessary(TRUE, thisProtocolId);
                    SetState(ProtocolNotLoaded, thisProtocolId);
#ifdef MAJOR_PNP_DEBUG
                    DbgPrint("Protocol %d was removed without being fully initialized\n", thisProtocolId);
#endif
                    }
                // else - don't care. The protocol state is not loaded, and will remain so
                }
            break;

        case ProtocolWasLoadedOrNeedsActivation:
        case ProtocolWasLoadedOrNeedsActivationWithoutAddress:
            if (fProtocolActive)
                {
                // If the protocol is not fully functional, we will submit an address change
                // request to get notified when it does
                if (VerifyProtocolIsFunctional(thisProtocolId))
                    {
                    // if a protocol was loaded, and now is active, restart the addresses on it
                    RestartProtocol(thisProtocolId);
                    if (thisProtocolId == TCP)
                        {
                        GetTransportProtocol(HTTP)->RestartProtocol(HTTP);
                        }

                    // we succeeded in changing the state of the protocol
                    ASSERT(State == ProtocolLoaded);
                    if (IsAddressChangeMonitoringOn(thisProtocolId))
                        {
                        MonitorFunctionalProtocolForAddressChange(thisProtocolId);
                        }
                    }
                }
            else
                {
                // if the protocol was loaded, but it's not active, we don't care;
                // if it was trying to get an address, but then it was unloaded,
                // cancel the request
                if (State == ProtocolWasLoadedOrNeedsActivationWithoutAddress)
                    {
                    CancelAddressChangeRequestIfNecessary(TRUE, thisProtocolId);
                    SetState(ProtocolWasLoadedOrNeedsActivation, thisProtocolId);
#ifdef MAJOR_PNP_DEBUG
                    DbgPrint("Protocol %d was removed without being fully initialized\n", thisProtocolId);
#endif
                    }
                }
            break;

        case ProtocolLoaded:
            ASSERT(IsAddressChangeMonitoringOn(thisProtocolId) == FALSE);
            // if the protocol was loaded, and it is active, we don't need to do anything;
            // if it was loaded, but is not active currently, we need to unload the protocol
            if (!fProtocolActive)
                {
#ifdef MAJOR_PNP_DEBUG
                DbgPrint("Protocol %d was just unloaded\n", thisProtocolId);
#endif
                UnloadProtocol(thisProtocolId);
                if (thisProtocolId == TCP)
                    {
                    GetTransportProtocol(HTTP)->UnloadProtocol(HTTP);
                    }
                SetState(ProtocolWasLoadedOrNeedsActivation, thisProtocolId);
                }
            break;

        case ProtocolLoadedAndMonitored:
            ASSERT(IsAddressChangeMonitoringOn(thisProtocolId));
            // if it was loaded, but is not active currently, we need to unload the protocol
            if (!fProtocolActive)
                {
#ifdef MAJOR_PNP_DEBUG
                DbgPrint("Protocol %d was just unloaded\n", thisProtocolId);
#endif
                CancelAddressChangeRequestIfNecessary(TRUE, thisProtocolId);
                UnloadProtocol(thisProtocolId);
                if (thisProtocolId == TCP)
                    {
                    GetTransportProtocol(HTTP)->UnloadProtocol(HTTP);
                    }
                SetState(ProtocolWasLoadedOrNeedsActivation, thisProtocolId);

                (*AddressChangeFn)((PVOID) State);
                }
            else
                {
#ifdef MAJOR_PNP_DEBUG
                DbgPrint("Protocol %d is monitored and received event\n", thisProtocolId);
#endif
                (*AddressChangeFn)((PVOID) State);
                }
            break;

#if defined(DBG) || defined(_DEBUG)
        default:
            ASSERT(!"Invalid State");
#endif
        }

    ASSERT_TRANSPORT_PROTOCOL_STATE(thisProtocolId);
}

void TransportProtocol::AddObjectToList(IN OUT BASE_ASYNC_OBJECT *pObj)
/*++
Function Name: AddObjectToList

Parameters:
    pObj - the object to be added

Description:
    Add the object to the list of transport objects for this protocol.

Returns:

--*/
{
    EnterCriticalSection(&AddressListLock);
    RpcpfInsertHeadList(&ObjectList, &pObj->ObjectList);
    LeaveCriticalSection(&AddressListLock);
}

void TransportProtocol::RemoveObjectFromList(IN OUT BASE_ASYNC_OBJECT *pObj)
/*++
Function Name: RemoveObjectFromList

Parameters:
    pObj - the object to be removed

Description:
    Removes the object from the list of transport objects for this protocol.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Prev, *Cur;

    Prev = NULL;

    EnterCriticalSection(&AddressListLock);

    RpcpfRemoveEntryList(&pObj->ObjectList);

    LeaveCriticalSection(&AddressListLock);
}

BOOL TransportProtocol::ResubmitQueriesIfNecessary(PROTOCOL_ID ProtocolId)
/*++
Function Name: ResubmitQueriesIfNecessary

Parameters:
    ProtocolId - the ID of the current protocol

Description:
    If there was a WSAIoctl pending that failed, it will be resubmitted.
    If this protocol was being monitored, try to restart monitoring if necessary

Returns:
    FALSE if the WSAIoctl was not resubmitted successfully.
    TRUE if the WSAIoctl was resubmitted successfully, or there was no need to resubmit it.

--*/
{
    if (addressChangeSocket)
        {
        if ((addressChangeOverlapped.Internal != 0) && (addressChangeOverlapped.Internal != STATUS_PENDING))
            {
            if (SubmitAddressChangeQuery() == FALSE)
                return FALSE;
            }
        }

    if (State == ProtocolLoadedAndMonitored)
        {
        if (MonitorFunctionalProtocolForAddressChange(ProtocolId) == FALSE)
            return FALSE;
        }

    return TRUE;
}

PROTOCOL_ID 
MapProtocolId (
    IN UINT ProtocolId,
    IN UINT AddressFamily
    )
/*++
Function Name: MapProtocolId

Parameters:
    ProtocolId - Winsock protocol ID
    AddressFamily - Winsock address family

Description:
    Converts a Winsock Protocol ID to a RPC Transport protocol ID.

Returns:
    The RPC Transport Protocol ID if successfull, or -1 if no mapping can be found

--*/
{
    unsigned id;

    for (id = 1; id < cWsTransportTable; id++)
        {
        if ((WsTransportTable[id].Protocol == (int) ProtocolId)
            && (WsTransportTable[id].AddressFamily == (int) AddressFamily))
            {
            return id;
            }
        }

    return -1;
}

BOOL TransportProtocol::HandlePnPStateChange(void)
/*++
Function Name: HandlePnPNotification

Parameters:

Description:
    Whenever a PnP notification (NewAddress) arrives, the completion port will direct it
    to this routine, which will handle all state management and all handling of the PnP
    notification.

Returns:
    TRUE if the runtime should be notified that a protocol state change has occurred.
    FALSE if the run time should not be notified, or need not be notified that a
        protocol state change has occurred.

--*/
{
    int i;

    //
    // Enumerate the currently loaded protocols
    //
    WSAPROTOCOL_INFO *lpProtocolBuffer;
    DWORD dwBufferLength = 512;
    int ProtocolCount;
    PROTOCOL_ID ProtocolId;
    TransportProtocol *pCurrentProtocol;
    BOOL fRetVal;

    EnterCriticalSection(&AddressListLock);

    ASSERT(hWinsock2);

    while (1)
        {
        lpProtocolBuffer = (WSAPROTOCOL_INFO *) I_RpcAllocate(dwBufferLength);
        if (lpProtocolBuffer == 0)
            {
            fRetVal = FALSE;
            goto CleanupAndReturn;
            }

        ProtocolCount = WSAEnumProtocolsT(
                              0,
                              lpProtocolBuffer,
                              &dwBufferLength
                              );
        if (ProtocolCount != SOCKET_ERROR)
            {
            break;
            }

        I_RpcFree(lpProtocolBuffer);

        if (GetLastError() != WSAENOBUFS)
            {
            fRetVal = FALSE;
            goto CleanupAndReturn;
            }
        }

    for (i = 1; i < MAX_PROTOCOLS; i++)
        {
        pCurrentProtocol = GetTransportProtocol(i);
        pCurrentProtocol->HandleProtocolChange(lpProtocolBuffer, ProtocolCount, i);
        }

    I_RpcFree(lpProtocolBuffer);

    fRetVal = g_NotifyRt;

CleanupAndReturn:
    LeaveCriticalSection(&AddressListLock);
#ifdef MAJOR_PNP_DEBUG
    DumpProtocolState();
#endif
    return fRetVal;
}

BOOL TransportProtocol::ResubmitQueriesIfNecessary(void)
/*++
Function Name: ResubmitQueriesIfNecessary

Parameters:

Description:
    Iterates through all protocols and calls their ResubmitQueriesIfNecessary

Returns:
    FALSE if at least one protocol needed to resubmit a query, but failed to do so
    TRUE otherwise

--*/
{
    int i;
    BOOL fAllResubmitsSucceeded = TRUE;
    TransportProtocol *pCurrentProtocol;

#ifdef MAJOR_PNP_DEBUG
    DbgPrint("Resubmitting queries for process %d\n", GetCurrentProcessId());
#endif

    EnterCriticalSection(&AddressListLock);

    for (i = 1; i < MAX_PROTOCOLS; i++)
        {
        pCurrentProtocol = GetTransportProtocol(i);
        if (!pCurrentProtocol->ResubmitQueriesIfNecessary(i))
            fAllResubmitsSucceeded = FALSE;
        }

    LeaveCriticalSection(&AddressListLock);

    return fAllResubmitsSucceeded;
}

void TransportProtocol::AddObjectToProtocolList(BASE_ASYNC_OBJECT *pObj)
{
    GetTransportProtocol(pObj->id)->AddObjectToList(pObj);
}

void TransportProtocol::RemoveObjectFromProtocolList(IN OUT BASE_ASYNC_OBJECT *pObj)
{
    // in some cases, we can legally have the id set to INVALID_PROTOCOL_ID
    // this happens when we have initialized the connection, but have failed
    // before calling Open on it, and then we attempt to destroy it
    if (pObj->id != INVALID_PROTOCOL_ID)
        {
        GetTransportProtocol(pObj->id)->RemoveObjectFromList(pObj);
        }
}

BOOL TransportProtocol::VerifyProtocolIsFunctional(IN PROTOCOL_ID ProtocolId)
/*++
    Function Name: VerifyProtocolIsFunctional

    Parameters: ProtocolId - the protocol which we're attempting to verify as functional or not

    Description: Tries to find out the listening address for a loaded protocol. The address
        itself is not used anywhere. It just testifies that the protocol is fully operational.
        Depending on how far it gets with testing whether the protocol is operational,
        it will change the State to ProtocolLoaded, ProtocolLoadedWithoutAddress or
        ProtocolWasLoadedOrNeedsActivationWithoutAddress. It will return TRUE iff the state is moved to
        ProtocolLoaded.

    Returns: TRUE if the address was found and the protocol was fully operational
             FALSE if the address could not be found, and the protocol is not
                fully operational. Note that there are two subcases here. One is when
                the protocol is not operational (or we cannot confirm that for lack of
                resources for example) and it has no sign of becoming operational. The
                second is when the protocol is not operational, but there are chances of
                it becoming operational. This happens with protocols that take some
                time to initialize. In the second case, this function will arrange for
                a retry attempt by posting an async WSAIoctl request to the completion
                port. In the current code base, we don't differentiate between the two
                cases because we don't need to. We may need to do so in the future.

--*/
{
    ASSERT((State == ProtocolNotLoaded) 
        || (State == ProtocolWasLoadedOrNeedsActivation) 
        || (State == ProtocolLoadedWithoutAddress) 
        || (State == ProtocolWasLoadedOrNeedsActivationWithoutAddress));

    ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);

    if (OpenAddressChangeRequestSocket(ProtocolId) == FALSE)
        goto AbortAndCleanup;

    // if the socket already has an address, skip further checks
    // NOTE: this check provides a fast way to check initialization state of
    // protocols that initialize quickly, but more importantly, it provides a
    // handling path for protocols that have submitted an address list change query
    // and now are getting back the result
    if (DoesAddressSocketHaveAddress())
        {

#ifdef MAJOR_PNP_DEBUG
        DbgPrint("Protocol %d is functional (1)\n", ProtocolId);
#endif

        CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
        SetStateToLoadedAndMonitorProtocolIfNecessary(ProtocolId);
        ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
        return TRUE;
        }

    // if there isn't a pending request, and there isn't a successful request (i.e. there is either
    // a failed request, or no request has been submitted so far)
    if ((addressChangeOverlapped.Internal != 0) && (addressChangeOverlapped.Internal != STATUS_PENDING))
        {
#ifdef MAJOR_PNP_DEBUG
        DbgPrint("Submitting WSAIoclt for protocol %d\n", ProtocolId);
#endif

        if (!SubmitAddressChangeQuery())
            goto AbortAndCleanup;
        }

    // check once more whether we have address - this takes care of the race where the
    // address did arrive between the time we checked for it in the beginning of this
    // function and the time we submitted the address change query
    if (DoesAddressSocketHaveAddress())
        {
#ifdef MAJOR_PNP_DEBUG
        DbgPrint("Protocol %d is functional (2)\n", ProtocolId);
#endif
        CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
        SetStateToLoadedAndMonitorProtocolIfNecessary(ProtocolId);
        ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
        return TRUE;
        }

    // regardless of whether we succeeded immediately or we are pending, advance the
    // state to ProtocolLoadedWithoutAddress and return not loaded. The completion at the
    // completion port will take care of the rest
    if (State == ProtocolWasLoadedOrNeedsActivation)
        SetState(ProtocolWasLoadedOrNeedsActivationWithoutAddress, ProtocolId);
    else if (State == ProtocolNotLoaded)
        SetState(ProtocolLoadedWithoutAddress, ProtocolId);
#ifdef MAJOR_PNP_DEBUG
    else
        {
        DbgPrint("VerifyProtocolIsFunctional did not change state for protocol %d, state: %s\n", ProtocolId,
            ProtocolStateNames[State]);
        }
#endif

    ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
    return FALSE;

AbortAndCleanup:
    // TRUE or FALSE for this argument doesn't matter here -
    // the operation has failed
    CancelAddressChangeRequestIfNecessary(FALSE, ProtocolId);
    ASSERT_TRANSPORT_PROTOCOL_STATE(ProtocolId);
    return FALSE;
}

BOOL TransportProtocol::DoesAddressSocketHaveAddress(void)
/*++
Function Name: DoesAddressSocketHaveAddress

Parameters:

Description:
    Checks if a valid address can be obtained for this protocol.

Returns:
    TRUE - a valid address could be obtained for this protocol
    FALSE - otherwise

--*/
{
    DWORD byteRet = 0;
    char buf[40];

    ASSERT(addressChangeSocket != 0);

    if (WSAIoctl(addressChangeSocket, SIO_ADDRESS_LIST_QUERY,
                 0, 0, buf, sizeof(buf), &byteRet, NULL, NULL) == SOCKET_ERROR)
        {
        return FALSE;
        }

    // if the result has non-zero length ...
    if (byteRet != 0)
        {
#if 0
        int i;
        DbgPrint("WSAIoctl returned:\n");
        for (i = 0; i < byteRet; i ++)
            {
            DbgPrint(" %X", (unsigned long) buf[i]);
            }
        DbgPrint("\nWSAIoctl with ADDRESS_LIST_QUERY returned addresses success\n");
#endif

        // ... and the resulting value is non zero ...
        if (*(long *)buf != 0)
            {
            // ... we have managed to get the true address
            return TRUE;
            }
        }

    return FALSE;
}

void TransportProtocol::CancelAddressChangeRequestIfNecessary(BOOL fForceCancel, IN PROTOCOL_ID ProtocolId)
/*++
Function Name: CancelAddressChangeRequestIfNecessary

Parameters:

Description:
    If there's an active WSAIoctl on the protocol, cancel it by closing the socket.

Returns:

--*/
{
    if (addressChangeSocket != 0)
        {
        // if the address change monitoring is off, or cancel is
        // forced, do the actual cancelling. That is, we don't
        // cancel if this is a monitored protocol and cancel is
        // optional
        if (!IsAddressChangeMonitoringOn(ProtocolId) || fForceCancel)
            {
#ifdef MAJOR_PNP_DEBUG
            DbgPrint("Address change request cancelled\n");
#endif
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            addressChangeOverlapped.Internal = -1;
            }
        }
}

void TransportProtocol::RestartProtocol(PROTOCOL_ID ProtocolId)
/*++
Function Name: RestartProtocol

Parameters:
    ProtocolId - the protocol to be restarted.

Description:
    Restarts all addresses on this protocol.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Obj;
    BOOL fAddressFound = 0;
    RPC_STATUS Status;
    LIST_ENTRY *CurrentEntry;

    VALIDATE(ProtocolId)
        {
        TCP,
#ifdef SPX_ON
        SPX,
#endif
#ifdef APPLETALK_ON
        DSP,
#endif
        HTTP,
        UDP,
#ifdef IPX_ON
        IPX,
#endif
        TCP_IPv6
        } END_VALIDATE;

    CurrentEntry = ObjectList.Flink;

    while(CurrentEntry != &ObjectList)
        {
        Obj = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);
        ASSERT(Obj->id == (int) ProtocolId);

        if (Obj->type & ADDRESS)
            {
            if (Obj->type & DATAGRAM)
                {
                Status = DG_ReactivateAddress((WS_DATAGRAM_ENDPOINT *) Obj);
                }
            else
                {
                Status = WS_ReactivateAddress((WS_ADDRESS *) Obj);
                }

            if (Status == RPC_S_OK)
                {
                fAddressFound = 1;
                COMMON_AddressManager((BASE_ADDRESS *) Obj);
                }
            }
        CurrentEntry = CurrentEntry->Flink;
        }

    if (fAddressFound)
        {
        COMMON_PostNonIoEvent(TRANSPORT, 0, 0);
        }
}

void TransportProtocol::UnloadProtocol(PROTOCOL_ID ProtocolId)
/*++
Function Name: UnloadProtocol

Parameters:
    ProtocolId - the protocol to be unloaded.

Description:
    Walks the list of the protocol transport objects. Closes the connections, and removes the
        addresses from the list. Thus failing requests on addresses will not be retried.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *Obj;
    LIST_ENTRY *CurrentEntry;

    VALIDATE(ProtocolId)
        {
        TCP,
#ifdef SPX_ON
        SPX,
#endif
#ifdef APPLETALK_ON
        DSP,
#endif
        HTTP,
        UDP,
#ifdef IPX_ON
        IPX,
#endif
        TCP_IPv6,
        HTTPv2
        } END_VALIDATE;

    CurrentEntry = ObjectList.Flink;

    //
    // - Cleanup all the objects (ie: close the socket).
    // - Remove all objects other than address objects
    //   from the list.
    //
    while(CurrentEntry != &ObjectList)
        {
        Obj = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);

        ASSERT(Obj->id == (int)ProtocolId);

        if (Obj->type & ADDRESS)
            {
            COMMON_RemoveAddress((BASE_ADDRESS *) Obj);
            }
        else
            {
            RpcpfRemoveEntryList(&Obj->ObjectList);
            
            if (ProtocolId != HTTPv2)
                WS_Abort(Obj);
            else
                HTTP_Abort(Obj);
            }

        CurrentEntry = CurrentEntry->Flink;
        }
}

BOOL TransportProtocol::SubmitAddressChangeQuery(void)
/*++
Function Name: SubmitAddressChangeQuery

Parameters:

Description:
    Submits an address change query (WSAIoctl)

Returns:
    TRUE if the WSAIoctl was successfully posted.
    FALSE otherwise

--*/
{
    ASSERT(addressChangeSocket != 0);
    static DWORD dwBytesReturned;

    //
    // Post an address list change request
    //
    addressChangeOverlapped.hEvent = 0;
    addressChangeOverlapped.Offset = 0;
    addressChangeOverlapped.OffsetHigh = 0;
    addressChangeOverlapped.Internal = 0;

    // submit the address change request - it will always complete on the completion port
    // we don't care about the dwBytesReturned. The provider requires a valid address, or
    // it rejects the request
    if (WSAIoctl(addressChangeSocket, SIO_ADDRESS_LIST_CHANGE,
                 0, 0, 0, 0, &dwBytesReturned, &addressChangeOverlapped, 0) == SOCKET_ERROR)
        {
        if (WSAGetLastError() != ERROR_IO_PENDING)
            {
#ifdef MAJOR_PNP_DEBUG
            DbgPrint("Submitting WSAIoclt failed with: %d\n", GetLastError());
#endif
            return FALSE;
            }
        }

    return TRUE;
}

void TransportProtocol::SetState(TransportProtocolStates newState, PROTOCOL_ID ProtocolId)
/*++
Function Name: SetState

Parameters:
    newState - the new state that the protocol needs to move to
    ProtocolId - the protocol number of this protocol

Description:
    Sets the state of the protocol. Nobody should write the state directly, because
        protocol state mirroring will stop working.

Returns:

--*/
{
    TransportProtocol *CurrentProtocol;

#ifdef MAJOR_PNP_DEBUG
    DbgPrint("Protocol %d moved from state: %s to state: %s\n", ProtocolId, ProtocolStateNames[State],
        ProtocolStateNames[newState]);
#endif

    // either the address change monitoring is not on for this protocol, or
    // the protocol doesn't move to loaded state, but not both
    ASSERT(!IsAddressChangeMonitoringOn(ProtocolId) || (newState != ProtocolLoaded));
    State = newState;
    if (ProtocolId == TCP)
        {
        // if a base protocols is moved into loaded and monitored, make sure
        // the trailing protocols doesn't follow it there. In such a case
        // the trailing protocol becomes only loaded
        if (newState == ProtocolLoadedAndMonitored)
            {
            GetTransportProtocol(HTTP)->State = ProtocolLoaded;
            }
        else
            {
            GetTransportProtocol(HTTP)->State = newState;
            }

        MirrorProtocolState(TCP_IPv6);
        }
    else if (ProtocolId == TCP_IPv6)
        {
        MirrorProtocolState(TCP);
        }
}

void TransportProtocol::SetStateToLoadedAndMonitorProtocolIfNecessary(PROTOCOL_ID ProtocolId)
{
    if (IsAddressChangeMonitoringOn(ProtocolId))
        {
        // monitor functional protocols for address change will
        // set the state
        MonitorFunctionalProtocolForAddressChange(ProtocolId);
        }
    else
        SetState(ProtocolLoaded, ProtocolId);
}

RPC_STATUS InitTransportProtocols(void)
/*++
Function Name: InitTransportProtocols

Parameters:

Description:
    Initializes all transport level protocols. This function should be called before
    any of the TransportProtocol functions.

Returns:

--*/
{
    TransportProtocolArray = new TransportProtocol[MAX_PROTOCOLS];
    if (TransportProtocolArray == NULL)
        return (RPC_S_OUT_OF_MEMORY);
    else
        return RPC_S_OK;
}

#if defined(DBG) || defined(_DEBUG)
void TransportProtocol::AssertTransportProtocolState(void)
/*++
Function Name: AssertTransportProtocolState

Parameters:

Description:
    Loops through all protocols and calls AssertState on them

Returns:

--*/
{
    int i;

    for (i = 1; i < MAX_PROTOCOLS; i ++)
        {
        GetTransportProtocol(i)->AssertState(i);
        }
}

void TransportProtocol::AssertState(PROTOCOL_ID ProtocolId)
/*++
Function Name: AssertState

Parameters:
    ProtocolId - the protocol number of the this protocol

Description:
    Currently this includes that addressChangeSocket is set only in the *WithoutAddress states
        and that all the objects in this protocol list are of the same protocol as this protocol.

Returns:

--*/
{
    BASE_ASYNC_OBJECT *pObject;
    LIST_ENTRY *CurrentEntry;

    // make sure that the internal state of the object is consistent
    ASSERT (State >= ProtocolNotLoaded);
    ASSERT (State <= ProtocolLoadedAndMonitored);

    if (IsTrailingProtocol(ProtocolId))
        {
        ASSERT(addressChangeSocket == 0);
        }
    else
        {
        // if we are in one of these states, there should be no address change request pending
        if ((State == ProtocolNotLoaded) 
            || (State == ProtocolWasLoadedOrNeedsActivation) 
            || (State == ProtocolLoaded))
            {
            ASSERT(addressChangeSocket == 0);
            }
        else
            {
            // if we are in one of the else states, there must be address change request pending
            ASSERT(addressChangeSocket != 0);
            }
        }

    // walk the object list and make sure every object is of the same protocol
    CurrentEntry = ObjectList.Flink;

    while (CurrentEntry != &ObjectList)
        {
        pObject = CONTAINING_RECORD(CurrentEntry, BASE_ASYNC_OBJECT, ObjectList);
        ASSERT(pObject->id == ProtocolId);
        CurrentEntry = CurrentEntry->Flink;
        }
}

#endif

BOOL TransportProtocol::MonitorFunctionalProtocolForAddressChange(PROTOCOL_ID ProtocolId)
/*++
Function Name: MonitorFunctionalProtocolForAddressChange

Parameters:
    ProtocolId - the protocol id of the current protocol

Description:
    Makes sure that an already functional protocol is monitored for address change. This is done
    by:
    - if an address change socket does not exist, one is opened.
    - if no address change WSAIoctl is pending on the socket, one is posted.

Returns:
    TRUE if the posting of address change was successful
    FALSE if it wasn't

--*/
{
    BOOL bRetVal = FALSE;

    // OpenAddressChangeRequestSocket will take care to check whether there's already
    // a socket opened
    if (OpenAddressChangeRequestSocket(ProtocolId) == FALSE)
        goto Cleanup;

    if (addressChangeOverlapped.Internal != STATUS_PENDING)
        {
        if (SubmitAddressChangeQuery() == FALSE)
            goto Cleanup;
        }

    bRetVal = TRUE;
Cleanup:
    if (State != ProtocolLoadedAndMonitored)
        SetState(ProtocolLoadedAndMonitored, ProtocolId);

    return bRetVal;
}

BOOL TransportProtocol::OpenAddressChangeRequestSocket(PROTOCOL_ID ProtocolId)
/*++
Function Name: OpenAddressChangeRequestSocket

Parameters:
    ProtocolId - the protocol id of the current protocol

Description:
    Makes sure that an address change request socket is opened.

Returns:
    TRUE if the opening was successful
    FALSE if it wasn't

--*/
{
    const WS_TRANS_INFO *pInfo = &WsTransportTable[ProtocolId];
    HANDLE h;

    // we may end up with non-zero addressChangeSocket if this is an address change query
    // request coming back to us. In this case we don't need to open up another socket
    if (addressChangeSocket == 0)
        {
        ASSERT((State == ProtocolNotLoaded) 
            || (State == ProtocolWasLoadedOrNeedsActivation) 
            || (State == ProtocolLoaded));

        //
        // Create a socket
        //
        addressChangeSocket = WSASocketT(pInfo->AddressFamily,
                          pInfo->SocketType,
                          pInfo->Protocol,
                          0,
                          0,
                          WSA_FLAG_OVERLAPPED);
        if (addressChangeSocket == INVALID_SOCKET)
            {
            //
            // We should be able to at least open a socket on the protocol,
            // if not we got a bogus notification or we're out of resources
            addressChangeSocket = 0;
            return FALSE;
            }

        //
        // make the handle non-inheritable so it goes away when we close it.
        //
        if (FALSE == SetHandleInformation( (HANDLE) addressChangeSocket, HANDLE_FLAG_INHERIT, 0))
            {
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            return FALSE;
            }

        // associate the socket with the completion port so that we get the notification there
        h = CreateIoCompletionPort((HANDLE)addressChangeSocket,
                               RpcCompletionPort,
                               NewAddress,
                               0);
        if (h == 0)
            {
            closesocket(addressChangeSocket);
            addressChangeSocket = 0;
            return FALSE;
            }
        else
            {
            ASSERT(h == RpcCompletionPort);
            }
        }
    else
        {
        // we may have a protocol in state ProtocolNotLoaded, because we are just trying
        // to bring it to loaded state
        ASSERT((State == ProtocolLoadedWithoutAddress) 
            || (State == ProtocolWasLoadedOrNeedsActivationWithoutAddress) 
            || (State == ProtocolLoadedAndMonitored) || (State == ProtocolNotLoaded));
        }

#ifdef MAJOR_PNP_DEBUG
    DbgPrint("Socket was successfully opened for protocol %d\n", ProtocolId);
#endif

    return TRUE;
}

void 
TransportProtocol::MirrorProtocolState (
    IN PROTOCOL_ID MirrorProtocolId
    )
/*++
Function Name: MirrorProtocolState

Parameters:
    MirrorProtocolId - the protocol which is mirrored

Description:
    If this is one of the protocols in a dual stack configuration, change
    the other protocol into appropriate state

Returns:

--*/
{
    TransportProtocol *MirrorProtocol;

    MirrorProtocol = GetTransportProtocol(MirrorProtocolId);
    if ((State == ProtocolLoadedAndMonitored) || (State == ProtocolLoaded))
        {
        if (MirrorProtocol->State == ProtocolNotLoaded)
            {
            MirrorProtocol->SetState(ProtocolWasLoadedOrNeedsActivation, MirrorProtocolId);
            }
        else if (MirrorProtocol->State == ProtocolLoadedWithoutAddress)
            {
            MirrorProtocol->SetState(ProtocolWasLoadedOrNeedsActivationWithoutAddress, MirrorProtocolId);
            }
        }
}

#ifdef MAJOR_PNP_DEBUG
void TransportProtocol::DumpProtocolState(void)
/*++
Function Name: DumpProtocolState

Parameters:

Description:
    Iterates through all protocol and calls their DumpProtocolState

Returns:

--*/
{
    int i;

    DbgPrint("Dumping protocol state for process %d\n", GetCurrentProcessId());

    for (i = 1; i < MAX_PROTOCOLS; i ++)
        {
        GetTransportProtocol(i)->DumpProtocolState(i);
        }
}

const char *ProtocolStateNames[] = {"ProtocolNotLoaded", "ProtocolLoadedWithoutAddress" ,
                                    "ProtocolWasLoadedOrNeedsActivation", "ProtocolLoaded", 
                                    "ProtocolWasLoadedOrNeedsActivationWithoutAddress",
                                    "ProtocolLoadedAndMonitored"};


void TransportProtocol::DumpProtocolState(PROTOCOL_ID ProtocolId)
/*++
Function Name: DumpProtocolState

Parameters:
    ProtocolId - the protocol number for this protocol.

Description:
    Dumps all significant information for this protcool on the debugger

Returns:

--*/
{
    BASE_ASYNC_OBJECT *pCurrentObject;
    LIST_ENTRY *pCurrentEntry = ObjectList.Flink;
    int fFirstTime = TRUE;
    const RPC_CHAR *Protseq;

    if (TransportTable[ProtocolId].pInfo)
        Protseq = TransportTable[ProtocolId].pInfo->ProtocolSequence;
    else
        Protseq = L"(null)";

    DbgPrint("Protocol: %S\n", Protseq);
    DbgPrint("State: %s, Addr Change Socket: %X, Addr Change Overlapped: %X\n",
        ProtocolStateNames[State], addressChangeSocket, (ULONG_PTR)&addressChangeOverlapped);
    while (pCurrentEntry != &ObjectList)
        {
        if (fFirstTime)
            {
            DbgPrint("Object List:\n");
            fFirstTime = FALSE;
            }
        pCurrentObject = CONTAINING_RECORD(pCurrentEntry, BASE_ASYNC_OBJECT, ObjectList);
        DbgPrint("\t%X\n", (ULONG_PTR)pCurrentObject);
        pCurrentEntry = pCurrentEntry->Flink;
        }
}
#endif

TransportProtocol *TransportProtocolArray;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\regexp.cxx ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  regexp.c
//
//    Simple regular expression matching.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#include <precomp.hxx>

//-------------------------------------------------------------------------
//  MatchRE()
//
//  Match the test string (pszString) against the specifed pattern. If they
//  match return TRUE, else return FALSE.
//
//  In this function patterns are made up from "literal" characters plus
//  some control characters, "*", "?", "[" and "]". Asterix (*) is a place
//  holder for "zero or more" of any character. Question Mark (?) is a place
//  holder for "any single character". The square brackets ([]) contain a
//  list of matching characters, in this case "-" is used to denote a range
//  of characters (i.e. [a-zA-Z] matches any alpha character).
//
//  Note: Currently there is no support for "or" (|) operator.
//
//  Note: Ranges are simple, there is no support for dash at the begining
//        of a range to denote the dash itself.
//-------------------------------------------------------------------------
BOOL MatchRE( unsigned char *pszString,
              unsigned char *pszPattern )
{
    unsigned char ch;
    unsigned char chPattern;
    unsigned char chRangeLow;

    while (TRUE)
       {
       // Walk throuh the pattern, matching it against the string.
       switch (chPattern = *pszPattern++)
          {
          case '*':
             // Match zero or more characters.
             while (*pszString)
                {
                if (MatchRE(pszString++,pszPattern))
                   {
                   return TRUE;
                   }
                }
                return MatchRE(pszString,pszPattern);

          case '?':
             // Match any single character.
             if (*pszString++ == 0)
                {
                // Not at end of string, so no match.
                return FALSE;
                }
             break;

          case '[':
             // Match a set of characters.
             if ( (ch = *pszString++) == 0)
                {
                // Syntax error, no matching close bracket "]".
                return FALSE;
                }

             // ch = toupper(ch);
             chRangeLow = 0;
             while (chPattern = *pszPattern++)
                {
                if (chPattern == ']')
                   {
                   // End of char set, no match found.
                   return FALSE;
                   }

                if (chPattern == '-')
                   {
                   // check a range of chars?
                   chPattern = *pszPattern;           // get high limit of range
                   if ((chPattern == 0)||(chPattern == ']'))
                      {
                      // Syntax error.
                      return FALSE;
                      }

                   if ((ch >= chRangeLow)&&(ch <= chPattern))
                      {
                      // In range, go to next character.
                      break;
                      }
                   }

                chRangeLow = chPattern;
                // See if character matches this pattern element.
                if (ch == chPattern)
                   {
                   // Character match, go on.
                   break;
                   }
                }

             // Have a match in the character set, skip to the end of the set.
             while ((chPattern)&&(chPattern != ']'))
                {
                chPattern = *pszPattern++;
                }

             break;

          case 0:
             // End of pattern, return TRUE if at end of string.
             return ((*pszString)? FALSE : TRUE);

          default:
             ch = *pszString++;
             // Check for exact character match.
             // Note: CASE matters...
             if (ch != chPattern)
                {
                // No match.
                return FALSE;
                }
             break;
          }
       }

    // Can never exit from here.
}

//-------------------------------------------------------------------------
//  MatchREList()
//
//  Match a string against a list (array) of RE pattens, return TRUE iff
//  the string matches one of the RE patterns. The list of patterns is a
//  NULL terminated array of pointers to RE pattern strings.
//-------------------------------------------------------------------------
BOOL MatchREList( unsigned char  *pszString,
                  unsigned char **ppszREList  )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (MatchRE(pszString,pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}

//-------------------------------------------------------------------------
//  MatchExactList()
//
//-------------------------------------------------------------------------
BOOL MatchExactList( unsigned char  *pszString,
                     unsigned char **ppszREList )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (!lstrcmpA((char *) pszString, (char *) pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\nbtrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nbtrans.cxx

Abstract:

    Netbios connection transport interface.  Parts are similar
    to wstran.cxx but there are major differences due to
    addresses supporting multiple listen sockets.

Author:

    Mario Goertzel    [MarioGo]


Revision History:

    MarioGo     3/28/1996   Based and depends on wstrans.cxx
    MarioGo     2/04/1997   Updated for async and client

--*/

#include <precomp.hxx>
#include <CharConv.hxx>

// Globals

BOOL fNetbiosLoaded = FALSE;

const DWORD MAX_LANA = 256;
const DWORD MAX_RESERVED_EPT = 32; // LanMan uses ports < 32.

typedef struct
{
    RPC_CHAR *Protseq;
    UINT ProtseqLength;
    PROTOCOL_ID id;
    BYTE MinEndpoint;
    BYTE MaxEndpoint;
} NB_PROTSEQ_CONFIG;

const NB_PROTSEQ_CONFIG NbProtseqConfig[] =
{
    {
    RPC_STRING_LITERAL("ncacn_nb_nb"),
    11,
    NBF,
    33,
    105
    },

    {
    RPC_STRING_LITERAL("ncacn_nb_tcp"),
    12,
    NBT,
    106,
    180
    },

    {
    RPC_STRING_LITERAL("ncacn_nb_ipx"),
    12,
    NBI,
    181,
    255
    }
};

const DWORD cNetbiosProtseqs = sizeof(NbProtseqConfig)/sizeof(NB_PROTSEQ_CONFIG);

typedef struct
{
    UCHAR ProtocolId;
    UCHAR Lana;
} NB_PROTOCOL_MAP;

DWORD cLanas;
NB_PROTOCOL_MAP *pNetbiosLanaMap = 0;

BOOL *afUsedEndpoints = 0;

const RPC_CHAR *NetbiosRegistryKey =
    RPC_CONST_STRING("Software\\Microsoft\\Rpc\\NetBios");

// enough to contain ncacn_nb_tcp#\0
const size_t MaxNbProtseqLength = 16;


RPC_STATUS
LoadNetbios()
/*++

Routine Description:

    Loads RPC netbios configuration data from the registry.

Note:

    Unlike wsock32.dll, advapi32.dll (required for registry APIs)
    is already loaded by rpcrt4.dll.  So it is okay to link
    directly to advapi32.dll.

Arguments:

    None

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    HKEY hKey;
    RPC_STATUS status;
    int i;
    PROTOCOL_ID id;

    RPC_CHAR protseq[MaxNbProtseqLength];
    DWORD cProtseq;
    DWORD datatype;
    DWORD lana;
    DWORD cLana;

    ASSERT(fNetbiosLoaded == FALSE);

    if (!pNetbiosLanaMap)
        {
        // Alloc space for the lana to RPC protocol mapping
        cLanas = 0;
        pNetbiosLanaMap = new NB_PROTOCOL_MAP[MAX_LANA];
        if (!pNetbiosLanaMap)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (!afUsedEndpoints)
        {
        // Alloc space to keep track of which endpoints are in use.
        afUsedEndpoints = new BOOL[256];
        if (!afUsedEndpoints)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        for (int i = 0; i <= MAX_RESERVED_EPT; i++)
            {
            afUsedEndpoints[i] = TRUE;
            }

        for (i = MAX_RESERVED_EPT + 1; i < 256; i++)
            {
            afUsedEndpoints[i] = FALSE;
            }
        }

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           NetbiosRegistryKey,
                           0,
                           KEY_READ,
                           &hKey);

    if (status)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Unable to open netbios key: %d\n",
                       GetLastError()));

        return(RPC_S_OUT_OF_RESOURCES);
        }

    ASSERT(hKey);

    for(i = 0, cLanas = 0; cLanas < MAX_LANA; i++)
        {
        cProtseq = MaxNbProtseqLength;
        cLana = sizeof(lana);

        status = RegEnumValueW(hKey,
                               i,
                               protseq,
                               &cProtseq,
                               0,
                               &datatype,
                               (PBYTE)&lana,
                               &cLana);

        if (status == ERROR_NO_MORE_ITEMS)
            {
            // This is the normal exit path.
            break;
            }

        if (status)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Unable to read netbios key %d, %d\n",
                           i,
                           GetLastError()));

            return(RPC_S_OUT_OF_RESOURCES);
            }

        if (datatype != REG_DWORD || lana >= MAX_LANA)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Invalid config for netbios entry %d\n",
                           i));

            ASSERT(0);
            continue;
            }

        for (int j = 0; j < cNetbiosProtseqs; j++)
            {
            if (wcsncmp(protseq,
                        NbProtseqConfig[j].Protseq,
                        NbProtseqConfig[j].ProtseqLength) == 0)
                {
                id = NbProtseqConfig[j].id;
                break;
                }
            }

        if (j == cNetbiosProtseqs)
            {
            // Unknown protsrq.
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Invalid config for netbios entry %S %d\n",
                           protseq,
                           i));

            ASSERT(0);
            continue;
            }

        pNetbiosLanaMap[cLanas].ProtocolId = (UCHAR)id;
        pNetbiosLanaMap[cLanas].Lana = (UCHAR)lana;
        cLanas++;
        }

    ASSERT(cLanas < MAX_LANA); // If this gets hit we may want to
                               // grow the table size or fix setup.

    if (cLanas == 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Invalid NETBIOS configuration\n"));

        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    return(RPC_S_OK);
}


void RPC_ENTRY WS_ServerAbortListen(RPC_TRANSPORT_ADDRESS);

RPC_STATUS
NB_ServerListenHelper(
    IN  PWS_ADDRESS pAddress,
    IN  USHORT port,
    IN  const NB_PROTSEQ_CONFIG *pConfig,
    IN  unsigned int PendingQueueSize
    )
/*++

Routine Description:

    This routine does the work of actually creating a server address.

Arguments:

    pAddress - A pointer to the loadable transport interface address.
        Will contain the newly allocated listen socket when finished.

    port - The port number to use, never zero here.

    pConfig - Config data for the protseq we're using.

    PendingQueueSize - Supplies the size of the queue of pending
        requests which should be created by the transport.
        In this case it is simply passed to listen().

ReturnValue:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT

--*/
{
    int retval, length;
    RPC_STATUS status;
    WS_SOCKADDR sockaddr;
    PWS_ADDRESS pList, pOld;
    SOCKET sock;
    PROTOCOL_ID index = pConfig->id;
    BOOL found = FALSE;
    DWORD dwLastError;

    pList = pAddress;

    status = RPC_S_CANT_CREATE_ENDPOINT;

    ASSERT(cLanas > 0 && cLanas < MAX_LANA);

    for (unsigned i = 0; i < cLanas; i++)
        {
        if (pNetbiosLanaMap[i].ProtocolId == (UCHAR)index)
            {
            //
            // Open a socket.
            //
            sock = WSASocketT(WsTransportTable[index].AddressFamily,
                              WsTransportTable[index].SocketType,
                              WsTransportTable[index].Protocol * pNetbiosLanaMap[i].Lana,
                              0,
                              0,
                              WSA_FLAG_OVERLAPPED);

            if (sock == INVALID_SOCKET)
                {
                switch(GetLastError())
                    {
                    case WSAEAFNOSUPPORT:
                    case WSAEPROTONOSUPPORT:
                    case WSAENETDOWN:
                    case WSAESOCKTNOSUPPORT:
                    case WSAEINVAL:     // when registry is not yet setup.
                        status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                        break;

                    case WSAENOBUFS:
                    case WSAEMFILE:
                        status = RPC_S_OUT_OF_MEMORY;
                        break;

                    default:
                        ASSERT(0);
                        status = RPC_S_OUT_OF_RESOURCES;
                        break;
                    }
                break;
                }

            //
            // Try to bind to the lana.
            //
            {
            DWORD Size = 1+MAX_COMPUTERNAME_LENGTH;
            char AsciiComputerName[1+MAX_COMPUTERNAME_LENGTH];

            if (!GetComputerNameA( AsciiComputerName, &Size) )
                {
                status = RPC_S_CANT_CREATE_ENDPOINT;
                closesocket(sock);
                break;
                }

            SET_NETBIOS_SOCKADDR(&sockaddr.nbaddr,
                                 NETBIOS_UNIQUE_NAME,
                                 AsciiComputerName,
                                 (char) port);
            }

            if ( bind(sock,&sockaddr.generic,sizeof(WS_SOCKADDR)) )
                {
                dwLastError = GetLastError();
                if (dwLastError == WSAEADDRINUSE)
                    {
                    //
                    // If the caller is trying use a dynamic endpoint
                    // then we may want to retry with another port.
                    //
                    status = ERROR_RETRY;
                    }
                else if(dwLastError == WSAENETDOWN)
                    {
                    closesocket(sock);
                    continue;
                    }
                else
                    status = RPC_S_CANT_CREATE_ENDPOINT;
                closesocket(sock);
                break;
                }

            if(listen(sock, PendingQueueSize) == SOCKET_ERROR)
                {
                status = RPC_S_OUT_OF_MEMORY;
                closesocket(sock);
                break;
                }

            //
            // Allocate a new address object, if needed.
            //
            found = TRUE;

            if (0 == pList)
                {
                // >1 lana, need to allocate another address.
                pList = new WS_ADDRESS;
                if (pList == 0)
                    {
                    status = RPC_S_OUT_OF_MEMORY;
                    break;
                    }

                // Insert new address into list of nb addresses.
                pOld->pNextAddress = pList;
                }

            pList->type = ADDRESS;
            pList->id = index;
            pList->ConnectionSocket = 0;
            SetProtocolMultiplier(pList, pNetbiosLanaMap[i].Lana);
            pList->NewConnection = WS_NewConnection;
            pList->SubmitListen = WS_SubmitAccept;
            pList->InAddressList = NotInList;
            pList->pFirstAddress = pAddress;
            pList->ListenSocket = 0;
            pList->ConnectionSocket = 0;
            pList->pNextAddress = 0;
            pList->Endpoint = 0;
            pList->pAddressVector = 0;
            pList->pNext = 0;
            memset(&pList->Listen, 0, sizeof(BASE_OVERLAPPED));
            pList->Listen.pAsyncObject = pList;
            pList->ListenSocket = sock;
            RpcpInitializeListHead(&pList->ObjectList);

            retval = pList->GetExtensionFunctionPointers(sock);

            if (!retval)
                {
                switch (GetLastError())
                    {
                    case WSAEFAULT:
                    case WSAEINVAL:
                        status = RPC_S_INTERNAL_ERROR;
                        break;

                    case WSAEOPNOTSUPP:
                        status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                        break;

                    default:
                        status = RPC_S_OUT_OF_RESOURCES;
                    }
                closesocket(sock);
                break;
                }

            status = COMMON_PrepareNewHandle((HANDLE)sock);

            if (status != RPC_S_OK)
                {
                closesocket(sock);
                break;
                }

            ASSERT(status == RPC_S_OK);

            pOld = pList;
            pList = 0;

            }
        }

    //
    // Cleanup only if we find something
    //
    if ((TRUE == found) && (status != RPC_S_OK))
        {
        WS_ServerAbortListen(pAddress);
        }

    return(status);
}


RPC_STATUS
NB_ServerListen(
    IN PROTOCOL_ID index,
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    This routine allocates a netbios server address receive new client
    connections.  If successful a call to NB_CompleteListen() will actually
    allow new connection callbacks to the RPC runtime to occur.  If the
    runtime is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (0-255) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    ppAddressVector - Network address of this machine.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    RPC_STATUS status;
    NTSTATUS NtStatus;
    USHORT port, maxport;
    const NB_PROTSEQ_CONFIG *pConfig;
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;

    // Figure out which flavor of Netbios we're going to use.

    pConfig = 0;

    for (int i = 0; i < cNetbiosProtseqs; i++)
        {
        if (index == NbProtseqConfig[i].id)
            {
            pConfig = &NbProtseqConfig[i];
            break;
            }
        }

    if (0 == pConfig)
        {
        ASSERT(0);
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    // Figure out what ports to try to listen on.

    if (*pEndpoint)
        {
        status = EndpointToPortNumber(*pEndpoint, port);

        if (status != RPC_S_OK)
            {
            return(status);
            }

        if (port > 255)
            {
            return(RPC_S_INVALID_ENDPOINT_FORMAT);
            }

        // Static endpoint, only try the one endpoint.

        status = NB_ServerListenHelper(pAddress,
                                       port,
                                       pConfig,
                                       PendingQueueSize);

        afUsedEndpoints[port] = TRUE;
        }
    else
        {
        port = pConfig->MinEndpoint;
        maxport = pConfig->MaxEndpoint;

        // Try to listen to a port.  This is iterative for dynamic endpoints.

        for(; port <= maxport; port++)
            {

            if (InterlockedExchange((PLONG)&afUsedEndpoints[port], TRUE) == FALSE)
                {

                status = NB_ServerListenHelper(pAddress,
                                               port,
                                               pConfig,
                                               PendingQueueSize);

                if (status == RPC_S_OK)
                    {
                    break;
                    }

                if (status != ERROR_RETRY)
                    {
                    return(status);
                    }
                }
            else
                {
                status = ERROR_RETRY;
                }
            }
        }

    if (status != RPC_S_OK)
        {
        if (status == ERROR_RETRY)
            {
            if (*pEndpoint)
                {
                return(RPC_S_DUPLICATE_ENDPOINT);
                }
            return(RPC_S_CANT_CREATE_ENDPOINT);
            }
        return(status);
        }

    //
    // Build address vector
    //

    ASSERT(pAddress->pAddressVector == 0);

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + gdwComputerNameLength * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (pVector)
        {
        pVector->Count = 1;
        pVector->NetworkAddresses[0] = (RPC_CHAR *)&pVector->NetworkAddresses[1];

        wcscpy(pVector->NetworkAddresses[0], gpstrComputerName);

        pAddress->pAddressVector = pVector;
        *ppAddressVector = pVector;
        }
    else
        {
        WS_ServerAbortListen(ThisAddress);
        return(RPC_S_OUT_OF_MEMORY);
        }

    //
    // If needed, return the dynamic endpoint as a string.
    //
    if (!*pEndpoint)
        {
        *pEndpoint = new RPC_CHAR[NB_MAXIMUM_ENDPOINT];
        if (!*pEndpoint)
            {
            WS_ServerAbortListen(ThisAddress);
            return(RPC_S_OUT_OF_MEMORY);
            }
        PortNumberToEndpoint(port, *pEndpoint);
        }

    return(RPC_S_OK);
}

C_ASSERT(FIELD_OFFSET(NB_CONNECTION, fReceivePending) == FIELD_OFFSET(WS_CLIENT_CONNECTION, fReceivePending));


RPC_STATUS
RPC_ENTRY
NB_ClientOpen(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT Timeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_nb_*"
    NetworkAddress - The name of the server, a 1-15 character netbios name
    NetworkOptions - Ignored
    Timeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    PNB_CONNECTION p = (PNB_CONNECTION)ThisConnection;
    unsigned i;
    PROTOCOL_ID id = 0;
    USHORT port;
    RPC_STATUS status;
    UCHAR nbname[NB_MAXIMUM_NAME];
    SOCKET sock;
    WS_SOCKADDR addr;
    BOOL fIsUserModeConnection;

    // Figure out which specific Netbios protocol we're using
    for (i = 0; i < cNetbiosProtseqs; i++)
        {
        if (wcscmp(NbProtseqConfig[i].Protseq, ProtocolSequence) == 0)
            {
            id = NbProtseqConfig[i].id;
            break;
            }
        }

    ASSERT(id);

    // Initialize common part of the connection object

    // use explicit placement to initialize vtable
    p = new (p) NB_CONNECTION;

    p->id = id;
    p->type = CLIENT | CONNECTION;
    p->Conn.Socket = 0;
    p->fAborted = 0;
    p->pReadBuffer = 0;
    p->maxReadBuffer = 0;
    p->iPostSize = CO_MIN_RECV;
    p->iLastRead = 0;
    memset(&p->Read.ol, 0, sizeof(p->Read.ol));
    p->Read.pAsyncObject = p;
    p->Read.thread       = 0;
    p->SequenceNumber    = 0;
    p->InitIoCounter();
    p->fReceivePending = 0;
    RpcpInitializeListHead(&p->ObjectList);

    // The netbios endpoint is really just the 16th character in the
    // netbios name registered by the server.  The value is 1-255.

    status = EndpointToPortNumber(Endpoint, port);

    if (status != RPC_S_OK)
        {
        return status;
        }

    if (port > 255)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    // Build the uppercase netbios name we're looking for.

    if (NetworkAddress && *NetworkAddress)
        {
        if (wcslen(NetworkAddress) >= NB_MAXIMUM_NAME)
            {
            return(RPC_S_INVALID_NET_ADDR);
            }
        PlatformToAnsi(NetworkAddress, (PCHAR)nbname);
        }
    else
        {
        PlatformToAnsi(gpstrComputerName, (PCHAR)nbname);
        }

    _strupr((PCHAR)nbname);

    // Loop over every lana until we run out or succeed.
    unsigned ErrorCount = 0;

    for (i = 0; i < cLanas; i++)
        {

        if (pNetbiosLanaMap[i].ProtocolId != id)
            {
            continue;
            }

        UCHAR lana = pNetbiosLanaMap[i].Lana;

        //
        // Open socket
        //

        sock = WSASocketT(AF_NETBIOS,
                          SOCK_SEQPACKET,
                          -1 * lana,
                          0,
                          0,
                          WSA_FLAG_OVERLAPPED);

        if (sock == INVALID_SOCKET)
            {
            switch(GetLastError())
                {
                case WSAEAFNOSUPPORT:
                case WSAEPROTONOSUPPORT:
                case WSAESOCKTNOSUPPORT:
                case WSAEINVAL:     // when registry is not yet setup.
                    ErrorCount++;
                    break;

                default:
                    break;
                }
            // Keep trying until we run out of lana's.

            // This was a 4.0 hot fix for exchange, they had an invalid lana
            // in the configuration and it caused us to abort too early.

            continue;
            }

        DWORD option = TRUE;
        int retval;

        retval = setsockopt( sock, SOL_SOCKET, SO_REUSEADDR,
                             (PCHAR)&option, sizeof(option) );

        ASSERT(0 == retval);


        SET_NETBIOS_SOCKADDR( (&addr.nbaddr),
                              NETBIOS_UNIQUE_NAME,
                              nbname,
                              (CHAR)port );

        //
        // Connect the socket to the server.  This is where we expect to block
        // and/or fail.
        //

        if (connect(sock, &addr.generic, sizeof(addr)) == SOCKET_ERROR)
            {
            closesocket(sock);
            // Keep trying until we run out of lana's.
            continue;
            }

        status = COMMON_PrepareNewHandle((HANDLE)sock);
        if (status != RPC_S_OK)
            {
            closesocket(sock);
            return RPC_S_OUT_OF_MEMORY;
            }

        // Connected, life is good.
        p->Conn.Socket = sock;

        fIsUserModeConnection = IsUserModeSocket(sock, &status);
        if (status)
            {
            closesocket(sock);
            ErrorCount ++;
            continue;
            }
        // if this is a user mode connection, use Winsock functions ...
        if (fIsUserModeConnection)
            p = new (p) NB_SAN_CONNECTION;

        return(RPC_S_OK);
        }

    // Either no lana's configured or none of them worked.
    if (ErrorCount == cLanas)
        {
        return (RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    return(RPC_S_SERVER_UNAVAILABLE);
}

RPC_STATUS
RPC_ENTRY
NB_Send(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Length,
    BUFFER Buffer,
    PVOID SendContext
    )
/*++

Routine Description:

    Submits a send of the buffer on the connection.  Will complete with
    ConnectionServerSend or ConnectionClientSend event either when
    the data has been sent on the network or when the send fails.

    This routine is specific to netbios since it supports sending
    sequence numbers.

Arguments:

    ThisConnection - The connection to send the data on.
    Length - The length of the data to send.
    Buffer - The data to send.
    SendContext - A buffer to use as the CO_SEND_CONTEXT for
        this operation.

Return Value:

    RPC_S_OK

    RPC_P_SEND_FAILED - Connection aborted

--*/
{
    PNB_CONNECTION pConnection = (PNB_CONNECTION)ThisConnection;
    CO_SEND_CONTEXT *pSend = (CO_SEND_CONTEXT *)SendContext;
    BOOL b;
    DWORD ignored;
    RPC_STATUS status;

    pConnection->StartingWriteIO();

    if (pConnection->fAborted)
        {
        pConnection->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    pSend->maxWriteBuffer = Length;
    pSend->pWriteBuffer = Buffer;
    pSend->Write.pAsyncObject = pConnection;
    pSend->Write.ol.hEvent = 0;
    pSend->Write.ol.Offset = 0;
    pSend->Write.ol.OffsetHigh = 0;
    pSend->Write.thread = I_RpcTransProtectThread();

    if ((pConnection->type & TYPE_MASK) == CLIENT)
        {
        // Client sends need to be prefixed with the sequence number.

        // Note: this depends on having only a single client side
        // send pending on a connection at a time.  If this changes
        // we can move the sequence number into the SEND_CONTEXT.

        WSABUF bufs[2];

        bufs[0].buf = (PCHAR)&pConnection->SequenceNumber;
        bufs[0].len = sizeof(ULONG);
        bufs[1].buf = (PCHAR)Buffer;
        bufs[1].len = Length;

        status = RPC_S_OK;

        if (WSASend(pConnection->Conn.Socket,
                             bufs,
                             2,
                             &ignored,
                             0,
                             &pSend->Write.ol,
                             0))
            {
            status = GetLastError();
            }
        }
    else
        {
        status = pConnection->Send(pConnection->Conn.Handle,
                                Buffer,
                                Length,
                                &ignored,
                                &pSend->Write.ol
                                );
        }

    ASSERT(WSA_IO_PENDING == ERROR_IO_PENDING);

    pConnection->WriteIOFinished();

    if (   status != RPC_S_OK
        && status != ERROR_IO_PENDING)
        {

        if (   status != ERROR_NETNAME_DELETED
            && status != ERROR_GRACEFUL_DISCONNECT
            && status != WSAESHUTDOWN
            && status != WSAECONNRESET
            && status != WSAECONNABORTED
            && status != WSAENETRESET
               )
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "NB Send failed %d on %p\n",
                           status,
                           pConnection));
            }

        I_RpcTransUnprotectThread(pSend->Write.thread);

        pConnection->WS_CONNECTION::Abort();
        return(RPC_P_SEND_FAILED);
        }

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
NB_Recv(
    RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    Called be the runtime on a connection without a currently
    pending recv.  This will submit the first recv on the
    connection.  Later recv's maybe posted by CO_Recv.  This is
    required to strip the sequence number off of fragments.

Arguments:

    ThisConnection - A connection without a read pending on it.

Return Value:

    RPC_S_OK
    RPC_P_RECEIVE_FAILED

--*/
{
    PNB_CONNECTION pConnection = (PNB_CONNECTION)ThisConnection;

    // Reply fragments don't have a sequence number, so we'll
    // just let the standard code deal with them.
    if ((pConnection->type & TYPE_MASK) == CLIENT)
        {
        pConnection->SequenceNumber = 0;
        return(CO_Recv(ThisConnection));
        }

    ASSERT(pConnection->iLastRead == 0);

    static ULONG NetbiosSequenceNumber;
    BOOL b;
    DWORD ignored;
    DWORD bytes;
    RPC_STATUS status;
    WSABUF bufs[2];
    int retval;

    if (pConnection->pReadBuffer == 0)
        {
        pConnection->pReadBuffer = TransConnectionAllocatePacket(pConnection,
                                                                 pConnection->iPostSize);

        if (NULL == pConnection->pReadBuffer)
            {
            pConnection->WS_CONNECTION::Abort();
            return(RPC_P_RECEIVE_FAILED);
            }

        pConnection->maxReadBuffer = pConnection->iPostSize;
        }

    pConnection->StartingReadIO();
    if (pConnection->fAborted)
        {
        pConnection->ReadIOFinished();
        return(RPC_P_RECEIVE_FAILED);
        }

    pConnection->Read.thread = I_RpcTransProtectThread();
    pConnection->Read.ol.hEvent = 0;

    bufs[0].buf = (PCHAR)&NetbiosSequenceNumber;
    bufs[0].len = sizeof(ULONG);
    bufs[1].buf = (PCHAR)pConnection->pReadBuffer;
    bufs[1].len = pConnection->maxReadBuffer;

    ignored = 0;

    retval = WSARecv(pConnection->Conn.Socket,
                     bufs,
                     2,
                     &bytes,
                     &ignored,
                     &pConnection->Read.ol,
                     0);

    pConnection->ReadIOFinished();

    if (   (0 != retval)
        && ((status = GetLastError()) != ERROR_IO_PENDING)
        && (status != WSAEMSGSIZE) )
        {

        TransDbgDetail((DPFLTR_RPCPROXY_ID,
                        DPFLTR_INFO_LEVEL,
                        RPCTRANS "NB WSARecv failed %d on %p\n",
                        status,
                        pConnection));

        I_RpcTransUnprotectThread(pConnection->Read.thread);

        pConnection->WS_CONNECTION::Abort();
        return(RPC_P_RECEIVE_FAILED);
        }

    // Even if the read completed here, it will also be posted to the
    // completion port.  This means we don't need to handle the read here.

    return(RPC_S_OK);
}

RPC_STATUS NB_CONNECTION::ProcessRead(IN  DWORD bytes, OUT BUFFER *pBuffer,
                                      OUT PUINT pBufferLength)
/*++

Routine Description:

    Wrapper for BASE_CONNECTION::ProcessRead.  This removes alls signs of the sequence
    number and return the results of BASE_CONNECTION::ProcessRead.

Arguments:
Return Value:

    See BASE_CONNECTION::ProcessRead

--*/
{
    // If this is the first read on the server then we need to substract
    // four from the bytes read since reading the sequence number doesn't count.

    if (type & SERVER)
        {
        // Server
        if (iLastRead == 0)
            {
            // First read

            if (bytes <= 4)
                {
                ASSERT(0);
                WS_CONNECTION::Abort();
                return(RPC_P_RECEIVE_FAILED);
                }

            bytes -= sizeof(ULONG);
            }
        }
    else
        {
        SequenceNumber = 0;
        }

    return(WS_CONNECTION::ProcessRead(bytes,
                                      pBuffer,
                                      pBufferLength));
}


RPC_STATUS
RPC_ENTRY
NB_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Sends a message on the connection.  This method must appear
    to be synchronous from the callers perspective.

Arguments:

    Connection - The connection of send to.
    BufferLength - The size of the buffer.
    Buffer - The data to sent.
    fDisableShutdownCheck - N/A to netbios.

Return Value:

    RPC_P_SEND_FAILED - Connection will be closed if this is returned.

    RPC_S_OK - Data sent

--*/

{
    PNB_CONNECTION p = (PNB_CONNECTION)Connection;
    ULONG bytes;
    INT retval;
    RPC_STATUS status;
    WSABUF bufs[2];
    int count;
    HANDLE hEvent = I_RpcTransGetThreadEvent();
    BOOL fWaitAlertably;

    p->StartingWriteIO();

    if (p->fAborted)
        {
        p->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    // Setting the low bit of the event indicates that the write
    // completion should NOT be sent to the i/o completion port.
    OVERLAPPED olWrite;
    olWrite.Internal = 0;
    olWrite.InternalHigh = 0;
    olWrite.Offset = 0;
    olWrite.OffsetHigh = 0;
    olWrite.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

    if ((p->type & TYPE_MASK) == CLIENT)
        {
        bufs[0].buf = (PCHAR)&p->SequenceNumber;
        bufs[0].len = sizeof(ULONG);
        bufs[1].buf = (PCHAR)Buffer;
        bufs[1].len = BufferLength;

        count = 2;
        BufferLength += sizeof(ULONG);
        }
    else
        {
        bufs[0].buf = (PCHAR)Buffer;
        bufs[0].len = BufferLength;
        count = 1;
        }

    retval = WSASend(p->Conn.Socket,
                     bufs,
                     count,
                     &bytes,
                     0,
                     &olWrite,
                     0);

    p->WriteIOFinished();

    if (retval == 0)
        {
        ASSERT(bytes == BufferLength);
        p->SequenceNumber++;
        return(RPC_S_OK);
        }

    status = GetLastError();
    if (status == WSA_IO_PENDING)
        {
        fWaitAlertably = !fDisableCancelCheck;
        status = UTIL_GetOverlappedResultEx(p,
                                          &olWrite,
                                          &bytes,
                                          fWaitAlertably,
                                          Timeout);

        if (status == RPC_S_OK)
            {
            ASSERT(bytes == BufferLength);
            p->SequenceNumber++;
            return(RPC_S_OK);
            }
        }

    p->WS_CONNECTION::Abort();

    if (status == RPC_S_CALL_CANCELLED)
        {
        // Wait for the write to finish.  Since we closed the
        // connection this won't take very long.
        UTIL_WaitForSyncIO(&olWrite,
                           FALSE,
                           INFINITE);
        }
    else
        {
        if (status != RPC_P_TIMEOUT)
            status = RPC_P_SEND_FAILED;
        }

    return(status);
}


RPC_STATUS
RPC_ENTRY
NBF_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
// See NB_ServerListen
{
    return( NB_ServerListen(NBF,
                            ThisAddress,
                            pEndpoint,
                            PendingQueueSize,
                            ppAddressVector) );
}


RPC_STATUS
RPC_ENTRY
NBT_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
// See NB_ServerListen
{
    return( NB_ServerListen(NBT,
                            ThisAddress,
                            pEndpoint,
                            PendingQueueSize,
                            ppAddressVector) );
}


RPC_STATUS
RPC_ENTRY
NBI_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
// See NB_ServerListen
{
    return( NB_ServerListen(NBI,
                            ThisAddress,
                            pEndpoint,
                            PendingQueueSize,
                            ppAddressVector) );
}


//
// Transport interface definitions
//

const RPC_CONNECTION_TRANSPORT
NBF_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NB_TOWER_ID,
    NBF_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_nb_nb"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(NB_CONNECTION),
    sizeof(NB_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NBF_MAX_SEND,
    0,
    0,
    NB_ClientOpen,
    0, // No SendRecv on winsock
    CO_SyncRecv,
    WS_Abort,
    WS_Close,
    NB_Send,
    NB_Recv,
    NB_SyncSend,
    0,  // turn on/off keep alives
    NBF_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // query client address support.
    0, // query local address
    0, // query client id support.
    0, // Impersonate
    0  // Revert
    };

const RPC_CONNECTION_TRANSPORT
NBT_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NB_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_nb_tcp"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(NB_CONNECTION),
    sizeof(NB_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NBT_MAX_SEND,
    0,
    0,
    NB_ClientOpen,
    0, // No SendRecv on winsock
    CO_SyncRecv,
    WS_Abort,
    WS_Close,
    NB_Send,
    NB_Recv,
    NB_SyncSend,
    0,  // turn on/off keep alives
    NBT_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // query client address support.
    0, // query local address
    0, // query client id support.
    0, // Impersonate
    0  // Revert
    };

const RPC_CONNECTION_TRANSPORT
NBI_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NB_TOWER_ID,
    IPX_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_nb_ipx"),
    "135",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(NB_CONNECTION),
    sizeof(NB_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NBI_MAX_SEND,
    0,
    0,
    NB_ClientOpen,
    0, // No SendRecv on winsock
    CO_SyncRecv,
    WS_Abort,
    WS_Close,
    NB_Send,
    NB_Recv,
    NB_SyncSend,
    0,  // turn on/off keep alives
    NBI_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // query client address support.
    0, // query local address
    0, // query client id support.
    0, // Impersonate
    0  // Revert
    };



const RPC_CONNECTION_TRANSPORT *
NB_TransportLoad (
    IN PROTOCOL_ID index
    )
{
    RPC_STATUS status;

    if (fWinsockLoaded == FALSE)
        {
        if (RPC_WSAStartup() == FALSE)
            {
            return 0;
            }
        fWinsockLoaded = TRUE;
        }

    if (fNetbiosLoaded == FALSE)
        {
        status = LoadNetbios();

        if (status != RPC_S_OK)
            {
            return 0;
            }

        fNetbiosLoaded = TRUE;
        }

    switch(index)
        {
        case NBF:
            return(&NBF_TransportInterface);
            break;
        case NBT:
            return(&NBT_TransportInterface);
            break;
        case NBI:
            return(&NBI_TransportInterface);
            break;
        default:
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "NB_TransportLoad called with index: %d\n",
                           index));

            ASSERT(0);
        }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\nptrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nptrans.cxx

Abstract:

    Named pipes specific transport interface layer.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/18/1996    Bits 'n pieces
    MarioGo    10/30/1996    ASync RPC + client side

--*/

#include <precomp.hxx>

#include <rpcqos.h> // mtrt for I_RpcParseSecurity

//
// Support functions not exported to the runtime
//

// Hard coded world (aka EveryOne) SID
const SID World = { 1, 1, { 0, 0, 0, 0, 0, 1}, 0};

// Hard coded world (aka EveryOne) SID
const SID AnonymousLogonSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID};

RPC_STATUS
NMP_SetSecurity(
    IN NMP_ADDRESS *pAddress,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    If the caller supplies an SD this validates and makes a copy of the
    security descriptor.  Otherwise is generates a good default SD.

Arguments:

    ThisAddress - Supplies the address which will own the security descriptor.

    SecurityDescriptor - Supplies the security descriptor to be copied.

Return Value:

    RPC_S_OK - Everyone is happy; we successfully duplicated the security
        descriptor.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is invalid.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to duplicate the
        security descriptor.

--*/
{
    BOOL b;
    SECURITY_DESCRIPTOR_CONTROL    Control;
    DWORD Revision;
    DWORD BufferLength;

    if ( SecurityDescriptor == 0 )
        {
        // By default, RPC will create a SD which only allows the process owner to
        // create more pipe instances.  This prevents other users from stealing
        // the pipe.

        pAddress->SecurityDescriptor = new SECURITY_DESCRIPTOR;
        if (   pAddress->SecurityDescriptor == 0
            || !InitializeSecurityDescriptor(pAddress->SecurityDescriptor,
                                           SECURITY_DESCRIPTOR_REVISION) )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        // Open our thread token and pull out the owner SID.  This is SID will be
        // added to the DACL below.

        ASSERT(GetSidLengthRequired(SID_MAX_SUB_AUTHORITIES) <= 0x44);

        DWORD cTokenOwner = sizeof(TOKEN_OWNER) + 0x44;
        PVOID buffer[sizeof(TOKEN_OWNER) + 0x44];
        PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER)buffer;
        HANDLE hToken;

        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }

        b = GetTokenInformation(hToken, TokenOwner, pTokenOwner, cTokenOwner, &cTokenOwner);

        ASSERT(cTokenOwner <= sizeof(buffer));

        CloseHandle(hToken);

        if (!b)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }

        // Now allocate the ACL and add the owner and EveryOne (world) ACEs and Anonymous Logon ACESs

        DWORD size = 3*sizeof(ACCESS_ALLOWED_ACE) + sizeof(World) + sizeof(AnonymousLogonSid) + 0x44;
        PACL pdacl = new(size) ACL;
        ULONG ldacl = size + sizeof(ACL);

        if (NULL == pdacl)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        ASSERT(IsValidSid((PVOID)&World));
        ASSERT(IsValidSid((PVOID)&AnonymousLogonSid));

        InitializeAcl(pdacl, ldacl, ACL_REVISION);

        if (!AddAccessAllowedAce(pdacl, ACL_REVISION,
                                 (FILE_GENERIC_READ|FILE_GENERIC_WRITE)&(~FILE_CREATE_PIPE_INSTANCE),
                                 (PVOID)&World))
            {
            ASSERT(0);
            return(RPC_S_OUT_OF_RESOURCES);
            }
        if (!AddAccessAllowedAce(pdacl, ACL_REVISION,
                                 (FILE_GENERIC_READ|FILE_GENERIC_WRITE)&(~FILE_CREATE_PIPE_INSTANCE),
                                 (PVOID)&AnonymousLogonSid ))
            {
            ASSERT(0);
            return(RPC_S_OUT_OF_RESOURCES);
            }

        if (!AddAccessAllowedAce(pdacl, ACL_REVISION, FILE_ALL_ACCESS, pTokenOwner->Owner))
            {
            ASSERT(0);
            return(RPC_S_OUT_OF_RESOURCES);
            }

        if (!SetSecurityDescriptorDacl(pAddress->SecurityDescriptor, TRUE, pdacl, FALSE))
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }

        return(RPC_S_OK);
        }

    // Caller supplied SecurityDescriptor.  Make sure it is valid and, if needed, make a
    // self relative copy.

    if ( IsValidSecurityDescriptor(SecurityDescriptor) == FALSE )
        {
        return(RPC_S_INVALID_SECURITY_DESC);
        }

    if (FALSE == GetSecurityDescriptorControl(SecurityDescriptor, &Control, &Revision))
        {
        return(RPC_S_INVALID_SECURITY_DESC);
        }

    if (Control & SE_SELF_RELATIVE)
        {
        // Already self-relative, just copy it.

        BufferLength = GetSecurityDescriptorLength(SecurityDescriptor);
        ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR));
        pAddress->SecurityDescriptor = new(BufferLength
                                           - sizeof(SECURITY_DESCRIPTOR))
                                           SECURITY_DESCRIPTOR;
        if (pAddress->SecurityDescriptor == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        memcpy(pAddress->SecurityDescriptor, SecurityDescriptor, BufferLength);
        return(RPC_S_OK);
        }

    // Make self-relative and copy it.
    BufferLength = 0;
    b = MakeSelfRelativeSD(SecurityDescriptor, 0, &BufferLength);
    ASSERT(b == FALSE);
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
        return(RPC_S_INVALID_SECURITY_DESC);
        }

    //
    // self-relative SD's can be of different size than the original SD.
    //

    ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR_RELATIVE));
    pAddress->SecurityDescriptor = new(BufferLength
                                       - sizeof(SECURITY_DESCRIPTOR_RELATIVE))
                                   SECURITY_DESCRIPTOR;

    if (pAddress->SecurityDescriptor == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    b = MakeSelfRelativeSD(SecurityDescriptor,
                           pAddress->SecurityDescriptor,
                           &BufferLength);

    if (b == FALSE)
        {
        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        delete pAddress->SecurityDescriptor;
        return(RPC_S_OUT_OF_MEMORY);
        }

    return(RPC_S_OK);
}

//
// Functions exported to the RPC runtime.
//

RPC_STATUS RPC_ENTRY
NMP_AbortHelper(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Closes a connection, will be called only before NMP_Close() and
    maybe called by several threads at once.  It must also handle
    the case where another thread is about to start IO on the connection.

Arguments:

    Connection - pointer to a server connection object to abort.

Return Value:

    RPC_S_OK

--*/
{
    HANDLE h;
    BOOL b;
    PNMP_CONNECTION p = (PNMP_CONNECTION)Connection;

    if (InterlockedIncrement(&p->fAborted) != 1)
        {
        // Another thread beat us to it.  Normal during a call to NMP_Close.
        return(RPC_S_OK);
        }

    I_RpcLogEvent(SU_TRANS_CONN, EV_ABORT, Connection, 0, 0, 1, 2);


    // Wait for any threads which are starting IO to do so.
    while(p->IsIoStarting())
        Sleep(1);

    RTL_SOFT_ASSERT(p->fAborted != 0 && p->IsIoStarting() == 0);

    if (p->type & SERVER)
        {
        if (fDontFlush == 0)
            {
            // This will block until all pending writes on the connection
            // have been read. Needed on the server which writes (example: a
            // a fault) and closes the connection.
            b = FlushFileBuffers(p->Conn.Handle);

            //
            // the above call can fail if the pipe was disconnected
            //
            }

        // Once a pipe instance has been disconnected, it can be reused
        // for a future client connection.  Each NMP address keeps a
        // small cache of free pipe instances.  This is a performance
        // optimization.

        ASSERT(p->pAddress);

        b = DisconnectNamedPipe(p->Conn.Handle);
        if (b)
            {
            // will zero out Conn.Handle if it fits in the cache
            p->pAddress->sparePipes.CheckinHandle(&(p->Conn.Handle));
            }
        // else nothing - code down below will close it

        h = p->Conn.Handle;
        }
    else
        {
        ASSERT(p->pAddress == 0);
        h = p->Conn.Handle;
        }

    if (h)
        {
        b = CloseHandle(h);
        ASSERT(b);
        }

    return(RPC_S_OK);
}

RPC_STATUS NMP_CONNECTION::Abort(void)
{
    return NMP_AbortHelper(this, 0);
}


RPC_STATUS
RPC_ENTRY
NMP_Close(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Actually cleans up the resources associated with a connection.
    This is called exactly once one any connection.  It may or
    may not have previously been aborted.

Arguments:

    ThisConnection - pointer to the connection object to close.

Return Value:

    RPC_S_OK

--*/
{
    BOOL b;
    HANDLE h;

    PNMP_CONNECTION p = (PNMP_CONNECTION)ThisConnection;

    NMP_AbortHelper(ThisConnection, fDontFlush);

    if (p->iLastRead)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Closing connection %p with left over data (%d) %p \n",
                       p,
                       p->iLastRead,
                       p->pReadBuffer));
        }

    TransConnectionFreePacket(p, p->pReadBuffer);
    p->pReadBuffer = 0;

    return(RPC_S_OK);
}

void RPC_ENTRY
NMP_ServerAbortListen(
    IN RPC_TRANSPORT_ADDRESS Address
    )
/*++

Routine Description:

    This routine will be called if an error occurs in setting up the
    address between the time that SetupWithEndpoint or SetupUnknownEndpoint
    successfully completed and before the next call into this loadable
    transport module.  We need to do any cleanup from Setup*.

Arguments:

    pAddress - The address which is being aborted.

Return Value:

    None

--*/
{
    NMP_ADDRESS *p = (NMP_ADDRESS *)Address;

    // p->Endpoint is actually a pointer into p->LocalEndpoint

    delete p->SecurityDescriptor;
    delete p->LocalEndpoint;
    delete p->pAddressVector;

    // These are zero except when everything is setup ok.

    ASSERT(p->hConnectPipe == 0);
    ASSERT(p->sparePipes.IsSecondHandleUsed() == FALSE);

    return;
}


RPC_STATUS
NMP_CreatePipeInstance(
    NMP_ADDRESS *pAddress
    )
/*++

Routine Description:

    Wrapper around CreateNamedPipe.

Return Value:

    RPC_S_OK - A new pipe instance created.
    RPC_P_FOUND_IN_CACHE - Found a pipe instance to recycle.

    RPC_S_OUT_OF_MEMORY
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INTERNAL_ERROR

--*/
{
    RPC_STATUS status;
    SECURITY_ATTRIBUTES sa;


    ASSERT(pAddress->hConnectPipe == 0);

    sa.lpSecurityDescriptor = pAddress->SecurityDescriptor;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);

    // See if there are any cached pipe instances to reuse.

    pAddress->hConnectPipe = pAddress->sparePipes.CheckOutHandle();
    if (pAddress->hConnectPipe)
        return(RPC_P_FOUND_IN_CACHE);

    // The cache is empty, create a new pipe instance

    pAddress->hConnectPipe = CreateNamedPipeW(pAddress->LocalEndpoint,
                                              PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                                              PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE,
                                              PIPE_UNLIMITED_INSTANCES,
                                              2048,
                                              2048,
                                              NMPWAIT_USE_DEFAULT_WAIT,
                                              &sa);

    if (pAddress->hConnectPipe != INVALID_HANDLE_VALUE)
        {
        return(RPC_S_OK);
        }

    pAddress->hConnectPipe = 0;
    switch(GetLastError())
        {
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_NOT_ENOUGH_QUOTA:
        case ERROR_NO_SYSTEM_RESOURCES:
            {
            status = RPC_S_OUT_OF_MEMORY;
            break;
            }
        case ERROR_FILE_NOT_FOUND:
        case ERROR_INVALID_NAME:
        case ERROR_PATH_NOT_FOUND:
            {
            status = RPC_S_INVALID_ENDPOINT_FORMAT;
            break;
            }
        case ERROR_ACCESS_DENIED:
            {
            // An odd mapping, but this error means the pipe already exists
            // which is what this error means.
            status = RPC_S_DUPLICATE_ENDPOINT;
            break;
            }
        default:
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "CreateNamedPipe failed: %d\n",
                           GetLastError() ));

            ASSERT(0);
            status = RPC_S_INTERNAL_ERROR;
            }
        }

    return(status);
}


inline
RPC_STATUS
NMP_ConnectNamedPipe(
    NMP_ADDRESS *pAddress
    )
/*++

Routine Description:

    Inline wrapper for ConnectNamedPipe.

Arguments:

    pAddress - The address to use to connect.

Return Value:

    RPC_S_OK
    ConnectNamedPipe() error
--*/
{
    RPC_STATUS status;

    BOOL b = ConnectNamedPipe(pAddress->hConnectPipe,
                              &pAddress->Listen.ol);

    if (!b)
        {
        status = GetLastError();

        switch(status)
            {
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_IO_PENDING:
            case ERROR_PIPE_CONNECTED:
            case ERROR_NO_SYSTEM_RESOURCES:
                {
                break;
                }

            case ERROR_NO_DATA:
                {
                b = CloseHandle(pAddress->hConnectPipe);
                ASSERT(b);
                pAddress->hConnectPipe = 0;
                break;
                }

            default:
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "ConnectNamedPipe failed: %d\n",
                               status));

                ASSERT(0);
                }
            }
        }
    else
        {
        status = RPC_S_OK;
        }

    return(status);
}


void
NMP_SubmitConnect(
    IN BASE_ADDRESS *Address
    )
/*++

Routine Description:

    Called on an address without a pending connect pipe or on an address
    who previous connect pipe has been aborted.

Arguments:

    Address - The address to submit the connect on.

Return Value:

    None

--*/
{
    RPC_STATUS status;
    NMP_ADDRESS *pAddress = (NMP_ADDRESS *)Address;
    BOOL b;

    //
    // We may or may not need to create a new instance.  If a previous
    // ConnectNamedPipe was aborted then the existing instance is ok.
    //

    if (pAddress->hConnectPipe == 0)
        {

        status = NMP_CreatePipeInstance(pAddress);

        if (status == RPC_S_OK)
            {
            status = COMMON_PrepareNewHandle(pAddress->hConnectPipe);
            }
        else
            {
            if (status == RPC_P_FOUND_IN_CACHE)
                {
                status = RPC_S_OK;
                }
            }

        if (status != RPC_S_OK)
            {
            if (pAddress->hConnectPipe)
                {
                b = CloseHandle(pAddress->hConnectPipe);
                ASSERT(b);
                pAddress->hConnectPipe = 0;
                }

            COMMON_AddressManager(pAddress);
            return;
            }
        }

    status = NMP_ConnectNamedPipe(pAddress);

    if (status == ERROR_PIPE_CONNECTED)
        {
        // When a client connects here means that there will not be an IO
        // completion notification for this connection. We could call
        // NMP_NewConnection here but that makes error handling hard.  We'll
        // just post the notification directly.

        b = PostQueuedCompletionStatus(RpcCompletionPort,
                                       0,
                                       TRANSPORT_POSTED_KEY,
                                       &pAddress->Listen.ol);

        if (!b)
            {
            // Give up on this connection.
            b = CloseHandle(pAddress->hConnectPipe);
            ASSERT(b);
            pAddress->hConnectPipe = 0;
            COMMON_AddressManager(pAddress);
            }
        return;
        }

    if (status != ERROR_IO_PENDING)
        {
        COMMON_AddressManager(pAddress);
        }

    return;
}


RPC_STATUS
NMP_NewConnection(
    IN PADDRESS Address,
    OUT PCONNECTION *ppConnection
    )
/*++

Routine Description:

    Called when an ConnectNamedPipe completes on the main recv any thread.

    Can't fail after it calls I_RpcTransServerNewConnection().

Arguments:

    pAddress - The address used as context in a previous AcceptEx.
    ppConnection - A place to store the new pConnection.  Used
        when a connection been created and then a failure occurs.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS status;

    NMP_ADDRESS *pAddress = (NMP_ADDRESS *)Address;
    HANDLE hClient = pAddress->hConnectPipe;
    NMP_CONNECTION *pConnection;

    // First, submit an new instance for the next client

    pAddress->hConnectPipe = 0;
    NMP_SubmitConnect(pAddress);

    // Allocate a new connection object

    pConnection = (PNMP_CONNECTION)I_RpcTransServerNewConnection(pAddress);

    *ppConnection = pConnection;

    if (!pConnection)
        {
        CloseHandle(hClient);
        return(RPC_S_OUT_OF_MEMORY);
        }

    // Got a good connection, initialize it..
    // start with the vtbl
    pConnection = new (pConnection) NMP_CONNECTION;
    pConnection->type = SERVER | CONNECTION;
    pConnection->id = NMP;
    pConnection->Conn.Handle = hClient;
    pConnection->fAborted = 0;
    pConnection->pReadBuffer = 0;
    pConnection->maxReadBuffer = 0;
    pConnection->iLastRead = 0;
    pConnection->iPostSize = gPostSize;
    memset(&pConnection->Read.ol, 0, sizeof(pConnection->Read.ol));
    pConnection->Read.pAsyncObject = pConnection;
    pConnection->InitIoCounter();
    pConnection->pAddress = pAddress;

    return(RPC_S_OK);
}

RPC_CHAR *
ULongToHexString (
    IN RPC_CHAR * String,
    IN unsigned long Number
    );

#ifdef TRANSPORT_DLL

RPC_CHAR *
ULongToHexString (
    IN RPC_CHAR * String,
    IN unsigned long Number
    )
/*++

Routine Description:

    We convert an unsigned long into hex representation in the specified
    string.  The result is always eight characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned long to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 28) & 0x0F];
    *String++ = HexDigits[(Number >> 24) & 0x0F];
    *String++ = HexDigits[(Number >> 20) & 0x0F];
    *String++ = HexDigits[(Number >> 16) & 0x0F];
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}
#endif

RPC_STATUS
NMP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN PWSTR NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    This routine allocates a new pipe to receive new client connections.
    If successful a call to NMP_CompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur.  Setup
    before the call to NMP_CompleteListen() can be stopped after this
    function call with a call to NMP_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (pipe) to listen on.  Set
        to listened pipe for dynamic endpoints.
    PendingQueueSize - Meaningless for named pipes.
    EndpointFlags - Meaningless for named pipes.
    NICFlags - Meaningless for named pipes.
    SecurityDescriptor - The SD to associate with this address.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_SECURITY_DESC

--*/
{
    BOOL b;
    INT i;
    RPC_STATUS status;
    PWSTR LocalPipeEndpoint;
    PNMP_ADDRESS pAddress = (PNMP_ADDRESS)ThisAddress;
    BOOL fEndpointCreated = FALSE;

    pAddress->type = ADDRESS;
    pAddress->id = NMP;
    pAddress->NewConnection = NMP_NewConnection;
    pAddress->SubmitListen = NMP_SubmitConnect;
    pAddress->InAddressList = NotInList;
    pAddress->pNext = 0;
    pAddress->hConnectPipe = 0;
    memset(&pAddress->Listen, 0, sizeof(BASE_OVERLAPPED));
    pAddress->Listen.pAsyncObject = pAddress;
    pAddress->pAddressVector = 0;
    pAddress->LocalEndpoint = 0;
    pAddress->Endpoint = 0;
    pAddress->pNextAddress = 0;
    pAddress->pFirstAddress = pAddress;
    pAddress->sparePipes.Init();


    // Determine the network address we'll try to listen on

    if (*pEndpoint)
        {
        // User specified an endpoint to use.

        if (RpcpStringNCompare(*pEndpoint, RPC_CONST_STRING("\\pipe\\"), 6) != 0)
            return(RPC_S_INVALID_ENDPOINT_FORMAT);

        i = RpcpStringLength(*pEndpoint) + 1 + 3; // NULL, \\, \\, .

        LocalPipeEndpoint = new RPC_CHAR[i];

        if (NULL == LocalPipeEndpoint)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        LocalPipeEndpoint[0] = L'\\';
        LocalPipeEndpoint[1] = L'\\';
        LocalPipeEndpoint[2] = L'.';
        RpcpStringCopy(&LocalPipeEndpoint[3], *pEndpoint);
        }
    else
        {
        // Make up an endpoint to use.
        // Format: \\.\pipe\<pid in hex (8).<counter in hex (3)>\0

        static LONG EndpointCounter = 0;

        LocalPipeEndpoint = new RPC_CHAR[3 + 6 + 8 + 1 + 3 + 1];

        if (NULL == LocalPipeEndpoint)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        LONG counter;
        PWSTR pwstrT = LocalPipeEndpoint;

        *pwstrT++ = RPC_CONST_CHAR('\\');
        *pwstrT++ = RPC_CONST_CHAR('\\');
        *pwstrT++ = RPC_CONST_CHAR('.');
        *pwstrT++ = RPC_CONST_CHAR('\\');
        *pwstrT++ = RPC_CONST_CHAR('p');
        *pwstrT++ = RPC_CONST_CHAR('i');
        *pwstrT++ = RPC_CONST_CHAR('p');
        *pwstrT++ = RPC_CONST_CHAR('e');
        *pwstrT++ = RPC_CONST_CHAR('\\');
        pwstrT = ULongToHexString(pwstrT, GetCurrentProcessId());
        *pwstrT++ = RPC_CONST_CHAR('.');
        counter = InterlockedExchangeAdd(&EndpointCounter, 1);
        *pwstrT++ = HexDigits[(counter >> 8) & 0x0F];
        *pwstrT++ = HexDigits[(counter >> 4) & 0x0F];
        *pwstrT++ = HexDigits[counter & 0x0F];
        *pwstrT = 0;

        *pEndpoint = DuplicateString(LocalPipeEndpoint + 3);
        if (!(*pEndpoint))
            {
            delete LocalPipeEndpoint;
            return RPC_S_OUT_OF_MEMORY;
            }

        fEndpointCreated = TRUE;
        }

    // Security setup

    status = NMP_SetSecurity(pAddress, SecurityDescriptor);

    if (status != RPC_S_OK)
        {
        delete LocalPipeEndpoint;
        if (fEndpointCreated)
            delete *pEndpoint;
        return(status);
        }

    // Network address setup

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + (3 + gdwComputerNameLength) * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (NULL == pVector)
        {
        NMP_ServerAbortListen(pAddress);
        delete LocalPipeEndpoint;
        if (fEndpointCreated)
            delete *pEndpoint;
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR *)&pVector->NetworkAddresses[1];

    RpcpStringCopy(pVector->NetworkAddresses[0], RPC_CONST_STRING("\\\\"));
    RpcpStringCat(pVector->NetworkAddresses[0], gpstrComputerName);

    //
    // Setup address
    //

    pAddress->Endpoint = LocalPipeEndpoint + 3;
    pAddress->LocalEndpoint = LocalPipeEndpoint;
    pAddress->pAddressVector = pVector;

    // We need to create two pipe instances to start with.  This is necessary
    // to avoid a race where a client connects and quickly disconnects.
    // Before the server can submit the next connect another client fails with
    // RPC_S_SERVER_UNAVAILABLE.  The extra pipe instance forces the client to
    // retry and everything works.

    HANDLE hSpares[2];

    for (i = 0; i < 2; i++)
        {
        status = NMP_CreatePipeInstance(pAddress);
        ASSERT(status != RPC_P_FOUND_IN_CACHE);

        if (status != RPC_S_OK)
            {
            ASSERT(pAddress->hConnectPipe == 0);
            break;
            }

        hSpares[i] = pAddress->hConnectPipe;
        pAddress->hConnectPipe = 0;

        status = COMMON_PrepareNewHandle(hSpares[i]);

        if (status != RPC_S_OK)
            {
            break;
            }
        }

    if (status != RPC_S_OK)
        {
        NMP_ServerAbortListen(pAddress);
        if (fEndpointCreated)
            delete *pEndpoint;
        return(status);
        }

    // Move the pipe instances back into the address.

    pAddress->sparePipes.CheckinHandle(&hSpares[0]);
    // assert that it succeeded (i.e. did not zero out the handle)
    ASSERT(hSpares[0] == NULL);

    pAddress->sparePipes.CheckinHandle(&hSpares[1]);
    ASSERT(hSpares[1] == NULL);

    //
    // Done with phase one, now return to the runtime and wait.
    //

    *ppAddressVector = pVector;

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
NMP_ConnectionImpersonateClient (
    IN RPC_TRANSPORT_CONNECTION SConnection
    )
// Impersonate the client at the other end of the connection.
{
    NMP_CONNECTION *p = (NMP_CONNECTION *)SConnection;
    BOOL b;

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    b = ImpersonateNamedPipeClient(p->Conn.Handle);

    p->OtherIOFinished();

    if (!b)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ImpersonateNamedPipeClient (%p) failed %d\n",
                       p,
                       GetLastError() ));

        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }
    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
NMP_ConnectionRevertToSelf (
    RPC_TRANSPORT_CONNECTION SConnection
    )
/*++

Routine Description:

    We want to stop impersonating the client. This means we want
    the current thread's security context to revert the the
    default.

Arguments:

    SConnection - unused

Return Value:

    RPC_S_OK

    RPC_S_INTERNAL_ERROR - Not impersonating or something else went wrong.
                           (Debug systems only)
--*/
{
    BOOL b;

    UNUSED(SConnection);

    b = RevertToSelf();

#if DBG
    if (!b)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "RevertToSelf failed %d\n",
                       GetLastError()));

        ASSERT(b);
        return(RPC_S_INTERNAL_ERROR);
        }
#endif

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
NMP_ConnectionQueryClientAddress(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the address of the client.  Uses an extended in NT 5
    ioctl to reterive the client machine name from named pipes.

Arguments:

    ThisConnection - The server connection of interest.
    NetworkAddress - Will contain the string on success.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/

{
    NTSTATUS NtStatus;
    RPC_STATUS status;
    IO_STATUS_BLOCK IoStatus;
    NMP_CONNECTION *p = (NMP_CONNECTION *)ThisConnection;
    FILE_PIPE_CLIENT_PROCESS_BUFFER_EX ClientProcess;
    HANDLE hEvent = I_RpcTransGetThreadEvent();
    DWORD size;

    ClientProcess.ClientComputerNameLength = 0;

    ASSERT(hEvent);

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    NtStatus = NtFsControlFile(p->Conn.Handle,
                               hEvent,
                               0,
                               0,
                               &IoStatus,
                               FSCTL_PIPE_QUERY_CLIENT_PROCESS,
                               0,
                               0,
                               &ClientProcess,
                               sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX));

    p->OtherIOFinished();

    if (NtStatus == STATUS_PENDING)
        {
        status = WaitForSingleObject(hEvent, INFINITE);
        ASSERT(status == WAIT_OBJECT_0);
        if (status != WAIT_OBJECT_0)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }
        }

    if (!NT_SUCCESS(NtStatus))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "QUERY_PIPE_PROCESS ioctl failed %x\n",
                       NtStatus));

        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (ClientProcess.ClientComputerNameLength == 0)
        {
        // Must be local, no ID.  Just copy the local computer name into the
        // buffer and continue.

        size = gdwComputerNameLength;  // Includes null
        wcscpy(ClientProcess.ClientComputerBuffer, gpstrComputerName);
        }
    else
        {
        ASSERT(wcslen(ClientProcess.ClientComputerBuffer) < 16);

        // Convert from bytes to characters, add one for the null.

        size = ClientProcess.ClientComputerNameLength/2 + 1;
        }

    *pNetworkAddress = new WCHAR[size];
    if (!*pNetworkAddress)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    wcscpy(*pNetworkAddress, ClientProcess.ClientComputerBuffer);

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
NMP_ConnectionQueryClientId (
    IN RPC_TRANSPORT_CONNECTION SConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess
    )
/*++

Routine Description:

    We want to query the identifier of the client process at the other
    of this named pipe.  Two pipes from the same client process will always
    return the same identifier for their client process.  Likewise, two
    pipes from different client processes will never return the same
    identifier for their respective client process.

    This is one of the few things you can't do in win32.

Arguments:

    SConnection - Supplies the named pipe instance for which we want to
        obtain the client process identifier.

    ClientProcess - Returns the identifier for the client process at the
        other end of this named pipe instance.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS status;
    IO_STATUS_BLOCK IoStatus;
    NMP_CONNECTION *p = (NMP_CONNECTION *)SConnection;
    FILE_PIPE_CLIENT_PROCESS_BUFFER ClientProcessBuffer;
    HANDLE hEvent = I_RpcTransGetThreadEvent();
    BOOL fLocal;

    ClientProcess->ZeroOut();

    ASSERT(hEvent);

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    NtStatus = NtFsControlFile(p->Conn.Handle,
                               hEvent,
                               0,
                               0,
                               &IoStatus,
                               FSCTL_PIPE_QUERY_CLIENT_PROCESS,
                               0,
                               0,
                               &ClientProcessBuffer,
                               sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER));

    p->OtherIOFinished();

    if (NtStatus == STATUS_PENDING)
        {
        status = WaitForSingleObject(hEvent, INFINITE);
        ASSERT(status == WAIT_OBJECT_0);
        if (status != WAIT_OBJECT_0)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }
        }

    if (NT_SUCCESS(NtStatus))
        {
        if (ClientProcessBuffer.ClientSession)
            {
            ClientProcessBuffer.ClientSession = 0;
            fLocal = FALSE;
            }
        else
            fLocal = TRUE;

        ClientProcess->SetNMPClientIdentifier(&ClientProcessBuffer, fLocal);
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
NMP_Initialize (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * NetworkOptions,
    IN BOOL fAsync
    )
/*++

Routine Description:

    Initialize the connection. This function is guaranteed to be called
    in the thread that called GetBuffer.

Arguments:

    ThisConnection - A place to store the connection
*/
{
    PNMP_CONNECTION pConnection = (PNMP_CONNECTION)ThisConnection;

    // use explicit placement to initialize vtbl
    pConnection = new (pConnection) NMP_CONNECTION;

    pConnection->id = NMP;
    pConnection->Initialize();
    pConnection->pAddress = 0;

    return RPC_S_OK;
}



RPC_STATUS
RPC_ENTRY
NMP_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_np"
    NetworkAddress - The name of the server, with or without the '\\'
    NetworkOptions - Options from the string binding.  For security:

        security=
            [anonymous|identification|impersonation|delegation]
            [dynamic|static]
            [true|false]

        All three fields must be present.  To specify impersonation
        with dynamic tracking and effective only, use the following
        string for the network options.

        "security=impersonation dynamic true"

    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite

    {Send,Recv}BufferSize - Ignored.

    CallTimeout - call timeout in milliseconds. Ignored for named pipes.

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given. Not used for named pipes.

    AdditionalCredentials - additional credentials that we were given. 
        Not used for named pipes.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_NETWORK_OPTIONS
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS Status;
    PNMP_CONNECTION pConnection = (PNMP_CONNECTION)ThisConnection;
    BOOL f;
    HANDLE hPipe;
    DWORD SecurityQOSFlags = 0;
    NTSTATUS NtStatus;
    UINT AddressLen ;
    UINT EndpointLen;
    HANDLE ImpersonationToken = 0;
    DWORD StartTickCount;
    DWORD RetryCount;
    BOOL fLocalAddress = FALSE;

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    if (NetworkOptions && *NetworkOptions)
        {
        //
        // Enable transport level security.
        //
        // By default named pipes (CreateFile) uses security with impersonation,
        // dynamic tracking and effective only enabled.
        //
        // RPC level security sits on top of this and provides other features.
        //
        // Named pipes security is controlled via an options string in the string
        // binding.  The runtime exports an API to parse the string which is used
        // here to do most of the work.
        //
        SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

        Status = I_RpcParseSecurity(NetworkOptions,
                                    &SecurityQualityOfService);

        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_INVALID_NETWORK_OPTIONS );
            goto Cleanup;
            }

        // Convert into SecurityQOS into CreateFile flags

        ASSERT(SECURITY_ANONYMOUS      == (SecurityAnonymous <<16));
        ASSERT(SECURITY_IDENTIFICATION == (SecurityIdentification <<16));
        ASSERT(SECURITY_IMPERSONATION  == (SecurityImpersonation <<16));
        ASSERT(SECURITY_DELEGATION     == (SecurityDelegation <<16));

        SecurityQOSFlags =   SECURITY_SQOS_PRESENT
                           | (SecurityQualityOfService.ImpersonationLevel << 16);

        SecurityQOSFlags |= (SecurityQualityOfService.ContextTrackingMode
                             != SECURITY_STATIC_TRACKING) ? SECURITY_CONTEXT_TRACKING : 0;

        SecurityQOSFlags |= (SecurityQualityOfService.EffectiveOnly)
                             ? SECURITY_EFFECTIVE_ONLY : 0;
        }

    ASSERT(NetworkAddress);

    if (NetworkAddress[0] == '\\')
        {
        if (   NetworkAddress[1] == '\\'
            && NetworkAddress[2] != '\0'
            && NetworkAddress[3] != '\\')
            {
            NetworkAddress += 2;
            }
        else
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_INVALID_NET_ADDR, 
                EEInfoDLNMPOpen30, 
                NetworkAddress);

            Status = RPC_S_INVALID_NET_ADDR;
            goto Cleanup;
            }
        }

    if (   (NetworkAddress[0] == 0)
        || (RpcpStringCompare(NetworkAddress, gpstrComputerName) == 0) )
        {
        NetworkAddress = RPC_STRING_LITERAL(".");
        fLocalAddress = TRUE;
        }

    ASSERT(Endpoint);
    if (   Endpoint[0] != 0
        && RpcpStringNCompare(Endpoint, RPC_CONST_STRING("\\pipe\\"), 6) != 0)
        {
        Status = RPC_S_INVALID_ENDPOINT_FORMAT;
        goto Cleanup;
        }

    AddressLen = RpcpStringLength(NetworkAddress);
    EndpointLen = RpcpStringLength(Endpoint);

    RPC_CHAR *TransportAddress;
    TransportAddress = (RPC_CHAR *)alloca(   (2 + AddressLen + EndpointLen + 1)
                                           * sizeof(RPC_CHAR) );

    TransportAddress[0] = TransportAddress[1] = '\\';
    memcpy(TransportAddress + 2,
           NetworkAddress,
           AddressLen * sizeof(RPC_CHAR));

    memcpy(TransportAddress + 2 + AddressLen,
           Endpoint,
           (EndpointLen + 1) * sizeof(RPC_CHAR));

    ASSERT(   ((long)ConnTimeout >= RPC_C_BINDING_MIN_TIMEOUT)
           && (ConnTimeout <= RPC_C_BINDING_INFINITE_TIMEOUT));

    StartTickCount = GetTickCount();
    RetryCount = 0;
    do
        {
        hPipe = CreateFile((RPC_SCHAR *)TransportAddress,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            FILE_FLAG_OVERLAPPED | SecurityQOSFlags,
                            0
                           );

        if (hPipe != INVALID_HANDLE_VALUE)
            {
            DWORD Mode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

            f = SetNamedPipeHandleState(hPipe, &Mode, 0, 0);

            if (f)
                {
                Status = COMMON_PrepareNewHandle(hPipe);
                if (Status == RPC_S_OK)
                    {
                    break;
                    }
                else
                    {
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "COMMON_PrepareNewHandle: %d\n",
                                   GetLastError()));
                    }
                }
            else
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "SetNamedPipeHandleState: %d\n",
                               GetLastError()));

                Status = GetLastError();
                }

            CloseHandle(hPipe);
            hPipe = INVALID_HANDLE_VALUE;

            }
        else
            {
            Status = GetLastError();
            }

        if (Status != ERROR_PIPE_BUSY)
            {
            RpcpErrorAddRecord(fLocalAddress ? EEInfoGCNPFS : EEInfoGCRDR,
                Status, 
                EEInfoDLNMPOpen10, 
                TransportAddress,
                SecurityQOSFlags);

            switch(Status)
                {
                case ERROR_INVALID_NAME:
                    Status = RPC_S_INVALID_ENDPOINT_FORMAT;
                    break;

                case ERROR_BAD_NET_NAME:
                case ERROR_INVALID_NETNAME:
                    Status = RPC_S_INVALID_NET_ADDR;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_NOT_ENOUGH_QUOTA:
                case ERROR_COMMITMENT_LIMIT:
                case ERROR_TOO_MANY_OPEN_FILES:
                case ERROR_OUTOFMEMORY:
                    Status = RPC_S_OUT_OF_MEMORY;
                    break;

                case ERROR_NOT_ENOUGH_SERVER_MEMORY:
                    Status = RPC_S_SERVER_OUT_OF_MEMORY;
                    break;

                case ERROR_NO_SYSTEM_RESOURCES:
                case ERROR_WORKING_SET_QUOTA:
                    Status = RPC_S_OUT_OF_RESOURCES;
                    break;

                case ERROR_ACCESS_DENIED:
                case ERROR_ACCOUNT_EXPIRED:
                case ERROR_ACCOUNT_RESTRICTION:
                case ERROR_ACCOUNT_LOCKED_OUT:
                case ERROR_ACCOUNT_DISABLED:
                case ERROR_NO_SUCH_USER:
                case ERROR_BAD_IMPERSONATION_LEVEL:
                case ERROR_BAD_LOGON_SESSION_STATE:
                case ERROR_INVALID_PASSWORD:
                case ERROR_INVALID_LOGON_HOURS:
                case ERROR_INVALID_WORKSTATION:
                case ERROR_INVALID_SERVER_STATE:
                case ERROR_INVALID_DOMAIN_STATE:
                case ERROR_INVALID_DOMAIN_ROLE:
                case ERROR_LOGON_FAILURE:
                case ERROR_LICENSE_QUOTA_EXCEEDED:
                case ERROR_LOGON_NOT_GRANTED:
                case ERROR_LOGON_TYPE_NOT_GRANTED:
                case ERROR_MUTUAL_AUTH_FAILED:
                case ERROR_NETWORK_ACCESS_DENIED:
                case ERROR_NO_SUCH_DOMAIN:
                case ERROR_NO_SUCH_LOGON_SESSION:
                case ERROR_NO_LOGON_SERVERS:
                case ERROR_NO_TRUST_SAM_ACCOUNT:
                case ERROR_PASSWORD_EXPIRED:
                case ERROR_PASSWORD_MUST_CHANGE:
                case ERROR_TRUSTED_DOMAIN_FAILURE:
                case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
                case ERROR_WRONG_TARGET_NAME:
                case ERROR_WRONG_PASSWORD:
                case ERROR_TIME_SKEW:
                case ERROR_NO_TRUST_LSA_SECRET:
                case ERROR_LOGIN_WKSTA_RESTRICTION:
                case ERROR_SHUTDOWN_IN_PROGRESS:
                case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
                case ERROR_DOWNGRADE_DETECTED:
                case ERROR_CONTEXT_EXPIRED:
                    Status = RPC_S_ACCESS_DENIED;
                    break;

                //case ERROR_INTERNAL_ERROR:
                case ERROR_NOACCESS:
                // Really unexpected errors - fall into default on retail.
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "Unexpected error: %d\n",
                                   Status));

                    ASSERT(0);

                default:
                    VALIDATE(Status)
                        {
                        ERROR_REM_NOT_LIST,
                        ERROR_SHARING_PAUSED,
                        ERROR_NETNAME_DELETED,
                        ERROR_SEM_TIMEOUT,
                        ERROR_FILE_NOT_FOUND,
                        ERROR_PATH_NOT_FOUND,
                        ERROR_BAD_NETPATH,
                        ERROR_NETWORK_UNREACHABLE,
                        ERROR_UNEXP_NET_ERR,
                        ERROR_REQ_NOT_ACCEP,
                        ERROR_GEN_FAILURE,
                        ERROR_BAD_NET_RESP,
                        ERROR_PIPE_NOT_CONNECTED,
                        ERROR_NETLOGON_NOT_STARTED,
                        ERROR_DOMAIN_CONTROLLER_NOT_FOUND,
                        ERROR_CONNECTION_ABORTED,
                        ERROR_CONNECTION_INVALID,
                        ERROR_HOST_UNREACHABLE,
                        ERROR_CANT_ACCESS_DOMAIN_INFO,
                        ERROR_DUP_NAME,
                        ERROR_NO_SUCH_PACKAGE,
                        ERROR_INVALID_FUNCTION,
                        ERROR_BAD_DEV_TYPE
                        } END_VALIDATE;
                    Status = RPC_S_SERVER_UNAVAILABLE;
                    break;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status, 
                EEInfoDLNMPOpen40);

            goto Cleanup;
            }

        ASSERT(hPipe == INVALID_HANDLE_VALUE);

        // No pipe instances available, wait for one to show up...

        WaitNamedPipe((RPC_SCHAR *)TransportAddress, 1000);

        // attempt the connect for at least 40 seconds and at least 20 times
        // note that since this is DWORD, even if the counter has wrapped
        // the difference will be accurate
        RetryCount ++;
        }
    while ((GetTickCount() - StartTickCount < 40000) || (RetryCount <= 20));

    if (hPipe == INVALID_HANDLE_VALUE)
        {
        Status = RPC_S_SERVER_TOO_BUSY;
        RpcpErrorAddRecord(fLocalAddress ? EEInfoGCNPFS : EEInfoGCRDR,
            Status, 
            EEInfoDLNMPOpen20,
            TransportAddress);
        // No instances available
        goto Cleanup;
        }

    // Pipe opened successfully

    pConnection->Conn.Handle = hPipe;
    pConnection->fAborted = 0;
    pConnection->pReadBuffer = 0;
    pConnection->maxReadBuffer = 0;
    pConnection->iPostSize = gPostSize;
    pConnection->iLastRead = 0;
    memset(&pConnection->Read.ol, 0, sizeof(pConnection->Read.ol));
    pConnection->Read.pAsyncObject = pConnection;
    pConnection->Read.thread       = 0;
    pConnection->Read.ol.Internal = 0;
    pConnection->InitIoCounter();
    pConnection->pAddress = 0;

    Status = RPC_S_OK;

Cleanup:


    return(Status);
}


RPC_STATUS
RPC_ENTRY
NMP_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Sends a message on the connection.  This method must appear
    to be synchronous from the callers perspective.

Arguments:

    pConnection - The connection.
    Buffer - The data to send.
    BufferLength - The size of the buffer.
    fDisableShutdownCheck - N/A to named pipes.

Return Value:

    RPC_S_OK - Data sent
    RPC_P_SEND_FAILED - Connection will be aborted if this is returned.
    RPC_S_CALL_CANCELLED - The call was cancelled

--*/
{
    NMP_CONNECTION *p = (NMP_CONNECTION *)Connection;
    DWORD bytes;
    RPC_STATUS status;
    OVERLAPPED olWrite;
    HANDLE hEvent;
    BOOL fPendingReturned = FALSE;

    hEvent = I_RpcTransGetThreadEvent();

    ASSERT(hEvent);

    p->StartingWriteIO();

    if (p->fAborted)
        {
        p->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    // Setting the low bit of the event indicates that the write
    // completion should NOT be sent to the i/o completion port.
    olWrite.Internal = 0;
    olWrite.InternalHigh = 0;
    olWrite.Offset = 0;
    olWrite.OffsetHigh = 0;
    olWrite.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (Buffer, BufferLength, 0);
        }
#endif

    status = p->NMP_CONNECTION::Send(p->Conn.Handle,
                            Buffer,
                            BufferLength,
                            &bytes,
                            &olWrite
                            );

    p->WriteIOFinished();

    if (status == RPC_S_OK)
        {
        ASSERT(bytes == BufferLength);
        return(RPC_S_OK);
        }

    if (status == ERROR_IO_PENDING)
        {
        fPendingReturned = TRUE;
        // if fDisableCancelCheck - not alertable. Else, alertable.
        status = UTIL_GetOverlappedResultEx(Connection,
                                            &olWrite,
                                            &bytes,
                                            (fDisableCancelCheck ? FALSE : TRUE),
                                            Timeout);

        if (status == RPC_S_OK)
            {
            ASSERT(bytes == BufferLength);
            return(RPC_S_OK);
            }
        }

    ASSERT(status != ERROR_SUCCESS);

    RpcpErrorAddRecord(EEInfoGCNMP,
        status, 
        EEInfoDLNMPSyncSend10,
        (ULONGLONG)Connection,
        (ULONGLONG)Buffer,
        BufferLength,
        fPendingReturned);

    VALIDATE(status)
        {
        ERROR_NETNAME_DELETED,
        ERROR_GRACEFUL_DISCONNECT,
        ERROR_BROKEN_PIPE,
        ERROR_PIPE_NOT_CONNECTED,
        ERROR_NO_DATA,
        ERROR_NO_SYSTEM_RESOURCES,
        ERROR_WORKING_SET_QUOTA,
        ERROR_SEM_TIMEOUT,
        ERROR_UNEXP_NET_ERR,
        ERROR_BAD_NET_RESP,
        ERROR_HOST_UNREACHABLE,
        RPC_S_CALL_CANCELLED,
        ERROR_CONNECTION_ABORTED,
        ERROR_NOT_ENOUGH_QUOTA,
        RPC_P_TIMEOUT,
        ERROR_LOGON_FAILURE,
        ERROR_TIME_SKEW,
        ERROR_NETWORK_UNREACHABLE,
        ERROR_NO_LOGON_SERVERS
        } END_VALIDATE;

    p->NMP_CONNECTION::Abort();

    if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
        {
        // Wait for the write to finish.  Since we closed the pipe
        // this won't take very long.
        UTIL_WaitForSyncIO(&olWrite,
                           FALSE,
                           INFINITE);
        }
    else
        {
        status = RPC_P_SEND_FAILED;
        }

    return(status);
}

RPC_STATUS
RPC_ENTRY
NMP_SyncSendRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN UINT InputBufferSize,
    IN BUFFER InputBuffer,
    OUT PUINT pOutputBufferSize,
    OUT BUFFER *pOutputBuffer
    )
/*++

Routine Description:

    Sends a request to the server and waits to receive the next PDU
    to arrive at the connection.

Arguments:

    ThisConnection - The connection to wait on.
    InputBufferSize - The size of the data to send to the server.
    InputBuffer - The data to send to the server
    pOutputBufferSize - On return it contains the size of the PDU received.
    pOutputBuffer - On return contains the PDU received.

Return Value:

    RPC_S_OK

    RPC_P_SEND_FAILED - Connection aborted, data did not reach the server.
    RPC_P_RECEIVE_FAILED - Connection aborted, data might have reached
        the server.

--*/
{
    PNMP_CONNECTION p = (PNMP_CONNECTION)ThisConnection;
    BOOL b;
    DWORD bytes;
    DWORD readbytes;
    RPC_STATUS status;
    HANDLE hEvent;

    ASSERT(p->pReadBuffer == 0);
    ASSERT(p->iLastRead == 0);

    p->pReadBuffer = TransConnectionAllocatePacket(p, p->iPostSize);
    if (!p->pReadBuffer)
        {
        p->NMP_CONNECTION::Abort();
        return(RPC_P_SEND_FAILED);
        }

    hEvent = I_RpcTransGetThreadEvent();

    ASSERT(hEvent);

    p->Read.ol.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

    p->maxReadBuffer = p->iPostSize;
    bytes = p->maxReadBuffer;

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (InputBuffer, InputBufferSize, 0);
        }
#endif

    b = TransactNamedPipe(p->Conn.Handle,
                          InputBuffer,
                          InputBufferSize,
                          p->pReadBuffer,
                          bytes,
                          &bytes,
                          &p->Read.ol
                          );


    if (!b)
        {
        status = GetLastError();
        if (status == ERROR_IO_PENDING)
            {
            status = UTIL_GetOverlappedResult(p,
                                              &p->Read.ol,
                                              &bytes);
            }
        else
            {
            ASSERT(status != RPC_S_OK);
            }
        }
    else
        {
        status = RPC_S_OK;
        }

    if (status == RPC_S_OK)
        {
        // Success - got the whole reply in the transact

        *pOutputBuffer = p->pReadBuffer;
        p->pReadBuffer = 0;
        *pOutputBufferSize = bytes;

        ASSERT(bytes == MessageLength((PCONN_RPC_HEADER)*pOutputBuffer));

        return(RPC_S_OK);
        }

    if (status != ERROR_MORE_DATA)
        {
        RpcpErrorAddRecord(EEInfoGCNMP,
            status, 
            EEInfoDLNMPSyncSendReceive10,
            (ULONGLONG)p,
            (ULONGLONG)InputBuffer,
            InputBufferSize);

        if (status == ERROR_BAD_PIPE)
            {
            status = RPC_P_SEND_FAILED;
            }
        else
            {
            // surprisingly enough, ERROR_PIPE_NOT_CONNECTED can be
            // returned if the server died midway through the
            // operation.

            VALIDATE(status)
                {
                ERROR_NETNAME_DELETED,
                ERROR_GRACEFUL_DISCONNECT,
                ERROR_BROKEN_PIPE,
                ERROR_PIPE_BUSY,
                ERROR_NO_DATA,
                ERROR_NO_SYSTEM_RESOURCES,
                ERROR_SEM_TIMEOUT,
                ERROR_UNEXP_NET_ERR,
                ERROR_BAD_NET_RESP,
                ERROR_CONNECTION_ABORTED,
                ERROR_NETWORK_UNREACHABLE,
                ERROR_HOST_UNREACHABLE,
                ERROR_BAD_NETPATH,
                ERROR_REM_NOT_LIST,
                ERROR_ACCESS_DENIED,
                ERROR_NOT_ENOUGH_QUOTA,
                ERROR_LOGON_FAILURE,
                ERROR_TIME_SKEW,
                ERROR_PIPE_NOT_CONNECTED
                } END_VALIDATE;

            status = RPC_P_RECEIVE_FAILED;
            }

        p->NMP_CONNECTION::Abort();
        return(status);
        }

    // More data to read.

    ASSERT(p->Read.ol.InternalHigh == p->maxReadBuffer);

    ASSERT(MessageLength((PCONN_RPC_HEADER)p->pReadBuffer) > p->maxReadBuffer);

    bytes = p->maxReadBuffer;

    status = p->ProcessRead(bytes, pOutputBuffer, pOutputBufferSize);

    if (status == RPC_P_PARTIAL_RECEIVE)
        {
        // More to arrive, submit a read for all of it.

        status = CO_SubmitSyncRead(p, pOutputBuffer, pOutputBufferSize);

        if (status == RPC_P_IO_PENDING)
            {
            status = UTIL_GetOverlappedResult(p, &p->Read.ol, &bytes);

            // Since we read all the expected data and np is message mode
            // this should either fail or give back all the data.

            ASSERT(status != ERROR_MORE_DATA);

            if (status == RPC_S_OK)
                {
                status = p->ProcessRead(bytes, pOutputBuffer, pOutputBufferSize);

                ASSERT(status != RPC_P_PARTIAL_RECEIVE);
                }
            }
        }

    if (status != RPC_S_OK)
        {
        RpcpErrorAddRecord(EEInfoGCNMP,
            status, 
            EEInfoDLNMPSyncSendReceive20,
            (ULONGLONG)p,
            (ULONGLONG)InputBuffer,
            InputBufferSize);

        p->NMP_CONNECTION::Abort();
        if (status != RPC_P_TIMEOUT)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_P_RECEIVE_FAILED, 
                EEInfoDLNMPSyncSendReceive30,
                status);
            return(RPC_P_RECEIVE_FAILED);
            }
        else
            return (status);
        }

    ASSERT(*pOutputBufferSize == MessageLength((PCONN_RPC_HEADER)*pOutputBuffer));
    ASSERT(p->pReadBuffer == 0);

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY NMP_Abort(IN RPC_TRANSPORT_CONNECTION Connection)
{
    return ((NMP_CONNECTION *)Connection)->NMP_CONNECTION::Abort();
}


const RPC_CONNECTION_TRANSPORT
NMP_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NMP_TOWER_ID,
    UNC_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_np"),
    "\\pipe\\epmapper",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(NMP_ADDRESS),
    sizeof(NMP_CONNECTION),
    sizeof(NMP_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NMP_MAX_SEND,
    NMP_Initialize,
    0,
    NMP_Open,
    NMP_SyncSendRecv,
    CO_SyncRecv,
    NMP_Abort,
    NMP_Close,
    CO_Send,
    CO_Recv,
    NMP_SyncSend,
    0,  // turn on/off keep alives
    NMP_ServerListen,
    NMP_ServerAbortListen,
    COMMON_ServerCompleteListen,
    NMP_ConnectionQueryClientAddress,
    0, // query local address
    NMP_ConnectionQueryClientId,
    NMP_ConnectionImpersonateClient,
    NMP_ConnectionRevertToSelf,
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };

const RPC_CONNECTION_TRANSPORT *
NMP_TransportLoad (
    )
{
    return(&NMP_TransportInterface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\tower.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1999

    Module Name:

        Tower.cxx

    Abstract:

        Common code from building and exploding towers.  Each
        protocol supported by the transport interface needs
        a section in this file.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     11/11/1996    Bits 'n pieces

--*/

#include <precomp.hxx>

#ifndef UNALIGNED
#error UNALIGNED macro undefined
#endif

// Tower structures are totally packed
#include <pshpack1.h>

// CODE REVIEW: cleanup mtrt tower stuff and have only one copy of these.

typedef struct _FLOOR_0OR1 {
   unsigned short ProtocolIdByteCount;
   byte FloorId;
   UUID Uuid;
   unsigned short MajorVersion;
   unsigned short AddressByteCount;
   unsigned short MinorVersion;
 } FLOOR_0OR1;
typedef FLOOR_0OR1 UNALIGNED * PFLOOR_0OR1;

typedef struct _FLOOR_234 {
   unsigned short ProtocolIdByteCount;
   byte FloorId;
   unsigned short AddressByteCount;
   byte Data[2];
} FLOOR_234;
typedef FLOOR_234 UNALIGNED * PFLOOR_234;

typedef struct _FLOOR_2 {
   unsigned short ProtocolIdByteCount;
   byte RpcProtocol;
   unsigned short AddressByteCount;
   unsigned short RpcProtocolMinor;
} FLOOR_2;
typedef FLOOR_2 UNALIGNED * PFLOOR_2;

typedef struct _FLOOR_3 {
   unsigned short ProtocolIdByteCount;
   byte PortType;
   unsigned short AddressByteCount;
   char     EndPoint[2];
} FLOOR_3;
typedef FLOOR_3 UNALIGNED * PFLOOR_3;

typedef struct _FLOOR_4 {
   unsigned short ProtocolIdByteCount;
   byte HostType;
   unsigned short AddressByteCount;
   char Host[2];
} FLOOR_4;
typedef FLOOR_4 UNALIGNED * PFLOOR_4;

typedef struct _GENERIC_ID {
   UUID Uuid;
   unsigned short MajorVersion;
   unsigned short MinorVersion;
} GENERIC_ID;
typedef GENERIC_ID UNALIGNED * PGENERIC_ID;

#include <poppack.h>
// Restore normal packing

// Transport protocols defined in cotrans.hxx and dgtrans.hxx

// Given a FLOOR type and a pointer computes a pointer to the next floor.

#define NEXTFLOOR(t,x) (t)((byte *)x + ((t)x)->ProtocolIdByteCount        \
                                     + ((t)x)->AddressByteCount           \
                                     + sizeof(((t)x)->ProtocolIdByteCount)\
                                     + sizeof(((t)x)->AddressByteCount))

RPC_STATUS
RPC_ENTRY
COMMON_TowerConstruct(
    IN PCHAR Protseq,
    IN PCHAR NetworkAddress,
    IN PCHAR Endpoint,
    OUT PUSHORT Floors,
    OUT PULONG ByteCount,
    OUT PUCHAR *Tower
    )
/*++

Routine Description:

    Constructs a OSF tower for the protocol, network address and endpoint.

Arguments:

    Protseq - The protocol for the tower.
    NetworkAddress - The network address to be encoded in the tower.
    Endpoint - The endpoint to be encoded in the tower.
    Floors - The number of twoer floors it encoded into the tower.
    ByteCount - The size of the "upper-transport-specific" tower that
        is encoded by this call.
    Tower - The encoded "upper tower" that is encoded by this call.
        This caller is responsible for freeing this memory.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_RPC_PROTSEQ

--*/
{
    PFLOOR_234 Floor;
    ADDRINFO *AddrInfo;
    ADDRINFO Hint;

    INT index = MapProtseq(Protseq);

    if (index == 0)
        {
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    RPC_TRANSPORT_INTERFACE pInfo = TransportTable[index].pInfo;

    ASSERT(pInfo);

    if (Endpoint == NULL || *Endpoint == '\0')
        {
        Endpoint = pInfo->WellKnownEndpoint;
        }

    // Currently all protocols have 5 floors.  If a new protocol
    // is added with < 5 floors watch out in tower explode.

    *Floors = 5;

    // Figure out the size of the tower

    size_t addr_size;
    size_t ept_size;
    size_t size;

    // Figure out the endpoint size
    switch (index)
        {
        // Protocols which use port numbers (ushorts) as endpoints
        case TCP:
#ifdef SPX_ON
        case SPX:
#endif
        case HTTP:
        case UDP:
#ifdef IPX_ON
        case IPX:
#endif
            ept_size = 2;
            break;

        // Protocols which use strings as endpoints
        case NMP:
#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            ASSERT(Endpoint && *Endpoint);
            ept_size = strlen(Endpoint) + 1;
            break;
            }

        #if DBG
        default:
            ASSERT(0);
            return(RPC_S_INTERNAL_ERROR);
        #endif
        }

    // Figure out the address size
    switch(index)
        {
        // Protocols which use 4 bytes longs as the address size
        case TCP:
        case UDP:
        case HTTP:
            {
            addr_size = 4;
            break;
            }
#ifndef SPX_IPX_OFF
        // Protocols which use 10 byte (32+48 bit) address size
#ifdef SPX_ON
        case SPX:
#endif
#ifdef IPX_ON
        case IPX:
#endif
            {
            addr_size = 10;
            break;
            }
#endif

        // Protocols which use the string as the address
        case NMP:

#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            if ((NetworkAddress == NULL) || (*NetworkAddress== '\0'))
                {
                addr_size = 2;
                }
            else
                {
                addr_size = strlen(NetworkAddress) + 1;
                }
            break;
            }

        #if DBG
        default:
            ASSERT(0);
            return(RPC_S_INTERNAL_ERROR);
        #endif
        }


    // Compute total size.
    // Note: FLOOR_234 already contains 2 bytes of data.

    size = addr_size + ept_size + 2*(sizeof(FLOOR_234) - 2);

    // Allocate tower
    *Tower = new UCHAR[size];
    if (!*Tower)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    *ByteCount = size;

    // Now fill-in the endpoint part of the tower

    Floor = (PFLOOR_234)*Tower;
    Floor->ProtocolIdByteCount = 1;
    Floor->FloorId = (UCHAR)pInfo->TransId;

    switch(index)
        {
        // Protocols which use big endian ushorts
        case TCP:
        case HTTP:
#ifdef SPX_ON
        case SPX:
#endif
        case UDP:
#ifdef IPX_ON
        case IPX:
#endif
            {
            Floor->AddressByteCount = 2;
            USHORT port = (USHORT) atoi(Endpoint);
            port = htons(port);
            memcpy((char PAPI *)&Floor->Data[0], &port, 2);
            break;
            }

        // Protocols which use ansi strings
        case NMP:

#ifdef NETBIOS_ON
        case NBT:
        case NBF:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            Floor->AddressByteCount = (unsigned short) ept_size;
            memcpy(&Floor->Data[0], Endpoint, ept_size);
            break;
            }

        #if DBG
        default:
            ASSERT(0);
        #endif
        }

    // Move to the next tower and fill-in the address part of the tower

    Floor = NEXTFLOOR(PFLOOR_234, Floor);
    Floor->ProtocolIdByteCount = 1;
    Floor->FloorId = (unsigned char) pInfo->TransAddrId;

    switch (index)
        {
        // IP protocols use 4 byte big endian IP addreses
        case TCP:
        case HTTP:
        case UDP:
            {
            int err;

            RpcpMemorySet(&Hint, 0, sizeof(Hint));
            Hint.ai_flags = AI_NUMERICHOST;

            err = getaddrinfo(NetworkAddress, 
                NULL, 
                &Hint,
                &AddrInfo);

            if (err)
                {
                // if it's not a dot address, keep it zero
                RpcpMemorySet(&Floor->Data[0], 0, 4);  
                }
            else
                {
                RpcpMemoryCopy(&Floor->Data[0], &(((SOCKADDR_IN *)AddrInfo->ai_addr)->sin_addr.s_addr), 4);
                freeaddrinfo(AddrInfo);
                }

            Floor->AddressByteCount = 4;
            break;
            }

#ifndef SPX_IPX_OFF
        // IPX protocols use little endian net (32 bit) + node (48 bit) addresses
#ifdef SPX_ON
        case SPX:
#endif
#ifdef IPX_ON
        case IPX:
#endif
            {
            Floor->AddressByteCount = 10;
            memset(&Floor->Data[0], 0, 10);  // Zero is fine..
            break;
            }
#endif

        // Protocols which use string names.
        case NMP:

#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            if ((NetworkAddress) && (*NetworkAddress))
                {
                Floor->AddressByteCount = (unsigned short) addr_size;
                memcpy(&Floor->Data[0], NetworkAddress, addr_size);
                }
            else
                {
                Floor->AddressByteCount = 2;
                Floor->Data[0] = 0;
                }
            break;
            }

        #if DBG
        default:
            ASSERT(0);
        #endif
        }

    return(RPC_S_OK);
}

const INT HTTP_OLD_ADDRESS_ID = 0x20;

RPC_STATUS
RPC_ENTRY
COMMON_TowerExplode(
    IN PUCHAR Tower,
    OUT PCHAR *Protseq,
    OUT PCHAR *NetworkAddress,
    OUT PCHAR *Endpoint
    )
/*++

Routine Description:

    Decodes an OSF transport "upper tower" for the runtime.

Arguments:

    Tower - The encoded "upper tower" to decode
    Protseq - The protseq encoded in the Tower
        Does not need to be freed by the caller.
    NetworkAddress - The network address encoded in the Tower
        Must be freed by the caller.
    Endpoint - The endpoint encoded in the Tower.
        Must be freed by the caller.

Return Value:

    RPC_S_OK

    RPC_S_INVALID_RPC_PROTSEQ

    RPC_S_OUT_OF_MEMORY

--*/
{
    PFLOOR_234 Floor = (PFLOOR_234)Tower;
    PFLOOR_234 NextFloor = NEXTFLOOR(PFLOOR_234, Tower);
    RPC_STATUS Status = RPC_S_OK;
    INT Index;

    // Find the protocol based first on the ID from this floor,
    // and then the next floor.  We only dereference the next
    // floor if we match the ID on this floor.

    for (unsigned i = 1; i < cTransportTable; i++)
        {
        if (TransportTable[i].ProtocolTowerId == Floor->FloorId)
            {
            if (TransportTable[i].AddressTowerId == NextFloor->FloorId)
                break;

            // 
            // The & 0x0F is needed because the legacy server code incorrectly
            // cleared the high nibble before sending the address tower id
            //
            if ((TransportTable[i].AddressTowerId & 0x0F) == NextFloor->FloorId )
                break;

            // N.B. Old (Win9x/NT4) clients would send a AddressTowerId of 0x20
            // (HTTP_OLD_ADDRESS_ID). We need to match this as well.
            if ((Floor->FloorId == HTTP_TOWER_ID)
                && (NextFloor->FloorId == HTTP_OLD_ADDRESS_ID))
                break;

            }
        }

    if (i == cTransportTable)
        {
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    Index = i;

    RPC_TRANSPORT_INTERFACE pInfo = TransportTable[Index].pInfo;

    ASSERT(pInfo);

    //
    // Figure out the protseq
    //

    if (ARGUMENT_PRESENT(Protseq))
        {
        size_t len = RpcpStringLength(pInfo->ProtocolSequence);
        *Protseq = new char[len + 1];
        if (*Protseq)
            {
            RPC_CHAR *MySrc = (RPC_CHAR *) pInfo->ProtocolSequence;
            char *MyDest = *Protseq;

            while (*MyDest++ = (char) *MySrc++);
            }
        else
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    //
    // Figure out the endpoint
    //

    if (ARGUMENT_PRESENT(Endpoint))
        {
        Status = RPC_S_OUT_OF_MEMORY;

        switch(Index)
            {
            // Protocols which use strings as the endpoint format.
            case NMP:

#ifdef NETBIOS_ON
            case NBT:
            case NBI:
            case NBF:
#endif

#ifdef NCADG_MQ_ON
            case MSMQ:
#endif

#ifdef APPLETALK_ON
            case DSP:
#endif
                {
                *Endpoint = new CHAR[Floor->AddressByteCount];
                if (*Endpoint)
                    {
                    memcpy(*Endpoint, (PCHAR)&Floor->Data[0],
                           Floor->AddressByteCount);
                    Status = RPC_S_OK;
                    }
                }
                break;

            // Protocols which use ushort's as the endpoint format.
            case TCP:
#ifdef SPX_ON
            case SPX:
#endif
            case HTTP:
            case UDP:
#ifdef IPX_ON
            case IPX:
#endif
                {
                USHORT PortNum = *(PUSHORT)(&Floor->Data[0]);

                PortNum = RpcpByteSwapShort(PortNum);  // Towers are big endian.

                *Endpoint = new CHAR[6]; // 65535'\0'
                if (*Endpoint)
                    {
                    _itoa(PortNum, *Endpoint, 10);
                    Status = RPC_S_OK;
                    }
                }
                break;

            default:
                ASSERT(0);
            }

        if (Status != RPC_S_OK)
            {
            if (ARGUMENT_PRESENT(Protseq))
                {
                delete *Protseq;
                *Protseq = 0;
                }
            return(Status);
            }
        }

    //
    // Now the hard part, figure out the network address.
    //

    if (ARGUMENT_PRESENT(NetworkAddress))
        {
        Floor = NEXTFLOOR(PFLOOR_234, Floor);
        Status = RPC_S_OUT_OF_MEMORY;

        switch(Index)
            {
            // Protocols which use strings as their network address
            case NMP:

#ifdef NETBIOS_ON
            case NBF:
            case NBT:
            case NBI:
#endif

#ifdef NCADG_MQ_ON
            case MSMQ:
#endif

#ifdef APPLETALK_ON
            case DSP:
#endif
                *NetworkAddress = new CHAR[Floor->AddressByteCount];
                if (*NetworkAddress)
                    {
                    memcpy(*NetworkAddress,
                           &Floor->Data[0],
                           Floor->AddressByteCount);
                    Status = RPC_S_OK;
                    }
                break;

            // Protocols using IP addresses
            case TCP:
            case HTTP:
            case UDP:
                {

                if (Floor->AddressByteCount != 4)
                    {
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    break;
                    }

                struct in_addr in;
                in.S_un.S_un_b.s_b1 = Floor->Data[0];
                in.S_un.S_un_b.s_b2 = Floor->Data[1];
                in.S_un.S_un_b.s_b3 = Floor->Data[2];
                in.S_un.S_un_b.s_b4 = Floor->Data[3];

                PCHAR t = inet_ntoa(in);
                if (t)
                    {
                    *NetworkAddress = new CHAR[16+1];
                    if (*NetworkAddress)
                        {
                        strcpy(*NetworkAddress, t);
                        Status = RPC_S_OK;
                        }
                    }
                else
                    {
                    ASSERT(0);
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    }

                }
                break;

#ifndef SPX_IPX_OFF
            // Protocols using IPX 80 bit addresses
#ifdef SPX_ON
            case SPX:
#endif
#ifdef IPX_ON
            case IPX:
#endif
                {
                if (Floor->AddressByteCount != 10)
                    {
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    break;
                    }

                // Format: ~NNNNNNNNAAAAAAAAAAAA'\0'
                // Network number (32bits) and IEEE 802 address (48bits)

                *NetworkAddress = new CHAR[1 + 8 + 12 + 1];
                if (*NetworkAddress)
                    {
                    PCHAR p = *NetworkAddress;
                    PCHAR pInput = (PCHAR) &Floor->Data[0];
                    *p++ = '~';
                    for (int i = 0; i < 10; i++)
                        {
                        CHAR c = *pInput ++;
                        *p++ = (char) HexDigits[(c >> 4) & 0xF];
                        *p++ = (char) HexDigits[ c       & 0xF];
                        }
                    *p = '\0';
                    Status = RPC_S_OK;
                    }

                break;
                }
#endif
            }

        if (Status != RPC_S_OK)
            {
            if (ARGUMENT_PRESENT(Endpoint))
                {
                delete *Endpoint;
                *Endpoint = 0;
                }
            if (ARGUMENT_PRESENT(Protseq))
                {
                delete *Protseq;
                *Protseq = 0;
                }
            return(Status);
            }
        }

    ASSERT(Status == RPC_S_OK);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1989


Revision History:

!ENDIF

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=rpctrans

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK or LIBRARY)
#

TARGETPATH=obj
TARGETTYPE=LIBRARY

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..;..\..\..\mtrt;..\..\..\rtifs\$(O);..\..\..\charconv;$(BASE_INC_PATH);$(NET_INC_PATH)

#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

MSC_WARNING_LEVEL=/WX

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES= $(SOURCES)  \
    ..\afd.cxx      \
    ..\complete.cxx \
    ..\Cookie.cxx   \
    ..\loader.cxx   \
    ..\cotrans.cxx  \
    ..\dgtrans.cxx  \
    ..\HndlCach.cxx \
    ..\HTTP2.cxx    \
    ..\HttpRTS.cxx  \
    ..\muteximp.cxx \
    ..\nptrans.cxx  \
    ..\wsload.cxx   \
    ..\wstrans.cxx  \
    ..\tower.cxx    \
    ..\httptran.cxx \
    ..\httpreg.cxx  \
    ..\regexp.cxx   \
    ..\util.cxx     \
    ..\Protocol.cxx \
    ..\WHttpImp.cxx

i386_SOURCES= \
    ..\ipxname.cxx

C_DEFINES= $(C_DEFINES) -DWIN32RPC -D_RPCRT4_ -D_RPCTRANS_

UMTYPE=console

#
# Defining the NTTARGETFILES variable causes MAKEFILE.DEF to attempt to
# include .\makefile.inc immediately after it specifies the top
# level targets (all, clean and loc) and their dependencies.  MAKEFILE.DEF
# also expands the value of the NTTARGETFILES variable at the end of the
# list of dependencies for the all target.  Useful for specifying additional
# targets and dependencies that don't fit the general case covered by
# MAKEFILE.DEF
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\util.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

    Module Name:

        Util.cxx

    Abstract:

        Transport/protocol independent helper functions.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     2/21/1997    Bits 'n pieces

--*/

#include <precomp.hxx>

RPC_STATUS
EndpointToPortNumber(
    IN RPC_CHAR *endpoint,
    OUT USHORT &port)
/*++

Routine Description:

    Validates a unicode string which should contain a winsock (USHORT) port
    number and converts the string to an integer.

Arguments:

    endpoint - The port number as a unicode string
    port - If successful, the port number.

Return Value:

    RPC_S_OK
    RPC_S_INVALID_ENDPOINT_FORMAT

--*/
{
    RPC_CHAR *pT;

#ifdef UNICODE
    ULONG lport = wcstol(endpoint, &pT, 10);
#else
    ULONG lport = ANSI_strtol((const RPC_SCHAR *) endpoint, (RPC_SCHAR **) &pT, 10);
#endif

    if (lport == 0 || lport > 0xFFFF || *pT != 0)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    port = (USHORT)lport;

    return(RPC_S_OK);
}


RPC_STATUS
EndpointToPortNumberA(
    IN char *endpoint,
    OUT USHORT &port)
/*++

Routine Description:

    Validates an ANSI string which should contain a winsock (USHORT) port
    number and converts the string to an integer.

Arguments:

    endpoint - The port number as an ANSI string
    port - If successful, the port number.

Return Value:

    RPC_S_OK
    RPC_S_INVALID_ENDPOINT_FORMAT

--*/
{
    char *pT;

    ULONG lport = ANSI_strtol(endpoint, &pT, 10);

    if (lport == 0 || lport > 0xFFFF || *pT != 0)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    port = (USHORT)lport;

    return(RPC_S_OK);
}

void
PortNumberToEndpoint(
    IN USHORT port,
    OUT RPC_CHAR *pEndpoint
    )
{
    UNICODE_STRING UnicodeString;

    ASSERT(port);

    UnicodeString.Buffer = pEndpoint;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 6 * sizeof(RPC_CHAR);

    NTSTATUS status = RtlIntegerToUnicodeString(port, 0, &UnicodeString);
    ASSERT(NT_SUCCESS(status));
}

void
PortNumberToEndpointA(
    IN USHORT port,
    OUT char *pEndpoint
    )
{
    NTSTATUS status = RtlIntegerToChar(port, 
        10,                 // Base
        6 * sizeof(char),   // OutputLength
        pEndpoint);

    ASSERT(NT_SUCCESS(status));
}

inline
UCHAR ConvertHexDigit(UCHAR digit)
/*++

Routine Description:

    Converts a character containing '0'-'9', 'a'-'f' or 'A'-'F' into the
    equivalent binary value: 0x0 - 0xF.

Arguments:

    digit - The character to convert.

Return Value:

    The value of digit or zero if the digit is not a hex digit.

--*/
{
    UCHAR r;

    r = digit - '0';
    if (r < 10)
        {
        return(r);
        }

    r = digit - 'a';
    if (r < 6)
        {
        return(r + 10);
        }

    r = digit - 'A';
    if (r < 6)
        {
        return(r + 10);
        }

    ASSERT(0);
    return 0;
}

UCHAR
HexDigitsToBinary(
    IN UCHAR high,
    IN UCHAR low
    )
/*++

Routine Description:

    Builds an 8-bit value from two hex digits.

--*/
{
    return( ( ConvertHexDigit(high) << 4 ) | ConvertHexDigit(low) );
}

DWORD
UTIL_WaitForSyncIO(
    LPOVERLAPPED lpOverlapped,
    IN BOOL fAlertable,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    The special part is that the same event (this's threads event)
    maybe used for multiple IOs at once. If another one of those
    IOs completes, it is ignored.  This only returns when the IO
    specified by lpOverlapped finishes or an alert/timeout happens.

Arguments:

    lpOverlapped - The status block associated with the IO in question.
    fAlertable - If TRUE, the wait is alertable
    dwTimeout - Milliseconds to wait for the IO.

Return Value:

    Same as WaitForSingleObjectEx()

--*/

{
    DWORD status;

    for (;;)
        {
        if (HasOverlappedIoCompleted(lpOverlapped))
            {
            break;
            }

        status = WaitForSingleObjectEx(lpOverlapped->hEvent, dwTimeout, fAlertable);
        if (status != WAIT_OBJECT_0)
            {
            ASSERT(   (status == WAIT_IO_COMPLETION && fAlertable)
                   || (status == WAIT_TIMEOUT && (dwTimeout != INFINITE)));
            return(status);
            }

        if (HasOverlappedIoCompleted(lpOverlapped))
            {
            break;
            }

        // Another Io completed, just ignore it for now.

        ResetEvent(lpOverlapped->hEvent);
        }

    return(WAIT_OBJECT_0);
}

DWORD
UTIL_WaitForSyncHTTP2IO(
    IN LPOVERLAPPED lpOverlapped,
    IN HANDLE hEvent,
    IN BOOL fAlertable,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    The special part is that the same event (this's threads event)
    maybe used for multiple IOs at once. If another one of those
    IOs completes, it is ignored.  This only returns when the IO
    specified by lpOverlapped finishes or an alert/timeout happens.

Arguments:

    lpOverlapped - The status block associated with the IO in question.

    hEvent - the event to wait on

    fAlertable - If TRUE, the wait is alertable

    dwTimeout - Milliseconds to wait for the IO.

Return Value:

    Same as WaitForSingleObjectEx()

--*/

{
    DWORD status;

    ASSERT(hEvent);

    for (;;)
        {
        if (lpOverlapped->OffsetHigh)
            {
            break;
            }

        status = WaitForSingleObjectEx(hEvent, dwTimeout, fAlertable);
        if (status != WAIT_OBJECT_0)
            {
            ASSERT(   (status == WAIT_IO_COMPLETION && fAlertable)
                   || (status == WAIT_TIMEOUT && (dwTimeout != INFINITE)));
            return(status);
            }

        if (lpOverlapped->OffsetHigh)
            {
            break;
            }

        // Another Io completed, just ignore it for now.

        ResetEvent(hEvent);
        }

    return(WAIT_OBJECT_0);
}

RPC_STATUS
UTIL_GetOverlappedResultEx(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL fAlertable,
    DWORD dwTimeout
    )
/*++

Routine Description:

    Similar to the Win32 API GetOverlappedResult.

    Works with thread event based IO.  (even with multiple IOs/thread-event)
    Allows cancels

Arguments:

    ThisConnection - RPC runtime connection associated with this IO.

    lpOverlapped - Overlapped structure of the IO in progress.
        Must contain a valid hEvent member.

    lpNumberOfBytesTransferred - see GetOverlappedResult

    fAlertable - If true, RPC cancels are enabled. This means the
        wait must be alertable and must follow a protocol to determine
        if a call has been cancelled.

    dwTimeout - Milliseconds to wait

Return Value:

    RPC_S_Ok
    RPC_P_TIMEOUT
    RPC_S_CALL_CANCELLED

--*/
{
    BASE_ASYNC_OBJECT *Connection = (BASE_ASYNC_OBJECT *) ThisConnection;
    ASSERT(lpOverlapped->hEvent);

    RPC_STATUS status;
    DWORD canceltimeout = 0;

    for(;;)
        {
        // Wait for the IO to complete
        status = UTIL_WaitForSyncIO(lpOverlapped, fAlertable, dwTimeout);

        if (status == WAIT_OBJECT_0)
            {
            break;
            }

        if (status == WAIT_TIMEOUT)
            {
            ASSERT(dwTimeout != INFINITE);

            if (canceltimeout)
                {
                return(RPC_S_CALL_CANCELLED);
                }

            return(RPC_P_TIMEOUT);
            }

        ASSERT(status == WAIT_IO_COMPLETION);

        if ((Connection->type & TYPE_MASK) == CLIENT)
            {
            //
            // The RPC call may have been cancelled, need to call
            // into the runtime to find out.
            //

            status = I_RpcTransIoCancelled(ThisConnection, &canceltimeout);
            switch (status)
                {
                case RPC_S_OK:
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "RPC cancelled (%p)\n",
                                   lpOverlapped));

                    if (canceltimeout == 0)
                        {
                        return (RPC_S_CALL_CANCELLED);
                        }

                    //
                    // Convert to milliseconds
                    //
                    canceltimeout *= 1000;

                    if (dwTimeout > canceltimeout)
                        {
                        dwTimeout = canceltimeout;
                        }
                    break;

                case RPC_S_NO_CALL_ACTIVE:
                    //
                    // ignore and continue
                    //
                    break;

                default:
                    return RPC_S_CALL_CANCELLED;
                }
            }

        // Either the call was cancelled and timeout has been updated or
        // the call wasn't cancelled and we need to wait again.
        }

    // IO has completed
    ASSERT(HasOverlappedIoCompleted(lpOverlapped));

    // IO successful
    *lpNumberOfBytesTransferred = ULONG(lpOverlapped->InternalHigh);

    if ( NT_SUCCESS(lpOverlapped->Internal) )
        {
        return(RPC_S_OK);
        }

    // IO failed
    return RtlNtStatusToDosError(ULONG(lpOverlapped->Internal));
}

RPC_STATUS
UTIL_GetOverlappedHTTP2ResultEx(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    IN LPOVERLAPPED lpOverlapped,
    IN HANDLE hEvent,
    IN BOOL fAlertable,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Similar to the Win32 API GetOverlappedResult.

    Works with thread event based IO.  (even with multiple IOs/thread-event)
    Allows cancels

Arguments:

    ThisConnection - RPC runtime connection associated with this IO.

    lpOverlapped - Overlapped structure of the IO in progress.
        Must contain a valid hEvent member.

    hEvent - event to wait on

    fAlertable - If true, RPC cancels are enabled. This means the
        wait must be alertable and must follow a protocol to determine
        if a call has been cancelled.

    dwTimeout - Milliseconds to wait

Return Value:

    RPC_S_Ok
    RPC_P_TIMEOUT
    RPC_S_CALL_CANCELLED

--*/
{
    BASE_ASYNC_OBJECT *Connection = (BASE_ASYNC_OBJECT *) ThisConnection;
    ASSERT(hEvent);

    RPC_STATUS status;
    DWORD canceltimeout = 0;

    for(;;)
        {
        // Wait for the IO to complete
        status = UTIL_WaitForSyncHTTP2IO(lpOverlapped, hEvent, fAlertable, dwTimeout);

        if (status == WAIT_OBJECT_0)
            {
            break;
            }

        if (status == WAIT_TIMEOUT)
            {
            ASSERT(dwTimeout != INFINITE);

            if (canceltimeout)
                {
                return(RPC_S_CALL_CANCELLED);
                }

            return(RPC_P_TIMEOUT);
            }

        ASSERT(status == WAIT_IO_COMPLETION);

        if ((Connection->type & TYPE_MASK) == CLIENT)
            {
            //
            // The RPC call may have been cancelled, need to call
            // into the runtime to find out.
            //

            status = I_RpcTransIoCancelled(ThisConnection, &canceltimeout);
            switch (status)
                {
                case RPC_S_OK:
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "RPC cancelled (%p)\n",
                                   lpOverlapped));

                    if (canceltimeout == 0)
                        {
                        return (RPC_S_CALL_CANCELLED);
                        }

                    //
                    // Convert to milliseconds
                    //
                    canceltimeout *= 1000;

                    if (dwTimeout > canceltimeout)
                        {
                        dwTimeout = canceltimeout;
                        }
                    break;

                case RPC_S_NO_CALL_ACTIVE:
                    //
                    // ignore and continue
                    //
                    break;

                default:
                    return RPC_S_CALL_CANCELLED;
                }
            }

        // Either the call was cancelled and timeout has been updated or
        // the call wasn't cancelled and we need to wait again.
        }

    // IO has completed
    ASSERT(lpOverlapped->OffsetHigh);

    if (lpOverlapped->Internal == RPC_S_OK)
        {
        return(RPC_S_OK);
        }

    if ((lpOverlapped->Internal == RPC_P_CONNECTION_SHUTDOWN)
        || (lpOverlapped->Internal == RPC_P_RECEIVE_FAILED)
        || (lpOverlapped->Internal == RPC_P_SEND_FAILED)
        || (lpOverlapped->Internal == RPC_P_CONNECTION_CLOSED)
        || (lpOverlapped->Internal == RPC_S_OUT_OF_MEMORY)
        || (lpOverlapped->Internal == RPC_S_SERVER_UNAVAILABLE)
        || (lpOverlapped->Internal == RPC_S_PROTOCOL_ERROR) )
        {
        return lpOverlapped->Internal;
        }
    else
        {
        // IO failed
        status = RtlNtStatusToDosError(ULONG(lpOverlapped->Internal));
        ASSERT(status != ERROR_MR_MID_NOT_FOUND);
        return status;
        }
}




char * _cdecl
RpcStrTok(
    IN char * string,
    IN const char * control,
    IN OUT char ** ppStrPrev
    )
/*++

Routine Description:

    Tokenize string with delimiter in control. Similar to C runtime function
    strtok() but no state information is maintained. The caller is expected
    to give the string from where to tokenize next.

    strtok considers the string to consist of a sequence of zero or more
    text tokens separated by spans of one or more control chars. The first
    call, with string specified, returns a pointer to the first char of the
    first token, and will write a null char into string immediately
    following the returned token. Subsequent calls with zero for the first
    argument (string) will work thru the string until no tokens remain. The
    control string may be different from call to call. when no tokens remain
    in string a NULL pointer is returned. Remember the control chars with a
    bit map, one bit per ascii char. The null char is always a control char.

Arguments:

    string - string to tokenize, or NULL to get next token

    control - string of characters to use as delimiters

    strPrev - string returned from the preceeding call to RpcStrTok().

Note:

    a. Works only for ANSI character strings.

    b. Cloned from SLM project vctools [crt\crtw32\string\strtok.c].

Return Value:

    pointer to first token in string, or if string was NULL, to next token

    NULL,  when no more tokens remain.

--*/
{
    char *str;
    const char *ctrl = control;

    unsigned char map[32];
    int count;

    ASSERT(ppStrPrev != NULL);

    char * nextoken = *ppStrPrev;

    /* Clear control map */
    for (count = 0; count < 32; count++)
        map[count] = 0;

    /* Set bits in delimiter table */
    do {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    /* Initialize str. If string is NULL, set str to the saved
     * pointer (i.e., continue breaking tokens out of the string
     * from the last strtok call) */
    if (string)
        str = string;
    else
        str = nextoken;

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token iff this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
        str++;

    string = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for ( ; *str ; str++ )
        if ( map[*str >> 3] & (1 << (*str & 7)) ) {
            *str++ = '\0';
            break;
            }

    /* Update nextoken (or the corresponding field in the per-thread data
     * structure). This should update *ppStrPrev. */
    nextoken = str;

    /* Determine if a token has been found. */
    if ( string == str )
        return NULL;
    else
        return string;
}


#if defined(DBG) && defined(TRANSPORT_DLL)
BOOL ValidateError(
    IN unsigned int Status,
    IN unsigned int Count,
    IN const int ErrorList[])
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            // more error codes here
            } END_VALIDATE;

     This function is called with the RpcStatus and expected errors codes
     as parameters.  If RpcStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.
    Count - number of variable length arguments

    ... - One or more expected status codes.  Terminated with 0 (RPC_S_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    unsigned i;

    for (i = 0; i < Count; i++)
        {
        if (ErrorList[i] == (int) Status)
            {
            return TRUE;
            }
        }

    PrintToDebugger("RPC Assertion: unexpected failure %lu (0lx%08x)\n",
                    (unsigned long)Status, (unsigned long)Status);

    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\wsload.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    wsload.cxx

Abstract:

    Implements the wrapper used to avoid loading the winsock
    DLLs into more processes than necessary.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/21/1996    Bits 'n pieces

--*/

#include <precomp.hxx>
#include <wswrap.hxx>

struct WINSOCK_FUNCTION_TABLE WFT;

HMODULE hWinsock = 0;
HMODULE hWinsock2 = 0;

typedef int (PASCAL FAR *PWSASTARTUP)(WORD wVersionRequired, LPWSADATA lpWSAData);

typedef struct tagProcAddressData
{
    int nDllIndex;      // 0 is ws2_32.dll, 1 is mswsock.dll
    char *pProcName;
} ProcAddressData;

const ProcAddressData WinsockProcData[] = {
    { 0, "socket" },
    { 0, "bind" },
    { 0, "closesocket" },
    { 0, "getsockname" },
    { 0, "connect" },
    { 0, "listen" },
    { 0, "send" },
    { 0, "recv" },
    { 0, "sendto" },
    { 0, "recvfrom" },
    { 0, "setsockopt" },
    { 0, "getsockopt" },
    { 0, "inet_ntoa" },
    { 0, "gethostbyname" },
    { 1, "GetAddressByNameA" },
    { 0, "WSASocketW" },
    { 0, "WSARecv" },
    { 0, "WSARecvFrom" },
    { 0, "WSASend" },
    { 0, "WSASendTo" },
    { 0, "WSAProviderConfigChange" },
    { 0, "WSAEnumProtocolsW" },
    { 0, "WSAIoctl" },
    { 0, "getaddrinfo"},
    { 0, "freeaddrinfo"},
    { 0, "getnameinfo" },
    { 0, "WSAGetOverlappedResult" }
    };

LONG TriedUsingAfd = 0;

void TryUsingAfdProc(void) {    

    // Figure out if we can call AFD directly for datagram.

    // This is a performance optimization - if any thing fails
    // or does match exactly to MSAFD the we'll just use the
    // ws2_32 exported functions.
    static const UUID aDefaultProviders[] = {
        { 0xe70f1aa0, 0xab8b, 0x11cf, 0x8c, 0xa3, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92 }, // AFD UDP
        { 0x9d60a9e0, 0x337a, 0x11d0, 0xbd, 0x88, 0x0, 0x00, 0xc0, 0x82, 0xe6, 0x9a }, // RSVP UDP
        { 0x11058240, 0xbe47, 0x11cf, 0x95, 0xc8, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92 }  // AFD IPX
        };


    INT aProtocols[] = { IPPROTO_UDP, NSPROTO_IPX, 0 };
    WSAPROTOCOL_INFO *info;
    DWORD dwSize;
    INT cProtocols;
    BOOL fUseAfd = TRUE;

    info = new WSAPROTOCOL_INFO[8];
    if (info == NULL)
        {
        cProtocols = 0;
        fUseAfd = FALSE;
        }
    else
        {
        dwSize = sizeof(WSAPROTOCOL_INFO) * 8;
        }

    if (fUseAfd)
        {
        cProtocols = WSAEnumProtocolsT(aProtocols,
                                      info,
                                      &dwSize);

        if (cProtocols <= 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Failed to enum protocols, using winsock. %d\n",
                           GetLastError()));

            cProtocols = 0;
            fUseAfd = FALSE;
            }

        for (int i = 0; i < cProtocols; i++)
            {
            BOOL fFoundIt = FALSE;

            for (int j = 0; j < sizeof(aDefaultProviders)/sizeof(UUID); j++)
                {
                if (memcmp(&aDefaultProviders[j], &info[i].ProviderId, sizeof(UUID)) == 0)
                    {
                    fFoundIt = TRUE;
                    }
                }

            if (!fFoundIt)
                {
                fUseAfd = FALSE;
                }
            }
        }

    if (fUseAfd)
        {
        WFT.pWSASendTo = AFD_SendTo;
        WFT.pWSARecvFrom = AFD_RecvFrom;
        }
    else
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Non-default winsock providers loaded\n"));
        }

    if (info)
        delete info;
}


C_ASSERT((sizeof(WinsockProcData) / sizeof(ProcAddressData)) <= (sizeof(WINSOCK_FUNCTION_TABLE) / sizeof(FARPROC)));

BOOL RPC_WSAStartup(void)
{
    // Transport load can only be called by a single thread at a time.

    WSADATA data;
    PWSASTARTUP pStartup;
    FARPROC *ppProc;
    BOOL status;
    BOOL b;
    HMODULE ws2;
    HMODULE ws;
    HMODULE hDlls[2];

    if (hWinsock == 0)
        {
        ws = LoadLibrary(RPC_CONST_SSTRING("mswsock.dll"));

        ws2 = LoadLibrary(RPC_CONST_SSTRING("ws2_32.dll"));

        if (ws == 0 || ws2 == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Unable to load windows sockets dlls, bad config? %d\n",
                           GetLastError()));

            return FALSE;
            }
        }
    else
        {
        // loading already performed - just return true
        ASSERT(hWinsock2);
        return TRUE;
        }

    status = FALSE;

    pStartup = (PWSASTARTUP)GetProcAddress(ws2, "WSAStartup");
    if (pStartup)
        {
        if ( (*pStartup)(2, &data) == NO_ERROR)
            {
            status = TRUE;
            }
        }

    if (!status)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "GetProcAddr or WSAStartup failed %d\n",
                       GetLastError()));

        b = FreeLibrary(ws);
        if (b)
            b = FreeLibrary(ws2);

        if (!b)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "FreeLibrary failed %d\n",
                           GetLastError()));

            ASSERT(0);
            }
        return(FALSE);
        }

    ppProc = (FARPROC *)&WFT;
    hDlls[0] = ws2;
    hDlls[1] = ws;

    // WinsockProcData is smaller than WINSOCK_FUNCTION_TABLE. Make sure the loop
    // is driven by WinsockProcData
    for (int i = 0; i < sizeof(WinsockProcData) / sizeof(ProcAddressData); i++)
        {
        *ppProc = GetProcAddress(hDlls[WinsockProcData[i].nDllIndex], WinsockProcData[i].pProcName);
        if (*ppProc == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Failed to load winsock procedure %s correctly\n",
                           WinsockProcData[i].pProcName));

            b = FreeLibrary(ws);
            if (b)
                b = FreeLibrary(ws2);

            if (!b)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "FreeLibrary failed %d\n",
                               GetLastError()));

                ASSERT(0);
                }
            return(FALSE);
            }
        *ppProc ++;
        }

    hWinsock = ws;
    hWinsock2 = ws2;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\ecblist.c ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  ecblist.c
//
//  Simple hash table support for keeping a list of active ECBs.
//
//  History:
//
//    Edward Reus   12-08-97   Initial Version.
//    Edward Reus   03-01-2000 Convert to hash table.
//--------------------------------------------------------------------

#include <sysinc.h>
#include <winsock2.h>
#include <httpfilt.h>

#include <httpext.h>
#include "ecblist.h"
#include "filter.h"

//--------------------------------------------------------------------
// InitializeECBList()
//
// Create an empty ECB list. If the list is successfully created,
// the return a pointer to it, else return NULL.
//
// This will fail (return FALSE) if either the memory allocation
// for the list failed, or if the initialization of a critical
// section for the list failed.
//--------------------------------------------------------------------
ACTIVE_ECB_LIST *InitializeECBList()
    {
    int    i;
    DWORD  dwStatus;
    DWORD  dwSpinCount = 0x80000008;  // Preallocate event, spincount is 4096.
    ACTIVE_ECB_LIST *pECBList;
 
    pECBList = MemAllocate(sizeof(ACTIVE_ECB_LIST));
    if (!pECBList)
       {
       return NULL;
       }

    memset(pECBList,0,sizeof(ACTIVE_ECB_LIST));
 
    dwStatus = RtlInitializeCriticalSectionAndSpinCount(&pECBList->cs,dwSpinCount);
    if (dwStatus != 0)
       {
       MemFree(pECBList);
       return NULL;
       }

    for (i=0; i<HASH_SIZE; i++)
       {
       InitializeListHead( &(pECBList->HashTable[i]) );
       }
 
    return pECBList;
    }

//--------------------------------------------------------------------
// EmptyECBList()
//
// Return true iff the ECB list holds at least one active ECB.
//--------------------------------------------------------------------
BOOL EmptyECBList( IN ACTIVE_ECB_LIST *pECBList )
    {
    ASSERT(pECBList);

    return (pECBList->dwNumEntries > 0);
    }

//--------------------------------------------------------------------
// InternalLookup()
//
// Do a non-protected lookup for the specified ECB. If its found, then
// return a pointer to its ECB_ENTRY, else return NULL.
//--------------------------------------------------------------------
ECB_ENTRY *InternalLookup( IN ACTIVE_ECB_LIST *pECBList,
                           IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD       dwHash;
    LIST_ENTRY *pHead;
    LIST_ENTRY *pListEntry;
    ECB_ENTRY  *pECBEntry;

    dwHash = ECB_HASH(pECB);

    pHead = &(pECBList->HashTable[dwHash]);
    pListEntry = pHead->Flink;

    while (pListEntry != pHead)
        {
        pECBEntry = CONTAINING_RECORD(pListEntry,ECB_ENTRY,ListEntry);
        if (pECB == pECBEntry->pECB)
            {
            return pECBEntry;
            }

        pListEntry = pListEntry->Flink;
        }

    return NULL;
    }

//--------------------------------------------------------------------
// LookupInECBList()
//
// Look for the specified extension control block (pECB) on the
// list of active ECBs. If its found, then return a pointer to it.
// If its not found then return NULL.
//--------------------------------------------------------------------
EXTENSION_CONTROL_BLOCK *LookupInECBList(
                                 IN ACTIVE_ECB_LIST *pECBList,
                                 IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD       dwStatus;
    ECB_ENTRY  *pECBEntry;
    EXTENSION_CONTROL_BLOCK *pRet = NULL;

    ASSERT(pECBList);
    ASSERT(pECB);

    if (pECBList->dwNumEntries == 0)
        {
        return NULL;
        }

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        pRet = pECB;
        }
 
    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
 
    return pRet;
    }

//--------------------------------------------------------------------
// AddToECBList()
//
// Add the specified extension control block (pECB) to the list
// of active ECBs. If the ECB is already in the list of active ECBs
// then return success (already added).
//
// Return TRUE on success, FALSE on failure.
//--------------------------------------------------------------------
BOOL   AddToECBList( IN ACTIVE_ECB_LIST *pECBList,
                     IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    DWORD      dwHash;
    ECB_ENTRY *pECBEntry;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
 
    //
    // Check to see if the ECB is alreay on the list...
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
       {
       #ifdef DBG_ERROR
       DbgPrint("RpcProxy: AddToECBList(): pECB (0x%p) already in list\n",pECB);
       #endif
       dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
       ASSERT(dwStatus == 0);
       return TRUE;
       }
 
    //
    // Make up a new ECB entry:
    //
    pECBEntry = MemAllocate(sizeof(ECB_ENTRY));
    if (!pECBEntry)
       {
       dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
       ASSERT(dwStatus == 0);

       return FALSE;
       }
 
    pECBEntry->lRefCount = 1;   // Take the first reference...
    pECBEntry->dwTickCount = 0; // Set when connection is closed.
    pECBEntry->pECB = pECB;     // Cache the Extension Control Block.

    dwHash = ECB_HASH(pECB);
 
    InsertHeadList( &(pECBList->HashTable[dwHash]),
                    &(pECBEntry->ListEntry) );

    pECBList->dwNumEntries++;

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
 
    return TRUE;
    }

//--------------------------------------------------------------------
//  IncrementECBRefCount()
//
//  Find the specified ECB in the list and increment its refcount.
//  Return TRUE if its found, FALSE if it isn't on the list.
//
//  Note: That the RefCount shouldn't go over 2 (or less than 0).
//--------------------------------------------------------------------
BOOL IncrementECBRefCount( IN ACTIVE_ECB_LIST *pECBList,
                           IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    DWORD      dwHash;
    ECB_ENTRY *pECBEntry;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    //
    // Look for the ECB:
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        pECBEntry->lRefCount++;
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
    return (pECBEntry != NULL);
    }

//--------------------------------------------------------------------
//  DecrementECBRefCount()
//
//  Look for the specified ECB in the list and if found, decrement its
//  refcount. If the RefCount falls to zero, then remove it from the 
//  list and return it. If the refcount is greater than zero (or the
//  ECB wasn't on the lsit) then return NULL.
//--------------------------------------------------------------------
EXTENSION_CONTROL_BLOCK *DecrementECBRefCount(
                            IN ACTIVE_ECB_LIST *pECBList,
                            IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    ECB_ENTRY *pECBEntry;
    EXTENSION_CONTROL_BLOCK *pRet = NULL;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    //
    // Look for the ECB:
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        pECBEntry->lRefCount--;
        ASSERT(pECBEntry->lRefCount >= 0);

        if (pECBEntry->lRefCount <= 0)
            {
            RemoveEntryList( &(pECBEntry->ListEntry) );
            pRet = pECBEntry->pECB;
            MemFree(pECBEntry);
            pECBList->dwNumEntries--;
            }
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
    return pRet;
    }

//--------------------------------------------------------------------
// LookupRemoveFromECBList()
//
// Look for the specified extension control block (pECB) on the
// list of active ECBs. If its found, then remove it from the active
// list and return a pointer to it. If its not found then return
// NULL.
//--------------------------------------------------------------------
EXTENSION_CONTROL_BLOCK *LookupRemoveFromECBList(
                             IN ACTIVE_ECB_LIST *pECBList,
                             IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    ECB_ENTRY *pECBEntry;
    EXTENSION_CONTROL_BLOCK *pRet = NULL;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    //
    // Look for the ECB:
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        RemoveEntryList( &(pECBEntry->ListEntry) );
        MemFree(pECBEntry);
        pECBList->dwNumEntries--;
        pRet = pECB;
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
    return pRet;
    }

#ifdef DBG
//--------------------------------------------------------------------
// CountBucket()
//
// Helper used by CheckECBHashBalance() to count the number of entries
// in a hast table bucket.
//--------------------------------------------------------------------
int CountBucket( IN LIST_ENTRY *pBucket )
    {
    int iCount = 0;
    LIST_ENTRY *p = pBucket->Flink;

    while (p != pBucket)
        {
        iCount++;
        p = p->Flink;
        }
    return iCount;
    }
//--------------------------------------------------------------------
// CheckECBHashBalance()
//
// DBG code to walk through the hash table and inspect the hash buckets
// for collisions. A will balanced hash table will have a nice uniform 
// distribution of entries spread throughout the hash buckets in the
// hash table.
//--------------------------------------------------------------------
void CheckECBHashBalance( IN ACTIVE_ECB_LIST *pECBList )
    {
    #define ICOUNTS                    7
    #define ILAST                     (ICOUNTS-1)
    #define TOO_MANY_COLLISIONS_POINT  3
    int  i;
    int  iCount;
    int  iHashCounts[ICOUNTS];
    BOOL fAssert = FALSE;

    memset(iHashCounts,0,sizeof(iHashCounts));

    for (i=0; i<HASH_SIZE; i++)
        {
        iCount = CountBucket( &(pECBList->HashTable[i]) );
        if (iCount < ILAST)
            {
            iHashCounts[iCount]++;
            }
        else
            {
            iHashCounts[ILAST]++;
            }
        }

    DbgPrint("CheckECBHashBalance():\n");
    for (i=0; i<ICOUNTS; i++)
        {
        DbgPrint("  Buckets with %d entries: %d\n",i,iHashCounts[i]);
        if ((i>=TOO_MANY_COLLISIONS_POINT)&&(iHashCounts[i] > 0))
            {
            fAssert = TRUE;
            }
        }

    ASSERT(fAssert == FALSE);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\ecblist.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  ecblist.h
//
//  Simple rountines to keep a list of the active ISAPI ECBs.
//--------------------------------------------------------------------

#ifndef _ECBLIST_H
#define _ECBLIST_H

//--------------------------------------------------------------------
//  ACTIVE_ECB_LIST is the list (hashed) of currently active
//  Extension Control Blocks. There is one ECB_ENTRY for each
//  currently active ECB the RpcProxy.dll is managing.
//--------------------------------------------------------------------

//  HASH_SIZE should be a prime number.
#define   HASH_SIZE  991
#define   ECB_HASH(pointer)  (((UINT_PTR)pointer)%HASH_SIZE)

typedef struct _ECB_ENTRY
   {
     LIST_ENTRY   ListEntry;    // Linked list of hash collisions.
     LONG         lRefCount;    // Refcount for ECBs.
     DWORD        dwTickCount;  // For ECB age
     EXTENSION_CONTROL_BLOCK *pECB;
   } ECB_ENTRY;


typedef struct _ACTIVE_ECB_LIST
   {
   RTL_CRITICAL_SECTION  cs;
   DWORD                 dwNumEntries;
   LIST_ENTRY            HashTable[HASH_SIZE]; // List heads for the hash.
   } ACTIVE_ECB_LIST;

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

extern ACTIVE_ECB_LIST *InitializeECBList();

extern BOOL   EmptyECBList( IN ACTIVE_ECB_LIST *pECBList );

extern BOOL   AddToECBList( IN ACTIVE_ECB_LIST *pECBList,
                            IN EXTENSION_CONTROL_BLOCK *pECB );

extern BOOL   IncrementECBRefCount( IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

extern EXTENSION_CONTROL_BLOCK *DecrementECBRefCount(
                                    IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

extern EXTENSION_CONTROL_BLOCK *LookupInECBList(
                                    IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

extern EXTENSION_CONTROL_BLOCK *LookupRemoveFromECBList(
                                    IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

#ifdef DBG
extern void   CheckECBHashBalance( IN ACTIVE_ECB_LIST *pECBList );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\wstrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    wstrans.cxx

Abstract:

    Winsock connection transport interface.

Author:

    Mario Goertzel    [MarioGo]


Revision History:

    MarioGo     3/18/1996    Bits 'n pieces
    MarioGo     12/1997      Async and client parts
    KamenM      Aug 2/2000   IPv6 Support added - rewrote parts of it

--*/

#include <precomp.hxx>
extern "C" {
#include <iphlpapi.h>
}
#include <CharConv.hxx>

//
// Globals
//

BOOL fWinsockLoaded = FALSE;

const WS_TRANS_INFO WsTransportTable[] =
    // indexed by protocol ID
{

    {
    0
    },

    // TCP
    {
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN),
    FALSE,
    TRUE,
    TRUE, TRUE, FALSE, FALSE
    },

#ifdef SPX_ON
    // SPX
    {
    AF_IPX,
    SOCK_STREAM,
    NSPROTO_SPXII,
    sizeof(SOCKADDR_IPX),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

#endif

    // NMP - not winsock.
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

#ifdef NETBIOS_ON
    // NBF
    {
    AF_NETBIOS,
    SOCK_SEQPACKET,
    -1, // Protocol is -1*(LANA),
    sizeof(SOCKADDR_NB),
    TRUE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

    // NBT
    {
    AF_NETBIOS,
    0,
    -1, // Protocol is -1*(LANA)
    sizeof(SOCKADDR_NB),
    TRUE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

    // NBI
    {
    AF_NETBIOS,
    SOCK_SEQPACKET,
    -1, // Protocol is -1*(LANA)
    sizeof(SOCKADDR_NB),
    TRUE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    // NBF
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // NBT
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // NBI
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },
#endif

#ifdef APPLETALK_ON
    // DSP
    {
    AF_APPLETALK,
    SOCK_RDM,
    ATPROTO_ADSP,
    sizeof(SOCKADDR_AT),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    // DSP
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },
#endif

    // SPP
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // HTTP
    {
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN),
    FALSE,
    TRUE,
    TRUE, TRUE, FALSE, FALSE
    },

    // UDP
    {
    AF_INET,
    SOCK_DGRAM,
    IPPROTO_UDP,
    sizeof(SOCKADDR_IN),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

#ifdef IPX_ON
    // IPX
    {
    AF_IPX,
    SOCK_DGRAM,
    NSPROTO_IPX,
    sizeof(SOCKADDR_IPX),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    // IPX
    {
    0,
    0,
    0,
    0,
    0,
    0,
    0, 0, 0, 0
    },
#endif

    // CDP (Cluster datagram protocol)
    {
    AF_CLUSTER,
    SOCK_DGRAM,
    CLUSPROTO_CDP,
    sizeof(SOCKADDR_CLUSTER),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

    // MSMQ - not winsock.
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // TCP over IPv6
    {
    AF_INET6,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN6),
    FALSE,
    TRUE,
    TRUE, TRUE, FALSE, FALSE
    },

    // HTTPv2
    {
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN),
    FALSE,      // fNetbios
    FALSE,      // fCheckShutdowns
    TRUE,       // fSetNoDelay
    TRUE,       // fSetKeepAlive
    FALSE,      // fSetRecvBuffer
    FALSE       // fSetSendBuffer
    },
};

const DWORD cWsTransportTable = sizeof(WsTransportTable)/sizeof(WS_TRANS_INFO);

const DWORD cTcpTimeoutDefault = 120 * 60 * 1000; // Normal TCP/IP timeout, 120 minutes

const UUID WS_ADDRESS::ExtensionFunctionsUuids[] = {WSAID_ACCEPTEX, WSAID_GETACCEPTEXSOCKADDRS};
const int WS_ADDRESS::AcceptExFunctionId = 0;
const int WS_ADDRESS::GetAcceptExSockAddressFunctionId = 1;

#define FIRST_EXTENSION_FUNCTION_CODE  (WS_ADDRESS::AcceptExFunctionId)
#define LAST_EXTENSION_FUNCTION_CODE  (WS_ADDRESS::GetAcceptExSockAddressFunctionId)

inline BOOL IsNetbiosProtocol(PROTOCOL_ID id)
{
#ifdef NETBIOS_ON
    return ((id == NBT) || (id == NBF) || (id == NBI));
#else
    return FALSE;
#endif
}

void 
TCPResolverHint::GetResolverHint (
    OUT BOOL *fIPv4Hint,
    OUT WS_SOCKADDR *sa
    )
/*++

Routine Description:

    Retrieves the resolver hint from the runtime supplied hint
    (the this object).

Arguments:

    fIPv4Hint - on output true if the store hint was about IPv4
    sa - on output, the IP address is retrieved from the hint
        and stored in sa.

Return Value:

--*/
{
    SOCKADDR_IN6 *IPv6Address = (SOCKADDR_IN6 *)sa;

    *fIPv4Hint = fIPv4HintValid;
    if (fIPv4HintValid)
        {
        ((SOCKADDR_IN *)sa)->sin_addr.s_addr = u.IPv4Hint;
        }
    else
        {
        IPv6Address->sin6_flowinfo = 0;
        *((u_long *)(IPv6Address->sin6_addr.s6_addr)    ) = *((u_long *)(u.IPv6Hint.u.Word)    );
        *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1) = *((u_long *)(u.IPv6Hint.u.Word) + 1);
        *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2) = *((u_long *)(u.IPv6Hint.u.Word) + 2);
        *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3) = *((u_long *)(u.IPv6Hint.u.Word) + 3);
        IPv6Address->sin6_scope_id = 0;
        }
}

void
TCPResolverHint::SetResolverHint (
    IN BOOL fIPv4Hint,
    IN WS_SOCKADDR *sa
    )
/*++

Routine Description:

    Sets the resolver hint in the runtime supplied hint
    (the this object).

Arguments:

    fIPv4Hint - true if the stored hint is about IPv4
    sa - the IP address is retrieved from sa
        and is stored in the hint.

Return Value:

--*/
{
    SOCKADDR_IN6 *IPv6Address = (SOCKADDR_IN6 *)sa;

    fIPv4HintValid = fIPv4Hint;
    if (fIPv4HintValid)
        {
        u.IPv4Hint = ((SOCKADDR_IN *)sa)->sin_addr.s_addr;
        }
    else
        {
        *((u_long *)(u.IPv6Hint.u.Word)    ) = *((u_long *)(IPv6Address->sin6_addr.s6_addr)    );
        *((u_long *)(u.IPv6Hint.u.Word) + 1) = *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1);
        *((u_long *)(u.IPv6Hint.u.Word) + 2) = *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2);
        *((u_long *)(u.IPv6Hint.u.Word) + 3) = *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3);
        }
}

BOOL WS_ADDRESS::GetExtensionFunctionPointers(SOCKET sock)
{
    int i;

    for (i = FIRST_EXTENSION_FUNCTION_CODE; i <= LAST_EXTENSION_FUNCTION_CODE; i ++)
        {
        if (GetExtensionFunctionPointerForFunction(sock, i) == FALSE)
            return FALSE;
        }
    return TRUE;
}

BOOL WS_ADDRESS::GetExtensionFunctionPointerForFunction(SOCKET sock, int nFunctionCode)
{
    DWORD dwBytesReturned;
    int retval;

    ASSERT(nFunctionCode >= FIRST_EXTENSION_FUNCTION_CODE);
    ASSERT(nFunctionCode <= LAST_EXTENSION_FUNCTION_CODE);
    ASSERT(sizeof(ExtensionFunctionPointers)/sizeof(ExtensionFunctionPointers[0]) == (LAST_EXTENSION_FUNCTION_CODE - FIRST_EXTENSION_FUNCTION_CODE + 1));

    retval = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, (void *) &ExtensionFunctionsUuids[nFunctionCode],
        sizeof(UUID), (void *) &ExtensionFunctionPointers[nFunctionCode], sizeof(void *), &dwBytesReturned,
        NULL, NULL);

    if (retval == SOCKET_ERROR)
        return FALSE;

    ASSERT(dwBytesReturned == sizeof(void *));
    return TRUE;
}


//
// General winsock interfaces
//

RPC_STATUS WS_CONNECTION::Abort(void)
/*++

Routine Description:

    Closes a connection, will be called only before WS_Close() and
    maybe called by several threads at once.  It must also handle
    the case where another thread is about to start IO on the connection.

Arguments:

    Connection - pointer to a server connection object to abort.

Return Value:

    RPC_S_OK

--*/

{
    if (InterlockedIncrement(&fAborted) != 1)
        {
        // Another thread beat us to it. Normal during
        // a call to WS_Close.
        return(RPC_S_OK);
        }

    I_RpcLogEvent(SU_TRANS_CONN, EV_ABORT, this, ULongToPtr(GetLastError()), 0, 1, 2);

    // Wait for any threads which are starting IO to do so.
    while(IsIoStarting())
        Sleep(1);

    RTL_SOFT_ASSERT(fAborted != 0 && IsIoStarting() == 0);

    if (type & SERVER)
        {
        ASSERT(pAddress != NULL);
        }

    if (Conn.Socket)
        {
        closesocket(Conn.Socket);
        Conn.Socket = 0;
        }

    return(RPC_S_OK);
}


VOID
WS_DeactivateAddress (
    IN WS_ADDRESS *pAddress
    )
/*++
Function Name:WS_DeactivateAddress

Parameters:

Note:

    Doesn't deal with multiple transport addresses/runtime address
    case in netbios or TCP/IP bound to a subset of NICs case. These
    cases currently don't PnP.

Description:

Returns:

--*/
{
    switch (pAddress->id)
        {
        case TCP:
        case TCP_IPv6:
        case HTTP:
#ifdef SPX_ON
        case SPX:
#endif
#ifdef APPLETALK_ON
        case DSP:
#endif
            break;

        default:
            //
            // Don't deactivate the other guys
            //
#ifdef NETBIOS_ON
            ASSERT((pAddress->id == NMP)
                    || (pAddress->id == NBF)
                    || (pAddress->id == NBT)
                    || (pAddress->id == NBI)
                    || (pAddress->id == CDP)
                    );
#else
            ASSERT((pAddress->id == NMP)
                    || (pAddress->id == CDP)
                    );
#endif
            return;
        }

    if (InterlockedIncrement(&pAddress->fAborted) != 1)
        {
        return;
        }

    if (pAddress->ListenSocket)
        {
        closesocket(pAddress->ListenSocket);
        pAddress->ListenSocket = 0;
        }

    if (pAddress->ConnectionSocket)
        {
        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        }
}

RPC_STATUS
WS_ServerListenCommon (
    IN WS_ADDRESS *pAddress
    );

USHORT
WS_GetPortForTCPAddressOnAddressRestart (
    IN WS_ADDRESS *pAddress
    )
/*++
Function Name: WS_GetPortForTCPAddressOnAddressRestart

Parameters:
    pAddress - the address for which we need to get the port

Description:
    When an address is restarted and it happens to be a TCP
    address, we need to call this function to get the port to
    be used. This is necessary so that if we are in a dual
    transport configuration with an active address we can get
    the port from the other address in order to maintain
    consistency

Returns:
    the port number or 0 (means no known ports or not a dual 
    transport configuration)

--*/
{
    WS_ADDRESS *NextAddress;
    USHORT PortNumber = 0;

    ASSERT((pAddress->id == TCP) || (pAddress->id == TCP_IPv6));
    ASSERT(pAddress->fDynamicEndpoint);

    if (pAddress->pFirstAddress != NULL)
        {
        NextAddress = (WS_ADDRESS *)pAddress->pFirstAddress;
        }
    else
        NextAddress = pAddress;


    while (NextAddress != NULL)
        {
        ASSERT(NextAddress->fDynamicEndpoint);
        ASSERT((NextAddress->id == TCP) || (NextAddress->id == TCP_IPv6));
        if (!NextAddress->fAborted)
            {
            PortNumber = RpcpGetIpPort(&NextAddress->ListenAddr);
            ASSERT(PortNumber != 0);
            break;
            }
        NextAddress = (WS_ADDRESS *)NextAddress->pNextAddress;
        }

    return PortNumber;
}


RPC_STATUS
WS_ReactivateAddress (
    IN WS_ADDRESS *pAddress
    )
/*++
Function Name:WS_ReactivateAddress

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    LIST_ENTRY OldEntry;

    //
    // If the endpoint is dynamic, clear out the endpoint
    //
    switch (pAddress->id)
        {
        case TCP:
        case TCP_IPv6:
            if (pAddress->fDynamicEndpoint)
                {
                RpcpSetIpPort(sockaddr, WS_GetPortForTCPAddressOnAddressRestart(pAddress));
                }
            break;

        case HTTP:
            if (pAddress->fDynamicEndpoint)
                {
                RpcpSetIpPort(sockaddr, 0);
                }
            break;

#ifdef SPX_ON
        case SPX:
            if (pAddress->fDynamicEndpoint)
                {
                sockaddr->ipxaddr.sa_socket = 0;
                }
            break;
#endif

#ifdef APPLETALK_ON
        case DSP:
            // Don't need to null out the endpoint
            break;
#endif

        default:
            VALIDATE(pAddress->id)
                {
                NMP,
#ifdef NETBIOS_ON
                NBF,
                NBT,
                NBI,
#endif
                CDP
                } END_VALIDATE;
            //
            // Don't reactivate the other guys
            //
            return RPC_S_OK;
        }

    // save the old entry, because WS_ServerListenCommon overwrites it
    OldEntry.Flink = pAddress->ObjectList.Flink;
    OldEntry.Blink = pAddress->ObjectList.Blink;

    Status = WS_ServerListenCommon (pAddress);
    if (Status == RPC_S_OK)
        {
        pAddress->fAborted = 0;
        pAddress->GetExtensionFunctionPointers(pAddress->ListenSocket);
        }
    else if (Status == RPC_P_ADDRESS_FAMILY_INVALID)
        {
        Status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    // restore the old entry, because WS_ServerListenCommon has overwritten it
    pAddress->ObjectList.Flink = OldEntry.Flink;
    pAddress->ObjectList.Blink = OldEntry.Blink;

    return Status;
}


RPC_STATUS
RPC_ENTRY
WS_Close(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Called once when the connection object is to be really deleted.
    At this point there will be no async IO pending on the connection.

Arguments:

    ThisConnection - The connection object to close

Return Value:

    RPC_S_OK

--*/

{
    SOCKET s;
    WS_CONNECTION *p = (WS_CONNECTION *)ThisConnection;

    p->WS_CONNECTION::Abort();

    if (p->iLastRead)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Closing connection %p with left over data (%d) %p \n",
                       p,
                       p->iLastRead,
                       p->pReadBuffer));
        }

    // Wait for the pending receive, if any, to actually complete.

    if ((p->type & TYPE_MASK) == CLIENT)
        {
        // these operations don't apply to all netbios flavors - they
        // apply to protocols which interop with OSF servers only
        // (because of the check for shutdown)
        if (!IsNetbiosProtocol(p->id))
            {
            PWS_CCONNECTION pcc = (PWS_CCONNECTION)ThisConnection;
            if (pcc->fReceivePending)
                {
                UTIL_WaitForSyncIO(&pcc->Read.ol,
                                   FALSE,
                                   INFINITE);

                }
            }
        }

    // Now free the read buffer

    TransConnectionFreePacket(ThisConnection, p->pReadBuffer);
    p->pReadBuffer = 0;

    TransportProtocol::RemoveObjectFromProtocolList((BASE_ASYNC_OBJECT *) ThisConnection);

    return(RPC_S_OK);
}


BOOL
WS_ProtectListeningSocket(
    IN SOCKET sock,
    IN BOOL newValue
    )
/*++

Routine Description:

    Sets the SO_EXCLUSIVEADDRUSE socket option on the sock parameter.  This
    prevents another process from using same port # and stealing our
    connections.

    Note: This option can only be set by administrators.  This routine has no
          affect when called by non-administrator.

Arguments:

    sock - The socket to protect
    newValue - TRUE if the socket is to be protected, FALSE if it is to be unprotected

Return Value:

    0 if it succeeds, 1 if it fails

--*/
{
    int fSocketExclusive = newValue;
    int rval;

    rval = setsockopt(sock,
                      SOL_SOCKET,
                      SO_EXCLUSIVEADDRUSE,
                      (const char *)&fSocketExclusive,
                      sizeof(fSocketExclusive));

    if (rval != 0)
        {
        // Non-administrators fail with WSAEACCES.

        if (GetLastError() != WSAEACCES)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           "Unable to protect listening socket %d\n",
                           GetLastError()));
            }
        }

    return rval;
}


RPC_STATUS
WS_CheckForShutdowns(
    PWS_CCONNECTION p
    )
/*++

Routine Description:

    When a connection is idle OSF DCE 1.1+ machines will try to reduce
    resource usage by shutting down the connection.  This is the place
    in the DCE RPC protocol where the servers send data to the client
    asychronously to the client sending a request.
    When a server decides to shutdown a connection it send three
    PDUs of the rpc_shutdown type.  Then, if there are no open context
    handles on the connection, it will gracefully close the connection.
    Note: If there are context handles open on the connection then
    the connection is not acutally closed, but the shutdown PDUs are
    still sent.

Algorithm:

    allocate a buffer large enough for a shutdown PDU.

    loop (i = 1 to 4 step 1)
        submit an async receive on the connection.
        If the receive doesn't complete immediately, return.

        type = PDU->type.

        If type != shutdown, save the PDU in the connection and return.

        goto Loop:

    If we get here it means we got too many shutdown PDUs. ASSERT and
    close the connection.

Arguments:

    p - The connection to check for shutdowns on.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_P_RECEIVE_FAILED
    RPC_P_SEND_FAILED

--*/

{
    RPC_STATUS status;
    BUFFER buffer;
    UINT length;
    HANDLE hEvent;

    if (p->iLastRead == 0)
        {
        // The server may have sent us a shutdown packet while the client
        // was idle.  We'll submit a recv now and check the result without
        // waiting.
        //
        // OSF servers will send 3 shutdown packets and then close the
        // connection.  We try to submit four receives, this way if the
        // connection has already been closed we can fail here.

        // Allocate a packet
        p->pReadBuffer = TransConnectionAllocatePacket(p, p->iPostSize);

        if (NULL == p->pReadBuffer)
            {
            p->WS_CONNECTION::Abort();
            return(RPC_S_OUT_OF_MEMORY);
            }

        p->maxReadBuffer = p->iPostSize;
        }
    else
        {
        ASSERT(p->pReadBuffer);
        }

    InitReadEvent(p);

    for (int i = 0; i < 4; i++)
        {
        status = CO_SubmitSyncRead(p, &buffer, &length);

        if (status == RPC_S_OK)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Shutdown check completed!\n"));

            PCONN_RPC_HEADER phdr = (PCONN_RPC_HEADER)buffer;

            switch (MessageType(phdr))
                {
                case rpc_shutdown:
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "Received a shutdown\n"));

                    p->fShutdownReceived = TRUE;

                    // Reset the buffers and try again.
                    if (p->pReadBuffer == 0)
                        {
                        p->pReadBuffer = buffer;
                        p->maxReadBuffer = p->iPostSize;
                        }
                    // else
                    // it is possible that by now all shutdowns
                    // are coalesced in memory - in this case
                    // pReadbuffer and maxReadBuffer are already
                    // set and there is nothing for us to do here -
                    // just loop around and get them
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_P_SEND_FAILED, 
                        EEInfoDLWSCheckForShutdowns10,
                        i);
                    break;

                case rpc_fault:
                    // Io pending - don't free the buffer.
                    p->fReceivePending = TRUE;
                    p->pReadBuffer = buffer;
                    p->maxReadBuffer = p->iPostSize;

                    if (((CONN_RPC_FAULT *) buffer)->status == NCA_STATUS_PROTO_ERROR)
                        {
                        //
                        // This can happen if the server is NT 4.0 and it received a cancel
                        // after a call completed.
                        //
                        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                       DPFLTR_WARNING_LEVEL,
                                       RPCTRANS "Received an out of sequence packet: %p %p\n",
                                       p,
                                       phdr));

                        RpcpErrorAddRecord(EEInfoGCWinsock,
                            RPC_P_SEND_FAILED, 
                            EEInfoDLWSCheckForShutdowns20,
                            (ULONG)((CONN_RPC_FAULT *) buffer)->status,
                            (ULONG)i);
                        goto Cleanup;
                        }

                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_P_RECEIVE_COMPLETE, 
                        EEInfoDLWSCheckForShutdowns30,
                        (ULONG)((CONN_RPC_FAULT *) buffer)->status,
                        (ULONG)i);

                    return RPC_P_RECEIVE_COMPLETE;

                default:
                    // Got something else - this is probably a protocol error.
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "Received an out of sequence packet: %p %p\n",
                                   p,
                                   phdr));

                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_P_SEND_FAILED, 
                        EEInfoDLWSCheckForShutdowns40,
                        (ULONG)MessageType(phdr),
                        (ULONG)i);

                    ASSERT(0);
                    goto Cleanup;
                }
            }
        else
            {
            if (status == RPC_P_IO_PENDING)
                {
                // Io pending - don't free the buffer.
                p->fReceivePending = TRUE;
                return(RPC_S_OK);
                }

            RpcpErrorAddRecord(EEInfoGCWinsock,
                status, 
                EEInfoDLWSCheckForShutdowns50,
                i);
            return(status);
            }
        }

Cleanup:
    p->WS_CONNECTION::Abort();
    return(RPC_P_SEND_FAILED);
}


RPC_STATUS
RPC_ENTRY
WS_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Sends a message on the connection.  This method must appear
    to be synchronous from the callers perspective.

    Note: This routine must check for OSF DCE shutdown PDUs
    on TCP/IP to avoid interop problems.

Arguments:

    Connection - The connection of send to.
    BufferLength - The size of the buffer.
    Buffer - The data to sent.
    fDisableShutdownCheck - Normally FALSE, when true this disables
        the transport check for async shutdown PDUs.  This is needed
        when sending the third leg.


Return Value:

    RPC_P_SEND_FAILED - Connection will be closed if this is returned.

    RPC_S_OK - Data sent

--*/

{
    DWORD bytes;
    RPC_STATUS status;

    PWS_CCONNECTION p = (PWS_CCONNECTION)Connection;
    ASSERT(!IsNetbiosProtocol(p->id));

    // Note: this can be called on SERVER connections, too.
    // All references to CLIENT-ONLY members must be guarded with
    // (p->type & CLIENT).

    //
    // OSF 1.1(+) server's send, asynchronously to the client sending a
    // request, shutdown PDUs on "idle" connections.  Here we check for
    // shutdown PDUs in order to allow the client to retry the call on
    // another connection if this one has closed.
    //

    if (   ((p->type & TYPE_MASK) == CLIENT)
        && (FALSE == p->fCallStarted)
        && WsTransportTable[p->id].fCheckShutdowns
        && (fDisableShutdownCheck == FALSE)
        && (GetTickCount() - p->dwLastCallTime) > MILLISECONDS_BEFORE_PEEK)
        {
        p->fShutdownReceived = FALSE;

        status = WS_CheckForShutdowns(p);

        if (status != RPC_S_OK)
            {
            VALIDATE(status)
                {
                RPC_P_RECEIVE_FAILED,
                RPC_P_CONNECTION_SHUTDOWN,
                RPC_P_SEND_FAILED,
                RPC_S_OUT_OF_MEMORY,
                RPC_P_RECEIVE_COMPLETE
                } END_VALIDATE;

            if (status == RPC_P_RECEIVE_COMPLETE)
                {
                return status;
                }

            RpcpErrorAddRecord(EEInfoGCWinsock,
                RPC_P_SEND_FAILED, 
                EEInfoDLWSSyncSend10);
            return(RPC_P_SEND_FAILED);
            }

        // There is no need to to this again until SyncRecv is called.
        p->fCallStarted = TRUE;
        }

    HANDLE hEvent = I_RpcTransGetThreadEvent();

    p->StartingWriteIO();

    if (p->fAborted)
        {
        p->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    // Setting the low bit of the event indicates that the write
    // completion should NOT be sent to the i/o completion port.
    OVERLAPPED olWrite;
    olWrite.Internal = 0;
    olWrite.InternalHigh = 0;
    olWrite.Offset = 0;
    olWrite.OffsetHigh = 0;
    olWrite.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (Buffer, BufferLength, 0);
        }
#endif

    status = p->Send(p->Conn.Handle,
                            Buffer,
                            BufferLength,
                            &bytes,
                            &olWrite
                            );

    p->WriteIOFinished();

    if (status == RPC_S_OK)
        {
        ASSERT(bytes == BufferLength);
        return(RPC_S_OK);
        }

    if (status == ERROR_IO_PENDING)
        {
        // if fDisableCancelCheck, make the thread wait non-alertably,
        // otherwise, make it wait alertably.
        status = UTIL_GetOverlappedResultEx(Connection,
                                            &olWrite,
                                            &bytes,
                                            !fDisableCancelCheck,
                                            Timeout);

        if (status == RPC_S_OK)
            {
            ASSERT(bytes == BufferLength);
            return(RPC_S_OK);
            }
        }

    ASSERT(status != RPC_S_OK);

    RpcpErrorAddRecord(EEInfoGCWinsock,
        status, 
        EEInfoDLWSSyncSend20);

    p->WS_CONNECTION::Abort();

    if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
        {
        // Wait for the write to finish.  Since we closed the
        // connection this won't take very long.
        UTIL_WaitForSyncIO(&olWrite,
                           FALSE,
                           INFINITE);
        }
    else
        {
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RPC_P_SEND_FAILED, 
            EEInfoDLWSSyncSend30);

        status = RPC_P_SEND_FAILED;
        }

    return(status);
}

VOID
WS_P_SetKeepAliveTimeout(
    IN SOCKET Socket,
    IN BOOL OnOff,
    IN UINT KATime,
    IN UINT KAInterval = 5000 OPTIONAL)
/*++

Arguments:

    Socket - The socket to set the keepalive timeout on
    OnOff - TRUE to turn if on. FALSE to turn it off
    KATime - The timeout in milliseconds for the
        first keepalive packet
    KAInterval - The timeout in milliseconds for the
        subsequent keepalive packets

--*/
{
    int r;
    tcp_keepalive tcpka;
    DWORD t;

    // make sure we indeed get TRUE of FALSE - we don't know how Winsock will
    // take it otherwise
    ASSERT((OnOff == TRUE) || (OnOff == FALSE));

    tcpka.onoff             = OnOff;
    tcpka.keepalivetime     = KATime; // Milliseconds, time to send first KA
    tcpka.keepaliveinterval = KAInterval;    // Milliseconds, this is the TCP/IP default.

    r = WSAIoctl(Socket,
                 SIO_KEEPALIVE_VALS,
                 (PVOID)&tcpka,
                 sizeof(tcpka),
                 (PVOID)&tcpka,
                 sizeof(tcpka),
                 &t,
                 0,
                 0);

    if (r != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "setsockopt KEEPALIVE_VALS failed %d\n",
                       GetLastError()));
        }
}

RPC_STATUS
RPC_ENTRY 
WS_TurnOnOffKeepAlives (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for Winsock transports supporting keepalives.

Arguments:

    ThisConnection - The connection to turn keep alives on on.
    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.
    KATime - how much to wait before sending first keep alive

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we use it on the server, we must protect
        the handle by calling StartingOtherIO

--*/
{
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[p->id];
    RPC_STATUS RpcStatus = RPC_S_OK;

    // convert the timeout from runtime scale to transport scale
    if (Units == tuRuntime)
        {
        ASSERT(KATime.RuntimeUnits != RPC_C_BINDING_INFINITE_TIMEOUT);
        KATime.Milliseconds = ConvertRuntimeTimeoutToWSTimeout(KATime.RuntimeUnits);
        }

    // When the server is turning on keepalives it must protect
    // the operation by calling StartingOtherIO
    if (bProtectIO)
        {
        p->StartingOtherIO();
        }

    //
    // It is possible that this code is executed before TCP_Open and WS_Open
    // have been called or that unrecoverable failure has been hit.
    // In this case p->id will be invalid or fAborted will be set.
    //
    if (p->id == INVALID_PROTOCOL_ID || p->fAborted)
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        goto Cleanup;
        }

    ASSERT(pInfo->fSetKeepAlive);

    WS_P_SetKeepAliveTimeout(
        p->Conn.Socket, 
        TurnOn ? TRUE : FALSE, 
        KATime.Milliseconds,
        KAInterval);

Cleanup:
    if (bProtectIO)
        {
        p->OtherIOFinished();
        }
    return RpcStatus;
}


RPC_STATUS
RPC_ENTRY
WS_SyncRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Receive the next PDU to arrive at the connection.

Arguments:

    ThisConnection - The connection to wait on.
    fCancelable - If TRUE, the wait will also include the threads cancel
        event and will timeout after the cancel event is signaled.
    pBuffer - If successful, points to a buffer containing the next PDU.
    BufferSize -  If successful, contains the length of the message.

Return Value:

    RPC_S_OK
    RPC_P_RECEIVE_FAILED - Connection aborted.
    RPC_P_CONNECTION_SHUTDOWN - Graceful disconnect from server, connection aborted.
    RPC_S_CALL_CANCELLED - Timeout after cancel event, connection aborted.

Note:

    Used only on the client. If we use it on the server, we must protect
        the handle with StartingOtherIO.

--*/
{
    RPC_STATUS status;
    DWORD bytes;
    HANDLE hEvent;
    BOOL fReceivePending;
    BOOL fSetKeepAliveVals = FALSE;
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    DWORD dwActualTimeout;
    BOOL fWaitOnConnectionTimeout;

    ASSERT((p->type & TYPE_MASK) == CLIENT);
    ASSERT(!IsNetbiosProtocol(p->id));

    // There maybe a receive already pending from the shutdown check
    // in WS_SyncSend.  If so, we want to skip the first submit.

    fReceivePending = p->fReceivePending;
    p->fReceivePending = FALSE;
    p->fCallStarted = FALSE;

    // if there's a per operation timeout, use the lesser of the operation
    // and connection timeout
    if (dwTimeout != INFINITE)
        {
        if (dwTimeout <= p->Timeout)
            {
            dwActualTimeout = dwTimeout;
            fWaitOnConnectionTimeout = FALSE;
            }
        else
            {
            dwActualTimeout = p->Timeout;
            fWaitOnConnectionTimeout = TRUE;
            }
        }
    else
        {
        // wait on the connection timeout
        dwActualTimeout = p->Timeout;
        fWaitOnConnectionTimeout = TRUE;
        }

    ASSERT(   (fReceivePending == FALSE)
           || (p->Read.ol.hEvent == (HANDLE) ((ULONG_PTR)I_RpcTransGetThreadEvent() | 0x1)) );

    //
    // Keep looping until we have a complete message.
    //
    // Note that SubmitSyncRecv may complete with a whole message read.
    //
    do
        {

        if (!fReceivePending)
            {
            // Allocate a receive buffer if needed.

            if (p->pReadBuffer == NULL)
                {
                ASSERT(p->iLastRead == 0);

                p->pReadBuffer = TransConnectionAllocatePacket(p,
                                                               p->iPostSize);
                if (p->pReadBuffer == NULL)
                    {
                    p->WS_CONNECTION::Abort();
                    return(RPC_P_RECEIVE_FAILED);
                    }

                p->maxReadBuffer = p->iPostSize;
                }

            InitReadEvent(p);

            status = CO_SubmitSyncRead(p, pBuffer, pBufferLength);

            if (status != RPC_P_IO_PENDING)
                {
                break;
                }
            }
        else
            {
            fReceivePending = FALSE;
            }

        do
            {

            //
            // Wait for the pending receive on the connection to complete
            //
            status = UTIL_GetOverlappedResultEx(ThisConnection,
                                                &p->Read.ol,
                                                &bytes,
                                                TRUE, // Alertable
                                                dwActualTimeout);


            if (   status != RPC_S_OK
                || bytes == 0 )
                {

                // if we timed out ...
                if (status == RPC_P_TIMEOUT)
                    {
                    ASSERT(dwActualTimeout != INFINITE);

                    // if we waited on the per connection timeout ...
                    if (fWaitOnConnectionTimeout)
                        {
                        ASSERT(p->Timeout != INFINITE);
                        if (dwTimeout == INFINITE)
                            {
                            // enable keep alives and wait forever
                            dwActualTimeout = INFINITE;
                            }
                        else
                            {
                            ASSERT(p->Timeout < dwTimeout);

                            // enable keep alives and wait the difference
                            dwActualTimeout = dwTimeout - p->Timeout;
                            fWaitOnConnectionTimeout = FALSE;
                            }
                        // Enable aggressive keepalives on the socket if transport
                        // supports it
                        if (WsTransportTable[p->id].fSetKeepAlive)
                            {
                            WS_P_SetKeepAliveTimeout(p->Conn.Socket, 
                                TRUE,       // OnOff
                                p->Timeout);
                            fSetKeepAliveVals = TRUE;
                            }
                        continue;
                        }
                    // else we have chosen the per operation timeout and
                    // have timed out on that - time to bail out
                    }

                // Normal error path

                RpcpErrorAddRecord(EEInfoGCWinsock,
                    status, 
                    EEInfoDLWSSyncRecv10,
                    (status == RPC_S_OK ? bytes : 0));

                p->WS_CONNECTION::Abort();

                if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
                    {
                    UTIL_WaitForSyncIO(&p->Read.ol,
                                       FALSE,
                                       INFINITE);
                    if ((status == RPC_P_TIMEOUT) && fWaitOnConnectionTimeout)
                        {
                        status = RPC_P_RECEIVE_FAILED;
                        RpcpErrorAddRecord(EEInfoGCWinsock,
                            status, 
                            EEInfoDLWSSyncRecv20);
                        }
                    }
                else
                    {
                    status = RPC_P_RECEIVE_FAILED;
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        status, 
                        EEInfoDLWSSyncRecv30);
                    }

                return(status);
                }
            }
        while (status == RPC_P_TIMEOUT);

        status = p->ProcessRead(bytes, pBuffer, pBufferLength);

        }
    while (status == RPC_P_PARTIAL_RECEIVE);

    p->dwLastCallTime = GetTickCount();

    if (fSetKeepAliveVals)
        {
        // Call complete okay, clear keep alives
        WS_P_SetKeepAliveTimeout(p->Conn.Socket, 
            FALSE,      // OnOff
            0);
        }

    return(status);
}

void
RPC_ENTRY
WS_ServerAbortListen(
    IN RPC_TRANSPORT_ADDRESS Address
    )
/*++

Routine Description:

    This routine will be called if an error occurs in setting up the
    address between the time that SetupWithEndpoint or SetupUnknownEndpoint
    successfully completed and before the next call into this loadable
    transport module.  We need to do any cleanup from Setup*.

Arguments:

    pAddress - The address which is being aborted.

Return Value:

    None

--*/
{
    PWS_ADDRESS pList = (PWS_ADDRESS)Address;
    PWS_ADDRESS pLast = 0;
    INT i, retval;

    delete pList->pAddressVector;
    delete pList->Endpoint;

    TransportProtocol::RemoveObjectFromProtocolList(pList);

    while(pList)
        {
        if (pList->ListenSocket)
            {
            closesocket(pList->ListenSocket);
            }

        if (pList->ConnectionSocket)
            {
            closesocket(pList->ConnectionSocket);
            }


        pLast = pList;
        pList = (PWS_ADDRESS) pList->pNextAddress;

        if (pLast != (PWS_ADDRESS)Address)
            {
            TransportProtocol::RemoveObjectFromProtocolList(pLast);
            delete pLast;
            }
        }

    return;
}


VOID
WS_SubmitAccept(
    BASE_ADDRESS *Address
    )
/*++

Routine Description:

    Used to submit an accept on a listen socket. Called once when the
    listen socket is created and again after each client connects.

    The listen socket must already be added to the completion port.

Arguments:

    Address - The address to accept on.
            ->ConnectionSocket - socket to accept on, or zero in
                which case a new socket is allocated and put here.

Return Value:

    None

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)Address;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[pAddress->id];
    SOCKET sAccept;
    RPC_STATUS status;

    if (pAddress->ConnectionSocket != 0)
        {
        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        }

    pAddress->ConnectionSocket =
        WSASocketT(pInfo->AddressFamily,
                   pInfo->SocketType,
                   pInfo->Protocol * GetProtocolMultiplier(pAddress),
                   0,
                   0,
                   WSA_FLAG_OVERLAPPED);

    if (pAddress->ConnectionSocket == SOCKET_ERROR)
        {
        pAddress->ConnectionSocket = 0;
        COMMON_AddressManager(Address);
        return;
        }

    //
    // make the handle non-inheritable so it goes away when we close it.
    // join the socket to the completion port
    //
    if (FALSE    == SetHandleInformation(   (HANDLE) pAddress->ConnectionSocket, HANDLE_FLAG_INHERIT, 0) ||
        RPC_S_OK != COMMON_PrepareNewHandle((HANDLE) pAddress->ConnectionSocket))
        {
        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        COMMON_AddressManager(Address);
        return;
        }

    ASSERT(pAddress->ConnectionSocket != INVALID_SOCKET);

    DWORD bytes = 0;

    BOOL b = pAddress->pAcceptExFunction(pAddress->ListenSocket,
                      pAddress->ConnectionSocket,
                      &pAddress->AcceptBuffer,
                      0,
                      0,
                      sizeof(WS_SOCKADDR) + 16,
                      &bytes,
                      &pAddress->Listen.ol
                      );

    if (!b && (GetLastError() != ERROR_IO_PENDING))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "AcceptEx failed %p, %d %d\n",
                       pAddress,
                       pAddress->ConnectionSocket,
                       GetLastError()));

        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        COMMON_AddressManager(Address);
        }

    return;
}


void
WS_SetSockOptForConnection (
    IN const WS_TRANS_INFO *pInfo,
    IN SOCKET sock
    )
/*++

Routine Description:

    Sets the socket options for the given socket for a server
    side connection socket.

Arguments:

    pInfo - the transport information for the Winsock transport
    sock - the socket on which to set options

Return Value:

    None. Setting the options is a best effort. Failures are ignored.

--*/
{
    int retval = 0;

    if (pInfo->fSetNoDelay)
        {
        INT NoDelay = TRUE;
        retval = setsockopt(sock,
                            pInfo->Protocol,
                            TCP_NODELAY,
                            (PCHAR)&NoDelay, sizeof(NoDelay)
                            );
        }

    if (   pInfo->fSetKeepAlive
        && retval == 0)
        {
        INT KeepAlive = TRUE;
        retval = setsockopt(sock,
                            pInfo->Protocol,
                            SO_KEEPALIVE,
                            (PCHAR)&KeepAlive, sizeof(KeepAlive)
                            );
        }

    if (retval != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "setsockopt failed %d, %d\n",
                       retval,
                       GetLastError()));
        }

}


RPC_STATUS
WS_NewConnection(
    IN PADDRESS Address,
    OUT PCONNECTION *ppConnection
    )
/*++

Routine Description:

    Called when an AcceptEx completes on an I/O completion thread.

Arguments:

    Address - The address used as context in a previous AcceptEx.
    ppConnection - A place to store the new pConnection.  Used
        when a connection been created and then a failure occurs.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS status;
    BOOL b;
    WS_ADDRESS *pAddress = (WS_ADDRESS *)Address;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[pAddress->id];
    WS_CONNECTION *pConnection;
    UINT fReceiveDirect;
    SOCKET sock = pAddress->ConnectionSocket;
    int retval = 0;
    WS_SOCKADDR *saAddrs;
    WS_SOCKADDR saClient;
    INT adwAddrLen;
    BOOL fSANConnection;
    int LocalAddressLength = 0;
    PSOCKADDR DummyAddr = NULL;

    ASSERT(sock);

    pAddress->ConnectionSocket = 0;

    // First, parse the client address out of the accept
    // since the next accept will reuse the same buffer.

    pAddress->pGetAcceptExSockaddressFunction(&pAddress->AcceptBuffer,
                         0,
                         0,
                         sizeof(WS_SOCKADDR) + 16,
                         &DummyAddr,
                         &LocalAddressLength,
                         (struct sockaddr **)&saAddrs,
                         &adwAddrLen);

    ASSERT(adwAddrLen <= sizeof(WS_SOCKADDR));

    // Save the client address before submitting the next accept.
    saClient = *saAddrs;

    // Submit the next accept.
    WS_SubmitAccept(pAddress);

    // Now, try process the new connection..
    WS_SetSockOptForConnection(pInfo, sock);

    /*
    fSANConnection = IsUserModeSocket(sock, &status);
    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return status;
        }
        */
    fSANConnection = TRUE;

    //
    // Notes:
    //
    // a. For security reasons, we require the RPC HTTP Servers to send back
    //    an identification message.
    //
    // b. This should "really" be done in WS_SubmitAccept(). This is done here
    //    for convenience. This is OK if HttpSendIdentifyRespomse() rarely
    //    fails.
    //
    if ((pAddress->id == HTTP) &&
        (status = HttpSendIdentifyResponse(sock)))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSendIdentifyResponse failed %p, %d - %d\n",
                       pAddress,
                       sock,
                       status
                       ));
        closesocket(sock);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    BASE_ADDRESS *pRealAddress = pAddress->pFirstAddress;

    pConnection = (WS_CONNECTION *)
                  I_RpcTransServerNewConnection(pRealAddress);

    *ppConnection = pConnection;

    if (!pConnection)
        {
        // Abort the connection.

        INT DontLinger = TRUE;
        // REVIEW: check a protocol flag to do this?
        retval = setsockopt(sock, SOL_SOCKET, SO_DONTLINGER,
                            (PCHAR)&DontLinger, sizeof(DontLinger));
        ASSERT(retval == 0);
        closesocket(sock);
        return(RPC_S_OUT_OF_MEMORY);
        }

    // Got a good connection, initialize it..

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // This function cannot fail after this point.  There is no
    // way to notify the runtime that the connection has been closed.
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifdef NETBIOS_ON
    if ((pAddress->id == NBF)
        || (pAddress->id == NBT)
        || (pAddress->id == NBI))
        {
        if (fSANConnection)
            pConnection = new (pConnection) NB_SAN_CONNECTION;
        else
            pConnection = new (pConnection) NB_CONNECTION;
        }
    else 
#endif
    if (pAddress->id == HTTP)
        {
        pConnection = new (pConnection) WS_HTTP2_INITIAL_CONNECTION;
        }
    else
        {
        if (fSANConnection)
            pConnection = new (pConnection) WS_SAN_CONNECTION;
        else
            pConnection = new (pConnection) WS_CONNECTION;
        }

    pConnection->type = SERVER | CONNECTION;
    pConnection->id = pAddress->id;
    pConnection->Conn.Socket = sock;
    pConnection->fAborted = 0;
    pConnection->pReadBuffer = 0;
    pConnection->maxReadBuffer = 0;
    pConnection->iLastRead = 0;
    pConnection->iPostSize = gPostSize;
    pConnection->saClientAddress = saClient;
    RpcpMemorySet(&pConnection->Read.ol, 0, sizeof(pConnection->Read.ol));
    pConnection->Read.pAsyncObject = pConnection;
    pConnection->InitIoCounter();
    pConnection->pAddress = pAddress;

    TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) *ppConnection);

    return(RPC_S_OK);
}


BOOL
IsUserModeSocket(
    IN SOCKET s,
    OUT RPC_STATUS *pStatus)
/*++

Routine Description:

    Given a socket, it tells whether this is a true kernel socket or not. This test is based per VadimE's input
    that:
        "Just call getsockopt (SOL_SOCKET, SO_PROTOCOL_INFOW) and check XP1_IFS_HANDLES in
        dwServiceFlags1 of WSAPROTOCOL_INFOW. If flag is not set, the handle is not "TRUE"
        IFS handle and file system calls on them carry performance penalty.

        Make sure you call after connection is established or information returned may be
        inaccurate."

Arguments:

    s - The socket to be tested
    pStatus - RPC_S_OK if everything is fine. RPC_S_OUT_OF_MEMORY if the test could not be performed. Note
        that in the latter case the return value is undefined and should be disregarded.

Return Value:

    TRUE - the socket is a true kernel socket
    FALSE  - the socket is not a kernel socket

--*/
{
    WSAPROTOCOL_INFO protocolInfo;
    int paramSize = sizeof(protocolInfo);
    int retval;

    // check whether this is a kernel connection. We do this by checking whether this socket is a true
    // IFS_HANDLE. If yes, then this is not a kernel socket. If not, then it is a kernel socket
    retval = getsockopt(s, SOL_SOCKET, SO_PROTOCOL_INFOW, (char *) &protocolInfo, &paramSize);
    if (retval == SOCKET_ERROR)
        {
        *pStatus = RPC_S_OUT_OF_MEMORY;
        return FALSE;
        }

    *pStatus = RPC_S_OK;

    if (protocolInfo.dwServiceFlags1 & XP1_IFS_HANDLES)
        return FALSE;
    else
        return TRUE;
}


RPC_STATUS
WS_ServerListenCommon (
    IN WS_ADDRESS *pAddress
    )
/*++

Routine Description:

    This routine does common server address setup.

Arguments:

    pAddress - A pointer to the loadable transport interface address.
        Will contain the newly allocated listen socket when finished.

    pListenAddr - Initalized socket address to bind to. On output
        it will contain results of the bind.

    PendingQueueSize - Value specified in use protseq, used
        to set the pending queue size for listens.

ReturnValue:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S__CANT_CREATE_ENDPOINT

--*/
{
    SOCKET               sock;
    int                  retval, length;
    RPC_STATUS           status;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[pAddress->id];
    WS_SOCKADDR *pListenAddr = &(pAddress->ListenAddr);
    DWORD EndpointFlags = pAddress->EndpointFlags;
    BOOL fRetVal;
    int i;
    DWORD LastError;

    pAddress->type = ADDRESS;
    pAddress->InAddressList = NotInList;
    pAddress->fAborted = 0;
    pAddress->pNext = 0;
    pAddress->ListenSocket = 0;
    pAddress->ConnectionSocket = 0;
    pAddress->pNextAddress = 0;
    pAddress->pFirstAddress = pAddress;
    memset(&pAddress->Listen, 0, sizeof(BASE_OVERLAPPED));
    pAddress->Listen.pAsyncObject = pAddress;
    for (i = FIRST_EXTENSION_FUNCTION_CODE; i < LAST_EXTENSION_FUNCTION_CODE; i ++)
        {
        pAddress->ExtensionFunctionPointers[i] = NULL;
        }
    RpcpInitializeListHead(&pAddress->ObjectList);

    // First order of business: get a valid socket
    //
    sock = WSASocketT(pInfo->AddressFamily,
                      pInfo->SocketType,
                      pInfo->Protocol,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);

    if (sock == INVALID_SOCKET)
        {
        LastError = GetLastError();

        RpcpErrorAddRecord(EEInfoGCWinsock,
            LastError, 
            EEInfoDLWSServerListenCommon10,
            pInfo->AddressFamily,
            pInfo->SocketType,
            pInfo->Protocol);

        switch(LastError)
            {
            case WSAENETDOWN:
            case WSAEINVAL:
            case WSAEPROTOTYPE:
            case WSAENOPROTOOPT:
            case WSAEPROTONOSUPPORT:
            case WSAESOCKTNOSUPPORT:
            case WSAEPFNOSUPPORT:
            case WSAEADDRNOTAVAIL:
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            case WSAEAFNOSUPPORT:
                status = RPC_P_ADDRESS_FAMILY_INVALID;
                break;

            case WSAENOBUFS:
            case WSAEMFILE:
            case WSA_NOT_ENOUGH_MEMORY:
                status = RPC_S_OUT_OF_MEMORY;
                break;

            default:
                ASSERT(0);

                // !break

            case WSAEPROVIDERFAILEDINIT:
                status = RPC_S_OUT_OF_RESOURCES;
                break;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            status, 
            EEInfoDLWSServerListenCommon30);

        return(status);
        }

    //
    // Make the handle non-inheritable so it goes away when we close it.
    //
    if (FALSE == SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0))
        {
        closesocket(sock);
        return RPC_S_OUT_OF_RESOURCES;
        }

    //
    // Protect the socket to prevent another server from using our port.
    //

    WS_ProtectListeningSocket(sock, TRUE);

    fRetVal = pAddress->GetExtensionFunctionPointers(sock);

    if (!fRetVal)
        {
        switch (GetLastError())
            {
            case WSAEFAULT:
            case WSAEINVAL:
                status = RPC_S_INTERNAL_ERROR;
                break;

            case WSAEOPNOTSUPP:
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            default:
                status = RPC_S_OUT_OF_RESOURCES;
            }
        closesocket(sock);
        return(status);
        }

    //
    // Try to bind to the given port number...
    //

    pListenAddr->generic.sa_family = pInfo->AddressFamily;

    // N.B. - we should think how the port allocation will look for TCP/IPv6
    status = WS_Bind(sock, pListenAddr, (pAddress->id == TCP) || (pAddress->id == HTTP), EndpointFlags);

    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return(status);
        }

    if(listen(sock, pAddress->QueueSize) == SOCKET_ERROR)
        {
        RpcpErrorAddRecord(EEInfoGCWinsock,
            RPC_S_OUT_OF_RESOURCES, 
            EEInfoDLWSServerListenCommon20,
            GetLastError(),
            (ULONGLONG)sock,
            (ULONG)pAddress->QueueSize);
        closesocket(sock);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    status = COMMON_PrepareNewHandle((HANDLE)sock);
    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return(status);
        }

    pAddress->ListenSocket = sock;

    TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) pAddress);

    TransportProtocol::FunctionalProtocolDetected(pAddress->id);

    return(RPC_S_OK);
}


RPC_STATUS
WS_Initialize_Internal (
    IN PWS_CCONNECTION pConnection
    )
{
    pConnection->Initialize();

    pConnection->fCallStarted      = FALSE;
    pConnection->fShutdownReceived = FALSE;
    pConnection->fReceivePending   = FALSE;
    pConnection->dwLastCallTime    = GetTickCount();
    pConnection->pAddress = NULL;
    RpcpInitializeListHead(&pConnection->ObjectList);

    return RPC_S_OK;
}


RPC_STATUS
WS_Initialize (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR *NetworkAddress,
    IN RPC_CHAR *NetworkOptions,
    IN BOOL fAsync
    )
{
    PWS_CCONNECTION p = (PWS_CCONNECTION) ThisConnection;

    p->id = INVALID_PROTOCOL_ID;
    return WS_Initialize_Internal(p);
}

const UUID ConnectExExtensionFunctionUuid = WSAID_CONNECTEX;


RPC_STATUS
WS_Open(
    IN PWS_CCONNECTION p,
    IN WS_SOCKADDR *psa,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN ULONG CallTimeout,
    IN BOOL fHTTP2Open
    )
/*++

Routine Description:

    Common part of opening a winsock connection to a server.

Arguments:

    p - The partially initialized client connection object. If fHTTP2,
        this is a connection object, not client connection object.
    psa - sockaddr with protocol specific part already containing
        this address and port of the server.
    ConnTimeout - Valid for TCP/IP, see SyncRecv error handling.
    {Send,Recv}BufferSize - Used to set the transport buffer
        sizes on some protocols. Currently ignored.
    CallTimeout - call timeout in milliseconds
    fHTTP2Open - the open is an HTTP2 open

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

    RPC_S_SERVER_UNAVAILABLE - failed
    ERROR_RETRY - failed, but another address might work.

--*/
{
    // Initialize common part of the connection object

    const WS_TRANS_INFO *pInfo = &WsTransportTable[p->id];
    SOCKET sock;
    RPC_STATUS           status;
    BOOL fSANConnection;
    DWORD LastError;
    RPC_CLIENT_PROCESS_IDENTIFIER ServerAddress;
    HANDLE hEvent;
    OVERLAPPED ol;
    DWORD dwBytesReturned;
    LPFN_CONNECTEX ConnectEx;
    union
        {
        SOCKADDR_IN sockaddr;
        SOCKADDR_IN6 sockaddr6;
        };
    int NameLen;

    DWORD Transfer;
    DWORD Flags;

    // Set if we had already called GetLastErrorand added EEInfo.
    // Adding EEInfo may overwrite the LastError and getting it second
    // time will return 0 and cause an assert.
    BOOL fGetLastErrorCalled = FALSE;

    if (!fHTTP2Open)
        {
        WS_Initialize_Internal(p);
        }

    //
    // Open a socket
    //

    sock = WSASocketT(pInfo->AddressFamily,
                      pInfo->SocketType,
                      pInfo->Protocol,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);

    if (sock == INVALID_SOCKET)
        {
        LastError = GetLastError();

        RpcpErrorAddRecord(EEInfoGCWinsock,
            LastError, 
            EEInfoDLWSOpen10,
            pInfo->AddressFamily,
            pInfo->SocketType,
            pInfo->Protocol);

        switch(LastError)
            {
            case WSAEAFNOSUPPORT:
            case WSAEPROTONOSUPPORT:
            case WSAEPROTOTYPE:
            case WSAENETDOWN:
            case WSAESOCKTNOSUPPORT:
            case WSAEINVAL:     // when registry is not yet setup.
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            case ERROR_NOT_ENOUGH_QUOTA:
            case WSAENOBUFS:
            case WSAEMFILE:
            case WSA_NOT_ENOUGH_MEMORY:
            // This failure is possible in low memory conditions
            // or due to fault injection during registry read or
            // notification creation.
            case WSASYSCALLFAILURE:
                status = RPC_S_OUT_OF_MEMORY;
                break;

            case ERROR_ACCESS_DENIED:
                status = RPC_S_ACCESS_DENIED;
                break;

            default:
                ASSERT(0);
                // no break - fall through

            case WSAEPROVIDERFAILEDINIT:
                status = RPC_S_OUT_OF_RESOURCES;
                break;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            status, 
            EEInfoDLWSOpen30);

        return (status);
        }

    //
    // make the handle non-inheritable so it goes away when we close it.
    //
    if (FALSE == SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0))
        {
        closesocket(sock);
        return RPC_S_OUT_OF_RESOURCES;
        }

    p->Conn.Socket = sock;

    //
    // Set socket options
    //
    // REVIEW: Set loopback socket option? Ask winsock folks.

    DWORD option;
    int retval = 0;

    if (pInfo->fSetNoDelay)
        {
        option = TRUE;
        retval = setsockopt( sock, pInfo->Protocol, TCP_NODELAY,
                             (PCHAR)&option, sizeof(option) );
        }

    if (pInfo->fSetKeepAlive && retval == 0)
        {
        option = TRUE;
        retval = setsockopt( sock, pInfo->Protocol, SO_KEEPALIVE,
                             (PCHAR)&option, sizeof(option) );
        }

    if (   pInfo->fSetSendBuffer
        && SendBufferSize
        && retval == 0)
        {
        ASSERT(SendBufferSize <= 0xFFFF);
        retval = setsockopt( sock, SOL_SOCKET, SO_SNDBUF,
                             (PCHAR)&SendBufferSize, sizeof(UINT) );
        }

    if (   pInfo->fSetRecvBuffer
        && RecvBufferSize
        && retval == 0 )
        {
        ASSERT(RecvBufferSize <= 0xFFFF);
        retval = setsockopt( sock, SOL_SOCKET, SO_RCVBUF,
                             (PCHAR)&RecvBufferSize, sizeof(UINT) );
        }


    if (retval)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "setsockopt failed %d\n",
                       GetLastError()));

        p->WS_CONNECTION::Abort();

        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (!fHTTP2Open)
        {
        //
        // Set timeout
        //

        if (   WsTransportTable[p->id].fSetKeepAlive
            && ConnTimeout != RPC_C_BINDING_INFINITE_TIMEOUT)
            {
            ASSERT(   ((long)ConnTimeout >= RPC_C_BINDING_MIN_TIMEOUT)
                   && (ConnTimeout <= RPC_C_BINDING_MAX_TIMEOUT));

            // convert the timeout from runtime scale to transport scale
            p->Timeout = ConvertRuntimeTimeoutToWSTimeout(ConnTimeout);
            }
        else
            {
            p->Timeout = INFINITE;
            }
        }

    //
    // HTTP specific connect() done in HTTP_Open().
    //
    if (p->id == HTTP)
        {
        //
        // For HTTP, add the new socket to the io completion port
        // now. For TCP, we'll add it later.
        //
        status = COMMON_PrepareNewHandle((HANDLE)sock);
        if (status != RPC_S_OK)
            {
            closesocket(sock);
            return status;
            }

        return (RPC_S_OK);
        }


    //
    // Connect the socket to the server
    //

    psa->generic.sa_family = pInfo->AddressFamily;

    if ((CallTimeout == INFINITE) || (CallTimeout == 0) 
#ifdef SPX_ON
        || (p->id == SPX)
#endif
        )
        {
        retval = connect(sock, &psa->generic, pInfo->SockAddrSize);
        }
    else
        {
        // we have a specified call timeout. Use ConnectEx instead

        // first, bind the socket. Unlike connect, ConnectEx doesn't
        // accept unbound sockets
        if (p->id != TCP_IPv6)
            {
            sockaddr.sin_addr.S_un.S_addr = INADDR_ANY;
            sockaddr.sin_family = AF_INET;
            sockaddr.sin_port = 0;
            NameLen = sizeof(sockaddr);
            }
        else
            {
            IN6ADDR_SETANY(&sockaddr6);
            sockaddr6.sin6_scope_id = 0;
            NameLen = sizeof(sockaddr6);
            }

        retval = bind(sock,
            (SOCKADDR *)&sockaddr,
            NameLen);

        if (retval == SOCKET_ERROR)
            {
            status = GetLastError();
            RpcpErrorAddRecord(EEInfoGCWinsock,
                status,
                EEInfoDLWSOpen60);

            fGetLastErrorCalled = TRUE;

            goto Handle_WS_OpenError;
            }

        // second retrieve address of ConnectEx
        retval = WSAIoctl(sock, 
            SIO_GET_EXTENSION_FUNCTION_POINTER, 
            (void *) &ConnectExExtensionFunctionUuid,
            sizeof(UUID), 
            (void *) &ConnectEx,
            sizeof(void *), 
            &dwBytesReturned,
            NULL,   // lpOverlapped
            NULL    // lpCompletionRoutine
            );

        if (retval == SOCKET_ERROR)
            {
            // ConnectEx is not available.  We need to default to using connect.
            retval = connect(sock, &psa->generic, pInfo->SockAddrSize);
            }
        else
            {
            // Use ConnectEx.

            ASSERT(dwBytesReturned == sizeof(void *));

            hEvent = I_RpcTransGetThreadEvent();
            ASSERT(hEvent);

            ol.Internal = 0;
            ol.InternalHigh = 0;
            ol.Offset = 0;
            ol.OffsetHigh = 0;
            // There may be a window between winsock's raising the event to signal IO completion
            // and checking if there is a completion port associated with the socket.  We
            // need to make sure that the IO completion packet will not be posted to a port if
            // we associate it with the socket after the event is raised but before the packet is posted.
            ol.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

            retval = ConnectEx(sock, 
                &psa->generic, 
                pInfo->SockAddrSize,
                NULL,   // lpSendBuffer
                0,      // dwSendDataLength
                NULL,   // lpdwBytesSent
                &ol);

            // N.B. ConnectEx returns the opposite of connect - TRUE for
            // success and FALSE for failure. Since the error handling is
            // common, we must make the return value consistent. We do this
            // by reverting the return value for ConnectEx
            retval = !retval;

            if (retval != 0)
                {
                LastError = GetLastError();
                if ((LastError != ERROR_IO_PENDING) && (LastError != WSA_IO_PENDING))
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        LastError, 
                        EEInfoDLWSOpen80);

                    status = LastError;
                    fGetLastErrorCalled = TRUE;

                    goto Handle_WS_OpenError;                    
                    }

                // wait for the result or for timeout
                LastError = WaitForSingleObject(hEvent, CallTimeout);
                if (LastError == WAIT_TIMEOUT)
                    {
                    // we have hit a timeout. Kill the socket and bail out
                    status = RPC_S_CALL_CANCELLED;
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        status, 
                        EEInfoDLWSOpen50,
                        CallTimeout);

                    p->WS_CONNECTION::Abort();

                    // wait for our IO to complete. Should be quick after
                    // we closed the socket
                    LastError = WaitForSingleObject(hEvent, INFINITE);
                    ASSERT(LastError == WAIT_OBJECT_0);
                    ASSERT(HasOverlappedIoCompleted(&ol));

                    return status;
                    }
                else
                    {
                    ASSERT(LastError == WAIT_OBJECT_0);
                    ASSERT(HasOverlappedIoCompleted(&ol));

                    // Retrieve the overlapped result.  No need to wait since the IO has
                    // already completed.
                    if (!WSAGetOverlappedResult(sock, &ol, &Transfer, FALSE, &Flags))
                        {
                        // set retval to the WSA error code.
                        retval = WSAGetLastError();

                        RpcpErrorAddRecord(EEInfoGCWinsock,
                            retval, 
                            EEInfoDLWSOpen90);

                        status = retval;
                        fGetLastErrorCalled = TRUE;
                        }
                    else
                        {
                        retval = setsockopt(sock,
                            SOL_SOCKET,
                            SO_UPDATE_CONNECT_CONTEXT,
                            NULL,
                            0
                            );
                        }
                    }
                }
            else
                {
                retval = setsockopt(sock,
                    SOL_SOCKET,
                    SO_UPDATE_CONNECT_CONTEXT,
                    NULL,
                    0
                    );
                }
            }
        }

    if (retval == 0)
        {
        //
        // After we're done with connect/ConnectEx, add the socket
        // to the completion port.
        //
        status = COMMON_PrepareNewHandle((HANDLE)sock);
        if (status != RPC_S_OK)
            {
            goto Handle_WS_OpenError;
            }

        fSANConnection = IsUserModeSocket(sock, &status);
        if (status == RPC_S_OK)
            {
            if (fSANConnection && !fHTTP2Open)
                {
                // reinitialize vtbl
                p = new (p) WS_SAN_CLIENT_CONNECTION;
                }
            TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) p);
            return(RPC_S_OK);
            }
        }

Handle_WS_OpenError:

    if (!fGetLastErrorCalled)
        {
        status = GetLastError();
        }

    ServerAddress.ZeroOut();
    if (p->id == TCP)
        {
        ServerAddress.SetIPv4ClientIdentifier(psa->inetaddr.sin_addr.S_un.S_addr, FALSE);
        }
    else if (p->id == TCP_IPv6)
        {
        ServerAddress.SetIPv6ClientIdentifier(&psa->ipaddr, sizeof(psa->ipaddr), FALSE);
        }

    RpcpErrorAddRecord(EEInfoGCWinsock,
        status, 
        EEInfoDLWSOpen20,
        (ULONG)ntohs(RpcpGetIpPort(psa)),
        ServerAddress.GetDebugULongLong1(),
        ServerAddress.GetDebugULongLong2());

    switch(status)
        {
        case WSAENETUNREACH:
        case STATUS_BAD_NETWORK_PATH:
        case STATUS_NETWORK_UNREACHABLE:
        case STATUS_PROTOCOL_UNREACHABLE:
        case WSAEHOSTUNREACH:
        case STATUS_HOST_UNREACHABLE:
        case WSAETIMEDOUT:
        case STATUS_LINK_TIMEOUT:
        case STATUS_IO_TIMEOUT:
        case STATUS_TIMEOUT:
        case WSAEADDRNOTAVAIL:
        case STATUS_INVALID_ADDRESS:
        case STATUS_INVALID_ADDRESS_COMPONENT:
            status = ERROR_RETRY;
            break;

        case WSAENOBUFS:
        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_PAGEFILE_QUOTA:
        case STATUS_COMMITMENT_LIMIT:
        case STATUS_WORKING_SET_QUOTA:
        case STATUS_NO_MEMORY:
        case STATUS_QUOTA_EXCEEDED:
        case STATUS_TOO_MANY_PAGING_FILES:
        case STATUS_REMOTE_RESOURCES:
        case ERROR_NOT_ENOUGH_MEMORY:
            status = RPC_S_OUT_OF_MEMORY;
            break;

        default:
            VALIDATE(status)
                {
                WSAENETDOWN,
                STATUS_INVALID_NETWORK_RESPONSE,
                STATUS_NETWORK_BUSY,
                STATUS_NO_SUCH_DEVICE,
                STATUS_NO_SUCH_FILE,
                STATUS_OBJECT_PATH_NOT_FOUND,
                STATUS_OBJECT_NAME_NOT_FOUND,
                STATUS_UNEXPECTED_NETWORK_ERROR,
                WSAECONNREFUSED,
                STATUS_REMOTE_NOT_LISTENING,
                STATUS_CONNECTION_REFUSED,
                WSAECONNABORTED,
                STATUS_LOCAL_DISCONNECT,
                STATUS_TRANSACTION_ABORTED,
                STATUS_CONNECTION_ABORTED,
                WSAEADDRINUSE,
                ERROR_CONNECTION_REFUSED
                } END_VALIDATE;

            status = RPC_S_SERVER_UNAVAILABLE;
            break;
        }

    RpcpErrorAddRecord(EEInfoGCWinsock,
        status, 
        EEInfoDLWSOpen40);

    p->WS_CONNECTION::Abort();

    return(status);
}

/////////////////////////////////////////////////////////////////////
//
// TCP/IP specific stuff
//

RPC_STATUS
IP_ADDRESS_RESOLVER::NextAddress(
    OUT SOCKADDR_STORAGE *pAddress
    )
/*++

Routine Description:

    Returns the next IP address associated with the Name
    parameter to the constructor.

    During the first call if check for loopback and for dotted numeric IP
    address formats.  If these fail then it begins a complex lookup
    (WSALookupServiceBegin) and returns the first available address.

    During successive calls in which a complex lookup was started
    it returns sucessive addressed returned by WSALookupServiceNext().

Arguments:

    pAddress - If successful, the pAddress->sin_addr.s_addr member is set
        to an IP address to try. For all cosClients, if IPvToUse is ipvtuIPAny,
        pAddress->sin_family is set to the actual address family for the
        returned address. This allows client to find out what address was
        returned to them.

Return Value:

    RPC_S_OK - pAddress contains a new IP address

    RPC_S_SERVER_UNAVAILABLE - Unable to find any more addresses
    RPC_S_OUT_OF_MEMORY

--*/
{
    int err;
    RPC_STATUS status;
    SOCKADDR_IN6 *IPv6Address = (SOCKADDR_IN6 *)pAddress;
    SOCKADDR_STORAGE addr;
    int ai_flags;
    int i;
    USES_CONVERSION;
    CStackAnsi AnsiName;
    BOOL fValidIPv4;
    BOOL fValidIPv6;
    ADDRINFO *ThisAddrInfo;

    if (!AddrInfo)
        {
        if (!Name)
            {
            if (cos == cosServer)
                {
                if (IPvToUse == ipvtuIPv6)
                    {
                    IPv6Address->sin6_flowinfo = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr)    ) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3) = 0;
                    IPv6Address->sin6_scope_id = 0;
                    }
                else
                    {
                    ASSERT(IPvToUse == ipvtuIPv4);
                    ((SOCKADDR_IN *)pAddress)->sin_addr.s_addr = INADDR_ANY;
                    }
                }
            else
                {
                if (LoopbacksReturned > 2)
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_SERVER_UNAVAILABLE, 
                        EEInfoDLNextAddress40);
                    return RPC_S_SERVER_UNAVAILABLE;
                    }

                if ((IPvToUse == ipvtuIPv6)
                    || ((IPvToUse == ipvtuIPAny) 
                         && 
                         (LoopbacksReturned == 1)
                       )
                   )
                    {
                    IPv6Address->sin6_family = AF_INET6;
                    IPv6Address->sin6_flowinfo = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr)    ) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3) = 1;
                    IPv6Address->sin6_scope_id = 0;
                    }
                else if ((IPvToUse == ipvtuIPv4)
                         || ((IPvToUse == ipvtuIPAny) 
                             && 
                             (LoopbacksReturned == 0)
                           )
                        )
                    {
                    // Loopback - assign result of htonl(INADDR_LOOPBACK)
                    // Little-endian dependence.
                    ((SOCKADDR_IN *)pAddress)->sin_addr.s_addr = 0x0100007F;
                    ((SOCKADDR_IN *)pAddress)->sin_family = AF_INET;
                    }
                else
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_SERVER_UNAVAILABLE, 
                        EEInfoDLNextAddress40);
                    return RPC_S_SERVER_UNAVAILABLE;
                    }

                LoopbacksReturned ++;
                }

            return RPC_S_OK;
            }

        if (cos == cosServer)
            ai_flags = AI_PASSIVE;
        else
            ai_flags = 0;

        switch (IPvToUse)
            {
            case ipvtuIPAny:
                // make a hint for any protocol
                Hint.ai_flags = ai_flags | AI_NUMERICHOST;
                Hint.ai_family = PF_UNSPEC;
                break;

            case ipvtuIPv4:
                // make a hint for any v4 protocol
                Hint.ai_flags = ai_flags | AI_NUMERICHOST;
                Hint.ai_family = AF_INET;
                break;

            case ipvtuIPv6:
                // make a hint for TCPv6
                Hint.ai_flags = ai_flags | AI_NUMERICHOST;
                Hint.ai_family = AF_INET6;
                break;

            default:
                ASSERT((IPvToUse == ipvtuIPAny)
                    || (IPvToUse == ipvtuIPv4)
                    || (IPvToUse == ipvtuIPv6));
            }

        ATTEMPT_STACK_W2A(AnsiName, Name);

        err = getaddrinfo(AnsiName, 
            NULL, 
            &Hint,
            &AddrInfo);

        if (err)
            {
            ASSERT((err != EAI_BADFLAGS)
                && (err != EAI_SOCKTYPE));

            // take down the numeric hosts flag - we'll try
            // to resolve it as a DNS name
            Hint.ai_flags &= ~AI_NUMERICHOST;

            err = getaddrinfo(AnsiName,
                NULL,
                &Hint,
                &AddrInfo);

            if (err)
                {
                RpcpErrorAddRecord(EEInfoGCWinsock,
                    err, 
                    EEInfoDLNextAddress10,
                    Name);
                if (err == EAI_MEMORY)
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_OUT_OF_MEMORY, 
                        EEInfoDLNextAddress20);
                    return RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    VALIDATE(err)
                        {
                        EAI_AGAIN,
                        EAI_FAMILY,
                        EAI_FAIL,
                        EAI_NODATA,
                        EAI_NONAME,
                        EAI_SERVICE
                        } END_VALIDATE;
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_SERVER_UNAVAILABLE, 
                        EEInfoDLNextAddress30);
                    return RPC_S_SERVER_UNAVAILABLE;
                    }
                }

            }

        // successfully resolved this address
        // just stick it in and we'll let the code below handle it
        CurrentAddrInfo = AddrInfo;
        }

    ASSERT(AddrInfo != NULL);

    // get the next value from the cache
    while (CurrentAddrInfo)
        {
        ThisAddrInfo = CurrentAddrInfo;
        CurrentAddrInfo = CurrentAddrInfo->ai_next;

        fValidIPv4 = FALSE;
        fValidIPv6 = FALSE;

        if (ThisAddrInfo->ai_family == AF_INET)
            {
            fValidIPv4 = TRUE;
            }

        if (ThisAddrInfo->ai_family == AF_INET6)
            {
            fValidIPv6 = TRUE;
            }

        if ((IPvToUse == ipvtuIPv4) && !fValidIPv4)
            continue;

        if ((IPvToUse == ipvtuIPv6) && !fValidIPv6)
            continue;

        if ((IPvToUse == ipvtuIPAny) && !fValidIPv4 && !fValidIPv6)
            continue;

        if (ThisAddrInfo->ai_family == AF_INET)
            {
            ASSERT((IPvToUse == ipvtuIPv4)
                || (IPvToUse == ipvtuIPAny));
            RpcpCopyIPv4Address((SOCKADDR_IN *)ThisAddrInfo->ai_addr, (SOCKADDR_IN *)pAddress);
            ((SOCKADDR_IN *)pAddress)->sin_family = AF_INET;
            }
        else
            {
            ASSERT((IPvToUse == ipvtuIPv6)
                || (IPvToUse == ipvtuIPAny));
            RpcpCopyIPv6Address((SOCKADDR_IN6 *)ThisAddrInfo->ai_addr, IPv6Address);
            IPv6Address->sin6_family = AF_INET6;
            IPv6Address->sin6_scope_id = ((SOCKADDR_IN6 *)ThisAddrInfo->ai_addr)->sin6_scope_id;
            IPv6Address->sin6_flowinfo = 0;
            }

        return RPC_S_OK;
        }

    RpcpErrorAddRecord(EEInfoGCWinsock,
        RPC_S_SERVER_UNAVAILABLE, 
        EEInfoDLNextAddress40);

    return RPC_S_SERVER_UNAVAILABLE;
}

IP_ADDRESS_RESOLVER::~IP_ADDRESS_RESOLVER()
{
    if (AddrInfo)
        freeaddrinfo(AddrInfo);
}

RPC_STATUS
IP_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector,
    IN ULONG NICFlags,
    IN RPC_CHAR *NetworkAddress OPTIONAL,
    IN WS_ADDRESS *Address OPTIONAL
    )
/*++

Routine Description:

    Builds a vector of IP addresses supported by this machine.

Arguments:

    ppAddressVector - A place to store the vector.
    NICFlags - the flags as specified in the RPC_POLICY of the
        RpcServerUse*Protseq* APIs
    NetworkAddess - the network address we were asked to listen
        on. May be NULL.
    Address - in the case of firewall, the addresses we chose to
        listen on.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    //
    // Figure out all of our IP addresses
    //
    NETWORK_ADDRESS_VECTOR *pVector;
    unsigned i;
    RPC_CHAR *NextAddress;
    int NumberOfAddresses;
    WS_ADDRESS *CurrentAddress;

    if ((pFirewallTable == 0 || NICFlags == RPC_C_BIND_TO_ALL_NICS) && !NetworkAddress)
        {
        ULONG Ignored;

        // Get Dns hostname
        pVector = (NETWORK_ADDRESS_VECTOR *)AllocateAndGetComputerName(cnaNew,
            ComputerNameDnsHostname,
            FIELD_OFFSET(NETWORK_ADDRESS_VECTOR, NetworkAddresses[1]),
            FIELD_OFFSET(NETWORK_ADDRESS_VECTOR, NetworkAddresses[1]),
            &Ignored);
        if (pVector == NULL)
            {
            RpcpErrorAddRecord(EEInfoGCWinsock,
                RPC_S_OUT_OF_MEMORY, 
                EEInfoDLIPBuildAddressVector10,
                GetLastError());
            return RPC_S_OUT_OF_MEMORY;
            }

        pVector->Count = 1;
        pVector->NetworkAddresses[0] = (RPC_CHAR*)&pVector->NetworkAddresses[1];
        }
    else if (NetworkAddress)
        {
        // the length of the network address including the terminating NULL
        // (in characters)
        int NetworkAddressLength;
#if DBG
            {
            // if we have a network address, it must be in IP address notation
            // make an ASSERT to verify that nobody ever passes an dns name here
            ADDRINFO Hint;
            ADDRINFO *AddrInfo;
            USES_CONVERSION;
            CStackAnsi AnsiName;
            int err;

            RpcpMemorySet(&Hint, 0, sizeof(Hint));
            Hint.ai_flags = AI_NUMERICHOST;
            ATTEMPT_STACK_W2A(AnsiName, NetworkAddress);

            err = getaddrinfo(AnsiName,
                NULL,
                &Hint,
                &AddrInfo);

            // this is a numeric address. It should never fail
            ASSERT (!err);
            }
#endif

        NetworkAddressLength = RpcpStringLength(NetworkAddress) + 1;

        pVector = (NETWORK_ADDRESS_VECTOR *)
              I_RpcAllocate(  sizeof(NETWORK_ADDRESS_VECTOR)
                            + sizeof(RPC_CHAR *)
                            + (sizeof(RPC_CHAR) * NetworkAddressLength));
        if (pVector == NULL)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }

        pVector->Count = 1;

        NextAddress = (RPC_CHAR *)&pVector->NetworkAddresses[1];

        pVector->NetworkAddresses[0] = NextAddress;

        RpcpMemoryCopy(NextAddress, NetworkAddress, NetworkAddressLength * 2);
        }
    else
        {
        NumberOfAddresses = 0;
        CurrentAddress = Address;
        while (CurrentAddress != NULL)
            {
            NumberOfAddresses ++;
            CurrentAddress = (WS_ADDRESS *)CurrentAddress->pNextAddress;
            }

        pVector = (NETWORK_ADDRESS_VECTOR *)
              I_RpcAllocate(  sizeof(NETWORK_ADDRESS_VECTOR)
                            + (sizeof(RPC_CHAR *)
                            + max(IPv6_MAXIMUM_RAW_NAME, IP_MAXIMUM_RAW_NAME) * sizeof(RPC_CHAR))
                              * NumberOfAddresses);
        if (pVector == NULL)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }

        pVector->Count = NumberOfAddresses;

        RPC_CHAR *NextAddress = (RPC_CHAR*)&pVector->
            NetworkAddresses[NumberOfAddresses];
        IN_ADDR addr;
        SOCKADDR_IN6 *Ipv6Address;
        unsigned j;

        CurrentAddress = Address;
        for (i = 0; i < NumberOfAddresses; i++)
            {
            pVector->NetworkAddresses[i] = NextAddress;

            if (CurrentAddress->id != TCP_IPv6)
                {
                addr.s_addr = ((SOCKADDR_IN *)(&CurrentAddress->ListenAddr.inetaddr))->sin_addr.s_addr;

                swprintf((RPC_SCHAR *)NextAddress, RPC_CONST_SSTRING("%d.%d.%d.%d"),
                         addr.s_net, addr.s_host, addr.s_lh, addr.s_impno);
                }
            else
                {
                Ipv6Address = (SOCKADDR_IN6 *)(&CurrentAddress->ListenAddr.inetaddr);
                

                swprintf((RPC_SCHAR *)NextAddress, RPC_CONST_SSTRING("%X:%X:%X:%X:%X:%X:%X:%X"),
                         Ipv6Address->sin6_addr.u.Word[0],
                         Ipv6Address->sin6_addr.u.Word[1],
                         Ipv6Address->sin6_addr.u.Word[2],
                         Ipv6Address->sin6_addr.u.Word[3],
                         Ipv6Address->sin6_addr.u.Word[4],
                         Ipv6Address->sin6_addr.u.Word[5],
                         Ipv6Address->sin6_addr.u.Word[6],
                         Ipv6Address->sin6_addr.u.Word[7]
                         );
                }
            NextAddress += max(IPv6_MAXIMUM_RAW_NAME, IP_MAXIMUM_RAW_NAME);
            CurrentAddress = (WS_ADDRESS *)CurrentAddress->pNextAddress;
            }
        }


    *ppAddressVector = pVector;

    return(RPC_S_OK);
}


RPC_STATUS
WS_Bind(
    IN SOCKET sock,
    IN OUT WS_SOCKADDR *pListenAddr,
    IN BOOL IpProtocol,
    IN DWORD EndpointFlags
    )
/*++

Routine Description:

    Binds the socket to a port.  Takes into account the endpoint flags
    and the value of the port in the WS_SOCKADDR.  There is IP specific
    code for firewalls which is keyed off of the EndpointFlags.

Arguments:

    sock - The socket to bind
    pListenAddr - On input the sin_port member is checked. For fixed endpoints
        this is set and is the only address bound to.  On output it contains
        the info on the fully bound socket.
    IpProtocol - Whether this is an IP protocol.  TRUE for TCP/IP and HTTP.
    EndpointFlags - see RpcTrans.hxx.  If non-zero and we're allocating a
        dynamic port then we must call the runtime.

Return Value:

    RPC_S_OK

    RPC_S_DUPLICATE_ENDPOINT : when a fixed endpoint is already in use.
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT

--*/
{
    RPC_STATUS status;
    int Retries = 0;
    BOOL fFirewallPorts = FALSE;
    BOOL fSetSockOptFailed;
    DWORD LastError;
    USHORT Port;

    if (IpProtocol && (RpcpGetIpPort(pListenAddr) == 0))
        {
        Retries = 8;
        }

    do
        {
        if (Retries)
            {
            status = I_RpcServerAllocateIpPort(EndpointFlags, &Port);

            if (status != RPC_S_OK)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    status, 
                    EEInfoDLWSBind10,
                    EndpointFlags);
                break;
                }

            RpcpSetIpPort(pListenAddr, Port);

            // Check if any firewall ports are defined. If they are remember
            // that so we can map the error correctly.

            if (!fFirewallPorts && (RpcpGetIpPort(pListenAddr) == 0))
                {
                Retries = 0;
                }
            else
                {
                Retries--;
                fFirewallPorts = TRUE;
                }

            RpcpSetIpPort(pListenAddr, htons(RpcpGetIpPort(pListenAddr)));
            }
        else
            {
            status = RPC_S_OK;
            }


WS_Bind_Rebind:
        if ( bind(sock,
                  &pListenAddr->generic,
                  sizeof(WS_SOCKADDR)) )
            {

            LastError = GetLastError();
            switch(LastError)
                {
                case WSAEACCES:
                    fSetSockOptFailed = WS_ProtectListeningSocket(sock, FALSE);
                    // if this failed, we have to bail out, or we'll spin
                    if (fSetSockOptFailed)
                        {
                        status = GetLastError();
                        RpcpErrorAddRecord(EEInfoGCRuntime,
                            status, 
                            EEInfoDLWSBind20);
                        break;
                        }

                    goto WS_Bind_Rebind;
                    // no break, because we can't end up here

                case WSAEADDRINUSE:
                    {
                    status = RPC_S_DUPLICATE_ENDPOINT;
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        status, 
                        EEInfoDLWSBind45,
                        (ULONG)ntohs(RpcpGetIpPort(pListenAddr)));
                    break;
                    }

                case WSAENOBUFS:
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        LastError, 
                        EEInfoDLWSBind40);
                    status = RPC_S_OUT_OF_MEMORY;
                    break;
                    }

                default:
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        LastError, 
                        EEInfoDLWSBind50);
                    status = RPC_S_CANT_CREATE_ENDPOINT;
                    break;
                    }
                }
            }
        }
    while ( (status == RPC_S_DUPLICATE_ENDPOINT) && Retries);

    if (status != RPC_S_OK)
        {
        if (fFirewallPorts && status == RPC_S_DUPLICATE_ENDPOINT)
            {
            status = RPC_S_OUT_OF_RESOURCES;
            }

        RpcpErrorAddRecord(EEInfoGCWinsock,
            status, 
            EEInfoDLWSBind30);
        return(status);
        }

    int length = sizeof(WS_SOCKADDR);
    if (getsockname(sock, &pListenAddr->generic, &length))
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}

RPC_STATUS
CDP_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    Look up the Cluster node number of this node and build
    the appropriate vector

Arguments:

    ppAddressVector - A place to store the vector.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    HKEY ParamsKey;
    NETWORK_ADDRESS_VECTOR * pVector;
    const RPC_CHAR *ClussvcParams =
                RPC_CONST_STRING("System\\CurrentControlSet\\Services\\ClusSvc\\Parameters");
    RPC_CHAR *ClusRegNodeId = RPC_STRING_LITERAL("NodeId");
    DWORD KeyType;
    RPC_CHAR NodeIdString[ CDP_MAXIMUM_RAW_NAME ];
    DWORD StringLength = CDP_MAXIMUM_RAW_NAME * sizeof( RPC_CHAR );
    DWORD status;

    //
    // open the Clussvc parameters key and extrace the NodeId
    //

    status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         (const RPC_SCHAR *)ClussvcParams,
                         &ParamsKey );

    if ( status != ERROR_SUCCESS )
        {
        return RPC_S_INVALID_NET_ADDR;
        }

    status = RegQueryValueEx(ParamsKey,
                             (const RPC_SCHAR *)ClusRegNodeId,
                             NULL,
                             &KeyType,
                             (LPBYTE)&NodeIdString,
                             &StringLength);

    RegCloseKey( ParamsKey );

    if ( status != ERROR_SUCCESS ||
         KeyType != REG_SZ ||
                (( StringLength / sizeof( RPC_CHAR )) > CDP_MAXIMUM_RAW_NAME ))
        {
        return RPC_S_INVALID_NET_ADDR;
        }

    pVector = (NETWORK_ADDRESS_VECTOR *)
        I_RpcAllocate( sizeof(NETWORK_ADDRESS_VECTOR ) +
                       sizeof(RPC_CHAR *) +
                       StringLength );

    if (pVector == NULL)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR *)&pVector->NetworkAddresses[1];

    RpcpStringCopy( pVector->NetworkAddresses[0], NodeIdString );

    *ppAddressVector = pVector;

    return RPC_S_OK;
}

typedef struct tagIPVersionSettings
{
    IPVersionToUse IPVersion;
    BOOL fUseIPv6;
} IPVersionSettings;

const static IPVersionSettings ListenIPVersionSettings[2] = {{ipvtuIPv4, FALSE}, {ipvtuIPv6, TRUE}};

typedef enum tagIPVersionSettingsIndexes
{
    ipvsiIPv4SettingsIndex = 0,
    ipvsiIPv6SettingsIndex
} IPVersionSettingsIndexes;

typedef struct tagListenAddressListElement
{
    INT ProtocolId;
    IPVersionSettingsIndexes IPVersionSettingsIndex;
    BOOL fSuccessfullyInitialized;
    RPC_STATUS ErrorCode;
    union
        {
        SOCKADDR_IN6 inet6Addr;
        SOCKADDR_IN inetAddr;
        } u;
} ListenAddressListElement;

typedef struct tagTCPServerListenParams
{
    INT ProtocolId;
    IPVersionSettingsIndexes IPVersionSettingsIndex;
} TCPServerListenParams;

const static TCPServerListenParams HTTPListenParams[1] = {HTTP, ipvsiIPv4SettingsIndex};
const static TCPServerListenParams TCPListenParams[2] = 
    {{TCP, ipvsiIPv4SettingsIndex}, 
    {TCP_IPv6, ipvsiIPv6SettingsIndex}};
const int MAX_TCP_SERVER_LISTEN_LOOP_ITERATIONS = 2;

RPC_STATUS
TCP_ServerListenEx(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    IN BOOL fHttp,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    This routine allocates a port to receive new client connections.
    If successful a call to COMMON_CompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur. If the runtime
    is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    ThisAddress - A pointer to the loadable transport interface address.
    NetworkAddress - the address to listen on. This can be specified for
        IP only, and it *cannot* be a DNS name. If it is, this function
        will work incorrectly for multihomed/multi IP machines.
    pEndpoint - Optionally, the endpoint (port) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    EndpointFlags - Flags that control dynamic port allocation
    NICFlags - Flags that control network (IP) address binding
    SecurityDescriptor - Meaningless for TCP

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    RPC_STATUS status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    unsigned i;
    PWS_ADDRESS pList, pOld;
    int NeededAddressListSize;
    ListenAddressListElement *ListenAddressList;
    ListenAddressListElement *CurrentListElement;
    int AddressListSize;
    SOCKADDR_IN IPv4Address;
    SOCKADDR_IN6 *IPv6Address;
    int LoopIterations;
    TCPServerListenParams *ParamsToUse;
    IPVersionSettingsIndexes IPVersionSettingsIndex;
    BOOL fAtLeastOneAddressInitialized;
    USHORT PortNumber;      // in network byte order!
    BOOL fDynamicEndpoint;
    BOOL fFatalErrorEncountered;
    RPC_STATUS FatalErrorCode;
    WS_ADDRESS *LastSuccessfullyInitializedAddress;
    WS_ADDRESS *NextAddress;
    BOOL fDualTransportConfiguration = FALSE;
    BOOL fLoopbackAddressProcessed;

    // sizing pass - allocate sufficient memory
    if (pFirewallTable == 0 || NICFlags == RPC_C_BIND_TO_ALL_NICS)
        {
        if (fHttp)
            AddressListSize = 1;
        else
            {
            AddressListSize = 2;
            fDualTransportConfiguration = TRUE;
            }
        }
    else
        {
        AddressListSize = pFirewallTable->NumAddresses + 1;
        }

    NeededAddressListSize = AddressListSize * sizeof(ListenAddressListElement);

    ListenAddressList = new ListenAddressListElement[NeededAddressListSize];
    if (ListenAddressList == NULL)
        return RPC_S_OUT_OF_MEMORY;

    fAtLeastOneAddressInitialized = FALSE;
    RpcpMemorySet(ListenAddressList, 
        0,
        AddressListSize * sizeof(ListenAddressListElement));

    // processing pass. Set all the required addresses in the array
    if (pFirewallTable == 0 || NICFlags == RPC_C_BIND_TO_ALL_NICS)
        {
        if (fHttp)
            {
            ASSERT(AddressListSize == 1);
            ParamsToUse = (TCPServerListenParams *)HTTPListenParams;
            LoopIterations = 1;
            }
        else
            {
            ParamsToUse = (TCPServerListenParams *)TCPListenParams;
            LoopIterations = 2;
            }

        for (i = 0; i < LoopIterations; i ++)
            {
            CurrentListElement = &ListenAddressList[i];
            CurrentListElement->ProtocolId = ParamsToUse[i].ProtocolId;
            IPVersionSettingsIndex = ParamsToUse[i].IPVersionSettingsIndex;
            CurrentListElement->IPVersionSettingsIndex = IPVersionSettingsIndex;

            IP_ADDRESS_RESOLVER resolver(NetworkAddress, 
                cosServer,
                ListenIPVersionSettings[IPVersionSettingsIndex].IPVersion       // IP version to use
                );

            // resolve the address. Since this cannot be a DNS name, we will resolve
            // to one address at most. We choose the ipv6 address, because it has space
            // for both. The actual parameter that determines the type of name resolution
            // to be done is IP version to use passed to the constructor
            status = resolver.NextAddress((SOCKADDR_STORAGE *)&CurrentListElement->u.inet6Addr);
            if (status == RPC_S_OK)
                {
                fAtLeastOneAddressInitialized = TRUE;
                CurrentListElement->fSuccessfullyInitialized = TRUE;
                }
            }
        }
    else
        {
        fAtLeastOneAddressInitialized = TRUE;
        fLoopbackAddressProcessed = FALSE;

        for (i = 0; i < AddressListSize; i++)
            {
            CurrentListElement = &ListenAddressList[i];

            if (fHttp)
                {
                CurrentListElement->ProtocolId = HTTP;
                }
            else 
                {
                CurrentListElement->ProtocolId = TCP;                
                }

            CurrentListElement->IPVersionSettingsIndex = ipvsiIPv4SettingsIndex;
            CurrentListElement->fSuccessfullyInitialized = TRUE;

            if (i == pFirewallTable->NumAddresses)
                {
                CurrentListElement->u.inetAddr.sin_addr.s_addr = 0x0100007F;
                }
            else
                {
                if (pFirewallTable->Addresses[i] == 0x0100007F)
                    fLoopbackAddressProcessed = TRUE;
                CurrentListElement->u.inetAddr.sin_addr.s_addr = pFirewallTable->Addresses[i];
                }
            }

        // if the loopback address was in the firewall configuration, 'forget' about
        // the last entry we added for the loopback address. Otherwise, we'll have
        // it twice in the list, and this will cause errors
        if (fLoopbackAddressProcessed)
            {
            AddressListSize --;
            // since we added one, and fLoopbackAddressProcessed is set only if
            // we find something in the list, then AddressListSize must still be
            // greater than 0.
            ASSERT(AddressListSize > 0);
            }
        }

    if (fAtLeastOneAddressInitialized)
        {
        fAtLeastOneAddressInitialized = FALSE;
        }
    else
        {
        // the only place where we can fail so far is name resolution. If this
        // fails, return the status
        delete [] ListenAddressList;
        return status;
        }

    // Figure out what port to bind to.

    if (*pEndpoint)
        {
        status = EndpointToPortNumber(*pEndpoint, PortNumber);
        if (status != RPC_S_OK)
            {
            delete [] ListenAddressList;
            return(status);
            }

        PortNumber = htons(PortNumber);
        fDynamicEndpoint = 0;
        }
    else
        {
        PortNumber = 0;
        fDynamicEndpoint = TRUE;
        }

    // zoom in through the array address, and listen on all successfully initialized
    // protocols
    pList = pAddress;
    fFatalErrorEncountered = FALSE;

    for (i = 0; i < AddressListSize; i ++)
        {
        CurrentListElement = &ListenAddressList[i];
        if (!CurrentListElement->fSuccessfullyInitialized)
            continue;

        if (pList == 0)
            {
            pList = new WS_ADDRESS;
            if (pList == 0)
                {
                fFatalErrorEncountered = TRUE;

                FatalErrorCode = RPC_S_OUT_OF_MEMORY;
                break;
                }

            pOld->pNextAddress = pList;
            }

        sockaddr = &(pList->ListenAddr);

        RpcpMemorySet(sockaddr, 0, sizeof(*sockaddr));

        // the port we have set is already in network byte order - 
        // no need to change it
        RpcpSetIpPort(sockaddr, PortNumber);

        pList->fDynamicEndpoint = fDynamicEndpoint;

        if (ListenIPVersionSettings[CurrentListElement->IPVersionSettingsIndex].fUseIPv6)
            {
            ((SOCKADDR_IN6 *)sockaddr)->sin6_flowinfo = 0;
            RpcpCopyIPv6Address(&CurrentListElement->u.inet6Addr, (SOCKADDR_IN6 *)sockaddr);
            }
        else
            {
            RpcpCopyIPv4Address(&CurrentListElement->u.inetAddr, (SOCKADDR_IN *)sockaddr);
            }

        pList->id = CurrentListElement->ProtocolId;
        pList->NewConnection = WS_NewConnection;
        pList->SubmitListen = WS_SubmitAccept;
        SetProtocolMultiplier(pList, 1);
        pList->pAddressVector = 0;
        pList->Endpoint = 0;
        pList->QueueSize = PendingQueueSize;
        pList->EndpointFlags = EndpointFlags;

        sockaddr->generic.sa_family = WsTransportTable[CurrentListElement->ProtocolId].AddressFamily;

        // we must know whether we got WSAEAFNOSUPPORT when we opened the socket
        // if yes, we must record this in CurrentElement, and we must not blow
        // the address. If we got something else, we should abort even in dual
        // transport config. The addresses on the firewall are a separate thing -
        // we ignore the ones we can't listen on.

        // Actually listen
        status = WS_ServerListenCommon(pList);

        // the next two are actually initialized in WS_ServerListenCommon as well,
        // so we want to override the seetings WS_ServerListenCommon makes
        pList->pFirstAddress = pAddress;
        pList->pNextAddress = NULL;

        if (status != RPC_S_OK)
            {
            if ((status == RPC_S_DUPLICATE_ENDPOINT) 
                || (fDualTransportConfiguration && (status != RPC_P_ADDRESS_FAMILY_INVALID)))
                {
                // if either somebody else is listening on our port for this address,
                // or this is a dual transport configuratuon, and we faile to listen
                // on one of the transports for reasons other that it not being
                // installed, bail out
                fFatalErrorEncountered = TRUE;
                FatalErrorCode = status;
                break;
                }
            else if (fDualTransportConfiguration && (status == RPC_P_ADDRESS_FAMILY_INVALID))
                {
                pList->InAddressList = Inactive;

                // we still need to register the address with PnP
                // make sure it's not already there
                ASSERT(RpcpIsListEmpty(&pList->ObjectList));
                TransportProtocol::AddObjectToProtocolList(pList);
                }

            CurrentListElement->ErrorCode = status;

            CurrentListElement->fSuccessfullyInitialized = FALSE;
            }
        else
            {
            if (i == 0)
                {
                PortNumber = RpcpGetIpPort(&pAddress->ListenAddr);
                }
            fAtLeastOneAddressInitialized = TRUE;
            }

        pOld = pList;
        pList = 0;
        }

    // compact the list by removing addresses we couldn't successfully listen on
    pList = pAddress;
    for (i = 0; i < AddressListSize; i ++)
        {
        // we may have an early break if a memory allocation failed
        if (pList == NULL)
            break;

        // if this address has not initialized successfully, and this is not
        // the first address, and either none of the elements initialized
        // successfully or this is not a dual transport configuration with
        // error RPC_P_ADDRESS_FAMILY_INVALID, delete the element
        if (!ListenAddressList[i].fSuccessfullyInitialized && (i > 0) && 
            (!fAtLeastOneAddressInitialized 
                || (!fDualTransportConfiguration 
                    || (ListenAddressList[i].ErrorCode != RPC_P_ADDRESS_FAMILY_INVALID)
                   )
                ))
            {
            ASSERT(pOld != pList);
            pOld->pNextAddress = pList->pNextAddress;
            NextAddress = (WS_ADDRESS *)pList->pNextAddress;
            TransportProtocol::RemoveObjectFromProtocolList(pList);
            delete pList;
            }
        else
            {
            pOld = pList;
            NextAddress = (WS_ADDRESS *)pList->pNextAddress;
            }

        pList = NextAddress;
        }

    if (!fAtLeastOneAddressInitialized)
        {
        TransportProtocol::RemoveObjectFromProtocolList(pAddress);
        delete [] ListenAddressList;
        if (status == RPC_P_ADDRESS_FAMILY_INVALID)
            status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        return status;
        }

    // the attempt to listen on dual protocol configurations may have left EEInfo
    // record in the TEB. If we're here, we have succeeded, and we can delete them
    RpcpPurgeEEInfo();

    if (!ListenAddressList[0].fSuccessfullyInitialized)
        {
        // here, pOld must be the last successfully initialized element
        // or the last element we haven't given up on (i.e. potentially
        // active through PnP)
        // It cannot be the first element, or we would have bailed out
        // by now. We cannot have only one element either
        ASSERT(pOld->pNextAddress == NULL);
        ASSERT(pAddress->pNextAddress != NULL);

        // here at least one has succeeded and all non-first failed
        // elements are deleted, though a fatal error may have been
        // encountered. We need to deal with the first element
        // because we don't want to expose elements with failed
        // initialization outside this routine
        if (!(fDualTransportConfiguration && (ListenAddressList[0].ErrorCode == RPC_P_ADDRESS_FAMILY_INVALID)))
            {
            // remove the element we will copy to the first element
            TransportProtocol::RemoveObjectFromProtocolList(pOld);

            NextAddress = (WS_ADDRESS *)pAddress->pNextAddress;
            RpcpMemoryCopy(pAddress, pOld, sizeof(WS_ADDRESS));
            pAddress->pNextAddress = NextAddress;

            // find the element we just copied over the first, and free it
            LastSuccessfullyInitializedAddress = pOld;
            pList = pAddress;
            while (pList->pNextAddress != LastSuccessfullyInitializedAddress)
                {
                pList = (WS_ADDRESS *)pList->pNextAddress;
                }

            delete pList->pNextAddress;
            pList->pNextAddress = NULL;

            // add the first element back on the list.
            TransportProtocol::AddObjectToProtocolList(pAddress);
            }
        }

    delete [] ListenAddressList;

    // by now all elements in the list have listened successfully
    // or are in transport PnP state. However
    // if we encountered a fatal error, we need to abort any way
    if (fFatalErrorEncountered)
        {
        WS_ServerAbortListen(pAddress);

        // fatal error - bail out
        return FatalErrorCode;
        }

    // Listened okay

    // Figure out our network addresses
    status = IP_BuildAddressVector(
                                   &pAddress->pAddressVector,
                                   NICFlags,
                                   NetworkAddress,
                                   pAddress);

    if (status != RPC_S_OK)
        {
        WS_ServerAbortListen(pAddress);
        return(status);
        }

    *ppAddressVector = pAddress->pAddressVector;

    // Return the dynamic port, if needed.

    if (!*pEndpoint)
        {
        *pEndpoint = new RPC_CHAR[6]; // 65535 max
        if (!*pEndpoint)
            {
            WS_ServerAbortListen(ThisAddress);
            return(RPC_S_OUT_OF_MEMORY);
            }

        PortNumber = ntohs(PortNumber);

        PortNumberToEndpoint(PortNumber, *pEndpoint);
        }

    // Save away the endpoint in the address, if needed, here.
    // (PnP?)

    return(status);
}




RPC_STATUS
TCP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
{

    return (TCP_ServerListenEx(
                ThisAddress,
                NetworkAddress,
                pEndpoint,
                PendingQueueSize,
                SecurityDescriptor,
                EndpointFlags,
                NICFlags,
                FALSE,          // Not HTTP
                ppAddressVector
                ));
}

RPC_STATUS
WS_ConvertClientAddress (
    IN const SOCKADDR *ClientAddress,
    IN ULONG ClientAddressType,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Converts a given IP address to a RPC network address

Arguments:

    ClientAddress - the client IP address. Can be SOCKADDR_IN6
        for IPv6.

    ClientAddressType - TCP or TCP_IPv6

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    USES_CONVERSION;
    CNlUnicode nlUnicode;
    int Result;
    int SocketLength;
    int HostLength;
    char *HostName;
    char *ScopeIdSeparator;

    ASSERT((ClientAddressType == TCP) || (ClientAddressType == TCP_IPv6));

    if (ClientAddressType == TCP)
        SocketLength = sizeof(SOCKADDR_IN);
    else
        SocketLength = sizeof(SOCKADDR_IN6);

    // allocate space for the numeric name plus the terminating NULL
    HostLength = max(IP_MAXIMUM_RAW_NAME, IPv6_MAXIMUM_RAW_NAME) + 1;
    HostName = (char *)alloca(HostLength);

    Result = getnameinfo(ClientAddress,
        SocketLength,
        HostName,
        HostLength,
        NULL,
        0,
        NI_NUMERICHOST);

    ASSERT(Result == 0);

    ScopeIdSeparator = strchr(HostName, '%');
    if (ScopeIdSeparator)
        {
        // if there is a scope separator, whack everything after
        // the scope separator (i.e. we don't care about the scope).
        *ScopeIdSeparator = 0;
        }

    ATTEMPT_NL_A2W(nlUnicode, HostName);

    *pNetworkAddress = (WCHAR *)nlUnicode;
    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
TCP_QueryClientAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.
    The clients address is saved when the client connects, so all
    we need to do is format the address.

Arguments:

    ThisConnection - The server connection of interest.
    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    return WS_ConvertClientAddress((const SOCKADDR *)&p->saClientAddress.ipaddr,
        p->id,
        pNetworkAddress
        );
}


RPC_STATUS
RPC_ENTRY
TCP_QueryLocalAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

Arguments:

    ThisConnection - The server connection of interest.

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;
    int MinimumBufferLength;
    int Result;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[p->id];

    ASSERT(p->type & SERVER);

    if ((p->id == TCP) || (p->id == HTTP))
        {
        MinimumBufferLength = sizeof(SOCKADDR_IN);
        *AddressFormat = RPC_P_ADDR_FORMAT_TCP_IPV4;
        }
    else
        {
        ASSERT(p->id == TCP_IPv6);
        MinimumBufferLength = sizeof(SOCKADDR_STORAGE);
        *AddressFormat = RPC_P_ADDR_FORMAT_TCP_IPV6;
        }

    if (*BufferSize < MinimumBufferLength)
        {
        *BufferSize = MinimumBufferLength;
        return ERROR_MORE_DATA;
        }

    ASSERT(p->pAddress);

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    Result = setsockopt(p->Conn.Socket,
        SOL_SOCKET,
        SO_UPDATE_ACCEPT_CONTEXT,
        (char *)&p->pAddress->ListenSocket,
        sizeof(p->pAddress->ListenSocket) );

    if (Result != SOCKET_ERROR)
        {
        Result = getsockname(p->Conn.Socket,
            (sockaddr *)Buffer, 
            (int *) BufferSize);

        // SO_UPDATE_ACCEPT_CONTEXT has the nasty habit of deleting
        // all of our socker options. Restore them
        WS_SetSockOptForConnection(pInfo, p->Conn.Socket);

        p->OtherIOFinished();

        if (Result == SOCKET_ERROR)
            {
            RpcpErrorAddRecord(EEInfoGCWinsock,
                RPC_S_OUT_OF_MEMORY,
                EEInfoDLTCP_QueryLocalAddress10,
                (ULONGLONG) p->Conn.Socket,
                GetLastError());
            return RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        p->OtherIOFinished();

        RpcpErrorAddRecord(EEInfoGCWinsock,
            RPC_S_OUT_OF_MEMORY,
            EEInfoDLTCP_QueryLocalAddress20,
            (ULONGLONG) p->Conn.Socket,
            GetLastError());
        return RPC_S_OUT_OF_MEMORY;
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
TCP_QueryClientId(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is suppose to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

Arguments:

    ThisConnection - Server connection in question.
    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OUT

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    ASSERT(p->type & SERVER);

    // Currently, we don't have an efficient way of determining which clients
    // are local, and which remote. Since some clients grant more permissions
    // to local clients, we want to be on the safe side, and return all TCP
    // clients as remote.
    ClientProcess->ZeroOut();
    if (p->id != TCP_IPv6)
        {
        ClientProcess->SetIPv4ClientIdentifier(p->saClientAddress.inetaddr.sin_addr.s_addr,
            FALSE   // fLocal
            );
        }
    else
        {
        ClientProcess->SetIPv6ClientIdentifier(&p->saClientAddress.ipaddr, 
            sizeof(p->saClientAddress.ipaddr),
            FALSE   // fLocal
            );
        }

    return(RPC_S_OK);
}

RPC_STATUS
TCPOrHTTP_Open(
    IN WS_CONNECTION *Connection,
    IN RPC_CHAR * NetworkAddress,
    IN USHORT Endpoint,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN OUT TCPResolverHint *Hint,
    IN BOOL  fHintInitialized,
    IN ULONG CallTimeout,
    IN BOOL fHTTP2Open,
    IN I_RpcProxyIsValidMachineFn IsValidMachineFn OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    NetworkAddress - The name of the server, either a dot address or DNS name
    Endpoint - the port number in host byte order representation
    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.
    ResolverHint - Resolver hint
    fHintInitialized - If TRUE, the ResolveHint contains the IP address
        of the server. If FALSE, do standard name resolution.
    CallTimeout - the call timeout in milliseconds
    fHTTP2Open - non-zero if this is an HTTP2 Open
    IsValidMachineFn - a callback function that is used to validate machine/port
        for access from this process. Used by HTTP only.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS status;
    WS_SOCKADDR sa;
    PVOID rnrContext;
    BOOL fIPv4Hint;
    USES_CONVERSION;
    CStackAnsi AnsiName;
    BOOL NetworkAddressConverted;
    char *DotName;
    char DotNameBuffer[max(IP_MAXIMUM_RAW_NAME, IPv6_MAXIMUM_RAW_NAME) + 1]; 

    ASSERT(NetworkAddress);

    // All this function needs to is initialize transport specific
    // parts of the connection and sockaddr.  This includes resolving
    // the network address into a `raw' address.

    RpcpSetIpPort(&sa, htons(Endpoint));

    if (fHTTP2Open)
        {
        Connection->id = HTTPv2;
        NetworkAddressConverted = FALSE;
        }
    else
        Connection->id = TCP;

    // Two cases, previously saved address or first open

    if (fHintInitialized)
        {
        Hint->GetResolverHint(&fIPv4Hint, &sa);

        if (!fIPv4Hint)
            Connection->id = TCP_IPv6;

        ASSERT(IsValidMachineFn == FALSE);

        status = WS_Open((PWS_CCONNECTION)Connection, 
            &sa, 
            ConnTimeout, 
            SendBufferSize, 
            RecvBufferSize, 
            CallTimeout,
            fHTTP2Open
            );
        if (status == ERROR_RETRY)
            {
            status = RPC_S_SERVER_UNAVAILABLE;
            }

        return(status);
        }

    // Prepare to resolve the network address

    IP_ADDRESS_RESOLVER resolver(NetworkAddress, 
        cosClient,
        ipvtuIPAny       // IP version to use
        );

    // Loop until success, fatal failure or we run out of addresses.

    do
        {
        status = resolver.NextAddress(&sa.ipaddr);

        if (status != RPC_S_OK)
            {
            break;
            }

        if (IsValidMachineFn)
            {
            ASSERT(fHTTP2Open != FALSE);
            if (NetworkAddressConverted == FALSE)
                {
                ATTEMPT_STACK_W2A(AnsiName, NetworkAddress);
                NetworkAddressConverted = TRUE;
                }

            DotName = inet_ntoa(sa.inetaddr.sin_addr);
            strcpy(DotNameBuffer, DotName);

            status = IsValidMachineFn(AnsiName,
                DotNameBuffer,
                Endpoint
                );

            // if the server is not allowed for access, continue with next
            if (status != RPC_S_OK)
                continue;
            }

        if (sa.ipaddr.ss_family == AF_INET6)
            Connection->id = TCP_IPv6;
        else if (Connection->id == TCP_IPv6)
            {
            // if we were at IPv6 and we didn't select IPv6 this time, it must
            // be IPv4
            ASSERT(sa.ipaddr.ss_family == AF_INET);
            Connection->id = TCP;
            }

        // Call common open function
        status = WS_Open((PWS_CCONNECTION)Connection, 
            &sa, 
            ConnTimeout, 
            SendBufferSize, 
            RecvBufferSize, 
            CallTimeout,
            fHTTP2Open
            );
        }
    while (status == ERROR_RETRY);

    if (status == RPC_S_OK)
        {
        Hint->SetResolverHint((Connection->id == TCP) || (Connection->id == HTTPv2), &sa);
        }

    return(status);
}




RPC_STATUS
RPC_ENTRY
TCP_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN OUT PVOID ResolverHint,
    IN BOOL  fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_ip_tcp". Ignored in this function
    NetworkAddress - The name of the server, either a dot address or DNS name
    NetworkOptions - Ignored
    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.
    ResolverHint - IP address of server, if valid.
    fHintInitialized - If TRUE, the ResolveHint contains the IP address
        of the server. If FALSE, do standard name resolution.
    CallTimeout - the call timeout in milliseconds

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given. Not used for TCP.

    AdditionalCredentials - additional credentials that we were given. 
        Not used for TCP.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS status;
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    USHORT port;

    ASSERT(NetworkAddress);

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    // use explicit placement to initialize the vtable. We need this to
    // be able to use the virtual functions
    p = new (p) WS_CLIENT_CONNECTION;

    // All this function needs to is initialize transport specific
    // parts of the connection and sockaddr.  This includes resolving
    // the network address into a `raw' address.

    // Figure out the destination port
    status = EndpointToPortNumber(Endpoint, port);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    return TCPOrHTTP_Open (p,
        NetworkAddress,
        port,
        ConnTimeout,
        SendBufferSize,
        RecvBufferSize,
        (TCPResolverHint *)ResolverHint,
        fHintInitialized,
        CallTimeout,
        FALSE,   // fHTTP2Open
        NULL     // IsValidMachineFn
        );
}

#ifdef SPX_ON
/////////////////////////////////////////////////////////////////////
//
// SPX specific functions
//

RPC_STATUS
SPX_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    This routine allocates a new pipe to receive new client connections.
    If successful a call to COMMON_CompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur. If the runtime
    is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (port) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    EndpointFlags - Meaningless for SPX
    NICFlags - Meaningless for SPX
    SecurityDescriptor - Meaningless for SPX

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    RPC_STATUS status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    INT i;
    USHORT port;

    pAddress->id = SPX;
    pAddress->NewConnection = WS_NewConnection;
    pAddress->SubmitListen = WS_SubmitAccept;
    SetProtocolMultiplier(pAddress, 1);
    pAddress->pAddressVector = 0;
    pAddress->Endpoint = 0;
    pAddress->QueueSize = PendingQueueSize;
    pAddress->EndpointFlags = EndpointFlags;

    sockaddr->generic.sa_family = WsTransportTable[SPX].AddressFamily;

    // Figure out what port to bind to.

    if (*pEndpoint)
        {
        status = EndpointToPortNumber(*pEndpoint, port);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        sockaddr->ipxaddr.sa_socket = htons(port);
        pAddress->fDynamicEndpoint = 0;
        }
    else
        {
        pAddress->fDynamicEndpoint = 1;
        sockaddr->ipxaddr.sa_socket = 0;
        }

    // No need to bind to a specific address for SPX
    memset(sockaddr->ipxaddr.sa_netnum,  0, sizeof(sockaddr->ipxaddr.sa_netnum) );
    memset(sockaddr->ipxaddr.sa_nodenum, 0, sizeof(sockaddr->ipxaddr.sa_nodenum));

    // Actually listen

    status = WS_ServerListenCommon(pAddress);


    if (status == RPC_S_OK)
        {
        // Listened okay, update local IPX address.
        //
        // Since there is only one addess no lock is required.
        //
        memcpy(IpxAddr.sa_netnum, sockaddr->ipxaddr.sa_netnum, 4);
        memcpy(IpxAddr.sa_nodenum, sockaddr->ipxaddr.sa_nodenum, 6);
        fIpxAddrValid = TRUE;

        // Figure out our network addresses
        status = IPX_BuildAddressVector(&pAddress->pAddressVector);

        if (status != RPC_S_OK)
            {
            WS_ServerAbortListen(pAddress);
            return(status);
            }

        *ppAddressVector = pAddress->pAddressVector;

        // Return the dynamic port, if needed.

        if (!*pEndpoint)
            {
            *pEndpoint = new RPC_CHAR[6]; // 65535 max
            if (!*pEndpoint)
                {
                WS_ServerAbortListen(ThisAddress);
                return(RPC_S_OUT_OF_MEMORY);
                }

            port = ntohs(sockaddr->ipxaddr.sa_socket);

            PortNumberToEndpoint(port, *pEndpoint);
            }

        TransportProtocol::FunctionalProtocolDetected(pAddress->id);

        // Save away the endpoint in the address, if needed, here.
        // (PnP?)

        }
    else if (status == RPC_P_ADDRESS_FAMILY_INVALID)
        {
        status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    return(status);
}


RPC_STATUS
RPC_ENTRY
SPX_QueryClientAddress(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR ** pNetworkAddress
    )
/*++

Routine Description:

    Returns the raw IPX of the client to a connection as a string.  The
    clients address is saved when the client connects, so all we need to do is
    format the address.

Arguments:

    ThisConnection - The connection of interest.
    pNetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    WS_CONNECTION *p= (WS_CONNECTION *)ThisConnection;
    ASSERT(p->type & SERVER);

    RPC_CHAR *Address = new RPC_CHAR[IPX_MAXIMUM_RAW_NAME];

    if (!Address)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    IPX_AddressToName(&p->saClientAddress.ipxaddr, Address);

    *pNetworkAddress = Address;

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
SPX_QueryClientId(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which SPX is not) this is suppose to give an ID
    which will be shared by all connections from the same process or security
    identity.  This prevents one user from grabbing another users association
    group and using their context handles.

    Since SPX is not secure we return the IPX node number of the client.
    This limits the attacks to other processes running on the client machine
    which is better than nothing.

Arguments:

    ThisConnection - Server connection in question.
    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OUT

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    ASSERT(p->type & SERVER);

    // The runtime assumes that any connections with a ClientProcess->FirstPart is 
    // zero means the client is local.
    // Currently, we don't have an efficient way of determining which clients
    // are local, and which remote. Since some clients grant more permissions
    // to local clients, we want to be on the safe side, and return all SPX
    // clients as remote.

    ClientProcess->ZeroOut();
    ClientProcess->SetIPXClientIdentifier(p->saClientAddress.ipxaddr.sa_nodenum,
        sizeof(p->saClientAddress.ipxaddr.sa_nodenum), FALSE);

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
SPX_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_spx"
    NetworkAddress - The name of the server, either a raw address or pretty name
    NetworkOptions - Ignored
    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.
    CallTimeout - call timeout in milliseconds

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given. Not used for SPX.

    AdditionalCredentials - additional credentials that we were given. 
        Not used for SPX.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS status;
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    SOCKET sock;
    WS_SOCKADDR sa;
    CHAR AnsiPort[IPX_MAXIMUM_ENDPOINT];
    PCHAR AnsiNetworkAddress;
    BOOL fUseCache = TRUE;
    BOOL fFoundInCache = FALSE;

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    // use explicit placement to initialize the vtable. We need this to
    // be able to use the virtual functions
    p = new (p) WS_CLIENT_CONNECTION;

    // All this function needs to is initialize transport specific
    // parts of the connection and sockaddr.  This includes resolving
    // the network address into a `raw' address.

    p->id = SPX;

    // Figure out the destination port
    USHORT port;
    status = EndpointToPortNumber(Endpoint, port);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    for (;;)
        {
        // Resolve network address

        sa.ipxaddr.sa_family = AF_IPX;
        sa.ipxaddr.sa_socket = 0;

        status = IPX_NameToAddress(NetworkAddress, fUseCache, &sa.ipxaddr);

        if (status == RPC_P_FOUND_IN_CACHE)
            {
            ASSERT(fUseCache);
            fFoundInCache = TRUE;
            status = RPC_S_OK;
            }

        if (status != RPC_S_OK)
            {
            if (status == RPC_P_MATCHED_CACHE)
                {
                status = RPC_S_SERVER_UNAVAILABLE;
                }
            return(status);
            }

        sa.ipxaddr.sa_socket = htons(port);

        // Call common open function

        status = WS_Open(p, 
            &sa, 
            ConnTimeout, 
            SendBufferSize, 
            RecvBufferSize, 
            CallTimeout,
            FALSE       // fHTTP2Open
            );

        if (status == ERROR_RETRY)
            {
            status = RPC_S_SERVER_UNAVAILABLE;
            }

        if (   status == RPC_S_SERVER_UNAVAILABLE
            && fFoundInCache
            && fUseCache )
            {
            fUseCache = FALSE;
            continue;
            }

        break;
        }

    return(status);
}
#endif

#ifdef APPLETALK_ON

/////////////////////////////////////////////////////////////////////
//
// Appletalk data stream protocol (DSP) specific functions
//

RPC_STATUS DSP_GetAppleTalkName(
    OUT CHAR *Buffer
    )
/*++

Routine Description:

    Returns the server's name for appletalk workstations.  This value
    defaults to GetComputerName() but can be changed.  Mail from JameelH:

    By default it is the netbios name of the server. It can be overwritten.
    The new name is at:
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\MacFile\Parameters\ServerName.

    By default this value is not present.

Arguments:

    Buffer - Supplies a buffer (at least 33 bytes) for the name.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_RESOURCES - Unable to get the name for some reasons.
--*/
{
    RPC_STATUS Status;
    HKEY hKey;
    DWORD Size = 33;
    DWORD Type;

    Status =
    RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
                RPC_CONST_SSTRING("System\\CurrentControlSet\\Services\\MacFile\\Parameters"),
        0,
        KEY_READ,
        &hKey);

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (Status == ERROR_SUCCESS)
        {

        Status =
        RegQueryValueExA(
            hKey,
            "ServerName",
            0,
            &Type,
            (PBYTE)Buffer,
            &Size);
        }


    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (Status == ERROR_SUCCESS)
        {
        // Found a name in the registry.

        ASSERT(   Type == REG_SZ
               && Size <= 32
               && strlen(Buffer) == (Size + 1));

        return(RPC_S_OK);
        }

    // Not in the registry, must be using the computer name.

    Size = 33;

    if ( GetComputerNameA(
            Buffer,
            &Size ) == FALSE )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "GetComputerNameA failed! %d\n",
                       GetLastError()));

        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}


const PCHAR DSP_OBJECTTYPE_PREFIX = "DceDspRpc ";

RPC_STATUS
DSP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    This routine allocates a port to receive new client connections.
    If successful a call to COMMON_CompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur. If the runtime
    is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (port) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    EndpointFlags - Meaningless for DSP
    NICFlags - Meaningless for DSP
    SecurityDescriptor - Meaningless for DSP

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    RPC_STATUS status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    USHORT port;
    CHAR AnsiEndpoint[NBP_MAXIMUM_ENDPOINT];

    pAddress->id = DSP;
    pAddress->NewConnection = WS_NewConnection;
    pAddress->SubmitListen = WS_SubmitAccept;
    SetProtocolMultiplier(pAddress, 1);
    pAddress->pAddressVector = 0;
    pAddress->Endpoint = 0;
    pAddress->QueueSize = PendingQueueSize;
    pAddress->EndpointFlags = EndpointFlags;

    //
    // For DSP the endpoint is a character string.  It is not actually used
    // to allocate the socket.  We let DSP allocate a port and then register
    // the port along with our address and endpoint with NBP.
    //

    if (*pEndpoint)
        {
        // Runtime gave us an endpoint, convert it to ansi
        int nLength;
                *AnsiEndpoint = 0;
        nLength = RpcpStringLength(*pEndpoint);
        if ((nLength <= 0) || (nLength > 22))
            {
            return(RPC_S_INVALID_ENDPOINT_FORMAT);
            }
        PlatformToAnsi(*pEndpoint, AnsiEndpoint);
        pAddress->fDynamicEndpoint = 0;
        }
    else
        {
        static LONG EndpointCount = 0;
        //
        // Create a dynamic endpoint using Use process ID + 16-bit counter.
        //
        *pEndpoint = new RPC_CHAR[7 + 8 + 4 + 1 + 1];
        if (!*pEndpoint)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        CHAR buffer[9];

        strcpy(AnsiEndpoint, "DynEpt ");
        _ltoa(GetCurrentProcessId(), buffer, 16);
        lstrcatA(AnsiEndpoint, buffer);
        buffer[0] = '.';
        LONG t = InterlockedIncrement(&EndpointCount);
        _ltoa( t & 0xFFFF, buffer + 1, 16);
        lstrcatA(AnsiEndpoint, buffer);

        SimpleAnsiToPlatform(AnsiEndpoint, *pEndpoint);
        pAddress->fDynamicEndpoint = 1;
        }

    ASSERT(strlen(AnsiEndpoint) > 0 && strlen(AnsiEndpoint) < NBP_MAXIMUM_ENDPOINT);

    memset(&sockaddr->ataddr, 0, sizeof(WS_SOCKADDR));
    sockaddr->generic.sa_family = WsTransportTable[DSP].AddressFamily;

    // For DSP we always bind to a transport choosen port.  The endpoint
    // only exists in the NBP router as a mapping to our address and port.

    // Create listen socket

    status = WS_ServerListenCommon(pAddress);


    if (status != RPC_S_OK)
        {
        if (status == RPC_P_ADDRESS_FAMILY_INVALID)
            status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        return(status);
        }

    // Now, try to register our name and zone.
    //
    // The final format of the name to register is:
    // <ComputerName>@<Zone>@DceDspRpc <Endpoint>
    //
    // The <ComputerName>@<Zone> string is treated as this machines
    // name as far as the runtime cares.  The <Endpoint> is used as
    // the endpoint.
    //

    CHAR ComputerName[NBP_MAXIMUM_NAME];

    status = DSP_GetAppleTalkName(ComputerName);

    if (status != RPC_S_OK)
        {
        WS_ServerAbortListen(ThisAddress);
        return(status);
        }

// The following code segment is commented out to be consistent with
// what we did in NT4. In NT4, we had a bug where if the AppleTalk name
// registered is just the computer name without the zone name appended.
// In NT5, we achieve the same by commenting out this code which appends
// the zone name.
//

/*
    INT cZone;

    PSZ pszT = ComputerName;
    while(*pszT)
        pszT++;
    *pszT++ = '@';
    cZone = 33;

    // So far we have ComputerName@ and a pointer to just after the @.

    if (getsockopt(pAddress->ListenSocket,
                   SOL_APPLETALK,
                   SO_LOOKUP_MYZONE,
                   pszT,
                   &cZone) != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Failed to lookup zone: %d\n",
                       GetLastError()));

        // Don't fail, this could be a small network, just register '*' for
        // the broadcast/local zone.
        *pszT++ = '*';
        *pszT++ = '0';
        }
*/

    //
    // We need to register our computer name and endpoint next.
    //

    WSH_REGISTER_NAME   AtalkNameToRegister;
    int                 length;

    ASSERT(MAX_COMPUTERNAME_LENGTH < MAX_ENTITY + 1);

    length = strlen(AnsiEndpoint);
    memcpy(AtalkNameToRegister.TypeName, DSP_OBJECTTYPE_PREFIX, 10);
    memcpy(AtalkNameToRegister.TypeName + 10, AnsiEndpoint, length);
    AtalkNameToRegister.TypeNameLen = length + 10;

    length = strlen(ComputerName);
    memcpy(AtalkNameToRegister.ObjectName, ComputerName, length);
    AtalkNameToRegister.ObjectNameLen = (char) length;

    AtalkNameToRegister.ZoneName[0] = '*';
    AtalkNameToRegister.ZoneNameLen = 1;

    // Could do a lookup and connect to see if our name is already registered..

    if (setsockopt(
              pAddress->ListenSocket,
              SOL_APPLETALK,
              SO_REGISTER_NAME,
              (char *)&AtalkNameToRegister,
              sizeof(AtalkNameToRegister)
              ) != 0 )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Failed to register name: %d\n",
                       GetLastError()));

        WS_ServerAbortListen(ThisAddress);
        return(RPC_S_CANT_CREATE_ENDPOINT);
        }

    // All done, build out parameters

    ASSERT(length == (int) strlen(ComputerName));

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + (length + 2) * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (NULL == pVector)
        {
        WS_ServerAbortListen(ThisAddress);
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR*)&pVector->NetworkAddresses[1];

        AnsiToPlatform(ComputerName, pVector->NetworkAddresses[0]);

    pAddress->pAddressVector = pVector;
    *ppAddressVector = pVector;

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
DSP_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Not supported on Windows NT.

--*/
{
    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
}
#endif



RPC_STATUS RPC_ENTRY WS_Abort(IN RPC_TRANSPORT_CONNECTION Connection)
{
    return ((WS_CONNECTION *)Connection)->WS_CONNECTION::Abort();
}

/////////////////////////////////////////////////////////////////////
//
// Transport information definitions
//

const RPC_CONNECTION_TRANSPORT
TCP_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    TCP_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_ip_tcp"),
    "135",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    max(sizeof(WS_CLIENT_CONNECTION), sizeof(WS_SAN_CLIENT_CONNECTION)),
    max(sizeof(WS_CONNECTION), sizeof(WS_SAN_CONNECTION)),
    sizeof(CO_SEND_CONTEXT),
    sizeof(TCPResolverHint),
    TCP_MAX_SEND,
    WS_Initialize,
    0,
    TCP_Open,
    0, // No SendRecv on winsock
    WS_SyncRecv,
    WS_Abort,
    WS_Close,
    CO_Send,
    CO_Recv,
    WS_SyncSend,
    WS_TurnOnOffKeepAlives,
    TCP_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    TCP_QueryClientAddress,
    TCP_QueryLocalAddress,
    TCP_QueryClientId,
    0, // Impersonate
    0, // Revert
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };

#ifdef SPX_ON
const RPC_CONNECTION_TRANSPORT
SPX_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    SPX_TOWER_ID,
    IPX_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_spx"),
    "34280",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    max(sizeof(WS_CLIENT_CONNECTION), sizeof(WS_SAN_CLIENT_CONNECTION)),
    max(sizeof(WS_CONNECTION), sizeof(WS_SAN_CONNECTION)),
    sizeof(CO_SEND_CONTEXT),
    0,
    SPX_MAX_SEND,
    WS_Initialize,
    0,
    SPX_Open,
    0, // No SendRecv on winsock
    WS_SyncRecv,
    WS_Abort,
    WS_Close,
    CO_Send,
    CO_Recv,
    WS_SyncSend,
    0,  // turn on/off keep alives
    SPX_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    SPX_QueryClientAddress,
    0, // query local address
    SPX_QueryClientId,
    0, // Impersonate
    0, // Revert
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };
#endif

#ifdef APPLETALK_ON
const RPC_CONNECTION_TRANSPORT
DSP_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    DSP_TOWER_ID,
    NBP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_at_dsp"),
    "Endpoint Mapper",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    sizeof(WS_ADDRESS),
    sizeof(WS_CLIENT_CONNECTION),
    sizeof(WS_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    DSP_MAX_SEND,
    WS_Initialize,
    0,
    DSP_Open,  // Not really supported.
    0, // No SendRecv on winsock
    WS_SyncRecv,
    WS_Abort,
    WS_Close,
    CO_Send,
    CO_Recv,
    WS_SyncSend,
    0,  // turn on/off keep alives
    DSP_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0, // DSP_QueryClientAddress,
    0, // DSP_QueryClientId,
    0, // Impersonate
    0, // Revert
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };
#endif

#define RPC_NIC_INDEXES "System\\CurrentControlSet\\Services\\Rpc\\Linkage"
FIREWALL_INFO *pFirewallTable = 0;
BOOL fFirewallInited = FALSE;
typedef DWORD (*PGETIPADDRTABLE)
    (
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PDWORD           pdwSize,
    IN     BOOL             bOrder
    );


DWORD
NextIndex(
    char **Ptr
    )
{
    char *Index = *Ptr ;
    if (*Index == 0)
        {
        return -1;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    return (DWORD) atoi(Index) ;
}


BOOL
GetCardIndexTable (
    DWORD **IndexTable,
    DWORD *NumIndexes
    )
{
    HKEY hKey;
    int retry;
    DWORD Size ;
    DWORD Type;
    char *Buffer;
    RPC_STATUS Status;
    char *TempBuffer;

    Status =
    RegOpenKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_NIC_INDEXES,
                  0,
                  KEY_READ,
                  &hKey);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        *IndexTable = NULL;
        return TRUE;
        }

    if (Status != ERROR_SUCCESS)
        {
        return FALSE;
        }

    Size = 512 ;
    Buffer = (char *) I_RpcAllocate(Size) ;
    if (Buffer == 0)
        {
        goto Cleanup;
        }

    while(TRUE)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "Bind",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        if (Status == ERROR_SUCCESS)
            {
            break;
            }

        if (Status == ERROR_MORE_DATA)
            {
            I_RpcFree(Buffer) ;
            Buffer = (char *) I_RpcAllocate(Size) ;
            if (Buffer == 0)
                {
                goto Cleanup;
                }
            continue;
            }

        if (Status == ERROR_FILE_NOT_FOUND)
            {
            I_RpcFree(Buffer) ;
            *IndexTable = NULL;
            RegCloseKey(hKey);

            return TRUE;
            }

        goto Cleanup;
        }

    if (*Buffer == 0)
        {
        ASSERT(!"No cards to bind to") ;
        goto Cleanup;
        }

    //
    // we know this much will be enough
    //
    *IndexTable = (DWORD *) I_RpcAllocate(Size * sizeof(DWORD));
    if (*IndexTable == 0)
        {
        goto Cleanup;
        }

    *NumIndexes = 0;
    int Index;
    TempBuffer = Buffer;
    while ((Index = NextIndex(&TempBuffer)) != -1)
        {
        (*IndexTable)[*NumIndexes] = Index;
        (*NumIndexes)++;
        }

    ASSERT(*NumIndexes);

    I_RpcFree(Buffer);
    RegCloseKey(hKey);

    return TRUE;

Cleanup:
    if (Buffer)
        {
        I_RpcFree(Buffer);
        }

    RegCloseKey(hKey);

    return FALSE;
}


BOOL
DoFirewallInit (
    )
{
    unsigned i;
    unsigned j;
    DWORD NumIndexes;
    DWORD *IndexTable;
    PMIB_IPADDRTABLE pMib;
    HMODULE hDll;
    PGETIPADDRTABLE pGetIpAddrTable;
    RPC_STATUS Status;

    if (fFirewallInited)
        {
        return TRUE;
        }

    if (GetCardIndexTable(&IndexTable, &NumIndexes) == FALSE)
        {
        return FALSE;
        }

    if (IndexTable == 0)
        {
        fFirewallInited = TRUE;
        return TRUE;
        }

    hDll = LoadLibrary(RPC_CONST_SSTRING("iphlpapi.dll"));
    if (hDll == 0)
        {
        return FALSE;
        }

    pGetIpAddrTable = (PGETIPADDRTABLE)GetProcAddress(hDll, "GetIpAddrTable");
    if (pGetIpAddrTable == 0)
        {
        FreeLibrary(hDll);
        return FALSE;
        }

    DWORD Size = 20*sizeof(MIB_IPADDRROW)+sizeof(DWORD);

    for (i = 0; i < 2; i++)
        {
        pMib = (PMIB_IPADDRTABLE) I_RpcAllocate(Size);
        if (pMib == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            break;
            }

        Status = pGetIpAddrTable(pMib, &Size, 0);
        if (Status == 0)
            {
            break;
            }
        }

    FreeLibrary(hDll);

    if (Status != 0)
        {
        if (pMib)
            I_RpcFree(pMib);
        return FALSE;
        }

    pFirewallTable = (FIREWALL_INFO *) I_RpcAllocate(
                                                     (pMib->dwNumEntries+1)*sizeof(DWORD));
    if (pFirewallTable == 0)
        {
        I_RpcFree(pMib);
        return FALSE;
        }

    pFirewallTable->NumAddresses = 0;
    for (i = 0; i < NumIndexes; i++)
        {
        for (j = 0; j < pMib->dwNumEntries; j++)
            {
            if ((pMib->table[j].dwIndex & 0x00FFFFFF) == IndexTable[i])
                {
                pFirewallTable->Addresses[
                    pFirewallTable->NumAddresses] = pMib->table[j].dwAddr;
                pFirewallTable->NumAddresses++;
                }
            }
        }

    I_RpcFree(pMib);
    I_RpcFree(IndexTable);

    fFirewallInited = TRUE;
    return TRUE;
}

const RPC_CONNECTION_TRANSPORT *
WS_TransportLoad (
    IN PROTOCOL_ID index
    )
{
    RPC_STATUS status;

    if (fWinsockLoaded == FALSE)
        {
        if (RPC_WSAStartup() == FALSE)
            {
            return 0;
            }
        fWinsockLoaded = TRUE;
        }

    switch(index)
        {
        case TCP:
            AddressChangeFn = I_RpcServerInqAddressChangeFn();

            if (AddressChangeFn)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "TCP address change function has been loaded"));
                }

            if (DoFirewallInit())
                {
                return(&TCP_TransportInterface);
                }
            break;

#ifdef SPX_ON
        case SPX:
            AddressChangeFn = I_RpcServerInqAddressChangeFn();

            if (AddressChangeFn)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "SPX address change function has been loaded"));
                }

            if (InitializeIpxNameCache() != RPC_S_OK)
                {
                return(0);
                }
            return(&SPX_TransportInterface);
#endif

#ifdef APPLETALK_ON
        case DSP:
            return(&DSP_TransportInterface);
#endif

        case HTTP:
            return(&HTTP_TransportInterface);

        default:
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "WS_TransportLoad called with index: %d\n",
                           index));

            ASSERT(0);
        }

    return(0);
}

RPC_STATUS SAN_CONNECTION::SANReceive(HANDLE hFile, LPVOID lpBuffer,
                                  DWORD nNumberOfBytesToRead,
                                  LPDWORD lpNumberOfBytesRead,
                                  LPOVERLAPPED lpOverlapped)
{
    WSABUF wsaBuf;
    int nResult;

    wsaBuf.len = nNumberOfBytesToRead;
    wsaBuf.buf = (char *)lpBuffer;
    m_dwFlags = 0;

    nResult = WSARecv((SOCKET)hFile, &wsaBuf, 1, lpNumberOfBytesRead, &m_dwFlags,
            lpOverlapped, NULL);
    if (nResult == SOCKET_ERROR)
        return WSAGetLastError();
    else
        return RPC_S_OK;
}

RPC_STATUS SAN_CONNECTION::SANSend(HANDLE hFile, LPCVOID lpBuffer,
                               DWORD nNumberOfBytesToWrite,
                               LPDWORD lpNumberOfBytesWritten,
                               LPOVERLAPPED lpOverlapped)
{
    WSABUF wsaBuf;
    int nResult;
    wsaBuf.len = nNumberOfBytesToWrite;
    wsaBuf.buf = (char *)lpBuffer;

    nResult = WSASend((SOCKET)hFile, &wsaBuf, 1, lpNumberOfBytesWritten, 0,
        lpOverlapped, NULL);
    if (nResult == SOCKET_ERROR)
        return WSAGetLastError();
    else
        return RPC_S_OK;
}

RPC_STATUS WS_CONNECTION::Receive(HANDLE hFile, LPVOID lpBuffer,
                                  DWORD nNumberOfBytesToRead,
                                  LPDWORD lpNumberOfBytesRead,
                                  LPOVERLAPPED lpOverlapped)
{
    return UTIL_ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

RPC_STATUS WS_CONNECTION::Send(HANDLE hFile, LPCVOID lpBuffer,
                               DWORD nNumberOfBytesToWrite,
                               LPDWORD lpNumberOfBytesWritten,
                               LPOVERLAPPED lpOverlapped)
{
    return UTIL_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

void
RPC_CLIENT_PROCESS_IDENTIFIER::SetIPv6ClientIdentifier (
    IN void *Buffer,
    IN size_t BufferSize,
    IN BOOL fLocal)
/*++

Routine Description:

    IPv6 servers can use this to store their IP address in
    the client identifier.

Arguments:

    Buffer - the buffer with the client identifier
    BufferSize - the size of the data in buffer
    fLocal - TRUE if the client is guaranteed to be Local. False otherwise.

Return Value:


--*/
{
    SOCKADDR_IN6 *IPv6Address;
    ASSERT(BufferSize >= sizeof(SOCKADDR_IN6));

    this->fLocal = fLocal;
    RpcpMemoryCopy(u.ULongClientId, Buffer, sizeof(SOCKADDR_IN6));
    IPv6Address = (SOCKADDR_IN6 *)u.ULongClientId;
    IPv6Address->sin6_port = 0;
    IPv6Address->sin6_flowinfo = 0;
    IPv6Address->sin6_scope_id = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\httpreg.c ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  httpreg.c
//
//    HTTP/RPC Proxy Registry Functions.
//
//  Author:
//    06-16-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include <mbstring.h>
#include "ecblist.h"
#include "filter.h"
#include "regexp.h"


//-------------------------------------------------------------------------
//  AtoUS()
//
//  Convert a numeric string to an unsigned short. If the conversion
//  fails return FALSE.
//-------------------------------------------------------------------------
static BOOL AtoUS( char *pszValue, unsigned short *pusValue )
{
   int  iValue;
   size_t  iLen = strlen(pszValue);

   *pusValue = 0;

   if ((iLen == 0) || (iLen > 5) || (iLen != strspn(pszValue,"0123456789")))
      {
      return FALSE;
      }

   iValue = atoi(pszValue);

   if ((iValue < 0) || (iValue > 65535))
      {
      return FALSE;
      }

   *pusValue = (unsigned short) iValue;

   return TRUE;
}

//-------------------------------------------------------------------------
//  HttpParseServerPort()
//
//  Parse strings of the form:  <svr>:<port>[-<port>]
//
//  Return TRUE iff we have a valid specification of a server/port range.
//-------------------------------------------------------------------------
static BOOL HttpParseServerPort( IN  char        *pszServerPortRange,
                                 OUT VALID_PORT  *pValidPort )
{
   char *psz;
   char *pszColon;
   char *pszDash;

   if (pszColon=_mbschr(pszServerPortRange,':'))
      {
      if (pszColon == pszServerPortRange)
         {
         return FALSE;
         }

      *pszColon = 0;
      psz = pszColon;
      psz++;
      pValidPort->pszMachine = (char*)MemAllocate(1+lstrlen(pszServerPortRange));
      if (!pValidPort->pszMachine)
         {
         return FALSE;
         }

      lstrcpy(pValidPort->pszMachine,pszServerPortRange);
      *pszColon = ':';
      if (*psz)
         {
         if (pszDash=_mbschr(psz,'-'))
            {
            *pszDash = 0;
            if (!AtoUS(psz,&pValidPort->usPort1))
               {
               pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
               return FALSE;
               }

            *pszDash = '-';
            psz = pszDash;

            if (!AtoUS(++psz,&pValidPort->usPort2))
               {
               pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
               return FALSE;
               }
            }
         else
            {
            if (!AtoUS(psz,&pValidPort->usPort1))
               {
               pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
               return FALSE;
               }

            pValidPort->usPort2 = pValidPort->usPort1;
            }
         }
      else
         {
         pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
         return FALSE;
         }
      }
   else
      {
      return FALSE;
      }

   return TRUE;
}

//-------------------------------------------------------------------------
//  HttpFreeValidPortList()
//
//-------------------------------------------------------------------------
void HttpFreeValidPortList( IN VALID_PORT *pValidPorts )
{
   VALID_PORT *pCurrent = pValidPorts;

   if (pValidPorts)
      {
      while (pCurrent->pszMachine)
         {
         MemFree(pCurrent->pszMachine);

         if (pCurrent->ppszDotMachineList)
            {
            FreeIpAddressList(pCurrent->ppszDotMachineList);
            }

         pCurrent++;
         }

      MemFree(pValidPorts);
      }
}

//-------------------------------------------------------------------------
//  HttpParseValidPortsList()
//
//  Given a semicolon separated list of valid machine name/port ranges
//  string, part it and return an array of ValidPort structures. The last
//  entry has a NULL pszMachine field.
//-------------------------------------------------------------------------
static VALID_PORT *HttpParseValidPortsList( IN char *pszValidPorts )
{
   int    i;
   int    iLen;
   int    count = 1;
   DWORD  dwSize = 1+lstrlen(pszValidPorts);
   char  *pszList;
   char  *psz;
   VALID_PORT *pValidPorts = NULL;

   if (!dwSize)
      {
      return NULL;
      }

   // Make a local copy of the machine/ports list to work with:
   pszList = _alloca(dwSize);

   if (!pszList)
      {
      // Out of memory.
      return NULL;
      }

   lstrcpy(pszList,pszValidPorts);

   // See how many separate machine/port range patterns ther are in
   // the list:
   //
   // NOTE: That count may be too high, if either the list contains
   //       double semicolons or the list ends with a semicolon. If
   //       either/both of these happen that's Ok, our array will be
   //       just a little too long.
   psz = pszList;
   while (psz=_mbsstr(psz,";"))
      {
      count++;
      psz++;
      }

   pValidPorts = (VALID_PORT*)MemAllocate( (1+count)*sizeof(VALID_PORT) );
   if (!pValidPorts)
      {
      // Out of memory.
      return NULL;
      }

   memset(pValidPorts,0,(1+count)*sizeof(VALID_PORT));

   i = 0;
   while (i<count)
      {
      if (!*pszList)
         {
         // End of list. This happens when the list contained empty
         // patterns.
         break;
         }

      psz = _mbsstr(pszList,";");
      if (psz)
         {
         *psz = 0;   // Nul where the semicolon was...

         if ( (iLen=lstrlen(pszList)) == 0)
            {
            // Zero length pattern.
            pszList = ++psz;
            continue;
            }

         if (!HttpParseServerPort(pszList,&(pValidPorts[i++])))
            {
            HttpFreeValidPortList(pValidPorts);
            return NULL;
            }
         }
      else
         {
         // Last one.
         if (!HttpParseServerPort(pszList,&(pValidPorts[i++])))
            {
            HttpFreeValidPortList(pValidPorts);
            return NULL;
            }
         }

      pszList = ++psz;
      }

   return pValidPorts;
}

//-------------------------------------------------------------------------
//  HttpProxyCheckRegistry()
//
//  Check the registry to see if HTTP/RPC is enabled and if so, return a
//  list (array) of machines that the RPC Proxy is allowed to reach (may
//  be NULL. If the proxy is enabled but the list is NULL they you can
//  only do RPC to processes local to the IIS HTTP/RPC Proxy. Otherwise,
//  the returned list specifies specifically what machines may be reached
//  by the proxy.
//
//  The following registry entries are found in:
//
//    \HKEY_LOCAL_MACHINE
//        \Software
//        \Microsoft
//        \Rpc
//        \RpcProxy
//
//  Enabled : REG_DWORD
//
//    TRUE iff the RPC proxy is enabled.
//
//  ValidPorts : REG_SZ
//
//    Semicolon separated list of machine/port ranges used to specify
//    what machine are reachable from the RPC proxy. For example:
//
//    foxtrot:1-4000;Data*:200-4000
//
//    Will allow access to the machine foxtrot (port ranges 1 to 4000) and
//    to all machines whose name begins with Data (port ranges 200-4000).
//
//-------------------------------------------------------------------------
BOOL HttpProxyCheckRegistry( OUT DWORD       *pdwEnabled,
                             OUT VALID_PORT **ppValidPorts )
{
   int    i;
   long   lStatus;
   DWORD  dwType;
   DWORD  dwSize;
   HKEY   hKey;
   char  *pszValidPorts;
   struct hostent UNALIGNED *pHostEnt;
   struct in_addr   ServerInAddr;

   *pdwEnabled = FALSE;
   *ppValidPorts = NULL;

   lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,REG_PROXY_PATH_STR,0,KEY_READ,&hKey);
   if (lStatus != ERROR_SUCCESS)
      {
      return TRUE;
      }

   dwSize = sizeof(*pdwEnabled);
   lStatus = RegQueryValueEx(hKey,REG_PROXY_ENABLE_STR,0,&dwType,(LPBYTE)pdwEnabled,&dwSize);
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return TRUE;
      }

   if (!*pdwEnabled)
      {
      // RPC Proxy is disabled, no need to go on.
      RegCloseKey(hKey);
      return TRUE;
      }

   dwSize = 0;
   lStatus = RegQueryValueEx(hKey,REG_PROXY_VALID_PORTS_STR,0,&dwType,(LPBYTE)NULL,&dwSize);
   if ( (lStatus != ERROR_SUCCESS) || (dwSize == 0) )
      {
      // I don't care if this registry entry is missing, just won't be able to talk to
      // any other machines.
      RegCloseKey(hKey);
      return TRUE;
      }

   // dwSize is now how big the valid ports string is (including the trailing nul.
   pszValidPorts = (char*)_alloca(dwSize);

   lStatus = RegQueryValueEx(hKey,REG_PROXY_VALID_PORTS_STR,0,&dwType,(LPBYTE)pszValidPorts,&dwSize);
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return FALSE;
      }

   RegCloseKey(hKey);

   *ppValidPorts = HttpParseValidPortsList(pszValidPorts);

   return TRUE;
}

//-------------------------------------------------------------------------
//  HttpConvertToDotAddress()
//
//  Convert the specified machine name to IP dot notation if possible.
//-------------------------------------------------------------------------
char *HttpConvertToDotAddress( char *pszMachineName )
{
   struct   hostent UNALIGNED *pHostEnt;
   struct     in_addr  MachineInAddr;
   char      *pszDot = NULL;
   char      *pszDotMachine = NULL;

   pHostEnt = gethostbyname(pszMachineName);
   if (pHostEnt)
      {
      memcpy(&MachineInAddr,pHostEnt->h_addr,pHostEnt->h_length);
      pszDot = inet_ntoa(MachineInAddr);
      }

   if (pszDot)
      {
      pszDotMachine = (char*)MemAllocate(1+lstrlen(pszDot));
      if (pszDotMachine)
         {
         lstrcpy(pszDotMachine,pszDot);
         }
      }

   return pszDotMachine;
}

//-------------------------------------------------------------------------
//  HttpNameToDotAddressList()
//
//  Convert the specified machine name to IP dot notation if possible. 
//  Return a list (null terminated) of the IP dot addresses in ascii.
//
//  If the function fails, then retrun NULL. It can fail if gethostbyname()
//  fails, or memory allocation fails.
//-------------------------------------------------------------------------
char **HttpNameToDotAddressList( IN char *pszMachineName )
{
   int        i;
   int        iCount = 0;
   struct   hostent UNALIGNED *pHostEnt;
   struct     in_addr  MachineInAddr;
   char     **ppszDotList = NULL;
   char      *pszDot = NULL;
   char      *pszDotMachine = NULL;

   pHostEnt = gethostbyname(pszMachineName);
   if (pHostEnt)
      {
      // Count how many addresses we have:
      while (pHostEnt->h_addr_list[iCount])
          {
          iCount++;
          }

      // Make sure we have at lease one address:
      if (iCount > 0)
          {
          ppszDotList = (char**)MemAllocate( sizeof(char*)*(1+iCount) );
          }

      // Build an array of strings, holding the addresses (ascii DOT
      // notation:
      if (ppszDotList)
          {
          for (i=0; i<iCount; i++)
               {
               memcpy(&MachineInAddr,
                      pHostEnt->h_addr_list[i],
                      pHostEnt->h_length);

               pszDot = inet_ntoa(MachineInAddr);

               if (pszDot)
                   {
                   ppszDotList[i] = (char*)MemAllocate(1+lstrlen(pszDot));
                   if (ppszDotList[i])
                       {
                       strcpy(ppszDotList[i],pszDot);
                       }
                   else
                       {
                       // memory allocate failed:
                       break;
                       }
                   }
              }

          ppszDotList[i] = NULL;   // Null terminated list.
          }
      }

   return ppszDotList;
}

//-------------------------------------------------------------------------
//  CheckDotCacheTimestamp()
//
//  Return true if the current time stamp is aged out.
//-------------------------------------------------------------------------
static BOOL CheckDotCacheTimestamp( DWORD  dwCurrentTickCount,
                                    DWORD  dwDotCacheTimestamp )

   {
   if (  (dwCurrentTickCount < dwDotCacheTimestamp)
      || ((dwCurrentTickCount - dwDotCacheTimestamp) > HOST_ADDR_CACHE_LIFE) )
      {
      return TRUE;
      }

   return FALSE;
   }

//-------------------------------------------------------------------------
//  CheckPort()
//
//-------------------------------------------------------------------------
static BOOL CheckPort( SERVER_CONNECTION *pConn,
                       VALID_PORT        *pValidPort )
{
   return ( (pConn->dwPortNumber >= pValidPort->usPort1)
            && (pConn->dwPortNumber <= pValidPort->usPort2) );
}

//-------------------------------------------------------------------------
//  HttpProxyIsValidMachine()
//
//-------------------------------------------------------------------------
BOOL HttpProxyIsValidMachine( SERVER_INFO *pServerInfo,
                     SERVER_CONNECTION *pConn )
{
   int         i;
   char      **ppszDot;
   DWORD       dwTicks;
   DWORD       dwSize;
   DWORD       dwStatus;
   VALID_PORT *pValidPorts;


   // See if the machine is this (local) one, if so, then
   // its access is Ok.
   if (!_mbsicmp(pConn->pszMachine,pServerInfo->pszLocalMachineName))
      {
      return TRUE;
      }

   // Ok convert the local machine name to dot notation and
   // see if we have a match:
   dwTicks = GetTickCount();
   dwStatus = RtlEnterCriticalSection(&pServerInfo->cs);

   // We keep a cache of the IP addresses for the local machine name,
   // that chach ages out every ~5 minutes, to allow for dynamic change
   // of IP addresses. This does the age-out of the IP address list:
   if (  (pServerInfo->ppszLocalDotMachineList)
      && CheckDotCacheTimestamp(dwTicks,pServerInfo->dwDotCacheTimestamp) )
      {
      FreeIpAddressList(pServerInfo->ppszLocalDotMachineList);
      pServerInfo->ppszLocalDotMachineList = NULL;
      }

   // If we don't (or no longer have) a list of the IP addresses for the
   // local machine, then generate it:
   if (!pServerInfo->ppszLocalDotMachineList)
      {
      pServerInfo->dwDotCacheTimestamp = dwTicks;

      pServerInfo->ppszLocalDotMachineList
               = HttpNameToDotAddressList(pServerInfo->pszLocalMachineName);
      }

   // Go through a list of the IP addresses to see if we have a match.
   // Note that the machine may have more than one address associated 
   // with it:
   if (  (pServerInfo->ppszLocalDotMachineList)
      && (pConn->pszDotMachine) )
      {
      ppszDot = pServerInfo->ppszLocalDotMachineList;

      while (*ppszDot)
         {
         if (!_mbsicmp(pConn->pszDotMachine,*ppszDot))
            {
            dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
            return TRUE;
            }
         else
            {
            ppszDot++;
            }
         }
      }

   dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);


   // Check the machine name against those that were allowed
   // in the registry:
   dwStatus = RtlEnterCriticalSection(&pServerInfo->cs);

   pValidPorts = pServerInfo->pValidPorts;

   if (pValidPorts)
      {
      while (pValidPorts->pszMachine)
         {
         // See if we have a name match:
         if ( (MatchREi(pConn->pszMachine,pValidPorts->pszMachine))
              && (CheckPort(pConn,pValidPorts)) )
            {
            dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
            return TRUE;
            }

         // The "valid entry" in the registry might be an address
         // wildcard, check it:
         if (  (pConn->pszDotMachine)
            && (MatchREi(pConn->pszDotMachine,pValidPorts->pszMachine))
            && (CheckPort(pConn,pValidPorts)) )
            {
            dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
            return TRUE;
            }

         // If the address list is aged out then get rid of it.
         if (  (pValidPorts->ppszDotMachineList)
            && CheckDotCacheTimestamp(dwTicks,pServerInfo->dwDotCacheTimestamp))
            {
            FreeIpAddressList(pValidPorts->ppszDotMachineList);
            pValidPorts->ppszDotMachineList = NULL;
            }

         // Make up a new list of addresses for this machine.
         if (!pValidPorts->ppszDotMachineList)
            {
            // Note: that this will only work if the name in the valid 
            // ports list is not a wildcard.
            //
            // Note: pServerInfo->dwCacheTicks will have been updated
            // above...
            //
            pValidPorts->ppszDotMachineList 
                 = HttpNameToDotAddressList(pValidPorts->pszMachine);
            }

         // Try a match using internet dot address:
         if (  (pValidPorts->ppszDotMachineList)
            && (pConn->pszDotMachine)
            && (CheckPort(pConn,pValidPorts)) )
            {
            // Note that the machine may have more than one address
            // associated with it:
            //
            ppszDot = pValidPorts->ppszDotMachineList;

            while (*ppszDot)
               {
               if (!_mbsicmp(pConn->pszDotMachine,*ppszDot))
                   {
                   dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
                   return TRUE;
                   }
               else
                   {
                   ppszDot++;
                   }
               }
            }

         pValidPorts++;
         }
      }

   dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\httpreg.h ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  httpreg.h
//
//    HTTP/RPC protocol specific constants and types.
//
//  Author:
//    04-23-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  Constants:
//---------------------------------------------------------------------------

#define  REG_PROXY_PATH_STR         "Software\\Microsoft\\Rpc\\RpcProxy"
#define  REG_PROXY_ENABLE_STR       "Enabled"
#define  REG_PROXY_VALID_PORTS_STR  "ValidPorts"

//---------------------------------------------------------------------------
//  Types:
//---------------------------------------------------------------------------

typedef struct _ValidPort
{
   char          *pszMachine;
   unsigned short usPort1;
   unsigned short usPort2;
}  ValidPort;


//---------------------------------------------------------------------------
//  Functions:
//---------------------------------------------------------------------------

extern BOOL HttpProxyCheckRegistry( OUT DWORD *pdwEnabled,
                                    OUT ValidPorts **ppValidPorts );

extern void HttpFreeValidPortList( IN ValidPort *pValidPorts );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\common\whttpimp.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    WHttpImp.cxx

Abstract:

    HTTP2 WinHttp import functionality.

Author:

    KamenM      10-30-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <Http2Log.hxx>
#include <WHttpImp.hxx>

RpcWinHttpImportTableType RpcWinHttpImportTable = {NULL};

HMODULE WinHttpLibrary = NULL;

const char *RpcWinHttpImportTableFunctionNames[] = {
    "WinHttpOpen",
    "WinHttpSetStatusCallback",
    "WinHttpSetOption",
    "WinHttpConnect",
    "WinHttpOpenRequest",
    "WinHttpQueryOption",
    "WinHttpSendRequest",
    "WinHttpWriteData",
    "WinHttpReceiveResponse",
    "WinHttpReadData",
    "WinHttpCloseHandle",
    "WinHttpQueryHeaders",
    "WinHttpQueryDataAvailable",
    "WinHttpQueryAuthSchemes",
    "WinHttpSetCredentials",
    "WinHttpAddRequestHeaders"
    };

RPC_STATUS InitRpcWinHttpImportTable (
    void
    )
/*++

Routine Description:

    Initializes the Rpc WinHttp import table. Must
    be called before any WinHttp function.
    The function must be idempotent.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error.

--*/
{
    RPC_STATUS RpcStatus;
    int i;
    int FunctionsCount;
    FARPROC *CurrentFunction;
    HMODULE LocalWinHttpLibrary;

    GlobalMutexRequest();

    if (WinHttpLibrary == NULL)
        {
        WinHttpLibrary = LoadLibrary(L"WinHttp.dll");
        if (WinHttpLibrary == NULL)
            {
            RpcStatus = GetLastError();
            GlobalMutexClear();
            if (RpcStatus == ERROR_FILE_NOT_FOUND)
                RpcStatus = RPC_S_CANNOT_SUPPORT;
            else
                RpcStatus = RPC_S_OUT_OF_MEMORY;

            return RpcStatus;
            }
        }

    FunctionsCount = sizeof(RpcWinHttpImportTableFunctionNames) 
        / sizeof(RpcWinHttpImportTableFunctionNames[0]);

    CurrentFunction = (FARPROC *) &RpcWinHttpImportTable;

    for (i = 0; i < FunctionsCount; i ++)
        {
        *CurrentFunction = GetProcAddress(WinHttpLibrary, 
            RpcWinHttpImportTableFunctionNames[i]
            );

        if (*CurrentFunction == NULL)
            {
            LocalWinHttpLibrary = WinHttpLibrary;
            WinHttpLibrary = NULL;
            GlobalMutexClear();
            FreeLibrary(LocalWinHttpLibrary);
            return RPC_S_CANNOT_SUPPORT;
            }

        CurrentFunction ++;
        }

    GlobalMutexClear();
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\memory.c ===
//-----------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  memory.c
//
//  The RPC Proxy uses its own heap.
//
//
//  History:
//
//    Edward Reus   06-23-97   Initial Version.
//-----------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"

//-----------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------

HANDLE g_hHeap = NULL;

//-----------------------------------------------------------------
//  MemInitialize()
//
//  Creates a heap to be used by MemAllocate() and MemFree().
//
//  Note: You don't need to call this function, it will be called
//  automatically by MemAllocate().
//-----------------------------------------------------------------
BOOL MemInitialize( DWORD *pdwStatus )
{
   SYSTEM_INFO SystemInfo;

   *pdwStatus = 0;

   if (!g_hHeap)
      {
      GetSystemInfo(&SystemInfo);

      g_hHeap = HeapCreate(0L,SystemInfo.dwPageSize,0L);
      if (!g_hHeap)
         {
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("MemInitialize(): HeapCreate() failed: %d\n",*pdwStatus);
         #endif
         return FALSE;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  MemAllocate()
//
//  Allocate a chunk of memory of dwSize bytes.
//-----------------------------------------------------------------
void *MemAllocate( DWORD dwSize )
{
   DWORD  dwStatus;
   void  *pMem;

   if (!g_hHeap)
      {
      if (!MemInitialize(&dwStatus))
         {
         return NULL;
         }
      }

   pMem = HeapAlloc(g_hHeap,0L,dwSize);

   return pMem;
}

//-----------------------------------------------------------------
//  MemFree()
//
//  Free memory allocated by MemAllocate().
//-----------------------------------------------------------------
void *MemFree( void *pMem )
{
   if (g_hHeap)
      {
      #ifdef DBG_ERROR
      if (!HeapFree(g_hHeap,0L,pMem))
         {
         DbgPrint("MemFree(): HeapFree() failed: %d\n",GetLastError());
         }
      #else
      HeapFree(g_hHeap,0L,pMem);
      #endif
      }
   #ifdef DBG_ERROR
   else
      {
      DbgPrint("MemFree(): Called on uninitialized Heap.\n");
      }
   #endif

   return NULL;
}

//-----------------------------------------------------------------
//  MemTerminate()
//
//-----------------------------------------------------------------
void MemTerminage()
{
   if (g_hHeap)
      {
      #ifdef DBG_ERROR
      if (!HeapDestroy(g_hHeap))
         {
         DbgPrint("MemTerminate(): HeapDestroy() failed: %d\n",GetLastError());
         }
      #else
      HeapDestroy(g_hHeap);
      #endif
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\filter.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  filter.h
//
//--------------------------------------------------------------------


// Flag to track counts of open sockets and IIS sessions:
#ifdef DBG
// #define DBG_ERROR
// #define DBG_ECBREF
// #define  DBG_ACCESS
// #define  DBG_COUNTS
// #define  TRACE_MALLOC
#endif

#define  STATUS_CONNECTION_OK           200
#define  STATUS_SERVER_ERROR            500
#define  STATUS_CONNECTION_FAILED       502
#define  STATUS_MUST_BE_POST            503
#define  STATUS_POST_BAD_FORMAT         504

#define  STATUS_CONNECTION_OK_STR       "HTTP/1.0 200 Connection established\n"
#define  STATUS_CONNECTION_FAILED_STR   "HTTP/1.0 502 Connection to RPC server failed\n"
#define  STATUS_MUST_BE_POST_STR        "HTTP/1.0 503 Must use POST\n"
#define  STATUS_POST_BAD_FORMAT_STR     "HTTP/1.0 504 POST bad format\n"

#define  FILTER_DESCRIPTION             "HTTP/RPC Proxy Filter"
#define  EXTENSION_DESCRIPTION          "HTTP/RPC Proxy Extension"

// NOTE: RPC_CONNECT_LEN must be the length of RPC_CONNECT.
#define  RPC_CONNECT                  "RPC_CONNECT"
#define  RPC_CONNECT_LEN                  11

#define  CHAR_SPACE                      ' '
#define  CHAR_TAB                       '\t'
#define  CHAR_COLON                      ':'
#define  CHAR_AMPERSAND                  '&'
#define  CHAR_NL                        '\n'
#define  CHAR_LF                        '\r'
#define  CHAR_0                          '0'
#define  CHAR_9                          '9'
#define  CHAR_A                          'A'
#define  CHAR_F                          'F'

#define  HTTP_SERVER_ID_STR           "ncacn_http/1.0"
#define  HTTP_SERVER_ID_TIMEOUT          30

#define  POST_STR                     "POST"
#define  URL_PREFIX_STR               "/rpc/RpcProxy.dll"
#define  URL_START_PARAMS_STR            "?"
#define  URL_PARAM_SEPARATOR_STR         "&"
// #define  URL_SUFFIX_STR               " HTTP/1.0\r\nUser-Agent: RPC\r\nContent-Length: 0\r\nConnection: Keep-Alive\r\nPragma: No-Cache\r\n\r\n"
// #define  URL_SUFFIX_STR               " HTTP/1.1\r\nAccept: */*\r\nAccept-Language: en-us\r\nUser-Agent: RPC\r\nContent-Length: 0\r\nHost: edwardr2\r\nConnection: Close\r\nPragma: No-Cache\r\n\r\n"
#define  URL_SUFFIX_STR                  " HTTP/1.0\r\nUser-Agent: RPC\r\nContent-Length: 0\r\nConnection: Close\r\nPragma: No-Cache\r\n\r\n"

//
// Some stuff to chunk IIS 6 entity 
//
#define  URL_SUFFIX_STR_60               " HTTP/1.1\r\nUser-Agent: RPC\r\nTransfer-Encoding: chunked\r\nConnection: Close\r\nPragma: No-Cache\r\nHost: "
#define  URL_SUFFIX_STR_60_TERM          "\r\n\r\n"
#define  CHUNK_PREFIX_SIZE               (sizeof( "XXXXXXXX\r\n" ) - 1)
#define  CHUNK_PREFIX                    "%x\r\n"
#define  CHUNK_SUFFIX                    "\r\n"
#define  CHUNK_SUFFIX_SIZE               (sizeof( "\r\n" ) - 1)

#define  WSA_VERSION                  0x0101
#define  DEF_HTTP_PORT                    80

#define  HOST_ADDR_CACHE_LIFE      5*60*1000

#define  TIMEOUT_MSEC                  30000
#define  READ_BUFFER_SIZE               8192
#define  HTTP_PORT_STR_SIZE               20

#define  MAX_URL_BUFFER                  256
#define  MAX_MACHINE_NAME_LEN            255
#define  MAX_HTTP_CLIENTS                256
#define  MAX_FREE_OVERLAPPED              64

#define  REG_PROXY_PATH_STR           "Software\\Microsoft\\Rpc\\RpcProxy"
#define  REG_PROXY_ENABLE_STR         "Enabled"
#define  REG_PROXY_VALID_PORTS_STR    "ValidPorts"

#ifndef  HSE_REQ_ASYNC_READ_CLIENT

    // These are new constructs and types defined by K2. Newer
    // versions of httpext.h will already define these.

    #define  HSE_REQ_ASYNC_READ_CLIENT       (10 + HSE_REQ_END_RESERVED)
    #define  HSE_REQ_ABORTIVE_CLOSE          (14 + HSE_REQ_END_RESERVED)
    #define  HSE_REQ_SEND_RESPONSE_HEADER_EX (16 + HSE_REQ_END_RESERVED)

    typedef struct _HSE_SEND_HEADER_EX_INFO
        {
        //
        // HTTP status code and header
        //
        LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
        LPCSTR  pszHeader;  // HTTP header

        DWORD   cchStatus;  // number of characters in status code
        DWORD   cchHeader;  // number of characters in header

        BOOL    fKeepConn;  // keep client connection alive?
        } HSE_SEND_HEADER_EX_INFO;

#endif

#ifndef HSE_REQ_CLOSE_CONNECTION

    // New SSF() command to close an async connection and cancel
    // any outstanding IOs (reads) on it.

    #define HSE_REQ_CLOSE_CONNECTION         (17 + HSE_REQ_END_RESERVED)

#endif

//--------------------------------------------------------------------
//--------------------------------------------------------------------

#define HEX_DIGIT_VALUE(chex)                                   \
                  (  (((chex) >= CHAR_0) && ((chex) <= CHAR_9)) \
                     ? ((chex) - CHAR_0)                        \
                     : ((chex) - CHAR_A + 10) )

//--------------------------------------------------------------------
//--------------------------------------------------------------------

#ifdef DBG_COUNTS
extern int g_iSocketCount;
extern int g_iSessionCount;
#endif

//--------------------------------------------------------------------
//  Types:
//--------------------------------------------------------------------

typedef struct _VALID_PORT
{
   char          *pszMachine;         // A valid machine to access.
   char         **ppszDotMachineList; // Its name in IP dot notation.
   unsigned short usPort1;
   unsigned short usPort2;
}  VALID_PORT;


typedef struct _SERVER_CONNECTION
{
   int             iRefCount;
   DWORD           dwPortNumber;
   char           *pszMachine;        // RPC server friendly name.
   char           *pszDotMachine;
   DWORD           MachineAddrLen;
   struct in_addr  MachineAddr;
   ULONG_PTR       dwKey;
   struct          sockaddr_in Server;
   SOCKET          Socket;
   DWORD           cbIIS6ChunkBuffer;
   BYTE *          pbIIS6ChunkBuffer;
} SERVER_CONNECTION;


typedef struct _SERVER_OVERLAPPED
{
   DWORD  Internal;
   DWORD  InternalHigh;
   DWORD  Offset;
   DWORD  OffsetHigh;
   HANDLE hEvent;
   struct _SERVER_OVERLAPPED *pNext;
   EXTENSION_CONTROL_BLOCK   *pECB;   // Connection to client.
   SERVER_CONNECTION         *pConn;  // Connection to the RPC server.
   DWORD  dwBytes;                    // #bytes to Read/Write.
   DWORD  dwFlags;                    // Async flags.
   BOOL   fFirstRead;
   BOOL   fIsServerSide;              // TRUE iff server side connection.

   DWORD  dwIndex;                    // Filter/ISAPI transition index.
   LIST_ENTRY     ListEntry;          // Filter/ISAPI transition list.

   unsigned char  arBuffer[READ_BUFFER_SIZE]; // Read/Write Buffer.
} SERVER_OVERLAPPED;


typedef struct _SERVER_INFO
{
   RTL_CRITICAL_SECTION   cs;
   HANDLE                 hIoCP;

   DWORD                  dwEnabled;
   DWORD                  dwDotCacheTimestamp;  // Timestamp, used to 
                                         // age out IP address "dot"
                                         // lists.

   char                  *pszLocalMachineName;
   char                 **ppszLocalDotMachineList;  // IP address list
                                         // for the local machine.
   VALID_PORT            *pValidPorts;

   RTL_CRITICAL_SECTION   csFreeOverlapped;
   DWORD                  dwFreeOverlapped;
   SERVER_OVERLAPPED     *pFreeOverlapped;
   SERVER_OVERLAPPED     *pLastOverlapped;

   ACTIVE_ECB_LIST       *pActiveECBList;

} SERVER_INFO;

//--------------------------------------------------------------------
//  Functions:
//--------------------------------------------------------------------

extern void  FreeServerInfo( SERVER_INFO **ppServerInfo );

extern DWORD WINAPI ServerThreadProc( void *pArg );

extern BOOL  IsDirectAccessAttempt( HTTP_FILTER_CONTEXT  *pFC,
                                    void      *pvNotification );

extern SERVER_CONNECTION *IsNewConnect( HTTP_FILTER_CONTEXT  *pFC,
                                        HTTP_FILTER_RAW_DATA *pRawData,
                                        DWORD                *pdwStatus );

extern BOOL  ChunkEntity( SERVER_CONNECTION    *pConn,
                          HTTP_FILTER_RAW_DATA *pRawData );

extern BOOL  ResolveMachineName( SERVER_CONNECTION *pConn,
                                 DWORD             *pdwStatus );

extern BOOL  ConnectToServer( HTTP_FILTER_CONTEXT *pFC,
                              DWORD               *pdwStatus);

extern BOOL  ConvertVerbToPost( HTTP_FILTER_CONTEXT  *pFC,
                                HTTP_FILTER_RAW_DATA *pRawData,
                                SERVER_OVERLAPPED    *pOverlapped );

extern BOOL  SetupIoCompletionPort( HTTP_FILTER_CONTEXT *pFC,
                                    SERVER_INFO         *pServerInfo,
                                    DWORD               *pdwStatus );

extern DWORD SendToServer( SERVER_CONNECTION *pConn,
                           char              *pBuffer,
                           DWORD              dwBytes );

extern DWORD HttpReplyToClient( HTTP_FILTER_CONTEXT  *pFC,
                                char       *pszHttpStatus );

extern SERVER_OVERLAPPED *AllocOverlapped();

extern SERVER_OVERLAPPED *FreeOverlapped( SERVER_OVERLAPPED *pOverlapped );

extern SERVER_CONNECTION *AllocConnection();

extern void               AddRefConnection( SERVER_CONNECTION *pConn );

extern void               CloseServerConnection( SERVER_CONNECTION *pConn );

extern SERVER_CONNECTION *FreeServerConnection( SERVER_CONNECTION *pConn );

extern void               ShutdownConnection( SERVER_CONNECTION *pConn,
                                              int    how );

extern void               CloseClientConnection(
                                         EXTENSION_CONTROL_BLOCK *pECB );

extern DWORD EndOfSession( SERVER_INFO         *pServerInfo,
                           HTTP_FILTER_CONTEXT *pFC );



extern BOOL  SkipWhiteSpace( char **ppszData,
                             DWORD *pdwStatus );

extern BOOL  ParseMachineNameAndPort( char              **ppszData,
                                      SERVER_CONNECTION  *pConn,
                                      DWORD              *pdwStatus );

extern char *AnsiToPortNumber( char  *pszPort,
                               DWORD *pdwPort  );

extern unsigned char *AnsiHexToDWORD( unsigned char *pszNum,
                                      DWORD         *pdwNum,
                                      DWORD         *pdwStatus );

extern char *HttpConvertToDotAddress( char *pszMachine );

extern BOOL HttpProxyCheckRegistry( DWORD       *pdwEnabled,
                                    VALID_PORT **ppValidPorts );

extern BOOL HttpProxyIsValidMachine( SERVER_INFO       *pServerInfo,
                                     SERVER_CONNECTION *pConn );

extern void FreeIpAddressList( char **ppszDotMachineList );

extern void HttpFreeValidPortList( VALID_PORT *pValidPorts );

extern BOOL  MemInitialize( DWORD *pdwStatus );

extern void *MemAllocate( DWORD dwSize );

extern void *MemFree( VOID *pMem );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\filter.c ===
//-----------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  filter.c
//
//  IIS Filter is the front end of the RpcProxy for HTTP over RPC.
//
//
//  History:
//
//    Edward Reus   00-00-97   Initial Version.
//-----------------------------------------------------------------

#define  FD_SETSIZE   1

#include <sysinc.h>
#include <mbstring.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"
#include "olist.h"

//-----------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------

#ifdef DBG_COUNTS
int g_iSocketCount = 0;
int g_iSessionCount = 0;
#endif

SERVER_INFO *g_pServerInfo = NULL;

BOOL g_fIsIIS6 = TRUE;

#define      MAX_NUM_LEN       20

//-----------------------------------------------------------------
// GetFilterVersion()
//
//-----------------------------------------------------------------
BOOL WINAPI GetFilterVersion( HTTP_FILTER_VERSION *pVer )
{
   WSADATA  wsaData;
   DWORD    dwStatus;
   DWORD    dwSize;

   // Fillout filter information:
   pVer->dwServerFilterVersion = HTTP_FILTER_REVISION;
   pVer->dwFilterVersion = HTTP_FILTER_REVISION;

   lstrcpy(pVer->lpszFilterDesc,FILTER_DESCRIPTION);

   pVer->dwFlags = SF_NOTIFY_ORDER_LOW
                 | SF_NOTIFY_READ_RAW_DATA
                 | SF_NOTIFY_END_OF_NET_SESSION
                 | SF_NOTIFY_PREPROC_HEADERS;


   // Initialize Winsock:
   if (WSAStartup(WSA_VERSION,&wsaData) == SOCKET_ERROR)
      {
      #ifdef DBG_ERROR
      DbgPrint("GetFilterVersion(): WSAStartup() failed: Error: %d\n",WSAGetLastError());
      #endif
      return FALSE;
      }

   //
   // Initialize a save list of SERVER_OVERLAPPED structures
   // that is used to pass connection data between the filter
   // and ISAPI:
   //
   if (!InitializeOverlappedList())
      {
      // If this guy failed, then a critical section failed to
      // initialize, should be very very rare...
      return FALSE;
      }

   //
   // Create the server info data structure and create events
   // used to register and unregister the socket events:
   //
   g_pServerInfo = (SERVER_INFO*)MemAllocate(sizeof(SERVER_INFO));
   if (!g_pServerInfo)
      {
      // Out of memeory...
      return FALSE;
      }

   memset(g_pServerInfo,0,sizeof(SERVER_INFO));

   g_pServerInfo->pszLocalMachineName = (char*)MemAllocate(1+MAX_COMPUTERNAME_LENGTH);
   if (!g_pServerInfo->pszLocalMachineName)
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   dwSize = 1+MAX_COMPUTERNAME_LENGTH;
   if (  (!GetComputerName(g_pServerInfo->pszLocalMachineName,&dwSize))
      || (!HttpProxyCheckRegistry(&g_pServerInfo->dwEnabled,&g_pServerInfo->pValidPorts))
      || (dwStatus = RtlInitializeCriticalSection(&g_pServerInfo->cs))
      || (dwStatus = RtlInitializeCriticalSection(&g_pServerInfo->csFreeOverlapped))
      || (!(g_pServerInfo->hIoCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0))) )
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   //
   // Initialize a list of the active and inactive ECBs
   //
   g_pServerInfo->pActiveECBList = InitializeECBList();
   if (!g_pServerInfo->pActiveECBList)
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   return TRUE;
}


//-----------------------------------------------------------------
// HttpFilterProc()
//
//-----------------------------------------------------------------
DWORD WINAPI HttpFilterProc( HTTP_FILTER_CONTEXT *pFC,
                             DWORD  dwNotificationType,
                             VOID  *pvNotification     )
{
   DWORD  dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
   DWORD  dwStatus = 0;
   DWORD  dwSize;
   unsigned char      szPort[HTTP_PORT_STR_SIZE];
   SERVER_CONNECTION *pConn;
   SERVER_OVERLAPPED *pOverlapped;

   switch (dwNotificationType)
      {
      case SF_NOTIFY_READ_RAW_DATA:
         if (pFC->pFilterContext)
            {
            // Existing connection if we have already set up the filter context.
            pConn = pFC->pFilterContext;
            #if FALSE
            if (pConn->Socket == INVALID_SOCKET)
               {
               dwFilterStatus = SF_STATUS_REQ_FINISHED;
               }
            else
               {
               dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
               }
            #else

            if ( g_fIsIIS6 )
            {
               //
               // We'll need to chunk the entity ourselves
               //

               if ( !ChunkEntity(pConn,(HTTP_FILTER_RAW_DATA*)pvNotification))
               {
                  dwFilterStatus = SF_STATUS_REQ_FINISHED;
               }
               else
               {
                  dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
               }
            }
            else
            {
               dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
            #endif
            }
         else if ( (g_pServerInfo->dwEnabled)
                   && (pConn=IsNewConnect(pFC,(HTTP_FILTER_RAW_DATA*)pvNotification,&dwStatus)) )
            {
            // Establish a new connection between client and server.

            // For overlapped server reads:
            pOverlapped = AllocOverlapped();
            if (!pOverlapped)
               {
               #ifdef DBG_ERROR
               DbgPrint("HttpFilterProc(): AllocOverlapped() failed: %d\n",dwStatus);
               #endif
               // dwStatus = HttpReplyToClient(pFC,STATUS_CONNECTION_FAILED_STR);
               SetLastError(STATUS_CONNECTION_FAILED);
               dwFilterStatus = SF_STATUS_REQ_FINISHED;
               break;
               }

            // AddRef the SERVER_CONNECTION pConn since it is in
            // several data structures.
            pOverlapped->pConn = pConn;
            pOverlapped->fIsServerSide = TRUE;
            AddRefConnection(pConn);

            // Do machine name resolution:
            if (  (!ResolveMachineName(pConn,&dwStatus))
               || (!HttpProxyIsValidMachine(g_pServerInfo,pConn))
               || (!ConnectToServer(pFC,&dwStatus))
               || (!ConvertVerbToPost(pFC,(HTTP_FILTER_RAW_DATA*)pvNotification,pOverlapped))
               || (!SetupIoCompletionPort(pFC,g_pServerInfo,&dwStatus)) )
               {
               // dwStatus = HttpReplyToClient(pFC,STATUS_CONNECTION_FAILED_STR);
               FreeOverlapped(pOverlapped);
               FreeServerConnection(pConn);
               pFC->pFilterContext = NULL;

               // Was SF_STATUS_REQ_FINISHED... Now use SF_STATU_REQ_ERROR to have IIS return
               // the error status...
               SetLastError(STATUS_CONNECTION_FAILED);
               dwFilterStatus = SF_STATUS_REQ_ERROR;
               break;
               }

            // Reply Ok to client:
            // dwStatus = HttpReplyToClient(pFC,STATUS_CONNECTION_OK_STR);

            #ifdef DBG_ERROR
            if (dwStatus)
               {
               DbgPrint("HttpFilterProc(): ReplyToClient() failed: %d\n",dwStatus);
               }
            #endif
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         else
            {
            // Data isn't for me, pass it on:
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         break;

      case SF_NOTIFY_END_OF_NET_SESSION:
         if (pFC->pFilterContext)
            {
            // Connection with client was closed, so close
            // the connection with the server:
            dwStatus = EndOfSession(g_pServerInfo,pFC);

            dwFilterStatus = SF_STATUS_REQ_FINISHED;
            }
         else
            {
            // Not our problem, so do nothing...
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         break;

      case SF_NOTIFY_PREPROC_HEADERS:
         // We don't want anyone to directly access the RPC ISAPI, so
         // we'll look for a direct access attempt here:
         if (IsDirectAccessAttempt(pFC,pvNotification))
            {
            dwFilterStatus = SF_STATUS_REQ_FINISHED;
            }
         else
            {
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         break;

      default:
         #ifdef DBG_ERROR
            DbgPrint("HttpFilterProc(): Unexpected notification: %d\n",
                     dwNotificationType );
         #endif
         dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
         break;
      }

   return dwFilterStatus;
}

//-----------------------------------------------------------------------------
//  FreeIpAddressList()
//
//-----------------------------------------------------------------------------
void FreeIpAddressList( char **ppszDotMachineList )
    {
    char **ppsz = ppszDotMachineList;

    if (ppsz)
       {
       while (*ppsz)
          {
          MemFree(*ppsz);
          ppsz++;
          }

       MemFree(ppszDotMachineList);
       }
    }

//-----------------------------------------------------------------------------
//  FreeServerInfo()
//
//-----------------------------------------------------------------------------
void FreeServerInfo( SERVER_INFO **ppServerInfo )
   {
   char       **ppszDot;
   DWORD        dwStatus;
   SERVER_INFO *pServerInfo = *ppServerInfo;

   if (pServerInfo)
      {
      // The name of this machine (local name):
      if (pServerInfo->pszLocalMachineName)
         {
         MemFree(pServerInfo->pszLocalMachineName);
         }

      // The list of addresses associated with this machine:
      if (pServerInfo->ppszLocalDotMachineList)
         {
         FreeIpAddressList(pServerInfo->ppszLocalDotMachineList);
         }

      // The list if the valid ports (read from the registry):
      if (pServerInfo->pValidPorts)
         {
         HttpFreeValidPortList(pServerInfo->pValidPorts);
         }

      dwStatus = RtlDeleteCriticalSection(&g_pServerInfo->cs);

      dwStatus = RtlDeleteCriticalSection(&g_pServerInfo->csFreeOverlapped);

      if (pServerInfo->hIoCP)
         {
         CloseHandle(pServerInfo->hIoCP);
         }

      MemFree(pServerInfo);
      }

   *ppServerInfo = NULL;
   }

//-----------------------------------------------------------------------------
//  DwToHexAnsi()
//
//  Convert a DWORD number to an ANSI HEX string.
//-----------------------------------------------------------------------------
DWORD DwToHexAnsi( IN     DWORD dwVal, 
                   IN OUT char *pszNumBuff,
                   IN     DWORD dwLen        )
{
   NTSTATUS NtStatus = RtlIntegerToChar(dwVal,16,dwLen,pszNumBuff);

   if (!NT_SUCCESS(NtStatus))
       {
       pszNumBuff[0] = '0';
       pszNumBuff[1] = 0;
       dwLen = 1;
       }
   else
       {
       dwLen = strlen(pszNumBuff);
       }

   return dwLen;
}

//-----------------------------------------------------------------------------
//  AnsiHexToDWORD()
//
//  Convert the string HEX number in pszNum into a DWORD and return it in
//  *pdwNum. If the conversion fails, then return NULL, else advance the
//  string pointer past the number and return it (pszNum).
//-----------------------------------------------------------------------------
unsigned char *AnsiHexToDWORD( unsigned char *pszNum,
                               DWORD         *pdwNum,
                               DWORD         *pdwStatus )
{
   DWORD dwNum = 0;
   DWORD dwDigitCount = 0;
   NTSTATUS NtStatus;

   *pdwNum = *pdwStatus = 0;

   // Skip over any leading spaces:
   while (*pszNum == CHAR_SPACE)
      {
      pszNum++;
      }

   NtStatus = RtlCharToInteger( pszNum, 16, &dwNum );

   if (!NT_SUCCESS(NtStatus))
       {
       *pdwStatus = ERROR_INVALID_DATA;
       return NULL;
       }

   *pdwNum = dwNum;

   return pszNum;
}

//-----------------------------------------------------------------
//  AllocOverlapped()
//
//-----------------------------------------------------------------
SERVER_OVERLAPPED *AllocOverlapped()
{
   DWORD  dwStatus;
   SERVER_OVERLAPPED *pOverlapped;

   dwStatus = RtlEnterCriticalSection(&g_pServerInfo->csFreeOverlapped);
   if (dwStatus)
      {
      #ifdef DBG_ERROR
      DbgPrint("AllocOverlapped(): RtlEnterCriticalSection() failed: %d\n",
               dwStatus);
      #endif
      return NULL;
      }

   if (g_pServerInfo->pFreeOverlapped)
      {
      pOverlapped = g_pServerInfo->pFreeOverlapped;

      g_pServerInfo->pFreeOverlapped = pOverlapped->pNext;

      if (!g_pServerInfo->pFreeOverlapped)
         {
         g_pServerInfo->pLastOverlapped = NULL;
         ASSERT(g_pServerInfo->dwFreeOverlapped == 1); // Hasn't been decremented yet...
         }

      g_pServerInfo->dwFreeOverlapped--;

      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);

      pOverlapped->Internal = 0;
      pOverlapped->InternalHigh = 0;
      pOverlapped->Offset = 0;
      pOverlapped->OffsetHigh = 0;
      pOverlapped->hEvent = 0;
      pOverlapped->pNext = NULL;
      pOverlapped->pECB = NULL;
      pOverlapped->pConn = NULL;
      }
   else
      {
      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);

      pOverlapped = (SERVER_OVERLAPPED*)MemAllocate(sizeof(SERVER_OVERLAPPED));
      if (pOverlapped)
         {
         memset(pOverlapped,0,sizeof(SERVER_OVERLAPPED));
         }
      else
         {
         // Memory allocation failed:
         #ifdef DBG_ERROR
         DbgPrint("AllocOverlapped(): Allocation of SERVER_OVERLAPPED failed.\n");
         #endif
         }
      }

   #ifdef TRACE_MALLOC
   DbgPrint("AllocOverlapped(): pOverlapped: 0x%x\n",pOverlapped);
   #endif

   return pOverlapped;
}

//-----------------------------------------------------------------
//  FreeOverlapped()
//
//-----------------------------------------------------------------
SERVER_OVERLAPPED *FreeOverlapped( SERVER_OVERLAPPED *pOverlapped )
{
   int                      iRet;
   DWORD                    dwStatus;
   EXTENSION_CONTROL_BLOCK *pECB;
   SERVER_CONNECTION       *pConn = pOverlapped->pConn;
   SOCKET                   Socket;


   #ifdef TRACE_MALLOC
   DbgPrint("FreeOverlapped(): pOverlapped: 0x%x pConn: 0x%x\n",
            pOverlapped, pConn );
   #endif

   if (pConn)
      {
      pOverlapped->pConn = NULL;
      FreeServerConnection(pConn);
      }

   if (pECB=pOverlapped->pECB)
      {
      pOverlapped->pECB = NULL;
      CloseClientConnection( pECB );
      }


   dwStatus = RtlEnterCriticalSection(&g_pServerInfo->csFreeOverlapped);
   ASSERT(dwStatus == 0);

   if (g_pServerInfo->dwFreeOverlapped < MAX_FREE_OVERLAPPED)
      {
      if (!g_pServerInfo->pFreeOverlapped)
         {
         g_pServerInfo->pFreeOverlapped = pOverlapped;
         g_pServerInfo->pLastOverlapped = pOverlapped;
         }
      else
         {
         pOverlapped->pNext = NULL;
         g_pServerInfo->pLastOverlapped->pNext = pOverlapped;
         g_pServerInfo->pLastOverlapped = pOverlapped;
         }

      g_pServerInfo->dwFreeOverlapped++;
      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);
      }
   else
      {
      // Already have a cache of available SERVER_OVERLAPPED, so we
      // can get rid of this one.

      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);

      MemFree(pOverlapped);
      }

   return NULL;
}

//-----------------------------------------------------------------
//  SetupIoCompletionPort()
//
//  Associate the new socket with our IO completion port so that
//  we can post asynchronous reads to it. Return TRUE on success,
//  FALSE on failure.
//-----------------------------------------------------------------
BOOL SetupIoCompletionPort( HTTP_FILTER_CONTEXT *pFC,
                            SERVER_INFO         *pServerInfo,
                            DWORD               *pdwStatus )
{
   DWORD              dwStatus;
   HANDLE             hIoCP;
   SERVER_CONNECTION *pConn = (SERVER_CONNECTION*)(pFC->pFilterContext);

   if (pConn)
      {
      dwStatus = RtlEnterCriticalSection(&pServerInfo->cs);

      pConn->dwKey = pConn->Socket;

      hIoCP = CreateIoCompletionPort( (HANDLE)pConn->Socket,
                                      pServerInfo->hIoCP,
                                      pConn->dwKey,
                                      0 );
      if (!hIoCP)
         {
         dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
         // Very, very bad!
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("SetupIoCompletionPort(): CreateIoCompletionPort() failed %d\n",*pdwStatus);
         #endif
         return FALSE;
         }

      pServerInfo->hIoCP = hIoCP;
      dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
      }
   else
      {
      #ifdef DBG_ERROR
      DbgPrint("SetupIoCompletionPort(): Bad State: pConn is NULL.\n");
      #endif
      return FALSE;
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  ConvertVerbToPost()
//
//  Our incomming request was an RPC_CONNECT, we need to rewrite
//  the input buffer to an appropriate POST request to be captured
//  by the RpcIsapi extension.
//-----------------------------------------------------------------
BOOL ConvertVerbToPost( HTTP_FILTER_CONTEXT  *pFC,
                        HTTP_FILTER_RAW_DATA *pRawData,
                        SERVER_OVERLAPPED    *pOverlapped  )
{
   int    len;
   char   szBuffer[256];
   char   szNumBuffer[MAX_NUM_LEN];
   DWORD  dwIndex;
   char   szChunkedRequest[512];
   char   szIpAddress[ 64 ];
   DWORD  cbIpAddress;
   BOOL   fRet;

   if ( g_fIsIIS6 )
   {
      lstrcpy(szBuffer,RPC_CONNECT);
   }
   else
   {
      lstrcpy(szBuffer,POST_STR);
   }
   lstrcat(szBuffer," ");
   lstrcat(szBuffer,URL_PREFIX_STR);
   lstrcat(szBuffer,URL_START_PARAMS_STR);

   dwIndex = SaveOverlapped(pOverlapped);

   DwToHexAnsi( dwIndex, szNumBuffer, MAX_NUM_LEN );
   lstrcat(szBuffer,szNumBuffer);

   if ( g_fIsIIS6 )
   {
      //
      // Make the request chunked for IIS 6.0 since HTTP.SYS doesn't support
      // reads on a 0 byte POST
      //

      lstrcat(szBuffer, URL_SUFFIX_STR_60);

      cbIpAddress = sizeof( szIpAddress );

      fRet = pFC->GetServerVariable( pFC,
                                     "LOCAL_ADDR",
                                     szIpAddress,
                                     &cbIpAddress );
      if ( !fRet )
      {
         return FALSE;
      }

      lstrcat(szBuffer, szIpAddress);
      lstrcat(szBuffer, URL_SUFFIX_STR_60_TERM);
   }
   else
   {
      lstrcat(szBuffer,URL_SUFFIX_STR);
   }

   len = lstrlen(szBuffer);
   if ( (DWORD)len > pRawData->cbInBuffer)
      {
      #ifdef DBG_ERROR
      DbgPrint("ConvertVerbToPost(): Error: Buffer too small (%d < %d)\n",len,pRawData->cbInBuffer);
      #endif
      return FALSE;
      }
   else
      {
      lstrcpy(pRawData->pvInData,szBuffer);
      pRawData->cbInData = len;
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  GetIndex()
//
//-----------------------------------------------------------------
BOOL GetIndex( unsigned char *pszUrl,
               DWORD         *pdwIndex )
    {
    DWORD    dwStatus;
    unsigned char *psz;

    *pdwIndex = 0;

    if (psz=_mbsstr(pszUrl,URL_START_PARAMS_STR))
        {
        if (!*psz)
            {
            return FALSE;    // Unexpected end of string...
            }

        psz = _mbsinc(psz);
        if (*psz)
            {
            psz = AnsiHexToDWORD(psz,pdwIndex,&dwStatus);
            if (psz)
                {
                return TRUE;
                }
            }
        }

    return FALSE;
    }

//-----------------------------------------------------------------
//  IsDirectAccessAttempt()
//
//  We don't want anybody on the outside to directly access the
//  RpcProxy ISAPI. Is is only called directly by the RPC Proxy
//  filter. So, we need to look for URLs of the form:   
//
//          /rpc/rpcproxy.dll ...
//
//  If a match is found, return TRUE, else return FALSE.
//
//-----------------------------------------------------------------
BOOL IsDirectAccessAttempt( HTTP_FILTER_CONTEXT *pFC,
                            void     *pvNotification )
{
   BOOL   fIsDirect = FALSE;
   DWORD  dwSize;
   DWORD  dwIndex;
   unsigned char  Buffer[MAX_URL_BUFFER];
   HTTP_FILTER_PREPROC_HEADERS *pPreprocHeaders;

   pPreprocHeaders = (HTTP_FILTER_PREPROC_HEADERS*)pvNotification;

   ASSERT(pPreprocHeaders);

   dwSize = MAX_URL_BUFFER;
   if (pPreprocHeaders->GetHeader(pFC,"url",Buffer,&dwSize))
       {
       #ifdef DBG_ACCESS
       DbgPrint("RpcProxy Filter: Url: %s\n",Buffer);
       #endif
       if (!_mbsnbicmp(Buffer,URL_PREFIX_STR,sizeof(URL_PREFIX_STR)-1))
           {
           if (GetIndex(Buffer,&dwIndex) && IsValidOverlappedIndex(dwIndex))
               {
               fIsDirect = FALSE;
               }
           else
               {
               fIsDirect = TRUE;
               }
           }
       }

   #ifdef DBG_ACCESS
   dwSize = MAX_URL_BUFFER;
   if (pPreprocHeaders->GetHeader(pFC,"method",Buffer,&dwSize))
       {
       DbgPrint("RpcProxy Filter: Method: %s\n",Buffer);
       }

   dwSize = MAX_URL_BUFFER;
   if (pPreprocHeaders->GetHeader(pFC,"version",Buffer,&dwSize))
       {
       DbgPrint("RpcProxy Filter: Version: %s\n",Buffer);
       }

   if (fIsDirect)
       {
       DbgPrint("RpcProxy Filter: Direct access attempt.\n");
       }
   #endif

   return fIsDirect;
}

//-----------------------------------------------------------------
//  IsNewConnect()
//
//  See if this is an RPC_CONNECT verb. If so, then establish
//  the connection with the server. The structure of the connect
//  is:
//
//  RPC_CONNECT <Host>:<Port> HTTP/1.0
//
//  Return TRUE iff this is an RPC_CONNECT, else return FALSE.
//
//-----------------------------------------------------------------
SERVER_CONNECTION *IsNewConnect( HTTP_FILTER_CONTEXT  *pFC,
                                 HTTP_FILTER_RAW_DATA *pRawData,
                                 DWORD                *pdwStatus )
{
   int    i;
   char  *pszData = (char*)(pRawData->pvInData);
   char  *pszRpcConnect = RPC_CONNECT;
   SERVER_CONNECTION *pConn;

   *pdwStatus = 0;

   // First see if the verb is for us:
   if (pRawData->cbInData < RPC_CONNECT_LEN)
      {
      return NULL;
      }

   for (i=0; i<RPC_CONNECT_LEN; i++)
      {
      if ( *(pszData++) != *(pszRpcConnect++) )
         {
         return NULL;
         }
      }

   // We have a connect request:
   pConn = AllocConnection();
   if (!pConn)
      {
      return NULL;
      }

   // Skip over any white space to the machine name:
   if (!SkipWhiteSpace(&pszData,pdwStatus))
      {
      FreeServerConnection(pConn);
      return NULL;
      }

   // Extract out the machine name:
   // Note: Command should end with "HTTP/1.0\n":
   if (!ParseMachineNameAndPort(&pszData,pConn,pdwStatus))
      {
      FreeServerConnection(pConn);
      return NULL;
      }


   pFC->pFilterContext = (void*)pConn;

   return pConn;
}

//-----------------------------------------------------------------
//  ChunkEntity()
//
//  For IIS 6.0, chunk encode the entity to ensure that HTTP.SYS allows
//  the ISAPI extension part of this application to work
//
//  Returns FALSE if we cannot do the chunking
//
//-----------------------------------------------------------------
BOOL ChunkEntity( SERVER_CONNECTION * pConn,
                  HTTP_FILTER_RAW_DATA *pRawData )
{
   DWORD            cbRequired;
   CHAR             achChunkPrefix[ CHUNK_PREFIX_SIZE + 1 ];
   DWORD            cchChunkPrefix;
   
   ASSERT( pConn != NULL );
   ASSERT( pRawData != NULL );

   //
   // We should only do the chunk hack for IIS 6
   //
   
   ASSERT( g_fIsIIS6 );

   //
   // Calculate how much buffer we need to add chunk prefix
   //

   wsprintf( achChunkPrefix,
             CHUNK_PREFIX,
             pRawData->cbInData );

   cchChunkPrefix = strlen( achChunkPrefix );

   cbRequired = pRawData->cbInData + cchChunkPrefix + CHUNK_SUFFIX_SIZE;

   //
   // If the buffer provided by IIS is large enough, then we don't need
   // to allocate our own
   //

   if ( cbRequired <= pRawData->cbInBuffer )
   {
      //
      // Shift the buffer over
      //

      memmove( (PBYTE) pRawData->pvInData + cchChunkPrefix,
               pRawData->pvInData,
               pRawData->cbInData );

      //
      // Prepend chunked prefix
      //
      
      memcpy( (PBYTE) pRawData->pvInData,
              achChunkPrefix,
              cchChunkPrefix );

      //
      // Append chunked suffix
      //

      memcpy( (PBYTE) pRawData->pvInData + cchChunkPrefix + pRawData->cbInData,
              CHUNK_SUFFIX,
              CHUNK_SUFFIX_SIZE );

      //
      // Update length
      //

      pRawData->cbInData = cbRequired;
   }
   else
   {
      //
      // We will have to allocate a new buffer
      //

      if ( pConn->cbIIS6ChunkBuffer < cbRequired )
      {
         //
         // We already have a buffer big enough
         //

         if ( pConn->pbIIS6ChunkBuffer != NULL )
         {
            MemFree( pConn->pbIIS6ChunkBuffer );
            pConn->pbIIS6ChunkBuffer = NULL;
         }

         pConn->pbIIS6ChunkBuffer = MemAllocate( cbRequired );
         if ( pConn->pbIIS6ChunkBuffer == NULL )
         {
            return FALSE;
         }

         pConn->cbIIS6ChunkBuffer = cbRequired;
      }
      
      //
      // Now copy stuff to new buffer
      //

      memcpy( pConn->pbIIS6ChunkBuffer,
              achChunkPrefix,
              cchChunkPrefix );

      memcpy( pConn->pbIIS6ChunkBuffer + cchChunkPrefix,
              pRawData->pvInData,
              pRawData->cbInData );

      memcpy( pConn->pbIIS6ChunkBuffer + cchChunkPrefix + pRawData->cbInData,
              CHUNK_SUFFIX,
              CHUNK_SUFFIX_SIZE );

      //
      // Update raw data structure to point to our buffer
      //

      pRawData->pvInData = pConn->pbIIS6ChunkBuffer;
      pRawData->cbInData = cbRequired;
      pRawData->cbInBuffer = cbRequired;
   }

   return TRUE;
}

//-----------------------------------------------------------------
//  SkipWhiteSpace()
//
//-----------------------------------------------------------------
BOOL SkipWhiteSpace( char **ppszData,
                     DWORD *pdwStatus )
{
   char  *psz = *ppszData;

   *pdwStatus = 0;

   while ( (*psz == CHAR_SPACE) || (*psz == CHAR_TAB) )
      {
      psz++;
      }

   *ppszData = psz;

   return TRUE;
}

//-----------------------------------------------------------------
//  ParseMachineNameAndPort()
//
//  The machine name and port should look like:  <machine>:<port>
//-----------------------------------------------------------------
BOOL ParseMachineNameAndPort( char              **ppszData,
                              SERVER_CONNECTION  *pConn,
                              DWORD              *pdwStatus )
{
   int    len = 0;
   char  *psz = *ppszData;
   char  *pszMachine;

   *pdwStatus = RPC_S_OK;

   // Get the machine name length:
   while ( (*psz != CHAR_COLON) && (*psz != CHAR_NL) && (*psz != CHAR_LF) )
      {
      len++; psz++;
      }

   if (*psz != CHAR_COLON)
      {
      *pdwStatus = RPC_S_INVALID_ENDPOINT_FORMAT;
      return FALSE;
      }

   if (len > MAX_MACHINE_NAME_LEN)
      {
      *pdwStatus = RPC_S_STRING_TOO_LONG;
      return FALSE;
      }

   // Make a buffer to hold the machine name:
   pConn->pszMachine = pszMachine = (char*)MemAllocate(1+len);
   if (!pConn->pszMachine)
      {
      *pdwStatus = RPC_S_OUT_OF_MEMORY;
      return FALSE;
      }

   // Copy over the machine name:
   psz = *ppszData;
   while (*psz != CHAR_COLON)
      {
      *(pszMachine++) = *(psz++);
      // pszMachine++;
      // psz++;
      }

   *pszMachine = 0;

   // Ok get the port number:
   psz++;
   psz = AnsiToPortNumber(psz,&pConn->dwPortNumber);
   if (!psz)
      {
      pConn->pszMachine = MemFree(pConn->pszMachine);
      *pdwStatus = RPC_S_INVALID_ENDPOINT_FORMAT;
      return FALSE;
      }

   *ppszData = psz;
   return TRUE;
}

//-----------------------------------------------------------------
//  AnsiToPortNumber()
//
//-----------------------------------------------------------------
char *AnsiToPortNumber( char  *pszPort,
                        DWORD *pdwPort  )
{
   *pdwPort = 0;

   while ( (*pszPort >= CHAR_0) && (*pszPort <= CHAR_9) )
      {
      *pdwPort = 10*(*pdwPort) + (*(pszPort++) - CHAR_0);

      // I want to limit the port number to 65535:
      if (*pdwPort > 65535)
         {
         *pdwPort = 0;
         return NULL;
         }
      }

   return pszPort;
}

//-----------------------------------------------------------------
//  ResolveMachineName()
//
//  Resolve the machine name, address and port number. The machine
//  name may come in as either a friendly name or as an IP address.
//-----------------------------------------------------------------
BOOL ResolveMachineName( SERVER_CONNECTION *pConn,
                         DWORD             *pdwStatus )
{
   unsigned long     ulHostAddr;
   struct   hostent *pHostEnt;
   char             *pszDot;
   struct   in_addr  MachineInAddr;

   *pdwStatus = 0;
   memset( &(pConn->Server), 0, sizeof(pConn->Server) );

   // Resolve the machine name, which may be either an address in IP dot
   // notation or a host name string:
   if (!pConn->pszMachine)
      {
      // local machine:
      ulHostAddr = INADDR_LOOPBACK;
      pHostEnt = gethostbyaddr( (char*)&ulHostAddr, sizeof(struct in_addr), AF_INET);
      if (pHostEnt)
         {
         pConn->pszMachine = (char*)MemAllocate(1+lstrlen(pHostEnt->h_name));
         if (!pConn->pszMachine)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): Out of memory.\n");
            #endif
            return FALSE;
            }

         lstrcpy(pConn->pszMachine,pHostEnt->h_name);
         }

      memcpy(&MachineInAddr,&ulHostAddr,sizeof(struct in_addr));
      pszDot = inet_ntoa(MachineInAddr);
      if (pszDot)
         {
         pConn->pszDotMachine = (char*)MemAllocate(1+lstrlen(pszDot));
         if (!pConn->pszDotMachine)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): Out of memory.\n");
            #endif
            return FALSE;
            }

         lstrcpy(pConn->pszDotMachine,pszDot);
         }

      ulHostAddr = htonl(INADDR_LOOPBACK);
      memcpy( &(pConn->Server.sin_addr), (unsigned char *)&ulHostAddr, sizeof(ulHostAddr) );
      pConn->Server.sin_family = AF_INET;
      }
   else
      {
      // First, assume an address in numeric dot notation (xxx.xxx.xxx.xxx):
      ulHostAddr = inet_addr(pConn->pszMachine);
      if (ulHostAddr == INADDR_NONE)
         {
         // Not a numeric address, try a network name:
         pHostEnt = gethostbyname(pConn->pszMachine);
         if (!pHostEnt)
            {
            *pdwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): gethostbyname() failed: %d\n",
                     *pdwStatus);
            #endif
            return FALSE;
            }

         memcpy(&MachineInAddr,pHostEnt->h_addr,pHostEnt->h_length);
         pszDot = inet_ntoa(MachineInAddr);
         if (pszDot)
            {
            pConn->pszDotMachine = (char*)MemAllocate(1+lstrlen(pszDot));
            if (!pConn->pszDotMachine)
               {
               *pdwStatus = RPC_S_OUT_OF_MEMORY;
               #ifdef DBG_ERROR
               DbgPrint("ResolveMachineName(): Out of memory.\n");
               #endif
               return FALSE;
               }

            lstrcpy(pConn->pszDotMachine,pszDot);
            }
         }
      else
         {
         // Ok, machine name was an IP address.
         pHostEnt = gethostbyaddr( (char*)&ulHostAddr, sizeof(ulHostAddr), AF_INET );
         if (!pHostEnt)
            {
            *pdwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): gethostbyaddr() failed: %d\n",*pdwStatus);
            #endif
            return FALSE;
            }

         pConn->pszDotMachine = pConn->pszMachine;
         pConn->pszMachine = (char*)MemAllocate(1+lstrlen(pHostEnt->h_name));
         if (!pConn->pszMachine)
            {
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): Out of memory.\n");
            #endif
            return FALSE;
            }

         lstrcpy(pConn->pszMachine,pHostEnt->h_name);
         }
      memcpy( &(pConn->Server.sin_addr), pHostEnt->h_addr, pHostEnt->h_length );
      pConn->Server.sin_family = pHostEnt->h_addrtype;
      }

   //
   // Now, do the port number (Note: htons() doesn't fail):
   //
   pConn->Server.sin_port = htons( (unsigned short)(pConn->dwPortNumber) );

   return TRUE;
}

//-----------------------------------------------------------------
//  CheckRpcServer()
//
//  When we've just connected to an HTTP/RPC server, it must send
//  us and ID string, so that we know that the socket is in fact
//  an RPC server listening on ncacn_http. If we get correct string
//  then return TRUE.
//
//  If we don't get the correct response back in HTTP_SERVER_TIMEOUT
//  seconds then fail (return FALSE).
//-----------------------------------------------------------------
BOOL CheckRpcServer( SERVER_CONNECTION *pConn,
                     DWORD             *pdwStatus )
{
   int    iBytes;
   int    iRet;
   int    iBytesLeft = sizeof(HTTP_SERVER_ID_STR) - 1;
   char   Buff[sizeof(HTTP_SERVER_ID_STR)];
   char  *pBuff;
   fd_set rfds;
   struct timeval Timeout;

   FD_ZERO(&rfds);
   FD_SET(pConn->Socket,&rfds);

   *pdwStatus = 0;
   pBuff = Buff;
   Timeout.tv_sec = HTTP_SERVER_ID_TIMEOUT;
   Timeout.tv_usec = 0;

   while (TRUE)
      {
      iRet = select(0,&rfds,NULL,NULL,&Timeout);

      if (iRet == 0)
         {
         // Timeout
         return FALSE;
         }
      else if (iRet == SOCKET_ERROR)
         {
         // Socket (select) error
         *pdwStatus = WSAGetLastError();
         return FALSE;
         }

      iBytes = recv( pConn->Socket, pBuff, iBytesLeft, 0 );

      if (iBytes == 0)
         {
         // Socket was closed by the server
         }
      else if (iBytes == SOCKET_ERROR)
         {
         *pdwStatus = WSAGetLastError();
         return FALSE;
         }

      pBuff += iBytes;
      iBytesLeft -= iBytes;

      if (iBytesLeft == 0)
         {
         *pBuff = 0;
         break;
         }

      ASSERT(iBytes > 0);

      }

   // Got an ID string, check to make sure its correct:
   if (lstrcmpi(Buff,HTTP_SERVER_ID_STR))
      {
      return FALSE;
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  ConnectToServer()
//
//-----------------------------------------------------------------
BOOL ConnectToServer( HTTP_FILTER_CONTEXT *pFC,
                      DWORD               *pdwStatus )
{
   int                iRet;
   int                iCount;
   int                iSocketStatus;
   int                iSocketType = SOCK_STREAM;
   int                iNagleOff = TRUE;
   int                iKeepAliveOn = TRUE;
   struct hostent    *pHostEnt;
   SERVER_CONNECTION *pConn = (SERVER_CONNECTION*)(pFC->pFilterContext);
   unsigned short     usHttpPort = DEF_HTTP_PORT;
   SOCKET             Socket;

   *pdwStatus = 0;

   //
   // Create the socket:
   //
   #ifdef DBG_ERROR
   if (pConn->Socket != INVALID_SOCKET)
      {
      DbgPrint("ConnectToServer(): socket() on existing socket.\n");
      }
   #endif

   pConn->Socket = socket(AF_INET,iSocketType,0);
   if (pConn->Socket == INVALID_SOCKET)
      {
      *pdwStatus = WSAGetLastError();
      #ifdef DBG_ERROR
      DbgPrint("ConnectToServer(): socket() failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   #ifdef DBG_COUNTS
   iCount = InterlockedIncrement(&g_iSocketCount);
   DbgPrint("socket(%d): Count: %d -> %d\n",pConn->Socket,iCount-1,iCount);
   #endif

   //
   // Connect to the RPC server:
   //
   iSocketStatus = connect( pConn->Socket,
                            (struct sockaddr*)&(pConn->Server),
                            sizeof(pConn->Server) );
   if (iSocketStatus == SOCKET_ERROR)
      {
      *pdwStatus = WSAGetLastError();
      iRet = closesocket(pConn->Socket);
      pConn->Socket = INVALID_SOCKET;
      return FALSE;
      }

   //
   // Turn off Nagle Algorithm, turn keep-alive on:
   //
   setsockopt(pConn->Socket,IPPROTO_TCP,TCP_NODELAY,(char*)&iNagleOff,sizeof(iNagleOff));

   setsockopt(pConn->Socket,IPPROTO_TCP,SO_KEEPALIVE,(char*)&iKeepAliveOn,sizeof(iKeepAliveOn));

   //
   // Make sure the socket that we've connected to is for HTTP/RPC. If so,
   // then it will return an Ident string as soon as it does the accept().
   //
   if (  (!CheckRpcServer(pConn,pdwStatus))
      && ( (Socket=pConn->Socket) != INVALID_SOCKET) )
      {
      iRet = closesocket(pConn->Socket);
      pConn->Socket = INVALID_SOCKET;
      #ifdef DBG_COUNTS
      if (iRet == SOCKET_ERROR)
         {
         DbgPrint("[2] closesocket(%d) failed: %d\n",Socket,WSAGetLastError());
         }
      else
         {
         int iCount = InterlockedDecrement(&g_iSocketCount);
         DbgPrint("[2] closesocket(%d): Count: %d -> %d\n",Socket,1+iCount,iCount);
         }
      #endif
      return FALSE;
      }

   return TRUE;
}


//-----------------------------------------------------------------
//  AllocConnection()
//
//-----------------------------------------------------------------
SERVER_CONNECTION *AllocConnection()
{
   SERVER_CONNECTION  *pConn;

   pConn = (SERVER_CONNECTION*)MemAllocate(sizeof(SERVER_CONNECTION));
   if (!pConn)
      {
      #ifdef DBG_ERROR
      DbgPrint("AllocConnection(): Allocate failed.\n");
      #endif
      return NULL;
      }

   memset(pConn,0,sizeof(SERVER_CONNECTION));
   pConn->iRefCount = 1;
   pConn->Socket = INVALID_SOCKET;

   #ifdef TRACE_MALLOC
   DbgPrint("AllocConnection(): pConn: 0x%x Socket: %d\n",pConn,pConn->Socket);
   #endif

   return pConn;
}

//-----------------------------------------------------------------
//  AddRefConnection()
//
//-----------------------------------------------------------------
void AddRefConnection( SERVER_CONNECTION *pConn )
{
   ASSERT(pConn);
   ASSERT(pConn->iRefCount > 0);

   InterlockedIncrement(&pConn->iRefCount);

   #ifdef TRACE_MALLOC
   DbgPrint("AddRefConnection(): pConn: 0x%x Socket: %d iRefCount: %d\n",
            pConn, pConn->Socket, pConn->iRefCount);
   #endif
}

//-----------------------------------------------------------------
//  ShutdownConnection()
//
//-----------------------------------------------------------------
void ShutdownConnection( SERVER_CONNECTION *pConn,
                         int                how    )
{
   SOCKET  Socket;
   int     iRet;

   if (pConn)
      {
      Socket = pConn->Socket;
      if (Socket != INVALID_SOCKET)
         {
         iRet = shutdown(Socket,how);

         #ifdef DBG_ERROR
         if (iRet == SOCKET_ERROR)
            {
            DbgPrint("shutdown(%d) failed: %d\n",
                     Socket, WSAGetLastError() );
            }
         #endif
         }
      }
}

//-----------------------------------------------------------------
//  CloseServerConnection()
//
//-----------------------------------------------------------------
void CloseServerConnection( SERVER_CONNECTION *pConn )
{
   SOCKET  Socket;
   int     iRet;

   if (pConn)
      {
      Socket = (UINT_PTR)InterlockedExchangePointer((PVOID *)&pConn->Socket,(PVOID)INVALID_SOCKET);
      if (Socket != INVALID_SOCKET)
         {
         iRet = closesocket(Socket);

         #ifdef DBG_ERROR
         if (iRet == SOCKET_ERROR)
            {
            DbgPrint("closesocket(%d) failed: %d\n",
                     Socket, WSAGetLastError() );
            }
         #ifdef DBG_COUNTS
         else
            {
            int iCount = InterlockedDecrement(&g_iSocketCount);
            DbgPrint("closesocket(%d): Count: %d -> %d\n",
                     Socket, 1+iCount, iCount );
            }
         #endif
         #endif
         }
      }
}

//-----------------------------------------------------------------
//  FreeServerConnection()
//
//  SERVER_CONNECTIONs are reference counted so, that there may
//  be several references to one. FreeServerConnection() will continue
//  to return a pointer to the connection as long as the reference
//  count is >0. When  the reference count drops to zero, the
//  connection is actually free'd, and FreeServerConnection() will then
//  return NULL.
//-----------------------------------------------------------------
SERVER_CONNECTION *FreeServerConnection( SERVER_CONNECTION *pConn )
{
   SOCKET  Socket;
   int     iRet;
   int     iRefCount = InterlockedDecrement(&pConn->iRefCount);

   ASSERT(iRefCount >= 0);

   #ifdef TRACE_MALLOC
   DbgPrint("FreeServerConnection(): pConn: 0x%x Socket: %d iRefCount: %d\n",
            pConn, pConn->Socket, pConn->iRefCount);
   #endif

   if (iRefCount > 0)
      {
      // Still one or more outstanding references to this SERVER_CONNECTION.
      ShutdownConnection(pConn,SD_RECEIVE);
      return pConn;
      }

   if (pConn)
      {
      CloseServerConnection(pConn);

      if (pConn->pszMachine)
          {
          pConn->pszMachine = MemFree(pConn->pszMachine);
          }

      if (pConn->pszDotMachine)
          {
          pConn->pszDotMachine = MemFree(pConn->pszDotMachine);
          }

      MemFree(pConn);
      }
   else
      {
      #ifdef DBG_ERROR
      DbgPrint("FreeServerConnection(): called with NULL pointer (filter.c).\n");
      #endif
      }

   return NULL;
}

//-----------------------------------------------------------------
//  SendToServer()
//
//-----------------------------------------------------------------
DWORD SendToServer( SERVER_CONNECTION  *pConn,
                    char               *pBuffer,
                    DWORD               dwBytes )
{
   int    iRet;
   char  *pCurrent = pBuffer;
   DWORD  dwStatus = ERROR_SUCCESS;
   DWORD  dwBytesToSend = dwBytes;
   DWORD  dwBytesWritten = 0;
   SERVER_OVERLAPPED *pOverlapped;
   fd_set wfds;
   struct timeval Timeout;

   #ifdef DBG_ERROR
   if (pConn->Socket == INVALID_SOCKET)
      {
      DbgPrint("SendToServer(%d): Invalid Socket.\n",pConn->Socket);
      }
   #endif

   FD_ZERO(&wfds);
   FD_SET(pConn->Socket,&wfds);

   Timeout.tv_sec = HTTP_SERVER_ID_TIMEOUT;
   Timeout.tv_usec = 0;

   while (dwBytes > dwBytesWritten)
       {
       iRet = select(0,NULL,&wfds,NULL,&Timeout);
       if (iRet == 0)
           {
           // Timeout...
           continue;
           }
       else if (iRet == SOCKET_ERROR)
           {
           dwStatus = WSAGetLastError();
           #ifdef DBG_ERROR
           DbgPrint("SendToServer(%d): Failed: %d\n",pConn->Socket,dwStatus);
           #endif
           break;
           }

       iRet = send(pConn->Socket,pBuffer,dwBytesToSend,0);
       if (iRet == SOCKET_ERROR)
           {
           dwStatus = WSAGetLastError();
           #ifdef DBG_ERROR
           DbgPrint("SendToServer(%d): Failed: %d\n",pConn->Socket,dwStatus);
           #endif
           break;
           }

       dwBytesWritten += iRet;
       pCurrent += iRet;
       }

   return dwStatus;
}

//-----------------------------------------------------------------
//  HttpReplyToClient()
//
//-----------------------------------------------------------------
DWORD HttpReplyToClient( HTTP_FILTER_CONTEXT  *pFC,
                         char                 *pszConnectionStatus )
{
   DWORD  dwStatus = 0;
   DWORD  dwReserved = 0;
   DWORD  len = lstrlen(pszConnectionStatus);


   if (!pFC->WriteClient(pFC,pszConnectionStatus,&len,dwReserved) )
      {
      dwStatus = GetLastError();
      #ifdef DBG_ERROR
      DbgPrint("HttpReplyToClient(): WriteClient() failed: %d\n",dwStatus);
      #endif
      }

   return dwStatus;
}

//-----------------------------------------------------------------
//  CloseClientConnection()
//
//  Tells the IIS to close the client connection. Any pending
//  asynchronous IOs (reads) will be terminated with the error
//  ERROR_NETNAME_DELETED (64).
//
//-----------------------------------------------------------------
void CloseClientConnection( EXTENSION_CONTROL_BLOCK *pECB )
   {
   if (pECB)
      {
      // pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;

      if (!pECB->ServerSupportFunction( pECB->ConnID,
                                        HSE_REQ_CLOSE_CONNECTION,
                                        NULL, NULL, NULL))
         {
         #ifdef DBG_ERROR
         DbgPrint("CloseClientConnection(): HSE_REQ_CLOSE_CONNECTION failed: %d\n", GetLastError());
         #endif
         }

      #ifdef DBG_ERROR
      DbgPrint("CloseClientConnection(): HSE_REQ_CLOSE_CONNECTION\n");
      #endif
      }
   }

//-----------------------------------------------------------------
//  EndOfSession()
//
//  Sends a message to the server forwarding thread to tell it to
//  close down the connection to the RPC server represented by
//  pConn.
//
//-----------------------------------------------------------------
DWORD EndOfSession( SERVER_INFO         *pServerInfo,
                    HTTP_FILTER_CONTEXT *pFC          )
{
   int    iRet;
   DWORD  dwStatus = 0;
   SOCKET Socket;
   SERVER_CONNECTION *pConn = (SERVER_CONNECTION*)(pFC->pFilterContext);

   // Socket = pConn->Socket;

   #ifdef DBG_ERROR
   DbgPrint("EndOfSession(): Socket: %d\n",pConn->Socket);
   #endif

   // CloseServerConnection(pConn);

   FreeServerConnection(pConn);

   return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\olist.c ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  olist.c
//
//    Maintain list of SERVER_OVERLAPPED structures, used in passing 
//    the overlapped structure pointers between the RpcProxy filter
//    and its ISAPI. This happens on initial connection.
//
//  Author:
//    05-04-98  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#define  FD_SETSIZE   1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <sysinc.h>
#include <mbstring.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"
#include "olist.h"


static RTL_CRITICAL_SECTION  g_cs;
static LIST_ENTRY            g_OverlappedList;
static DWORD                 g_dwIndex;

//-------------------------------------------------------------------------
//  InitializeOverlappedList()
//
//-------------------------------------------------------------------------
BOOL InitializeOverlappedList()
    {
    DWORD  dwStatus;

    dwStatus = RtlInitializeCriticalSection(&g_cs);
    if (dwStatus != 0)
        {
        return FALSE;
        }

    InitializeListHead(&g_OverlappedList);

    g_dwIndex = 1;

    return TRUE;
    }

//-------------------------------------------------------------------------
//  SaveOverlapped()
//
//-------------------------------------------------------------------------
DWORD SaveOverlapped( SERVER_OVERLAPPED *pOverlapped )
    {
    DWORD  dwStatus;
    DWORD  dwIndex;

    dwStatus = RtlEnterCriticalSection(&g_cs);

    InsertTailList(&g_OverlappedList,&(pOverlapped->ListEntry));

    dwIndex = g_dwIndex++;
    pOverlapped->dwIndex = dwIndex;

    // Reset the index allocation so we'll never run out of 
    // index values...
    if (g_dwIndex >= 0x7fffffff)
        {
        // 0x7fffffff is a LOT of connections...
        g_dwIndex = 1;
        }

    dwStatus = RtlLeaveCriticalSection(&g_cs);

    return dwIndex;
    }

//-------------------------------------------------------------------------
// GetOverlapped()
//
//-------------------------------------------------------------------------
SERVER_OVERLAPPED *GetOverlapped( DWORD dwIndex )
    {
    DWORD              dwStatus;
    LIST_ENTRY        *pEntry;
    SERVER_OVERLAPPED *pOverlapped = NULL;

    dwStatus = RtlEnterCriticalSection(&g_cs);

    pEntry = g_OverlappedList.Flink;

    while (pEntry != &g_OverlappedList)
        {
        pOverlapped = CONTAINING_RECORD(pEntry,
                                        SERVER_OVERLAPPED,
                                        ListEntry );
        if (pOverlapped->dwIndex == dwIndex)
            {
            RemoveEntryList(pEntry);
            dwStatus = RtlLeaveCriticalSection(&g_cs);
            return pOverlapped;
            }

        pEntry = pEntry->Flink;
        }

    dwStatus = RtlLeaveCriticalSection(&g_cs);

    return NULL;
    }

//-------------------------------------------------------------------------
//  IsValidOverlappedIndex()
//
//  Return TRUE iff the specified index refers to a valid 
//  SERVER_OVERLAPPED in the list.
//-------------------------------------------------------------------------
BOOL IsValidOverlappedIndex( DWORD dwIndex )
    {
    DWORD              dwStatus;
    LIST_ENTRY        *pEntry;
    SERVER_OVERLAPPED *pOverlapped = NULL;

    dwStatus = RtlEnterCriticalSection(&g_cs);

    pEntry = g_OverlappedList.Flink;

    while (pEntry != &g_OverlappedList)
        {
        pOverlapped = CONTAINING_RECORD(pEntry,
                                        SERVER_OVERLAPPED,
                                        ListEntry );
        if (pOverlapped->dwIndex == dwIndex)
            {
            dwStatus = RtlLeaveCriticalSection(&g_cs);
            return TRUE;
            }

        pEntry = pEntry->Flink;
        }

    dwStatus = RtlLeaveCriticalSection(&g_cs);

    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\olist.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  olist.h
//
//    Maintain list of SERVER_OVERLAPPED structures, used in passing
//    the overlapped structure pointers between the RpcProxy filter
//    and its ISAPI. This happens on initial connection.
//
//  Author:
//    05-04-98  Edward Reus    Initial version.
//
//--------------------------------------------------------------------


#ifndef OLIST_H
#define OLIST_H

extern BOOL InitializeOverlappedList();

extern DWORD SaveOverlapped( SERVER_OVERLAPPED *pOverlapped );

extern BOOL  IsValidOverlappedIndex( DWORD dwIndex );

extern SERVER_OVERLAPPED *GetOverlapped( DWORD dwIndex );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\regexp.h ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  regexp.h
//
//    Simple, fast regular expression matching.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#ifndef REG_EXP_H
#define REG_EXP_H

extern BOOL MatchREi( unsigned char *pszString,
                      unsigned char *pszPattern );


#if FALSE
... not currently used ...
extern BOOL MatchRE( unsigned char *pszString,
                     unsigned char *pszPattern );

extern BOOL MatchREList( unsigned char  *pszString,
                         unsigned char **ppszREList  );

extern BOOL MatchExactList( unsigned char  *pszString,
                            unsigned char **ppszREList );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\regexp.c ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  regexp.c
//
//    Simple regular expression matching.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#include <sysinc.h>
#include <mbstring.h>
#include "regexp.h"

//-------------------------------------------------------------------------
//  MatchREi()
//
//  Match the test string (pszString) against the specifed pattern. If they
//  match return TRUE, else return FALSE. This version works with ANSI
//  characters and is case independent.
//
//  In this function patterns are made up from "literal" characters plus
//  some control characters, "*", "?". Asterix (*) is a place
//  holder for "zero or more" of any character. Question Mark (?) is a place
//  holder for "any single character". The square brackets ([]) contain a
//  list of matching characters, in this case "-" is used to denote a range
//  of characters (i.e. [A-Z] matches any alpha character), but I didn't 
//  pub brackets in this one yet...
//
//-------------------------------------------------------------------------
BOOL MatchREi( unsigned char *pszString,
               unsigned char *pszPattern )
{
    unsigned char *pchRangeLow;

    while (TRUE)
       {
       // Walk throuh the pattern, matching it against the string.
       switch (*pszPattern)
          {
          case '*':
             // Match zero or more characters.
             pszPattern = _mbsinc(pszPattern);
             while (*pszString)
                {
                if (MatchREi(pszString,pszPattern))
                   {
                   return TRUE;
                   }
                pszString = _mbsinc(pszString);
                }
                return MatchREi(pszString,pszPattern);

          case '?':
             // Match any single character.
             if (*pszString == 0)
                {
                // Not at end of string, so no match.
                return FALSE;
                }
             pszString = _mbsinc(pszString);
             break;

          #if FALSE
          case '[':
             // Match a set of characters.
             if (*pszString == 0)
                {
                // Syntax error, no matching close bracket "]".
                return FALSE;
                }

             pchRangeLow = 0;
             while (*pszPattern)
                {
                if (*pszPattern == ']')
                   {
                   // End of char set, no match found.
                   return FALSE;
                   }

                if (*pszPattern == '-')
                   {
                   // check a range of chars?
                   pszPattern = _mbsinc(pszPattern);

                   // get high limit of range:
                   if ((*pszPattern == 0)||(*pszPattern == ']'))
                      {
                      // Syntax error.
                      return FALSE;
                      }

                   if ( (_mbsnicoll(pszString,pchRangeLow,1) >= 0)
                      &&(_mbsnicoll(pszString,pszPattern,1) <= 0))
                      {
                      // In range, go to next character.
                      break;
                      }
                   }

                pchRangeLow = pchPattern;

                // See if character matches this pattern element.
                if (_mbsnicoll(pszString,pszPattern,1) == 0)
                   {
                   // Character match, go on.
                   break;
                   }

                pszPattern = _mbsinc(pszPattern);
                }

             // Have a match in the character set, skip to the end of the set.
             while ((*pszPattern != 0)&&(*pszPattern != ']'))
                {
                pszPattern = _mbsinc(pszPattern);
                }

             break;
             #endif

          case 0:
             // End of pattern, return TRUE if at end of string.
             return ((*pszString)? FALSE : TRUE);

          default:
             // Check for exact character match.
             if (_mbsnicoll(pszString,pszPattern,1))
                {
                // No match.
                return FALSE;
                }
             pszString = _mbsinc(pszString);
             break;
          }

          pszPattern = _mbsinc(pszPattern);
       }

    // Can never exit from here.
}

#if FALSE
    ... not currently used ...
//-------------------------------------------------------------------------
//  MatchRE()
//
//  Match the test string (pszString) against the specifed pattern. If they
//  match return TRUE, else return FALSE.
//
//  In this function patterns are made up from "literal" characters plus
//  some control characters, "*", "?", "[" and "]". Asterix (*) is a place
//  holder for "zero or more" of any character. Question Mark (?) is a place
//  holder for "any single character". The square brackets ([]) contain a
//  list of matching characters, in this case "-" is used to denote a range
//  of characters (i.e. [a-zA-Z] matches any alpha character).
//
//  Note: Currently there is no support for "or" (|) operator.
//
//  Note: Ranges are simple, there is no support for dash at the begining
//        of a range to denote the dash itself.
//-------------------------------------------------------------------------
BOOL MatchRE( unsigned char *pszString,
              unsigned char *pszPattern )
{
    unsigned char ch;
    unsigned char chPattern;
    unsigned char chRangeLow;

    while (TRUE)
       {
       // Walk throuh the pattern, matching it against the string.
       switch (chPattern = *pszPattern++)
          {
          case '*':
             // Match zero or more characters.
             while (*pszString)
                {
                if (MatchRE(pszString++,pszPattern))
                   {
                   return TRUE;
                   }
                }
                return MatchRE(pszString,pszPattern);

          case '?':
             // Match any single character.
             if (*pszString++ == 0)
                {
                // Not at end of string, so no match.
                return FALSE;
                }
             break;

          case '[':
             // Match a set of characters.
             if ( (ch = *pszString++) == 0)
                {
                // Syntax error, no matching close bracket "]".
                return FALSE;
                }

             // ch = toupper(ch);
             chRangeLow = 0;
             while (chPattern = *pszPattern++)
                {
                if (chPattern == ']')
                   {
                   // End of char set, no match found.
                   return FALSE;
                   }

                if (chPattern == '-')
                   {
                   // check a range of chars?
                   chPattern = *pszPattern;           // get high limit of range
                   if ((chPattern == 0)||(chPattern == ']'))
                      {
                      // Syntax error.
                      return FALSE;
                      }

                   if ((ch >= chRangeLow)&&(ch <= chPattern))
                      {
                      // In range, go to next character.
                      break;
                      }
                   }

                chRangeLow = chPattern;
                // See if character matches this pattern element.
                if (ch == chPattern)
                   {
                   // Character match, go on.
                   break;
                   }
                }

             // Have a match in the character set, skip to the end of the set.
             while ((chPattern)&&(chPattern != ']'))
                {
                chPattern = *pszPattern++;
                }

             break;

          case 0:
             // End of pattern, return TRUE if at end of string.
             return ((*pszString)? FALSE : TRUE);

          default:
             ch = *pszString++;
             // Check for exact character match.
             // Note: CASE doesn't matter...
             if (tolower(ch) != tolower(chPattern))
                {
                // No match.
                return FALSE;
                }
             break;
          }
       }

    // Can never exit from here.
}

//-------------------------------------------------------------------------
//  MatchREList()
//
//  Match a string against a list (array) of RE pattens, return TRUE iff
//  the string matches one of the RE patterns. The list of patterns is a
//  NULL terminated array of pointers to RE pattern strings.
//-------------------------------------------------------------------------
BOOL MatchREList( unsigned char  *pszString,
                  unsigned char **ppszREList  )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (MatchRE(pszString,pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}

//-------------------------------------------------------------------------
//  MatchExactList()
//
//-------------------------------------------------------------------------
BOOL MatchExactList( unsigned char  *pszString,
                     unsigned char **ppszREList )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (!_mbsicmp(pszString,pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\server.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  server.h
//
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#ifndef CHAR_0
#define CHAR_0       '0'
#define CHAR_9       '9'
#endif

#ifndef CHAR_A
#define CHAR_A       'A'
#define CHAR_F       'F'
#endif

//--------------------------------------------------------------------
//  Functions:
//--------------------------------------------------------------------

extern DWORD CleanupECB( EXTENSION_CONTROL_BLOCK *pECB );

extern DWORD WINAPI ReceiveThreadProc( void *pvServerInfo );

extern BOOL  CheckStartReceiveThread( SERVER_INFO *pServerInfo,
                                      DWORD       *pdwStatus  );

extern BOOL  SubmitNewRead( SERVER_INFO       *pServerInfo,
                            SERVER_OVERLAPPED *pOverlapped,
                            DWORD             *pdwStatus   );

extern BOOL  StartAsyncClientRead( EXTENSION_CONTROL_BLOCK *pECB,
                                   SERVER_CONNECTION       *pConn,
                                   DWORD                   *pdwStatus );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\server.c ===
//-----------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  server.c
//
//  Thread code to manage communication between RPC client and
//  server for the HTTP RPC proxy.
//
//  History:
//
//    Edward Reus  00-00-97   Initial version.
//-----------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"
#include "server.h"

//-----------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------

HANDLE  g_hServerThread = 0;
DWORD   g_dwThreadId = 0;

extern  SERVER_INFO *g_pServerInfo;

//-----------------------------------------------------------------
// CleanupECB()
//
// When the client or server side connection is closed, they call
// this function to handle cleanup of the ECB. The active ECBs are
// reference counted, since its used by both the server and client
// side threads. When the count goes to zero, the ECB can be
// destroyed by the IIS (HSE_REQ_DONE_WITH_SESSION).
//
//-----------------------------------------------------------------
DWORD CleanupECB( EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD dwStatus = 0;

    if (DecrementECBRefCount(g_pServerInfo->pActiveECBList,pECB))
        {
        //
        // The ECB reference count has reached zero, we can get
        // rid of it:
        //
        #ifdef DBG_ECBREF
        DbgPrint("CleanupECB(): Destroy ECB: 0x%x\n",pECB);
        #endif

        if (!pECB->ServerSupportFunction( pECB->ConnID,
                                          HSE_REQ_DONE_WITH_SESSION,
                                          NULL, NULL, NULL))
            {
            dwStatus = GetLastError();
            #ifdef DBG_ERROR
            DbgPrint("CleanupECB(): HSE_REQ_DONE_WITH_SESSION failed: %d\n",dwStatus);
            #endif
            }
        }

    return dwStatus;
    }

#ifdef DBG
//-----------------------------------------------------------------
//  CheckForOldECBs()
//
//-----------------------------------------------------------------
void CheckForOldECBs()
    {
    int    i;
    DWORD  dwStatus;
    DWORD  dwAgeMsec;
    DWORD  dwTickCount = GetTickCount();
    ACTIVE_ECB_LIST   *pECBList = g_pServerInfo->pActiveECBList;
    ECB_ENTRY         *pECBEntry;
    LIST_ENTRY        *pEntry;
    LIST_ENTRY        *pHead = NULL;
    LIST_ENTRY        *pOldEntries = NULL;
    EXTENSION_CONTROL_BLOCK *pECB;

    //
    // Check for ECBs that are inactive (one side of connection
    // closed) for more that 10 minutes.
    //
    #define OLD_AGE_LIMIT 1000*60*10

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    for (i=0; i<HASH_SIZE; i++)
        {
        pHead = &(pECBList->HashTable[i]);

        pEntry = pHead->Flink;

        while (pEntry != pHead)
            {
            pECBEntry = CONTAINING_RECORD(pEntry,ECB_ENTRY,ListEntry);

            if (pECBEntry->dwTickCount)
                {
                // Ok, this is one where one of the server/client side
                // has closed the connection:
                //
                // dwAgeMsec is the age of the current ECB is msec.
                //
                if (pECBEntry->dwTickCount > dwTickCount)
                    {
                    // Rollover case (every ~49 days):
                    dwAgeMsec = (0xFFFFFFFF - pECBEntry->dwTickCount) + dwTickCount;
                    }
                else
                    {
                    dwAgeMsec = dwTickCount - pECBEntry->dwTickCount;
                    }

                // ASSERT( dwAgeMsec <= OLD_AGE_LIMIT);

                if (dwAgeMsec > OLD_AGE_LIMIT)
                    {
                    RemoveEntryList(pEntry);
                    pEntry->Blink = pOldEntries;
                    pOldEntries = pEntry;
                    }
                }

            pEntry = pEntry->Flink;
            }
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    while (pOldEntries)
        {
        pECBEntry = CONTAINING_RECORD(pOldEntries,ECB_ENTRY,ListEntry);
        pECB = pECBEntry->pECB;
        pOldEntries = pOldEntries->Blink;

        MemFree(pECBEntry);

        #ifdef DBG_ECBREF
        DbgPrint("CheckForOldECBs(): Age out pECB: 0x%x\n",pECB);
        #endif

        if (!pECB->ServerSupportFunction( pECB->ConnID,
                                          HSE_REQ_DONE_WITH_SESSION,
                                          NULL, NULL, NULL))
            {
            #ifdef DBG_ERROR
            DbgPrint("CheckForOldECBs(): HSE_REQ_DONE_WITH_SESSION failed: %d\n", GetLastError());
            #endif
            }
        }
    }
#endif

//-----------------------------------------------------------------
//  SendToClient()
//
//  Forward data received from the server back to the client.
//-----------------------------------------------------------------
BOOL SendToClient( SERVER_INFO       *pServerInfo,
                   SERVER_OVERLAPPED *pOverlapped,
                   DWORD              dwReceiveSize,
                   DWORD             *pdwStatus     )
{
   DWORD  dwSize;
   DWORD  dwFlags = (HSE_IO_SYNC | HSE_IO_NODELAY);
   UCHAR *pBuffer = pOverlapped->arBuffer;
   EXTENSION_CONTROL_BLOCK *pECB = pOverlapped->pECB;

   *pdwStatus = 0;

   //
   // Forward the data to the client:
   //
   dwSize = dwReceiveSize;
   while (dwReceiveSize)
      {
      if (!pECB->WriteClient(pECB->ConnID,pBuffer,&dwSize,dwFlags))
         {
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("SendToClient(): WriteClient() failed: %d\n",*pdwStatus);
         #endif
         return FALSE;
         }

      dwReceiveSize -= dwSize;

      if (dwReceiveSize)
         {
         pBuffer += dwSize;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  SubmitNewRead()
//
//  Submit a read request on the socket connected to the
//  RPC server process.
//-----------------------------------------------------------------
BOOL SubmitNewRead( SERVER_INFO       *pServerInfo,
                    SERVER_OVERLAPPED *pOverlapped,
                    DWORD             *pdwStatus    )
{
   DWORD  dwBytesRead = 0;
   SERVER_CONNECTION  *pConn = pOverlapped->pConn;


   *pdwStatus = 0;

   pOverlapped->Internal = 0;
   pOverlapped->InternalHigh = 0;
   pOverlapped->Offset = 0;
   pOverlapped->OffsetHigh = 0;
   pOverlapped->hEvent = 0;

   SetLastError(ERROR_SUCCESS);

   if (!ReadFile( (HANDLE)pConn->Socket,
                  pOverlapped->arBuffer,
                  READ_BUFFER_SIZE,
                  &dwBytesRead,
                  (OVERLAPPED*)pOverlapped ) )
      {
      *pdwStatus = GetLastError();
      if ( (*pdwStatus != ERROR_IO_PENDING) && (*pdwStatus != ERROR_SUCCESS) )
         {
         #ifdef DBG_ERROR
         DbgPrint("SubmitNewRead(): ReadFile() Socket: %d  failed: %d\n",pConn->Socket,*pdwStatus);
         #endif
         return FALSE;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  ForwardAndSubmitNewRead()
//
//  Forward data to the client, the submit a new read on the
//  server.
//-----------------------------------------------------------------
BOOL ForwardAndSubmitNewRead( SERVER_INFO       *pServerInfo,
                              SERVER_OVERLAPPED *pOverlapped,
                              DWORD              dwReceiveSize,
                              DWORD             *pdwStatus     )
{
   DWORD  dwBytesRead = 0;
   SERVER_CONNECTION  *pConn = pOverlapped->pConn;

   *pdwStatus = 0;

   //
   // Forward the data to the client:
   //
   if (!SendToClient(pServerInfo,pOverlapped,dwReceiveSize,pdwStatus))
      {
      return FALSE;
      }

   //
   // Submit another read on the socket:
   //
   if (!SubmitNewRead(pServerInfo,pOverlapped,pdwStatus))
      {
      return FALSE;
      }

   return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
//-----------------------------------------------------------------
//  ServerReceiveThreadProc()
//
//  This is the receive thread for the server. It monitors the
//  all the sockets to RPC servers that are currently connected
//  to the RPC proxy. When it gets incomming data from an RPC
//  server socket, it forwards the data to the client, then
//  submits a new read on the socket that data came in on.
//
//  Once its started, it never stops...
//-----------------------------------------------------------------
DWORD WINAPI ServerReceiveThreadProc( void *pvServerInfo )
{
   int    iRet;
   BOOL   fWaitAll = FALSE;
   DWORD  dwStatus;
   DWORD  dwTimeout = TIMEOUT_MSEC;
   DWORD  dwWhichEvent;
   ULONG_PTR dwKey;
   DWORD  dwNumBytes;
   SERVER_OVERLAPPED *pOverlapped;
   SERVER_INFO       *pServerInfo = (SERVER_INFO*)pvServerInfo;
   EXTENSION_CONTROL_BLOCK *pECB;
   DWORD  dwTemp;
   DWORD  dwSize;
   DWORD  dwFlags;


   while (TRUE)
      {
      SetLastError(0);
      dwKey = 0;
      dwNumBytes = 0;
      pOverlapped = NULL;
      if (!GetQueuedCompletionStatus(pServerInfo->hIoCP,&dwNumBytes,&dwKey,(OVERLAPPED**)&pOverlapped,dwTimeout))
         {
         dwStatus = GetLastError();
         if (dwStatus == WAIT_TIMEOUT)
            {
            // Our reads are still posted, go around again:
            #ifdef DBG
            CheckForOldECBs();
            #endif
            continue;
            }
         else if (dwStatus == ERROR_OPERATION_ABORTED)
            {
            // The posted read on the server was aborted (why?). Try
            // to resubmit the read...
            if ( (pOverlapped)
               && (!SubmitNewRead(pServerInfo,pOverlapped,&dwStatus)) )
               {
               pECB = pOverlapped->pECB;
               CloseServerConnection(pOverlapped->pConn);
               FreeOverlapped(pOverlapped);
               CleanupECB(pECB);
               #ifdef DBG_ERROR
               DbgPrint("ServerReceiveThreadProc(): Aborted re-submit failed: %d\n",dwStatus);
               #endif
               }
            continue;
            }
         else if (dwStatus == ERROR_NETNAME_DELETED)
            {
            // The server connection has been closed:
            if (pOverlapped)
               {
               pECB = pOverlapped->pECB;
               CloseServerConnection(pOverlapped->pConn);
               FreeOverlapped(pOverlapped);
               CleanupECB(pECB);

               #ifdef DBG_ERROR
               DbgPrint("ServerReceiveThreadProc(): Socket(%d): ERROR_NETNAME_DELETED\n",dwKey,dwStatus);
               #endif
               }
            continue;
            }
         else
            {
            #ifdef DBG_ERROR
            DbgPrint("ServerReceiveThreadProc(): GetQueuedCompletionStatus() failed: %d\n",dwStatus);
            #endif
            if (pOverlapped)
               {
               pECB = pOverlapped->pECB;
               CloseServerConnection(pOverlapped->pConn);
               FreeOverlapped(pOverlapped);
               CleanupECB(pECB);
               }
            continue;
            }
         }

      // Check for incomming data from a server:
      if (pOverlapped)
          {
          pECB = pOverlapped->pECB;

          if (dwNumBytes)
              {
              //
              // data from server arrived...
              //
              if (!ForwardAndSubmitNewRead(pServerInfo,pOverlapped,dwNumBytes,&dwStatus))
                 {
                 CloseServerConnection(pOverlapped->pConn);
                 FreeOverlapped(pOverlapped);
                 CleanupECB(pECB);
                 #ifdef DBG_ERROR
                 DbgPrint("ServerReceiveThreadProc(): ForwardAndSubmitNewRead(): failed: %d\n",dwStatus);
                 #endif
                 }
              }
          else
              {
              // Receive, but zero bytes, so connection was gracefully closed...
              CloseServerConnection(pOverlapped->pConn);
              FreeOverlapped(pOverlapped);
              CleanupECB(pECB);
              }
          }
      else
          {
          // The filter called EndOfSession() and posted this message to
          // us to close up... dwKey is the socket in question:

          #ifdef DBG_ERROR
          DbgPrint("ServerReceiveProc(): EndOfSession(): pOverlapped == NULL\n");
          #endif

          iRet = closesocket( (SOCKET)dwKey );

          #ifdef DBG_COUNTS
          if (iRet == SOCKET_ERROR)
              {
              DbgPrint("[6] closesocket(%d) failed: %d\n",dwKey,WSAGetLastError());
              }
          else
              {
              int iCount = InterlockedDecrement(&g_iSocketCount);
              DbgPrint("[6] closesocket(%d): Count: %d -> %d\n",
                       dwKey, 1+iCount, iCount );
              }
          #endif
          }
      }

   return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

//-----------------------------------------------------------------
//  CheckStartReceiveThread()
//
//  Check to see of the server side receive thread is running, if
//  it isn't started yet, then start it.
//-----------------------------------------------------------------
BOOL CheckStartReceiveThread( SERVER_INFO *pServerInfo,
                              DWORD       *pdwStatus )
{
   *pdwStatus = 0;

   if (!g_hServerThread)
      {
      g_hServerThread = CreateThread( NULL,
                                      0,
                                      ServerReceiveThreadProc,
                                      (void*)pServerInfo,
                                      0,
                                      &g_dwThreadId );

      if (!g_hServerThread)
         {
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("CheckStartServerThread(): CreateThread() failed: 0x%x\n",pdwStatus);
         #endif
         return FALSE;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  AsyncClientReadComplete()
//
//  This function is called when data (a call) comes in from an
//  RPC client. It then forwards the data to the RPC server via
//  the function SendToServer().
//-----------------------------------------------------------------
void WINAPI AsyncClientReadComplete( IN EXTENSION_CONTROL_BLOCK *pECB,
                                     IN void     *pvOverlapped,
                                     IN DWORD     dwBytes,
                                     IN DWORD     dwStatus )
{
   int       iRet;
   DWORD     dwSize;
   DWORD     dwFlags;
   DWORD     dwLocalStatus;
   SERVER_CONNECTION       *pConn;
   SERVER_OVERLAPPED       *pOverlapped = (SERVER_OVERLAPPED*)pvOverlapped;
   SOCKET    Socket;

   ASSERT(pECB == pOverlapped->pECB);

   pConn = pOverlapped->pConn;

   if (dwStatus == ERROR_SUCCESS)
      {
      if (dwBytes)
         {
         if (pOverlapped->fFirstRead)
            {
            pOverlapped->fFirstRead = FALSE;
            if ( (dwBytes < 72) && (pECB->lpbData) )
               {
               #ifdef DBG_ERROR
               DbgPrint("AsyncClientReadComplete(): Bind missing bytes: %d\n",72-dwBytes);
               #endif
               dwStatus = SendToServer(pOverlapped->pConn,pECB->lpbData,72-dwBytes);
               }
            }

         // Got data from the client, forward it to the server:
         dwStatus = SendToServer(pOverlapped->pConn,pOverlapped->arBuffer,dwBytes);

         // Submit a new async read on the client:
         if (dwStatus == ERROR_SUCCESS)
            {
            dwSize = sizeof(pOverlapped->arBuffer);
            dwFlags = HSE_IO_ASYNC;
            if (!pECB->ServerSupportFunction(pECB->ConnID,
                                             HSE_REQ_ASYNC_READ_CLIENT,
                                             pOverlapped->arBuffer,
                                             &dwSize,
                                             &dwFlags))
               {
               dwStatus = GetLastError();
               }
            }
         }
      }

   if ((dwBytes == 0) || (dwStatus != ERROR_SUCCESS))
      {
      //
      // Connection to client was closed (dwBytes == 0) or error. So
      // shutdown socket to server:
      //
      if (pOverlapped)
         {
         CloseServerConnection(pOverlapped->pConn);
         pOverlapped->pECB = NULL;
         FreeOverlapped(pOverlapped);
         CleanupECB(pECB);
         }

      #ifdef DBG_ERROR
      if ((dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_NETNAME_DELETED))
         {
         DbgPrint("AsyncClientReadComplete(): Erorr: %d  Close server socket: %d\n",dwStatus,pConn->Socket);
         }
      #endif
      }
}

//-----------------------------------------------------------------
//  StartAsyncClientRead()
//
//  Called by the RpcIsapi half of the code to start an async read
//  on the client connection.
//-----------------------------------------------------------------
BOOL StartAsyncClientRead( EXTENSION_CONTROL_BLOCK *pECB,
                           SERVER_CONNECTION       *pConn,
                           DWORD                   *pdwStatus )
{
   SERVER_OVERLAPPED       *pOverlapped;

   pOverlapped = AllocOverlapped();
   if (!pOverlapped)
       {
       *pdwStatus = RPC_S_OUT_OF_MEMORY;
       return FALSE;
       }

   *pdwStatus = 0;

   pOverlapped->pECB = pECB;

   // The SERVER_CONNECTION (pConn) is in two separate SERVER_OVERLAPPED
   // structures, one for client async reads and one for server async
   // reads, as well as in the filter context. So it is reference counted.
   pOverlapped->pConn = pConn;
   AddRefConnection(pConn);

   pOverlapped->fFirstRead = TRUE;

   if (!pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_IO_COMPLETION,
                                    AsyncClientReadComplete,
                                    NULL,
                                    (void*)pOverlapped))
      {
      *pdwStatus = GetLastError();
      FreeOverlapped(pOverlapped);
      #ifdef DBG_ERROR
      DbgPrint("StartAsyncClientRead(): HSE_REQ_IO_COMPLETION Failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   pOverlapped->dwBytes = sizeof(pOverlapped->arBuffer);
   pOverlapped->dwFlags = HSE_IO_ASYNC;
   if (!pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_ASYNC_READ_CLIENT,
                                    pOverlapped->arBuffer,
                                    &pOverlapped->dwBytes,
                                    &pOverlapped->dwFlags))
      {
      *pdwStatus = GetLastError();
      FreeOverlapped(pOverlapped);
      #ifdef DBG_ERROR
      DbgPrint("StartAsyncClientRead(): HSE_REQ_ASYNC_READ_CLIENT Failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood  (stevewo) 12-Apr-1989
    Edward Reus (edwardr) 14-Jun-1997  Version for RpcProxy.Dll


Revision History:

!ENDIF

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=RpcProxy

#
# The TARGETPATH and TARGETTYPE varialbes are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK or LIBRARY)
#

TARGETPATH=obj
TARGETTYPE=DYNLINK
PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

TARGETLIBS= $(SDK_LIB_PATH)\rpcrt4.lib               \
            $(SDK_LIB_PATH)\ole32.lib    \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\wsock32.lib  \
            $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\msvcrt.lib

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\..\..\mtrt
MSC_WARNING_LEVEL=/WX

#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\filter.c     \
         ..\RpcIsapi.c   \
         ..\server.c     \
         ..\httpreg.c    \
         ..\regexp.c     \
         ..\memory.c     \
         ..\ecblist.c    \
         ..\olist.c      \
         ..\registry.cpp \
         ..\RpcProxy.rc

!ifdef DOSWIN32RPC
RPCENV=-DDOSWIN32RPC -DWIN32RPC
!else
RPCENV=-DNTENV -DWIN32RPC -DNTWIN32RPC
!endif

C_DEFINES=$(RPCENV)
USE_NTDLL=1
NOENTRY=1

UMTYPE=console
UMRES=obj\*\RpcProxy.res
#NTPROFILEINPUT=yes

#
# Defining the NTTARGETFILES variable causes MAKEFILE.DEF to attempt to
# include .\makefile.inc immediately after it specifies the top
# level targets (all, clean and loc) and their dependencies.  MAKEFILE.DEF
# also expands the value of the NTTARGETFILES variable at the end of the
# list of dependencies for the all target.  Useful for specifying additional
# targets and dependencies that don't fit the general case covered by
# MAKEFILE.DEF
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\registry.h ===
//--------------------------------------------------------------------
// Copyright (C)1998 Microsoft Corporation, All Rights Reserved
//
// registry.h
//
// Constants for registration of the ncacn_http RpcProxy with
// the registry and IIS MetaBase.
//
//
//--------------------------------------------------------------------


#ifndef _MBASE_H_
#define _MBASE_H_

//--------------------------------------------------------------------
//  Registry constants:
//--------------------------------------------------------------------

#ifdef DBG
#define DBG_REG
#endif

#define MAX_TCPIP_HOST_NAME       512

#define REG_RPC_PATH             TEXT("Software\\Microsoft\\Rpc")
#define REG_RPCPROXY             TEXT("RpcProxy")
#define REG_ENABLED              TEXT("Enabled")
#define REG_VALID_PORTS          TEXT("ValidPorts")
#define REG_PORT_RANGE           TEXT(":100-5000")

//--------------------------------------------------------------------
//  MetaBase constants:
//--------------------------------------------------------------------
#define ORIGINAL_BUFFER_SIZE     512

#define SYSTEM_ROOT              TEXT("SystemRoot")
#define RPCPROXY_PATH            TEXT("\\System32\\RpcProxy")

#define RPCPROXY                 TEXT("RpcProxy")
#define RPCPROXY_DLL             TEXT("RpcProxy.dll")

#define LOCAL_MACHINE_W3SVC      TEXT("/LM/W3SVC")
#define APP_ROOT_PATH            TEXT("/LM/W3SVC/1/Root/rpc")
#define APP_FRIENDLY_NAME        TEXT("rpc")
#define APP_WAM_CLSID            TEXT("{BF285648-0C5C-11D2-A476-0000F8080B50}")

#define IISFILTER                TEXT("IIsFilter")
#define FILTER_DESCRIPTION       TEXT("Microsoft RPC Proxy Filter, v1.0")

#define IIS_WEB_VIRTUAL_DIR      TEXT("IIsWebVirtualDir")

#define MD_KEY_FILTERS           TEXT("Filters")
#define MD_KEY_FILTERS_RPCPROXY  TEXT("Filters/RpcProxy")
#define MD_KEY_ROOT_RPC          TEXT("1/ROOT/Rpc")

#define ACCESS_PERM_FLAGS        MD_ACCESS_EXECUTE
#define DIRECTORY_BROWSING_FLAGS 0x4000001E

#endif //_MBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\registry.cpp ===
//---------------------------------------------------------------------
//  Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
//  registry.cpp
//
//---------------------------------------------------------------------

#define UNICODE
#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <malloc.h>
#include <winsock2.h>
#include <olectl.h>   // for: SELFREG_E_CLASS
#include <iadmw.h>    // COM Interface header 
#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines
#include <httpfilt.h>
#include "registry.h"

//----------------------------------------------------------------
//  Externals:
//----------------------------------------------------------------

extern "C" void *MemAllocate( DWORD dwSize );

extern "C" void *MemFree( VOID *pMem );

//----------------------------------------------------------------
//  Globals:
//----------------------------------------------------------------

// static HINSTANCE   g_hInst = 0;

//----------------------------------------------------------------
//  AnsiToUnicode()
//
//  Convert an ANSI string to a UNICODE string.
//----------------------------------------------------------------
DWORD AnsiToUnicode( IN  UCHAR *pszString,
                     IN  ULONG  ulStringLen,
                     OUT WCHAR *pwsString    )
{
    if (!pszString)
       {
       if (!pwsString)
          {
          return NO_ERROR;
          }
       else
          {
          pwsString[0] = 0;
          return NO_ERROR;
          }
       }

    if (!MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                              (char*)pszString, 1+ulStringLen,
                              pwsString, 1+ulStringLen ))
       {
       return ERROR_NO_UNICODE_TRANSLATION;
       }

    return NO_ERROR;
}

//---------------------------------------------------------------------
//  RegSetKeyAndValue()
//
//  Private helper function for SetupRegistry() that creates
//  a key, sets a value, then closes the key.
//
//  Parameters:
//    pwsKey       WCHAR* The name of the key
//    pwsSubkey    WCHAR* The name of a subkey
//    pwsValueName WCHAR* The value name.
//    pwsValue     WCHAR* The data value to store
//    dwType       The type for the new registry value.
//    dwDataSize   The size for non-REG_SZ registry entry types.
//
//  Return:
//    BOOL         TRUE if successful, FALSE otherwise.
//---------------------------------------------------------------------
BOOL RegSetKeyAndValue( const WCHAR *pwsKey,
                        const WCHAR *pwsSubKey,
                        const WCHAR *pwsValueName,
                        const WCHAR *pwsValue,
                        const DWORD  dwType = REG_SZ,
                              DWORD  dwDataSize = 0 )
    {
    HKEY   hKey;
    DWORD  dwSize = 0;
    WCHAR  *pwsCompleteKey;

    if (pwsKey)
        dwSize = wcslen(pwsKey);

    if (pwsSubKey)
        dwSize += wcslen(pwsSubKey);

    dwSize = (1+1+dwSize)*sizeof(WCHAR);  // Extra +1 for the backslash...

    pwsCompleteKey = (WCHAR*)_alloca(dwSize);

    if (!pwsCompleteKey)
        {
        return FALSE;   // Out of stack memory.
        }

    wcscpy(pwsCompleteKey,pwsKey);

    if (NULL!=pwsSubKey)
        {
        wcscat(pwsCompleteKey, TEXT("\\"));
        wcscat(pwsCompleteKey, pwsSubKey);
        }

    if (ERROR_SUCCESS!=RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                       pwsCompleteKey,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_ALL_ACCESS, NULL, &hKey, NULL))
        {
        return FALSE;
        }

    if (pwsValue)
        {
        if ((dwType == REG_SZ)||(dwType == REG_EXPAND_SZ))
          dwDataSize = (1+wcslen(pwsValue))*sizeof(WCHAR);

        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, dwDataSize );
        }
    else
        {
        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, 0 );
        }

    RegCloseKey(hKey);
    return TRUE;
    }

//---------------------------------------------------------------------
//  SetupRegistry()
//
//  Add RPC proxy specific registry entries to contol its operation.
//
//  \HKEY_LOCAL_MACHINE
//     \Software
//         \Microsoft
//             \Rpc
//                 \RpcProxy
//                     \Enabled:REG_DWORD:0x00000001
//                     \ValidPorts:REG_SZ:<hostname>:1-5000
//
//---------------------------------------------------------------------
HRESULT SetupRegistry()
    {
    DWORD  dwEnabled = 0x01;
    DWORD  dwSize;
    DWORD  dwStatus;
    WCHAR *pwsValidPorts = 0;
    char   szHostName[MAX_TCPIP_HOST_NAME];

    // Note that gethostname() is an ANSI (non-unicode) function:
    if (SOCKET_ERROR == gethostname(szHostName,sizeof(szHostName)))
        {
        dwStatus = WSAGetLastError();
        return SELFREG_E_CLASS;
        }

    dwSize = 1 + _mbstrlen(szHostName);
    pwsValidPorts = (WCHAR*)MemAllocate( sizeof(WCHAR)
                                         * (dwSize + wcslen(REG_PORT_RANGE)) );
    if (!pwsValidPorts)
        {
        return E_OUTOFMEMORY;
        }

    dwStatus = AnsiToUnicode((unsigned char*)szHostName,dwSize,pwsValidPorts);
    if (dwStatus != NO_ERROR)
        {
        MemFree(pwsValidPorts);
        return SELFREG_E_CLASS;
        }

    wcscat(pwsValidPorts,REG_PORT_RANGE);

    if (  !RegSetKeyAndValue( REG_RPC_PATH,
                              REG_RPCPROXY,
                              REG_ENABLED,
                              (unsigned short *)&dwEnabled,
                              REG_DWORD,
                              sizeof(DWORD))

       || !RegSetKeyAndValue( REG_RPC_PATH,
                              REG_RPCPROXY,
                              REG_VALID_PORTS,
                              pwsValidPorts,
                              REG_SZ) )
        {
        MemFree(pwsValidPorts);
        return SELFREG_E_CLASS;
        }

    MemFree(pwsValidPorts);

    return S_OK;
    }

//---------------------------------------------------------------------
//  CleanupRegistry()
//
//  Delete the RpcProxy specific registry entries.
//---------------------------------------------------------------------
HRESULT CleanupRegistry()
    {
    HRESULT  hr;
    LONG     lStatus;
    DWORD    dwLength = sizeof(WCHAR) + sizeof(REG_RPC_PATH)
                                      + sizeof(REG_RPCPROXY);
    WCHAR   *pwsSubKey;

    pwsSubKey = (WCHAR*)_alloca(sizeof(WCHAR)*dwLength);

    if (pwsSubKey)
        {
        wcscpy(pwsSubKey,REG_RPC_PATH);
        wcscat(pwsSubKey,TEXT("\\"));
        wcscat(pwsSubKey,REG_RPCPROXY);

        lStatus = RegDeleteKey( HKEY_LOCAL_MACHINE,
                                pwsSubKey );
        }

    return S_OK;
    }

//---------------------------------------------------------------------
//  GetMetaBaseString()
//
//  Retrieve a string value from the metabase.
//---------------------------------------------------------------------
HRESULT GetMetaBaseString( IN  IMSAdminBase    *pIMeta,
                           IN  METADATA_HANDLE  hMetaBase,
                           IN  WCHAR           *pwsKeyPath,
                           IN  DWORD            dwIdent,
                           OUT WCHAR           *pwsBuffer,
                           IN OUT DWORD        *pdwBufferSize )
    {
    HRESULT  hr;
    DWORD    dwSize;
    METADATA_RECORD *pmbRecord;

    dwSize = sizeof(METADATA_RECORD);

    pmbRecord = (METADATA_RECORD*)MemAllocate(dwSize);
    if (!pmbRecord)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pmbRecord,0,dwSize);

    pmbRecord->dwMDIdentifier = dwIdent;
    pmbRecord->dwMDAttributes = 0;  // METADATA_INHERIT;
    pmbRecord->dwMDUserType = IIS_MD_UT_SERVER;
    pmbRecord->dwMDDataType = STRING_METADATA;
    pmbRecord->dwMDDataLen = *pdwBufferSize;
    pmbRecord->pbMDData = (BYTE*)pwsBuffer;

    hr = pIMeta->GetData( hMetaBase,
                          pwsKeyPath,
                          pmbRecord,
                          &dwSize );
    #ifdef DBG_REG
    if (FAILED(hr))
        {
        DbgPrint("pIMeta->GetData(): Failed: 0x%x\n",hr);
        }
    #endif

    MemFree(pmbRecord);

    return hr;
    }

//---------------------------------------------------------------------
//  SetMetaBaseString()
//
//  Store a string value into the metabase.
//---------------------------------------------------------------------
HRESULT SetMetaBaseString( IMSAdminBase    *pIMeta,
                           METADATA_HANDLE  hMetaBase,
                           WCHAR           *pwsKeyPath,
                           DWORD            dwIdent,
                           WCHAR           *pwsBuffer,
                           DWORD            dwAttributes,
                           DWORD            dwUserType )
    {
    HRESULT  hr;
    METADATA_RECORD MbRecord;

    memset(&MbRecord,0,sizeof(MbRecord));

    MbRecord.dwMDIdentifier = dwIdent;
    MbRecord.dwMDAttributes = dwAttributes;
    MbRecord.dwMDUserType = dwUserType;
    MbRecord.dwMDDataType = STRING_METADATA;
    MbRecord.dwMDDataLen = sizeof(WCHAR) * (1 + wcslen(pwsBuffer));
    MbRecord.pbMDData = (BYTE*)pwsBuffer;

    hr = pIMeta->SetData( hMetaBase,
                          pwsKeyPath,
                          &MbRecord );

    return hr;
    }

//---------------------------------------------------------------------
//  GetMetaBaseDword()
//
//  Get a DWORD value from the metabase.
//---------------------------------------------------------------------
HRESULT GetMetaBaseDword( IMSAdminBase    *pIMeta,
                          METADATA_HANDLE  hMetaBase,
                          WCHAR           *pwsKeyPath,
                          DWORD            dwIdent,
                          DWORD           *pdwValue )
    {
    HRESULT  hr;
    DWORD    dwSize;
    METADATA_RECORD MbRecord;

    memset(&MbRecord,0,sizeof(MbRecord));
    *pdwValue = 0;

    MbRecord.dwMDIdentifier = dwIdent;
    MbRecord.dwMDAttributes = 0;
    MbRecord.dwMDUserType = IIS_MD_UT_SERVER;
    MbRecord.dwMDDataType = DWORD_METADATA;
    MbRecord.dwMDDataLen = sizeof(DWORD);
    MbRecord.pbMDData = (unsigned char *)pdwValue;

    hr = pIMeta->GetData( hMetaBase,
                          pwsKeyPath,
                          &MbRecord,
                          &dwSize );

    return hr;
    }

//---------------------------------------------------------------------
//  SetMetaBaseDword()
//
//  Store a DWORD value into the metabase.
//---------------------------------------------------------------------
HRESULT SetMetaBaseDword( IMSAdminBase    *pIMeta,
                          METADATA_HANDLE  hMetaBase,
                          WCHAR           *pwsKeyPath,
                          DWORD            dwIdent,
                          DWORD            dwValue,
                          DWORD            dwAttributes,
                          DWORD            dwUserType )
    {
    HRESULT  hr;
    DWORD    dwSize;
    METADATA_RECORD MbRecord;

    memset(&MbRecord,0,sizeof(MbRecord));

    MbRecord.dwMDIdentifier = dwIdent;
    MbRecord.dwMDAttributes = dwAttributes;
    MbRecord.dwMDUserType = dwUserType;
    MbRecord.dwMDDataType = DWORD_METADATA;
    MbRecord.dwMDDataLen = sizeof(DWORD);
    MbRecord.pbMDData = (unsigned char *)&dwValue;

    hr = pIMeta->SetData( hMetaBase,
                          pwsKeyPath,
                          &MbRecord );

    return hr;
    }

//---------------------------------------------------------------------
// SetupMetaBase()
//
// Setup entries in the metabase for both the filter and ISAPI parts
// of the RPC proxy. Note that these entries used to be in the registry.
//
// W3Svc/Filters/FilterLoadOrder            "...,RpcProxy"
// W3Svc/Filters/RpcProxy/FilterImagePath   "%SystemRoot%\System32\RpcProxy"
// W3Svc/Filters/RpcProxy/KeyType           "IIsFilter"
// W3Svc/Filters/RpcProxy/FilterDescription "Microsoft RPC Proxy Filter, v1.0"
//
// W3Svc/1/ROOT/Rpc/KeyType                 "IIsWebVirtualDir"
// W3Svc/1/ROOT/Rpc/VrPath                  "%SystemRoot%\System32\RpcProxy"
// W3Svc/1/ROOT/Rpc/AccessPerm              0x205
// W3Svc/1/ROOT/Rpc/Win32Error              0x0
// W3Svc/1/ROOT/Rpc/DirectoryBrowsing       0x4000001E
// W3Svc/1/ROOT/Rpc/AppIsolated             0x0
// W3Svc/1/ROOT/Rpc/AppRoot                 "/LM/W3SVC/1/Root/rpc"
// W3Svc/1/ROOT/Rpc/AppWamClsid             "{BF285648-0C5C-11D2-A476-0000F8080B50}"
// W3Svc/1/ROOT/Rpc/AppFriendlyName         "rpc"
//
//---------------------------------------------------------------------
HRESULT SetupMetaBase()
    {
    HRESULT hr = 0;
    DWORD   dwValue = 0;
    DWORD   dwSize = 0;
    DWORD   dwBufferSize = sizeof(WCHAR) * ORIGINAL_BUFFER_SIZE;
    WCHAR  *pwsBuffer = (WCHAR*)MemAllocate(dwBufferSize);
    WCHAR  *pwsSystemRoot = _wgetenv(SYSTEM_ROOT);
    WCHAR   wsPath[METADATA_MAX_NAME_LEN];

    IMSAdminBase   *pIMeta;
    METADATA_HANDLE hMetaBase;

    //
    // Name of this DLL (and where it is):
    //
    // WCHAR   wszModule[256];
    //
    // if (!GetModuleFileName( g_hInst, wszModule,
    //                         sizeof(wszModule)/sizeof(WCHAR)))
    //    {
    //    return SELFREG_E_CLASS;
    //    }

    if (!pwsBuffer)
        {
        return E_OUTOFMEMORY;
        }

    hr = CoCreateInstance( CLSID_MSAdminBase, 
                           NULL, 
                           CLSCTX_ALL,
                           IID_IMSAdminBase, 
                           (void **)&pIMeta );  
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("CoCreateInstance(): Failed: 0x%x\n",hr);
        #endif
        MemFree(pwsBuffer);
        return hr;
        }

    // Get a handle to the Web service:
    hr = pIMeta->OpenKey( METADATA_MASTER_ROOT_HANDLE, 
                          LOCAL_MACHINE_W3SVC,
                          (METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE),
                          20, 
                          &hMetaBase );

    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("pIMeta->OpenKey(): Failed: 0x%x\n",hr);
        #endif
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    //
    // IIS Filter: FilterLoadOrder
    //
    dwSize = dwBufferSize;
    hr = GetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS,       // See iiscnfg.h
                            MD_FILTER_LOAD_ORDER, // See iiscnfg.h
                            pwsBuffer,
                            &dwSize );
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("GetMetaBaseString(): Failed: 0x%x\n",hr);
        #endif
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }
    else
        {
        if (!wcsstr(pwsBuffer,RPCPROXY))
            {
            // RpcProxy is not in FilterLoadOrder, so add it:
            wcscat(pwsBuffer,TEXT(","));
            wcscat(pwsBuffer,RPCPROXY);
            hr = SetMetaBaseString( pIMeta,
                                 hMetaBase,
                                 MD_KEY_FILTERS,
                                 MD_FILTER_LOAD_ORDER,
                                 pwsBuffer,
                                 0,
                                 IIS_MD_UT_SERVER );
            }

        if (FAILED(hr))
            {
            MemFree(pwsBuffer);
            pIMeta->Release();
            return hr;
            }
        }

    //
    // IIS Filter: RpcProxy/FilterImagePath
    //
    hr = pIMeta->AddKey( hMetaBase, MD_KEY_FILTERS_RPCPROXY );
    if ( (FAILED(hr)) && (hr != 0x800700b7))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    wcscpy(pwsBuffer,pwsSystemRoot);
    wcscat(pwsBuffer,RPCPROXY_PATH);
    wcscat(pwsBuffer,TEXT("\\"));
    wcscat(pwsBuffer,RPCPROXY_DLL);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY,
                            MD_FILTER_IMAGE_PATH,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // IIS Filter: Filters/RpcProxy/KeyType
    //

    wcscpy(pwsBuffer,IISFILTER);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY,
                            MD_KEY_TYPE,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    wcscpy(pwsBuffer,FILTER_DESCRIPTION);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY,
                            MD_FILTER_DESCRIPTION,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_FILTERS_RPCPROXY,
                           MD_FILTER_FLAGS,
                           SF_NOTIFY_ORDER_LOW
                           | SF_NOTIFY_READ_RAW_DATA
                           | SF_NOTIFY_END_OF_NET_SESSION
                           | SF_NOTIFY_PREPROC_HEADERS,
                           0,
                           IIS_MD_UT_SERVER );
    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AccessPerm 
    //
    dwValue = ACCESS_PERM_FLAGS;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_ACCESS_PERM,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Disable entity body preload for this ISAPI
    //

    dwValue = 0;
    
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_UPLOAD_READAHEAD_SIZE,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/Win32Error
    //
    dwValue = 0;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_WIN32_ERROR,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    //
    // Set: /W3Svc/1/ROOT/rpc/DirectroyBrowsing
    //
    dwValue = DIRECTORY_BROWSING_FLAGS;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_DIRECTORY_BROWSING,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        pIMeta->Release();
        CoUninitialize();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/KeyType
    //
    wcscpy(pwsBuffer,IIS_WEB_VIRTUAL_DIR);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_KEY_TYPE,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/VrPath
    //
    wcscpy(pwsBuffer,pwsSystemRoot);
    wcscat(pwsBuffer,RPCPROXY_PATH);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_VR_PATH,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

#if FALSE

    //
    // Set: /W3Svc/1/ROOT/rpc/AppIsolated
    //
    dwValue = 0;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_APP_ISOLATED,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_WAM );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AppRoot
    //
    wcscpy(pwsBuffer,APP_ROOT_PATH);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_APP_ROOT,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AppWamClsid
    //
    wcscpy(pwsBuffer,APP_WAM_CLSID);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_APP_WAM_CLSID,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_WAM );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AppFriendlyName
    //
    wcscpy(pwsBuffer,APP_FRIENDLY_NAME);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_APP_FRIENDLY_NAME,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_WAM );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

#endif

    //
    // Release the handle and buffer:
    //
    MemFree(pwsBuffer);

    pIMeta->CloseKey(hMetaBase);

    pIMeta->Release();

    CoUninitialize();

    return 0;
    }

//---------------------------------------------------------------------
//  CleanupMetaBase()
//
//---------------------------------------------------------------------
HRESULT CleanupMetaBase()
    {
    HRESULT hr = 0;
    DWORD   dwSize = 0;
    WCHAR  *pwsRpcProxy;
    WCHAR  *pws;
    DWORD   dwBufferSize = sizeof(WCHAR) * ORIGINAL_BUFFER_SIZE;
    WCHAR  *pwsBuffer = (WCHAR*)MemAllocate(dwBufferSize);

    // CComPtr <IMSAdminBase> pIMeta;
    IMSAdminBase   *pIMeta;
    METADATA_HANDLE hMetaBase;

    if (!pwsBuffer)
        {
        return ERROR_OUTOFMEMORY;
        }

    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_ALL,
                           IID_IMSAdminBase,
                           (void **)&pIMeta );
    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        return hr;
        }

    //
    // Get a handle to the Web service:
    //
    hr = pIMeta->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                          TEXT("/LM/W3SVC"),
                          (METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE),
                          20,
                          &hMetaBase );
    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Remove the RpcProxy reference from the FilterLoadOrder value:
    //
    dwSize = dwBufferSize;
    hr = GetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS,
                            MD_FILTER_LOAD_ORDER,
                            pwsBuffer,
                            &dwSize );
    if (!FAILED(hr))
        {
        if (pwsRpcProxy=wcsstr(pwsBuffer,RPCPROXY))
            {
            // "RpcProxy" is in FilterLoadOrder, so remove it:

            // Check to see if RpcProxy is at the start of the list:
            if (pwsRpcProxy != pwsBuffer)
                {
                pwsRpcProxy--;  // Want to remove the comma before...
                dwSize = sizeof(RPCPROXY);
                }
            else
                {
                dwSize = sizeof(RPCPROXY) - 1;
                }

            pws = pwsRpcProxy + dwSize;
            memcpy(pwsRpcProxy,pws,sizeof(WCHAR)*(1+wcslen(pws)));
            hr = SetMetaBaseString( pIMeta,
                                    hMetaBase,
                                    MD_KEY_FILTERS,
                                    MD_FILTER_LOAD_ORDER,
                                    pwsBuffer,
                                    0,
                                    IIS_MD_UT_SERVER );
            }
        }


    //
    // Delete: /W3Svc/Filters/RpcProxy
    //
    hr = pIMeta->DeleteKey( hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY );

    //
    // Delete: /W3Svc/1/ROOT/Rpc
    //
    hr = pIMeta->DeleteKey( hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY );

    //
    // Release the handle and buffer:
    //
    MemFree(pwsBuffer);

    pIMeta->CloseKey(hMetaBase);

    pIMeta->Release();

    return S_OK;
    }

//---------------------------------------------------------------------
// DllRegisterServer()
//
// Setup the Registry and MetaBase for the RPC proxy.
//---------------------------------------------------------------------
HRESULT DllRegisterServer()
    {
    HRESULT  hr;
    WORD     wVersion = MAKEWORD(1,1);
    WSADATA  wsaData;

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllRegisterServer(): Start\n");
    #endif

    if (WSAStartup(wVersion,&wsaData))
        {
        return SELFREG_E_CLASS;
        }

    hr = CoInitializeEx(0,COINIT_MULTITHREADED);
    if (FAILED(hr))
        {
        hr = CoInitializeEx(0,COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
            {
            #ifdef DBG_REG
            DbgPrint("RpcProxy: CoInitialize(): Failed: 0x%x\n", hr );
            #endif
            return hr;
            }
        }

    hr = SetupRegistry();
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: SetupRegistry(): Failed: 0x%x (%d)\n",
                 hr, hr );
        #endif
        return hr;
        }

    hr = SetupMetaBase();
    #ifdef DBG_REG
    if (FAILED(hr))
        {
        DbgPrint("RpcProxy: SetupRegistry(): Failed: 0x%x (%d)\n",
                hr, hr );
        }
    #endif

    CoUninitialize();

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllRegisterServer(): End: hr: 0x%x\n",hr);
    #endif

    return hr;
    }

//---------------------------------------------------------------------
// DllUnregisterServer()
//
// Uninstall Registry and MetaBase values used by the RPC proxy.
//
// Modified to mostly return S_Ok, even if a problem occurs. This is 
// done so that the uninstall will complete even if there is a problem
// in the un-register.
//---------------------------------------------------------------------
HRESULT DllUnregisterServer()
    {
    HRESULT  hr;
    WORD     wVersion = MAKEWORD(1,1);
    WSADATA  wsaData;

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllUnregisterServer(): Start\n");
    #endif

    if (WSAStartup(wVersion,&wsaData))
        {
        return SELFREG_E_CLASS;
        }

    hr = CoInitializeEx(0,COINIT_MULTITHREADED);
    if (FAILED(hr))
        {
        hr = CoInitializeEx(0,COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
            {
            #ifdef DBG_REG
            DbgPrint("RpcProxy: CoInitializeEx() Failed: 0x%x\n",hr);
            #endif
            return S_OK;
            }
        }

    hr = CleanupRegistry();
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: CleanupRegistry() Failed: 0x%x (%d)\n",hr,hr);
        #endif
        return S_OK;
        }

    hr = CleanupMetaBase();

    #ifdef DBG_REG
    if (FAILED(hr))
        {
        DbgPrint("RpcProxy: CleanupRegistry() Failed: 0x%x (%d)\n",hr,hr);
        }
    #endif

    CoUninitialize();

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllUnregisterServer(): Start\n");
    #endif

    return S_OK;
    }

#if FALSE
//--------------------------------------------------------------------
// DllMain()
//
//--------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst,
                     ULONG     ulReason,
                     LPVOID    pvReserved )
    {
    BOOL fInitialized = TRUE;

    switch (ulReason)
       {
       case DLL_PROCESS_ATTACH:
          if (!DisableThreadLibraryCalls(hInst))
             {
             fInitialized = FALSE;
             }
          else
             {
             g_hInst = hInst;
             }
          break;

       case DLL_PROCESS_DETACH:
          break;

       case DLL_THREAD_ATTACH:
          // Not used. Disabled.
          break;

       case DLL_THREAD_DETACH:
          // Not used. Disabled.
          break;
       }

    return fInitialized;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\trans\rpcproxy\rpcisapi.c ===
//-----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  rpcisapi.cxx
//
//  IIS ISAPI extension part of the RPC proxy over HTTP.
//
//  Exports:
//
//    BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
//
//      Returns the version of the spec that this server was built with.
//
//    BOOL WINAPI HttpExtensionProc(   EXTENSION_CONTROL_BLOCK *pECB )
//
//      This function does all of the work.
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Includes:
//-----------------------------------------------------------------------------

#include <sysinc.h>
#include <winsock2.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#include <httpfilt.h>
#include <httpext.h>
#include <mbstring.h>
#include "ecblist.h"
#include "filter.h"
#include "olist.h"
#include "server.h"


//-----------------------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------------------

extern SERVER_INFO *g_pServerInfo;
extern BOOL g_fIsIIS6;

//-----------------------------------------------------------------------------
//  GetExtensionVersion()
//
//-----------------------------------------------------------------------------
BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
{
   pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

   ASSERT( sizeof(EXTENSION_DESCRIPTION) <= HSE_MAX_EXT_DLL_NAME_LEN );

   lstrcpy( pVer->lpszExtensionDesc, EXTENSION_DESCRIPTION );

   return TRUE;
}

//-----------------------------------------------------------------------------
//  ReplyToClient()
//
//-----------------------------------------------------------------------------
BOOL ReplyToClient( EXTENSION_CONTROL_BLOCK *pECB,
                    char                    *pBuffer,
                    DWORD                   *pdwSize,
                    DWORD                   *pdwStatus )
{
   DWORD  dwFlags = (HSE_IO_SYNC | HSE_IO_NODELAY);

   if (!pECB->WriteClient(pECB->ConnID,pBuffer,pdwSize,dwFlags))
      {
      *pdwStatus = GetLastError();
      #ifdef DBG_ERROR
      DbgPrint("ReplyToClient(): failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   *pdwStatus = HSE_STATUS_SUCCESS;
   return TRUE;
}

//-----------------------------------------------------------------------------
//  ParseQueryString()
//
//  The query string is in the format:
//
//    <Index_of_pOverlapped>
//
//  Where the index is in ASCII Hex. The index is read and converted back
//  to a DWORD then used to locate the SERVER_OVERLAPPED. If its found,
//  return TRUE, else return FALSE.
//
//  NOTE: "&" is the parameter separator if multiple parameters are passed.
//-----------------------------------------------------------------------------
BOOL ParseQueryString( unsigned char      *pszQuery,
                       SERVER_OVERLAPPED **ppOverlapped,
                       DWORD              *pdwStatus  )
{
   DWORD  dwIndex = 0;

   pszQuery = AnsiHexToDWORD(pszQuery,&dwIndex,pdwStatus);
   if (!pszQuery)
      {
      return FALSE;
      }

   *ppOverlapped = GetOverlapped(dwIndex);
   if (*ppOverlapped == NULL)
      {
      return FALSE;
      }

   return TRUE;
}

//-----------------------------------------------------------------------------
//  HttpExtensionProc()
//
//-----------------------------------------------------------------------------
DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )
{
   DWORD   dwStatus;
   DWORD   dwFlags;
   DWORD   dwSize;
   SERVER_INFO       *pServerInfo = g_pServerInfo;
   SERVER_OVERLAPPED *pOverlapped = NULL;
   HSE_SEND_HEADER_EX_INFO  HeaderEx;
   CHAR    *pVerb;

   pECB->dwHttpStatusCode = STATUS_CONNECTION_OK;

   if (g_fIsIIS6)
   {
      pVerb = RPC_CONNECT;
   }
   else
   {
      pVerb = POST_STR;
   }

   //
   // The RPC request must be a post (or RPC_CONNECT for 6.0):
   //
   if (_mbsicmp(pECB->lpszMethod,pVerb))
      {
      dwSize = sizeof(STATUS_MUST_BE_POST_STR) - 1; // don't want to count trailing 0.

      ReplyToClient(pECB,STATUS_MUST_BE_POST_STR,&dwSize,&dwStatus);
      return HSE_STATUS_SUCCESS;
      }

   //
   // Make sure there is no data from the initial BIND in the ECB data buffer:
   //
   // ASSERT(pECB->cbTotalBytes == 0);

   //
   // Get the connect parameters:
   //
   if (!ParseQueryString(pECB->lpszQueryString,&pOverlapped,&dwStatus))
      {
      dwSize = sizeof(STATUS_POST_BAD_FORMAT_STR) - 1;  // don't want to count trailing 0.

      ReplyToClient(pECB,STATUS_POST_BAD_FORMAT_STR,&dwSize,&dwStatus);
      return HSE_STATUS_SUCCESS;
      }

   pOverlapped->pECB = pECB;

   //
   // Add the new ECB to the Active ECB List:
   //
   if (!AddToECBList(g_pServerInfo->pActiveECBList,pECB))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): AddToECBList() failed\n");
      #endif
      FreeOverlapped(pOverlapped);
      pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;
      return HSE_STATUS_ERROR;
      }

   //
   // Submit the first client async read:
   //
   if (!StartAsyncClientRead(pECB,pOverlapped->pConn,&dwStatus))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): StartAsyncClientRead() failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;
      return HSE_STATUS_ERROR;
      }

   //
   // Post the first server read on the new socket:
   //
   IncrementECBRefCount(pServerInfo->pActiveECBList,pECB);

   if (!SubmitNewRead(pServerInfo,pOverlapped,&dwStatus))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): SubmitNewRead() failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;
      return HSE_STATUS_ERROR;
      }

   //
   // Make sure the server receive thread is up and running:
   //
   if (!CheckStartReceiveThread(g_pServerInfo,&dwStatus))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): CheckStartReceiveThread() failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;
      return HSE_STATUS_ERROR;
      }

   //
   // Send back connection Ok to client, and also set fKeepConn to FALSE.
   //
   dwSize = sizeof(HeaderEx);
   dwFlags = 0;
   memset(&HeaderEx,0,dwSize);
   HeaderEx.fKeepConn = FALSE;
   if (!pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                    &HeaderEx,
                                    &dwSize,
                                    &dwFlags))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): SSF(HSE_REQ_SEND_RESPONSE_HEADER_EX) failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;
      return HSE_STATUS_ERROR;
      }

   return HSE_STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\tools\erec\ebase.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    ebase.c

 Abstract:

    This file generates the error recovery data base.

 Notes:

    1.  Inputs to this module are the extable.* files generated by yacc in
        response to the s switch.
    2.  Take the state vs token index file ( extable.h3 ), and generate the
        state vs token table using the token index to token value
        translations provided by extable.h1
    3.  Take the state vs expected RHS file ( extable.h2 ) and generate a
        data base of expected RHS in every state.

 Author:

    vibhasc 11-15-91

 ----------------------------------------------------------------------------*/

/*****************************************************************************
 local defines and includes
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <malloc.h>
#include <string.h>

#include "ebase.h"

#define STATE_VS_TOKEN_INDEX_FILE   "extable.h3"
#define TOKEN_TRANSLATION_FILE      "extable.h1"
#define STATE_VS_EXPECTED_FILE      "extable.h2"
#define ISVALIDTOKEN( i ) (TRUE)
#define MAX_TRANSLATION_LINE_SIZE (512)

#define TRUE 1
#define FALSE 0
                                   /* from winerror.h */
#define ERROR_INVALID_DATA  13

#define CHECK_FSCAN_STATUS( fscanfcall ) \
    if ( EOF == (fscanfcall) ) \
        { \
            fprintf( stderr, \
                     "\nmidleb : error MIDLEB%d : unexpected end of input stream", \
                     ERROR_INVALID_DATA ); \
            exit( ERROR_INVALID_DATA ); \
        }

typedef unsigned int BOOL;

typedef enum _status
    {

    STATUS_OK   = 0,
    OUT_OF_MEMORY,
    CANT_OPEN_INPUT_FILE,
    CANT_OPEN_OUTPUT_FILE,
    WRONG_ARGUMENT_COUNT

    } STATUS_T;

typedef struct _xlat
    {
    char    *   pIncoming;
    char    *   pTranslated;
    struct _xlat *pNext;
    } XLAT;

typedef struct _DBENTRY
    {
    short   State;
    char *  pTranslated;
    } DBENTRY;

/*****************************************************************************
 global data 
 *****************************************************************************/

FILE                    *   hStateVsTokenIndexFile;
FILE                    *   hStateVsExpectedFile;
FILE                    *   hOutput;
FILE                    *   hXlatFile;
FILE                    *   hTokXlatHdl;
SGOTO                   **  pSGoto;
short                   *   pSGotoCount;
short                   **  pTokVsState;
short                   *   pTokVsStateIndex;
short                       ValidStates;
short                       ValidTokens;
char                    *   pPrefix;
XLAT                    *   pXlat = 0, 
                        *   pXlatCur = 0;
DBENTRY                 *   pDataBase;
short                       NTOKENS;
short                       ACCEPTCODE;
short                   *   TokVal;
short                   *   TokCount;
short                       NSTATES;
short                       MAXTOKVSSTATE;
short                       MAXSTATEVSTOK;
short                       MAXTOKENVALUE;
short                       MAXSTATEVSEXPECTED;

/*****************************************************************************
 external procedures
 *****************************************************************************/

STATUS_T                    Init( char *, char * );
STATUS_T                    Generate( FILE * );
STATUS_T                    OpenFileForReadProcessing( FILE **, char * );
void                        Dump( void );
BOOL                        SearchForStateInTokenVsState( short, short );
void                        TranslateExpectedConstructs( void );
char                    *   Translate( char * );


void
main(
    int argc,
    char *argv[] )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    
    the main routine.

 Arguments:

    Standard

 Return Value:
    
    Exit Status

 Notes:

    Usage : ebase <OutputFilename> <Xlatefile> <prefix> 

    Xlatefile is the file where production names to message translation
    is specified.

    prefix is idl or acf. The expected string array is created with a
    standard name prefixed with the user specified prefix.
----------------------------------------------------------------------------*/
{

    STATUS_T    Status;

    fprintf( stderr, "Error Recovery Data Base Generator\n" );


    if( argc == 4 )
        {

        pPrefix = argv[ 3 ];

        if( (Status = Init( argv[ 1 ], argv[ 2 ] )) == STATUS_OK )
            {
            Status  =   Generate( hStateVsTokenIndexFile );
            }

        Dump();

        TranslateExpectedConstructs();

        }
    else
        {

        fprintf( stderr, "Wrong argument count\n" );
        fprintf( stderr, "Usage : midleb <output file or - > <translation-file-name> <prefix>\n");
        Status = WRONG_ARGUMENT_COUNT;

        }

    exit( Status );

}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Initialize

 Arguments:

    OutputName   : output file name
    XlatFilename : the production/token name to error message translation.

 Return Value:

    STATUS_T    -   OUT_OF_MEMORY or
                -   CANT_OPEN_INPUT_FILE or
                -   STATUS_OK

 Notes:

    Sets up the file handles for all the files that need to be read from

----------------------------------------------------------------------------*/
STATUS_T
Init(
    char * OutputFileName,
    char * XlatFileName )
{
    STATUS_T    Status;
    int         i;

    Status  = OpenFileForReadProcessing(
                                &hStateVsTokenIndexFile,
                                STATE_VS_TOKEN_INDEX_FILE );

    if( Status == STATUS_OK )
        {
        Status  = OpenFileForReadProcessing(
                                    &hStateVsExpectedFile,
                                    STATE_VS_EXPECTED_FILE );

        if( Status == STATUS_OK )
            {
            Status = OpenFileForReadProcessing(
                                    &hTokXlatHdl,
                                    TOKEN_TRANSLATION_FILE );
            if( Status == STATUS_OK )
                {
                Status = OpenFileForReadProcessing( &hXlatFile, XlatFileName );
    
                if( Status == STATUS_OK )
                    {
                    if( strcmp( OutputFileName, "-" ) == 0 )
                        hOutput = stdout;
                    else if( (hOutput = fopen( OutputFileName , "w" )) == (FILE *)0 )
                        {
                        Status = CANT_OPEN_OUTPUT_FILE;
                        };
                    }
                }
            }
        }

    if( Status != STATUS_OK )
        return Status;

    /** read in the required numbers from the TOKEN_TRANSLATION_FILE **/

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, "%hd %hd\n", &NTOKENS, &ACCEPTCODE ) );

    /** read in the token translation table **/

    TokVal = (short *)calloc( 1, NTOKENS * sizeof( short ) );
    TokCount = (short *)calloc( 1, NTOKENS * sizeof( short ) );
        
        if (!TokVal || !TokCount )
            {
            fprintf( stderr, "Out of memory.\n");
            exit(OUT_OF_MEMORY);           
            } 

    for( i = 0;
         i < NTOKENS;
         i++ )
        {
        CHECK_FSCAN_STATUS( 
            fscanf( hTokXlatHdl, "%hd", &TokVal[ i ]) );
        }

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, "\n" ) );

    for( i = 0;
         i < NTOKENS;
         i++ )
        {
        CHECK_FSCAN_STATUS( 
            fscanf( hTokXlatHdl, "%hd", &TokCount[ i ]) );
        }

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, "\n" ) );

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, 
                "%hd %hd %hd %hd %hd\n", 
                &NSTATES, 
                &MAXTOKVSSTATE, 
                &MAXSTATEVSTOK, 
                &MAXTOKENVALUE, 
                &MAXSTATEVSEXPECTED ) ); 

    /** allocate memory now **/

    pSGoto  = (SGOTO **) calloc( 1,NSTATES * sizeof( SGOTO * ) );

    pSGotoCount = (short *)calloc(1, NSTATES * sizeof( short ) );

    pTokVsState = (short **)calloc( 1,(MAXTOKENVALUE+1) * sizeof( short * ) );

    pTokVsStateIndex = (short *)calloc(1, (MAXTOKENVALUE+1) * sizeof( short ) );

    pDataBase = ( DBENTRY * )calloc( 1, MAXSTATEVSEXPECTED * sizeof( DBENTRY ) );


        if( !pSGoto || !pSGotoCount || !pTokVsState || !pTokVsStateIndex || !pDataBase )
            {
            fprintf( stderr, "Out of memory.\n");
            exit(OUT_OF_MEMORY);
            }

    return Status;
}


STATUS_T
Generate(
    FILE    *   hSVsTIndexFile )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    
    Generate the state vs token table, given the state vs token index table
    in extable.h3 and token vs token index translation of extable.h1.

 Arguments:

    hStateVsTokenIndexFile  -   handle to the file which has the state vs
                                token index info.

 Return Value:

    None.

 Notes:

    The state vs token index file has the goto info for every valid token,
    For every state, this file contains the goto ( or none ) for every valid
    token ( represented by the token index ). Thus for each state, we lookup 
    to see if the state has a goto for a given token index. If it does, then 
    we translate the token index into a token value, and mark the goto for the
    state for that token in the state vs token table. 

    In the end we will have a very sparse array, which contains all the states
    and the gotos for the state for each token ( or the absence of any goto ).

    We will use this table to generate two tables:

        1. The set of all states which have a goto on a token
        2. The set of all tokens valid for any state.

    The exception to this rule is the accept action which is treated like
    an absence of goto.
----------------------------------------------------------------------------*/
    {
    
    short    iState,i,j,Temp,SGotoCount;
    SGOTO   *p;

    /** fixup pointers to token vs state pointer array **/

    for( i = 0;
         i < NTOKENS;
         i++ )
        {

        if( TokCount[ i ] )
            {
            j = TokVal[ i ];

            if( ISVALIDTOKEN( j ) )
                            {
                pTokVsState[ j ] = calloc( 1, TokCount[ i ] * sizeof( short ) );
                            
                            if (!pTokVsState[ j ])
                                {
                                fprintf( stderr, "Out of memory.\n" );
                                exit( OUT_OF_MEMORY );
                                }
                            }
            }

        }

    for( iState = 0;
         iState < NSTATES;
         ++iState )
        {

        /** ignore the state number */

        CHECK_FSCAN_STATUS( 
            fscanf( hSVsTIndexFile,
                    "%hd %c",
                    &Temp,
                    &Temp ) );

        /** get the count of number of state goto entries **/

        CHECK_FSCAN_STATUS( 
            fscanf( hSVsTIndexFile,
                    "%hd %c",
                    &SGotoCount,
                    &Temp ) );

        /** now read in the goto vs token pairs **/


        if( SGotoCount )
            {

            p = pSGoto[ iState ] = calloc( 1, SGotoCount * sizeof( SGOTO ) );

                        if (!p) 
                            {
                            fprintf( stderr, "Out of memory.\n" );
                            exit( OUT_OF_MEMORY );
                            }

            for( j = 0;
                j < SGotoCount;
                ++j )
                {

                CHECK_FSCAN_STATUS( 
                    fscanf( hSVsTIndexFile,
                            "%hd%c %hd",
                            &p->Goto,
                            &Temp,
                            &p->Token ) );

                Temp = TokVal[ p->Token ];

                if( ISVALIDTOKEN( Temp ) )
                    {
                    if( !SearchForStateInTokenVsState( Temp, p->Goto ) )
                        {
                        i = pTokVsStateIndex[ Temp ];
                        pTokVsStateIndex[ Temp ]++;

                        *(pTokVsState[Temp] +  i )  = p->Goto;
                        }
                    p++;
                    pSGotoCount[ iState ]++;

                    }
                }

            }


        }
    return STATUS_OK;
    }

STATUS_T
OpenFileForReadProcessing(
    FILE    **  pHandle,
    char    *   pName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This process opens a file for read processing, reports an error if
    the file could not be opened.

 Arguments:

    pHandle     -   pointer to a file handle deposition area.
    pName       -   pointer to a file name, null terminated.

 Return Value:

    STATUS_T    -   STATUS_OK if all is well.
                -   CANT_OPEN_INPUT_FILE otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
    FILE    *hF;

    if( ( hF = fopen( pName, "r" ) ) == (FILE *)NULL )
        {
        fprintf( stderr, "Cannot open input file : %s\n", pName );
        return CANT_OPEN_INPUT_FILE;
        }
    *pHandle = hF;
    return STATUS_OK;
}


void
Dump( void )
    {
    SGOTO   *   p;
    short       iTemp, i,j;

    /** dump the state goto table **/

    for( iTemp = 0, ValidStates = 0;
         iTemp < NSTATES;
         ++iTemp )
        {

        p = pSGoto[ iTemp ];

        if( j = pSGotoCount[ iTemp ] )
            {
            fprintf( hOutput, "\n SGOTO _sG%s%.4hd [ %d ] = {  ", pPrefix, iTemp, j );

            for( i = 0;
                i < j;
                i++ )
                {

                fprintf(  hOutput
                        , " {%hd, %hd} %c"
                        , p[ i ].Goto
                        , TokVal[ p[ i ].Token]
                        , ( (i+1 == j) ? ' ' : ',' ));
    
                }

            fprintf( hOutput, "};" );

            ValidStates++;
            }
        }


    /** now dump the array of pointers to this **/

    fprintf( hOutput, "\n\n#define VALIDSTATES_%s %d\n", pPrefix, ValidStates );

    fprintf( hOutput, "\n\nSGOTOVECTOR  SGoto%s[ VALIDSTATES_%s ] = {\n",pPrefix, pPrefix);

    for( i = 0;
         i < NSTATES;
         ++i )
        {
        if( pSGotoCount[ i ] )
            {
            fprintf( hOutput, "\n{ %d, _sG%s%.4hd, %d }"
                    , i
                    ,pPrefix
                    , i
                    , pSGotoCount[ i ] );
            fprintf( hOutput,"%c", ((i + 1 == NSTATES) ? ' ' : ',' ));
            }

        }

    fprintf( hOutput, "\n};\n\n" );

    /** count the valid token entries. i.e tokens for which states exist **/

fprintf(hOutput, "#if 0\n");

    for( ValidTokens = 0, i = 0;
         i < MAXTOKENVALUE;
         ++i )
         {

         if( pTokVsStateIndex[ i ] )
            ValidTokens++;
         }

    /** dump the token vs state table **/

    for( iTemp = 0;
         iTemp < NTOKENS;
         ++iTemp )
         {


         if( j = pTokVsStateIndex[ TokVal[ iTemp ] ] )
            {

            fprintf( hOutput, "short _tS%s%.4d[ %d ] = {", pPrefix, TokVal[ iTemp ], j );

            for( i = 0;
                 i < j;
                 ++i )
                {

                fprintf( hOutput, " %d %c", *(pTokVsState[ TokVal[ iTemp ] ]+i),
                         (( i