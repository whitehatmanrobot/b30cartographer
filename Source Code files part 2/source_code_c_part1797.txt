ve;
    BOOLEAN wasEnabled;

    //
    //  1. Open the Current user key.
    //
    if (RegOpenKeyEx( hSourceRegKey,
                      srcKey,
                      0,
                      KEY_READ,
                      &hRegKey ) != ERROR_SUCCESS)
    {
        return;
    }

    //
    //  2. Load the hive to a temporary key location.
    //
    if ((hHive = Intl_LoadNtUserHive( TEXT("TempKey"),
                                      destKey,
                                      &wasEnabled )) == NULL)
    {
        RegCloseKey(hRegKey);
        return;
    }

    //
    //  3. Delete .Default key values.
    //
    Intl_DeleteRegKeyValues(hHive);

    //
    //  4. Delete .Default subkeys.
    //
    Intl_DeleteRegSubKeys(hHive);

    //
    //  5. Copy tree.
    //
    Intl_CreateRegTree(hRegKey, hHive);

    //
    //  6. Clean up.
    //
    RegCloseKey(hHive);
    Intl_UnloadNtUserHive(TEXT("TempKey"), &wasEnabled);
    RegCloseKey(hRegKey);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_IsSetupMode
//
//  Look into the registry if we are currently in setup mode.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_IsSetupMode()
{
    HKEY hKey;
    DWORD fSystemSetupInProgress = 0;
    DWORD cbData = 0;

    //
    //  Open the registry key used by setup
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szSetupKey,
                      0,
                      KEY_READ,
                      &hKey ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Query for the value indicating that we are in setup.
    //
    cbData = sizeof(fSystemSetupInProgress);
    if (RegQueryValueEx( hKey,
                         szSetupInProgress,
                         NULL,
                         NULL,
                         (LPBYTE)&fSystemSetupInProgress,
                         &cbData ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (FALSE);
    }

    //
    //  Clean up
    //
    RegCloseKey(hKey);

    //
    //  Check the value
    //
    if (fSystemSetupInProgress)
    {
        //
        //  In setup mode...
        //
        if (g_bLog)
        {
            Intl_LogSimpleMessage(IDS_LOG_SETUP_MODE, NULL);
        }

        return (TRUE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_IsWinntUpgrade
//
//  Look into the registry if we are currently in winnt upgrade.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_IsWinntUpgrade()
{
    HKEY hKey;
    DWORD fUpgradeInProgress = 0;
    DWORD cbData = 0;

    //
    //  Verify that we're in setup first.
    //
    if (!g_bSetupCase)
    {
        return (FALSE);
    }

    //
    //  Open the registry key used by setup.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szSetupKey,
                      0,
                      KEY_READ,
                      &hKey ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Query for the value indicating that we are in setup.
    //
    cbData = sizeof(fUpgradeInProgress);
    if (RegQueryValueEx( hKey,
                         szSetupUpgrade,
                         NULL,
                         NULL,
                         (LPBYTE)&fUpgradeInProgress,
                         &cbData ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (FALSE);
    }

    //
    //  Clean up.
    //
    RegCloseKey(hKey);

    //
    //  Check the value.
    //
    if (fUpgradeInProgress)
    {
        //
        //  Upgrade scenario.
        //
        if (g_bLog)
        {
            Intl_LogSimpleMessage(IDS_LOG_UPGRADE_SCENARIO, NULL);
        }

        return (TRUE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_IsUIFontSubstitute
//
//  Look into the registry if we need to substitute the font.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_IsUIFontSubstitute()
{
    HKEY hKey;
    DWORD fUIFontSubstitute = 0;
    DWORD cbData = 0;

    //
    //  Command line call, no need to check registry
    //
    if (g_bMatchUIFont)
    {
        return (TRUE);
    }

    //
    //  Open the registry key used MUI font substitution.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szMUILanguages,
                      0,
                      KEY_READ,
                      &hKey ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Query for the value indicating that we need to apply font
    //  substitution.
    //
    cbData = sizeof(fUIFontSubstitute);
    if (RegQueryValueEx( hKey,
                         szUIFontSubstitute,
                         NULL,
                         NULL,
                         (LPBYTE)&fUIFontSubstitute,
                         &cbData ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (FALSE);
    }

    //
    //  Clean up.
    //
    RegCloseKey(hKey);

    //
    //  Check the value.
    //
    if (fUIFontSubstitute)
    {
        //
        //  Upgrade scenario.
        //
        if (g_bLog)
        {
            Intl_LogSimpleMessage(IDS_LOG_FONT_SUBSTITUTE, NULL);
        }

        return (TRUE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_ApplyFontSubstitute
//
//  Search into the intl.inf file to see of the SystemLocale need font
//  substitution.
//
////////////////////////////////////////////////////////////////////////////
VOID Intl_ApplyFontSubstitute(LCID SystemLocale)
{
    HINF hIntlInf;
    TCHAR szLCID[25];
    INFCONTEXT Context;
    TCHAR szFont[MAX_PATH] = {0};
    TCHAR szFontSubst[MAX_PATH] = {0};
    HKEY hKey;
    
    //
    //  Open the Intl.inf file.
    //
    if (Intl_OpenIntlInfFile(&hIntlInf))
    {
        //
        //  Get the locale.
        //
        wsprintf(szLCID, TEXT("%08x"), SystemLocale);

        //
        //  Look for the Font Substitute section.
        //
        if (SetupFindFirstLine( hIntlInf,
                                szFontSubstitute,
                                szLCID,
                                &Context ))
        {
            //
            //  Look for the Font and Font Substitute
            //
            if (!SetupGetStringField( &Context,
                                      1,
                                      szFont,
                                      MAX_PATH,
                                      NULL ) ||
                !SetupGetStringField( &Context,
                                      2,
                                      szFontSubst,
                                      MAX_PATH,
                                      NULL ))
            {
                //
                //  Clean up.
                //
                Intl_CloseInfFile(hIntlInf);
                return;
            }
        }
        else
        {
            //
            //  Nothing to do for this specific locale. Clean up.
            //
            Intl_CloseInfFile(hIntlInf);
            return;
        }
    }
    else
    {
        return;
    }

    //
    //  Close the Intl.inf file
    //
    Intl_CloseInfFile(hIntlInf);

    //
    //  Proceed with the font replacement.
    //
    if (szFont[0] && szFontSubst[0])
    {
        //
        //  Open the Font Substitute registry key.
        //
        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          c_szFontSubstitute,
                          0L,
                          KEY_READ | KEY_WRITE,
                          &hKey ) == ERROR_SUCCESS)
        {
            //
            //  Set the Font value with the Font Substitute.
            //
            RegSetValueEx( hKey,
                           szFont,
                           0L,
                           REG_SZ,
                           (LPBYTE)szFontSubst,
                           (lstrlen(szFontSubst) + 1) * sizeof(TCHAR) );
            RegCloseKey(hKey);
        }
    }
}
////////////////////////////////////////////////////////////////////////////
//
//  Intl_OpenLogFile
//
//  Opens the Region and Languages Options log for writing.
//
////////////////////////////////////////////////////////////////////////////

HANDLE Intl_OpenLogFile()
{
    DWORD dwSize;
    DWORD dwUnicodeHeader;
    HANDLE hFile;
    SECURITY_ATTRIBUTES SecurityAttributes;
    TCHAR lpPath[MAX_PATH];

    GetWindowsDirectory(lpPath, MAX_PATH);
    _tcscat(lpPath, TEXT("\\regopt.log"));

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = FALSE;

    hFile = CreateFile( lpPath,
                        GENERIC_WRITE,
                        0,
                        &SecurityAttributes,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

#ifdef UNICODE
    //
    //  If the file did not already exist, add the unicode header.
    //
    if (GetLastError() == 0)
    {
        dwUnicodeHeader = 0xFEFF;
        WriteFile(hFile, &dwUnicodeHeader, 2, &dwSize, NULL);
    }
#endif

    return (hFile);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LogMessage
//
//  Writes lpMessage to the Region and Languages Options log.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_LogMessage(
    LPCTSTR lpMessage)
{
    DWORD dwBytesWritten;
    HANDLE hFile;

    if (!g_bLog)
    {
        return (FALSE);
    }

    if (lpMessage == NULL)
    {
        return (TRUE);
    }

    hFile = Intl_OpenLogFile();

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile( hFile,
               lpMessage,
               _tcslen(lpMessage) * sizeof(TCHAR),
               &dwBytesWritten,
               NULL );

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile( hFile,
               TEXT("\r\n"),
               _tcslen(TEXT("\r\n")) * sizeof(TCHAR),
               &dwBytesWritten,
               NULL );

    CloseHandle(hFile);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LogUnattendFile
//
//  Writes the unattended mode file to the setup log.
//
////////////////////////////////////////////////////////////////////////////

void Intl_LogUnattendFile(
    LPCTSTR pFileName)
{
    DWORD dwSize;
    HANDLE hFile;
    OFSTRUCT fileInfo;
    BOOL bResult;
    CHAR inBuffer[MAX_PATH] = {0};
    DWORD nBytesRead;
    WCHAR outBufferW[MAX_PATH] = {0};
    int nWCharRead;
    DWORD status;

    //
    //  Open the unattended mode file.
    //
    if ((hFile = CreateFile( pFileName,
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL )) == INVALID_HANDLE_VALUE)
    {
        return;
    }

    //
    //  Write the header.
    //
    Intl_LogSimpleMessage(IDS_LOG_UNAT_HEADER, NULL);

    //
    //  Read the unattended mode file in 259 byte chunks.
    //
    while (bResult = ReadFile( hFile,
                               (LPVOID)&inBuffer,
                               MAX_PATH - 1,
                               &nBytesRead,
                               NULL ) && (nBytesRead > 0))
    {
        //
        //  Null terminated string.
        //
        inBuffer[nBytesRead] = '\0';

        //
        //  Convert the ansi data to unicode.
        //
        nWCharRead = MultiByteToWideChar( CP_ACP,
                                           MB_PRECOMPOSED,
                                           inBuffer,
                                           nBytesRead,
                                           outBufferW,
                                           MAX_PATH );

        //
        //  Write to the log file.
        //
        if (nWCharRead)
        {
            Intl_LogMessage((LPCTSTR)outBufferW);
        }
    }

    //
    //  Write the footer.
    //
    Intl_LogSimpleMessage(IDS_LOG_UNAT_FOOTER, NULL);

    //
    //  Cleanup.
    //
    CloseHandle(hFile);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LogSimpleMessage
//
//  Writes a simple message to the log file.
//
////////////////////////////////////////////////////////////////////////////

void Intl_LogSimpleMessage(
    UINT LogId,
    LPCTSTR pAppend)
{
    TCHAR szLogBuffer[4 * MAX_PATH];

    LoadString(hInstance, LogId, szLogBuffer, ARRAYSIZE(szLogBuffer) - 1);
    if (pAppend)
    {
        _tcscat(szLogBuffer, pAppend);
    }
    Intl_LogMessage(szLogBuffer);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LogFormatMessage
//
//  Writes an error message using FormatMessage to the log file.
//
////////////////////////////////////////////////////////////////////////////

void Intl_LogFormatMessage(
    UINT LogId)
{
    LPVOID lpMsgBuf = NULL;
    TCHAR szLogBuffer[4 * MAX_PATH];

    //
    //  Get the message for the last error.
    //
    FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_FROM_SYSTEM |
                     FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL,
                   GetLastError(),
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                   (LPTSTR) &lpMsgBuf,
                   0,
                   NULL );

    //
    //  Load the log message.
    //
    LoadString( hInstance,
                LogId,
                szLogBuffer,
                ARRAYSIZE(szLogBuffer) - 1 );

    //
    //  Concatenate the log message and the last error.
    //
    _tcscat(szLogBuffer, lpMsgBuf);

    //
    //  Log the message to the log file.
    //
    Intl_LogMessage(szLogBuffer);

    //
    //  Free the buffer created by FormatMessage.
    //
    if (lpMsgBuf)
    {
        LocalFree(lpMsgBuf);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_SaveDefaultUserSettings
//
//  This function will get information from the the current user and write it in
//  the .DEFAULT and NTUSER.DAT file.
//
////////////////////////////////////////////////////////////////////////////

void Intl_SaveDefaultUserSettings()
{
    //
    //  Check if the Default user settings have been saved already.
    //
    if (g_bSettingsChanged)
    {
        DWORD dwDisposition;
        HKEY hDesKey, hSrcKey;

        //
        //  Set the UI Language for ALL new users of this machine.
        //
        Intl_ChangeUILangForAllUsers(Intl_GetPendingUILanguage());

        //
        //  Copy the International keys and subkeys.
        //
        Intl_SaveValuesToDefault(c_szCPanelIntl, c_szCPanelIntl_DefUser);
        Intl_SaveValuesToNtUserFile(HKEY_CURRENT_USER, c_szCPanelIntl, c_szCPanelIntl);

        //
        //  Copy only the CTFMON information.
        //
        if(RegOpenKeyEx( HKEY_CURRENT_USER,
                         c_szCtfmon,
                         0,
                         KEY_ALL_ACCESS,
                         &hSrcKey) == ERROR_SUCCESS)
        {
            if(RegOpenKeyEx( HKEY_USERS,
                             c_szCtfmon_DefUser,
                             0,
                             KEY_ALL_ACCESS,
                             &hDesKey) == ERROR_SUCCESS)
            {
                DWORD dwValueLength, dwType;
                TCHAR szValue[REGSTR_MAX_VALUE_LENGTH];
             
                //
                //  Get the source value if exist.
                //
                szValue[0] = 0;
                dwValueLength = sizeof(szValue);
                if(RegQueryValueEx( hSrcKey,
                                    szCtfmonValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szValue,
                                    &dwValueLength) == ERROR_SUCCESS)
                {

                    //
                    //  Set the destination value.
                    //
                    RegSetValueEx( hDesKey,
                                   szCtfmonValue,
                                   0L,
                                   dwType,
                                   (CONST BYTE *)szValue,
                                   dwValueLength);
                }
                CloseHandle(hDesKey);
            }
            
            CloseHandle(hSrcKey);
        }
        Intl_SaveValuesToNtUserFile(HKEY_CURRENT_USER, c_szCtfmon, c_szCtfmon);

        //
        //  Copy the Keyboard Layouts keys and subkeys.
        //
        Intl_SaveValuesToDefault(c_szKbdLayouts, c_szKbdLayouts_DefUser);
        Intl_SaveValuesToNtUserFile(HKEY_CURRENT_USER, c_szKbdLayouts, c_szKbdLayouts);

        //
        //  Copy the Input Method keys and subkeys.
        //
        Intl_SaveValuesToDefault(c_szInputMethod, c_szInputMethod_DefUser);
        Intl_SaveValuesToNtUserFile(HKEY_CURRENT_USER, c_szInputMethod, c_szInputMethod);

        //
        //  Copy the Tips keys and subkeys. Make sure that the CTF 
        //  destination key exist.
        //
        if (RegCreateKeyEx( HKEY_USERS,
                            c_szInputTips_DefUser,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDesKey,
                            &dwDisposition ) == ERROR_SUCCESS)
        {
            CloseHandle(hDesKey);
            Intl_SaveValuesToDefault(c_szInputTips, c_szInputTips_DefUser);
            Intl_SaveValuesToNtUserFile(HKEY_CURRENT_USER, c_szInputTips, c_szInputTips);
        }

        //
        //  Settings saved.
        //
        g_bSettingsChanged = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_SaveDefaultUserInputSettings
//
//  This function copy .Default user input-related setting to ntuser.dat.
//  There are four things to copy to make keyboard layout work for
//  new users:
//      * "Software\\Microsoft\\Windows\\CurrentVersion\\Run\\ctfmon.exe" (if any)
//      * "Keyboard Layout"
//      * "Control Panel\\Input Method"
//      * "Software\\Microsoft\\CTF"    (if any)
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_SaveDefaultUserInputSettings() 
{
    HKEY hDesKey;
    DWORD dwDisposition;

    //
    // The following call will copy everything under Windows\CurrentVersion\Run
    // to ntuser.dat.
    //
    Intl_SaveValuesToNtUserFile(HKEY_USERS, c_szCtfmon_DefUser, c_szCtfmon);

    //
    //  Copy the Keyboard Layouts keys and subkeys.
    //
    Intl_SaveValuesToNtUserFile(HKEY_USERS, c_szKbdLayouts_DefUser, c_szKbdLayouts);

    //
    //  Copy the Input Method keys and subkeys.
    //
    Intl_SaveValuesToNtUserFile(HKEY_USERS, c_szInputMethod_DefUser, c_szInputMethod);

    //
    //  Copy the Tips keys and subkeys. Make sure that the CTF 
    //  destination key exist.
    //
    if (RegCreateKeyEx( HKEY_USERS,
                        c_szInputTips_DefUser,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hDesKey,
                        &dwDisposition ) == ERROR_SUCCESS)
    {
        CloseHandle(hDesKey);
        Intl_SaveValuesToNtUserFile(HKEY_USERS, c_szInputTips_DefUser, c_szInputTips);
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_IsMUIFileVersionSameAsOS
//
////////////////////////////////////////////////////////////////////////////

#define MUISETUP_EXE_RELATIVE_PATH  TEXT("mui\\muisetup.exe")
#define MUISETUP_INF_RELATIVE_PATH  TEXT("mui\\mui.inf")

BOOL Intl_IsMUISetupVersionSameAsOS()
{
    BOOL bSpUpgrade = FALSE;
    DWORD dwDummy = 0;
    DWORD dwBufSize = 0;
    UINT uiLen = 0;
    BYTE *pbBuffer = NULL;
    VS_FIXEDFILEINFO *pvsFileInfo;
    BOOL bResult = TRUE;
    TCHAR tempmsg[MAX_PATH];    
    TCHAR build[MAX_PATH];
    TCHAR szAppPath[MAX_PATH];
    TCHAR szInfPath[MAX_PATH];

    GetSystemWindowsDirectory(szAppPath, ARRAYSIZE(szAppPath));
    GetSystemWindowsDirectory(szInfPath, ARRAYSIZE(szInfPath));
    
    //
    //  Invoke muisetup to uninstall MUI languages.
    //
    if ((PathAppend(szAppPath, MUISETUP_EXE_RELATIVE_PATH) && Intl_FileExists(szAppPath)) && 
        (PathAppend(szInfPath, MUISETUP_INF_RELATIVE_PATH) && Intl_FileExists(szInfPath)))
    {
        dwBufSize = GetFileVersionInfoSize(szAppPath, &dwDummy);
        if (dwBufSize > 0)
        {
            // allocate enough buffer to store the file version info
            pbBuffer = (BYTE*) LocalAlloc(LPTR, dwBufSize+1);
            if (NULL == pbBuffer)
            {
                goto Exit;
            }
            else
            {
                // Get the file version info
                if (!GetFileVersionInfo(szAppPath, dwDummy, dwBufSize, pbBuffer))
                {
                    goto Exit;
                }
                else
                {
                    // get the version from the file version info using VerQueryValue
                    if (!VerQueryValue(pbBuffer, TEXT("\\"), (LPVOID *) &pvsFileInfo, &uiLen))
                    {
                        goto Exit;
                    }            
                }
            }        
        }
        else
        {
            goto Exit;
        }

        // read the mui.inf version from mui.inf
        GetPrivateProfileString( TEXT("Buildnumber"),
                                 NULL,
                                 TEXT("0"),
                                 tempmsg,
                                 ARRAYSIZE(tempmsg),
                                 szInfPath);
        
        wsprintf(build, TEXT("%d"), HIWORD(pvsFileInfo->dwFileVersionLS));

        if (_tcscmp(tempmsg, build))
        {
            bSpUpgrade = FALSE;   
        }
        else
        {
            bSpUpgrade = TRUE;
        }
    }

   
Exit:
    if (pbBuffer)
    {
        LocalFree(pbBuffer);        
    }
    return bSpUpgrade;
    
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_IsLIP
//
////////////////////////////////////////////////////////////////////////////
BOOL Intl_IsLIP()
{
    BOOL bResult = TRUE;
    UINT iLangCount = 0;
    HKEY hKey;
    TCHAR szValue[MAX_PATH];
    TCHAR szData[MAX_PATH];
    DWORD dwIndex, cchValue, cbData;
    DWORD UILang;
    DWORD dwType;
    LONG rc;

    //
    //  First check for the LIP System Key, if it is there, then we are done
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szLIPInstalled,
                      0,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (TRUE);
    }
    
    //
    //  if not found, then open the registry key used MUI to doublecheck
    //  for LIP enabled system
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szMUILanguages,
                      0,
                      KEY_READ,
                      &hKey ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Enumerate the values in the MUILanguages key.
    //
    dwIndex = 0;
    cchValue = sizeof(szValue) / sizeof(TCHAR);
    szValue[0] = TEXT('\0');
    cbData = sizeof(szData);
    szData[0] = TEXT('\0');
    rc = RegEnumValue( hKey,
                       dwIndex,
                       szValue,
                       &cchValue,
                       NULL,
                       &dwType,
                       (LPBYTE)szData,
                       &cbData );

    while (rc == ERROR_SUCCESS)
    {
        //
        //  If the UI language contains data, then it is installed.
        //
        if ((szData[0] != 0) &&
            (dwType == REG_SZ) &&
            (UILang = TransNum(szValue)) &&
            (GetLocaleInfo(UILang, LOCALE_SNATIVELANGNAME, szData, MAX_PATH)) &&
            (IsValidUILanguage((LANGID)UILang)))
        {
            //
            //  if English 0409 key is found, we have a MUI system and not LIP
            //
            if (UILang == 0x0409)
            {
                bResult = FALSE;
                break;
            }

            //
            // If there are more than one language installed, or then it is 
            // also not a LIP system - this can be 0409 + any other language also.
            //
            iLangCount= iLangCount + 1;
            if (iLangCount > 1)
            {
                bResult = FALSE;	        
                break;
            }
        }

        //
        //  Get the next enum value.
        //
        dwIndex++;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        cbData = sizeof(szData);
        szData[0] = TEXT('\0');
        rc = RegEnumValue( hKey,
                           dwIndex,
                           szValue,
                           &cchValue,
                           NULL,
                           &dwType,
                           (LPBYTE)szData,
                           &cbData );
    }
    //
    //  Clean up.
    //
    RegCloseKey(hKey);

    return bResult;
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_RemoveMUIFile
//
////////////////////////////////////////////////////////////////////////////

void Intl_RemoveMUIFile()
{
    TCHAR szAppPath[MAX_PATH];

    GetSystemWindowsDirectory(szAppPath, ARRAYSIZE(szAppPath));

    //
    //  Invoke muisetup to uninstall MUI languages.
    //
    if (PathAppend(szAppPath, MUISETUP_EXE_RELATIVE_PATH) &&
        Intl_FileExists(szAppPath))
    {
        //
        // Only remove MUI if we are not in an SP OS upgrade scenario
        //
        if (!Intl_IsMUISetupVersionSameAsOS() && !Intl_IsLIP())
        {
            SHELLEXECUTEINFO ExecInfo = {0};
            //
            // Don't delete muisetup.exe, this code is only for xpsp
            //
            /*
            SHFILEOPSTRUCT shFile =
            {
                NULL, FO_DELETE, szAppPath, NULL, FOF_NOCONFIRMATION|FOF_SILENT|FOF_NOERRORUI, 0, 0, 0
            };
            */

            ExecInfo.lpParameters    = TEXT("/u /r /s");
            ExecInfo.fMask           = SEE_MASK_FLAG_NO_UI;
            ExecInfo.lpFile          = szAppPath;
            ExecInfo.nShow           = SW_SHOWNORMAL;
            ExecInfo.cbSize          = sizeof(SHELLEXECUTEINFO);

            ShellExecuteEx(&ExecInfo);

            /*
            //
            //  An additional NULL character must be appended for this
            //  multi-string buffer.
            //
            szAppPath[lstrlen(szAppPath) + 1] = 0x00;

            SHFileOperation(&shFile);
            */
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_CallTextServices
//
////////////////////////////////////////////////////////////////////////////

void Intl_CallTextServices()
{
    TCHAR szAppPath[MAX_PATH];

    GetSystemDirectory(szAppPath, ARRAYSIZE(szAppPath));

    //
    //  Invoke the Input applet.
    //
    if (PathAppend(szAppPath, TEXT("rundll32.exe")) &&
        Intl_FileExists(szAppPath))
    {
        SHELLEXECUTEINFO ExecInfo = {0};

        ExecInfo.lpParameters    = TEXT("shell32.dll,Control_RunDLL input.dll");
        ExecInfo.lpFile          = szAppPath;
        ExecInfo.nShow           = SW_SHOWNORMAL;
        ExecInfo.cbSize          = sizeof(SHELLEXECUTEINFO);

        ShellExecuteEx(&ExecInfo);
    }
}




////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetPendingUILanguage
//
//  Look into the registry for the pending UI Language.  This function is
//  used for the default user case.
//
////////////////////////////////////////////////////////////////////////////

LANGID Intl_GetPendingUILanguage()
{
    HKEY hKey;
    LANGID dwDefaultUILanguage = 0;
    DWORD cbData = 0;
    TCHAR szBuffer[MAX_PATH];

    //
    //  Open the registry key used by setup.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szCPanelDesktop,
                      0,
                      KEY_READ,
                      &hKey ) != ERROR_SUCCESS)
    {
        return (GetUserDefaultUILanguage());
    }

    //
    //  Query the pending MUI Language.
    //
    cbData = ARRAYSIZE(szBuffer);
    if (RegQueryValueEx( hKey,
                         szMUILangPending,
                         NULL,
                         NULL,
                         (LPBYTE)szBuffer,
                         &cbData ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (GetUserDefaultUILanguage());
    }
    else
    {
        if ((dwDefaultUILanguage = (LANGID)TransNum(szBuffer)) == 0)
        {
            RegCloseKey(hKey);
            return (GetUserDefaultUILanguage());
        }
        else
        {
            RegCloseKey(hKey);
            return ((LANGID)dwDefaultUILanguage);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GetDotDefaultUILanguage
//
//  Retrieve the UI language stored in the HKCU\.Default.
//  This is the default UI language for new users.
//
////////////////////////////////////////////////////////////////////////////////////

LANGID Intl_GetDotDefaultUILanguage()
{
    HKEY hKey;
    DWORD dwKeyType;
    DWORD dwSize;
    BOOL success = FALSE;
    TCHAR szBuffer[MAX_PATH];
    LANGID langID;
    
    //
    //  Get the value in .DEFAULT.
    //
    if (RegOpenKeyEx( HKEY_USERS,
                      c_szCPanelDesktop_DefUser,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szBuffer) * sizeof(TCHAR);
        if (RegQueryValueEx( hKey,
                             c_szMUIValue,
                             0L,
                             &dwKeyType,
                             (LPBYTE)szBuffer,
                             &dwSize) == ERROR_SUCCESS)
        {
            if (dwKeyType == REG_SZ)
            {
                langID = (LANGID)_tcstol(szBuffer, NULL, 16);
                success = TRUE;
            }            
        }
        RegCloseKey(hKey);
    }

    if (!success)
    {
        return (GetUserDefaultUILanguage());
    }
    return (langID);    
}

////////////////////////////////////////////////////////////////////////////
//
//  Set the specified control to be left-to-right or right-to-left reading order.
// 
//  bUseRightToLeft==FALSE: Use left-to-right reading order
//  bUseRightToLeft==TRUE: Use right-to-left reading order
//
////////////////////////////////////////////////////////////////////////////

void SetControlReadingOrder(BOOL bUseRightToLeft, HWND hwnd) 
{
    BOOL bCurrentRTL;
    if (IsRtLLocale(GetUserDefaultUILanguage()))
    {
        // If the current UI langauge is RTL, the dailog is already localized as RTL.
        // In this case, don't change the direction of the control.
        return;
    }
    bCurrentRTL = (GetWindowLongPtr(hwnd, GWL_EXSTYLE) & (WS_EX_RTLREADING)) != 0;

    if (bCurrentRTL != bUseRightToLeft) 
    {
        // Reverse the WS_EX_RTLREADING and WS_EX_RIGHT bit.
        SetWindowLongPtr(hwnd, GWL_EXSTYLE, GetWindowLongPtr(hwnd, GWL_EXSTYLE) ^ (WS_EX_RTLREADING | WS_EX_RIGHT));
        InvalidateRect(hwnd, NULL, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\cplext.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    cplext.h

Abstract:

    This module contains the header information for property sheet extensions
    to system control panel applets.

Revision History:

--*/



#ifndef _INC_CPLEXT
#define _INC_CPLEXT



//
//  Below are constants for pages which can be replaced in the standard
//  control panel applets.  To extend an applet, you must define an object
//  which supports the IShellPropSheetExt interface and register it's
//  in-process server in a subkey under the applet's registry key.  Registry
//  paths for the applets are defined in the header file REGSTR.H.
//  Generally, when an IShellPropSheetExt is loaded, it's AddPages method
//  will be called once, while it's ReplacePage method may be called zero or
//  more times.  ReplacePage is only called in context.
//


//
//  Mouse Control Panel Extensions.
//
//  The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
//  uPageID parameter for servers registered under
//  ( REGSTR_PATH_CONTROLSFOLDER "\\Mouse" )
//

#define CPLPAGE_MOUSE_BUTTONS       1
#define CPLPAGE_MOUSE_PTRMOTION     2



//
//  Keyboard Control Panel Extensions.
//
//  The following constants MAY be passed in IShellPropSheetExt::ReplacePage's
//  uPageID parameter for servers registered under
//  ( REGSTR_PATH_CONTROLSFOLDER "\\Keyboard" )
//

#define CPLPAGE_KEYBOARD_SPEED      1



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\drvaplet.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    drvaplet.c

Abstract:

    This module contains the driver routines for the project.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "drvaplet.h"




//
//  Defines for Win16 builds.
//

#ifndef WIN32
#define LoadLibrary16       LoadLibrary
#define FreeLibrary16       FreeLibrary
#define GetProcAddress16    GetProcAddress
#endif




//
//  Global Variables.
//

//
//  CplApplet.
//
const TCHAR *c_szCplApplet  = TEXT("CPlApplet");
const char  *c_szCplAppletA = "CPlApplet";




//
//  Typedef Declarations.
//

//
//  DRIVER_APPLET_INFO: the info we keep around about a driver applet.
//
typedef struct
{
    HMODULE     module;
    APPLET_PROC applet;
    HICON       icon;

} DRIVER_APPLET_INFO, *PDAI;




//
//  GetDriverModule: gets the module.
//
////////////////////////////////////////////////////////////////////////////
//
//  GetDriverModule
//
//  Gets the module.
//
////////////////////////////////////////////////////////////////////////////

HMODULE GetDriverModule(
    LPCTSTR name)
{
#ifdef WIN32

#ifdef WINNT
    return (LoadLibrary(name));
#else
    return (LoadLibrary16(name));
#endif

#else
    return (GetModuleHandle(name));
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  ReleaseDriverModule
//
////////////////////////////////////////////////////////////////////////////

void ReleaseDriverModule(
    HMODULE module)
{
#ifdef WIN32

#ifdef WINNT
    FreeLibrary(module);
#else
    FreeLibrary16(module);
#endif

#else
    //
    // do nothing (got it with GetModuleHandle)
    //
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenDriverApplet
//
//  Opens a handle to the named driver applet.
//
////////////////////////////////////////////////////////////////////////////

HDAP OpenDriverApplet(
    LPCTSTR name)
{
    PDAI driver = (PDAI)LocalAlloc(LPTR, sizeof(DRIVER_APPLET_INFO));

    if (driver)
    {
        if ((driver->module = GetDriverModule(name)) != NULL)
        {
            if ((driver->applet = (APPLET_PROC)
#ifdef WINNT
                GetProcAddress(driver->module, c_szCplAppletA)) != NULL)
#else
                GetProcAddress16(driver->module, c_szCplApplet)) != NULL)
#endif
            {
                union
                {
                    NEWCPLINFO newform;
                    CPLINFO oldform;
                } info = { 0 };

                CallDriverApplet( (HDAP) driver,
                                  NULL,
                                  CPL_NEWINQUIRE,
                                  0,
                                  (LPARAM)&info.newform );

                if (info.newform.dwSize == sizeof(info.newform))
                {
                    driver->icon = info.newform.hIcon;
                    return ((HDAP)driver);
                }

//
//  NOTE: If the driver doesn't handle CPL_NEWIQUIRE, we must use CPL_INQUIRE
//  and LoadIcon the icon ourselves.  Win32 doesn't provide a LoadIcon16, so
//  in Win32 the 16 bit side of the thunk for CPL_NEWINQUIRE does this.  In
//  Win16, we do it right here.
//

#ifndef WIN32
                info.oldform.idIcon = 0;

                CallDriverApplet( (HDAP)driver,
                                  NULL,
                                  CPL_INQUIRE,
                                  0,
                                  (LPARAM)&info.oldform );

                if (info.oldform.idIcon)
                {
                    driver->icon =
                        LoadIcon( driver->module,
                                  MAKEINTRESOURCE(info.oldform.idIcon) );

                    return ((HDAP)driver);
                }
#endif
            }

            ReleaseDriverModule(driver->module);
        }

        LocalFree(driver);
    }

    return ((HDAP)0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CloseDriverApplet
//
//  Closes a handle to a driver applet.
//
////////////////////////////////////////////////////////////////////////////

void CloseDriverApplet(
    HDAP HDAP)
{
#define driver ((PDAI)HDAP)

    if (driver)
    {
        if (driver->icon)
        {
            DestroyIcon(driver->icon);
        }
        ReleaseDriverModule(driver->module);
        LocalFree(driver);
    }

#undef driver
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDriverAppletIcon
//
//  Gets a driver applet's icon (if any).
//
////////////////////////////////////////////////////////////////////////////

HICON GetDriverAppletIcon(
    HDAP HDAP)
{
#define driver ((PDAI)HDAP)

    //
    //  Must return a copy for the current process/task to own.
    //
    return ((driver && driver->icon) ? CopyIcon(driver->icon) : NULL);

#undef driver
}


////////////////////////////////////////////////////////////////////////////
//
//  CallDriverApplet
//
//  Calls the driver applet (same syntax as CplApplet).
//
////////////////////////////////////////////////////////////////////////////

LRESULT CallDriverApplet(
    HDAP HDAP,
    HWND wnd,
    UINT msg,
    LPARAM p1,
    LPARAM p2)
{
#define driver ((PDAI)HDAP)

    if (driver)
    {
#ifdef WIN32
        return ( CallCPLEntry16( driver->module,
                                 (FARPROC16)driver->applet,
                                 wnd,
                                 msg,
                                 p1,
                                 p2 ) );
#else
        return (driver->applet(wnd, msg, p1, p2));
#endif
    }

    return (0L);

#undef driver
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\util.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module contains the header information for the utility functions
    of the Regional Options applet.

Revision History:

--*/


#ifndef _UTIL_H_
#define _UTIL_H_



//
//  Include Files.
//
#include "intl.h"




//
//  Constant Declarations.
//

#define MB_OK_OOPS      (MB_OK    | MB_ICONEXCLAMATION)    // msg box flags
#define MB_YN_OOPS      (MB_YESNO | MB_ICONEXCLAMATION)    // msg box flags

#define MAX_UI_LANG_GROUPS   64




//
//  Global Variables.
//




//
//  Typedef Declarations.
//

typedef struct
{
    LPARAM Changes;                   // flags to denote changes
    DWORD dwCurUserLocale;            // index of current user locale setting in combo box
    DWORD dwCurUserRegion;            // index of current user region setting in combo box
    DWORD dwCurUILang;                // index of current UI Language setting in combo box
    DWORD dwLastUserLocale;           // index of the last user locale setting in combo box
} REGDLGDATA, *LPREGDLGDATA;

typedef struct languagegroup_s
{
    WORD wStatus;                      // status flags
    UINT LanguageGroup;                // language group value
    DWORD LanguageCollection;          // collection which belong the language group
    HANDLE hLanguageGroup;             // handle to free for this structure
    TCHAR pszName[MAX_PATH];           // name of language group
    UINT NumLocales;                   // number of locales in pLocaleList
    LCID pLocaleList[MAX_PATH];        // ptr to locale list for this group
    UINT NumAltSorts;                  // number of alternate sorts in pAltSortList
    LCID pAltSortList[MAX_PATH];       // ptr to alternate sorts for this group
    struct languagegroup_s *pNext;     // ptr to next language group node

} LANGUAGEGROUP, *LPLANGUAGEGROUP;

typedef struct codepage_s
{
    WORD wStatus;                   // status flags
    UINT CodePage;                  // code page value
    HANDLE hCodePage;               // handle to free for this structure
    TCHAR pszName[MAX_PATH];        // name of code page
    struct codepage_s *pNext;       // ptr to next code page node

} CODEPAGE, *LPCODEPAGE;


//
//  Language group of UI languages.
//
typedef struct
{
    int iCount;
    LGRPID lgrp[MAX_UI_LANG_GROUPS];

} UILANGUAGEGROUP, *PUILANGUAGEGROUP;




//
//  Functions Prototypes.
//

LONG
Intl_StrToLong(
    LPTSTR szNum);

DWORD
TransNum(
    LPTSTR lpsz);

BOOL
Item_Has_Digits(
    HWND hDlg,
    int nItemId,
    BOOL Allow_Empty);

BOOL
Item_Has_Digits_Or_Invalid_Chars(
    HWND hDlg,
    int nItemId,
    BOOL Allow_Empty,
    LPTSTR pInvalid);

BOOL
Item_Check_Invalid_Chars(
    HWND hDlg,
    LPTSTR lpszBuf,
    LPTSTR lpCkChars,
    int nCkIdStr,
    BOOL Allow_Empty,
    LPTSTR lpChgCase,
    int nItemId);

void
No_Numerals_Error(
    HWND hDlg,
    int nItemId,
    int iStrId);

void
Invalid_Chars_Error(
    HWND hDlg,
    int nItemId,
    int iStrId);

void
Localize_Combobox_Styles(
    HWND hDlg,
    int nItemId,
    LCTYPE LCType);

BOOL
NLSize_Style(
    HWND hDlg,
    int nItemId,
    LPTSTR lpszOutBuf,
    LCTYPE LCType);

BOOL
Set_Locale_Values(
    HWND hDlg,
    LCTYPE LCType,
    int nItemId,
    LPTSTR lpIniStr,
    BOOL bValue,
    int Ordinal_Offset,
    LPTSTR Append_Str,
    LPTSTR NLS_Str);

BOOL
Set_List_Values(
    HWND hDlg,
    int nItemId,
    LPTSTR lpValueString);

void
DropDown_Use_Locale_Values(
    HWND hDlg,
    LCTYPE LCType,
    int nItemId);

BOOL CALLBACK
EnumProc(
    LPTSTR lpValueString);

BOOL CALLBACK
EnumProcEx(
    LPTSTR lpValueString,
    LPTSTR lpDecimalString,
    LPTSTR lpNegativeString,
    LPTSTR lpSymbolString);

typedef BOOL (CALLBACK* LEADINGZEROS_ENUMPROC)(LPTSTR, LPTSTR, LPTSTR, LPTSTR);
typedef BOOL (CALLBACK* NEGNUMFMT_ENUMPROC)(LPTSTR, LPTSTR, LPTSTR, LPTSTR);
typedef BOOL (CALLBACK* MEASURESYSTEM_ENUMPROC)(LPTSTR);
typedef BOOL (CALLBACK* POSCURRENCY_ENUMPROC)(LPTSTR, LPTSTR, LPTSTR, LPTSTR);
typedef BOOL (CALLBACK* NEGCURRENCY_ENUMPROC)(LPTSTR, LPTSTR, LPTSTR, LPTSTR);

BOOL
EnumLeadingZeros(
    LEADINGZEROS_ENUMPROC lpLeadingZerosEnumProc,
    LCID LCId,
    DWORD dwFlags);

BOOL
EnumNegNumFmt(
    NEGNUMFMT_ENUMPROC lpNegNumFmtEnumProc,
    LCID LCId,
    DWORD dwFlags);

BOOL
EnumMeasureSystem(
    MEASURESYSTEM_ENUMPROC lpMeasureSystemEnumProc,
    LCID LCId,
    DWORD dwFlags);

BOOL
EnumPosCurrency(
    POSCURRENCY_ENUMPROC lpPosCurrencyEnumProc,
    LCID LCId,
    DWORD dwFlags);

BOOL
EnumNegCurrency(
    NEGCURRENCY_ENUMPROC lpNegCurrencyEnumProc,
    LCID LCId,
    DWORD dwFlags);

void
CheckEmptyString(
    LPTSTR lpStr);

void
SetDlgItemRTL(
    HWND hDlg,
    UINT uItem);

int
ShowMsg(
    HWND hDlg,
    UINT iMsg,
    UINT iTitle,
    UINT iType,
    LPTSTR pString);

void 
SetControlReadingOrder(
    BOOL bUseRightToLeft, 
    HWND hwnd);

void
Intl_EnumLocales(
    HWND hDlg,
    HWND hLocale,
    BOOL EnumSystemLocales);

BOOL CALLBACK
Intl_EnumInstalledCPProc(
    LPTSTR pString);

BOOL
Intl_InstallKeyboardLayout(
    HWND  hDlg,
    LCID  Locale,
    DWORD Layout,
    BOOL  bDefaultLayout,
    BOOL  bDefaultUser,
    BOOL  bSystemLocale);

BOOL
Intl_InstallKeyboardLayoutList(
    PINFCONTEXT pContext,
    DWORD dwStartField,
    BOOL bDefaultUserCase);

BOOL
Intl_InstallAllKeyboardLayout(
    LANGID Language);

BOOL
Intl_UninstallAllKeyboardLayout(
    UINT  uiLangGp,
    BOOL DefaultUserCase);

HKL
Intl_GetHKL(
    DWORD dwLocale,
    DWORD dwLayout);

BOOL
Intl_GetDefaultLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout);

BOOL
Intl_GetSecondValidLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout);

BOOL
Intl_InitInf(
    HWND hDlg,
    HINF *phIntlInf,
    LPTSTR pszInf,
    HSPFILEQ *pFileQueue,
    PVOID *pQueueContext);

BOOL
Intl_OpenIntlInfFile(
    HINF *phInf);

void
Intl_CloseInf(
    HINF hIntlInf,
    HSPFILEQ FileQueue,
    PVOID QueueContext);

BOOL
Intl_ReadDefaultLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    HINF hIntlInf);

BOOL
Intl_ReadSecondValidLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    HINF hIntlInf);

BOOL
Intl_CloseInfFile(
    HINF *phInf);

BOOL
Intl_IsValidLayout(
    DWORD dwLayout);

void
Intl_RunRegApps(
    LPCTSTR pszRegKey);

VOID
Intl_RebootTheSystem();

BOOL
Intl_InstallUserLocale(
    LCID Locale,
    BOOL bDefaultUserCase,
    BOOL bChangeLocaleInfo);

void
Intl_SetLocaleInfo(
    LCID Locale,
    LCTYPE LCType,
    LPTSTR lpIniStr,
    BOOL bDefaultUserCase);

void
Intl_AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    LPARAM lParam,
    UINT iMaxPages);

void
Intl_AddExternalPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    HINSTANCE hInst,
    LPSTR ProcName,
    UINT iMaxPages);

int
Intl_SetDefaultUserLocaleInfo(
    LPCTSTR lpKeyName,
    LPCTSTR lpString);

void
Intl_DeleteRegKeyValues(
    HKEY hKey);

DWORD
Intl_DeleteRegTree(
    HKEY hStartKey,
    LPTSTR pKeyName);

void
Intl_DeleteRegSubKeys(
    HKEY hKey);

DWORD
Intl_CopyRegKeyValues(
    HKEY hSrc,
    HKEY hDest);

DWORD
Intl_CreateRegTree(
    HKEY hSrc,
    HKEY hDest);

HKEY
Intl_LoadNtUserHive(
    LPCTSTR lpRoot,
    LPCTSTR lpKeyName,
    BOOLEAN *lpWasEnabled);

void
Intl_UnloadNtUserHive(
    LPCTSTR lpRoot,
    BOOLEAN *lpWasEnabled);

BOOL
Intl_ChangeUILangForAllUsers(
    LANGID UILanguageId);

BOOL
Intl_LoadLanguageGroups(
    HWND hDlg);

BOOL
Intl_GetSupportedLanguageGroups();

BOOL
Intl_EnumInstalledLanguageGroups();

BOOL
Intl_LanguageGroupDirExist(
    PTSTR pszLangDir);

BOOL
Intl_LanguageGroupFilesExist();

BOOL
Intl_GetLocaleList(
    LPLANGUAGEGROUP pLG);

DWORD
Intl_GetLanguageGroup(
    LCID lcid);

BOOL
Intl_GetUILanguageGroups(
    PUILANGUAGEGROUP pUILanguageGroup);

BOOL
CALLBACK
Intl_EnumUILanguagesProc(
    LPWSTR pwszUILanguage,
    LONG_PTR lParam);

void
Intl_SaveValuesToDefault(
    LPCTSTR srcKey,
    LPCTSTR destKey);

void
Intl_SaveValuesToNtUserFile(
    HKEY hSourceRegKey,
    LPCTSTR srcKey,
    LPCTSTR destKey);

DWORD
Intl_DefaultKeyboardLayout();

BOOL
Intl_IsLIP();

BOOL 
Intl_IsMUISetupVersionSameAsOS();

BOOL
Intl_IsSetupMode();

BOOL
Intl_IsWinntUpgrade();

BOOL 
Intl_IsUIFontSubstitute();

VOID
Intl_ApplyFontSubstitute(LCID SystemLocale);

HANDLE
Intl_OpenLogFile();

BOOL
Intl_LogMessage(
    LPCTSTR lpMessage);

void
Intl_LogUnattendFile(
    LPCTSTR pFileName);

void
Intl_LogSimpleMessage(
    UINT LogId,
    LPCTSTR pAppend);

void
Intl_LogFormatMessage(
    UINT LogId);

void
Intl_SaveDefaultUserSettings();

BOOL 
Intl_SaveDefaultUserInputSettings();

void
Intl_RemoveMUIFile();

void
Intl_CallTextServices();

LANGID
Intl_GetPendingUILanguage();

LANGID 
Intl_GetDotDefaultUILanguage();

#endif //_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\keybd.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    keybd.c

Abstract:

    This module contains the main routines for the Keyboard applet.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include <regstr.h>
#include <cplext.h>
#include "util.h"
#include <intlid.h>




//
//  Constant Declarations.
//

#define MAX_PAGES 32              // limit on number of pages

const HWPAGEINFO c_hpiKeybd = {
    // Keyboard device class
    { 0x4d36e96bL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } },

    // Keyboard troubleshooter command line
    IDS_KEYBD_TSHOOT,
};





//
//  Global Variables.
//

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegKeybd[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Keyboard");




//
//  Function Prototypes.
//

INT_PTR CALLBACK
KeyboardSpdDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);





////////////////////////////////////////////////////////////////////////////
//
//  _AddKeybdPropSheetPage
//
//  Adds a property sheet page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddKeybdPropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

    if (hpage && ppsh->nPages < MAX_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KeybdApplet
//
////////////////////////////////////////////////////////////////////////////

int KeybdApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    HPSXA hpsxa;
    int Result;
    HINSTANCE hInst;

    //
    //  Make the initial page.
    //
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = parent;
    psh.hInstance  = instance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_KEYBD_TITLE);
    psh.nPages     = 0;

    if (cmdline)
    {
        psh.nStartPage = lstrlen(cmdline) ? StrToLong(cmdline) : 0;
    }
    else
    {
        psh.nStartPage = 0;
    }
    psh.phpage = rPages;

    //
    //  Load any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegKeybd, 8);

    //
    //  Add the Speed page.
    //
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = instance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_KEYBD_SPEED);
    psp.pfnDlgProc  = KeyboardSpdDlg;
    psp.lParam      = 0;

    _AddKeybdPropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);

    //
    //  Add the Hardware page (not replaceable).
    //
    _AddKeybdPropSheetPage(CreateHardwarePage(&c_hpiKeybd), (LPARAM)&psh);

    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa)
    {
        UINT cutoff = psh.nPages;
        UINT added = SHAddFromPropSheetExtArray( hpsxa,
                                                 _AddKeybdPropSheetPage,
                                                 (LPARAM)&psh );

        if (psh.nStartPage >= cutoff)
        {
            psh.nStartPage += added;
        }
    }

    //
    //  Invoke the Property Sheets.
    //
    switch (PropertySheet(&psh))
    {
        case ( ID_PSRESTARTWINDOWS ) :
        {
            Result = APPLET_RESTART;
            break;
        }
        case ( ID_PSREBOOTSYSTEM ) :
        {
            Result = APPLET_REBOOT;
            break;
        }
        default :
        {
            Result = 0;
            break;
        }
    }

    //
    //  Free any loaded extensions.
    //
    if (hpsxa)
    {
        SHDestroyPropSheetExtArray(hpsxa);
    }

    //
    //  Free the library loaded for the external page.
    //
    if (hInst)
    {
        FreeLibrary(hInst);
    }

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\main.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    main.c

Abstract:

    This module contains the main routines for the Control Panel
    interface of the 32bit MAIN.CPL.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include "mousectl.h"
#include "drvaplet.h"




//
//  Global Variables.
//

#ifdef WINNT

HINSTANCE g_hInst = NULL;

#else

#pragma data_seg(".idata")
HINSTANCE g_hInst = NULL;
#pragma data_seg()

#endif




//
//  Externally Defined Applets.
//

int MouseApplet(HINSTANCE, HWND, LPCTSTR);  // mouse.c
int KeybdApplet(HINSTANCE, HWND, LPCTSTR);  // keybd.c

BOOL RegisterPointerStuff(HINSTANCE);       // from mouseptr.c




//
//  Typedef Declarations.
//
typedef struct
{
    int            idIcon;
    int            idTitle;
    int            idExplanation;
    PFNAPPLETQUERY pfnAppletQuery;
    PFNAPPLET      pfnApplet;
    LPCTSTR        szDriver;
} APPLET;

APPLET Applets[] =
{
    { IDI_MOUSE,       IDS_MOUSE_TITLE,  IDS_MOUSE_EXPLAIN,  NULL,  MouseApplet,  TEXT("MOUSE") },
    { IDI_KEYBD,       IDS_KEYBD_TITLE,  IDS_KEYBD_EXPLAIN,  NULL,  KeybdApplet,  NULL    },
};

#define NUM_APPLETS (sizeof(Applets) / sizeof(Applets[0]))

int cApplets = NUM_APPLETS;





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY LibMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInit
//
//  Called when a CPL consumer initializes a CPL.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInit(
    HWND hParent)
{
    int i;

    InitCommonControls();

    RegisterPointerStuff(g_hInst);

    RegisterMouseControlStuff(g_hInst);

    for (i = 0; i < cApplets; i++)
    {
        if ((Applets[i].pfnAppletQuery != NULL) &&
            ((*Applets[i].pfnAppletQuery)(hParent, APPLET_QUERY_EXISTS) == FALSE))
        {
            cApplets--;

            if (i != cApplets)
            {
                Applets[i] = Applets[cApplets];
            }

            i--;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplExit
//
//  Called when a CPL consumer is done with a CPL.
//
////////////////////////////////////////////////////////////////////////////

void CplExit(void)
{
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInquire
//
//  Called when a CPL consumer wants info about an applet.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInquire(
    LPCPLINFO info,
    int iApplet)
{
    APPLET *applet = Applets + iApplet;
    HMODULE hDriverApplet = NULL;

    info->idIcon = applet->idIcon;

    if (applet->szDriver) {

        if (hDriverApplet = GetDriverModule(applet->szDriver)) {

            info->idIcon = CPL_DYNAMIC_RES;
            ReleaseDriverModule(hDriverApplet);

        } // if (hDriverApplet = ...

    } // if (applet->szDriver)

    info->idName = applet->idTitle;
    info->idInfo = applet->idExplanation;
    info->lData  = 0L;

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplNewInquire
//
//  Called when a CPL consumer wants info about an applet.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplNewInquire(
    HWND parent,
    LPNEWCPLINFO info,
    int iApplet)
{
    APPLET *applet = Applets + iApplet;
    HDAP hdap;

    info->dwSize = sizeof(NEWCPLINFO);
    info->hIcon = NULL;

    //
    //  See if the applet is associated with a driver which can provide us
    //  an icon.
    //
    if ((applet->szDriver) &&
        ((hdap = OpenDriverApplet(applet->szDriver)) != NULL))
    {
        info->hIcon = GetDriverAppletIcon(hdap);
        CloseDriverApplet(hdap);
    }

    if ((!info->hIcon) && (applet->pfnAppletQuery != NULL))
    {
        info->hIcon = (HICON)(*(applet->pfnAppletQuery))( parent,
                                                          APPLET_QUERY_GETICON );
    }

    if (!info->hIcon)
    {
        info->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(applet->idIcon));
    }

    LoadString(g_hInst, applet->idTitle, info->szName, sizeof(info->szName));
    LoadString(g_hInst, applet->idExplanation, info->szInfo, sizeof(info->szInfo));

    info->lData = 0L;
    *info->szHelpFile = 0;
    info->dwHelpContext = 0UL;

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInvoke
//
//  Called to invoke an applet.  It checks the applet's return value to see
//  if we need to restart.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInvoke(
    HWND parent,
    int iApplet,
    LPCTSTR cmdline)
{
    DWORD exitparam = 0UL;

    switch (Applets[iApplet].pfnApplet(g_hInst, parent, cmdline))
    {
        case ( APPLET_RESTART ) :
        {
            exitparam = EW_RESTARTWINDOWS;
            break;
        }
        case ( APPLET_REBOOT ) :
        {
            exitparam = EW_REBOOTSYSTEM;
            break;
        }
        default :
        {
            return (1L);
        }
    }

    RestartDialog(parent, NULL, exitparam);
    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplApplet
//
//  A CPL consumer calls this to request stuff from us.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CPlApplet(
    HWND parent,
    UINT msg,
    LPARAM lparam1,
    LPARAM lparam2)
{
    switch (msg)
    {
        case ( CPL_INIT ) :
        {
            return (CplInit(parent));
        }
        case ( CPL_EXIT ) :
        {
            CplExit();
            break;
        }
        case ( CPL_GETCOUNT ) :
        {
            return (cApplets);
        }
        case ( CPL_INQUIRE ) :
        {
            return (CplInquire((LPCPLINFO)lparam2, (int)lparam1));
        }
        case ( CPL_NEWINQUIRE ) :
        {
            return (CplNewInquire(parent, (LPNEWCPLINFO)lparam2, (int)lparam1));
        }
        case ( CPL_DBLCLK ) :
        {
            lparam2 = 0L;

            // fall through...
        }
        case ( CPL_STARTWPARMS ) :
        {
            return (CplInvoke(parent, (int)lparam1, (LPTSTR)lparam2));
        }
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\main.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    main.h

Abstract:

    This module contains the header information for the main routines of the
    Control Panel interface of the 32bit MAIN.CPL.

Revision History:

--*/



#ifndef _MAIN_H
#define _MAIN_H

#define USECOMM
#define OEMRESOURCE
#define STRICT

#ifdef WIN32
#define INC_OLE2
#define CONST_VTABLE
#endif



//
//  Include Files.
//

#include <windows.h>
#include <windowsx.h>
#include <dlgs.h>
#include <cpl.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <commctrl.h>

#ifndef RC_INVOKED
#include <prsht.h>
#endif




//
//  Constant Declarations.
//

#define PATHMAX MAX_PATH
#define HELP_FILE TEXT("mouse.hlp")  // Help file for the mouse control panel




//
//  Typedef Declarations.
//

#ifndef NOARROWS
typedef struct
{
    short lineup;             // lineup/down, pageup/down are relative
    short linedown;           // changes.  top/bottom and the thumb
    short pageup;             // elements are absolute locations, with
    short pagedown;           // top & bottom used as limits.
    short top;
    short bottom;
    short thumbpos;
    short thumbtrack;
    BYTE  flags;              // flags set on return
} ARROWVSCROLL, NEAR *PARROWVSCROLL, FAR *LPARROWVSCROLL;

#define UNKNOWNCOMMAND 1
#define OVERFLOW       2
#define UNDERFLOW      4

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\keybdspd.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    keybdspd.c

Abstract:

    This module contains the main routines for the Keyboard applet's
    Speed property page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "util.h"
#include <regstr.h>
#include <help.h>




//
//  Constant Declarations.
//

#define KSPEED_MIN      0
#define KSPEED_MAX      31
#define KSPEED_RANGE    (KSPEED_MAX - KSPEED_MIN + 1)

//
//  For keyboard delay control.
//
#define KDELAY_MIN      0
#define KDELAY_MAX      3
#define KDELAY_RANGE    (KDELAY_MAX - KDELAY_MIN + 1)

//
//  For control of the cursor blink rate.
//
#define BLINK           1000

#define CURSORMIN       200
#define CURSORMAX       1200
#define CURSORSUM       (CURSORMIN + CURSORMAX)
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

static ARROWVSCROLL avsDelay =  { -1,
                                  1,
                                  -KDELAY_RANGE / 4,
                                  KDELAY_RANGE / 4,
                                  KDELAY_MAX,
                                  KDELAY_MIN
                                };
static ARROWVSCROLL avsSpeed  = { -1,
                                  1,
                                  -KSPEED_RANGE / 4,
                                  KSPEED_RANGE / 4,
                                  KSPEED_MAX,
                                  KSPEED_MIN
                                };
static ARROWVSCROLL avsCursor = { -1,
                                  1,
                                  -CURSORRANGE / 400,
                                  CURSORRANGE / 400,
                                  CURSORMAX / 100,
                                  CURSORMIN / 100,
                                  0,
                                  0
                                };




//
//  Context Help Ids.
//

static DWORD aKbdHelpIds[] =
{
    KDELAY_GROUP,        IDH_COMM_GROUPBOX,
    KBLINK_GROUP,        IDH_COMM_GROUPBOX,
    KDELAY_SCROLL,       IDH_DLGKEY_REPDEL,
    KSPEED_SCROLL,       IDH_DLGKEY_REPSPEED,
    KREPEAT_EDIT,        IDH_DLGKEY_REPTEST,
    KBLINK_EDIT,         IDH_DLGKEY_CURSOR_GRAPHIC,
    KCURSOR_BLINK,       IDH_DLGKEY_CURSBLNK,
    KCURSOR_SCROLL,      IDH_DLGKEY_CURSBLNK,

    0, 0
};




//
//  Global Variables.
//

//
//  FEATURE - these should be moved into the KeyboardSpdStr structure
//
static UINT uOriginalDelay, uOriginalSpeed;
static UINT uBlinkTime;
static UINT uNewBlinkTime;
static BOOL bKbNeedsReset = FALSE;
static HWND hwndCursorScroll;
static RECT rCursor;




//
//  Typedef Declarations.
//

typedef struct tag_KeyboardSpdStr
{
    HWND hDlg;        // HWND hKeyboardSpdDlg;

} KEYBOARDSPDSTR, *PKEYBOARDSPDSTR;





////////////////////////////////////////////////////////////////////////////
//
//  KeyboardSpeedSupported
//
////////////////////////////////////////////////////////////////////////////

BOOL KeyboardSpeedSupported()
{
#ifdef WINNT
    //
    // FEATURE  For Windows NT we assume that all keyboards can
    //         handle the SetSpeed - we might be able to do a
    //         better check in the future if KEYBOARD.DLL is available.
    //
    return (TRUE);
#else
    HANDLE hKeyboardModule = LoadLibrary16(TEXT("KEYBOARD"));
    BOOL bCanDorkWithTheSpeed = FALSE;

    if (hKeyboardModule)
    {
        if (GetProcAddress16(hKeyboardModule, TEXT("SetSpeed")))
        {
            bCanDorkWithTheSpeed = TRUE;
        }

        FreeLibrary16(hKeyboardModule);
    }

    return (bCanDorkWithTheSpeed);
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDelayAndSpeed
//
////////////////////////////////////////////////////////////////////////////

void SetDelayAndSpeed(
    HWND hDlg,
    int nDelay,
    int nSpeed,
    UINT uFlags)
{
    if (nDelay < 0)
    {
        nDelay = (int)SendDlgItemMessage( hDlg,
                                          KDELAY_SCROLL,
                                          TBM_GETPOS,
                                          0,
                                          0L );
    }

    if (nSpeed < 0)
    {
        nSpeed = (int)SendDlgItemMessage( hDlg,
                                          KSPEED_SCROLL,
                                          TBM_GETPOS,
                                          0,
                                          0L );
    }

    //
    //  Only send the WININICHANGE once.
    //
    SystemParametersInfo( SPI_SETKEYBOARDSPEED,
                          nSpeed,
                          0,
                          uFlags & ~SPIF_SENDWININICHANGE );
    SystemParametersInfo( SPI_SETKEYBOARDDELAY,
                          KDELAY_MAX - nDelay + KDELAY_MIN,
                          0L,
                          uFlags );
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyKeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyKeyboardSpdDlg(
    PKEYBOARDSPDSTR pKstr)
{
    HWND hDlg;

    if (pKstr)
    {
        hDlg = pKstr->hDlg;

        LocalFree((HGLOBAL)pKstr);

        SetWindowLongPtr(hDlg, DWLP_USER, 0);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSpeedGlobals
//
//  Get Repeat Speed, Delay, and Blink Time.
//
////////////////////////////////////////////////////////////////////////////

VOID GetSpeedGlobals()
{
    SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &uOriginalSpeed, FALSE);
    SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &uOriginalDelay, FALSE);

    uOriginalDelay = KDELAY_MAX - uOriginalDelay + KDELAY_MIN;

    uBlinkTime = uNewBlinkTime = GetCaretBlinkTime();
}


////////////////////////////////////////////////////////////////////////////
//
//  InitKeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitKeyboardSpdDlg(
    HWND hDlg)
{
    HourGlass(TRUE);

    if (!KeyboardSpeedSupported())
    {
        MyMessageBox( hDlg,
                      IDS_KEYBD_NOSETSPEED,
                      IDS_KEYBD_TITLE,
                      MB_OK | MB_ICONINFORMATION );

        HourGlass(FALSE);
        return (FALSE);
    }

    //
    //  Get Repeat Speed, Delay, and Blink Time.
    //
    GetSpeedGlobals();

    TrackInit(GetDlgItem(hDlg, KSPEED_SCROLL), uOriginalSpeed, &avsSpeed);
    TrackInit(GetDlgItem(hDlg, KDELAY_SCROLL), uOriginalDelay, &avsDelay);
    TrackInit(GetDlgItem(hDlg, KCURSOR_SCROLL), (CURSORSUM - uBlinkTime) / 100, &avsCursor );

    hwndCursorScroll = GetDlgItem(hDlg, KCURSOR_SCROLL);

    GetWindowRect(GetDlgItem(hDlg, KCURSOR_BLINK), &rCursor);
    ScreenToClient(hDlg, (LPPOINT)&rCursor.left);
    ScreenToClient(hDlg, (LPPOINT)&rCursor.right);

    SetTimer(hDlg, BLINK, uBlinkTime, NULL);

    HourGlass(FALSE);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

static const TCHAR c_szUserDesktopKey[] = REGSTR_PATH_DESKTOP;
static const TCHAR c_szCursorBlink[] = TEXT("CursorBlinkRate");

INT_PTR CALLBACK KeyboardSpdDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PKEYBOARDSPDSTR pKstr = (PKEYBOARDSPDSTR)GetWindowLongPtr(hDlg, DWLP_USER);
    static BOOL fBlink = FALSE;
    
    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            bKbNeedsReset = FALSE;
            return (InitKeyboardSpdDlg(hDlg));
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyKeyboardSpdDlg(pKstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            if ((HWND)lParam == hwndCursorScroll)
            {
                int nCurrent = (int)SendMessage( (HWND)lParam,
                                                 TBM_GETPOS,
                                                 0,
                                                 0L );

                uNewBlinkTime = CURSORSUM - (nCurrent * 100);
                SetCaretBlinkTime(uNewBlinkTime);
                KillTimer(hDlg, BLINK);
                SetTimer(hDlg, BLINK, CURSORSUM - (nCurrent * 100), NULL);
            }
            else
            {
                SetDelayAndSpeed(hDlg, -1, -1, 0);
                bKbNeedsReset = TRUE;
            }

            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        case ( WM_TIMER ) :
        {
            if (wParam == BLINK)
            {
                HDC hDC = GetDC(hDlg);
                if (fBlink)
                {
                    HBRUSH hBrush = CreateSolidBrush((COLORREF)0);
                    FillRect(hDC, &rCursor, hBrush);
                    DeleteObject(hBrush);
                }
                else
                    InvalidateRect(hDlg, &rCursor, TRUE);
                fBlink = !fBlink;            
                ReleaseDC(hDlg,hDC);
            }
            break;
        }
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        case ( WM_DISPLAYCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            break;
        }

        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aKbdHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aKbdHelpIds );
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    HKEY hk;

                    HourGlass(TRUE);

                    if (RegCreateKey( HKEY_CURRENT_USER,
                                      c_szUserDesktopKey,
                                      &hk ) == ERROR_SUCCESS)
                    {
                        TCHAR buf[16];

                        wsprintf(buf, TEXT("%d"), uNewBlinkTime);
                        RegSetValueEx( hk,
                                       c_szCursorBlink,
                                       0,
                                       REG_SZ,
                                       (LPBYTE)buf,
                                       (DWORD)(lstrlen(buf) + 1) * sizeof(TCHAR) );

                        RegCloseKey(hk);
                    }

                    SetDelayAndSpeed( hDlg,
                                      -1,
                                      -1,
                                      SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
                    GetSpeedGlobals();
                    HourGlass(FALSE);

                    break;
                }
                case ( PSN_RESET ) :
                {
                    SetCaretBlinkTime(uBlinkTime);

                    if (bKbNeedsReset)
                    {
                        //
                        //  Restore the original keyboard speed.
                        //
                        SetDelayAndSpeed( hDlg,
                                          uOriginalDelay,
                                          uOriginalSpeed,
                                          0 );
                    }
                    break;
                }
            }
            break;
        }
        default :
        {
            return FALSE;
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mouse.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouse.c

Abstract:

    This module contains the main routines for the Mouse applet.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include <regstr.h>
#include <cplext.h>
#include "util.h"



//
//  Constant Declarations.
//

#define MAX_PAGES 32


const HWPAGEINFO c_hpiMouse = {
    // Mouse device class
    { 0x4d36e96fL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } },

    // Mouse troubleshooter command line
    IDS_MOUSE_TSHOOT,
};


//
//  Global Variables.
//

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegMouse[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Mouse");




//
//  Function Prototypes.
//

INT_PTR CALLBACK
MouseButDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
MousePtrDlg(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
MouseMovDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);





////////////////////////////////////////////////////////////////////////////
//
//  _AddMousePropSheetPage
//
//  Adds a property sheet page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddMousePropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

    if (hpage && (ppsh->nPages < MAX_PAGES))
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseApplet
//
////////////////////////////////////////////////////////////////////////////

int MouseApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    HPSXA hpsxa;
    int Result;

    //
    //  Make the initial page.
    //
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = parent;
    psh.hInstance  = instance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_MOUSE_TITLE);
    psh.nPages     = 0;
    psh.nStartPage = 0;
    psh.phpage     = rPages;

    //
    //  Load any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegMouse, 8);

    //
    //  Add the Buttons page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_BUTTONS,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_BUTTONS);
        psp.pfnDlgProc  = MouseButDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }

    //
    //  Add the Pointers page (not replaceable).
    //
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = instance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_POINTER);
    psp.pfnDlgProc  = MousePtrDlg;
    psp.lParam      = 0;

    _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);

    //
    //  Add the Motion page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_PTRMOTION,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_MOTION);
        psp.pfnDlgProc  = MouseMovDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }

    _AddMousePropSheetPage(CreateHardwarePage(&c_hpiMouse), (LPARAM)&psh);

    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa)
    {
        UINT cutoff = psh.nPages;
        UINT added = SHAddFromPropSheetExtArray( hpsxa,
                                                 _AddMousePropSheetPage,
                                                 (LPARAM)&psh );

        if (psh.nStartPage >= cutoff)
        {
            psh.nStartPage += added;
        }
    }

    //
    //  Invoke the Property Sheets.
    //
    switch (PropertySheet(&psh))
    {
        case ( ID_PSRESTARTWINDOWS ) :
        {
            Result = APPLET_RESTART;
            break;
        }
        case ( ID_PSREBOOTSYSTEM ) :
        {
            Result = APPLET_REBOOT;
            break;
        }
        default :
        {
            Result = 0;
            break;
        }
    }

    //
    //  Free any loaded extensions.
    //
    if (hpsxa)
    {
        SHDestroyPropSheetExtArray(hpsxa);
    }

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mousectl.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousectl.h

Abstract:

    This module contains the header information for the Mouse control.

Revision History:

--*/



#ifndef _MOUSECTL_H
#define _MOUSECTL_H



#define MOUSECTL_CLASSNAME  TEXT("PropertyMouseButtonControl")


BOOL
RegisterMouseControlStuff(
    HINSTANCE instance);

void
MouseControlSetSwap(
    HWND window,
    BOOL swap);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mousectl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousectl.c

Abstract:

    This module contains the routines for the Mouse control.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "mousectl.h"
#include "rc.h"



//
//  Constant Declarations.
//

#define MOUSECTL_BITMAP_NAME          MAKEINTRESOURCE(IDB_MOUSE)

#define MOUSECTL_DATA                 0

//
//  These are indices into the VGA palette!
//
#define MOUSECTL_BKGND_INDEX          14    // light cyan
#define MOUSECTL_LBUTTON_INDEX        13    // light magenta
#define MOUSECTL_RBUTTON_INDEX        11    // light yellow
#define MOUSECTL_LBUTTON_ALTERNATE    5     // magenta
#define MOUSECTL_RBUTTON_ALTERNATE    3     // yellow

#define MOUSECTL_NORMAL_COLOR         RGB(255, 255, 255)

#define HALFRGB(c)  RGB(GetRValue(c) / 2, GetGValue(c) / 2, GetBValue(c) / 2)




//
//  Typedef Declarations.
//

typedef struct tagMOUSECTLDATA
{
    HWND     window;         // window handle for this control
    BOOL     swapped;        // are the buttons swapped?

    HBITMAP  image;          // DIB section image of mouse
    HDC      imagedc;        // DC where image lives
    HBITMAP  olddcimage;     // previous inhabitant of imagedc

    POINT    offset;         // offset of bitmap in control
    SIZE     size;           // size of bitmap

} MOUSECTLDATA, *PMOUSECTLDATA;




//
//  Forward Declarations.
//

LRESULT CALLBACK
MouseControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void
MouseControlShowSwap(
    PMOUSECTLDATA ctldata);





////////////////////////////////////////////////////////////////////////////
//
//  SetMouseControlData
//
////////////////////////////////////////////////////////////////////////////

__inline void SetMouseControlData(
    HWND window,
    PMOUSECTLDATA ctldata)
{
    SetWindowLongPtr(window, MOUSECTL_DATA, (LONG_PTR)ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMouseControlData
//
////////////////////////////////////////////////////////////////////////////

__inline PMOUSECTLDATA GetMouseControlData(
    HWND window)
{
    return ((PMOUSECTLDATA)GetWindowLongPtr(window, MOUSECTL_DATA));
}


////////////////////////////////////////////////////////////////////////////
//
//  RegisterMouseControlStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterMouseControlStuff(
    HINSTANCE instance)
{
    WNDCLASS wc;

    wc.style         = 0;
    wc.lpfnWndProc   = MouseControlWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PMOUSECTLDATA);
    wc.hInstance     = instance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = MOUSECTL_CLASSNAME;

    return (RegisterClass(&wc));
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateMouseControlData
//
////////////////////////////////////////////////////////////////////////////

PMOUSECTLDATA CreateMouseControlData(
    HWND window)
{
    PMOUSECTLDATA ctldata = (PMOUSECTLDATA)LocalAlloc(LPTR, sizeof(MOUSECTLDATA));

    if (ctldata)
    {
        ctldata->window = window;
        SetMouseControlData(window, ctldata);
    }

    return (ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseControlData
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseControlData(
    PMOUSECTLDATA ctldata)
{
    if (ctldata)
    {
        SetMouseControlData(ctldata->window, 0);

        LocalFree(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlNCCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MouseControlNCCreate(
    PMOUSECTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    if (!ctldata)
    {
        return (FALSE);
    }

    ctldata->image = LoadImage( cs->hInstance,
                                MOUSECTL_BITMAP_NAME,
                                IMAGE_BITMAP,
                                0,
                                0,
                                LR_CREATEDIBSECTION );

    if (ctldata->image)
    {
        ctldata->imagedc = CreateCompatibleDC(NULL);

        if (ctldata->imagedc)
        {
            BITMAP bm;

            ctldata->olddcimage =
                SelectBitmap(ctldata->imagedc, ctldata->image);

            ctldata->offset.x = ctldata->offset.y = 0;

            if (GetObject(ctldata->image, sizeof(BITMAP), &bm))
            {
                ctldata->size.cx  = bm.bmWidth;
                ctldata->size.cy  = bm.bmHeight;
                ctldata->offset.x = (cs->cx - ctldata->size.cx) / 2;
                ctldata->offset.y = (cs->cy - ctldata->size.cy) / 2;

                ctldata->swapped = FALSE;
                MouseControlShowSwap(ctldata);
                return (TRUE);
            }

            SelectBitmap(ctldata->imagedc, ctldata->olddcimage);
            ctldata->olddcimage = NULL;
        }

        DeleteBitmap(ctldata->image);
        ctldata->image = NULL;
    }

    ctldata->olddcimage = NULL;
    ctldata->imagedc    = NULL;

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlNCDestroy
//
////////////////////////////////////////////////////////////////////////////

void MouseControlNCDestroy(
    PMOUSECTLDATA ctldata)
{
    if (ctldata)
    {
        if (ctldata->olddcimage)
        {
            SelectBitmap(ctldata->imagedc, ctldata->olddcimage);
            ctldata->olddcimage = NULL;
        }

        if (ctldata->imagedc)
        {
            DeleteDC(ctldata->imagedc);
            ctldata->imagedc = NULL;
        }

        if (ctldata->image)
        {
            DeleteBitmap(ctldata->image);
            ctldata->image = NULL;
        }

        DestroyMouseControlData(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlPaint
//
////////////////////////////////////////////////////////////////////////////

void MouseControlPaint(
    PMOUSECTLDATA ctldata)
{
    PAINTSTRUCT ps;
    HDC dc = BeginPaint(ctldata->window, &ps);

    BitBlt( dc,
            ctldata->offset.x,
            ctldata->offset.y,
            ctldata->size.cx,
            ctldata->size.cy,
            ctldata->imagedc,
            0,
            0,
            SRCCOPY );

    EndPaint(ctldata->window, &ps);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlSetColor
//
////////////////////////////////////////////////////////////////////////////

__inline void MouseControlSetColor(
    PMOUSECTLDATA ctldata,
    UINT index,
    COLORREF color)
{
    RGBQUAD rgbq = { GetBValue(color), GetGValue(color), GetRValue(color), 0 };

    SetDIBColorTable(ctldata->imagedc, index, 1, &rgbq);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlShowSwap
//
////////////////////////////////////////////////////////////////////////////

void MouseControlShowSwap(
    PMOUSECTLDATA ctldata)
{
    MouseControlSetColor( ctldata,
                          MOUSECTL_BKGND_INDEX,
                          GetSysColor(COLOR_BTNFACE) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_RBUTTON_INDEX
                            : MOUSECTL_LBUTTON_INDEX,
                          GetSysColor(COLOR_HIGHLIGHT) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_RBUTTON_ALTERNATE
                            : MOUSECTL_LBUTTON_ALTERNATE,
                          HALFRGB(GetSysColor(COLOR_HIGHLIGHT)) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_LBUTTON_INDEX
                            : MOUSECTL_RBUTTON_INDEX,
                          MOUSECTL_NORMAL_COLOR );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_LBUTTON_ALTERNATE
                            : MOUSECTL_RBUTTON_ALTERNATE,
                          HALFRGB(MOUSECTL_NORMAL_COLOR) );

    InvalidateRect(ctldata->window, NULL, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlSetSwap
//
////////////////////////////////////////////////////////////////////////////

void MouseControlSetSwap(
    HWND window,
    BOOL swap)
{
    PMOUSECTLDATA ctldata = GetMouseControlData(window);

    if (ctldata->swapped != swap)
    {
        ctldata->swapped = swap;
        MouseControlShowSwap(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MouseControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSECTLDATA ctldata = (message == WM_NCCREATE)
                              ? CreateMouseControlData(window)
                              : GetMouseControlData(window);

    switch (message)
    {
        HANDLE_MSG(ctldata, WM_NCCREATE,  MouseControlNCCreate );
        HANDLE_MSG(ctldata, WM_NCDESTROY, MouseControlNCDestroy);
        HANDLE_MSG(ctldata, WM_PAINT,     MouseControlPaint    );
    }

    return (DefWindowProc(window, message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mousemov.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousemov.c

Abstract:

    This module contains the routines for the Mouse Pointer Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousehlp.h"




//
//  Constant Declarations.
//

#ifdef WINNT                 // NT does not currently support Mouse Trails
  #define  NO_MOUSETRAILS  1
#endif

#define ACCELMIN   0
#define ACCELMAX   (ACCELMIN + 6)      // range of 7 settings
#define TRAILMIN   2
#define TRAILMAX   (TRAILMIN + 5)      // range of 8 settings

//
// From shell\inc\shsemip.h
//
#define Assert(f)

//
//  Typedef Declarations.
//

//
//  Struct for SPI_GETMOUSE.
//
typedef struct tag_GetMouse
{
    int Thresh1;
    int Thresh2;
    int Speed;
} GETMOUSE, *LPGETMOUSE;


//
//  Dialog Data.
//
typedef struct tag_MouseGenStr
{
    GETMOUSE  gmOrig;
    GETMOUSE  gmNew;

    short     nSpeed;
    short     nOrigSpeed;

    int       nSensitivity;
    int       nOrigSensitivity;

#ifndef NO_MOUSETRAILS       // Mouse Trails are not implemented on NT
    short     nTrailSize;
    short     nOrigTrailSize;

    HWND      hWndTrailScroll;
#endif

    BOOL      fOrigSnapTo;

    HWND      hWndSpeedScroll;
    HWND      hDlg;

} MOUSEPTRSTR, *PMOUSEPTRSTR, *LPMOUSEPTRSTR;




//
//  Context Help Ids.
//

const DWORD aMouseMoveHelpIds[] =
{
    IDC_GROUPBOX_1,         IDH_DLGMOUSE_POINTMO,
    IDC_GROUPBOX_2,         IDH_COMM_GROUPBOX,
    MOUSE_SPEEDBMP,         NO_HELP,
    MOUSE_SPEEDSCROLL,      IDH_DLGMOUSE_POINTMO,
    IDC_GROUPBOX_3,         IDH_DLGMOUSE_ACCELERATION,
    MOUSE_ACCELNONE,        IDH_DLGMOUSE_ACCELERATION,
    MOUSE_ACCELLOW,         IDH_DLGMOUSE_ACCELERATION,
    MOUSE_ACCELMEDIUM,      IDH_DLGMOUSE_ACCELERATION,
    MOUSE_ACCELHIGH,        IDH_DLGMOUSE_ACCELERATION,
    MOUSE_PTRTRAIL,         NO_HELP,
    MOUSE_TRAILS,           IDH_DLGMOUSE_SHOWTRAIL,
    MOUSE_TRAILSCROLLTXT1,  IDH_DLGMOUSE_TRAILLENGTH,
    MOUSE_TRAILSCROLLTXT2,  IDH_DLGMOUSE_TRAILLENGTH,
    MOUSE_TRAILSCROLL,      IDH_DLGMOUSE_TRAILLENGTH,
    MOUSE_PTRSNAPDEF,       NO_HELP,
    IDC_GROUPBOX_4,         IDH_DLGMOUSE_SNAPDEF,
    MOUSE_SNAPDEF,          IDH_DLGMOUSE_SNAPDEF,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  DestroyMousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMousePtrDlg(
    PMOUSEPTRSTR pMstr)
{
    HWND hDlg;

    Assert( pMstr )

    if( pMstr )
    {
        hDlg = pMstr->hDlg;

        LocalFree( (HGLOBAL)pMstr );

        SetWindowLongPtr( hDlg, DWLP_USER, 0 );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableTrailScroll
//
////////////////////////////////////////////////////////////////////////////

#ifndef NO_MOUSETRAILS   // Mouse Trails are not implemented on NT
void EnableTrailScroll(
    HWND hDlg,
    BOOL val)
{
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLL), val);
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLLTXT1), val);
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLLTXT2), val);
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  InitMousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitMousePtrDlg(
    HWND hDlg)
{
    PMOUSEPTRSTR pMstr;
    BOOL fSnapTo;

    pMstr = (PMOUSEPTRSTR)LocalAlloc(LPTR, sizeof(MOUSEPTRSTR));

    if (pMstr == NULL)
    {
        return (TRUE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;

#ifndef NO_MOUSETRAILS   // Mouse trails are not implemented on NT
    //
    //  Enable or disable the Mouse Trails Checkbutton.
    //
    if (SystemParametersInfo(SPI_GETMOUSETRAILS, 0, &pMstr->nTrailSize, 0))
    {
        pMstr->nOrigTrailSize = pMstr->nTrailSize;

        EnableWindow(GetDlgItem(hDlg,MOUSE_TRAILS), TRUE);

        SendDlgItemMessage( hDlg,
                            MOUSE_TRAILSCROLL,
                            TBM_SETRANGE,
                            0,
                            MAKELONG(TRAILMIN, TRAILMAX) );

        CheckDlgButton(hDlg, MOUSE_TRAILS, (pMstr->nTrailSize > 1));

        if (pMstr->nTrailSize > 1)
        {
            SendDlgItemMessage( hDlg,
                                MOUSE_TRAILSCROLL,
                                TBM_SETPOS,
                                TRUE,
                                (LONG)pMstr->nTrailSize );
        }
        else
        {
            pMstr->nTrailSize = TRAILMAX;

            EnableTrailScroll(hDlg, FALSE);

            SendDlgItemMessage( hDlg,
                                MOUSE_TRAILSCROLL,
                                TBM_SETPOS,
                                TRUE,
                                (LONG)pMstr->nTrailSize );
        }
    }
    else
    {
        CheckDlgButton(hDlg, MOUSE_TRAILS, FALSE);

        EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILS), FALSE);

        EnableTrailScroll(hDlg, FALSE);
    }
#endif

    //
    // Enable or disable the Snap To Default Checkbutton
    //
    if (SystemParametersInfo(SPI_GETSNAPTODEFBUTTON, 0, (PVOID)&fSnapTo, FALSE))
    {
        pMstr->fOrigSnapTo = fSnapTo;
    }
    CheckDlgButton(hDlg, MOUSE_SNAPDEF, fSnapTo);

    SystemParametersInfo(SPI_GETMOUSE, 0, &pMstr->gmNew, FALSE);

    SystemParametersInfo(SPI_GETMOUSESPEED, 0, &pMstr->nOrigSensitivity, FALSE);
    if ((pMstr->nOrigSensitivity < 1) || (pMstr->nOrigSensitivity > 20))
    {
        pMstr->nOrigSensitivity = 10;
    }
    pMstr->nSensitivity = pMstr->nOrigSensitivity;

    pMstr->gmOrig.Thresh1 = pMstr->gmNew.Thresh1;
    pMstr->gmOrig.Thresh2 = pMstr->gmNew.Thresh2;
    pMstr->gmOrig.Speed   = pMstr->gmNew.Speed;
    if (pMstr->gmOrig.Speed == 0)
    {
        CheckRadioButton(hDlg, MOUSE_ACCELNONE, MOUSE_ACCELHIGH, MOUSE_ACCELNONE);
    }
    else if (pMstr->gmOrig.Speed == 1)
    {
        CheckRadioButton(hDlg, MOUSE_ACCELNONE, MOUSE_ACCELHIGH, MOUSE_ACCELLOW);
    }
    else if ((pMstr->gmOrig.Speed == 2) && (pMstr->gmOrig.Thresh2 >= 9))
    {
        CheckRadioButton(hDlg, MOUSE_ACCELNONE, MOUSE_ACCELHIGH, MOUSE_ACCELMEDIUM);
    }
    else
    {
        CheckRadioButton(hDlg, MOUSE_ACCELNONE, MOUSE_ACCELHIGH, MOUSE_ACCELHIGH);
    }

#ifndef NO_MOUSETRAILS       // Mouse Trails are not implemented on NT
    pMstr->hWndTrailScroll = GetDlgItem(hDlg, MOUSE_TRAILSCROLL);
#endif
    pMstr->hWndSpeedScroll = GetDlgItem(hDlg, MOUSE_SPEEDSCROLL);

    //
    //  0 Acc               = 4
    //  1 Acc, 5 xThreshold = 5
    //  1 Acc, 4 xThreshold = 6
    //  1 Acc, 3 xThreshold = 7
    //  1 Acc, 2 xThreshold = 8
    //  1 Acc, 1 xThreshold = 9
    //  2 Acc, 5 xThreshold = 10
    //  2 Acc, 4 xThreshold = 11
    //  2 Acc, 3 xThreshold = 12
    //  2 Acc, 2 xThreshold = 13
    //

    pMstr->nOrigSpeed = pMstr->nSpeed = ACCELMIN;

    if (pMstr->gmNew.Speed == 2)
    {
        pMstr->nSpeed += (24 - pMstr->gmNew.Thresh2) / 3;
    }
    else if (pMstr->gmNew.Speed == 1)
    {
        pMstr->nSpeed += (13 - pMstr->gmNew.Thresh1) / 3;
    }

    pMstr->nOrigSpeed = pMstr->nSpeed;

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETRANGE,
                        0,
                        MAKELONG(0, 10) );

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETPOS,
                        TRUE,
                        (LONG)pMstr->nOrigSensitivity / 2 );

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrailScroll
//
////////////////////////////////////////////////////////////////////////////

#ifndef NO_MOUSETRAILS
void TrailScroll(
    WPARAM wParam,
    LPARAM lParam,
    PMOUSEPTRSTR pMstr)
{
    pMstr->nTrailSize = (int)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L);
    SystemParametersInfo(SPI_SETMOUSETRAILS, pMstr->nTrailSize, 0, 0);
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  SpeedScroll
//
////////////////////////////////////////////////////////////////////////////

void SpeedScroll(
    WPARAM wParam,
    LPARAM lParam,
    PMOUSEPTRSTR pMstr)
{
    pMstr->nSensitivity = (int)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L) * 2;
    if (!pMstr->nSensitivity)
    {
        pMstr->nSensitivity = 1;
    }

    //
    //  Update speed when they let go of the thumb.
    //
    if (LOWORD(wParam) == SB_ENDSCROLL)
    {
        SystemParametersInfo( SPI_SETMOUSESPEED,
                              0,
                              (PVOID)pMstr->nSensitivity,
                              SPIF_SENDCHANGE );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseMovDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseMovDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSEPTRSTR pMstr;
    BOOL bRet;
    BOOL fSnapTo;

    pMstr = (PMOUSEPTRSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            bRet = InitMousePtrDlg(hDlg);
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyMousePtrDlg(pMstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

            if ((HWND)lParam == pMstr->hWndSpeedScroll)
            {
                SpeedScroll(wParam, lParam, pMstr);
            }
#ifndef NO_MOUSETRAILS       // Mouse Trails are not implemented on NT
            else if ((HWND)lParam == pMstr->hWndTrailScroll)
            {
                TrailScroll(wParam, lParam, pMstr);
            }
#endif
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
#ifndef NO_MOUSETRAILS       // Mouse Trails are not implemented on NT
                case ( MOUSE_TRAILS ) :
                {
                    if (IsDlgButtonChecked(hDlg, MOUSE_TRAILS))
                    {
                        EnableTrailScroll(hDlg, TRUE);

                        pMstr->nTrailSize =
                            (int)SendMessage( pMstr->hWndTrailScroll,
                                              TBM_GETPOS,
                                              0,
                                              0 );

                        SystemParametersInfo( SPI_SETMOUSETRAILS,
                                              pMstr->nTrailSize,
                                              0,
                                              0 );
                    }
                    else
                    {
                        EnableTrailScroll(hDlg, FALSE);
                        SystemParametersInfo(SPI_SETMOUSETRAILS, 0, 0, 0);
                    }
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }
#endif
                case ( MOUSE_SNAPDEF ) :
                {
                    SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                          IsDlgButtonChecked(hDlg, MOUSE_SNAPDEF),
                                          0,
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }
                case ( MOUSE_ACCELNONE ) :
                {
                    pMstr->gmNew.Speed   = 0;
                    pMstr->gmNew.Thresh1 = 0;
                    pMstr->gmNew.Thresh2 = 0;
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                    SystemParametersInfo(SPI_SETMOUSE, 0, &pMstr->gmNew, FALSE);
                    break;
                }
                case ( MOUSE_ACCELLOW ) :
                {
                    pMstr->gmNew.Speed   = 1;
                    pMstr->gmNew.Thresh1 = 7;
                    pMstr->gmNew.Thresh2 = 0;
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                    SystemParametersInfo(SPI_SETMOUSE, 0, &pMstr->gmNew, FALSE);
                    break;
                }
                case ( MOUSE_ACCELMEDIUM ) :
                {
                    pMstr->gmNew.Speed   = 2;
                    pMstr->gmNew.Thresh1 = 4;
                    pMstr->gmNew.Thresh2 = 12;
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                    SystemParametersInfo(SPI_SETMOUSE, 0, &pMstr->gmNew, FALSE);
                    break;
                }
                case ( MOUSE_ACCELHIGH ) :
                {
                    pMstr->gmNew.Speed   = 2;
                    pMstr->gmNew.Thresh1 = 4;
                    pMstr->gmNew.Thresh2 = 6;
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                    SystemParametersInfo(SPI_SETMOUSE, 0, &pMstr->gmNew, FALSE);
                    break;
                }
            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    //
                    //  Change cursor to hour glass.
                    //
                    HourGlass(TRUE);

#ifndef NO_MOUSETRAILS       // Mouse Trails are not implemented on NT.
                    //
                    //  Support mouse trails.
                    //
                    if (IsWindowEnabled(GetDlgItem(hDlg, MOUSE_TRAILS)))
                    {
                        if (IsDlgButtonChecked(hDlg, MOUSE_TRAILS))
                        {
                            SystemParametersInfo( SPI_SETMOUSETRAILS,
                                                  pMstr->nTrailSize,
                                                  0,
                                                  SPIF_UPDATEINIFILE |
                                                    SPIF_SENDCHANGE );
                        }
                        else
                        {
                            SystemParametersInfo( SPI_SETMOUSETRAILS,
                                                  0,
                                                  0,
                                                  SPIF_UPDATEINIFILE |
                                                    SPIF_SENDCHANGE );
                            pMstr->nTrailSize = 0;
                        }

                        //
                        //  New original once applied.
                        //
                        pMstr->nOrigTrailSize = pMstr->nTrailSize;
                    }
#endif
                    //
                    //  Support snap to default.
                    //
                    if (IsWindowEnabled(GetDlgItem(hDlg, MOUSE_SNAPDEF)))
                    {
                        fSnapTo = IsDlgButtonChecked(hDlg, MOUSE_SNAPDEF);

                        if (fSnapTo != pMstr->fOrigSnapTo)
                        {
                            SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                                  fSnapTo,
                                                  0,
                                                  SPIF_UPDATEINIFILE |
                                                    SPIF_SENDCHANGE );
                        }

                        //
                        //  New original once applied.
                        //
                        pMstr->fOrigSnapTo = fSnapTo;
                    }

                    //
                    //  Apply mouse speed.
                    //
                    SystemParametersInfo( SPI_SETMOUSESPEED,
                                          0,
                                          (PVOID)pMstr->nSensitivity,
                                          SPIF_UPDATEINIFILE | SPIF_SENDCHANGE );
                    pMstr->nOrigSensitivity = pMstr->nSensitivity;

                    //
                    //  Apply mouse acceleration.
                    //
                    SystemParametersInfo( SPI_SETMOUSE,
                                          0,
                                          &pMstr->gmNew,
                                          SPIF_UPDATEINIFILE | SPIF_SENDCHANGE );
                    pMstr->gmOrig = pMstr->gmNew;


                    HourGlass(FALSE);
                    break;
                }
                case ( PSN_RESET ) :
                {
#ifndef NO_MOUSETRAILS       // Mouse Trails are not implemented on NT
                    //
                    //  Support mouse trails.
                    //
                    if (IsWindowEnabled(GetDlgItem(hDlg, MOUSE_TRAILS)))
                    {
                        pMstr->nTrailSize = pMstr->nOrigTrailSize;

                        SystemParametersInfo( SPI_SETMOUSETRAILS,
                                              pMstr->nTrailSize,
                                              0,
                                              0 );
                    }
#endif
                    //
                    //  Support snap to default.
                    //
                    if (IsWindowEnabled(GetDlgItem(hDlg, MOUSE_SNAPDEF)))
                    {
                        CheckDlgButton(hDlg, MOUSE_SNAPDEF, pMstr->fOrigSnapTo);

                        SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                              pMstr->fOrigSnapTo,
                                              0,
                                              0 );
                    }

                    SystemParametersInfo( SPI_SETMOUSE,
                                          0,
                                          &pMstr->gmOrig,
                                          FALSE );

                    //
                    //  Restore the original mouse sensitivity.
                    //
                    SystemParametersInfo( SPI_SETMOUSESPEED,
                                          0,
                                          (PVOID)pMstr->nOrigSensitivity,
                                          FALSE );
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseMoveHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseMoveHelpIds );
            break;
        }

        case ( WM_DISPLAYCHANGE ) :
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            return TRUE;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\util.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module contains the header information for the utility routines
    for this project.

Revision History:

--*/



#ifndef _UTIL_H
#define _UTIL_H



void
HourGlass(
    BOOL fOn);

int
MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...);

void
TrackInit(
    HWND hwndScroll,
    int nCurrent,
    PARROWVSCROLL pAVS);

int
TrackMessage(
    WPARAM wParam,
    LPARAM lParam,
    PARROWVSCROLL pAVS);

typedef struct HWPAGEINFO {
    GUID    guidClass;                  // Setup device class
    UINT    idsTshoot;                  // Troubleshooter string
} HWPAGEINFO, *PHWPAGEINFO;
typedef const HWPAGEINFO *PCHWPAGEINFO;

HPROPSHEETPAGE
CreateHardwarePage(PCHWPAGEINFO phpi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mousebut.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousebut.c

Abstract:

    This module contains the routines for the Mouse Buttons Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousectl.h"
#include <regstr.h>
#include <winerror.h>        // needed for ERROR_SUCCESS value
#include "mousehlp.h"




//
//  Global Variables.
//

const TCHAR szYes[]          = TEXT("yes");
const TCHAR szNo[]           = TEXT("no");
const TCHAR szDblClkSpeed[]  = TEXT("DoubleClickSpeed");
const TCHAR szRegStr_Mouse[] = REGSTR_PATH_MOUSE;




//
//  Constant Declarations.
//

//
//  SwapMouseButtons takes:
//      TRUE to make it a right mouse
//      FALSE to make it a left mouse
//
#define RIGHT       TRUE
#define LEFT        FALSE

#define CLICKMIN    100      // milliseconds
#define CLICKMAX    900
#define CLICKSUM    (CLICKMIN + CLICKMAX)
#define CLICKRANGE  (CLICKMAX - CLICKMIN)

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define Assert(f)


//
//  Typedef Declarations.
//

typedef struct tag_MouseGenStr
{
    BOOL bSwap;
    BOOL bOrigSwap;

    short ClickSpeed;
    short OrigDblClkSpeed;

    HWND hWndDblClkScroll;
    HWND hDlg;                    // HWND hMouseButDlg;

    RECT OrigRect;
    RECT DblClkRect;

    POINT ObjectPoint;
    POINT SelectPoint;

    int jackstate, jackhits;      // for jack-in-the-box control
    int jackignore;               // for jack-in-the-box control

    BOOL bShellSingleClick,
         bOrigShellSingleClick ;

    HICON hIconSglClick,
          hIconDblClick ;

} MOUSEBUTSTR, *PMOUSEBUTSTR, *LPMOUSEBUTSTR;

//
//  Context Help Ids.
//

const DWORD aMouseButHelpIds[] =
{
    IDC_GROUPBOX_1,     IDH_COMM_GROUPBOX,
    IDC_GROUPBOX_2,     IDH_DLGMOUSE_HANDED_PIC,
    IDC_GROUPBOX_3,     IDH_DLGMOUSE_HANDED_PIC,
    IDC_GROUPBOX_4,     IDH_COMM_GROUPBOX,
    IDC_SELECTDRAG,     IDH_DLGMOUSE_HANDED_PIC,
    IDC_OBJECTMENU,     IDH_DLGMOUSE_HANDED_PIC,
    MOUSE_LEFTHAND,     IDH_DLGMOUSE_LEFT,
    MOUSE_RIGHTHAND,    IDH_DLGMOUSE_RIGHT,
    MOUSE_SELECTBMP,    IDH_DLGMOUSE_HANDED_PIC,
    MOUSE_MOUSEBMP,     IDH_DLGMOUSE_HANDED_PIC,
    MOUSE_MENUBMP,      IDH_DLGMOUSE_HANDED_PIC,
    MOUSE_CLICKSCROLL,  IDH_DLGMOUSE_DOUBCLICK,
    IDC_GROUPBOX_5,     IDH_DLGMOUSE_DCLICK_PIC,
    MOUSE_DBLCLKBMP,    IDH_DLGMOUSE_DCLICK_PIC,
    MOUSE_SGLCLICK,     IDH_MOUSE_SGLCLICK,
    MOUSE_DBLCLICK,     IDH_MOUSE_DBLCLICK,
    0, 0
};


//
//  helper function prototypes
//
void ShellClick_UpdateUI( HWND hDlg, PMOUSEBUTSTR pMstr) ;
void ShellClick_Refresh( PMOUSEBUTSTR pMstr ) ;


//
//  Debug Info.
//

#ifdef DEBUG

#define REG_INTEGER  1000

int fTraceRegAccess = 0;

void RegDetails(
    int     iWrite,
    HKEY    hk,
    LPCTSTR lpszSubKey,
    LPCTSTR lpszValueName,
    DWORD   dwType,
    LPTSTR  lpszString,
    int     iValue)
{
    TCHAR Buff[256];
    TCHAR *lpszReadWrite[] = { TEXT("DESK.CPL:Read"), TEXT("DESK.CPL:Write") };

    if (!fTraceRegAccess)
    {
        return;
    }

    switch (dwType)
    {
        case ( REG_SZ ) :
        {
            wsprintf( Buff,
                      TEXT("%s String:hk=%#08lx, %s:%s=%s\n\r"),
                      lpszReadWrite[iWrite],
                      hk,
                      lpszSubKey,
                      lpszValueName,
                      lpszString );
            break;
        }
        case ( REG_INTEGER ) :
        {
            wsprintf( Buff,
                      TEXT("%s int:hk=%#08lx, %s:%s=%d\n\r"),
                      lpszReadWrite[iWrite],
                      hk,
                      lpszSubKey,
                      lpszValueName,
                      iValue );
            break;
        }
        case ( REG_BINARY ) :
        {
            wsprintf( Buff,
                      TEXT("%s Binary:hk=%#08lx, %s:%s=%#0lx;DataSize:%d\r\n"),
                      lpszReadWrite[iWrite],
                      hk,
                      lpszSubKey,
                      lpszValueName,
                      lpszString,
                      iValue );
            break;
        }
    }
    OutputDebugString(Buff);
}

#endif  // DEBUG





////////////////////////////////////////////////////////////////////////////
//
//  GetIntFromSubKey
//
//  hKey is the handle to the subkey (already pointing to the proper
//  location.
//
////////////////////////////////////////////////////////////////////////////

int GetIntFromSubkey(
    HKEY hKey,
    LPCTSTR lpszValueName,
    int iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = sizeof(szValue);
    DWORD dwType;
    int iRetValue = iDefault;

    if ((RegQueryValueEx( hKey,
                          (LPTSTR)lpszValueName,
                          NULL,
                          &dwType,
                          (LPBYTE)szValue,
                          &dwSizeofValueBuff ) == ERROR_SUCCESS) &&
        (dwSizeofValueBuff))
    {
        //
        //  BOGUS: This handles only the string type entries now!
        //
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToLong(szValue);
        }
#ifdef DEBUG
        else
        {
            OutputDebugString(TEXT("String type expected from Registry\n\r"));
        }
#endif
    }

#ifdef DEBUG
    RegDetails(0, hKey, TEXT(""), lpszValueName, REG_INTEGER, NULL, iRetValue);
#endif

    return (iRetValue);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetIntFromReg
//
//  Opens the given subkey and gets the int value.
//
////////////////////////////////////////////////////////////////////////////

int GetIntFromReg(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszNameValue,
    int iDefault)
{
    HKEY hk;
    int iRetValue = iDefault;

    //
    //  See if the key is present.
    //
    if (RegOpenKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
        iRetValue = GetIntFromSubkey(hk, lpszNameValue, iDefault);
        RegCloseKey(hk);
    }

    return (iRetValue);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringFromReg
//
//  Opens the given subkey and gets the string value.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetStringFromReg(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszValueName,
    LPCTSTR lpszDefault,
    LPTSTR lpszValue,
    DWORD dwSizeofValueBuff)
{
    HKEY hk;
    DWORD dwType;
    BOOL fSuccess = FALSE;

    //
    //  See if the key is present.
    //
    if (RegOpenKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx( hk,
                              (LPTSTR)lpszValueName,
                              NULL,
                              &dwType,
                              (LPBYTE)lpszValue,
                              &dwSizeofValueBuff ) == ERROR_SUCCESS) &&
            (dwSizeofValueBuff))
        {
            //
            //  BOGUS: This handles only the string type entries now!
            //
#ifdef DEBUG
            if (dwType != REG_SZ)
            {
                OutputDebugString(TEXT("String type expected from Registry\n\r"));
            }
            else
#endif
            fSuccess = TRUE;
        }
        RegCloseKey(hk);
    }

    //
    //  If failure, use the default string.
    //
    if (!fSuccess)
    {
        lstrcpy(lpszValue, lpszDefault);
    }

#ifdef DEBUG
    RegDetails(0, hKey, lpszSubkey, lpszValueName, REG_SZ, lpszValue, 0);
#endif

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateRegistry
//
//  This updates a given value of any data type at a given location in
//  the registry.
//
//  The value name is passed in as an Id to a string in USER's String
//  table.
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateRegistry(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszValueName,
    DWORD dwDataType,
    LPVOID lpvData,
    DWORD dwDataSize)
{
    HKEY hk;

    if (RegCreateKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
        RegSetValueEx( hk,
                       (LPTSTR)lpszValueName,
                       0,
                       dwDataType,
                       (LPBYTE)lpvData,
                       dwDataSize );
#ifdef DEBUG
        RegDetails(1, hKey, lpszSubkey, lpszValueName, dwDataType, lpvData, (int)dwDataSize);
#endif

        RegCloseKey(hk);
        return (TRUE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ShowButtonState
//
//  Swaps the menu and selection bitmaps.
//
////////////////////////////////////////////////////////////////////////////

void ShowButtonState(
    PMOUSEBUTSTR pMstr)
{
    HWND hDlg;

    Assert(pMstr);

    hDlg = pMstr->hDlg;

    MouseControlSetSwap(GetDlgItem(hDlg, MOUSE_MOUSEBMP), pMstr->bSwap);

    SetWindowPos( GetDlgItem(hDlg, pMstr->bSwap ? IDC_SELECTDRAG : IDC_OBJECTMENU),
                  NULL,
                  pMstr->ObjectPoint.x,
                  pMstr->ObjectPoint.y,
                  0,
                  0,
                  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER );

    SetWindowPos( GetDlgItem(hDlg, !pMstr->bSwap ? IDC_SELECTDRAG : IDC_OBJECTMENU),
                  NULL,
                  pMstr->SelectPoint.x,
                  pMstr->SelectPoint.y,
                  0,
                  0,
                  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER );

    CheckDlgButton(hDlg, MOUSE_RIGHTHAND, !pMstr->bSwap);
    CheckDlgButton(hDlg, MOUSE_LEFTHAND, pMstr->bSwap);

    CheckDlgButton(hDlg, MOUSE_SGLCLICK, pMstr->bShellSingleClick);
    CheckDlgButton(hDlg, MOUSE_DBLCLICK, !pMstr->bShellSingleClick);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseButDlg
//
////////////////////////////////////////////////////////////////////////////
#define SAFE_DESTROYICON(hicon)   if (hicon) { DestroyIcon(hicon); hicon=NULL; }

void DestroyMouseButDlg(
    PMOUSEBUTSTR pMstr)
{
    if (pMstr)
    {
        SAFE_DESTROYICON( pMstr->hIconSglClick ) ;
        SAFE_DESTROYICON( pMstr->hIconDblClick )

        SetWindowLongPtr(pMstr->hDlg, DWLP_USER, 0);
        LocalFree((HGLOBAL)pMstr);
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  Jack stuff -- code to manage the jack-in-the-box double-click testbox.
//
////////////////////////////////////////////////////////////////////////////

typedef struct
{
    int first;          // first frame of state
    int last;           // last frame of state
    int repeat;         // state's repeat count
} JACKSTATE;

#define JACK_OPPOSITE_STATE     (-2)
#define JACK_NEXT_STATE         (-1)

#define JACK_CRANKING           ( 0)
#define JACK_OPENING            ( 1)
#define JACK_BOUNCING           ( 2)
#define JACK_CLOSING            ( 3)

//
//  NOTE: Every state starts with a key frame in the AVI file.
//

JACKSTATE JackFSA[] =
{
    {  0,  7, -1 },     // cranking
    {  8, 12,  1 },     // opening
    { 16, 23, -1 },     // bouncing
    { 24, 27,  1 },     // closing
};

#define JACK_NUM_STATES     (sizeof(JackFSA) / sizeof(JACKSTATE))


////////////////////////////////////////////////////////////////////////////
//
//  JackSetState
//
////////////////////////////////////////////////////////////////////////////

void JackSetState(
    HWND dlg,
    PMOUSEBUTSTR mstr,
    int index)
{
    JACKSTATE *state;

    switch (index)
    {
        case ( JACK_OPPOSITE_STATE ) :
        {
            mstr->jackstate++;

            // fall thru...
        }
        case ( JACK_NEXT_STATE ) :
        {
            index = mstr->jackstate + 1;
        }
    }

    index %= JACK_NUM_STATES;

    state = JackFSA + index;

    mstr->jackstate = index;

    mstr->jackignore++;

    Animate_Play( GetDlgItem(dlg, MOUSE_DBLCLKBMP),
                  state->first,
                  state->last,
                  state->repeat );
}


////////////////////////////////////////////////////////////////////////////
//
//  JackClicked
//
////////////////////////////////////////////////////////////////////////////

void JackClicked(
    HWND dlg,
    PMOUSEBUTSTR mstr)
{
    JACKSTATE *state = JackFSA + mstr->jackstate;

    if (state->repeat < 0)
    {
        JackSetState(dlg, mstr, JACK_NEXT_STATE);
    }
    else
    {
        mstr->jackhits++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  JackStopped
//
////////////////////////////////////////////////////////////////////////////

void JackStopped(
    HWND dlg,
    PMOUSEBUTSTR mstr)
{
    if (--mstr->jackignore < 0)
    {
        JACKSTATE *state = JackFSA + mstr->jackstate;

        if (state->repeat > 0)
        {
            int index;

            if (mstr->jackhits)
            {
                mstr->jackhits--;
                index = JACK_OPPOSITE_STATE;
            }
            else
            {
                index = JACK_NEXT_STATE;
            }

            JackSetState(dlg, mstr, index);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  JackStart
//
////////////////////////////////////////////////////////////////////////////

void JackStart(
    HWND dlg,
    PMOUSEBUTSTR mstr)
{
    mstr->jackhits = 0;
    mstr->jackstate = 0;
    mstr->jackignore = -1;

    Animate_Open( GetDlgItem(dlg, MOUSE_DBLCLKBMP),
                  MAKEINTRESOURCE(IDA_JACKNBOX) );

    JackSetState(dlg, mstr, JACK_CRANKING);
}

////////////////////////////////////////////////////////////////////////////
//
//  InitMouseButDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitMouseButDlg(
    HWND hDlg)
{
    POINT        Origin;
    SHELLSTATE   shellstate = {0} ;
    PMOUSEBUTSTR pMstr;
    RECT         TmpRect;
    HINSTANCE    hInstDlg = (HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ) ;

    pMstr = (PMOUSEBUTSTR)LocalAlloc(LPTR , sizeof(MOUSEBUTSTR));

    if (pMstr == NULL)
    {
        return (TRUE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;

    Origin.x = Origin.y = 0;
    ClientToScreen(hDlg, (LPPOINT)&Origin);

    GetWindowRect(hDlg, &pMstr->OrigRect);

    pMstr->OrigRect.left -= Origin.x;
    pMstr->OrigRect.right -= Origin.x;

    GetWindowRect(GetDlgItem(hDlg, MOUSE_DBLCLKBMP), &pMstr->DblClkRect);

    pMstr->DblClkRect.top    -= Origin.y;
    pMstr->DblClkRect.bottom -= Origin.y;
    pMstr->DblClkRect.left   -= Origin.x;
    pMstr->DblClkRect.right  -= Origin.x;

    //
    //  Find position of Select and Object windows.
    //
    GetWindowRect(GetDlgItem(hDlg, IDC_SELECTDRAG), &TmpRect);

    ScreenToClient(hDlg, (POINT *)&TmpRect);

    pMstr->SelectPoint.x = TmpRect.left;
    pMstr->SelectPoint.y = TmpRect.top;

    GetWindowRect(GetDlgItem(hDlg, IDC_OBJECTMENU), &TmpRect);

    ScreenToClient(hDlg, (POINT *)&TmpRect);

    pMstr->ObjectPoint.x = TmpRect.left;
    pMstr->ObjectPoint.y = TmpRect.top;

    //
    //  Set (and get), then restore the state of the mouse buttons.
    //
    (pMstr->bOrigSwap) = (pMstr->bSwap) = SwapMouseButton(TRUE);

    SwapMouseButton(pMstr->bOrigSwap);

    //
    //  Get shell single-click behavior:
    //
    SHGetSetSettings( &shellstate, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC, FALSE /*get*/ ) ;
    pMstr->bShellSingleClick =
    pMstr->bOrigShellSingleClick =  shellstate.fWin95Classic ? FALSE :
                                    shellstate.fDoubleClickInWebView ? FALSE :
                                    TRUE ;
    pMstr->hIconSglClick = LoadIcon( hInstDlg, MAKEINTRESOURCE( IDI_SGLCLICK ) ) ;
    pMstr->hIconDblClick = LoadIcon( hInstDlg, MAKEINTRESOURCE( IDI_DBLCLICK ) ) ;
    ShellClick_UpdateUI( hDlg, pMstr ) ;

    //
    //  Initialize check/radio button state
    //
    ShowButtonState(pMstr);

    pMstr->OrigDblClkSpeed =
    pMstr->ClickSpeed = (SHORT) GetIntFromReg( HKEY_CURRENT_USER,
                                       szRegStr_Mouse,
                                       szDblClkSpeed,
                                       CLICKMIN + (CLICKRANGE / 2) );

    pMstr->hWndDblClkScroll = GetDlgItem(hDlg, MOUSE_CLICKSCROLL);

    SendMessage( pMstr->hWndDblClkScroll,
                 TBM_SETRANGE,
                 0,
                 MAKELONG(CLICKMIN, CLICKMAX) );
    SendMessage( pMstr->hWndDblClkScroll,
                 TBM_SETPOS,
                 TRUE,
                 (LONG)(CLICKMIN + CLICKMAX - pMstr->ClickSpeed) );

    SetDoubleClickTime(pMstr->ClickSpeed);

    JackStart(hDlg, pMstr);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseButDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseButDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSEBUTSTR pMstr = (PMOUSEBUTSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            return (InitMouseButDlg(hDlg));
        }
        case ( WM_DESTROY ) :
        {
            DestroyMouseButDlg(pMstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            if ((HWND)lParam == pMstr->hWndDblClkScroll)
            {
                short temp = CLICKMIN + CLICKMAX -
                             (short)SendMessage( (HWND)lParam,
                                                 TBM_GETPOS,
                                                 0,
                                                 0L );

                if (temp != pMstr->ClickSpeed)
                {
                    pMstr->ClickSpeed = temp;

                    SetDoubleClickTime(pMstr->ClickSpeed);

                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                }
            }
            break;
        }
        case ( WM_RBUTTONDBLCLK ) :
        case ( WM_LBUTTONDBLCLK ) :
        {
            POINT point = { (int)MAKEPOINTS(lParam).x,
                            (int)MAKEPOINTS(lParam).y };

            if (PtInRect(&pMstr->DblClkRect, point))
            {
                JackClicked(hDlg, pMstr);
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( MOUSE_LEFTHAND ) :
                {
                    if (pMstr->bSwap != RIGHT)
                    {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

                        pMstr->bSwap = RIGHT;

                        ShowButtonState(pMstr);
                    }
                    break;
                }
                case ( MOUSE_RIGHTHAND ) :
                {
                    if (pMstr->bSwap != LEFT)
                    {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

                        pMstr->bSwap = LEFT;

                        ShowButtonState(pMstr);
                    }
                    break;
                }
                case ( MOUSE_DBLCLKBMP ) :
                {
                    if (HIWORD(wParam) == ACN_STOP)
                    {
                        JackStopped(hDlg, pMstr);
                    }
                    break;
                }
                case ( MOUSE_SGLCLICK ) :
                case ( MOUSE_DBLCLICK ) :
                {
                    if( pMstr->bShellSingleClick != (MOUSE_SGLCLICK == LOWORD(wParam)) )
                    {
                        pMstr->bShellSingleClick = (MOUSE_SGLCLICK == LOWORD(wParam)) ;
                        ShellClick_UpdateUI( hDlg, pMstr ) ;
                        SendMessage( GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L ) ;
                    }
                    break ;
                }


            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    HourGlass(TRUE);

                    if (pMstr->bSwap != pMstr->bOrigSwap)
                    {
                        SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                                              pMstr->bSwap,
                                              NULL,
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );

                        pMstr->bOrigSwap = pMstr->bSwap;
                    }

                    if (pMstr->ClickSpeed != pMstr->OrigDblClkSpeed)
                    {
                        SystemParametersInfo( SPI_SETDOUBLECLICKTIME,
                                              pMstr->ClickSpeed,
                                              NULL,
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );

                        pMstr->OrigDblClkSpeed = pMstr->ClickSpeed;
                    }


                    if( pMstr->bOrigShellSingleClick != pMstr->bShellSingleClick )
                    {
                        SHELLSTATE shellstate = {0} ;
                        ULONG      dwFlags = SSF_DOUBLECLICKINWEBVIEW ;

                        shellstate.fWin95Classic =
                        shellstate.fDoubleClickInWebView = !pMstr->bShellSingleClick ;

                        // update the WIN95CLASSIC member only if we've chosen single-click.
                        if( pMstr->bShellSingleClick )
                            dwFlags |= SSF_WIN95CLASSIC ;

                        SHGetSetSettings( &shellstate, dwFlags, TRUE ) ;
                        ShellClick_Refresh( pMstr ) ;

                        pMstr->bOrigShellSingleClick = pMstr->bShellSingleClick ;
                    }

                    HourGlass(FALSE);
                    break;
                }
                case ( PSN_RESET ) :
                {
                    SetDoubleClickTime(pMstr->OrigDblClkSpeed);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND) wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
            break;
        }

        case ( WM_DISPLAYCHANGE ) :
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            return TRUE;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_UpdateUI
//
//  Assigns the appropriate icon for shell single/double click
//
////////////////////////////////////////////////////////////////////////////
void ShellClick_UpdateUI(
    HWND hDlg,
    PMOUSEBUTSTR pMstr)
{
    HICON hicon = pMstr->bShellSingleClick ? pMstr->hIconSglClick :
                                             pMstr->hIconDblClick ;

    SendMessage( GetDlgItem( hDlg, MOUSE_CLICKICON ), STM_SETICON,
                 (WPARAM)hicon, 0L ) ;
}

////////////////////////////////////////////////////////////////////////////
//
//  IsShellWindow
//
//  Determines whether the specified window is a shell folder window.
//
////////////////////////////////////////////////////////////////////////////
#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif

BOOL IsShellWindow( HWND hwnd )
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) ||
           (lstrcmp(szClass, c_szExploreClass) == 0) ||
           (lstrcmp(szClass, c_szIExploreClass) == 0) ;
}

//The following value is taken from shdocvw\rcids.h
#ifndef FCIDM_REFRESH
#define FCIDM_REFRESH  0xA220
#endif // FCIDM_REFRESH

////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_RefreshEnumProc
//
//  EnumWindow callback for shell refresh.
//
////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ShellClick_RefreshEnumProc( HWND hwnd, LPARAM lParam )
{
    if( IsShellWindow(hwnd) )
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_Refresh
//
//  Re-renders the contents of all shell folder windows.
//
////////////////////////////////////////////////////////////////////////////
void ShellClick_Refresh( PMOUSEBUTSTR pMstr )
{
    HWND hwndDesktop = FindWindowEx(NULL, NULL, TEXT(STR_DESKTOPCLASS), NULL);

    if( NULL != hwndDesktop )
       PostMessage( hwndDesktop, WM_COMMAND, FCIDM_REFRESH, 0L );

    EnumWindows( ShellClick_RefreshEnumProc, 0L ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mouseptr.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouseptr.c

Abstract:

    This module contains the routines for the Mouse Pointer Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "mousehlp.h"
#include <regstr.h>

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef DEBUG
void * __cdecl memset(void *pmem, int v, size_t s)
{
    char *p = (char *)pmem;

    while (s--)
    {
        *p++ = (char)v;
    }
    return (pmem);
}
#endif




//
//  Constant Declarations.
//

#define gcxAvgChar              8

#define MAX_SCHEME_NAME_LEN     32
#define MAX_SCHEME_SUFFIX       32      // length of " (system scheme)" - update if more space is needed
#define OVERWRITE_TITLE         32      // length of title for the confirm overwrite dialog
#define OVERWRITE_MSG           200     // length of the message for the overwrite dialog

#define PM_NEWCURSOR            (WM_USER + 1)
#define PM_PAUSEANIMATION       (WM_USER + 2)
#define PM_UNPAUSEANIMATION     (WM_USER + 3)

#define ID_PREVIEWTIMER         1

#define CCH_ANISTRING           80

#define CIF_FILE        0x0001
#define CIF_MODIFIED    0x0002
#define CIF_SHARED      0x0004

#define IDT_BROWSE 1




//
//  Typedef Declarations.
//

typedef struct _CURSOR_INFO
{
    DWORD    fl;
    HCURSOR  hcur;
    int      ccur;
    int      icur;
    TCHAR    szFile[MAX_PATH];
} CURSOR_INFO, *PCURSOR_INFO;

#pragma pack(2)
typedef struct tagNEWHEADER
{
    WORD reserved;
    WORD rt;
    WORD cResources;
} NEWHEADER, *LPNEWHEADER;
#pragma pack()

typedef struct
{
    UINT   idVisName;
    int    idResource;
    int    idDefResource;
    LPTSTR pszIniName;
    TCHAR  szVisName[MAX_PATH];
} CURSORDESC, *PCURSORDESC;

//
// Structure that contains data used within a preview window.  This
// data is unique for each preview window, and is used to optimize
// the painting.
//
typedef struct
{
    HDC          hdcMem;
    HBITMAP      hbmMem;
    HBITMAP      hbmOld;
    PCURSOR_INFO pcuri;
} PREVIEWDATA, *PPREVIEWDATA;


typedef struct _MOUSEPTRBR
{
    HWND        hDlg;
    CURSOR_INFO curi;
} MOUSEPTRBR, *PMOUSEPTRBR;




//
//  Global Variables.
//

extern HINSTANCE g_hInst;    // from main.c
int gcxCursor, gcyCursor;
HWND ghwndDlg, ghwndFile, ghwndFileH, ghwndTitle, ghwndTitleH;
HWND ghwndCreator, ghwndCreatorH, ghwndCursors, ghwndPreview, ghwndSchemeCB;
HBRUSH ghbrHighlight, ghbrHighlightText, ghbrWindow, ghbrButton;

UINT guTextHeight = 0;
UINT guTextGap = 0;

COLORREF gcrHighlightText;

TCHAR gszFileName2[MAX_PATH];

UINT wBrowseHelpMessage;

LPTSTR gszFileNotFound = NULL;
LPTSTR gszBrowse = NULL;
LPTSTR gszFilter = NULL;

TCHAR gszNoMem[256] = TEXT("No Memory");

HHOOK ghhkMsgFilter;         // hook handle for message filter function

static const TCHAR szRegStr_Setup[] = REGSTR_PATH_SETUP TEXT("\\Setup");
static const TCHAR szSharedDir[]    = TEXT("SharedDir");

BOOL gfCursorShadow = FALSE;

//
//  Make sure you add new cursors to the end of this array.
//  Otherwise the cursor schemes will not work
//
CURSORDESC gacd[] =
{
    { IDS_ARROW,       OCR_NORMAL,      OCR_ARROW_DEFAULT,       TEXT("Arrow"),       TEXT("") },
    { IDS_HELPCUR,     OCR_HELP,        OCR_HELP_DEFAULT,        TEXT("Help"),        TEXT("") },
    { IDS_APPSTARTING, OCR_APPSTARTING, OCR_APPSTARTING_DEFAULT, TEXT("AppStarting"), TEXT("") },
    { IDS_WAIT,        OCR_WAIT,        OCR_WAIT_DEFAULT,        TEXT("Wait"),        TEXT("") },
    { IDS_CROSS,       OCR_CROSS,       OCR_CROSS_DEFAULT,       TEXT("Crosshair"),   TEXT("") },
    { IDS_IBEAM,       OCR_IBEAM,       OCR_IBEAM_DEFAULT,       TEXT("IBeam"),       TEXT("") },
    { IDS_NWPEN,       OCR_NWPEN,       OCR_NWPEN_DEFAULT,       TEXT("NWPen"),       TEXT("") },
    { IDS_NO,          OCR_NO,          OCR_NO_DEFAULT,          TEXT("No"),          TEXT("") },
    { IDS_SIZENS,      OCR_SIZENS,      OCR_SIZENS_DEFAULT,      TEXT("SizeNS"),      TEXT("") },
    { IDS_SIZEWE,      OCR_SIZEWE,      OCR_SIZEWE_DEFAULT,      TEXT("SizeWE"),      TEXT("") },
    { IDS_SIZENWSE,    OCR_SIZENWSE,    OCR_SIZENWSE_DEFAULT,    TEXT("SizeNWSE"),    TEXT("") },
    { IDS_SIZENESW,    OCR_SIZENESW,    OCR_SIZENESW_DEFAULT,    TEXT("SizeNESW"),    TEXT("") },
    { IDS_SIZEALL,     OCR_SIZEALL,     OCR_SIZEALL_DEFAULT,     TEXT("SizeAll"),     TEXT("") },
    { IDS_UPARROW,     OCR_UP,          OCR_UPARROW_DEFAULT,     TEXT("UpArrow"),     TEXT("") },
    { IDS_HANDCUR,     OCR_HAND,        OCR_HAND_DEFAULT,        TEXT("Hand"),        TEXT("") },
};

#define CCURSORS   (sizeof(gacd) / sizeof(gacd[0]))

CURSOR_INFO acuri[CCURSORS];

//
//  Registry Keys.
//
const TCHAR szCursorSubdir[]  = TEXT("Cursors");
const TCHAR szCursorRegPath[] = REGSTR_PATH_CURSORS;

static const TCHAR c_szRegPathCursors[] = REGSTR_PATH_CURSORS;
static const TCHAR c_szSchemes[]        = TEXT("Schemes");

static const TCHAR c_szRegPathCursorSchemes[] = REGSTR_PATH_CURSORS TEXT( "\\Schemes" );

//
//  Strings used to read from the combo box must be larger than max length.
//
TCHAR gszSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];    // used to store selected scheme name for saving
int iSchemeLocation;        // used to store scheme location (HKCU vs HKLM)

static const TCHAR c_szRegPathSystemSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");
TCHAR szSystemScheme[MAX_SCHEME_SUFFIX];
TCHAR szNone[MAX_SCHEME_NAME_LEN + 1];
const TCHAR szSchemeSource[] = TEXT("Scheme Source");

TCHAR gszPreviousScheme[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];   // used to tell if a different scheme is selected

#define ID_NONE_SCHEME    0
#define ID_USER_SCHEME    1
#define ID_OS_SCHEME      2




//
//  Context Help Ids.
//

const static DWORD aMousePtrHelpIDs[] =
{
    IDC_GROUPBOX_1,    IDH_COMM_GROUPBOX,
    ID_SCHEMECOMBO,    IDH_MOUSE_POINT_SCHEME,
    ID_SAVESCHEME,     IDH_MOUSE_POINT_SAVEAS,
    ID_REMOVESCHEME,   IDH_MOUSE_POINT_DEL,
    ID_PREVIEW,        IDH_MOUSE_POINT_PREVIEW,
    ID_CURSORLIST,     IDH_MOUSE_POINT_LIST,
    ID_DEFAULT,        IDH_MOUSE_POINT_DEFAULT,
    ID_BROWSE,         IDH_MOUSE_POINT_BROWSE,
    ID_CURSORSHADOW,   IDH_MOUSE_CURSORSHADOW,

    0, 0
};

const static DWORD aMousePtrBrowseHelpIDs[] =
{
    IDC_GROUPBOX_1,    IDH_MOUSE_POINT_PREVIEW,
    ID_CURSORPREVIEW,  IDH_MOUSE_POINT_PREVIEW,

    0, 0
};

const static DWORD aHelpIDs[] =
{
    ID_SCHEMEFILENAME, IDH_MOUSE_NEW_SCHEME_NAME,

    0, 0
};




//
//  Forward Declarations.
//

void LoadCursorSet(HWND hwnd);

void CreateBrushes(void);

LPTSTR GetResourceString(HINSTANCE hmod,int id);

void DrawCursorListItem(DRAWITEMSTRUCT *pdis);

BOOL GetCursorFromFile(CURSOR_INFO *pcuri);

BOOL Browse(HWND hwndOwner);

void CleanUpEverything(void);

VOID UpdateCursorList(void);

VOID NextFrame(HWND hwnd);

void HourGlass(BOOL fOn);

BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSOR_INFO *pcuri);

BOOL LoadScheme(void);

BOOL SaveScheme(void);

BOOL SaveSchemeAs(void);

void SaveCurSchemeName(void);

BOOL RemoveScheme(void);

BOOL InitSchemeComboBox(void);

BOOL SchemeUpdate(int i);

LPTSTR MakeFilename(LPTSTR sz);

INT_PTR CALLBACK SaveSchemeDlgProc(
    HWND  hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void CurStripBlanks(LPTSTR pszString);

int SystemOrUser(TCHAR *pszSchemeName);

BOOL UnExpandPath( LPTSTR pszPath );




////////////////////////////////////////////////////////////////////////////
//
//  RegisterPointerStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterPointerStuff(
    HINSTANCE hi)
{
    gcxCursor = GetSystemMetrics(SM_CXCURSOR);
    gcyCursor = GetSystemMetrics(SM_CYCURSOR);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitCursorsShadow
//
////////////////////////////////////////////////////////////////////////////

void InitCursorShadow(HWND hwnd)
{
    BOOL fPalette;
    HDC hdc;
    int nCommand;

    hdc = GetDC(NULL);
    fPalette = (GetDeviceCaps(hdc, NUMCOLORS) != -1);
    ReleaseDC(NULL, hdc);

    if (!fPalette) {
        nCommand = SW_SHOW;
    } else {
        nCommand = SW_HIDE;
    }
    ShowWindow(GetDlgItem(hwnd, ID_CURSORSHADOW), nCommand);

    if (nCommand = SW_SHOW) {
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, (PVOID)&gfCursorShadow, 0);
        CheckDlgButton(hwnd, ID_CURSORSHADOW, gfCursorShadow);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  InitCursorsDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitCursorsDlg(
    HWND hwnd)
{
    int i;

    ghwndDlg = hwnd;
    gszPreviousScheme[0] = TEXT('\0');

    //
    //  Register the help message from the File Open (Browse) dialog.
    //
    wBrowseHelpMessage = RegisterWindowMessage(HELPMSGSTRING);

    //
    //  Load Strings.
    //
    if (gszFileNotFound == NULL)
    {
        gszFileNotFound = GetResourceString(g_hInst, IDS_CUR_BADFILE);

        if (gszFileNotFound == NULL)
        {
            return (FALSE);
        }
    }

    if (gszBrowse == NULL)
    {
        gszBrowse = GetResourceString(g_hInst, IDS_CUR_BROWSE);

        if (gszBrowse == NULL)
        {
            return (FALSE);
        }
    }

#ifdef WINNT
    if (gszFilter == NULL)
    {
        gszFilter = GetResourceString(g_hInst, IDS_ANICUR_FILTER);

        if (!gszFilter)
        {
            return (FALSE);
        }
    }
#else
    if (gszFilter == NULL)
    {
        HDC  dc = GetDC(NULL);
        BOOL fAni = (GetDeviceCaps(dc, CAPS1) & C1_COLORCURSOR) != 0;

        ReleaseDC(NULL, dc);

        gszFilter = GetResourceString( g_hInst,
                                       fAni
                                         ? IDS_ANICUR_FILTER
                                         : IDS_CUR_FILTER );

        if (!gszFilter)
        {
            return (FALSE);
        }
    }
#endif

    //
    //  Load description strings from the resource file.
    //
    for (i = 0; i < CCURSORS; i++)
    {
        if ((!gacd[i].idVisName) ||
            (LoadString( g_hInst,
                         gacd[i].idVisName,
                         gacd[i].szVisName,
                         ARRAYSIZE(gacd[i].szVisName) ) <= 0))
        {
            //
            //  Show something.
            //
            lstrcpy(gacd[i].szVisName, gacd[i].pszIniName);
        }
    }

    //
    //  As an optimization, remember the window handles of the cursor
    //  information fields.
    //
    ghwndPreview  = GetDlgItem(hwnd, ID_PREVIEW);
    ghwndFile     = GetDlgItem(hwnd, ID_FILE);
    ghwndFileH    = GetDlgItem(hwnd, ID_FILEH);
    ghwndTitle    = GetDlgItem(hwnd, ID_TITLE);
    ghwndTitleH   = GetDlgItem(hwnd, ID_TITLEH);
    ghwndCreator  = GetDlgItem(hwnd, ID_CREATOR);
    ghwndCreatorH = GetDlgItem(hwnd, ID_CREATORH);
    ghwndCursors  = GetDlgItem(hwnd, ID_CURSORLIST);
    ghwndSchemeCB = GetDlgItem(hwnd, ID_SCHEMECOMBO);

    //
    //  Create some brushes we'll be using.
    //
    CreateBrushes();

    //
    //  Initialize the scheme combo box.
    //
    InitSchemeComboBox();

    //
    //  Pre-clear the cursor info array.
    //
    memset(acuri, 0, sizeof(acuri));

    //
    //  Load the cursors.
    //
    LoadCursorSet(hwnd);

    //
    //  Force an update of the preview window and the cursor details.
    //
    UpdateCursorList();

    InitCursorShadow(hwnd);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadCursorSet
//
////////////////////////////////////////////////////////////////////////////

void LoadCursorSet(
    HWND hwnd)
{
    CURSOR_INFO *pcuri;
    HKEY hkCursors;
    int i;

    if (RegOpenKey( HKEY_CURRENT_USER,
                    szCursorRegPath,
                    &hkCursors ) != ERROR_SUCCESS)
    {
        hkCursors = NULL;
    }

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
    {
        if ( hkCursors )
        {
            DWORD dwType;
            DWORD dwCount = sizeof(pcuri->szFile);

            DWORD dwErr = RegQueryValueEx( hkCursors,
                              gacd[i].pszIniName,
                              NULL,
                              &dwType,
                              (LPBYTE)pcuri->szFile,
                              &dwCount );

            if (dwErr == ERROR_SUCCESS)
            {
                if (TryToLoadCursor(hwnd, i, pcuri))
                {
                    goto EverythingWorked;
                }
            }
        }

        // This is actually the failure case.  We load the default cursor.
        pcuri->hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_SHARED | LR_DEFAULTSIZE | LR_ENVSUBST );

        pcuri->fl |= CIF_SHARED;

EverythingWorked:

        SendMessage(ghwndCursors, LB_ADDSTRING, 0, i);
    }

    if (hkCursors)
    {
        RegCloseKey(hkCursors);
    }

    SendMessage(ghwndCursors, LB_SETCURSEL, 0, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateBrushes
//
//  Creates the brushes that are used to paint within the Cursors applet.
//
////////////////////////////////////////////////////////////////////////////

VOID CreateBrushes()
{
    ghbrHighlight     = GetSysColorBrush(COLOR_HIGHLIGHT);
    gcrHighlightText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ghbrHighlightText = GetSysColorBrush(COLOR_HIGHLIGHTTEXT);
    ghbrWindow        = GetSysColorBrush(COLOR_WINDOW);
    ghbrButton        = GetSysColorBrush(COLOR_BTNFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetResourceString
//
//  Gets a string out of the resource file.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR GetResourceString(
    HINSTANCE hmod,
    int id)
{
    TCHAR szBuffer[256];
    LPTSTR psz;
    int cch;

    if ((cch = LoadString(hmod, id, szBuffer, ARRAYSIZE(szBuffer))) == 0)
    {
        return (NULL);
    }

    psz = LocalAlloc(LPTR, (cch + 1) * sizeof(TCHAR));

    if (psz != NULL)
    {
        int i;

        for (i = 0; i <= cch; i++)
        {
            psz[i] = (szBuffer[i] == TEXT('\1')) ? TEXT('\0') : szBuffer[i];
        }
    }

    return (psz);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeItemCursor
//
////////////////////////////////////////////////////////////////////////////

void FreeItemCursor(
    CURSOR_INFO *pcuri)
{
    if (pcuri->hcur)
    {
        if (!(pcuri->fl & CIF_SHARED))
        {
            DestroyCursor(pcuri->hcur);
        }
        pcuri->hcur = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MousePtrDlg(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    CURSOR_INFO *pcuri;
    HKEY hkCursors;
    int i;

    switch (msg)
    {
        case ( WM_INITDIALOG ) :
        {
            return InitCursorsDlg(hwnd);
        }
        case ( WM_DISPLAYCHANGE ) :
        {
            InitCursorShadow(hwnd);
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            ((MEASUREITEMSTRUCT *)lParam)->itemHeight = gcyCursor + 2;
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            DrawCursorListItem((DRAWITEMSTRUCT *)lParam);
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( ID_SCHEMECOMBO ) :
                {
                    switch (HIWORD(wParam))
                    {
                        case ( CBN_SELCHANGE ) :
                        {
                            LoadScheme();
                            break;
                        }
                    }
                    break;
                }
                case ( ID_DEFAULT ) :
                {
                    //
                    //  Throw away any fancy new cursor and replace it with
                    //  the system's original.
                    //
                    i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);

                    pcuri = &acuri[i];

                    if (!(pcuri->fl & CIF_FILE))
                    {
                        break;
                    }
                    pcuri->fl = CIF_MODIFIED;

                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);

                    FreeItemCursor(pcuri);

                    pcuri->hcur =
                        (HCURSOR)LoadImage( NULL,
                                            MAKEINTRESOURCE(gacd[i].idDefResource),
                                            IMAGE_CURSOR,
                                            0,
                                            0,
                                            LR_DEFAULTSIZE | LR_ENVSUBST );

                    *pcuri->szFile = TEXT('\0');

                    EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);

                    UpdateCursorList();

                    break;
                }
                case ( ID_CURSORLIST ) :
                {
                    switch (HIWORD(wParam))
                    {
                        case ( LBN_SELCHANGE ) :
                        {
                            i = (int)SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                            pcuri = &acuri[i];

                            //
                            //  Show a preview (including animation) in the
                            //  preview window.
                            //
                            SendMessage( ghwndPreview,
                                         STM_SETICON,
                                         (WPARAM)pcuri->hcur,
                                         0L );

                            //
                            //  Enable the "Set Default" button if the cursor
                            //  is from a file.
                            //
                            EnableWindow( GetDlgItem(hwnd, ID_DEFAULT),
                                          (pcuri->fl & CIF_FILE ) ? TRUE : FALSE );
                            break;
                        }
                        case ( LBN_DBLCLK ) :
                        {
                            Browse(hwnd);
                            break;
                        }
                    }
                    break;
                }
                case ( ID_BROWSE ) :
                {
                    Browse(hwnd);
                    break;
                }
                case ( ID_SAVESCHEME ) :
                {
                    SaveSchemeAs();
                    break;
                }
                case ( ID_REMOVESCHEME ) :
                {
                    RemoveScheme();
                    break;
                }
                case ( ID_CURSORSHADOW ) :
                {
                    gfCursorShadow = IsDlgButtonChecked(hwnd, ID_CURSORSHADOW);
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);
                    break;
                }
            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch(((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    //
                    //  Change cursor to hour glass.
                    //
                    HourGlass(TRUE);

                    // Set cursor shadow
                    SystemParametersInfo( SPI_SETCURSORSHADOW,
                                          0,
                                          (PVOID)gfCursorShadow,
                                          SPIF_UPDATEINIFILE);

                    //
                    //  Save the modified scheme, order of calls important.
                    //
                    SaveCurSchemeName();

                    //
                    //  Set the system cursors.
                    //
                    if (RegCreateKey( HKEY_CURRENT_USER,
                                      szCursorRegPath,
                                      &hkCursors ) == ERROR_SUCCESS)
                    {
                        for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
                        {
                            if (pcuri->fl & CIF_MODIFIED)
                            {
                                LPCTSTR data;
                                UINT count;

                                // Always unexpand before we save a filename
                                UnExpandPath(pcuri->szFile);

                                data = (pcuri->fl & CIF_FILE) ? pcuri->szFile : TEXT("");
                                count = (pcuri->fl & CIF_FILE) ? (lstrlen(pcuri->szFile) + 1) * sizeof(TCHAR) : sizeof(TCHAR);

                                RegSetValueEx( hkCursors,
                                               gacd[i].pszIniName,
                                               0L,
                                               REG_EXPAND_SZ,
                                               (CONST LPBYTE)data,
                                               count );
                            }
                        }

                        RegCloseKey(hkCursors);

                        SystemParametersInfo( SPI_SETCURSORS,
                                              0,
                                              0,
                                              SPIF_SENDCHANGE );
                    }

                    HourGlass(FALSE);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            gcrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }

        case ( WM_WININICHANGE ) :
        {
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }

        case ( WM_DESTROY ) :
        {
            //
            //  Clean up global allocs.
            //
            CleanUpEverything();

            if (gszFileNotFound != NULL)
            {
                LocalFree(gszFileNotFound);
                gszFileNotFound = NULL;
            }

            if (gszBrowse != NULL)
            {
                LocalFree(gszBrowse);
                gszBrowse = NULL;
            }

            if (gszFilter != NULL)
            {
                LocalFree(gszFilter);
                gszFilter = NULL;
            }
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMousePtrHelpIDs );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aMousePtrHelpIDs );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawCursorListItem
//
////////////////////////////////////////////////////////////////////////////

void DrawCursorListItem(
    DRAWITEMSTRUCT *pdis)
{
    CURSOR_INFO *pcuri;
    COLORREF clrOldText, clrOldBk;
    RECT rc;

    if (!guTextHeight || !guTextGap)
    {
        TEXTMETRIC tm;

        tm.tmHeight = 0;
        GetTextMetrics(pdis->hDC, &tm);

        if (tm.tmHeight < 0)
        {
            tm.tmHeight *= -1;
        }
        guTextHeight = (UINT)tm.tmHeight;
        guTextGap = (UINT)tm.tmAveCharWidth;
    }

    pcuri = &acuri[pdis->itemData];

    if (pdis->itemState & ODS_SELECTED)
    {
        clrOldText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrOldBk = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        clrOldText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        clrOldBk = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }

    ExtTextOut( pdis->hDC,
                pdis->rcItem.left + guTextGap,   // fudge factor
                (pdis->rcItem.top + pdis->rcItem.bottom - guTextHeight) / 2,
                ETO_OPAQUE,
                &pdis->rcItem,
                gacd[pdis->itemData].szVisName,
                lstrlen(gacd[pdis->itemData].szVisName),
                NULL );

    if (pcuri->hcur != NULL)
    {
        DrawIcon( pdis->hDC,
                  pdis->rcItem.right - (gcxCursor + guTextGap),
                  pdis->rcItem.top + 1, pcuri->hcur );
    }

    if (pdis->itemState & ODS_FOCUS)
    {
        CopyRect(&rc, &pdis->rcItem);
        InflateRect(&rc, -1, -1);
        DrawFocusRect(pdis->hDC, &rc);
    }

    SetTextColor(pdis->hDC, clrOldText);
    SetBkColor(pdis->hDC, clrOldBk);
}


////////////////////////////////////////////////////////////////////////////
//
//  TryToLoadCursor
//
////////////////////////////////////////////////////////////////////////////

BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSOR_INFO *pcuri)
{
    BOOL fRet    = TRUE;
    BOOL bCustom = (*pcuri->szFile != 0);


    if (bCustom && !GetCursorFromFile(pcuri))
    {
        HWND hwndControl = GetParent(hwnd);
        LPTSTR pszText;
        LPTSTR pszFilename;

        //
        //  MakeFilename returns the address of a global, so we don't
        //  need to free pszFilename.
        //
        pszFilename = MakeFilename(pcuri->szFile);

        pszText = LocalAlloc( LPTR,
                              (lstrlen(gszFileNotFound) +
                               lstrlen(gacd[i].szVisName) +
                               lstrlen(pszFilename) +
                               1) * sizeof(TCHAR) );

        if (pszText == NULL)
        {
            return (FALSE);
        }

        wsprintf(pszText, gszFileNotFound, pszFilename, gacd[i].szVisName);

        MessageBeep(MB_ICONEXCLAMATION);

        MessageBox(hwndControl, pszText, NULL, MB_ICONEXCLAMATION | MB_OK);

        pcuri->fl = CIF_MODIFIED;

        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);

        bCustom = FALSE;

        LocalFree(pszText);
    }

    if (!bCustom)
    {
        FreeItemCursor(pcuri);

        pcuri->hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idDefResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_DEFAULTSIZE | LR_ENVSUBST );

        *pcuri->szFile = TEXT('\0');

        EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);
        UpdateCursorList();
    }

    return (pcuri->hcur != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCursorFromFile
//
////////////////////////////////////////////////////////////////////////////

BOOL GetCursorFromFile(
    CURSOR_INFO *pcuri)
{
    pcuri->fl = 0;
    pcuri->hcur =
        (HCURSOR)LoadImage( NULL,
                            MakeFilename(pcuri->szFile),
                            IMAGE_CURSOR,
                            0,
                            0,
                            LR_LOADFROMFILE | LR_DEFAULTSIZE | LR_ENVSUBST );

    if (pcuri->hcur)
    {
        pcuri->fl |= CIF_FILE;
    }

    return (pcuri->hcur != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowsePreview
//
////////////////////////////////////////////////////////////////////////////

void MousePtrBrowsePreview(
    HWND hDlg)
{
    PMOUSEPTRBR pPtrBr;
    HCURSOR hcurOld;

    pPtrBr = (PMOUSEPTRBR)GetWindowLongPtr(hDlg, DWLP_USER);

    hcurOld = pPtrBr->curi.hcur;

    CommDlg_OpenSave_GetFilePath( GetParent(hDlg),
                                  pPtrBr->curi.szFile,
                                  ARRAYSIZE(pPtrBr->curi.szFile) );

    if (!GetCursorFromFile(&pPtrBr->curi))
    {
        pPtrBr->curi.hcur = NULL;
    }

    SendDlgItemMessage( hDlg,
                        ID_CURSORPREVIEW,
                        STM_SETICON,
                        (WPARAM)pPtrBr->curi.hcur, 0L );

    if (hcurOld)
    {
        DestroyCursor(hcurOld);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowseNotify
//
////////////////////////////////////////////////////////////////////////////

BOOL MousePtrBrowseNotify(
    HWND hDlg,
    LPOFNOTIFY pofn)
{
    switch (pofn->hdr.code)
    {
        case ( CDN_SELCHANGE ) :
        {
            //
            //  Don't show the cursor until the user stops moving around.
            //
            if (SetTimer(hDlg, IDT_BROWSE, 250, NULL))
            {
                //
                //  Don't destroy the old cursor.
                //
                SendDlgItemMessage( hDlg,
                                    ID_CURSORPREVIEW,
                                    STM_SETICON,
                                    0,
                                    0L );
            }
            else
            {
                MousePtrBrowsePreview(hDlg);
            }
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowseDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MousePtrBrowseDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            PMOUSEPTRBR pPtrBr = (PMOUSEPTRBR)((LPOPENFILENAME)lParam)->lCustData;

            if (pPtrBr)
            {
                pPtrBr->hDlg = hDlg;
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pPtrBr);
            break;
        }
        case ( WM_DESTROY ) :
        {
            KillTimer(hDlg, IDT_BROWSE);

            //
            //  Don't destroy the old cursor.
            //
            SendDlgItemMessage(hDlg, ID_CURSORPREVIEW, STM_SETICON, 0, 0L);
            break;
        }
        case ( WM_TIMER ) :
        {
            KillTimer(hDlg, IDT_BROWSE);

            MousePtrBrowsePreview(hDlg);
            break;
        }
        case ( WM_NOTIFY ) :
        {
            return (MousePtrBrowseNotify(hDlg, (LPOFNOTIFY) lParam));
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMousePtrBrowseHelpIDs );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aMousePtrBrowseHelpIDs );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Browse
//
//  Browse the file system for a new cursor for the selected item.
//
////////////////////////////////////////////////////////////////////////////

BOOL Browse(HWND hwndOwner)
{
    static TCHAR szCustomFilter[80] = TEXT("");
    static TCHAR szStartDir[MAX_PATH] = TEXT("");

    OPENFILENAME ofn;
    CURSOR_INFO curi;
    int i;
    BOOL fRet = FALSE;
    MOUSEPTRBR sPtrBr;

    if (!*szStartDir)
    {
        HKEY key = NULL;

        if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegStr_Setup, &key) == ERROR_SUCCESS)
        {
            LONG len = sizeof(szStartDir) / sizeof(szStartDir[0]);

            if (RegQueryValueEx( key,
                                 szSharedDir,
                                 NULL,
                                 NULL,
                                 (LPBYTE)szStartDir,
                                 &len ) != ERROR_SUCCESS)
            {
                *szStartDir = TEXT('\0');
            }

            RegCloseKey(key);
        }

        if (!*szStartDir)
        {
            GetWindowsDirectory(szStartDir, MAX_PATH);
        }

        PathAppend(szStartDir, szCursorSubdir);
    }

    curi.szFile[0] = TEXT('\0');

    sPtrBr.curi.szFile[0] = TEXT('\0');
    sPtrBr.curi.hcur      = NULL;

    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hwndOwner;
    ofn.hInstance         = g_hInst;
    ofn.lpstrFilter       = gszFilter;
    ofn.lpstrCustomFilter = szCustomFilter;
    ofn.nMaxCustFilter    = ARRAYSIZE(szCustomFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = curi.szFile;
    ofn.nMaxFile          = ARRAYSIZE(curi.szFile);
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = szStartDir;
    ofn.lpstrTitle        = gszBrowse;
    ofn.Flags             = OFN_EXPLORER | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK |
                            OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = NULL;
    ofn.lpfnHook          = MousePtrBrowseDlgProc;
    ofn.lpTemplateName    = MAKEINTRESOURCE(DLG_MOUSE_POINTER_BROWSE);
    ofn.lCustData         = (LPARAM)(PMOUSEPTRBR)&sPtrBr;

    fRet = GetOpenFileName(&ofn);

    GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir);

    if (!fRet)
    {
        goto brErrExit;
    }

    fRet = FALSE;

    //
    //  We have probably already gotten this cursor.
    //
    if (lstrcmpi(curi.szFile, sPtrBr.curi.szFile) == 0)
    {
        if (!sPtrBr.curi.hcur)
        {
            goto brErrExit;
        }

        curi = sPtrBr.curi;

        //
        //  Clear this so it will not get destroyed in the cleanup code.
        //
        sPtrBr.curi.hcur = NULL;
    }
    else
    {
        //
        //  The user must have typed in a name.
        //
        if (!GetCursorFromFile(&curi))
        {
            goto brErrExit;
        }
    }

    //
    //  Convert mapped drive letters to UNC.
    //
#ifdef UNICODE
    if (curi.szFile[1] == TEXT(':'))
#else
    if (!IsDBCSLeadByte(curi.szFile[0]) && (curi.szFile[1] == TEXT(':')))
#endif
    {
        TCHAR szDrive[3];
        TCHAR szNet[MAX_PATH];
        int lenNet = ARRAYSIZE(szNet);

        lstrcpyn(szDrive, curi.szFile, ARRAYSIZE(szDrive));

        if ((WNetGetConnection(szDrive, szNet, &lenNet) == NO_ERROR) &&
            (szNet[0] == TEXT('\\')) &&
            (szNet[1] == TEXT('\\')))
        {
            lstrcat(szNet, curi.szFile + 2);
            lstrcpy(curi.szFile, szNet);
        }
    }

    i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);

    curi.fl |= CIF_MODIFIED;

    SendMessage(GetParent(ghwndDlg), PSM_CHANGED, (WPARAM)ghwndDlg, 0L);

    EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), TRUE);

    //
    //  Destroy the old cursor before we retain the new one.
    //
    FreeItemCursor(acuri + i);

    acuri[i] = curi;

    UpdateCursorList();

    fRet = TRUE;

brErrExit:
    if (sPtrBr.curi.hcur)
    {
        DestroyCursor(sPtrBr.curi.hcur);
    }

    return (fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanUpEverything
//
//  Destroy all the outstanding cursors.
//
////////////////////////////////////////////////////////////////////////////

void CleanUpEverything()
{
    CURSOR_INFO *pcuri;
    int i;

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
    {
        FreeItemCursor(pcuri);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateCursorList
//
//  Force the Cursor ListBox to repaint and the cursor information below the
//  listbox to be refreshed as well.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateCursorList()
{
    int i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);
    PCURSOR_INFO pcuri = ((i >= 0) ? &acuri[i] : NULL);
    HCURSOR hcur = pcuri ? pcuri->hcur : NULL;
    HWND hDefaultButton = GetDlgItem(ghwndDlg, ID_DEFAULT);
    BOOL fEnableDefaultButton = (pcuri && (pcuri->fl & CIF_FILE));

    InvalidateRect(ghwndCursors, NULL, FALSE);

    SendMessage(ghwndPreview, STM_SETICON, (WPARAM)hcur, 0L);

    if (!fEnableDefaultButton && (GetFocus() == hDefaultButton))
    {
        SendMessage(ghwndDlg, WM_NEXTDLGCTL, (WPARAM)ghwndCursors, TRUE);
    }

    EnableWindow(hDefaultButton, fEnableDefaultButton);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveSchemeAs
//
////////////////////////////////////////////////////////////////////////////

BOOL SaveSchemeAs()
{
    BOOL fSuccess = TRUE;

    //
    //  Dialog proc returns TRUE & sets gszSchemeName to filename entered
    //  on OK.
    //
    if (DialogBox( g_hInst,
                   MAKEINTRESOURCE(DLG_MOUSE_POINTER_SCHEMESAVE),
                   ghwndDlg,
                   SaveSchemeDlgProc ))
    {
        fSuccess = SaveScheme();

        if (fSuccess)
        {
            int index = (int)SendMessage( ghwndSchemeCB,
                                          CB_FINDSTRINGEXACT,
                                          (WPARAM)-1,
                                          (LPARAM)gszSchemeName );
            //
            //  If not found, add it.
            //
            if (index < 0)
            {
                index = (int)SendMessage( ghwndSchemeCB,
                                          CB_ADDSTRING,
                                          0,
                                          (LPARAM)gszSchemeName );
            }

            //
            //  Select the name.
            //
            SendMessage(ghwndSchemeCB, CB_SETCURSEL, (WPARAM) index, 0);

            //
            //  Since this is now a user saved scheme, activate the delete
            //  button.
            //
            EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), TRUE);
        }
    }

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SubstituteString
//
//  Replaces the string pszRemove with the string pszReplace in the
//  string pszInput and places the output in pszResult.  Only looks
//  at the begining of the input string.
//
////////////////////////////////////////////////////////////////////////////

BOOL SubstituteString(LPCTSTR pszInput, LPCTSTR pszRemove, LPCTSTR pszReplace, LPTSTR pszResult, UINT cchResult)
{
    DWORD cchRemove = lstrlen(pszRemove);

    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       pszRemove, cchRemove, pszInput, cchRemove) == 2)
    {
        if (lstrlen(pszInput) + cchRemove < cchResult)
        {
            lstrcpy(pszResult, pszReplace);
            lstrcat(pszResult, pszInput + cchRemove);
            return TRUE;
        }
    }
    return FALSE;
}


BOOL UnExpandPath( LPTSTR pszPath )
{
    static TCHAR szUserProfile[MAX_PATH];
    static TCHAR szSystemRoot[MAX_PATH];
    static TCHAR szProgramFiles[MAX_PATH];
    static BOOL bInit = FALSE;
    TCHAR szUnexpandedFilename[MAX_PATH];

    if ( !bInit )
    {
        ExpandEnvironmentStrings( TEXT("%USERPROFILE%"),  szUserProfile,  ARRAYSIZE(szUserProfile)  );
        ExpandEnvironmentStrings( TEXT("%SYSTEMROOT%"),   szSystemRoot,   ARRAYSIZE(szSystemRoot)   );
        ExpandEnvironmentStrings( TEXT("%ProgramFiles%"), szProgramFiles, ARRAYSIZE(szProgramFiles) );
        bInit = TRUE;
    }

    if (!SubstituteString(pszPath, szUserProfile, TEXT("%USERPROFILE%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
    {
        if (!SubstituteString(pszPath, szSystemRoot, TEXT("%SYSTEMROOT%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
        {
            if (!SubstituteString(pszPath, szProgramFiles, TEXT("%ProgramFiles%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
            {
                return FALSE;
            }
        }
    }
    lstrcpy(pszPath, szUnexpandedFilename);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveScheme
//
////////////////////////////////////////////////////////////////////////////

BOOL SaveScheme()
{
    BOOL fSuccess = FALSE;

    if (*gszSchemeName)
    {
        const BUFFER_SIZE = CCURSORS * (MAX_PATH + 1) + 1;
        LPTSTR pszBuffer = (LPTSTR)LocalAlloc( LMEM_FIXED,
                                               BUFFER_SIZE * sizeof(TCHAR) );

        HKEY hk;
        int i;

        if (!pszBuffer)
        {
            return (FALSE);
        }

        pszBuffer[0] = TEXT('\0');

        for (i = 0; i < CCURSORS; i++)
        {
            if (i)
            {
                lstrcat(pszBuffer, TEXT(","));
            }

            // Replace path with evnironment variables.
            UnExpandPath(acuri[i].szFile);

            lstrcat(pszBuffer, acuri[i].szFile);
        }

        if (RegCreateKey( HKEY_CURRENT_USER,
                          c_szRegPathCursors,
                          &hk ) == ERROR_SUCCESS)
        {
            HKEY hks;

            if (RegCreateKey(hk, c_szSchemes, &hks) == ERROR_SUCCESS)
            {
                LPTSTR pszOldValue = (LPTSTR)LocalAlloc( LMEM_FIXED,
                                               BUFFER_SIZE * sizeof(TCHAR) );
                DWORD dwType;
                DWORD dwSize = BUFFER_SIZE*sizeof(TCHAR);
                BOOL bSave = FALSE;

                int ret = RegQueryValueEx(hks, gszSchemeName, NULL, &dwType, (LPBYTE)pszOldValue, &dwSize);

                //
                //  If the key already exists, ask to confirm the overwrite.
                //
                if (ret == ERROR_SUCCESS && (dwType==REG_SZ || dwType==REG_EXPAND_SZ))
                {
                    // only need to save if value is different from old value
                    if (lstrcmp(pszOldValue,pszBuffer)!=0)
                    {
                        TCHAR szTitle[OVERWRITE_TITLE];
                        TCHAR szMsg[OVERWRITE_MSG];
                        LoadString(g_hInst, IDS_OVERWRITE_TITLE, szTitle, OVERWRITE_TITLE);
                        LoadString(g_hInst, IDS_OVERWRITE_MSG, szMsg, OVERWRITE_MSG);

                        if (MessageBox( ghwndDlg,
                                        szMsg,
                                        szTitle,
                                        MB_ICONQUESTION | MB_YESNO ) == IDYES)
                        {
                            //
                            //  Overwrite confirmed.  Safe to save.
                            //
                            bSave = TRUE;
                        }
                    }
                    else
                    {
                        // no need to save since the new value is the same as the old value.
                        fSuccess = TRUE;
                    }
                }
                else
                {
                    //
                    //  The key doesn't exist, so it's safe to create it.
                    //
                    bSave = TRUE;
                }

                if (bSave)
                {
                    if (RegSetValueEx( hks,
                                       gszSchemeName,
                                       0,
                                       REG_EXPAND_SZ,
                                       (LPBYTE)pszBuffer,
                                       (lstrlen(pszBuffer) + 1) * sizeof(TCHAR) )
                          == ERROR_SUCCESS)
                    {
                        fSuccess = TRUE;
                    }
                }

                RegCloseKey(hks);
                LocalFree( pszOldValue );
            }

            RegCloseKey(hk);
        }

        LocalFree(pszBuffer);
    }

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveCurSchemeName
//
////////////////////////////////////////////////////////////////////////////

void SaveCurSchemeName()
{
    HKEY hk;

    if (RegCreateKey( HKEY_CURRENT_USER,
                      c_szRegPathCursors,
                      &hk ) == ERROR_SUCCESS)
    {
        int index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

        SendMessage( ghwndSchemeCB,
                     CB_GETLBTEXT,
                     (WPARAM)index,
                     (LPARAM)gszSchemeName );
        //
        //  Exclude the "none" pattern.
        //
        if (lstrcmpi(gszSchemeName, szNone) == 0)
        {
            *gszSchemeName = 0;
            iSchemeLocation = ID_NONE_SCHEME;
        }
        else
        {
            iSchemeLocation = SystemOrUser(gszSchemeName);
        }

        RegSetValue( hk,
                     NULL,
                     REG_SZ,
                     gszSchemeName,
                     (lstrlen(gszSchemeName) + 1) * sizeof(TCHAR) );

        RegSetValueEx( hk,
                       szSchemeSource,
                       0,
                       REG_DWORD,
                       (unsigned char *)&iSchemeLocation,
                       sizeof(iSchemeLocation) );

        RegCloseKey(hk);

        if (iSchemeLocation == ID_USER_SCHEME)
        {
            SaveScheme();
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadScheme
//
//  This is called whenever a selection is made from the schemes combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadScheme()
{
    const BUFFER_SIZE = CCURSORS * (MAX_PATH + 1) + 1;
    TCHAR pszSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];
    LPTSTR pszBuffer;
    BOOL fSuccess = FALSE;
    int index, ret;
    HKEY hk;

    //
    //  Allocate buffer for cursor paths.
    //
    pszBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, BUFFER_SIZE * sizeof(TCHAR));
    if (pszBuffer == NULL)
    {
        return (FALSE);
    }

    HourGlass(TRUE);

    *pszBuffer = *pszSchemeName = 0;

    index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

    //
    //  Get current scheme name.
    //
    SendMessage( ghwndSchemeCB,
                 CB_GETLBTEXT,
                 (WPARAM)index,
                 (LPARAM)pszSchemeName );

    // Get the text for the item at index, compare to the previous value to see
    // if it changed.  We can't simply compare the previous index because new items
    // get inserted into the list so the index can change and still be the same or
    // can be different when nothing has changed.
    if ( 0 == lstrcmp(gszPreviousScheme, pszSchemeName) )
    {
        // nothing to do, we're loading the already selected scheme
        return FALSE;
    }

    // We're loading a different scheme, enable the apply button.
    SendMessage(GetParent(ghwndDlg), PSM_CHANGED, (WPARAM)ghwndDlg, 0L);
    lstrcpy(gszPreviousScheme, pszSchemeName);

    //
    //  Exclude the "none" pattern.
    //
    if (lstrcmpi(pszSchemeName, szNone) != 0)
    {
        //
        //  If we have an os scheme, then search for the scheme in HKLM,
        //  otherwise look in HKCU.
        //
        if ((((ret = SystemOrUser(pszSchemeName)) == ID_OS_SCHEME)
               ? (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, &hk))
               : (RegOpenKey(HKEY_CURRENT_USER, c_szRegPathCursorSchemes, &hk)))
             == ERROR_SUCCESS)
        {
            DWORD len = BUFFER_SIZE * sizeof(TCHAR);

            if (RegQueryValueEx( hk,
                                 pszSchemeName, 0, NULL,
                                 (LPBYTE)pszBuffer,
                                 &len ) == ERROR_SUCCESS)
            {
                fSuccess = TRUE;       // can be reset to FALSE below
            }

            RegCloseKey(hk);
        }
    }
    else
    {
        //
        //  "none" pattern is a valid choice.
        //
        ret = ID_NONE_SCHEME;
        fSuccess = TRUE;
    }

    if (fSuccess)
    {
        LPTSTR pszNextFile, pszFile = pszBuffer;
        BOOL fEOL = FALSE;
        int i = 0;

        //
        //  Parse string of format TEXT("filename1, filename2, filename3...")
        //  into cursor info array.
        //
        do
        {
            while (*pszFile &&
                   (*pszFile == TEXT(' ')  ||
                    *pszFile == TEXT('\t') ||
                    *pszFile == TEXT('\n')))
            {
                pszFile++;
            }

            pszNextFile = pszFile;

            while (*pszNextFile != TEXT('\0'))
            {
                if (*pszNextFile == TEXT(','))
                {
                    break;
                }

                pszNextFile = CharNext(pszNextFile);
            }

            if (*pszNextFile == TEXT('\0'))
            {
                fEOL = TRUE;
            }
            else
            {
                *pszNextFile = TEXT('\0');
            }

            if (lstrcmp(pszFile, acuri[i].szFile))
            {
                //
                //  It's different than current, update.
                //
                lstrcpy(acuri[i].szFile, pszFile);

                fSuccess &= SchemeUpdate(i);
            }

            pszFile = pszNextFile;

            if (!fEOL)
            {
                pszFile++;        // skip TEXT('\0') and move to next path
            }

            i++;

        } while (i < CCURSORS);
    }

    LocalFree(pszBuffer);

    UpdateCursorList();

    EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), (ret == ID_USER_SCHEME));

    HourGlass(FALSE);

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SchemeUpdate
//
//  Updates the cursor at index i in acuri.
//
////////////////////////////////////////////////////////////////////////////

BOOL SchemeUpdate(int i)
{
    BOOL fSuccess = TRUE;

    if (acuri[i].hcur)
    {
        FreeItemCursor(acuri + i);
    }

    //
    //  If TEXT("Set Default").
    //
    if (*(acuri[i].szFile) == TEXT('\0'))
    {
        acuri[i].hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idDefResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_DEFAULTSIZE | LR_ENVSUBST );
        acuri[i].fl = 0;
    }
    else
    {
        fSuccess = TryToLoadCursor(ghwndDlg, i, &acuri[i]);
    }

    acuri[i].fl |= CIF_MODIFIED;

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveScheme
//
////////////////////////////////////////////////////////////////////////////

BOOL RemoveScheme()
{
    //
    //  Only user schemes can be removed, so this only needs to
    //  be MAX_SCHEME_NAME_LEN + 1 long.
    //
    TCHAR szSchemeName[MAX_SCHEME_NAME_LEN + 1];
    int index;
    HKEY hk;

    index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

    //
    //  Get current scheme name.
    //
    SendMessage( ghwndSchemeCB,
                 CB_GETLBTEXT,
                 (WPARAM)index,
                 (LPARAM)szSchemeName );

    //
    //  Exclude the "none" pattern from removal.
    //
    if (lstrcmpi(szSchemeName, szNone) == 0)
    {
        return (FALSE);
    }

    //
    //  HACK: assume deleting noname needs no confirmation -
    //  this is because the scheme won't save properly anyway.
    //
    if (*szSchemeName)
    {
        TCHAR RemoveMsg[MAX_PATH];
        TCHAR DialogMsg[MAX_PATH];

        LoadString(g_hInst, IDS_REMOVESCHEME, RemoveMsg, MAX_PATH);

        wsprintf(DialogMsg, RemoveMsg, (LPTSTR)szSchemeName);

        LoadString(g_hInst, IDS_NAME, RemoveMsg, MAX_PATH);

        if (MessageBox( ghwndDlg,
                        DialogMsg,
                        RemoveMsg,
                        MB_ICONQUESTION | MB_YESNO ) != IDYES)
        {
            return (TRUE);
        }
    }

    if (RegOpenKey( HKEY_CURRENT_USER,
                    c_szRegPathCursors,
                    &hk ) == ERROR_SUCCESS)
    {
        HKEY hks;

        if (RegOpenKey(hk, c_szSchemes, &hks) == ERROR_SUCCESS)
        {
            RegDeleteValue(hks, szSchemeName);
            RegCloseKey(hks);
        }

        RegCloseKey(hk);
    }

    //
    //  Delete from list box.
    //
    index = (int)SendMessage( ghwndSchemeCB,
                              CB_FINDSTRINGEXACT,
                              (WPARAM)-1,
                              (LPARAM)szSchemeName );

    SendMessage(ghwndSchemeCB, CB_DELETESTRING, (WPARAM)index, 0);

    SendMessage(ghwndSchemeCB, CB_SETCURSEL, 0, 0);
    SendMessage(ghwndDlg, WM_NEXTDLGCTL, 1, 0L);

    EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), FALSE);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSchemeComboBox
//
////////////////////////////////////////////////////////////////////////////

BOOL InitSchemeComboBox()
{
    TCHAR pszSchemeName[MAX_SCHEME_NAME_LEN + 1];
    TCHAR pszDefaultSchemeName[MAX_SCHEME_NAME_LEN + 1];
    TCHAR pszLongName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];
    int index;
    HKEY hk;
    DWORD len;

    LoadString(g_hInst, IDS_NONE, szNone, ARRAYSIZE(szNone));
    LoadString(g_hInst, IDS_SUFFIX, szSystemScheme, ARRAYSIZE(szSystemScheme));

    if (RegOpenKey(HKEY_CURRENT_USER, c_szRegPathCursors, &hk) == ERROR_SUCCESS)
    {
        HKEY hks;

        //
        //  Enumerate the schemes.
        //
        if (RegOpenKey(hk, c_szSchemes, &hks) == ERROR_SUCCESS)
        {
            DWORD i;

            for (i = 0; ;i++)
            {
                LONG ret;

                //
                //  Reset each pass.
                //
                len = ARRAYSIZE(pszSchemeName);

                ret = RegEnumValue( hks,
                                    i,
                                    pszSchemeName,
                                    &len,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL );

                if (ret == ERROR_MORE_DATA)
                {
                    continue;
                }

                if (ret != ERROR_SUCCESS)
                {
                    break;
                }

                //
                //  HACK to keep "NONE" pure.
                //
                if (lstrcmpi(pszSchemeName, szNone) != 0)
                {
                    SendMessage( ghwndSchemeCB,
                                 CB_ADDSTRING,
                                 0,
                                 (LPARAM)pszSchemeName );
                }
            }

            //
            //  At this point, all of the user defined scheme names have been
            //  added to the combo box.
            //
            RegCloseKey(hks);
        }

        //
        //  Get name of current one.
        //
        //  Reset again.
        //
        len = sizeof(pszDefaultSchemeName);

        RegQueryValue(hk, NULL, pszDefaultSchemeName, &len);

        //
        //  Try to read the value of Scheme Source.  If this value doesn't
        //  exist, then we have a pre NT 5.0 implementation, so all schemes
        //  will be user schemes.
        //
        len = sizeof(iSchemeLocation);
        if (RegQueryValueEx( hk,
                             szSchemeSource,
                             NULL,
                             NULL,
                             (unsigned char *)&iSchemeLocation,
                             &len ) != ERROR_SUCCESS)
        {
            iSchemeLocation = ID_USER_SCHEME;
        }

        RegCloseKey(hk);
    }

    //
    //  Now add the system defined pointer schemes.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, &hk) == ERROR_SUCCESS)
    {
        DWORD i;

        for (i = 0; ;i++)
        {
            LONG ret;

            //
            //  Reset each pass.
            //
            len = ARRAYSIZE(pszSchemeName);

            ret = RegEnumValue( hk,
                                i,
                                pszSchemeName,
                                &len,
                                NULL,
                                NULL,
                                NULL,
                                NULL );

            //
            //  If the Scheme name is longer than the allowed length, skip it.
            //
            if (ret == ERROR_MORE_DATA)
            {
                continue;
            }

            //
            //  If there's an error, then we're done.
            //
            if (ret != ERROR_SUCCESS)
            {
                break;
            }

            //
            //  When we add the system identifier to the string, it could be
            //  longer than MAX_SCHEME_NAME, however we only want to read
            //  max length from the registry.
            //
            lstrcpy(pszLongName, pszSchemeName);
            lstrcat(pszLongName, szSystemScheme);
            SendMessage(ghwndSchemeCB, CB_ADDSTRING, 0, (LPARAM)pszLongName);
        }

        RegCloseKey(hk);
    }

    //
    //  Add the "none" scheme.
    //
    SendMessage(ghwndSchemeCB, CB_INSERTSTRING, 0, (LPARAM)szNone);

    //
    //  Try to find current one in the combobox.
    //
    lstrcpy(pszLongName, pszDefaultSchemeName);
    if (iSchemeLocation == ID_OS_SCHEME)
    {
        lstrcat(pszLongName, szSystemScheme);
    }
    index = (int)SendMessage( ghwndSchemeCB,
                              CB_FINDSTRINGEXACT,
                              0xFFFF,
                              (LPARAM)pszLongName );

    //
    //  If found, select it.
    //
    if (index < 0)           // if we are on the None scheme
    {
        iSchemeLocation = ID_NONE_SCHEME;
        index = 0;
    }

    // We keep around a selection indicator so we know when selection has changed.
    // Initialize that value here.
    lstrcpy(gszPreviousScheme, pszLongName);

    SendMessage(ghwndSchemeCB, CB_SETCURSEL, (WPARAM)index, 0);

    EnableWindow( GetDlgItem(ghwndDlg, ID_REMOVESCHEME),
                  (iSchemeLocation == ID_USER_SCHEME) );

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveSchemeDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK SaveSchemeDlgProc(
    HWND  hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            HourGlass(TRUE);

            GetWindowText(ghwndSchemeCB, szSchemeName, ARRAYSIZE(szSchemeName));

            //
            //  CANNOT SAVE "NONE" SCHEME.
            //
            if (lstrcmpi(szSchemeName, szNone) == 0)
            {
                *szSchemeName = 0;
            }

            iSchemeLocation = SystemOrUser(szSchemeName);

            SetDlgItemText(hWnd, ID_SCHEMEFILENAME,  szSchemeName);

            SendDlgItemMessage(hWnd, ID_SCHEMEFILENAME, EM_SETSEL, 0, 32767);

            SendDlgItemMessage( hWnd,
                                ID_SCHEMEFILENAME,
                                EM_LIMITTEXT,
                                MAX_SCHEME_NAME_LEN,
                                0L );

            EnableWindow(GetDlgItem(hWnd, IDOK), szSchemeName[0] != TEXT('\0'));

            HourGlass(FALSE);
            return (TRUE);
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aHelpIDs );
            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aHelpIDs );
            return (TRUE);
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( ID_SCHEMEFILENAME ) :
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  CANNOT SAVE "NONE" SCHEME
                        //  cannot save a scheme ending with szSystemScheme
                        //
                        EnableWindow(
                            GetDlgItem(hWnd, IDOK),
                            ((GetDlgItemText( hWnd,
                                              ID_SCHEMEFILENAME,
                                              szSchemeName,
                                              ARRAYSIZE(szSchemeName) ) > 0) &&
                             (lstrcmpi(szSchemeName, szNone) != 0) &&
                             (SystemOrUser(szSchemeName) != ID_OS_SCHEME)) );
                    }
                    break;
                }
                case ( IDOK ) :
                {
                    GetDlgItemText( hWnd,
                                    ID_SCHEMEFILENAME,
                                    szSchemeName,
                                    MAX_SCHEME_NAME_LEN + 1 );

                    CurStripBlanks(szSchemeName);

                    if (*szSchemeName == TEXT('\0'))
                    {
                        MessageBeep(0);
                        break;
                    }

                    lstrcpy(gszSchemeName, szSchemeName);

                    // fall through...
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hWnd, LOWORD(wParam) == IDOK);
                    return (TRUE);
                }
            }
        }
    }

    //
    //  Didn't process a message.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeFilename
//
//  Returns Filename with a default path in system directory if no path
//  is already specified.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR MakeFilename(
    LPTSTR sz)
{
    TCHAR szTemp[MAX_PATH];

    ExpandEnvironmentStrings(sz, szTemp, MAX_PATH);

    if (szTemp[0] == TEXT('\\') || szTemp[1] == TEXT(':'))
    {
        lstrcpy(gszFileName2, szTemp);

        return (gszFileName2);
    }
    else
    {
        GetSystemDirectory(gszFileName2, ARRAYSIZE(gszFileName2));

        lstrcat(gszFileName2, TEXT("\\"));
        lstrcat(gszFileName2, szTemp);

        return (gszFileName2);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CurStripBlanks
//
//  Strips leading and trailing blanks from a string.
//  Alters the memory where the string sits.
//
////////////////////////////////////////////////////////////////////////////

void CurStripBlanks(LPTSTR pszString)
{
    LPTSTR pszPosn;

    //
    //  Strip leading blanks.
    //
    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
    {
        pszPosn++;
    }

    if (pszPosn != pszString)
    {
        lstrcpy(pszString, pszPosn);
    }

    //
    //  Strip trailing blanks.
    //
    if ((pszPosn = pszString + lstrlen(pszString)) != pszString)
    {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
       {
           pszPosn = CharPrev(pszString, pszPosn);
       }

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SystemOrUser
//
//  Attempts to determine if the scheme name selected from the combo
//  box ends with the string szSystemScheme and retuns ID_OS_SCHEME
//  if it does, ID_USER_SCHEME if it doesn't.
//
////////////////////////////////////////////////////////////////////////////

int SystemOrUser(TCHAR *pszSchemeName)
{
    TCHAR *pszSN;
    int lenSS, lenSN;
    int i;

    lenSS = lstrlen(szSystemScheme);
    lenSN = lstrlen(pszSchemeName);

    if (lenSN <= lenSS)
    {
        return (ID_USER_SCHEME);
    }

    pszSN = pszSchemeName + (lenSN - lenSS);

    //
    //  If these strings are different, it's a user scheme.
    //
    if (lstrcmpi(pszSN, szSystemScheme))
    {
        return (ID_USER_SCHEME);
    }

    //
    //  For system schemes, this function also removes the
    //  szSystemScheme string from the end.
    //
    *pszSN = TEXT('\0');

    return (ID_OS_SCHEME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\rc.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    rc.h

Abstract:

    This module contains the header information for the resources of
    this project.

Revision History:

--*/



#ifndef _RC_H
#define _RC_H



//
//  Icons.
//

#define IDI_MOUSE                      100
#define IDI_KEYBD                      200
#define IDI_PRINT                      300
#define IDI_FONTS                      400
#define IDI_ADM                        500

#define IDI_PTTRAILS                   103
#define IDI_PTSPEED                    104

#define IDI_DELAY                      105
#define IDI_REPEAT                     106

#define IDI_SNAPDEF                    108

#define IDI_SGLCLICK                   109
#define IDI_DBLCLICK                   110

//
//  Bitmaps.
//

#define IDB_MOUSE                      100




//
//  Animations.
//

#define IDA_JACKNBOX                   100




//
//  Strings.
//

#define IDS_MOUSE_TITLE                100
#define IDS_MOUSE_EXPLAIN              101
#define IDS_KEYBD_TITLE                102
#define IDS_KEYBD_EXPLAIN              103
#define IDS_PRINT_TITLE                104
#define IDS_PRINT_EXPLAIN              105
#define IDS_FONTS_TITLE                106
#define IDS_FONTS_EXPLAIN              107
#define IDS_ADM_TITLE                  108
#define IDS_ADM_EXPLAIN                109

#define IDS_MOUSE_TSHOOT               110
#define IDS_KEYBD_TSHOOT               111

#define IDS_UNKNOWN                    198
#define IDS_KEYBD_NOSETSPEED           199

#define IDS_ANICUR_FILTER              200
#define IDS_NAME                       201
#define IDS_INFO                       202
#define IDS_CUR_NOMEM                  203
#define IDS_CUR_BADFILE                204
#define IDS_CUR_BROWSE                 205
#define IDS_CUR_FILTER                 206
#define IDS_ARROW                      207
#define IDS_WAIT                       208
#define IDS_APPSTARTING                209
#define IDS_NO                         210
#define IDS_IBEAM                      211
#define IDS_CROSS                      212
#define IDS_SIZENS                     213
#define IDS_SIZEWE                     214
#define IDS_SIZENWSE                   215
#define IDS_SIZENESW                   216
#define IDS_SIZEALL                    217
#define IDS_HELPCUR                    218
#define IDS_NWPEN                      219
#define IDS_UPARROW                    220
#define IDS_NONE                       221
#define IDS_SUFFIX                     222
#define IDS_OVERWRITE_TITLE            223
#define IDS_OVERWRITE_MSG              224
#define IDS_HANDCUR                    225

#define IDS_REMOVESCHEME               230
#define IDS_DEFAULTSCHEME              231

#define IDS_FIRSTSCHEME                1000
#define IDS_LASTSCHEME                 1017




//
//  Dialog Boxes.
//

#define DLG_MOUSE_POINTER_SCHEMESAVE   99
#define DLG_MOUSE_BUTTONS              100
#define DLG_MOUSE_POINTER              101
#define DLG_MOUSE_POINTER_BROWSE       102
#define DLG_MOUSE_MOTION               103
#define DLG_KEYBD_SPEED                104
#define DLG_KEYBD_POINTER              105
#define DLG_HARDWARE                   106



//
//  Dialog Controls.
//

#define IDC_GROUPBOX_1                 94   // Use in place of IDC_STATIC for
#define IDC_GROUPBOX_2                 95   // controls with no context Help
#define IDC_GROUPBOX_3                 96
#define IDC_GROUPBOX_4                 97
#define IDC_GROUPBOX_5                 98
#define IDC_GROUPBOX_6                 99




//
//  Mouse Button Page.
//

#define MOUSE_LEFTHAND                 100
#define MOUSE_RIGHTHAND                101
#define MOUSE_SELECTBMP                102
#define MOUSE_MOUSEBMP                 103
#define MOUSE_MENUBMP                  104
#define MOUSE_CLICKSCROLL              105
#define MOUSE_DBLCLKBMP                106
#define MOUSE_PTRCOLOR                 107
#define MOUSE_SIZESCROLL               108
#define IDC_SELECTDRAG                 109
#define IDC_OBJECTMENU                 110
#define MOUSE_CLICKICON                111
#define MOUSE_DBLCLICK                 112
#define MOUSE_SGLCLICK                 113




//
//  Mouse Pointer Page.
//

#define DLG_CURSORS                    100
#define ID_CURSORLIST                  101
#define ID_BROWSE                      102
#define ID_DEFAULT                     103
#define ID_TITLEH                      104
#define ID_CREATORH                    105
#define ID_FILEH                       106
#define ID_TITLE                       107
#define ID_CREATOR                     108
#define ID_FILE                        109
#define ID_PREVIEW                     110
#define ID_SAVESCHEME                  111
#define ID_REMOVESCHEME                112
#define ID_SCHEMECOMBO                 113
#define ID_CURSORSHADOW                114

#define ID_SCHEMEFILENAME              300

#define ID_CURSORPREVIEW               400




//
//  Mouse Motion Page.
//

#define MOUSE_SPEEDSCROLL              101
#define MOUSE_TRAILBMP                 102
#define MOUSE_TRAILS                   103
#define MOUSE_TRAILSCROLL              104
#define MOUSE_PTRTRAIL                 105
#define MOUSE_SPEEDBMP                 106
#define MOUSE_TRAILSCROLLTXT1          107
#define MOUSE_TRAILSCROLLTXT2          108
#define MOUSE_SNAPDEF                  109
#define MOUSE_PTRSNAPDEF               110
#define MOUSE_ACCELBMP                 111
#define MOUSE_ACCELNONE                112
#define MOUSE_ACCELLOW                 113
#define MOUSE_ACCELMEDIUM              114
#define MOUSE_ACCELHIGH                115



//
//  Keyboard Speed Page.
//

#define KDELAY_SCROLL                  100
#define KSPEED_SCROLL                  101
#define KREPEAT_EDIT                   102
#define KBLINK_EDIT                    103
#define KCURSOR_BLINK                  104
#define KCURSOR_SCROLL                 105
#define KDELAY_GROUP                   106
#define KBLINK_GROUP                   107




//
//  Keyboard Pointer Page.
//

#define KCHK_ON                        100
#define KNUM_BMP                       101
#define KBTN_NUMBER                    102
#define KBTN_ARROW                     103
#define KARROW_BMP                     104
#define KPSPEED_SCROLL                 105
#define KPACC_SCROLL                   106



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\mousehlp.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousehlp.h

Abstract:

    This module contains the header information for the Mouse help.

Revision History:

--*/



//
//  ID values for Mouse property sheet.
//

#define NO_HELP                         ((DWORD) -1)

#define IDH_COMM_GROUPBOX               28548

#define IDH_DLGMOUSE_LEFT               3000
#define IDH_DLGMOUSE_RIGHT              3001
#define IDH_DLGMOUSE_DOUBCLICK          3002
#define IDH_DLGMOUSE_HANDED_PIC         3003
#define IDH_DLGMOUSE_DCLICK_PIC         3004
#define IDH_DLGMOUSE_SHOWTRAIL          3005
#define IDH_DLGMOUSE_TRAILLENGTH        3006
#define IDH_DLGMOUSE_TYPE               3007
#define IDH_DLGMOUSE_CHANGE             3008
#define IDH_DLGMOUSE_POINTMO            3009
#define IDH_MOUSE_POINT_SCHEME          3010
#define IDH_MOUSE_POINT_DEL             3011
#define IDH_MOUSE_POINT_SAVEAS          3012
#define IDH_MOUSE_POINT_BROWSE          3013
#define IDH_MOUSE_POINT_LIST            3014
#define IDH_MOUSE_POINT_DEFAULT         3015
#define IDH_DLGMOUSE_OPTIONS            3016
#define IDH_MOUSE_NEW_SCHEME_NAME       3017
#define IDH_MOUSE_POINT_PREVIEW         3018
#define IDH_DLGMOUSE_SNAPDEF            3019
#define IDH_DLGMOUSE_TYPE_LIST          3020
#define IDH_DLGMOUSE_ACCELERATION       3021
#define IDH_MOUSE_SGLCLICK              3022
#define IDH_MOUSE_DBLCLICK              3023
#define IDH_MOUSE_CURSORSHADOW          3024
#define IDH_MOUSE_ENABLEWHEEL           3025
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\util.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    This module contains the utility routines for this project.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


//
//  Global Variables.
//

extern HINSTANCE g_hInst;





////////////////////////////////////////////////////////////////////////////
//
//  HourGlass
//
////////////////////////////////////////////////////////////////////////////

void HourGlass(
    BOOL fOn)
{
   if (!GetSystemMetrics(SM_MOUSEPRESENT))
   {
      ShowCursor(fOn);
   }
   SetCursor(LoadCursor(NULL, (fOn ? IDC_WAIT : IDC_ARROW)));
}


////////////////////////////////////////////////////////////////////////////
//
//  MyMessageBox
//
////////////////////////////////////////////////////////////////////////////

#ifdef WINNT

int MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...)
{
    TCHAR szText[4 * PATHMAX], szCaption[2 * PATHMAX];
    int result;
    va_list parg;

    va_start(parg, uType);

    LoadString(g_hInst, uText, szCaption, ARRAYSIZE(szCaption));

    wvsprintf(szText, szCaption, parg);

    LoadString(g_hInst, uCaption, szCaption, ARRAYSIZE(szCaption));

    result = MessageBox(hWnd, szText, szCaption, uType);

    va_end(parg);

    return (result);
}

#else

int MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...)
{
    TCHAR szText[256 + PATHMAX], szCaption[256];
    int result;


    LoadString(g_hInst, uText, szCaption, ARRAYSIZE(szCaption));

    wvsprintf(szText, szCaption, (LPTSTR)(&uType + 1));

    LoadString(g_hInst, uCaption, szCaption, ARRAYSIZE(szCaption));

    result = MessageBox(hWnd, szText, szCaption, uType);

    return (result);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  TrackInit
//
////////////////////////////////////////////////////////////////////////////

void TrackInit(
    HWND hwndScroll,
    int nCurrent,
    PARROWVSCROLL pAVS)
{
    SendMessage(hwndScroll, TBM_SETRANGE, 0, MAKELONG(pAVS->bottom, pAVS->top));
    SendMessage(hwndScroll, TBM_SETPOS, TRUE, (LONG)nCurrent);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrackMessage
//
////////////////////////////////////////////////////////////////////////////

int TrackMessage(
    WPARAM wParam,
    LPARAM lParam,
    PARROWVSCROLL pAVS)
{
    return ((int)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L));
}

////////////////////////////////////////////////////////////////////////////
//
//  HardwareDlg_OnInitDialog
//
//  Load the real hardware tab out of devmgr.dll.
//
//  DWLP_USER     - HWND of inner page
//
////////////////////////////////////////////////////////////////////////////

// There is no devmgr.h (go figure) so we must declare it ourselves.

EXTERN_C DECLSPEC_IMPORT HWND STDAPICALLTYPE
DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);

void
HardwareDlg_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PCHWPAGEINFO phpi = (PCHWPAGEINFO)((LPPROPSHEETPAGE)lp)->lParam;
    HWND hwndHW = DeviceCreateHardwarePage(hdlg, &phpi->guidClass);

    if (hwndHW) {
        TCHAR tszTshoot[MAX_PATH];
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)hwndHW);
        if (LoadString(g_hInst, phpi->idsTshoot, tszTshoot, ARRAYSIZE(tszTshoot))) {
            SetWindowText(hwndHW, tszTshoot);
        }
    } else {
        DestroyWindow(hdlg); // catastrophic failure
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  HardwareDlg
//
//  The dialog procedure for generic hardware tabs.
//
//  GWLP_USERDATA - HINSTANCE of devmgr.dll
//  DWLP_USER     - HWND of inner page
//
//
////////////////////////////////////////////////////////////////////////////

typedef HWND (WINAPI *DEVICECREATEHARDWAREPAGE)
        (HWND hwndParent, const GUID *pguid);

INT_PTR CALLBACK HardwareDlg(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp)
{
    switch (uMsg) {

    case WM_INITDIALOG:
        HardwareDlg_OnInitDialog(hdlg, lp);
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CreateHardwarePage
//
////////////////////////////////////////////////////////////////////////////

HPROPSHEETPAGE
CreateHardwarePage(PCHWPAGEINFO phpi)
{
    PROPSHEETPAGE psp;

    // No hardware tab if we are a remote TS session, since we would end
    // up showing the properties of the server, not the client, and that
    // would be too confusing.
    if (GetSystemMetrics(SM_REMOTESESSION))
        return NULL;

    // No hardware tab if it's been disabled via policy.
    if (SHRestricted(REST_NOHARDWARETAB))
        return NULL;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_HARDWARE);
    psp.pfnDlgProc  = HardwareDlg;
    psp.lParam      = (LPARAM)phpi;

    return CreatePropertySheetPage(&psp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\portstr.h ===
#ifndef PORTSTR_H
#define PORTSTR_H

//
//  exported from ports.c
//
extern TCHAR  m_szColon[];
extern TCHAR  m_szComma[];
extern TCHAR  m_szCloseParen[];
extern TCHAR  m_szPorts[];
extern TCHAR  m_szCOM[];
extern TCHAR  m_szSERIAL[];

extern TCHAR m_szRegSerialMap[];

extern TCHAR m_szFIFO[];
extern TCHAR m_szDosDev[];
extern TCHAR m_szPollingPeriod[];
extern TCHAR m_szPortName[];


// Strings needed for parallel port installation.
//
extern TCHAR m_szPortSubClass[];
extern TCHAR m_szParallelClassDevName[];
extern TCHAR m_szParallelClassHwId[];

extern int m_nBaudRates[];

extern TCHAR m_sz9600[];

extern TCHAR m_szDefParams[];
extern short m_nDataBits[];
extern TCHAR *m_pszParitySuf[];
extern TCHAR *m_pszLenSuf[];
extern TCHAR *m_pszStopSuf[];
extern TCHAR *m_pszFlowSuf[];

#endif // PORTSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\comdb.c ===
/*++


  Author:

  Doron J. Holan (doronh), 1-22-1998
  --*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#include <msports.h>
#include <tchar.h>

#define GROWTH_VALUE         1024

#define BITS_INA_BYTE        8

typedef struct _DB_INFO {

    HANDLE  RegChangedEvent;
    HANDLE  AccessMutex;

    HKEY    DBKey;

    PBYTE   Ports;
    ULONG   PortsLength;
} DB_INFO, * PDB_INFO;

#define HandleToDBInfo(h) ((PDB_INFO) (h))
#define IsEventSignalled(hevent) (WaitForSingleObject(hevent, 0) == WAIT_OBJECT_0)
#define SanityCheckComNumber(num) { if (num > COMDB_MAX_PORTS_ARBITRATED) return ERROR_INVALID_PARAMETER; }
#define SanityCheckDBInfo(dbi) { if ((HANDLE) dbi == INVALID_HANDLE_VALUE) return ERROR_INVALID_PARAMETER; }


const TCHAR szMutexName[] = _T("ComPortNumberDatabaseMutexObject");
const TCHAR szComDBName[] = _T("ComDB");
const TCHAR szComDBMerge[] = _T("ComDB Merge");
const TCHAR szComDBPath[] = _T("System\\CurrentControlSet\\Control\\COM Name Arbiter");
const TCHAR szComDBPathOld[] = _T("System\\CurrentControlSet\\Services\\Serial");

#ifdef malloc
#undef malloc
#endif
#define malloc(size) LocalAlloc(LPTR, (size))

#ifdef free
#undef free
#endif 
#define free LocalFree

VOID
DestroyDBInfo(
     PDB_INFO DBInfo
     )
{
    if (DBInfo->AccessMutex && 
        DBInfo->AccessMutex != INVALID_HANDLE_VALUE) {
        CloseHandle(DBInfo->AccessMutex);
    }

    if (DBInfo->RegChangedEvent && 
        DBInfo->RegChangedEvent != INVALID_HANDLE_VALUE) {
        CloseHandle(DBInfo->RegChangedEvent);
    }

    if (DBInfo->DBKey && 
        DBInfo->DBKey != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(DBInfo->DBKey);     
    }

    if (DBInfo->Ports) {
        free(DBInfo->Ports);
    }

    free(DBInfo);
}

LONG
CreationFailure (
     PHCOMDB  PHComDB,
     PDB_INFO DBInfo
     )
{
    if (DBInfo->AccessMutex != 0) 
        ReleaseMutex(DBInfo->AccessMutex);
    DestroyDBInfo(DBInfo);
    *PHComDB = (HCOMDB) INVALID_HANDLE_VALUE;
    return ERROR_ACCESS_DENIED;
}

VOID
RegisterForNotification(
    PDB_INFO DBInfo
    )
{
    ResetEvent(DBInfo->RegChangedEvent);
    if (RegNotifyChangeKeyValue(DBInfo->DBKey,
                                FALSE,
                                REG_NOTIFY_CHANGE_LAST_SET,
                                DBInfo->RegChangedEvent,
                                TRUE) != ERROR_SUCCESS) {
        //
        // Can't get a notification of when the DB is changed so close the handle
        // and we must update the DB at every access no matter what
        //
        CloseHandle(DBInfo->RegChangedEvent);
        DBInfo->RegChangedEvent = INVALID_HANDLE_VALUE;
    }
}

BOOL
ResizeDatabase(
    PDB_INFO DBInfo,
    ULONG    NumberPorts
    )
{
    PBYTE newPorts = NULL;
    ULONG newPortsLength;

    if (DBInfo->Ports) {
        newPortsLength = NumberPorts / BITS_INA_BYTE;
        newPorts = (PBYTE) malloc(newPortsLength * sizeof(BYTE));

        if (newPorts) {
            memcpy(newPorts, DBInfo->Ports, DBInfo->PortsLength);
            free(DBInfo->Ports);
            DBInfo->Ports = newPorts;
            DBInfo->PortsLength = newPortsLength;

            return TRUE;
        }
        else {
            return FALSE;
        }
    }
    else {
        //
        // Just alloc and be done with it
        //
        DBInfo->PortsLength = NumberPorts / BITS_INA_BYTE;
        DBInfo->Ports = (PBYTE) malloc(DBInfo->PortsLength * sizeof(BYTE));

        return DBInfo->Ports ? TRUE : FALSE;
    }
}

LONG
WINAPI
ComDBOpen (
    PHCOMDB PHComDB
    )
/*++

Routine Description:

    Opens name data base, and returns a handle to be used in future calls.

Arguments:

    None.

Return Value:

    INVALID_HANDLE_VALUE if the call fails, otherwise a valid handle

    If INVALID_HANDLE_VALUE, call GetLastError() to get details (??)

--*/
{
    PDB_INFO dbInfo = malloc(sizeof(DB_INFO));
    DWORD    type, size, disposition = 0x0;
    BOOLEAN  migrated = FALSE;
    LONG     res;
    BYTE     merge[COMDB_MIN_PORTS_ARBITRATED / BITS_INA_BYTE /* 32 */]; 

    if (dbInfo == 0) {
        *PHComDB = (HCOMDB) INVALID_HANDLE_VALUE;
        return ERROR_ACCESS_DENIED;
    }

    dbInfo->AccessMutex = CreateMutex(NULL, FALSE, szMutexName);

    if (dbInfo->AccessMutex == 0) {
        return CreationFailure(PHComDB, dbInfo);
    }

    //
    // Enter the mutex so we can guarantee only one thread pounding on the reg
    // key at once
    //
    WaitForSingleObject(dbInfo->AccessMutex, INFINITE);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       szComDBPath, 
                       0,
                       (TCHAR *) NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS | KEY_NOTIFY,
                       (LPSECURITY_ATTRIBUTES) NULL,
                       &dbInfo->DBKey,
                       &disposition) != ERROR_SUCCESS) {
        //
        // Try again w/out notification caps
        //
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           szComDBPath,
                           0,
                           (TCHAR *) NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           &dbInfo->DBKey, 
                           &disposition) != ERROR_SUCCESS) {
            return CreationFailure(PHComDB, dbInfo);
        }

        dbInfo->RegChangedEvent = INVALID_HANDLE_VALUE;
    }
    else {
        dbInfo->RegChangedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (dbInfo->RegChangedEvent == 0) {
            dbInfo->RegChangedEvent = INVALID_HANDLE_VALUE;
        }
    }

    if (disposition == REG_CREATED_NEW_KEY) {
        //
        // Must migrate the previous values from the old com db path
        //
        HKEY hOldDB;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szComDBPathOld, 
                         0,
                         KEY_ALL_ACCESS,
                         &hOldDB) == ERROR_SUCCESS &&
            RegQueryValueEx(hOldDB,
                            szComDBName,
                            0,
                            &type,
                            NULL,
                            &dbInfo->PortsLength) == ERROR_SUCCESS) {

            //
            // The old value is still there, get its contents, copy it to the 
            // new location and delete the old value
            //
            migrated = TRUE;
            ResizeDatabase(dbInfo, dbInfo->PortsLength * BITS_INA_BYTE);
    
            size = dbInfo->PortsLength;

            res = RegQueryValueEx(hOldDB,
                                  szComDBName,
                                  0,
                                  &type,
                                  (PBYTE) dbInfo->Ports,
                                  &size);

            RegDeleteValue(hOldDB, szComDBName);

            //
            // The value does not exist, write it out
            //
            if (RegSetValueEx(dbInfo->DBKey,
                              szComDBName,
                              0,
                              REG_BINARY,
                              dbInfo->Ports,
                              dbInfo->PortsLength) != ERROR_SUCCESS) {

                RegCloseKey(hOldDB);
                return CreationFailure(PHComDB, dbInfo);
            }

            RegCloseKey(hOldDB);
        }

    }

    //
    // If we haven't migrated values from the old path, then either create a 
    // new chunk or read in values previously written
    //
    if (!migrated) {
        res = RegQueryValueEx(dbInfo->DBKey,
                              szComDBName,
                              0,
                              &type,
                              NULL,
                              &dbInfo->PortsLength);
    
        if (res == ERROR_FILE_NOT_FOUND) {
            ResizeDatabase(dbInfo, COMDB_MIN_PORTS_ARBITRATED); 
    
            //
            // The value does not exist, write it out
            //
            res = RegSetValueEx(dbInfo->DBKey,
                                szComDBName,
                                0,
                                REG_BINARY,
                                dbInfo->Ports,
                                dbInfo->PortsLength);
                                
            if (res != ERROR_SUCCESS) {
                return CreationFailure(PHComDB, dbInfo);
            }
        }
        else if (res == ERROR_MORE_DATA || res != ERROR_SUCCESS || type != REG_BINARY) {
            return CreationFailure(PHComDB, dbInfo);
        }
        else if (res == ERROR_SUCCESS) {
            ResizeDatabase(dbInfo, dbInfo->PortsLength * BITS_INA_BYTE);
    
            size = dbInfo->PortsLength;
            res = RegQueryValueEx(dbInfo->DBKey,
                                  szComDBName,
                                  0,
                                  &type,
                                  (PBYTE) dbInfo->Ports,
                                  &size);
        }
    }
    
    size = sizeof(merge);
    if (RegQueryValueEx(dbInfo->DBKey,
                        szComDBMerge,
                        0,
                        &type,
                        (PBYTE) merge,
                        &size) == ERROR_SUCCESS &&
        size <= dbInfo->PortsLength) {

        int i;

        for (i = 0 ; i < COMDB_MIN_PORTS_ARBITRATED / BITS_INA_BYTE; i++) {
            dbInfo->Ports[i] |= merge[i];
        }
        
        RegDeleteValue(dbInfo->DBKey, szComDBMerge);

        RegSetValueEx(dbInfo->DBKey,
                      szComDBName,
                      0,
                      REG_BINARY,
                      dbInfo->Ports,
                      dbInfo->PortsLength);
    }

    if (dbInfo->RegChangedEvent != INVALID_HANDLE_VALUE) {
        RegisterForNotification(dbInfo);
    }

    ReleaseMutex(dbInfo->AccessMutex);

    //
    // All done!  phew...
    //
    *PHComDB = (HCOMDB) dbInfo;
    return ERROR_SUCCESS;

}

LONG
WINAPI
ComDBClose (
    HCOMDB HComDB
    )
/*++

Routine Description:

    frees a handle to the database returned from OpenComPortDataBase

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:

    None

--*/
{
    PDB_INFO dbInfo = HandleToDBInfo(HComDB);

    SanityCheckDBInfo(dbInfo);
    DestroyDBInfo(dbInfo);

    return ERROR_SUCCESS;
}

BOOL
EnterDB(
    PDB_INFO DBInfo
    )
{
    BOOL eventSignalled = FALSE;
    LONG res;
    DWORD type, size;

    WaitForSingleObject(DBInfo->AccessMutex, INFINITE);
    
    if (DBInfo->RegChangedEvent == INVALID_HANDLE_VALUE ||
        (eventSignalled = IsEventSignalled(DBInfo->RegChangedEvent))) {

        size = 0;
        res = RegQueryValueEx(DBInfo->DBKey,
                              szComDBName,
                              0,
                              &type,
                              0,
                              &size);

        //
        // Couldn't update the DB ... fail
        // 
        if (res != ERROR_SUCCESS || type != REG_BINARY) {
            ReleaseMutex(DBInfo->AccessMutex);
            return FALSE;
        }

        if (size != DBInfo->PortsLength) {
            ResizeDatabase(DBInfo, size * BITS_INA_BYTE);
        }

        RegQueryValueEx(DBInfo->DBKey,
                        szComDBName,
                        0,
                        &type,
                        DBInfo->Ports,
                        &size);

        //
        // Reregister the notification with the registry
        // 
        if (eventSignalled) {
            RegisterForNotification(DBInfo);
        }
    }

    return TRUE;
}

LONG
LeaveDB(
    PDB_INFO DBInfo,
    BOOL     CommitChanges
    )
{
    LONG retVal = ERROR_SUCCESS;

    if (CommitChanges) {
        if (RegSetValueEx(DBInfo->DBKey,
                          szComDBName,
                          0,
                          REG_BINARY,
                          DBInfo->Ports,
                          DBInfo->PortsLength) != ERROR_SUCCESS) {
            retVal = ERROR_CANTWRITE;
        }

        //
        // The setting of the value in the reg signals the event...but we don't 
        // need to resync w/the reg off of this change b/c it is our own!  Instead
        // reset the event and rereg for the event
        //
        if (DBInfo->RegChangedEvent != INVALID_HANDLE_VALUE) {
            RegisterForNotification(DBInfo);
        }
    }

    ReleaseMutex(DBInfo->AccessMutex);
    return retVal;
}

VOID
GetByteAndMask(
    PDB_INFO DBInfo,
    DWORD    ComNumber,
    PBYTE    *Byte,
    PBYTE    Mask
    )
{
    ComNumber--;
    *Byte = DBInfo->Ports + (ComNumber / BITS_INA_BYTE);
    *Mask = 1 << (ComNumber % BITS_INA_BYTE);
}

LONG
WINAPI
ComDBGetCurrentPortUsage (
    HCOMDB   HComDB,
    PBYTE    Buffer,
    DWORD    BufferSize,
    ULONG    ReportType, 
    LPDWORD  MaxPortsReported
    )
/*++
    
    Handle requests that require no synch w/DB first.

  --*/
{
    PDB_INFO dbInfo = HandleToDBInfo(HComDB);
    PBYTE    curSrc, curDest, endDest;
    BYTE     mask;

    SanityCheckDBInfo(dbInfo);

    if (!EnterDB(dbInfo))  {
        return ERROR_NOT_CONNECTED;
    }

    if (Buffer == 0) {
        if (!MaxPortsReported) {
            LeaveDB(dbInfo, FALSE);
            return ERROR_INVALID_PARAMETER;
        }
        else {
            *MaxPortsReported = dbInfo->PortsLength * BITS_INA_BYTE;
            return LeaveDB(dbInfo, FALSE);
        }
    }

    if (ReportType == CDB_REPORT_BITS) {
        if (BufferSize > dbInfo->PortsLength) {
            BufferSize = dbInfo->PortsLength;
        }
        memcpy(Buffer, dbInfo->Ports, BufferSize);
        if (MaxPortsReported) {
            *MaxPortsReported = BufferSize * BITS_INA_BYTE;
        }
    }
    else if (ReportType == CDB_REPORT_BYTES) {
        if (BufferSize > dbInfo->PortsLength * BITS_INA_BYTE) {
            BufferSize = dbInfo->PortsLength * BITS_INA_BYTE;
        }

        curSrc = dbInfo->Ports;
        endDest = Buffer + BufferSize;
        curDest = Buffer;

        for (mask = 1; curDest != endDest; curDest++) {
            *curDest = (*curSrc & mask) ? 1 : 0;
            if (mask & 0x80) {
                mask = 0x1;
                curSrc++;
            }
            else
                mask <<= 1;
        }
    }
    else {
        LeaveDB(dbInfo, FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    return LeaveDB(dbInfo, FALSE);
}

LONG
WINAPI
ComDBClaimNextFreePort (
    HCOMDB   HComDB,
    LPDWORD  ComNumber
    )
/*++

Routine Description:

    returns the first free COMx value

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:


    returns ERROR_SUCCESS if successful. or other ERROR_ if not

    if successful, then ComNumber will be that next free com value and claims it in the database


--*/
{
    PDB_INFO dbInfo = HandleToDBInfo(HComDB);
    DWORD    num;
    BOOL     commit = FALSE;
    PBYTE    curSrc, srcEnd;
    BYTE     mask;
    LONG     ret;

    SanityCheckDBInfo(dbInfo);

    if (!EnterDB(dbInfo)) {
        return ERROR_NOT_CONNECTED;
    }

    curSrc = dbInfo->Ports;
    srcEnd = curSrc + dbInfo->PortsLength;

    for (num = 3, mask = 0x4; curSrc != srcEnd; num++) {
        if (!(*curSrc & mask)) {
            *ComNumber = num;
            *curSrc |= mask;
            commit = TRUE;
            break;
        }
        else if (mask & 0x80) {
            mask = 0x1;
            curSrc++;
        }
        else {
            mask <<= 1;
        }
    }

    if (curSrc == srcEnd && !commit && num < COMDB_MAX_PORTS_ARBITRATED) {
        // DB entirely full
        ResizeDatabase(dbInfo, ((num / GROWTH_VALUE) + 1) * GROWTH_VALUE);
        *ComNumber = num;

        GetByteAndMask(dbInfo, num, &curSrc, &mask);
        *curSrc |= mask;    
        commit = TRUE;
    }

    ret = LeaveDB(dbInfo, commit);
    if (!commit) {
        ret = ERROR_NO_LOG_SPACE;
    }

    return ret;
}

LONG
WINAPI
ComDBClaimPort (
    HCOMDB   HComDB,
    DWORD    ComNumber,
    BOOL     ForceClaim,
    PBOOL    Forced
    )
/*++

Routine Description:

    Attempts to claim a com name in the database

Arguments:

    DataBaseHandle - returned from OpenComPortDataBase.

    ComNumber      - The port value to be claimed

    Force          - If TRUE, will force the port to be claimed even if in use already



Return Value:


    returns ERROR_SUCCESS if port name was not already claimed, or if it was claimed
                          and Force was TRUE.

    ERROR_SHARING_VIOLATION  if port name is use and Force is false


--*/
{
    PDB_INFO dbInfo = HandleToDBInfo(HComDB);
    PBYTE    curByte;
    BYTE     mask;
    BOOL     commit = TRUE;
    LONG     res;
    ULONG    newSize;
    
    BOOL f;
    if (!(Forced)) {
        Forced = &f;
    }
    SanityCheckComNumber(ComNumber);
    SanityCheckDBInfo(dbInfo);

    if (!EnterDB(dbInfo)) {
        return ERROR_NOT_CONNECTED;
    }

    if (ComNumber > dbInfo->PortsLength * BITS_INA_BYTE) {
        ResizeDatabase(dbInfo, ((ComNumber / GROWTH_VALUE) + 1) * GROWTH_VALUE);
    }

    GetByteAndMask(dbInfo, ComNumber, &curByte, &mask);

    if (*curByte & mask) {
        commit = FALSE;
        if (ForceClaim) {
            if (Forced)
                *Forced = TRUE;
        }
        else {
            res = LeaveDB(dbInfo, commit);
            if (res == ERROR_SUCCESS) {
                return ERROR_SHARING_VIOLATION;
            }
            else {
                return res;
            }
        }   
    }
    else {
        if (Forced)
            *Forced = FALSE;
        *curByte |= mask;
    }

    return LeaveDB(dbInfo, commit);
}

LONG
WINAPI
ComDBReleasePort (
    HCOMDB   HComDB, 
    DWORD    ComNumber
    )
/*++

Routine Description:

    un-claims the port in the database

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    ComNumber      - port to be unclaimed in database

Return Value:


    returns ERROR_SUCCESS if successful. or other ERROR_ if not


--*/
{
    PDB_INFO dbInfo = HandleToDBInfo(HComDB);
    PBYTE    byte;
    BYTE     mask;

    SanityCheckDBInfo(dbInfo);

    if (!EnterDB(dbInfo)) {
        return ERROR_NOT_CONNECTED;
    }

    if (ComNumber > dbInfo->PortsLength * BITS_INA_BYTE) {
        LeaveDB(dbInfo, FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    GetByteAndMask(dbInfo, ComNumber, &byte, &mask);
    *byte &= ~mask;

    return LeaveDB(dbInfo, TRUE);
}

LONG
WINAPI
ComDBResizeDatabase (
    HCOMDB   HComDB, 
    DWORD    NewSize
    )
/*++

Routine Description:

    Resizes the database to the new size.  To get the current size, call
    ComDBGetCurrentPortUsage with a Buffer == NULL.

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    NewSize        - must be a multiple of 1024, with a max of 4096
    
Return Value:

    returns ERROR_SUCCESS if successful
            ERROR_BAD_LENGTH if NewSize is not greater than the current size or
                             NewSize is greater than COMDB_MAX_PORTS_ARBITRATED

--*/
{
    PDB_INFO dbInfo = HandleToDBInfo(HComDB);
    BOOL     commit = FALSE;

    SanityCheckDBInfo(dbInfo);

    if (NewSize % GROWTH_VALUE) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!EnterDB(dbInfo)) {
        return ERROR_NOT_CONNECTED;
    }

    if (NewSize > COMDB_MAX_PORTS_ARBITRATED ||
        dbInfo->PortsLength * BITS_INA_BYTE >= NewSize) {
        LeaveDB(dbInfo, FALSE);
        return ERROR_BAD_LENGTH;
    }

    ResizeDatabase(dbInfo, NewSize);

    return LeaveDB(dbInfo, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\advandlg.c ===
///////////////////////////////////////////////////////////////////////////
// Advanced Dialog Functions
///////////////////////////////////////////////////////////////////////////

#include "ports.h"
#include "pp.h"

#include <windowsx.h>

#define COBJMACROS 1

#include <ole2.h>
#include <initguid.h>
#include <oleacc.h>
#include <winable.h>

//
// write out values in tenths of a sec
//
#define SECONDS_CONVERSION_FACTOR  (10)
#define NUM_POLLING_PERIODS 7

DWORD PollingPeriods[NUM_POLLING_PERIODS] = {
           -1,
            0,
            1 * SECONDS_CONVERSION_FACTOR,
            5 * SECONDS_CONVERSION_FACTOR,
            10 * SECONDS_CONVERSION_FACTOR,
            30 * SECONDS_CONVERSION_FACTOR,
            60 * SECONDS_CONVERSION_FACTOR
            };

TCHAR PeriodDescription[NUM_POLLING_PERIODS+1][40] = {
    { _T("Disabled") },
    { _T("Manually") },
    { _T("Every second") },
    { _T("Every 5 seconds") },
    { _T("Every 10 seconds") },
    { _T("Every 30 seconds") },
    { _T("Every minute") },
    { _T("Other (every %d sec)") }
    };

ULONG RxValues[4] = { 1, 4, 8, 14};

WCHAR RxValuesStringMap[] = L"A:0:1:1:2:4:3:8:4:14:";
WCHAR TxValuesStringMap[] = L"use_raw";

TCHAR m_szRxFIFO[] =        _T("RxFIFO");
TCHAR m_szTxFIFO[] =        _T("TxFIFO");
TCHAR m_szFifoRxMax[] =     _T("FifoRxMax");
TCHAR m_szFifoTxMax[] =     _T("FifoTxMax");

const DWORD AdvanHelpIDs[] =
{
    IDC_DESC_1,             IDH_NOHELP,
    IDC_DESC_2,             IDH_NOHELP,

    IDC_FIFO,               IDH_DEVMGR_PORTSET_ADV_USEFIFO, // "Use FIFO buffers (requires 16550 compatible UART)" (Button)

    IDC_RECEIVE_TEXT,       IDH_NOHELP,                     // "&Receive Buffer:" (Static)
    IDC_RECEIVE_SLIDER,     IDH_DEVMGR_PORTSET_ADV_RECV,    // "" (msctls_trackbar32)
    IDC_RECEIVE_LOW,        IDH_NOHELP,                     // "Low (%d)" (Static)
    IDC_RECEIVE_HIGH,       IDH_NOHELP,                     // "High (%d)" (Static)
    IDC_RXVALUE,            IDH_NOHELP,

    IDC_TRANSMIT_TEXT,      IDH_NOHELP,                     // "&Transmit Buffer:" (Static)
    IDC_TRANSMIT_SLIDER,    IDH_DEVMGR_PORTSET_ADV_TRANS,   // "" (msctls_trackbar32)
    IDC_TRANSMIT_LOW,       IDH_NOHELP,                     // "Low (%d)" (Static)
    IDC_TRANSMIT_HIGH,      IDH_NOHELP,                     // "High (%d)" (Static)
    IDC_TXVALUE,            IDH_NOHELP,

    IDC_POLL_DESC,          IDH_NOHELP,
    IDC_POLL_PERIOD,        IDH_DEVMGR_PORTSET_ADV_DEVICES, // "" (ComboBox)

    PP_PORT_NUMBER,         IDH_DEVMGR_PORTSET_ADV_NUMBER,  // "" (ComboBox)
    IDC_COMNUMTEXT,         IDH_NOHELP,                     // "COM &Port Number:" (Static)

    IDC_RESTORE,            IDH_DEVMGR_PORTSET_ADV_DEFAULTS,// "&Restore Defaults" (Button)
    0, 0
};

#define Trackbar_SetPos(hwndTb, Redraw, Position)\
    (VOID) SendMessage(hwndTb, TBM_SETPOS, (WPARAM) Redraw, (LPARAM) Position)

#define Trackbar_SetRange(hwndTb, Redraw, MinVal, MaxVal)\
    (VOID) SendMessage(hwndTb, TBM_SETRANGE, (WPARAM) Redraw, (LPARAM) MAKELONG(MinVal, MaxVal))

#define Trackbar_SetTic(hwndTb, Tic)\
    (VOID) SendMessage(hwndTb, TBM_SETTIC, (WPARAM) 0, (LPARAM) Tic)

#define Trackbar_GetPos(hwndTb)\
    (DWORD) SendMessage(hwndTb, TBM_GETPOS, (WPARAM) 0, (LPARAM) 0)



BOOL
Advanced_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );


BOOL
Advanced_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

void
Advanced_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
Advanced_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

/*++

Routine Description: AdvancedPortsDlgProc

    The windows proc for the Advanced properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if the page could not be created

--*/
INT_PTR APIENTRY
AdvancedPortsDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {
    case WM_COMMAND:
        return Advanced_OnCommand(hDlg,
                                  (int) LOWORD(wParam),
                                  (HWND)lParam,
                                  (UINT) HIWORD(wParam));

    case WM_CONTEXTMENU:
        return Advanced_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        Advanced_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_HSCROLL:
        HandleTrackbarChange(hDlg, (HWND) lParam);
        return TRUE;

    case WM_INITDIALOG:
        return Advanced_OnInitDialog(hDlg, (HWND) wParam, lParam);
    }

    return FALSE;
} /* AdvancedPortsDlgProc */

BOOL
Advanced_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PADVANCED_DATA advancedData =
        (PADVANCED_DATA) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch(ControlId) {

    case IDC_FIFO:
        //
        // Disable or enable the sliders
        //
        EnableFifoControls(ParentHwnd, IsDlgButtonChecked(ParentHwnd, IDC_FIFO));
        return TRUE;

    case IDOK:
        SaveAdvancedSettings(ParentHwnd, advancedData);
        // fall through

    case IDCANCEL:
        EndDialog(ParentHwnd, ControlId);
        return TRUE;

    case IDC_RESTORE:
        RestoreAdvancedDefaultState(ParentHwnd, advancedData);
        return TRUE;
    }

    return FALSE;
}

BOOL
Advanced_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            m_szDevMgrHelp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) AdvanHelpIDs);

    return FALSE;
}

void
Advanced_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                 m_szDevMgrHelp,
                 HELP_WM_HELP,
                 (ULONG_PTR) AdvanHelpIDs);
    }
}

BOOL
Advanced_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PADVANCED_DATA advancedData;
    TCHAR          szFormat[200];
    TCHAR          szBuffer[200];

    advancedData = (PADVANCED_DATA) Lparam;

    //
    // Initialize the dialog box parameters
    //
    FillAdvancedDlg(ParentHwnd, advancedData);
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) advancedData);

    //
    // Set up the dialog box with these initialized parameters
    //
    InitializeControls(ParentHwnd, advancedData);

    LoadString(g_hInst, IDS_ADVANCED_SETTINGS_FOR, szFormat, CharSizeOf(szFormat));
    wsprintf(szBuffer, szFormat, advancedData->szComName);
    SetWindowText(ParentHwnd, szBuffer);


    return TRUE;
}

// @@BEGIN_DDKSPLIT
LONG
SerialDisplayAdvancedSettings(
    IN HWND             ParentHwnd,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    ADVANCED_DATA advancedData;
    HKEY          hDeviceKey;
    DWORD         dwPortNameSize;

    if (!DeviceInfoSet) {
        return ERROR_INVALID_PARAMETER;
    }

    advancedData.HidePolling = TRUE;
    advancedData.DeviceInfoSet = DeviceInfoSet;
    advancedData.DeviceInfoData = DeviceInfoData;

    //
    // Open the device key for the source device instance, and retrieve its
    // "PortName" value.
    //
    hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                      DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_READ);

    if (INVALID_HANDLE_VALUE == hDeviceKey)
        return ERROR_ACCESS_DENIED;

    dwPortNameSize = sizeof(advancedData.szComName);
    if (RegQueryValueEx(hDeviceKey,
                        m_szPortName,
                        NULL,
                        NULL,
                        (PBYTE) advancedData.szComName,
                        &dwPortNameSize) != ERROR_SUCCESS) {
        RegCloseKey(hDeviceKey);
        return  ERROR_INVALID_DATA;
    }
    RegCloseKey(hDeviceKey);

    return DisplayAdvancedDialog(ParentHwnd, &advancedData) ? ERROR_SUCCESS
                                                            : ERROR_ACCESS_DENIED;
}
// @@END_DDKSPLIT

BOOL InternalAdvancedDialog(
    IN     HWND           ParentHwnd,
    IN OUT PADVANCED_DATA AdvancedData
    )
{
    AdvancedData->hComDB = HCOMDB_INVALID_HANDLE_VALUE;
    ComDBOpen(&AdvancedData->hComDB);

    DialogBoxParam(g_hInst,
                   MAKEINTRESOURCE(DLG_PP_ADVPORTS),
                   ParentHwnd,
                   AdvancedPortsDlgProc,
                   (DWORD_PTR) AdvancedData);

    ComDBClose(AdvancedData->hComDB);
    AdvancedData->hComDB = HCOMDB_INVALID_HANDLE_VALUE;

    return TRUE;
}

// @@BEGIN_DDKSPLIT
BOOL
FindAdvancedDialogOverride(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PTCHAR           Value
    )
/*++

Routine Description:

    Checks the driver key in the devnode for the override value.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information

    DeviceInfoData - Supplies the address of the device information element

    Value          - Value read in from the registry

Return Value:

    If found TRUE, otherwise FALSE

--*/
{
    HKEY    hKey;
    TCHAR   szLine[LINE_LEN];
    DWORD   dwDataType, dwSize;
    TCHAR   szOverrideName[] = _T("EnumAdvancedDialog");

    //
    // Open up the driver key for this device so we can run our INF registry mods
    // against it.
    //
    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ);

    dwSize = sizeof(szLine);
    if (RegQueryValueEx(hKey,
                        szOverrideName,
                        NULL,
                        &dwDataType,
                        (PBYTE) &szLine,
                        &dwSize) != ERROR_SUCCESS ||
        dwDataType != REG_SZ) {
        RegCloseKey(hKey);
        return FALSE;
    }

    lstrcpy(Value, szLine);
    RegCloseKey(hKey);
    return TRUE;
}

BOOL
CallAdvancedDialogOverride(
    IN HWND           ParentHwnd,
    IN PADVANCED_DATA AdvancedData,
    PTCHAR            Override,
    PBOOL             Success
    )
{
    PTCHAR                  szProc = NULL;
    HINSTANCE               hInst = NULL;
    PPORT_ADVANCED_DIALOG   pfnAdvanced = NULL;
    TCHAR                   szNewComName[50];
    HKEY                    hDeviceKey;
    DWORD                   dwSize;
    TCHAR                   szMfg[LINE_LEN];

#ifdef UNICODE
    CHAR                    szFunction[LINE_LEN];
#endif

    szProc = _tcschr(Override, _T(','));
    if (!szProc) {
        return FALSE;
    }

    *szProc = _T('\0');
    szProc++;

    hInst = LoadLibrary(Override);
    if (!hInst) {
        return FALSE;
    }

#ifdef UNICODE
    WideCharToMultiByte(CP_ACP,
                        0,
                        szProc,
                        lstrlen(szProc) + 1,
                        szFunction,
                        sizeof(szFunction),
                        NULL,
                        NULL);

    pfnAdvanced = (PPORT_ADVANCED_DIALOG) GetProcAddress(hInst, szFunction);
#else
    pfnAdvanced = (PPORT_ADVANCED_DIALOG) GetProcAddress(hInst, szProc);
#endif
    if (!pfnAdvanced) {
        FreeLibrary(hInst);
        return FALSE;
    }

    _try
    {
        *Success = (*pfnAdvanced) (ParentHwnd,
                                   AdvancedData->HidePolling,
                                   AdvancedData->DeviceInfoSet,
                                   AdvancedData->DeviceInfoData,
                                   NULL);

    }
    _except(UnhandledExceptionFilter(GetExceptionInformation()))
    {
        *Success = FALSE;
    }

    //
    // Make sure the new com name is zero terminated in case of error
    //
    AdvancedData->szComName[0] = TEXT('\0');

    //
    // Open the device key for the source device instance, and retrieve its
    // "PortName" value in case the override dialog changed it.
    //
    hDeviceKey = SetupDiOpenDevRegKey(AdvancedData->DeviceInfoSet,
                                      AdvancedData->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_READ);

    if (INVALID_HANDLE_VALUE != hDeviceKey) {
        dwSize = sizeof(szNewComName);
        if (RegQueryValueEx(hDeviceKey,
                            m_szPortName,
                            NULL,
                            NULL,
                            (PBYTE) szNewComName,
                            &dwSize) == ERROR_SUCCESS) {
            lstrcpy(AdvancedData->szComName, szNewComName);
        }
        RegCloseKey(hDeviceKey);
    }

    FreeLibrary(hInst);
    return TRUE;
}
// @@END_DDKSPLIT

/*++

Routine Description: DisplayAdvancedDialog

    Opens the devices instance and checks to see if it is valid.  If so, then the advanced
    dialog is displayed.  Otherwise a message is displayed to the user stating that the user
    does not have write access to this particular key.

Arguments:

    ParentHwnd - Handle to the parent dialog (Port Settings Property Sheet)
    AdvancedData - hDeviceKey will be set with the device's key in the registry upon success,
                    INVALID_HANDLE_VALUE upon error

Return Value:

    None

--*/
BOOL DisplayAdvancedDialog(
    IN      HWND           ParentHwnd,
    IN OUT  PADVANCED_DATA AdvancedData
    )
{
    AdvancedData->hDeviceKey =
        SetupDiOpenDevRegKey(AdvancedData->DeviceInfoSet,
                             AdvancedData->DeviceInfoData,
                             DICS_FLAG_GLOBAL,
                             0,
                             DIREG_DEV,
                             KEY_ALL_ACCESS);

    if (AdvancedData->hDeviceKey == INVALID_HANDLE_VALUE) {
        MyMessageBox(ParentHwnd,
                     IDS_NO_WRITE_PRVILEGE,
                     IDS_NAME_PROPERTIES,
                     MB_OK | MB_ICONINFORMATION);
        return FALSE;
    }
    else {
// @@BEGIN_DDKSPLIT
        TCHAR szOverride[LINE_LEN];
        BOOL  success = FALSE;

        if (FindAdvancedDialogOverride(AdvancedData->DeviceInfoSet,
                                       AdvancedData->DeviceInfoData,
                                       szOverride) &&
            CallAdvancedDialogOverride(ParentHwnd,
                                       AdvancedData,
                                       szOverride,
                                       &success)) {
            RegCloseKey(AdvancedData->hDeviceKey);
            return success;
        }
        else {
// @@END_DDKSPLIT
            return InternalAdvancedDialog(ParentHwnd, AdvancedData);
// @@BEGIN_DDKSPLIT
        }
// @@END_DDKSPLIT
    }
}

/*++

Routine Description: EnableFifoControls

    Enables/Disables all of the controls bounded by the rectangle with the Use Fifo
    checkbox.

Arguments:

    hDlg - Handle to the dialog
    enabled - flag to either enable/disable the controls

Return Value:

    None

--*/
void EnableFifoControls(IN HWND hDlg,
                        IN BOOL enabled)
{
   // The actual trackbar/slider
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_SLIDER), enabled);

   // "Low (xxx)" (Receive)
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_LOW), enabled);

   // "High (xxx)" (Receive)
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_HIGH), enabled);

   // "Receive Buffer:  "
   EnableWindow(GetDlgItem(hDlg, IDC_RECEIVE_TEXT), enabled);

   // "(xxx)" (Actual value of trackbar, Receive)
   EnableWindow(GetDlgItem(hDlg, IDC_RXVALUE), enabled);

   // The actual trackbar/slider
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_SLIDER), enabled);

   // "Low (xxx)" (Transmit)
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_LOW), enabled);

   // "High (xxx)" (Transmit)
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_HIGH), enabled);

   // "Transmit Buffer" (Transmit)
   EnableWindow(GetDlgItem(hDlg, IDC_TRANSMIT_TEXT), enabled);

   // "(xxx)" (Actual value of trackbar, Trasmist)
   EnableWindow(GetDlgItem(hDlg, IDC_TXVALUE), enabled);
}

/*++

Routine Description: HandleTrackbarChange

    Whenever the user changes the trackbar thumb position, update the control
    to its right which displays its actual numeric value

Arguments:

    hDlg - Handle to the parent dialog
    hTrackbar - Handle to the trackbar whose thumb has changed

Return Value:

    None

--*/
void HandleTrackbarChange(IN HWND hDlg,
                          IN HWND hTrackbar
                          )
{
    DWORD ctrlID;
    TCHAR szCurrentValue[10];
    ULONG position;

    position = Trackbar_GetPos(hTrackbar);

    if (GetDlgCtrlID(hTrackbar) == IDC_RECEIVE_SLIDER) {
        //
        // Rx we need to translate the tick position from index to value
        //
        wsprintf(szCurrentValue, TEXT("(%d)"), RxValues[position-1]);
        ctrlID = IDC_RXVALUE;
    }
    else {
        //
        // Tx is just a straight translation between value and index
        //
        wsprintf(szCurrentValue, TEXT("(%d)"), position);
        ctrlID = IDC_TXVALUE;
    }
    SetDlgItemText(hDlg, ctrlID, szCurrentValue);
}

DWORD
RxValueToTrackbarPosition(IN OUT PDWORD RxValue
               )
{
    switch (*RxValue) {
    case 1:  return 1;
    case 4:  return 2;
    case 8:  return 3;
    case 14: return 4;
    }

    //
    // busted value
    //
    *RxValue = 14;
    return 4;
}

/*++

Routine Description:   SetTxTrackbarTicks

    Creates a tick at 1/4, half, and 3/4 across the span of the trackbar

Arguments:

    hTrackbar - handle to the trackbar that will receive the ticks
    minVal, maxVal - Range on the trackbar

Return Value:

    None

--*/
void
SetTxTrackbarTics(
    IN HWND   TrackbarHwnd
    )
{
    Trackbar_SetTic(TrackbarHwnd, 6);
    Trackbar_SetTic(TrackbarHwnd, 11);
}

/*++

Routine Description:  SetLabelText

    Sets the label's to the string identified by resID concated with the passed
    in value and closing paren.

    The final string is  [resID string][value])

Arguments:

    hLabel - handle to the control whose text is going to change
    resID  - resource ID for the beginning of the string that will become the
              label's text
    value  - number to be concated into the string


Return Value:

    None

--*/
void
SetLabelText(
    IN HWND     LabelHwnd,
    IN DWORD    ResId,
    IN ULONG    Value
    )
{
    TCHAR szTemp[258], txt[258];

    if (LoadString(g_hInst, ResId, szTemp, CharSizeOf(szTemp))) {
        lstrcpy(txt, szTemp);
        wsprintf(szTemp, _T("%d)"), Value);
        lstrcat(txt, szTemp);
    }
    else {
        lstrcpy(txt, _T("Low"));
    }
    SetWindowText(LabelHwnd, txt);
}

/*++

Routine Description: InitializeControls

    Initializes all of the controls that represent Fifo

Arguments:

    ParentHwnd - handle to the dialog
    AdvancedData - Contains all of the initial values

Return Value:

    None

--*/
void InitializeControls(
    IN HWND           ParentHwnd,
    IN PADVANCED_DATA AdvancedData
    )
{
    TCHAR    szCurrentValue[40];
    HWND     hwnd;
    int      i, periodIdx;

    //
    // Set up the Fifo buffers checkbox
    //
    if (!AdvancedData->UseFifoBuffersControl) {
        //
        // Something went wrong with the Fifo buffers control. Disable
        // the checkbox
        //
        CheckDlgButton(ParentHwnd, IDC_FIFO, BST_UNCHECKED);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), FALSE);
        EnableFifoControls(ParentHwnd, FALSE);
    }
    else {
        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), TRUE);

        if (!AdvancedData->UseFifoBuffers) {
            EnableFifoControls(ParentHwnd, FALSE);
            CheckDlgButton(ParentHwnd, IDC_FIFO, BST_UNCHECKED);
        }
        else {
            EnableFifoControls(ParentHwnd, TRUE);
            CheckDlgButton(ParentHwnd, IDC_FIFO, BST_CHECKED);
        }
    }

    //
    // Set up the sliders
    //
    if (!AdvancedData->UseRxFIFOControl ||
        !AdvancedData->UseTxFIFOControl) {
        //
        // Something went wrong with the sliders.
        // Disable them
        //
        CheckDlgButton(ParentHwnd, IDC_FIFO, BST_UNCHECKED);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), FALSE);
        EnableFifoControls(ParentHwnd, FALSE);
    }
    else {
        IAccPropServices * pAccPropServices = NULL;
        HRESULT        hr;
        
        //
        // Set up Rx Slider
        //
        hwnd = GetDlgItem(ParentHwnd, IDC_RECEIVE_SLIDER);

        Trackbar_SetRange(hwnd, TRUE, RX_MIN, 4);
        Trackbar_SetPos(hwnd,
                        TRUE,
                        RxValueToTrackbarPosition(&AdvancedData->RxFIFO));

        SetLabelText(GetDlgItem(ParentHwnd, IDC_RECEIVE_LOW),
                     IDS_LOW,
                     RX_MIN);
        SetLabelText(GetDlgItem(ParentHwnd, IDC_RECEIVE_HIGH),
                     IDS_HIGH,
                     AdvancedData->FifoRxMax);

        wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->RxFIFO);
        SetDlgItemText(ParentHwnd, IDC_RXVALUE, szCurrentValue);

        //
        // Create the mapping for this slider for accessibility
        //
        hr = CoCreateInstance(&CLSID_AccPropServices,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              &IID_IAccPropServices,
                              (PVOID *) &pAccPropServices);

        if (SUCCEEDED(hr) && pAccPropServices != NULL) {
            IAccPropServices_SetHwndPropStr(pAccPropServices,
                                            hwnd,
                                            OBJID_CLIENT,
                                            CHILDID_SELF,
                                            PROPID_ACC_VALUEMAP,
                                            RxValuesStringMap);

            IAccPropServices_Release(pAccPropServices);
        }

        //
        // Set up the Tx slider
        //
        hwnd = GetDlgItem(ParentHwnd, IDC_TRANSMIT_SLIDER);
        Trackbar_SetRange(hwnd, TRUE, TX_MIN, AdvancedData->FifoTxMax);
        Trackbar_SetPos(hwnd, TRUE, AdvancedData->TxFIFO);

        SetTxTrackbarTics(hwnd);

        SetLabelText(GetDlgItem(ParentHwnd, IDC_TRANSMIT_LOW),
                     IDS_LOW,
                     TX_MIN);
        SetLabelText(GetDlgItem(ParentHwnd, IDC_TRANSMIT_HIGH),
                     IDS_HIGH,
                     AdvancedData->FifoTxMax);

        wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->TxFIFO);
        SetDlgItemText(ParentHwnd, IDC_TXVALUE, szCurrentValue);
    
        //
        // Create the mapping for this slider for accessibility
        //
        hr = CoCreateInstance(&CLSID_AccPropServices,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              &IID_IAccPropServices,
                              (PVOID *) &pAccPropServices);

        if (SUCCEEDED(hr) && pAccPropServices != NULL) {
            IAccPropServices_SetHwndPropStr(pAccPropServices,
                                            hwnd,
                                            OBJID_CLIENT,
                                            CHILDID_SELF,
                                            PROPID_ACC_VALUEMAP,
                                            TxValuesStringMap);

            IAccPropServices_Release(pAccPropServices);
        }
    }

    FillPortNameCb(ParentHwnd, AdvancedData);

    if (!AdvancedData->HidePolling) {

        //
        // Add the descriptions for each polling period and select the current
        // setting
        //
        hwnd = GetDlgItem(ParentHwnd, IDC_POLL_PERIOD);
        periodIdx = NUM_POLLING_PERIODS;
        for (i = 0; i < NUM_POLLING_PERIODS; i++) {
            ComboBox_AddString(hwnd, PeriodDescription[i]);
            if (PollingPeriods[i] == AdvancedData->PollingPeriod) {
                periodIdx = i;
            }
        }

        if (periodIdx == NUM_POLLING_PERIODS) {
            wsprintf(szCurrentValue,
                     PeriodDescription[NUM_POLLING_PERIODS],
                     AdvancedData->PollingPeriod / SECONDS_CONVERSION_FACTOR);
            ComboBox_AddString(hwnd, szCurrentValue);
        }

        ComboBox_SetCurSel(hwnd, periodIdx);
    }
    else {
       ShowWindow(GetDlgItem(ParentHwnd, IDC_POLL_PERIOD), SW_HIDE);
       ShowWindow(GetDlgItem(ParentHwnd, IDC_POLL_DESC), SW_HIDE);
    }
} /* InitializeControls */


/*++

Routine Description:  RestoreAdvancedDefaultState

    Restores all values and UI to their default state, specifically:
    o All Fifo related child controls are enabled
    o The Rx trackbar is set to its max value
    o The Tx trackbar is set to its max value
    o The number of the comport is reset to its original value

Return Value:

    None

--*/
void RestoreAdvancedDefaultState(
    IN HWND           ParentHwnd,
    IN PADVANCED_DATA AdvancedData
    )
{
    USHORT ushIndex;
    TCHAR  szCurrentValue[10];
    int    i;

    //
    // Set up the Fifo buffers checkbox
    //
    EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), TRUE);

    EnableFifoControls(ParentHwnd, TRUE);
    CheckDlgButton(ParentHwnd, IDC_FIFO, BST_CHECKED);

    //
    // Set up the sliders and the static control that show their numberic value
    //
    Trackbar_SetPos(GetDlgItem(ParentHwnd, IDC_RECEIVE_SLIDER),
                    TRUE,
                    RxValueToTrackbarPosition(&AdvancedData->FifoRxMax));
    wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->FifoRxMax);
    SetDlgItemText(ParentHwnd, IDC_RXVALUE, szCurrentValue);

    Trackbar_SetPos(GetDlgItem(ParentHwnd, IDC_TRANSMIT_SLIDER), TRUE, AdvancedData->FifoTxMax);
    wsprintf(szCurrentValue, TEXT("(%d)"), AdvancedData->FifoTxMax);
    SetDlgItemText(ParentHwnd, IDC_TXVALUE, szCurrentValue);

    //
    // Set the COM name to whatever it is currently set to in the registry
    //
    ushIndex =
        (USHORT) ComboBox_FindString(GetDlgItem(ParentHwnd, PP_PORT_NUMBER),
                                     -1,
                                     AdvancedData->szComName);

    ushIndex = (ushIndex == CB_ERR) ? 0 : ushIndex;

    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, PP_PORT_NUMBER), ushIndex);
    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, IDC_POLL_PERIOD), POLL_PERIOD_DEFAULT_IDX);
} /* RestoreAdvancedDefaultStates */


/*++

Routine Description: FillPortNameCb

    fill in the Port Name combo box selection with a list
    of possible un-used portnames

Arguments:

    poppOurPropParams: where to save the data to
    hDlg:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
FillPortNameCb(
    HWND            ParentHwnd,
    PADVANCED_DATA  AdvancedData
    )
{
    BYTE  portUsage[MAX_COM_PORT/8];
    DWORD tmp, portsReported;
    int   i, j, nEntries;
    int   nCurPortNum;
    TCHAR szCom[40];
    TCHAR szInUse[40];
    char  mask, *current;
    HWND  portHwnd;

    portHwnd = GetDlgItem(ParentHwnd, PP_PORT_NUMBER);

    //
    // Check if our ComName is blank. If it is, disable the com port selector
    //
    if (_tcscmp(AdvancedData->szComName, TEXT("")) == 0) {
        EnableWindow(portHwnd, FALSE);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_COMNUMTEXT), FALSE);
        return 0;
    }

    //
    // assumes szComPort filled in...
    //
    nCurPortNum = myatoi(&AdvancedData->szComName[3]);

    if (!LoadString(g_hInst, IDS_IN_USE, szInUse, CharSizeOf(szInUse))) {
        wcscpy(szInUse, _T(" (in use)"));
    }

    //
    // first tally up which ports NOT to offer in list box
    //
    ZeroMemory(portUsage, MAX_COM_PORT/8);

    if (AdvancedData->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
        ComDBGetCurrentPortUsage(AdvancedData->hComDB,
                                 portUsage,
                                 MAX_COM_PORT / 8,
                                 CDB_REPORT_BITS,
                                 &portsReported);
    }

    //
    // tag the current port as not in use so it shows up in the CB
    //
    current = portUsage + (nCurPortNum-1) / 8;
    if ((i = nCurPortNum % 8))
        *current &= ~(1 << (i-1));
    else
        *current &= ~(0x80);

    current = portUsage;
    mask = 0x1;
    for(nEntries = j = 0, i = MIN_COM-1; i < MAX_COM_PORT; i++) {

       wsprintf(szCom, TEXT("COM%d"), i+1);
       if (*current & mask) {
           wcscat(szCom, szInUse);
       }

       if (mask == (char) 0x80) {
           mask = 0x01;
           current++;
       }
       else {
           mask <<= 1;
       }

       ComboBox_AddString(portHwnd, szCom);
   }

   ComboBox_SetCurSel(portHwnd, nCurPortNum-1);
   return 0;
} /* FillPortNamesCb */

/*++

Routine Description: FillAdvancedDlg

    fill in the advanced dialog window

Arguments:

    poppOurPropParams: the data to fill in
    ParentHwnd:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
FillAdvancedDlg(
    IN HWND             ParentHwnd,
    IN PADVANCED_DATA   AdvancedData
    )
{
   PSP_DEVINFO_DATA DeviceInfoData = AdvancedData->DeviceInfoData;
   HKEY  hDeviceKey;
   DWORD dwSize, dwData, dwFifo, dwError = ERROR_SUCCESS;

   //
   // Open the device key for the source device instance
   //
   hDeviceKey = AdvancedData->hDeviceKey;

   //
   // Get COM Name
   //
   dwSize = sizeof(AdvancedData->szComName);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szPortName,
                             NULL,
                             NULL,
                             (PBYTE)AdvancedData->szComName,
                             &dwSize);

   if (dwError != ERROR_SUCCESS) {
      wsprintf(AdvancedData->szComName, TEXT("COMX"));
   }

   //
   // Get ForceFifoEnable information
   //
   AdvancedData->UseFifoBuffersControl = TRUE;

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szFIFO,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->UseFifoBuffersControl = TRUE;
      if (dwFifo == 0) {
         AdvancedData->UseFifoBuffers = FALSE;
      }
      else {
         AdvancedData->UseFifoBuffers = TRUE;
      }
   }
   else {
      //
      // value does not exist. Create our own
      //
      dwData = 1;
      dwSize = sizeof(dwSize);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szFIFO,
                              0,
                              REG_DWORD,
                              (CONST BYTE *)(&dwData),
                              dwSize);

      if (dwError == ERROR_SUCCESS) {
         AdvancedData->UseFifoBuffers = TRUE;
      }
      else {
         AdvancedData->UseFifoBuffers = FALSE;
         AdvancedData->UseFifoBuffersControl = FALSE;
      }
   }

   //
   // Get FifoRxMax information
   //
   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szFifoRxMax,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwFifo);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->FifoRxMax = dwFifo;
      if (AdvancedData->FifoRxMax > RX_MAX) {
          AdvancedData->FifoRxMax = RX_MAX;
      }
   }
   else {
      //
      // value does not exist. Create our own
      //
      AdvancedData->FifoRxMax = RX_MAX;
   }

   //
   // Get RxFIFO information
   //
   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szFifoTxMax,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->FifoTxMax = dwFifo;
      if (AdvancedData->FifoTxMax > TX_MAX) {
          AdvancedData->FifoTxMax = TX_MAX;
      }
   }
   else {
      //
      // value does not exist. Create our own
      //
      AdvancedData->FifoTxMax = TX_MAX;
   }

   //
   // Get RxFIFO information
   //
   AdvancedData->UseRxFIFOControl = TRUE;

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szRxFIFO,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->RxFIFO = dwFifo;
      if (AdvancedData->RxFIFO > RX_MAX) {
          goto SetRxFIFO;
      }
   }
   else {
SetRxFIFO:
      //
      // value does not exist. Create our own
      //
      dwData = AdvancedData->FifoRxMax;
      dwSize = sizeof(dwData);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szRxFIFO,
                              0,
                              REG_DWORD,
                              (CONST BYTE *)(&dwData),
                              dwSize);

      if (dwError == ERROR_SUCCESS) {
         AdvancedData->RxFIFO = AdvancedData->FifoRxMax;
      }
      else {
         AdvancedData->RxFIFO = 0;
         AdvancedData->UseRxFIFOControl = FALSE;
      }
   }

   //
   // Get TxFIFO information
   //
   AdvancedData->UseTxFIFOControl = TRUE;

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szTxFIFO,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->TxFIFO = dwFifo;
      if (AdvancedData->TxFIFO > TX_MAX) {
          goto SetTxFIFO;
      }
   }
   else {
SetTxFIFO:
      //
      // value does not exist. Create our own
      //
      dwData = AdvancedData->FifoTxMax;
      dwSize = sizeof(dwData);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szTxFIFO,
                              0,
                              REG_DWORD,
                              (LPBYTE)(&dwData),
                              dwSize);

      if (dwError == ERROR_SUCCESS) {
         AdvancedData->TxFIFO = AdvancedData->FifoTxMax;
      }
      else {
         AdvancedData->TxFIFO = 0;
         AdvancedData->UseTxFIFOControl = FALSE;
      }
   }

   //
   // Get Polling Period information
   //
   AdvancedData->PollingPeriod = PollingPeriods[POLL_PERIOD_DEFAULT_IDX];

   dwSize = sizeof(dwFifo);
   dwError = RegQueryValueEx(hDeviceKey,
                             m_szPollingPeriod,
                             NULL,
                             NULL,
                             (LPBYTE)(&dwFifo),
                             &dwSize);

   if (dwError == ERROR_SUCCESS) {
      //
      // Save this initial value
      //
      AdvancedData->PollingPeriod = dwFifo;
   }
   else {
      //
      // value does not exist. Create our own
      //
      dwData = AdvancedData->PollingPeriod;
      dwSize = sizeof(dwData);
      dwError = RegSetValueEx(hDeviceKey,
                              m_szPollingPeriod,
                              0,
                              REG_DWORD,
                              (LPBYTE)(&dwData),
                              dwSize);
   }

   RegCloseKey(hDeviceKey);

   if (ERROR_SUCCESS != dwError) {
      return dwError;
   }
   else {
      return ERROR_SUCCESS;
   }
} /* FillAdvancedDlg*/

void
ChangeParentTitle(
    IN HWND    Hwnd,
    IN LPCTSTR OldComName,
    IN LPCTSTR NewComName
    )
{
    INT    textLength, offset, newNameLen, oldNameLen;
    PTCHAR oldTitle = NULL, newTitle = NULL;
    PTCHAR oldLocation;

    textLength = GetWindowTextLength(Hwnd);
    if (textLength == 0) {
        return;
    }

    //
    // Account for null char and unicode
    //
    textLength++;
    oldTitle = (PTCHAR) LocalAlloc(LPTR, textLength * sizeof(TCHAR));
    if (!oldTitle) {
        return;
    }

    if (!GetWindowText(Hwnd, oldTitle, textLength)) {
        goto exit;
    }

    oldLocation = wcsstr(oldTitle, OldComName);
    if (!oldLocation) {
        goto exit;
    }

    newNameLen = lstrlen(NewComName);
    oldNameLen = lstrlen(OldComName);
    offset = newNameLen - oldNameLen;
    if (offset > 0) {
        textLength += offset;
    }
    newTitle = (PTCHAR) LocalAlloc(LPTR, textLength * sizeof(TCHAR));
    if (!newTitle) {
        goto exit;
    }

    //
    // Find the OldComName in the title and do the following
    // 1)  up to that location in the string
    // 2)  copy the new name
    // 3)  copy the remainder of the string after OldComName
    //
    offset = (INT)(oldLocation - oldTitle);
    CopyMemory(newTitle, oldTitle, offset * sizeof(TCHAR));                 // 1
    CopyMemory(newTitle + offset, NewComName, newNameLen * sizeof(TCHAR));  // 2
    lstrcpy(newTitle + offset + newNameLen, oldLocation + oldNameLen);      // 3

    SetWindowText(Hwnd, newTitle);

exit:
    if (oldTitle) {
        LocalFree(oldTitle);
    }
    if (newTitle) {
        LocalFree(newTitle);
    }
}

void
MigratePortSettings(
    LPCTSTR OldComName,
    LPCTSTR NewComName
    )
{
    TCHAR settings[BUFFER_SIZE];
    TCHAR szNew[20], szOld[20];

    lstrcpy(szOld, OldComName);
    wcscat(szOld, m_szColon);

    lstrcpy(szNew, NewComName);
    wcscat(szNew, m_szColon);

    settings[0] = TEXT('\0');
    GetProfileString(m_szPorts,
                     szOld,
                     TEXT(""),
                     settings,
                     sizeof(settings) / sizeof(TCHAR) );

    //
    // Insert the new key based on the old one
    //
    if (settings[0] == TEXT('\0')) {
        WriteProfileString(m_szPorts, szNew, m_szDefParams);
    }
    else {
        WriteProfileString(m_szPorts, szNew, settings);
    }

    //
    // Notify everybody of the changes and blow away the old key
    //
    SendWinIniChange((LPTSTR)m_szPorts);
    WriteProfileString(m_szPorts, szOld, NULL);
}

void
EnactComNameChanges(
    IN HWND             ParentHwnd,
    IN PADVANCED_DATA   AdvancedData,
    IN HKEY             hDeviceKey,
    IN UINT             NewComNum)
{
    DWORD  dwNewComNameLen;
    TCHAR  buffer[BUFFER_SIZE];
    TCHAR  szFriendlyNameFormat[LINE_LEN];
    TCHAR  szDeviceDesc[LINE_LEN];
    PTCHAR szNewComName;
    UINT   i;
    UINT   curComNum;
    BOOLEAN updateMapping = TRUE;

    SP_DEVINSTALL_PARAMS spDevInstall;

    curComNum = myatoi(AdvancedData->szComName + wcslen(m_szCOM));

    if (AdvancedData->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
        BYTE   portUsage[MAX_COM_PORT/8];
        DWORD  portsReported;
        char   mask;

        //
        // Check to see if the desired new COM number has been claimed in the
        // com name database.  If so, ask the user if they are *really* sure
        //
        ComDBGetCurrentPortUsage(AdvancedData->hComDB,
                                 portUsage,
                                 MAX_COM_PORT / 8,
                                 CDB_REPORT_BITS,
                                 &portsReported);

        if ((i = NewComNum % 8))
            mask = 1 << (i-1);
        else
            mask = (char) 0x80;
        if ((portUsage[(NewComNum-1)/8] & mask) &&
            MyMessageBox(ParentHwnd, IDS_PORT_IN_USE, IDS_NAME_PROPERTIES,
                         MB_YESNO | MB_ICONINFORMATION) == IDNO) {
            //
            // Port has been previously claimed and user doesn't want to override
            //
            return;
        }
    }

    if (!QueryDosDevice(AdvancedData->szComName, buffer, BUFFER_SIZE-1)) {
        //
        // The old com name does not exist in the mapping.  Basically, the symbolic
        // link from COMX => \Device\SerialY has been broken.  Just change the
        // value in the registry and the friendly name for the device; don't
        // change the dos symbolic name b/c one does not exist
        //
        updateMapping = FALSE;
    }
    else {
        TCHAR  szComFileName[20]; // more than enough for "\\.\COMXxxx"
        HANDLE hCom;

        lstrcpy(szComFileName, L"\\\\.\\");
        lstrcat(szComFileName, AdvancedData->szComName);

        //
        // Make sure that the port has not been opened by another application
        //
        hCom = CreateFile(szComFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, NULL);

        //
        // If the file handle is invalid, then the com port is open, warn the user
        //
        if (hCom == INVALID_HANDLE_VALUE &&
            MyMessageBox(ParentHwnd, IDS_PORT_OPEN, IDS_NAME_PROPERTIES,
                         MB_YESNO | MB_ICONERROR) == IDNO) {
            return;
        }

        if (hCom != INVALID_HANDLE_VALUE) {
            CloseHandle(hCom);
        }
    }

    szNewComName = AdvancedData->szNewComName;
    wsprintf(szNewComName, _T("COM%d"), NewComNum);
    dwNewComNameLen = ByteCountOf(wcslen(szNewComName) + 1);

    //
    // Change the name in the symbolic namespace.
    // First try to get what device the old com name mapped to
    // (ie something like \Device\Serial0).  Then remove the mapping.  If
    // the user isn't an admin, then this will fail and the dialog will popup.
    // Finally, map the new name to the old device retrieved from the
    // QueryDosDevice
    //
    if (updateMapping) {
        BOOL removed;
        HKEY hSerialMap;

        if (!QueryDosDevice(AdvancedData->szComName, buffer, BUFFER_SIZE-1)) {
            //
            // This shouldn't happen because the previous QueryDosDevice call
            // succeeded
            //
            MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_NAME_PROPERTIES,
                         MB_ICONERROR);
            return;
        }

        //
        // If this fails, then the following define will just replace the current
        // mapping.
        //
        removed = DefineDosDevice(DDD_REMOVE_DEFINITION, AdvancedData->szComName, NULL);

        if (!DefineDosDevice(DDD_RAW_TARGET_PATH, szNewComName, buffer)) {
            //
            // error, first fix up the remove definition and restore the old
            // mapping
            //
            if (removed) {
                DefineDosDevice(DDD_RAW_TARGET_PATH, AdvancedData->szComName, buffer);
            }

            MyMessageBox(ParentHwnd, IDS_PORT_RENAME_ERROR, IDS_NAME_PROPERTIES,
                         MB_ICONERROR);

            return;
        }

        //
        // Set the \\HARDWARE\DEVICEMAP\SERIALCOMM field
        //
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         m_szRegSerialMap,
                         0,
                         KEY_ALL_ACCESS,
                         &hSerialMap) == ERROR_SUCCESS) {

            TCHAR  szSerial[BUFFER_SIZE];
            DWORD  dwSerialSize, dwEnum, dwType, dwComSize;
            TCHAR  szCom[BUFFER_SIZE];

            i = 0;
            do {
                dwSerialSize = CharSizeOf(szSerial);
                dwComSize = sizeof(szCom);
                dwEnum = RegEnumValue(hSerialMap,
                                      i++,
                                      szSerial,
                                      &dwSerialSize,
                                      NULL,
                                      &dwType,
                                      (LPBYTE)szCom,
                                      &dwComSize);

                if (dwEnum == ERROR_SUCCESS) {
                    if(dwType != REG_SZ)
                        continue;

                    if (wcscmp(szCom, AdvancedData->szComName) == 0) {
                        RegSetValueEx(hSerialMap,
                                        szSerial,
                                        0,
                                        REG_SZ,
                                        (PBYTE) szNewComName,
                                        dwNewComNameLen);
                                        break;
                    }
                }
                
            } while (dwEnum == ERROR_SUCCESS);
        }

        RegCloseKey(hSerialMap);
    }

    //
    // Update the com db
    //
    if (AdvancedData->hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
        ComDBReleasePort(AdvancedData->hComDB, (DWORD) curComNum);

        ComDBClaimPort(AdvancedData->hComDB, (DWORD) NewComNum, TRUE, NULL);
    }

    //
    // Set the friendly name in the form of DeviceDesc (COM#)
    //
    if (LoadString(g_hInst,
                   IDS_FRIENDLY_FORMAT,
                   szFriendlyNameFormat,
                   CharSizeOf(szFriendlyNameFormat)) &&
        SetupDiGetDeviceRegistryProperty(AdvancedData->DeviceInfoSet,
                                         AdvancedData->DeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         NULL,
                                         (PBYTE) szDeviceDesc,
                                         sizeof(szDeviceDesc),
                                         NULL)) {
        wsprintf(buffer, szFriendlyNameFormat, szDeviceDesc, szNewComName);
    }
    else {
        //
        // Use the COM port name straight out
        //
        lstrcpy(buffer, szNewComName);
    }

    SetupDiSetDeviceRegistryProperty(AdvancedData->DeviceInfoSet,
                                     AdvancedData->DeviceInfoData,
                                     SPDRP_FRIENDLYNAME,
                                     (PBYTE) buffer,
                                     ByteCountOf(wcslen(buffer)+1));

    //
    // Set the parent dialog's title to reflect the change in the com port's name
    //
    ChangeParentTitle(GetParent(ParentHwnd), AdvancedData->szComName, szNewComName);
    MigratePortSettings(AdvancedData->szComName, szNewComName);

    //
    // Update the PortName value in the devnode
    //
    RegSetValueEx(hDeviceKey,
                  m_szPortName,
                  0,
                  REG_SZ,
                  (PBYTE)szNewComName,
                  dwNewComNameLen);

    //
    // Now broadcast this change to the device manager
    //
    ZeroMemory(&spDevInstall, sizeof(SP_DEVINSTALL_PARAMS));
    spDevInstall.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if (SetupDiGetDeviceInstallParams(AdvancedData->DeviceInfoSet,
                                      AdvancedData->DeviceInfoData,
                                      &spDevInstall)) {
        spDevInstall.Flags |= DI_PROPERTIES_CHANGE;
        SetupDiSetDeviceInstallParams(AdvancedData->DeviceInfoSet,
                                      AdvancedData->DeviceInfoData,
                                      &spDevInstall);
    }
}

/*++

Routine Description: SaveAdvancedSettings

    saves the advanced box settings back to the registry, if any were
    changed

Arguments:

    AdvancedData: holds the current settings and the location of of
                   the device in the registry
    ParentHwnd:          address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
SaveAdvancedSettings(
    IN HWND ParentHwnd,
    IN PADVANCED_DATA AdvancedData
    )
{
   HKEY   hDeviceKey;
   DWORD  dwSize, dwData;

   UINT  i = CB_ERR, curComNum, newComNum = CB_ERR;
   UINT  uiDlgButtonChecked;
   DWORD dwRxPosition, dwTxPosition, dwPollingPeriod;

   SP_DEVINSTALL_PARAMS spDevInstall;

   //
   // Grab all of the new settings
   //

   uiDlgButtonChecked = IsDlgButtonChecked(ParentHwnd, IDC_FIFO);

   dwTxPosition = Trackbar_GetPos(GetDlgItem(ParentHwnd, IDC_TRANSMIT_SLIDER));
   dwRxPosition = Trackbar_GetPos(GetDlgItem(ParentHwnd, IDC_RECEIVE_SLIDER));

   //
   // Index is actually into the array of values
   //
   dwRxPosition = RxValues[dwRxPosition-1];

   curComNum = myatoi(AdvancedData->szComName + wcslen(m_szCOM));
   newComNum = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, PP_PORT_NUMBER));

   if (newComNum == CB_ERR) {
       newComNum = curComNum;
   }
   else {
       newComNum++;
   }

   i = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, IDC_POLL_PERIOD));

   if (i == CB_ERR || i >= NUM_POLLING_PERIODS) {
       dwPollingPeriod = AdvancedData->PollingPeriod;
   }
   else {
       dwPollingPeriod = PollingPeriods[i];
   }

   //
   // See if they changed anything
   //
   if (((AdvancedData->UseFifoBuffers  && uiDlgButtonChecked == BST_CHECKED) ||
        (!AdvancedData->UseFifoBuffers && uiDlgButtonChecked == BST_UNCHECKED)) &&
       AdvancedData->RxFIFO == dwRxPosition &&
       AdvancedData->TxFIFO == dwTxPosition &&
       AdvancedData->PollingPeriod == dwPollingPeriod &&
       newComNum == curComNum) {
      //
      // They didn't change anything. Just exit.
      //
      return ERROR_SUCCESS;
   }

   //
   // Open the device key for the source device instance
   //
   hDeviceKey = SetupDiOpenDevRegKey(AdvancedData->DeviceInfoSet,
                                     AdvancedData->DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DEV,
                                     KEY_ALL_ACCESS);

   if (INVALID_HANDLE_VALUE == hDeviceKey) {
      //
      // Not much we can do without a valid key, exit gracefully
      //
      return ERROR_SUCCESS;
   }

   //
   // Check to see if the user changed the COM port name
   //
   if (newComNum != curComNum) {
      EnactComNameChanges(ParentHwnd,
                          AdvancedData,
                          hDeviceKey,
                          newComNum);
   }


   if ((AdvancedData->UseFifoBuffers  && uiDlgButtonChecked == BST_UNCHECKED) ||
       (!AdvancedData->UseFifoBuffers && uiDlgButtonChecked == BST_CHECKED)) {
      //
      // They changed the Use Fifo checkbox.
      //
      dwData = (uiDlgButtonChecked == BST_CHECKED) ? 1 : 0;
      dwSize = sizeof(dwData);
      RegSetValueEx(hDeviceKey,
                    m_szFIFO,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)(&dwData),
                    dwSize);
   }

   if (AdvancedData->RxFIFO != dwRxPosition) {
      //
      // They changed the RxFIFO setting
      //
      dwData = dwRxPosition;
      dwSize = sizeof(dwData);
      RegSetValueEx(hDeviceKey,
                    m_szRxFIFO,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)(&dwData),
                    dwSize);
   }

   if (AdvancedData->TxFIFO != dwTxPosition) {
      //
      // They changed the TxFIFO setting
      //
      dwData = dwTxPosition;
      dwSize = sizeof(dwData);
      RegSetValueEx(hDeviceKey,
                    m_szTxFIFO,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)(&dwData),
                    dwSize);
   }

   if (AdvancedData->PollingPeriod != dwPollingPeriod) {
      //
      // They changed the polling period
      //
      dwData = dwPollingPeriod;
      dwSize = sizeof(dwData);
      RegSetValueEx(hDeviceKey,
                    m_szPollingPeriod,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)(&dwData),
                    dwSize);

      //
      // Don't really care if this fails, nothing else we can do
      //
      CM_Reenumerate_DevNode(AdvancedData->DeviceInfoData->DevInst,
                             CM_REENUMERATE_NORMAL);
   }

   RegCloseKey(hDeviceKey);

   SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                             AdvancedData->DeviceInfoSet,
                             AdvancedData->DeviceInfoData);

   return ERROR_SUCCESS;
} /* SaveAdvancedSettings*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\pp.c ===
/*----------------------------------------------------------------------
 file: pp.c - property page

@@BEGIN_DDKSPLIT

ToDo_NT50
{
   * Bug?: DIF_MOVEDEVICE in class installer opens reg key as READ access
    to perform a write.(ports.c)
}

 * History:
    7-29-97  - Add this module for NT5.0, kpb

@@END_DDKSPLIT
----------------------------------------------------------------------*/
#include "ports.h"
#include "pp.h"

// @@BEGIN_DDKSPLIT
BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree(Groups);
    }

    CloseHandle(Token);

    return(b);
}
// @@END_DDKSPLIT

TCHAR m_szDevMgrHelp[] = _T("devmgr.hlp");

const DWORD HelpIDs[]=
{
    IDC_STATIC,         IDH_NOHELP,
    IDC_ADVANCED,       IDH_DEVMGR_PORTSET_ADVANCED, // "&Advanced" (Button)
    PP_PORT_BAUDRATE,   IDH_DEVMGR_PORTSET_BPS,      // "" (ComboBox)
    PP_PORT_DATABITS,   IDH_DEVMGR_PORTSET_DATABITS, // "" (ComboBox)
    PP_PORT_PARITY,     IDH_DEVMGR_PORTSET_PARITY,   // "" (ComboBox)
    PP_PORT_STOPBITS,   IDH_DEVMGR_PORTSET_STOPBITS, // "" (ComboBox)
    PP_PORT_FLOWCTL,    IDH_DEVMGR_PORTSET_FLOW,     // "" (ComboBox)
    IDC_RESTORE_PORT,   IDH_DEVMGR_PORTSET_DEFAULTS, // "&Restore Defaults" (Button)
    0, 0
};

void InitPortParams(
    IN OUT PPORT_PARAMS      Params,
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData
    )
{
    BOOL                        showAdvanced = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA detailData;

    ZeroMemory(Params, sizeof(PORT_PARAMS));

    Params->DeviceInfoSet = DeviceInfoSet;
    Params->DeviceInfoData = DeviceInfoData;
    Params->ChangesEnabled = TRUE;

    //
    // Now we know how big our structure is, so we can allocate memory
    //
    Params->pAdvancedData =
        (PADVANCED_DATA) LocalAlloc(LPTR, sizeof(ADVANCED_DATA));

    if (Params->pAdvancedData == NULL) {
        //
        // Not enough memory
        //
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        showAdvanced = FALSE;
    }
    else
    {
        Params->pAdvancedData->HidePolling = FALSE;
    }
    //
    // See if we are being invoked locally or over the network.  If over the net,
    // then disable all possible changes.
    //
    detailData.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &detailData) &&
        detailData.RemoteMachineHandle != NULL) {
        showAdvanced = FALSE;
        Params->ChangesEnabled = FALSE;
    }

    // @@BEGIN_DDKSPLIT
    //
    // The user can still change the buadrate etc b/c it is written to some
    // magic place in the registry, not into the devnode
    //
    if (!IsUserAdmin()) {
        showAdvanced = FALSE;
    }
    // @@END_DDKSPLIT

    if (Params->pAdvancedData)
    {
        Params->pAdvancedData->DeviceInfoSet  = DeviceInfoSet;
        Params->pAdvancedData->DeviceInfoData = DeviceInfoData;
    }
    
    Params->ShowAdvanced = showAdvanced;
}

HPROPSHEETPAGE InitSettingsPage(PROPSHEETPAGE *     psp,
                                OUT PPORT_PARAMS    Params)
{
    //
    // Add the Port Settings property page
    //
    psp->dwSize      = sizeof(PROPSHEETPAGE);
    psp->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp->hInstance   = g_hInst;
    psp->pszTemplate = MAKEINTRESOURCE(DLG_PP_PORTSETTINGS);

    //
    // following points to the dlg window proc
    //
    psp->pfnDlgProc = PortSettingsDlgProc;
    psp->lParam     = (LPARAM) Params;

    //
    // following points to some control callback of the dlg window proc
    //
    psp->pfnCallback = PortSettingsDlgCallback;

    //
    // allocate our "Ports Setting" sheet
    //
    return CreatePropertySheetPage(psp);
}

/*++

Routine Description: SerialPortPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="msports.dll,thisproc"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL APIENTRY SerialPortPropPageProvider(LPVOID               Info,
                                         LPFNADDPROPSHEETPAGE AddFunc,
                                         LPARAM               Lparam
                                         )
{
   PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
   PROPSHEETPAGE             psp;
   HPROPSHEETPAGE            hpsp;
   PPORT_PARAMS              params = NULL;

   pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

   if (PortTypeSerial != 
       GetPortType(pprPropPageRequest->DeviceInfoSet,
                   pprPropPageRequest->DeviceInfoData,
                   FALSE)) {
       return FALSE;
   }

   //
   // Allocate and zero out memory for the struct that will contain
   // page specific data
   //
   params = (PPORT_PARAMS) LocalAlloc(LPTR, sizeof(PORT_PARAMS));

   if (!params) {
       ErrMemDlg(GetFocus());
       return FALSE;
   }

   if (pprPropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {
        InitPortParams(params,
                       pprPropPageRequest->DeviceInfoSet,
                       pprPropPageRequest->DeviceInfoData);

        hpsp = InitSettingsPage(&psp, params);

        if (!hpsp) {
            return FALSE;
        }

        if (!(*AddFunc)(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
} /* SerialPortPropPageProvider */


UINT CALLBACK
PortSettingsDlgCallback(HWND hwnd,
                        UINT uMsg,
                        LPPROPSHEETPAGE ppsp)
{
    PPORT_PARAMS params;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        params = (PPORT_PARAMS) ppsp->lParam;
        if (params->pAdvancedData) {
            LocalFree(params->pAdvancedData);
        }
        LocalFree(params);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );

BOOL
Port_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

void
Port_OnHelp(
    HWND       DialogHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    );

/*++

Routine Description: PortSettingsDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR APIENTRY
PortSettingsDlgProc(IN HWND   hDlg,
                    IN UINT   uMessage,
                    IN WPARAM wParam,
                    IN LPARAM lParam)
{
    switch(uMessage) {
    case WM_COMMAND:
        Port_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CONTEXTMENU:
        return Port_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        Port_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_INITDIALOG:
        return Port_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return Port_OnNotify(hDlg,  (NMHDR *)lParam);
    }

    return FALSE;
} /* PortSettingsDialogProc */

void
Port_OnAdvancedClicked(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    )
{
    //
    // Initialize the new COM name with the current COM name
    //
    lstrcpy(Params->pAdvancedData->szNewComName,
            Params->PortSettings.szComName);

    if (DisplayAdvancedDialog(DialogHwnd, Params->pAdvancedData)) {
        //
        // Only update if there is a change
        //
        if (_tcscmp(Params->pAdvancedData->szNewComName,
                    Params->PortSettings.szComName) != 0) {
            lstrcpy(Params->PortSettings.szComName,
                    Params->pAdvancedData->szNewComName);
        }
    }
}

void
Port_OnRestorePortClicked(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    )
{
    RestorePortSettings(DialogHwnd, Params);
    PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
    }
    else {
        switch (ControlId) {
        case IDC_ADVANCED:
            Port_OnAdvancedClicked(DialogHwnd, params);
            break;

        case IDC_RESTORE_PORT:
            Port_OnRestorePortClicked(DialogHwnd, params);
            break;

        //
        // Because this is a prop sheet, we should never get this.
        // All notifications for ctrols outside of the sheet come through
        // WM_NOTIFY
        //
        case IDCANCEL:
            EndDialog(DialogHwnd, 0);
            return;
        }
    }
}

BOOL
Port_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            m_szDevMgrHelp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) HelpIDs);

    return FALSE;
}

void
Port_OnHelp(
    HWND       DialogHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                m_szDevMgrHelp,
                HELP_WM_HELP,
                (ULONG_PTR) HelpIDs);
    }
}

BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PPORT_PARAMS params;

    //
    // on WM_INITDIALOG call, lParam points to the property
    // sheet page.
    //
    // The lParam field in the property sheet page struct is set by the
    // caller. When I created the property sheet, I passed in a pointer
    // to a struct containing information about the device. Save this in
    // the user window long so I can access it on later messages.
    //
    params = (PPORT_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(DialogHwnd, DWLP_USER, (ULONG_PTR) params);

    //
    // Set up the combo boxes with choices
    //
    FillCommDlg(DialogHwnd);

    //
    // Read current settings
    //
    FillPortSettingsDlg(DialogHwnd, params);

    EnableWindow(GetDlgItem(DialogHwnd, IDC_ADVANCED),
                 params->ShowAdvanced);
    EnableWindow(GetDlgItem(DialogHwnd, IDC_RESTORE_PORT),
                 params->ChangesEnabled);

    return TRUE;  // No need for us to set the focus.
}

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    switch (NmHdr->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Write out the com port options to the registry
        //
        SavePortSettingsDlg(DialogHwnd, params);
        SetWindowLongPtr(DialogHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

    default:
        return FALSE;
    }
}

VOID
SetCBFromRes(
    HWND   HwndCB,
    DWORD  ResId,
    DWORD  Default,
    BOOL   CheckDecimal)
{
    TCHAR   szTemp[258], szDecSep[2], cSep;
    LPTSTR  pThis, pThat, pDecSep;
    int     iRV;

    if (CheckDecimal) {
        iRV = GetLocaleInfo(GetUserDefaultLCID(), LOCALE_SDECIMAL,szDecSep,2);

        if (iRV == 0) {
            //
            // following code can take only one char for decimal separator,
            // better leave the point as separator
            //
            CheckDecimal = FALSE;
        }
    }

    if (!LoadString(g_hInst, ResId, szTemp, CharSizeOf(szTemp)))
        return;

    for (pThis = szTemp, cSep = *pThis++; pThis; pThis = pThat) {
        if (pThat = _tcschr( pThis, cSep))
            *pThat++ = TEXT('\0');

        if(CheckDecimal) {
            //
            // Assume dec separator in resource is '.', comment was put to this
            // effect
            //
            pDecSep = _tcschr(pThis,TEXT('.'));
            if (pDecSep) {
                //
                // assume decimal sep width == 1
                //
                *pDecSep = *szDecSep;
            }
        }
        SendMessage(HwndCB, CB_ADDSTRING, 0, (LPARAM) pThis);
    }

    SendMessage(HwndCB, CB_SETCURSEL, Default, 0L);
}

/*++

Routine Description: FillCommDlg

    Fill in baud rate, parity, etc in port dialog box

Arguments:

    hDlg: the window address

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
BOOL
FillCommDlg(
    HWND DialogHwnd
    )
{
    SHORT shIndex;
    TCHAR szTemp[81];

    //
    //  just list all of the baud rates
    //
    for(shIndex = 0; m_nBaudRates[shIndex]; shIndex++) {
        MyItoa(m_nBaudRates[shIndex], szTemp, 10);

        SendDlgItemMessage(DialogHwnd,
                           PP_PORT_BAUDRATE,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)szTemp);
    }

    //
    //  Set 9600 as default baud selection
    //
    shIndex = (USHORT) SendDlgItemMessage(DialogHwnd,
                                          PP_PORT_BAUDRATE,
                                          CB_FINDSTRING,
                                          (WPARAM)-1,
                                          (LPARAM)m_sz9600);

    shIndex = (shIndex == CB_ERR) ? 0 : shIndex;

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_BAUDRATE,
                       CB_SETCURSEL,
                       shIndex,
                       0L);

    for(shIndex = 0; m_nDataBits[shIndex]; shIndex++) {
        MyItoa(m_nDataBits[shIndex], szTemp, 10);

        SendDlgItemMessage(DialogHwnd,
                           PP_PORT_DATABITS,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)szTemp);
    }

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_DATABITS,
                       CB_SETCURSEL,
                       DEF_WORD,
                       0L);

    SetCBFromRes(GetDlgItem(DialogHwnd, PP_PORT_PARITY),
                 IDS_PARITY,
                 DEF_PARITY,
                 FALSE);

    SetCBFromRes(GetDlgItem(DialogHwnd, PP_PORT_STOPBITS),
                 IDS_BITS,
                 DEF_STOP,
                 TRUE);

    SetCBFromRes(GetDlgItem(DialogHwnd, PP_PORT_FLOWCTL),
                 IDS_FLOWCONTROL,
                 DEF_SHAKE,
                 FALSE);

    return 0;

} /* FillCommDlg */

/*++

Routine Description: FillPortSettingsDlg

    fill in the port settings dlg sheet

Arguments:

    params: the data to fill in
    hDlg:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
FillPortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    HKEY  hDeviceKey;
    DWORD dwPortNameSize, dwError;
    TCHAR szCharBuffer[81];

    //
    // Open the device key for the source device instance, and retrieve its
    // "PortName" value.
    //
    hDeviceKey = SetupDiOpenDevRegKey(Params->DeviceInfoSet,
                                      Params->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_READ);

    if (INVALID_HANDLE_VALUE == hDeviceKey) {
        goto RetGetLastError;
    }

    dwPortNameSize = sizeof(Params->PortSettings.szComName);
    dwError = RegQueryValueEx(hDeviceKey,
                              m_szPortName,  // "PortName"
                              NULL,
                              NULL,
                              (PBYTE)Params->PortSettings.szComName,
                              &dwPortNameSize);

    RegCloseKey(hDeviceKey);

    if(ERROR_SUCCESS != dwError) {
        goto RetERROR;
    }

    //
    // create "com#:"
    //
    lstrcpy(szCharBuffer, Params->PortSettings.szComName);
    lstrcat(szCharBuffer, m_szColon);

    //
    // get values from system, fills in baudrate, parity, etc.
    //
    GetPortSettings(DialogHwnd, szCharBuffer, Params);

    if (!Params->ChangesEnabled) {
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_BAUDRATE), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_PARITY), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_DATABITS), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_STOPBITS), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_FLOWCTL), FALSE);
    }

    return 0;

RetERROR:
    return dwError;

RetGetLastError:
   return GetLastError();
} /* FillPortSettingsDlg */




/*++

Routine Description: GetPortSettings

    Read in port settings from the system

Arguments:

    DialogHwnd:      address of the window
    ComName: the port we're dealing with
    Params:      where to put the information we're getting

Return Value:

    ULONG: returns error messages

--*/
void
GetPortSettings(
    IN HWND             DialogHwnd,
    IN PTCHAR           ComName,
    IN PPORT_PARAMS     Params
    )
{
    TCHAR  szParms[81];
    PTCHAR szCur, szNext;
    int    nIndex;
    int    nBaud;

    //
    // read settings in from system
   //
    GetProfileString(m_szPorts,
                     ComName,
                     g_szNull,
                     szParms,
                     81);

    StripBlanks(szParms);
    if (lstrlen(szParms) == 0) {
        lstrcpy(szParms, m_szDefParams);
        WriteProfileString(m_szPorts, ComName, szParms);
    }

    szCur = szParms;

    //
    //  baud rate
    //
    szNext = strscan(szCur, m_szComma);
    if (*szNext) {
        //
        // If we found a comma, terminate
        //
        *szNext++ = 0;
    }

    //
    // current Baud Rate selection
    //
    if (*szCur) {
        Params->PortSettings.BaudRate = myatoi(szCur);
    }
    else {
        //
        // must not have been written, use default
        //
        Params->PortSettings.BaudRate = m_nBaudRates[DEF_BAUD];
    }

    //
    // set the current value in the dialog sheet
    //
    nIndex = (int)SendDlgItemMessage(DialogHwnd,
                                     PP_PORT_BAUDRATE,
                                     CB_FINDSTRING,
                                     (WPARAM)-1,
                                     (LPARAM)szCur);

    nIndex = (nIndex == CB_ERR) ? 0 : nIndex;

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_BAUDRATE,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    szCur = szNext;

    //
    //  parity
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
        *szNext++ = 0;
    }
    StripBlanks(szCur);

    switch(*szCur) {
    case TEXT('o'):
        nIndex = PAR_ODD;
        break;

    case TEXT('e'):
        nIndex = PAR_EVEN;
        break;

    case TEXT('n'):
        nIndex = PAR_NONE;
        break;

    case TEXT('m'):
        nIndex = PAR_MARK;
        break;

    case TEXT('s'):
        nIndex = PAR_SPACE;
        break;

    default:
        nIndex = DEF_PARITY;
        break;
    }

    Params->PortSettings.Parity = nIndex;
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_PARITY,
                        CB_SETCURSEL,
                       nIndex,
                       0L);
    szCur = szNext;

    //
    //  word length: 4 - 8
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
        *szNext++ = 0;
    }

    StripBlanks(szCur);
    nIndex = *szCur - TEXT('4');

    if (nIndex < 0 || nIndex > 4) {
        nIndex = DEF_WORD;
    }

    Params->PortSettings.DataBits = nIndex;
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_DATABITS,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    szCur = szNext;

    //
    //  stop bits
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
       *szNext++ = 0;
    }

    StripBlanks(szCur);

    if (!lstrcmp(szCur, TEXT("1"))) {
        nIndex = STOP_1;
    }
    else if(!lstrcmp(szCur, TEXT("1.5"))) {
        nIndex = STOP_15;
    }
    else if(!lstrcmp(szCur, TEXT("2"))) {
        nIndex = STOP_2;
    }
    else {
        nIndex = DEF_STOP;
    }

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_STOPBITS,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    Params->PortSettings.StopBits = nIndex;
    szCur = szNext;

    //
    //  handshaking: Hardware, xon/xoff, or none
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
        *szNext++ = 0;
    }

    StripBlanks(szCur);

    if (*szCur == TEXT('p')) {
        nIndex = FLOW_HARD;
    }
    else if (*szCur == TEXT('x')) {
        nIndex = FLOW_XON;
    }
    else {
        nIndex = FLOW_NONE;
    }

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_FLOWCTL,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    Params->PortSettings.FlowControl = nIndex;
} /* GetPortSettings */

void
RestorePortSettings(
    HWND            DialogHwnd,
    PPORT_PARAMS    Params
    )
{
    UINT nIndex;

    //
    //  baud rate
    //
    nIndex = (UINT)SendDlgItemMessage(DialogHwnd,
                                      PP_PORT_BAUDRATE,
                                      CB_FINDSTRING,
                                      (WPARAM)-1,
                                      (LPARAM)TEXT("9600"));

    nIndex = (nIndex == CB_ERR) ? 0 : nIndex;
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_BAUDRATE,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    //
    //  parity
    //
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_PARITY,
                       CB_SETCURSEL,
                       PAR_NONE,
                       0L);

    //
    //  word length: 4 - 8
    //
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_DATABITS,
                       CB_SETCURSEL,
                       4, // the 4th index is 8, what we want
                       0L);

    //
    //  stop bits
    //
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_STOPBITS,
                       CB_SETCURSEL,
                       STOP_1,
                       0L);

    //
    //  handshaking: Hardware, xon/xoff, or none
    //
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_FLOWCTL,
                       CB_SETCURSEL,
                       FLOW_NONE,
                       0L);

    //    nIndex = FLOW_HARD;
    //    nIndex = FLOW_XON;
    //    nIndex = FLOW_NONE;
}

/*++

Routine Description: SavePortSettingsDlg

    save changes in the Ports Settings dlg sheet

Arguments:

    Params: where to save the data to
    ParentHwnd:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
SavePortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    TCHAR szCharBuffer[81];
    DWORD dwPortnum, dwOldPortnum;
    DWORD dwPortNameSize, dwError;
    TCHAR szNewComName[21];
    TCHAR szSerialKey[41];
    TCHAR szTitle[81];
    TCHAR szTitleFormat[81];
    HKEY  hDeviceKey, hKey;

    //
    // create "com#:"
    //
    // lstrcpy(szCharBuffer, Params->pAdvancedData->szNewComName);
    lstrcpy(szCharBuffer, Params->PortSettings.szComName);
    lstrcat(szCharBuffer, m_szColon);

    //
    //  store changes to win.ini; broadcast changes to apps
    //
    SavePortSettings(DialogHwnd, szCharBuffer, Params);

    return 0;
} /* SavePortSettingsDlg */




/*++

Routine Description: SavePortSettings

    Read the dlg screen selections for baudrate, parity, etc.
    If changed from what we started with, then save them

Arguments:

    hDlg:      address of the window
    szComName: which comport we're dealing with
    Params:      contains, baudrate, parity, etc

Return Value:

    ULONG: returns error messages

--*/
void
SavePortSettings(
    IN HWND            DialogHwnd,
    IN PTCHAR          ComName,
    IN PPORT_PARAMS    Params
    )
{
    TCHAR           szBuild[PATHMAX];
    ULONG           i;
    PP_PORTSETTINGS pppNewPortSettings;

    //
    //  Get the baud rate
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_BAUDRATE,
                                  WM_GETTEXT,
                                  18,
                                  (LPARAM)szBuild);
    if (!i) {
       goto Return;
    }

    pppNewPortSettings.BaudRate = myatoi(szBuild);

    //
    //  Get the parity setting
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_PARITY,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.Parity = i;
    lstrcat(szBuild, m_pszParitySuf[i]);

    //
    //  Get the word length
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_DATABITS,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.DataBits = i;
    lstrcat(szBuild, m_pszLenSuf[i]);

    //
    //  Get the stop bits
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_STOPBITS,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.StopBits = i;
    lstrcat(szBuild, m_pszStopSuf[i]);

    //
    //  Get the flow control
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_FLOWCTL,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.FlowControl = i;
    lstrcat(szBuild, m_pszFlowSuf[i]);

    //
    // if any of the values changed, then save it off
    //
    if (Params->PortSettings.BaudRate    != pppNewPortSettings.BaudRate ||
        Params->PortSettings.Parity      != pppNewPortSettings.Parity   ||
        Params->PortSettings.DataBits    != pppNewPortSettings.DataBits ||
        Params->PortSettings.StopBits    != pppNewPortSettings.StopBits ||
        Params->PortSettings.FlowControl != pppNewPortSettings.FlowControl) {

        //
        // Write settings string to [ports] section in win.ini
        // NT translates this if a translate key is set in registry
        // and it winds up getting written to
        // HKLM\Software\Microsoft\Windows NT\CurrentVersion\Ports
        //
        WriteProfileString(m_szPorts, ComName, szBuild);

        //
        // Send global notification message to all windows
        //
        SendWinIniChange((LPTSTR)m_szPorts);

        if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                       Params->DeviceInfoSet,
                                       Params->DeviceInfoData)) {
            //
            // Possibly do something here
            //
        }
    }

Return:
   return;

} /* SavePortSettings */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\ports.c ===
/** FILE: ports.c ********** Module Header ********************************
 *
 *  Class installer for the Ports class.
 *
 @@BEGIN_DDKSPLIT
 * History:
 *  12:30 on Tues  23 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  16:30 on Fri   27 Mar 1992  -by-  Steve Cathcart   [stevecat]
 *        Changed to allow for unlimited number of NT COM ports
 *  18:00 on Tue   06 Apr 1993  -by-  Steve Cathcart   [stevecat]
 *        Updated to work seamlessly with NT serial driver
 *  19:00 on Wed   05 Jan 1994  -by-  Steve Cathcart   [stevecat]
 *        Allow setting COM1 - COM4 advanced parameters
 @@END_DDKSPLIT
 *
 *  Copyright (C) 1990-1999 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                                Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

// Application specific
#include "ports.h"
#include <msports.h>

// @@BEGIN_DDKSPLIT
#include <initguid.h>
//
// Instantiate GUID_NULL.
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
//
// Instantiate class installer GUIDs (interesting one is GUID_DEVCLASS_PORTS).
//
#include <devguid.h>
// @@END_DDKSPLIT

//==========================================================================
//                                Globals
//==========================================================================

HANDLE  g_hInst  = NULL;

TCHAR g_szClose[ 40 ];              //  "Close" string
TCHAR g_szErrMem[ 200 ];            //  Low memory message
TCHAR g_szPortsApplet[ 30 ];        //  "Ports Control Panel Applet" title
TCHAR g_szNull[]  = TEXT("");       //  Null string

TCHAR  m_szColon[]      = TEXT( ":" );
TCHAR  m_szComma[]      = TEXT( "," );
TCHAR  m_szCloseParen[] = TEXT( ")" );
TCHAR  m_szPorts[]      = TEXT( "Ports" );
TCHAR  m_szCOM[]        = TEXT( "COM" );
TCHAR  m_szSERIAL[]     = TEXT( "Serial" );
TCHAR  m_szLPT[]        = TEXT( "LPT" );

//
//  NT Registry keys to find COM port to Serial Device mapping
//
TCHAR m_szRegSerialMap[] = TEXT( "Hardware\\DeviceMap\\SerialComm" );
TCHAR m_szRegParallelMap[] = TEXT( "Hardware\\DeviceMap\\PARALLEL PORTS" );

//
//  Registry Serial Port Advanced I/O settings key and valuenames
//

TCHAR m_szRegServices[]  =
            TEXT( "System\\CurrentControlSet\\Services\\" );

TCHAR m_szRootEnumName[]         = REGSTR_KEY_ROOTENUM;
TCHAR m_szAcpiEnumName[]         = REGSTR_KEY_ACPIENUM;

TCHAR m_szFIFO[]                = TEXT( "ForceFifoEnable" );
TCHAR m_szDosDev[]              = TEXT( "DosDevices" );
TCHAR m_szPollingPeriod[]       = TEXT( "PollingPeriod" );
TCHAR m_szPortName[]            = REGSTR_VAL_PORTNAME;
TCHAR m_szDosDeviceName[]       = TEXT( "DosDeviceName" );
TCHAR m_szFirmwareIdentified[]  = TEXT( "FirmwareIdentified" );
TCHAR m_szPortSubClass[]         = REGSTR_VAL_PORTSUBCLASS;

int m_nBaudRates[] = { 75, 110, 134, 150, 300, 600, 1200, 1800, 2400,
                       4800, 7200, 9600, 14400, 19200, 38400, 57600,
                       115200, 128000, 0 };

TCHAR m_sz9600[] = TEXT( "9600" );

TCHAR m_szDefParams[] = TEXT( "9600,n,8,1" );

short m_nDataBits[] = { 4, 5, 6, 7, 8, 0};

TCHAR *m_pszParitySuf[] = { TEXT( ",e" ),
                            TEXT( ",o" ),
                            TEXT( ",n" ),
                            TEXT( ",m" ),
                            TEXT( ",s" ) };

TCHAR *m_pszLenSuf[] = { TEXT( ",4" ),
                         TEXT( ",5" ),
                         TEXT( ",6" ),
                         TEXT( ",7" ),
                         TEXT( ",8" ) };

TCHAR *m_pszStopSuf[] = { TEXT( ",1" ),
                          TEXT( ",1.5" ),
                          TEXT( ",2 " ) };

TCHAR *m_pszFlowSuf[] = { TEXT( ",x" ),
                          TEXT( ",p" ),
                          TEXT( " " ) };

// @@BEGIN_DDKSPLIT
//
// Include the string-ified form of the Computer (i.e., HAL) class GUID here,
// so we don't have to pull in OLE or RPC just to get StringFromGuid.
//
TCHAR m_szComputerClassGuidString[] = TEXT( "{4D36E966-E325-11CE-BFC1-08002BE10318}" );

//
// String to append onto install section for COM ports in order to generate
// "PosDup" section.
//
TCHAR m_szPosDupSectionSuffix[] = (TEXT(".") INFSTR_SUBKEY_POSSIBLEDUPS);

//
// see GetDetectedSerialPortsList
//
TCHAR *m_pszSerialPnPIds[] = { TEXT( "*PNP0501" ) };

#define SERIAL_PNP_IDS_COUNT (sizeof(m_pszSerialPnPIds) / sizeof(m_pszSerialPnPIds[0]))
#define PARALLEL_MAX_NUMBER 3
// @@END_DDKSPLIT

#define IN_RANGE(value, minval, maxval) ((minval) <= (value) && (value) <= (maxval))


//==========================================================================
//                            Local Function Prototypes
//==========================================================================

DWORD
InstallPnPSerialPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

// @@BEGIN_DDKSPLIT
DWORD
GetDetectedSerialPortsList(
    IN HDEVINFO DeviceInfoSet,
    IN BOOL     FirstTimeSetup
    );

DWORD
RegisterDetectedSerialPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
GetPosDupList(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,
    OUT PTSTR            **PosDupList,
    OUT INT               *PosDupCount
    );
// @@END_DDKSPLIT

DWORD
InstallPnPParallelPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

DWORD
InstallSerialOrParallelPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

// @@BEGIN_DDKSPLIT
BOOL
GetSerialPortDevInstConfig(
    IN  DEVINST            DevInst,
    IN  ULONG              LogConfigType,
    OUT PIO_RESOURCE       IoResource,             OPTIONAL
    OUT PIRQ_RESOURCE      IrqResource             OPTIONAL
    );
BOOL
ChangeServiceStartType(
    IN PCTSTR ServiceName
    );
// @@END_DDKSPLIT



//==========================================================================
//                                Dll Entry Point
//==========================================================================
BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hDll;
        DisableThreadLibraryCalls(hDll);
        InitStrings();

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return TRUE;
}


//==========================================================================
//                                Functions
//==========================================================================

DWORD
WINAPI
PortsClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
)
/*++

Routine Description:

    This routine acts as the class installer for Ports devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    SP_MOVEDEV_PARAMS   MoveDevParams;
    SP_INSTALLWIZARD_DATA   iwd;
    HKEY                hDeviceKey;
    HCOMDB              hComDB;
    DWORD               PortNameSize,
                        Err,
                        size;
    TCHAR               PortName[20];
    BOOL                result;

    switch(InstallFunction) {

        case DIF_INSTALLDEVICE :

            return InstallSerialOrParallelPort(DeviceInfoSet, DeviceInfoData);

        case DIF_MOVEDEVICE :
            //
            // In addition to doing the default action of calling
            // SetupDiMoveDuplicateDevice, we need to retrieve the COM port
            // number of the old device, and set it to be the COM port number
            // of the new device (if the move is successful).  In Win95, setupx
            // had a hack inside of DiMoveDuplicateDevNode to do that, but it's
            // really the class installer's job to do class-specific stuff like
            // this.
            //
            MoveDevParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            if(!SetupDiGetClassInstallParams(DeviceInfoSet,
                                             DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&MoveDevParams,
                                             sizeof(MoveDevParams),
                                             NULL)) {
                return GetLastError();
            }

            //
            // Open the device key for the source device instance, and retrieve its
            // "PortName" value.
            //
            if((hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                  &MoveDevParams.SourceDeviceInfoData,
                                                  DICS_FLAG_GLOBAL,
                                                  0,
                                                  DIREG_DEV,
                                                  KEY_READ)) == INVALID_HANDLE_VALUE) {
                return GetLastError();
            }

            PortNameSize = sizeof(PortName);
            Err = RegQueryValueEx(hDeviceKey,
                                  m_szPortName,
                                  NULL,
                                  NULL,
                                  (PBYTE)PortName,
                                  &PortNameSize
                                 );

            RegCloseKey(hDeviceKey);

            if(Err != ERROR_SUCCESS) {
                return Err;
            }

            //
            // Now call the default routine for moving devices.
            //
            if(!SetupDiMoveDuplicateDevice(DeviceInfoSet, DeviceInfoData)) {
                return GetLastError();
            }

            //
            // The device was successfully moved.  Now open the destination device's key,
            // and store the COM port name there.  (Ignore failure here.)
            //
            if((hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                  &MoveDevParams.SourceDeviceInfoData,
                                                  DICS_FLAG_GLOBAL,
                                                  0,
                                                  DIREG_DEV,
                                                  KEY_READ)) != INVALID_HANDLE_VALUE) {

                RegSetValueEx(hDeviceKey,
                              m_szPortName,
                              0,
                              REG_SZ,
                              (PBYTE)PortName,
                              ByteCountOf(lstrlen(PortName) + 1)
                             );

                RegCloseKey(hDeviceKey);
            }

            return NO_ERROR;

        case DIF_REMOVE:

            if (PortTypeSerial == GetPortType(DeviceInfoSet, DeviceInfoData, FALSE)) {
                if (ComDBOpen(&hComDB) == ERROR_SUCCESS) {

                    hDeviceKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                      DeviceInfoData,
                                                      DICS_FLAG_GLOBAL,
                                                      0,
                                                      DIREG_DEV,
                                                      KEY_READ);

                    if (hDeviceKey !=   INVALID_HANDLE_VALUE) {
                        PortNameSize = sizeof(PortName);
                        Err = RegQueryValueEx(hDeviceKey,
                                              m_szPortName,
                                              NULL,
                                              NULL,
                                              (PBYTE)PortName,
                                              &PortNameSize
                                             );
                        RegCloseKey(hDeviceKey);

                        if (Err == ERROR_SUCCESS) {
                            ComDBReleasePort(hComDB,
                                             myatoi(PortName+wcslen(m_szCOM)));
                        }
                    }

                    ComDBClose(hComDB);
                }
            }

            if (!SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData)) {
                return GetLastError();
            }

            return NO_ERROR;

        // @@BEGIN_DDKSPLIT
        case DIF_FIRSTTIMESETUP:
            //
            // Change Start type for serial.sys on legacy free machines.
            //
            ChangeServiceStartType(TEXT("serial"));
            ChangeServiceStartType(TEXT("parport"));
            //
            // FALL THROUGH...
            //
        case DIF_DETECT:

            return GetDetectedSerialPortsList(DeviceInfoSet,
                                              (InstallFunction == DIF_FIRSTTIMESETUP)
                                             );

        case DIF_REGISTERDEVICE:

            return RegisterDetectedSerialPort(DeviceInfoSet,
                                              DeviceInfoData
                                             );
        // @@END_DDKSPLIT

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

// @@BEGIN_DDKSPLIT
BOOL
ChangeServiceStartType(
    IN PCTSTR ServiceName
    )
/*++

Routine Description:

    This routine changes the start type of the passed in Service to
    SERVICE_DEMAND_START if the system is legacy free.

Arguments:

    ServiceName - Service whose start type will be changed.

Return Value:

    TRUE is the service type was changed, else FALSE.

--*/
{
    HKEY        hKey;
    SC_HANDLE   scmHandle, serviceHandle;
    BOOL        legacyFree, serviceTypeChanged;
    DWORD       bootArchitecture, dwSize;
    //
    // Check if this system is legacy free or not..
    //
    serviceTypeChanged = FALSE;
    legacyFree = FALSE;
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("HARDWARE\\DESCRIPTION\\System"),
        &hKey
        ) == ERROR_SUCCESS) {
        //
        // According to ACPI spec, absence of bit 0 means legacy free!!!
        // Default to no legacy free.
        //
        bootArchitecture = 1;
        dwSize = sizeof(bootArchitecture);
        RegQueryValueEx(
            hKey,
            TEXT("BootArchitecture"),
            NULL,
            NULL,
            (LPBYTE)&bootArchitecture,
            &dwSize
            );
        if (!(bootArchitecture & 1)) {

            legacyFree = TRUE;
        }
        RegCloseKey(hKey);
    }
    //
    // For legacy free systems, change the service start-type to DemandStart (3).
    //
    if (legacyFree) {

        scmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (scmHandle) {

            serviceHandle = OpenService(scmHandle, ServiceName, SERVICE_ALL_ACCESS);
            if (serviceHandle) {

                serviceTypeChanged = ChangeServiceConfig(
                    serviceHandle,
                    SERVICE_NO_CHANGE,
                    SERVICE_DEMAND_START,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
                CloseServiceHandle(serviceHandle);
            }
            CloseServiceHandle(scmHandle);
        }
    }

    return serviceTypeChanged;
}
// @@END_DDKSPLIT

DWORD
InstallSerialOrParallelPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine installs either a serial or a parallel port.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Supplies the address of the device information element
        being installed.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error code.

--*/
{
    switch (GetPortType(DeviceInfoSet, DeviceInfoData, TRUE)) {
    case PortTypeParallel:
        return InstallPnPParallelPort(DeviceInfoSet, DeviceInfoData);

    case PortTypeSerial:
        return InstallPnPSerialPort(DeviceInfoSet, DeviceInfoData);

    default:
        return ERROR_DI_DO_DEFAULT;
    }
}

PortType
GetPortType(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN          DoDrvKeyInstall
    )
/*++

Routine Description:

    This routine determines whether the driver node selected for the specified device
    is for a parallel (LPT or ECP) or serial (COM) port.  It knows which is which by
    running the AddReg entries in the driver node's install section, and then looking
    in the devnode's driver key for a 'PortSubClass' value entry.  If this value is
    present, and set to 0, then this is an LPT or ECP port, otherwise we treat it like
    a COM port.  This value was relied upon in Win9x, so it is the safest way for us
    to make this determination.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Supplies the address of the device information element
        being installed.

Return Value:

    If the device is an LPT or ECP port, the return value is nonzero, otherwise it is
    FALSE.  (If anything goes wrong, the default is to return FALSE.)

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    HKEY hkDrv;
    TCHAR ActualInfSection[LINE_LEN];
    DWORD RegDataType;
    BYTE RegData;
    DWORD RegDataSize;
    PortType portType;
    ULONG err;

    portType = PortTypeSerial;
    hInf = INVALID_HANDLE_VALUE;
    hkDrv = 0;
    RegData = 0;

    do {
        //
        // Open up the driver key for this device so we can run our INF registry mods
        // against it.
        //
        hkDrv = SetupDiCreateDevRegKey(DeviceInfoSet,
                                       DeviceInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DRV,
                                       NULL,
                                       NULL);

        if (hkDrv == 0) {
            break;
        }

        if (DoDrvKeyInstall) {
            //
            // Retrieve information about the driver node selected for this
            // device.
            //
            DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
            if (!SetupDiGetSelectedDriver(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DriverInfoData)) {
                break;
            }

            DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                           DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInfoDetailData,
                                           sizeof(DriverInfoDetailData),
                                           NULL)
               && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
                //
                // For some reason we couldn't get detail data--this should
                // never happen.
                //
                break;
            }

            //
            // Open the INF that installs this driver node, so we can 'pre-run'
            // the AddReg entries in its install section.
            //
            hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                                    NULL,
                                    INF_STYLE_WIN4,
                                    NULL);

            if (hInf == INVALID_HANDLE_VALUE) {
                //
                // For some reason we couldn't open the INF--this should never
                // happen.
                //
                break;
            }

            //
            // Now find the actual (potentially OS/platform-specific) install
            // section name.
            //
            SetupDiGetActualSectionToInstall(
                hInf,
                DriverInfoDetailData.SectionName,
                ActualInfSection,
                sizeof(ActualInfSection) / sizeof(TCHAR),
                NULL,
                NULL);

            //
            // Now run the registry modification (AddReg/DelReg) entries in
            // this section...
            //
            SetupInstallFromInfSection(
                NULL,    // no UI, so don't need to specify window handle
                hInf,
                ActualInfSection,
                SPINST_REGISTRY,
                hkDrv,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL);
        }

        //
        // Check for a REG_BINARY (1 byte) 'PortSubClassOther' value entry first
        //
        RegDataSize = sizeof(RegData);
        err = RegQueryValueEx(hkDrv,
                              TEXT("PortSubClassOther"),
                              NULL,
                              &RegDataType,
                              &RegData,
                              &RegDataSize);

        if (err == ERROR_SUCCESS && RegDataSize == sizeof(BYTE) &&
            RegDataType == REG_BINARY && RegData != 0) {
            portType = PortTypeOther;
            break;
        }

        //
        // Check for a REG_BINARY (1-byte) 'PortSubClass' value entry set to 0.
        //
        RegDataSize = sizeof(RegData);
        if((ERROR_SUCCESS != RegQueryValueEx(hkDrv,
                                             m_szPortSubClass,
                                             NULL,
                                             &RegDataType,
                                             &RegData,
                                             &RegDataSize))
           || (RegDataSize != sizeof(BYTE))
           || (RegDataType != REG_BINARY))
        {
            portType = PortTypeSerial; // not a LPT/ECP device.
        }
        else {
            if (RegData == 0) {
                portType = PortTypeParallel;
            }
            else {
                portType = PortTypeSerial;
            }
        }
    } while (FALSE);

    if (hkDrv != 0) {
        RegCloseKey(hkDrv);
        hkDrv = 0;
    }

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    }

    return portType;
}

// @@BEGIN_DDKSPLIT
//
// If the preferred value is available, let them have that one
//
VOID
GenerateLptNumber(PDWORD Num,
                  DWORD  PreferredValue)
{
    HKEY    parallelMap;
    TCHAR   valueName[40];
    TCHAR   lptName[60], *lptNameLocation;

    int     i = 0;
    DWORD   valueSize, lptSize, regDataType, newLptNum;
    DWORD   highestLptNum = 0;
    BOOL    change = FALSE;
    TCHAR   errorMsg[MAX_PATH];
    DWORD   mask = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     m_szRegParallelMap,
                     0,
                     KEY_QUERY_VALUE ,
                     &parallelMap) != ERROR_SUCCESS) {
        return;
    }


    valueSize = CharSizeOf(valueName);
    lptSize = sizeof(lptName);
    while (ERROR_SUCCESS == RegEnumValue(parallelMap,
                                         i++,
                                         valueName,
                                         &valueSize,
                                         NULL,
                                         &regDataType,
                                         (LPBYTE) lptName,
                                         &lptSize)) {
        if (regDataType == REG_SZ) {
            lptNameLocation = wcsstr(_wcsupr(lptName), m_szLPT);
            if (lptNameLocation) {
                newLptNum = myatoi(lptNameLocation + wcslen(m_szLPT));
                if (newLptNum == PreferredValue) {
                    change = TRUE;
                }
                if (newLptNum > highestLptNum) {
                    highestLptNum = newLptNum;
                }
                if (newLptNum <= PARALLEL_MAX_NUMBER && newLptNum > 0) {
                    mask |= (1 << (newLptNum-1));
                }
            }
        }

        valueSize = CharSizeOf(valueName);
        lptSize = sizeof(lptName);
    }

    if (change) {
        if (mask < 7) {
            *Num = ((mask & 4)==0) ? PARALLEL_MAX_NUMBER : (((mask & 2)==0) ? 2 : 1);
        } else {
            *Num = highestLptNum + 1;
        }
    } else {
        *Num = PreferredValue;
    }

    RegCloseKey(parallelMap);
}

BOOL
DetermineLptNumberFromResources(
    IN  DEVINST            DevInst,
    OUT PDWORD             Num
    )
/*++

Routine Description:

    This routine retrieves the base IO port and IRQ for the specified device instance
    in a particular logconfig.

Arguments:

    DevInst - Supplies the handle of a device instance to retrieve configuration for.

Return Value:

    If success, the return value is TRUE, otherwise it is FALSE.

--*/
{
    LOG_CONF    logConfig;
    RES_DES     resDes;
    CONFIGRET   cr;
    BOOL        success;
    IO_RESOURCE ioResource;
    WORD        base;
    ULONGLONG base2;

    if (CM_Get_First_Log_Conf(&logConfig,
                              DevInst,
                              BOOT_LOG_CONF) != CR_SUCCESS) {
        GenerateLptNumber(Num, PARALLEL_MAX_NUMBER);
        return TRUE;
    }

    success = FALSE;    // assume failure.

    //
    // First, get the Io base port
    //
    if (CM_Get_Next_Res_Des(&resDes,
                            logConfig,
                            ResType_IO,
                            NULL,
                            0) != CR_SUCCESS) {
        goto clean0;
    }

    cr = CM_Get_Res_Des_Data(resDes,
                             &ioResource,
                             sizeof(IO_RESOURCE),
                             0);

    CM_Free_Res_Des_Handle(resDes);

    if (cr != CR_SUCCESS) {
        goto clean0;
    }

    success = TRUE;


    //
    // Values for resources from ISA Architecture
    //

    base = (WORD) ioResource.IO_Header.IOD_Alloc_Base;

    if (IN_RANGE(base, 0x278, 0x27f)) {
        *Num = 2;
    }
    else if (IN_RANGE(base, 0x378, 0x37f)) {
        *Num = 1;
    }
    else if (base == 0x3bc) {
        *Num = 1;
    }
    else {
        //
        // Most machines only have one port anways, so just try that here
        //
        GenerateLptNumber(Num, PARALLEL_MAX_NUMBER);
    }

clean0:
    CM_Free_Log_Conf_Handle(logConfig);

    return success;
}
// @@END_DDKSPLIT

DWORD
InstallPnPParallelPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

// @@BEGIN_DDKSPLIT
Routine Description:

    This routine installs a parallel (LPT or ECP) port.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Supplies the address of the device information element
        being installed.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error code.

    //
    // IGNORE the decription below, it is for the DDK only
    //

// @@END_DDKSPLIT

Routine Description:

    This routine installs a parallel port. In the DDK implementation, we let the
    default setup installer run and do nothing special.

--*/
{
// @@BEGIN_DDKSPLIT
    TCHAR           charBuffer[LINE_LEN],
                    friendlyNameFormat[LINE_LEN],
                    deviceDesc[LINE_LEN],
                    lptPortName[20];
    PTCHAR          lptLocation;
    DWORD           lptPortNameSize, lptNum;
    HKEY            hDeviceKey;
    TCHAR           lpszService[MAX_PATH];
    DWORD           error;

    //
    // We init the value here so that the DDK version of the function we have an
    // initialized value when it returns err.  In the shipping version of this
    // function, we immediately set this to a different value.
    //
// @@END_DDKSPLIT

    DWORD           err = ERROR_DI_DO_DEFAULT;

// @@BEGIN_DDKSPLIT
    err = ERROR_SUCCESS;

    //
    // Predispose the port name to 1.  On almost any machine imaginable, there
    // will only be ONE LPT port, so we might as well assume it.
    //
    lptNum = PARALLEL_MAX_NUMBER;

    ZeroMemory(lptPortName, sizeof(lptPortName));

    //
    // First, make sure that Device Parameters\PortName exists and contains a
    // valid value so that when the parallel driver starts, it can name the
    // device
    //

    if ((hDeviceKey = SetupDiCreateDevRegKey(DeviceInfoSet,
                                             DeviceInfoData,
                                             DICS_FLAG_GLOBAL,
                                             0,
                                             DIREG_DEV,
                                             NULL,
                                             NULL)) != INVALID_HANDLE_VALUE) {
        //
        // Retrieve the port name.
        //
        lptPortNameSize = sizeof(lptPortName);
        if (RegQueryValueEx(hDeviceKey,
                            m_szPortName,
                            NULL,
                            NULL,
                            (PBYTE)lptPortName,
                            &lptPortNameSize) != ERROR_SUCCESS) {
            lptPortNameSize = sizeof(lptPortName);
            if (RegQueryValueEx(hDeviceKey,
                                m_szDosDeviceName,
                                NULL,
                                NULL,
                                (PBYTE) lptPortName,
                                &lptPortNameSize) != ERROR_SUCCESS) {

                if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_ENUMERATOR_NAME,
                                                     NULL,
                                                     (PBYTE)charBuffer,
                                                     sizeof(charBuffer),
                                                     NULL)) {

                    if (lstrcmpi(charBuffer, m_szAcpiEnumName) == 0) {
                        wsprintf(lptPortName, _T("%s%d"), m_szLPT, 1);
                    }
                }

                if (*lptPortName != _T('\0')) {
                    DWORD dwSize, dwFirmwareIdentified;

                    dwSize = sizeof(dwFirmwareIdentified);
                    if (RegQueryValueEx(hDeviceKey,
                                        m_szFirmwareIdentified,
                                        NULL,
                                        NULL,
                                        (PBYTE) &dwFirmwareIdentified,
                                        &dwSize) == ERROR_SUCCESS) {
                        //
                        // ACPI puts the value "FirmwareIdentified" if it has enumerated
                        // this port.  We only rely on this if a DDN isn't present and we
                        // couldn't get the enumerator name
                        //
                        wsprintf(lptPortName, _T("%s%d"), m_szLPT, 1);
                    }
                }
            }
        }

        if (lptPortName[0] != (TCHAR) 0) {

            _wcsupr(lptPortName);
            lptLocation = wcsstr(lptPortName, m_szLPT);
            if (lptLocation) {
                lptNum = myatoi(lptLocation + wcslen(m_szLPT));
            } else {
                DetermineLptNumberFromResources((DEVINST) DeviceInfoData->DevInst,
                                                &lptNum);
            }
        }
        else {
            DetermineLptNumberFromResources((DEVINST) DeviceInfoData->DevInst,
                                            &lptNum);
        }
        //
        // Check if this is a brand new port by querying the service value.
        // On a newly detected port, there will be no service value.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_SERVICE,
                                             NULL,
                                             (LPBYTE) lpszService,
                                             MAX_PATH*sizeof(TCHAR),
                                             NULL)) {
            if (ERROR_INVALID_DATA == GetLastError())
            {
                GenerateLptNumber(&lptNum, lptNum);
            }
        }

        wsprintf(lptPortName, _T("LPT%d"), lptNum);

        //
        // If this fails, then we can't do much about it but continue
        //
        RegSetValueEx(hDeviceKey,
                      m_szPortName,
                      0,
                      REG_SZ,
                      (PBYTE) lptPortName,
                      ByteCountOf(lstrlen(lptPortName) + 1)
                      );

        RegCloseKey(hDeviceKey);
    }

    //
    // Second, let the default installation take place.
    //
    if (!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData)) {
        return GetLastError();
    }

    //
    // Now generate a string, to be used for the device's friendly name, that incorporates
    // both the INF-specified device description, and the port name.  For example,
    //
    //     ECP Printer Port (LPT1)
    //

    if (LoadString(g_hInst,
                   IDS_FRIENDLY_FORMAT,
                   friendlyNameFormat,
                   CharSizeOf(friendlyNameFormat)) &&
       SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_DEVICEDESC,
                                        NULL,
                                        (PBYTE)deviceDesc,
                                        sizeof(deviceDesc),
                                        NULL)) {
        wsprintf(charBuffer, friendlyNameFormat, deviceDesc, lptPortName);
    }
    else {
        //
        // Simply use LPT port name.
        //
        lstrcpy(charBuffer, lptPortName);
    }

    SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_FRIENDLYNAME,
                                     (PBYTE)charBuffer,
                                     ByteCountOf(lstrlen(charBuffer) + 1)
                                    );


    //
    // Ignore the comments below, but KEEP THEM IN.  We need them for the DDK
    //
// @@END_DDKSPLIT

    //
    // Let the default setup installer install parallel ports for the DDK
    // version of this class installer
    //
    return err;
}

// @@BEGIN_DDKSPLIT
DWORD
GetDetectedSerialPortsList(
    IN HDEVINFO DeviceInfoSet,
    IN BOOL     FirstTimeSetup
    )
/*++

Routine Description:

    This routine retrieves a list of all root-enumerated COM port device
    instances that are not manually installed (both phantoms and non-phantoms),
    and adds those device instances to the supplied device information set.

    See also ntos\io\pnpmap.c!PnPBiosEliminateDupes

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set into which
    the detected serial port elements are to be added.

    FirstTimeSetup - If non-zero, then we're in GUI-mode setup (responding to
        DIF_FIRSTTIMESETUP), and we only want to report (unregistered) devnodes
        created by the firmware mapper.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of failure.

--*/
{
    CONFIGRET cr;
    PTCHAR DevIdBuffer;
    ULONG DevIdBufferLen, Status, Problem;
    PTSTR CurDevId, DeviceIdPart, p;
    DWORD i;
    DEVNODE DevNode;
    HWND hwndParent = NULL;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DEVINFO_DATA DeviceInfoData;

    //
    // First retrieve a list of all root-enumerated device instances.
    //
    while(TRUE) {

        cr = CM_Get_Device_ID_List_Size(&DevIdBufferLen,
                                        m_szRootEnumName,
                                        CM_GETIDLIST_FILTER_ENUMERATOR
                                       );

        if((cr != CR_SUCCESS) || !DevIdBufferLen) {
            //
            // This should never happen.
            //
            return ERROR_INVALID_DATA;
        }

        if(!(DevIdBuffer = LocalAlloc(LPTR, DevIdBufferLen * sizeof(TCHAR)))) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        cr = CM_Get_Device_ID_List(m_szRootEnumName,
                                   DevIdBuffer,
                                   DevIdBufferLen,
                                   CM_GETIDLIST_FILTER_ENUMERATOR
                                  );

        if(cr == CR_SUCCESS) {
            //
            // Device list retrieved successfully.
            //
            break;

        } else {
            //
            // Free the current buffer before determining what error occurred.
            //
            LocalFree(DevIdBuffer);

            //
            // If the error we encountered was anything other than buffer-too-
            // small, then we have to bail.  (Note: since we sized our buffer
            // up-front, the only time we'll hit buffer-too-small is if someone
            // else is creating root-enumerated devnodes while we're trying to
            // retrieve the list.)
            //
            if(cr != CR_BUFFER_SMALL) {
                return ERROR_INVALID_DATA;
            }
        }
    }

    //
    // Retrieve the HWND associated with the device information set, so we can
    // specify that same handle for any device information elements we create.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(SetupDiGetDeviceInstallParams(DeviceInfoSet, NULL, &DeviceInstallParams)) {
        hwndParent = DeviceInstallParams.hwndParent;
    }

    //
    // Now examine each device ID in our list, looking for ones that match up
    // with the list of serial IDs that the firmware mapper can report.
    //
    for(CurDevId = DevIdBuffer;
        *CurDevId;
        CurDevId += lstrlen(CurDevId) + 1) {

        //
        // Skip over the root-enumerator prefix plus the first backslash.
        //
        DeviceIdPart = CurDevId + (sizeof(m_szRootEnumName) / sizeof(TCHAR));

        //
        // Find the next backslash and temporarily replace it with a NULL char.
        //
        p = _tcschr(DeviceIdPart, TEXT('\\'));

        if (p)
        {
            *p = TEXT('\0');
        }

        for(i = 0; i < SERIAL_PNP_IDS_COUNT; i++) {

            if(!lstrcmpi(DeviceIdPart, m_pszSerialPnPIds[i])) {
                //
                // We found a match
                //
                break;
            }
        }

        //
        // Before checking to see if we found a match, restore the backslash
        //
        if (p)
        {
            *p = TEXT('\\');
        }

        if(i >= SERIAL_PNP_IDS_COUNT) {
            //
            // We don't care about this device instance--move on to the next
            // one.
            //
            continue;
        }

        //
        // Next, attempt to locate the devnode (either present or not-present).
        // Note that this call _will not_ succeed for device instances that are
        // "private phantoms" (i.e., marked with the "Phantom" flag in their
        // device instance key by the firmware mapper or by some other process
        // that has created a new root-enumerated device instance, but has not
        // yet registered it).
        //
        cr = CM_Locate_DevNode(&DevNode,
                               CurDevId,
                               CM_LOCATE_DEVINST_PHANTOM
                              );

        if(cr == CR_SUCCESS) {
            //
            // We are dealing with a device that has been registered.  It may
            // or may not be present, however.  Attempt to retrieve its status.
            // If that fails, the device isn't present, and we don't want to
            // return it in our list of detected serial ports.  Also, we want
            // to skip this device if it was manually installed.
            //
            // Also, make sure we're processing DIF_DETECT.  We don't want to
            // do this for DIF_FIRSTTIMESETUP, because GUI-mode setup doesn't
            // pay attention to what previously-detected devices are no longer
            // found, so all we end up doing is causing two installs for each
            // detected device.
            //
            if(FirstTimeSetup
               || (CR_SUCCESS != CM_Get_DevNode_Status(&Status,
                                                       &Problem,
                                                       DevNode,
                                                       0))
               || (Status & DN_MANUAL)) {

                //
                // Move on to the next device.
                //
                continue;
            }

            //
            // OK, now we can add this device information element to our set of
            // detected devices.  Regardless of success or failure, we're done
            // with this device--it's time to move on to the next one.
            //
            SetupDiOpenDeviceInfo(DeviceInfoSet,
                                  CurDevId,
                                  hwndParent,
                                  0,
                                  NULL
                                 );
            continue;
        }

        //
        // If we get to here, then we've found a private phantom.  Create a
        // device information element for this device.  The underlying code
        // that implements CM_Create_DevInst won't allow creation of a device
        // instance that's already a private phantom _unless_ that device
        // instance was created by the firmware mapper.  Thus, we don't have to
        // worry about the (admittedly unlikely) case that we caught a private
        // phantom created by someone else (e.g., another detection in
        // progress.)
        //
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        if(!SetupDiCreateDeviceInfo(DeviceInfoSet,
                                    CurDevId,
                                    &GUID_DEVCLASS_PORTS,
                                    NULL,
                                    hwndParent,
                                    0,
                                    &DeviceInfoData)) {
            //
            // We were unable to create a device information element for this
            // private phantom (maybe because it wasn't a creation of the
            // firmware mapper).  At any rate, there's nothing we can do, so
            // skip this device and continue on.
            //
            continue;
        }

        //
        // OK, we have a device information element for our detected serial
        // port.  DIF_FIRSTTIMESETUP expects us to have a driver selected for
        // any devices we return.  DIF_DETECT doesn't make this requirement,
        // but it does respect the driver selection, if we make one.  Thus, we
        // always go ahead and do the compatible driver search ourselves.
        //
        if(!SetupDiBuildDriverInfoList(DeviceInfoSet,
                                       &DeviceInfoData,
                                       SPDIT_COMPATDRIVER)) {
            //
            // This should never fail--if it does, bail and move on to the next
            // device.
            //
            SetupDiDeleteDeviceInfo(DeviceInfoSet, &DeviceInfoData);
            continue;
        }

        //
        // Now select the best driver from among the compatible matches for the
        // device.
        //
        if(!SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                      DeviceInfoSet,
                                      &DeviceInfoData)) {
            //
            // This shouldn't fail, unless something really bad has happened
            // such as the user deleting %windir%\Inf\msports.inf.  If that
            // happens, then once again we've no choice but to bail and move on
            // to the next device.
            //
            SetupDiDeleteDeviceInfo(DeviceInfoSet, &DeviceInfoData);
            continue;
        }

        //
        // We've successfully added the detected device to the device info set.
        // On to the next device...
        //
    }

    LocalFree(DevIdBuffer);

    return NO_ERROR;
}


DWORD
RegisterDetectedSerialPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine performs duplicate detection on the specified device
    information element, and if it isn't found to be a duplicate of any
    existing device, this devinfo element is registered (thus transforming it
    from just registry spooge into a real, live root-enumerated devnode).

Arguments:

    DeviceInfoSet - Supplies the handle of the device information set that
        contains the element to be registered.

    DeviceInfoData - Supplies the context structure for the device information
        element to be registered.

Return Value:

    If the device isn't a duplicate, the return value is NO_ERROR.
    Otherwise, it is some other Win32 error code indicating the cause of
    failure.  The most common failure is due to having detected the device as
    being a duplicate of an existing one--in that case the error reported is
    ERROR_DUPLICATE_FOUND.

Remarks:

    If the device being registered wasn't created via device detection (i.e.,
    it doesn't have a boot config), then we just return ERROR_DI_DO_DEFAULT.

--*/
{
    CONFIGRET cr;
    LOG_CONF LogConf;
    RES_DES ResDes;
    IO_RESOURCE IoResource;
    CONFLICT_LIST ConflictList;
    ULONG ConflictCount, ConflictIndex;
    CONFLICT_DETAILS ConflictDetails;
    INT i, PosDupIndex, PosDupCount;
    PTCHAR IdBuffer = NULL;
    ULONG IdBufferSize = 0;
    DWORD Err;
    PCTSTR p;
    PTCHAR SerialDevNodeList = NULL;
    ULONG SerialDevNodeListSize;
    TCHAR CharBuffer[MAX_DEVNODE_ID_LEN];
    ULONG CharBufferSize;
    PTSTR *PosDupList;

    //
    // First, check to see if the boot config for this device conflicts with
    // any other device.  If it doesn't, then we know we don't have a duplicate.
    //
    if(!GetSerialPortDevInstConfig((DEVNODE)(DeviceInfoData->DevInst),
                                   BOOT_LOG_CONF,
                                   &IoResource,
                                   NULL)) {
        //
        // The device instance doesn't have a boot config--this will happen if
        // the user is attempting to manually install a COM port (i.e., not via
        // detection).  In this case, just let the default behavior happen.
        //
        return ERROR_DI_DO_DEFAULT;
    }

    //
    // We can't query for the resource conflict list on a phantom devnode.
    // Therefore, we are forced to register this devnode now, then uninstall it
    // later if we discover that it is, in fact, a duplicate.
    //
    if(!SetupDiRegisterDeviceInfo(DeviceInfoSet,
                                  DeviceInfoData,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL)) {
        //
        // Device couldn't be registered.
        //
        return GetLastError();
    }

    cr = CM_Query_Resource_Conflict_List(&ConflictList,
                                         (DEVNODE)(DeviceInfoData->DevInst),
                                         ResType_IO,
                                         &IoResource,
                                         sizeof(IoResource),
                                         0,
                                         NULL
                                        );

    if(cr != CR_SUCCESS) {
        //
        // Couldn't retrieve a conflict list--assume there are no conflicts,
        // thus this device isn't a duplicate.
        //
        return NO_ERROR;
    }

    //
    // Find out how many things conflicted.
    //
    if((CR_SUCCESS != CM_Get_Resource_Conflict_Count(ConflictList, &ConflictCount))
       || !ConflictCount) {

        //
        // Either we couldn't retrieve the conflict count, or it was zero.  In
        // any case, we should assume this device isn't a duplicate.
        //
        Err = NO_ERROR;
        goto clean1;
    }

    //
    // Retrieve the list of devnodes with which the Serial service is
    // associated (as either the function driver or a filter driver).
    //
    SerialDevNodeListSize = 1024; // start out with a 1K character buffer

    while(TRUE) {

        if(!(SerialDevNodeList = LocalAlloc(LPTR, SerialDevNodeListSize))) {
            //
            // Out of memory--time to bail!
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }

        cr = CM_Get_Device_ID_List(m_szSERIAL,
                                   SerialDevNodeList,
                                   SerialDevNodeListSize,
                                   CM_GETIDLIST_FILTER_SERVICE
                                  );

        if(cr == CR_SUCCESS) {
            break;
        }

        LocalFree(SerialDevNodeList);
        SerialDevNodeList = NULL;

        if(cr != CR_BUFFER_SMALL) {
            //
            // We failed for some reason other than buffer-too-small.  Maybe
            // the Serial service isn't even installed.  At any rate, we'll
            // just skip this part of our check when processing the conflicting
            // devnodes below.
            //
            break;
        }

        //
        // Figure out how big of a buffer we actually need,
        //
        cr = CM_Get_Device_ID_List_Size(&SerialDevNodeListSize,
                                        m_szSERIAL,
                                        CM_GETIDLIST_FILTER_SERVICE
                                       );
        if(cr != CR_SUCCESS) {
            //
            // This shouldn't fail, but if it does we'll just do without the
            // list.
            //
            break;
        }
    }

    //
    // Retrieve the list of possible duplicate IDs
    //
    if(!GetPosDupList(DeviceInfoSet, DeviceInfoData, &PosDupList, &PosDupCount)) {
        //
        // We couldn't retrieve the PosDup list for some reason--default to
        // the list of IDs known to be spat out by the firmware mapper.
        //
        PosDupList = m_pszSerialPnPIds;
        PosDupCount = SERIAL_PNP_IDS_COUNT;
    }

    //
    // Loop through each conflict, checking to see whether our device is a
    // duplicate of any of them.
    //
    for(ConflictIndex = 0; ConflictIndex < ConflictCount; ConflictIndex++) {

        ZeroMemory(&ConflictDetails, sizeof(ConflictDetails));

        ConflictDetails.CD_ulSize = sizeof(CONFLICT_DETAILS);
        ConflictDetails.CD_ulMask = CM_CDMASK_DEVINST | CM_CDMASK_FLAGS;

        cr = CM_Get_Resource_Conflict_Details(ConflictList,
                                              ConflictIndex,
                                              &ConflictDetails
                                             );

        //
        // If we failed to retrieve the conflict details, or if the conflict
        // was not with a PnP devnode, then we can ignore this conflict.
        //
        if((cr != CR_SUCCESS)
           || (ConflictDetails.CD_dnDevInst == -1)
           || (ConflictDetails.CD_ulFlags & (CM_CDFLAGS_DRIVER
                                             | CM_CDFLAGS_ROOT_OWNED
                                             | CM_CDFLAGS_RESERVED))) {
            continue;
        }

        //
        // We have a devnode--first check to see if this is the HAL devnode
        // (class = "Computer").  If so, then we've found the serial port in
        // use by the kernel debugger.
        //
        CharBufferSize = sizeof(CharBuffer);
        cr = CM_Get_DevNode_Registry_Property(ConflictDetails.CD_dnDevInst,
                                              CM_DRP_CLASSGUID,
                                              NULL,
                                              CharBuffer,
                                              &CharBufferSize,
                                              0
                                             );

        if((cr == CR_SUCCESS) && !lstrcmpi(CharBuffer, m_szComputerClassGuidString)) {
            //
            // We're conflicting with the HAL, presumably because it's claimed
            // the serial port IO addresses for use as the kernel debugger port.
            //
            // There are 3 scenarios:
            //
            //   1. non-ACPI, non-PnPBIOS machine -- detection is not required
            //      on these machines, because the mapper-reported devnodes are
            //      not reported as phantoms in the first place.
            //
            //   2. PnPBIOS or ACPI machine, debugger on PnP COM port -- we
            //      don't want to install our detected devnode because it's a
            //      duplicate.
            //
            //   3. PnPBIOS or ACPI machine, debugger on legacy COM port -- we
            //      _should_ install this devnode, because otherwise having the
            //      kernel debugger hooked up will prevent us from detecting
            //      the COM port.
            //
            // Unfortunately, we can't distinguish between cases (2) and (3) on
            // ACPI machines, because ACPI doesn't enumerate a devnode for the
            // serial port that's being used as the kernel debugger.  For now,
            // we're going to punt case (3) and say "tough"--you have to
            // disable the kernel debugger, reboot and re-run the hardware
            // wizard.  This isn't too bad considering that it's no worse than
            // what would happen if we actually had to poke at ports to detect
            // the COM port.  In that case, too, we would be unable to detect
            // the COM port if it was already in use by the debugger.
            //
            Err = ERROR_DUPLICATE_FOUND;
            goto clean2;
        }

        //
        // OK, we're not looking at the kernel debugger port.  Now check to see
        // if one of our known mapper-reported IDs is among this device's list
        // of hardware or compatible IDs.
        //
        for(i = 0; i < 2; i++) {

            cr = CM_Get_DevNode_Registry_Property(ConflictDetails.CD_dnDevInst,
                                                  (i ? CM_DRP_COMPATIBLEIDS
                                                     : CM_DRP_HARDWAREID),
                                                  NULL,
                                                  IdBuffer,
                                                  &IdBufferSize,
                                                  0
                                                 );

            if(cr == CR_BUFFER_SMALL) {

                if(IdBuffer) {
                    LocalFree(IdBuffer);
                }

                if(!(IdBuffer = LocalAlloc(LPTR, IdBufferSize))) {
                    //
                    // Out of memory--time to bail!
                    //
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean2;
                }

                //
                // Decrement our index, so when we loop around again, we'll
                // re-attempt to retrieve the same property.
                //
                i--;
                continue;

            } else if(cr != CR_SUCCESS) {
                //
                // Failed to retrieve the property--just move on to the next
                // one.
                //
                continue;
            }

            //
            // If we get to here, we successfully retrieved a multi-sz list of
            // hardware or compatible IDs for this device.
            //
            for(p = IdBuffer; *p; p += (lstrlen(p) + 1)) {
                for(PosDupIndex = 0; PosDupIndex < PosDupCount; PosDupIndex++) {
                    if(!lstrcmpi(p, PosDupList[PosDupIndex])) {
                        //
                        // We found a match--our guy's a dupe.
                        //
                        Err = ERROR_DUPLICATE_FOUND;
                        goto clean2;
                    }
                }
            }
        }

        //
        // If we get to here, then we didn't find any duplicates based on ID
        // matching.  However, there are some 16550-compatible PnP devices that
        // don't report the correct compatible ID.  However, we have another
        // trick we can use--if the device has serial.sys as either the
        // function driver or a filter driver, then this is a solid indicator
        // that we have a dupe.
        //
        if(SerialDevNodeList) {
            //
            // Retrieve the name of this devnode so we can compare it against
            // the list of devnodes with which the Serial service is associated.
            //
            if(CR_SUCCESS == CM_Get_Device_ID(ConflictDetails.CD_dnDevInst,
                                              CharBuffer,
                                              sizeof(CharBuffer) / sizeof(TCHAR),
                                              0)) {

                for(p = SerialDevNodeList; *p; p += (lstrlen(p) + 1)) {
                    if(!lstrcmpi(CharBuffer, p)) {
                        //
                        // This devnode is using serial.sys--it must be a dupe.
                        //
                        Err = ERROR_DUPLICATE_FOUND;
                        goto clean2;
                    }
                }
            }
        }
    }

    //
    // If we get here, then all our checks have past--our newly-detected device
    // instance is not a duplicate of any other existing devnodes.
    //
    Err = NO_ERROR;

clean2:
    if(SerialDevNodeList) {
        LocalFree(SerialDevNodeList);
    }
    if(IdBuffer) {
        LocalFree(IdBuffer);
    }
    if(PosDupList != m_pszSerialPnPIds) {
        for(PosDupIndex = 0; PosDupIndex < PosDupCount; PosDupIndex++) {
            LocalFree(PosDupList[PosDupIndex]);
        }
        LocalFree(PosDupList);
    }

clean1:
    CM_Free_Resource_Conflict_Handle(ConflictList);

    if(Err != NO_ERROR) {
        //
        // Since we registered the devnode, we must manually uninstall it if
        // we fail.
        //
        SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData);
    }

    return Err;
}


BOOL
GetPosDupList(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData,
    OUT PTSTR            **PosDupList,
    OUT INT               *PosDupCount
    )
/*++

Routine Description:

    This routine retrieves the list of PosDup IDs contained in the
    [<ActualInstallSec>.PosDup] INF section for the device information
    element's selected driver node.

Arguments:

    DeviceInfoSet - Supplies the handle of the device information set that
        contains the device information element for which a driver is selected

    DeviceInfoData - Supplies the context structure for the device information
        element for which a driver node is selected.  The PosDup list will be
        retrieved based on this driver node's (potentially decorated) INF
        install section.

    PosDupList - Supplies the address of a pointer that will be set, upon
        successful return, to point to a newly-allocated array of string
        pointers, each pointing to a newly-allocated string buffer containing
        a device ID referenced in the relevant PosDup section for the selected
        driver node.

    PosDupCount - Supplies the address of an integer variable that, upon
        successful return, receives the number of string pointers stored in the
        PosDupList array.

Return Value:

    If successful, the return value is non-zero.  The caller is responsible for
    freeing each string pointer in the array, as well as the array buffer
    itself.

    If unsuccessful, the return value is zero (FALSE).  (Note: the call is also
    considered unsuccessful if there's no associated PosDup section, or if it's
    empty).

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    TCHAR InfSectionWithExt[255];   // MAX_SECT_NAME_LEN from setupapi\inf.h
    BOOL b = FALSE;
    LONG LineCount, LineIndex;
    INFCONTEXT InfContext;
    DWORD NumElements, NumFields, FieldIndex;
    TCHAR PosDupId[MAX_DEVICE_ID_LEN];
    PTSTR PosDupCopy;

    //
    // Get the driver node selected for the specified device information
    // element.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        //
        // No driver node selected--there's nothing we can do!
        //
        goto clean0;
    }

    //
    // Now retrieve the corresponding INF and install section.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL)
       && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        //
        // We failed, and it wasn't because the buffer was too small.  We gotta
        // bail.
        //
        goto clean0;
    }

    //
    // Open the INF for this driver node.
    //
    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        goto clean0;
    }

    //
    // Get the (potentially decorated) install section name.
    //
    if(!SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData.SectionName,
                                         InfSectionWithExt,
                                         sizeof(InfSectionWithExt) / sizeof(TCHAR),
                                         NULL,
                                         NULL)) {
        goto clean1;
    }

    //
    // Append ".PosDup" to decorated install section.
    //
    lstrcat(InfSectionWithExt, m_szPosDupSectionSuffix);

    //
    // First, figure out the size of the array we're going to populate...
    //
    NumElements = 0;

    //
    // Loop through each line in the PosDup section.
    //
    LineCount = SetupGetLineCount(hInf, InfSectionWithExt);

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {
        if(SetupGetLineByIndex(hInf, InfSectionWithExt, LineIndex, &InfContext)) {
            NumElements += SetupGetFieldCount(&InfContext);
        }
    }

    if(!NumElements) {
        //
        // We didn't find any PosDup entries.
        //
        goto clean1;
    }

    //
    // Now allocate a buffer big enough to hold all these entries.
    //
    *PosDupList = LocalAlloc(LPTR, NumElements * sizeof(PTSTR));

    if(!*PosDupList) {
        goto clean1;
    }

    *PosDupCount = 0;

    //
    // Now loop though each PosDup entry, and store copies of those entries in
    // our array.
    //
    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(SetupGetLineByIndex(hInf, InfSectionWithExt, LineIndex, &InfContext)) {

            NumFields = SetupGetFieldCount(&InfContext);

            for(FieldIndex = 1; FieldIndex <= NumFields; FieldIndex++) {

                if(!SetupGetStringField(&InfContext,
                                        FieldIndex,
                                        PosDupId,
                                        sizeof(PosDupId) / sizeof(TCHAR),
                                        NULL)) {
                    //
                    // This shouldn't fail, but if it does, just move on to the
                    // next field.
                    //
                    continue;
                }

                PosDupCopy = LocalAlloc(LPTR,
                                        (lstrlen(PosDupId) + 1) * sizeof(TCHAR)
                                       );
                if(!PosDupCopy) {
                    goto clean2;
                }

                lstrcpy(PosDupCopy, PosDupId);

                (*PosDupList)[(*PosDupCount)++] = PosDupCopy;
            }
        }
    }

    //
    // If we get to here, and we found even one PosDup entry, consider the
    // operation a success
    //
    if(*PosDupCount) {
        b = TRUE;
        goto clean1;
    }

clean2:
    //
    // Something bad happened--clean up all memory allocated.
    //
    {
        INT i;

        for(i = 0; i < *PosDupCount; i++) {
            LocalFree((*PosDupList)[i]);
        }
        LocalFree(*PosDupList);
    }

clean1:
    SetupCloseInfFile(hInf);

clean0:
    return b;
}


// @@END_DDKSPLIT

#define NO_COM_NUMBER 0

BOOL
DetermineComNumberFromResources(
    IN  DEVINST            DevInst,
    OUT PDWORD             Num
    )
/*++

Routine Description:

    This routine retrieves the base IO port and IRQ for the specified device instance
    in a particular logconfig.

    If a successful match is found, then *Num == found number, otherwise
    *Num == NO_COM_NUMBER.

Arguments:

    DevInst - Supplies the handle of a device instance to retrieve configuration for.

Return Value:

    If success, the return value is TRUE, otherwise it is FALSE.

--*/
{
    LOG_CONF    logConfig;
    RES_DES     resDes;
    CONFIGRET   cr;
    BOOL        success;
    IO_RESOURCE ioResource;
    WORD        base;
    ULONGLONG base2;

    success = FALSE;    // assume failure.
    *Num = NO_COM_NUMBER;

    //
    // If the device does not have a boot config, use the com db
    //
    if (CM_Get_First_Log_Conf(&logConfig,
                              DevInst,
                              BOOT_LOG_CONF) != CR_SUCCESS) {
        return success;
    }

    //
    // First, get the Io base port
    //
    if (CM_Get_Next_Res_Des(&resDes,
                            logConfig,
                            ResType_IO,
                            NULL,
                            0) != CR_SUCCESS) {
        goto clean0;
    }

    cr = CM_Get_Res_Des_Data(resDes,
                             &ioResource,
                             sizeof(IO_RESOURCE),
                             0);

    CM_Free_Res_Des_Handle(resDes);

    if (cr != CR_SUCCESS) {
        goto clean0;
    }

    //
    // Values for resources from ISA Architecture
    //
    base = (WORD) ioResource.IO_Header.IOD_Alloc_Base;
    if (IN_RANGE(base, 0x3f8, 0x3ff)) {
        *Num = 1;
    }
    else if (IN_RANGE(base, 0x2f8, 0x2ff)) {
        *Num = 2;
    }
    else if (IN_RANGE(base, 0x3e8, 0x3ef)) {
        *Num = 3;
    }
    else if (IN_RANGE(base, 0x2e8, 0x2ef)) {
        *Num = 4;
    }

    if (*Num != NO_COM_NUMBER) {
        success = TRUE;
    }

clean0:
    CM_Free_Log_Conf_Handle(logConfig);

    return success;
}

#define DEF_MIN_COM_NUM (5)

DWORD
InstallPnPSerialPort(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine performs the installation of a PnP ISA serial port device (may
    actually be a modem card).  This involves the following steps:

        1.  Select a COM port number and serial device name for this port
            (This involves duplicate detection, since PnP ISA cards will
            sometimes have a boot config, and thus be reported by ntdetect/ARC
            firmware.)
        2.  Create a subkey under the serial driver's Parameters key, and
            set it up just as if it was a manually-installed port.
        3.  Display the resource selection dialog, and allow the user to
            configure the settings for the port.
        4.  Write out the settings to the serial port's key in legacy format
            (i.e., the way serial.sys expects to see it).
        5.  Write out PnPDeviceId value to the serial port's key, which gives
            the device instance name with which this port is associated.
        6.  Write out PortName value to the devnode key, so that modem class
            installer can continue with installation (if this is really a
            PnP ISA modem).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device being installed.

    DeviceInfoData - Supplies the address of the device information element
        being installed.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error code.

--*/
{
    HKEY        hKey;
    HCOMDB      hComDB;
    TCHAR       comPort[40],
                szPortName[20],
                charBuffer[MAX_PATH],
                friendlyNameFormat[LINE_LEN],
                deviceDesc[LINE_LEN];
    PTCHAR      comLocation;
    DWORD       comPortSize,
                comPortNumber = NO_COM_NUMBER,
                portsReported;
    DWORD       dwFirmwareIdentified, dwSize;
    BYTE        portUsage[32];
    BOOL        res;
    DWORD       firmwarePort = FALSE;

#if MAX_DEVICE_ID_LEN > MAX_PATH
#error MAX_DEVICE_ID_LEN is greater than MAX_PATH.  Update charBuffer.
#endif

    ZeroMemory(comPort, sizeof(comPort));

    ComDBOpen(&hComDB);

    if ((hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                     DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DEV,
                                     KEY_READ)) != INVALID_HANDLE_VALUE) {

        comPortSize = sizeof(comPort);
        if (RegQueryValueEx(hKey,
                            m_szPortName,
                            NULL,
                            NULL,
                            (PBYTE)comPort,
                            &comPortSize) == ERROR_SUCCESS) {
            firmwarePort = TRUE;
        }
        else if ((comPortSize = sizeof(comPort)) &&
                 RegQueryValueEx(hKey,
                                 m_szDosDeviceName,
                                 NULL,
                                 NULL,
                                 (PBYTE) comPort,
                                 &comPortSize) == ERROR_SUCCESS) {
            //
            // ACPI puts the name of the port as DosDeviceName, use this name
            // as the basis for what to call this port
            //
            firmwarePort = TRUE;
        }
        else {
            //
            // Our final check is to check the enumerator.  We care about two
            // cases:
            //
            // 1)  If the enumerators is ACPI.  If so, blindly consider this
            //     a firmware port (and get the BIOS mfg to provide a _DDN method
            //     for this device!)
            //
            // 2)  The port is "root" enumerated, yet it's not marked as
            // DN_ROOT_ENUMERATED.  This is the
            // way we distinguish PnPBIOS-reported devnodes.  Note that, in
            // general, these devnodes would've been caught by the check for a
            // "PortName" value above, but this won't be present if we couldn't
            // find a matching ntdetect-reported device from which to migrate
            // the COM port name.
            //
            // Note also that this check doesn't catch ntdetect or firmware
            // reported devices.  In these cases, we should already have a
            // PortName, thus the check above should catch those devices.  In
            // the unlikely event that we encounter an ntdetect or firmware
            // devnode that doesn't already have a COM port name, then it'll
            // get an arbitrary one assigned.  Oh well.
            //
            if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_ENUMERATOR_NAME,
                                                 NULL,
                                                 (PBYTE)charBuffer,
                                                 sizeof(charBuffer),
                                                 NULL)) {
                if (lstrcmpi(charBuffer, m_szAcpiEnumName) == 0) {
                    firmwarePort = TRUE;
                }
                else if (lstrcmpi(charBuffer, m_szRootEnumName) == 0) {
                    ULONG status, problem;

                    if ((CM_Get_DevNode_Status(&status,
                                               &problem,
                                               (DEVNODE)(DeviceInfoData->DevInst),
                                               0) == CR_SUCCESS)
                        && !(status & DN_ROOT_ENUMERATED))
                    {
                        firmwarePort = TRUE;
                    }
                }
            }

            dwSize = sizeof(dwFirmwareIdentified);
            if (firmwarePort == FALSE &&
                RegQueryValueEx(hKey,
                                m_szFirmwareIdentified,
                                NULL,
                                NULL,
                                (PBYTE) &dwFirmwareIdentified,
                                &dwSize) == ERROR_SUCCESS) {

                //
                // ACPI puts the value "FirmwareIdentified" if it has enumerated
                // this port.  We only rely on this if a DDN isn't present and we
                // couldn't get the enumerator name
                //
                firmwarePort = TRUE;
            }

            ZeroMemory(charBuffer, sizeof(charBuffer));
        }

        RegCloseKey(hKey);
    }

    if (firmwarePort) {
        //
        // Try to find "COM" in the name.  If it is found, simply extract
        // the number that follows it and use that as the com number.
        //
        // Otherwise:
        // 1) try to determine the number of the com port based on its
        //    IO range, otherwise
        // 2) look through the com db and try to find an unused port from
        //    1 to 4, if none are present then let the DB pick the next open
        //    port number
        //
        if (comPort[0] != (TCHAR) 0) {
            _wcsupr(comPort);
            comLocation = wcsstr(comPort, m_szCOM);
            if (comLocation) {
                comPortNumber = myatoi(comLocation + wcslen(m_szCOM));
            }
        }

        if (comPortNumber == NO_COM_NUMBER &&
            !DetermineComNumberFromResources((DEVINST) DeviceInfoData->DevInst,
                                             &comPortNumber) &&
            (hComDB != HCOMDB_INVALID_HANDLE_VALUE) &&
            (ComDBGetCurrentPortUsage(hComDB,
                                      portUsage,
                                      MAX_COM_PORT / 8,
                                      CDB_REPORT_BITS,
                                      &portsReported) == ERROR_SUCCESS)) {
            if (!(portUsage[0] & 0x1)) {
                comPortNumber = 1;
            }
            else if (!(portUsage[0] & 0x2)) {
                comPortNumber = 2;
            }
            else if (!(portUsage[0] & 0x4)) {
                comPortNumber = 3;
            }
            else if (!(portUsage[0] & 0x8)) {
                comPortNumber = 4;
            }
            else {
                comPortNumber = NO_COM_NUMBER;
            }
        }
    }

    if (comPortNumber == NO_COM_NUMBER) {
        if (hComDB == HCOMDB_INVALID_HANDLE_VALUE) {
            //
            // Couldn't open the DB, pick a com port number that doesn't conflict
            // with any firmware ports
            //
            comPortNumber = DEF_MIN_COM_NUM;
        }
        else {
            //
            // Let the db find the next number
            //
            ComDBClaimNextFreePort(hComDB,
                                   &comPortNumber);
        }
    }
    else {
        //
        // We have been told what number to use, claim it irregardless of what
        // has already been claimed
        //
        ComDBClaimPort(hComDB,
                       comPortNumber,
                       TRUE,
                       NULL);
    }

    if (hComDB != HCOMDB_INVALID_HANDLE_VALUE) {
        ComDBClose(hComDB);
    }

    //
    // Generate the serial and COM port names based on the numbers we picked.
    //
    wsprintf(szPortName, TEXT("%s%d"), m_szCOM, comPortNumber);

    //
    // Write out Device Parameters\PortName and PollingPeriod
    //
    if((hKey = SetupDiCreateDevRegKey(DeviceInfoSet,
                                      DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      NULL,
                                      NULL)) != INVALID_HANDLE_VALUE) {
        DWORD PollingPeriod = PollingPeriods[POLL_PERIOD_DEFAULT_IDX];

        //
        // A failure is not catastrophic, serial will just not know what to call
        // the port
        //
        RegSetValueEx(hKey,
                      m_szPortName,
                      0,
                      REG_SZ,
                      (PBYTE) szPortName,
                      ByteCountOf(lstrlen(szPortName) + 1)
                      );

        RegSetValueEx(hKey,
                      m_szPollingPeriod,
                      0,
                      REG_DWORD,
                      (PBYTE) &PollingPeriod,
                      sizeof(DWORD)
                      );

        RegCloseKey(hKey);
    }

    //
    // Now do the installation for this device.
    //
    if(!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData)) {
        return GetLastError();
    }

    //
    // Write out the friendly name based on the device desc
    //
    if (LoadString(g_hInst,
                   IDS_FRIENDLY_FORMAT,
                   friendlyNameFormat,
                   CharSizeOf(friendlyNameFormat)) &&
        SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         NULL,
                                         (PBYTE)deviceDesc,
                                         sizeof(deviceDesc),
                                         NULL)) {
        wsprintf(charBuffer, friendlyNameFormat, deviceDesc, szPortName);
    }
    else {
        lstrcpy(charBuffer, szPortName);
    }

    // Write the string friendly name string out
    SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                     DeviceInfoData,
                                     SPDRP_FRIENDLYNAME,
                                     (PBYTE)charBuffer,
                                     ByteCountOf(lstrlen(charBuffer) + 1)
                                     );

    //
    // Write out the default settings to win.ini (really a registry key) if they
    // don't already exist.
    //
    wcscat(szPortName, m_szColon);
    charBuffer[0] = TEXT('\0');
    GetProfileString(m_szPorts,
                     szPortName,
                     TEXT(""),
                     charBuffer,
                     sizeof(charBuffer) / sizeof(TCHAR) );
    //
    // Check to see if the default string provided was copied in, if so, write
    // out the port defaults
    //
    if (charBuffer[0] == TEXT('\0')) {
        WriteProfileString(m_szPorts, szPortName, m_szDefParams);
    }

    return NO_ERROR;
}

// @@BEGIN_DDKSPLIT
BOOL
GetSerialPortDevInstConfig(
    IN  DEVINST            DevInst,
    IN  ULONG              LogConfigType,
    OUT PIO_RESOURCE       IoResource,             OPTIONAL
    OUT PIRQ_RESOURCE      IrqResource             OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the base IO port and IRQ for the specified device instance
    in a particular logconfig.

Arguments:

    DevInst - Supplies the handle of a device instance to retrieve configuration for.

    LogConfigType - Specifies the type of logconfig to retrieve.  Must be either
        ALLOC_LOG_CONF, BOOT_LOG_CONF, or FORCED_LOG_CONF.

    IoResource - Optionally, supplies the address of an Io resource structure
        that receives the Io resource retreived.

    IrqResource - Optionally, supplies the address of an IRQ resource variable
        that receives the IRQ resource retrieved.

    AdditionalResources - Optionally, supplies the address of a CM_RESOURCE_LIST pointer.
        If this parameter is specified, then this pointer will be filled in with the
        address of a newly-allocated buffer containing any additional resources contained
        in this logconfig.  If there are no additional resources (which will typically be
        the case), then this pointer will be set to NULL.

        The caller is responsible for freeing this buffer.

    AdditionalResourcesSize - Optionally, supplies the address of a variable that receives
        the size, in bytes, of the buffer allocated and returned in the AdditionalResources
        parameter.  If that parameter is not specified, then this parameter is ignored.

Return Value:

    If success, the return value is TRUE, otherwise it is FALSE.

--*/
{
    LOG_CONF LogConfig;
    RES_DES ResDes;
    CONFIGRET cr;
    BOOL Success;
    PBYTE ResDesBuffer = NULL;
    ULONG ResDesBufferSize = 68; // big enough for everything but class-specific resource.

    if(CM_Get_First_Log_Conf(&LogConfig, DevInst, LogConfigType) != CR_SUCCESS) {
        return FALSE;
    }

    Success = FALSE;    // assume failure.

    //
    // First, get the Io base port
    //
    if(IoResource) {

        if(CM_Get_Next_Res_Des(&ResDes, LogConfig, ResType_IO, NULL, 0) != CR_SUCCESS) {
            goto clean0;
        }

        cr = CM_Get_Res_Des_Data(ResDes, IoResource, sizeof(IO_RESOURCE), 0);

        CM_Free_Res_Des_Handle(ResDes);

        if(cr != CR_SUCCESS) {
            goto clean0;
        }
    }

    //
    // Now, get the IRQ
    //
    if(IrqResource) {

        if(CM_Get_Next_Res_Des(&ResDes, LogConfig, ResType_IRQ, NULL, 0) != CR_SUCCESS) {
            goto clean0;
        }

        cr = CM_Get_Res_Des_Data(ResDes, IrqResource, sizeof(IRQ_RESOURCE), 0);

        CM_Free_Res_Des_Handle(ResDes);

        if(cr != CR_SUCCESS) {
            goto clean0;
        }
    }

    Success = TRUE;

clean0:
    CM_Free_Log_Conf_Handle(LogConfig);

    if(ResDesBuffer) {
        LocalFree(ResDesBuffer);
    }

    return Success;
}
// @@END_DDKSPLIT

void InitStrings(void)
{
    DWORD  dwClass, dwShare;
    TCHAR  szClass[ 40 ];

    LoadString(g_hInst,
               INITS,
               g_szErrMem,
               CharSizeOf(g_szErrMem));
    LoadString(g_hInst,
               IDS_INIT_NAME,
               g_szPortsApplet,
               CharSizeOf(g_szPortsApplet));

    //
    //  Get the "Close" string
    //
    LoadString(g_hInst,
               IDS_INIT_CLOSE,
               g_szClose,
               CharSizeOf(g_szClose));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\pp.h ===
#ifndef PP_H
#define PP_H

#define SERIAL_ADVANCED_SETTINGS
#include "msports.h"

#ifdef USE_P_TRACE_ERR
#define P_TRACE_ERR(_x) MessageBox( GetFocus(), TEXT(_x), TEXT("ports traceerr"), MB_OK | MB_ICONINFORMATION );
#define W_TRACE_ERR(_x) MessageBox( GetFocus(), _x, TEXT("ports traceerr"), MB_OK | MB_ICONINFORMATION );
#else
#define P_TRACE_ERR(_x)
#define W_TRACE_ERR(_x)
#endif

#define DO_COM_PORT_RENAMES

#define RX_MIN 1
#define RX_MAX 14
#define TX_MIN 1
#define TX_MAX 16

TCHAR m_szDevMgrHelp[];

//
// Structures
//
typedef struct
{
   DWORD BaudRate;       // actual baud rate
   DWORD Parity;         // index into dlg selection
   DWORD DataBits;       // index into dlg selection
   DWORD StopBits;       // index into dlg selection
   DWORD FlowControl;    // index into dlg selection
   TCHAR szComName[20];  // example: "COM5"  (no colon)
} PP_PORTSETTINGS, *PPP_PORTSETTINGS;

typedef struct _ADVANCED_DATA
{
    BOOL   HidePolling;
    BOOL   UseFifoBuffersControl;
    BOOL   UseFifoBuffers;
    BOOL   UseRxFIFOControl;
    BOOL   UseTxFIFOControl;
    DWORD  FifoRxMax;
    DWORD  FifoTxMax;
    DWORD  RxFIFO;
    DWORD  TxFIFO;
    DWORD  PollingPeriod;

    TCHAR  szComName[20];
    TCHAR  szNewComName[20];

    HKEY             hDeviceKey;         // (like ROOT\LEGACY_BEEP\0000)
    HCOMDB           hComDB;

    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;

} ADVANCED_DATA, *PADVANCED_DATA;

typedef struct _PORT_PARAMS
{
   PP_PORTSETTINGS              PortSettings;
   HDEVINFO                     DeviceInfoSet;
   PSP_DEVINFO_DATA             DeviceInfoData;
   BOOL                         ShowAdvanced;
   BOOL                         AdvancedChanged;
   BOOL                         ChangesEnabled;
   PADVANCED_DATA               pAdvancedData;
} PORT_PARAMS, *PPORT_PARAMS;


///////////////////////////////////////////////////////////////////////////////////
// Port Settings Property Page Prototypes
///////////////////////////////////////////////////////////////////////////////////

void
InitOurPropParams(
    IN OUT PPORT_PARAMS     Params,
    IN HDEVINFO             DeviceInfoSet,
    IN PSP_DEVINFO_DATA     DeviceInfoData,
    IN PTCHAR               StrSettings
    );

HPROPSHEETPAGE
InitSettingsPage(
    PROPSHEETPAGE *      Psp,
    OUT PPORT_PARAMS    Params
    );

UINT CALLBACK
PortSettingsDlgCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    );

INT_PTR APIENTRY
PortSettingsDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

void
SavePortSettings(
    IN HWND             DialogHwnd,
    IN PTCHAR           ComName,
    IN PPORT_PARAMS     Params
    );

void
GetPortSettings(
    IN HWND             DialogHwnd,
    IN PTCHAR           ComName,
    IN PPORT_PARAMS     Params
    );

VOID
SetCBFromRes(
    HWND  HwndCB, 
    DWORD ResId, 
    DWORD Default,
    BOOL  CheckDecimal);

BOOL
FillCommDlg(
    IN HWND DialogHwnd
    );

ULONG
FillPortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    );

ULONG
SavePortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    );

ULONG
FillPortNameCb(
    HWND           ParentHwnd,
    PADVANCED_DATA Params
    );

///////////////////////////////////////////////////////////////////////////////////
// Advanced Dialog Prototypes
///////////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY
AdvancedPortsDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

ULONG
FillAdvancedDlg(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

ULONG
SaveAdvancedDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
);

BOOL
DisplayAdvancedDialog(
    IN     HWND             DialogHwnd,
    IN OUT PADVANCED_DATA   AdvancedData
);

void
InitializeControls(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

void
RestoreAdvancedDefaultState(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

ULONG
SaveAdvancedSettings(
    IN HWND             DialogHwnd,
    IN PADVANCED_DATA   AdvancedData
    );

void
RestorePortSettings(
    HWND                DialogHwnd,
    PPORT_PARAMS        Params
);

void
SetTrackbarTicks(
    IN HWND   TrackbarHwnd,
    IN DWORD  MinVal,
    IN DWORD  MaxVal
    );

void
SetLabelText(
    IN HWND  LabelHwnd, 
    IN DWORD ResId,
    IN ULONG Value
    );

void
HandleTrackbarChange(
    IN HWND DialogHwnd, 
    IN HWND TrackbarHwnd
    );

void
EnableFifoControls(
    HWND DialogHwnd,
    BOOL Enabled
    );

// Context help header file and arrays for devmgr ports tab
// Created 2/21/98 by WGruber NTUA and DoronH NTDEV

//
// "Port Settings" Dialog Box
//

#define IDH_NOHELP      ((DWORD)-1)

#define IDH_DEVMGR_PORTSET_ADVANCED     15840   // "&Advanced" (Button)
#define IDH_DEVMGR_PORTSET_BPS      15841       // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DATABITS     15842   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_PARITY       15843   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_STOPBITS     15844   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_FLOW     15845       // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DEFAULTS     15892   // "&Restore Defaults" (Button)

//
// "Advanced Communications Port Properties" Dialog Box
//
#define IDH_DEVMGR_PORTSET_ADV_USEFIFO  16885   // "&Use FIFO buffers (requires 16550 compatible UART)" (Button)
#define IDH_DEVMGR_PORTSET_ADV_TRANS    16842   // "" (msctls_trackbar32)
#define IDH_DEVMGR_PORTSET_ADV_DEVICES  161027  // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_RECV         16821       // "" (msctls_trackbar32)
#define IDH_DEVMGR_PORTSET_ADV_NUMBER   16846   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_DEFAULTS 16844

#endif // PP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\ports.h ===
/** FILE: ports.h ********* Module Header ********************************
 *
 *  Control Panel System applet common definitions, resource ids, typedefs,
 *  external declarations and library routine function prototypes.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  22:00 on Wed   17 Nov 1993  -by-  Steve Cathcart   [stevecat]
 *        Changes for product update
 *  17:00 on Mon   18 Sep 1995  -by-  Steve Cathcart   [stevecat]
 *        Changes for product update - SUR release NT v4.0
 *
 *
 *  Copyright (C) 1990-1995 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                            Include Files
//==========================================================================

#ifndef PORTS_H
#define PORTS_H

#include <windows.h>
#include <tchar.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
// @@BEGIN_DDKSPLIT
#include <infstr.h>
// @@END_DDKSPLIT
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include "resource.h"

#include "portstr.h"

#define PORTS        4
#define MAXPORTS    32
#define KEYBZ       4096
#define BUFFER_SIZE 81

#define DEF_BAUD    3       //  1200
#define DEF_WORD    4       //  8 bits
#define DEF_PARITY  2       //  None
#define DEF_STOP    0       //  1
#define DEF_PORT    0       //  Null Port
#define DEF_SHAKE   2       //  None
#define PAR_EVEN    0
#define PAR_ODD     1
#define PAR_NONE    2
#define PAR_MARK    3
#define PAR_SPACE   4
#define STOP_1      0
#define STOP_15     1
#define STOP_2      2
#define FLOW_XON    0
#define FLOW_HARD   1
#define FLOW_NONE   2

#define MAX_COM_PORT  COMDB_MIN_PORTS_ARBITRATED   // Maximum number of COM ports NT supports
#define MIN_COM       1                            // Minimum new COM port number

#define POLL_PERIOD_DEFAULT_IDX 1 

//==========================================================================
//                        Definitions
//==========================================================================

//
//  General definitions
//

#define PATHMAX             MAX_PATH


//
//  Help IDs -- for the Ports applet
//
//
#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + 4 /* CHILD_PORTS */ )
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)

//==========================================================================
//                           Typedefs
//==========================================================================

typedef struct {
    SP_DEVINFO_DATA  DeviceInfoData;

    TCHAR ComName[20];
    TCHAR Settings[20];
    
    ULONG BaseAddress;
} PORT_INFO, *PPORT_INFO;

typedef struct _PORTS_WIZARD_DATA {

    HDEVINFO          DeviceInfoSet;
    PSP_DEVINFO_DATA  pDeviceInfoData;

    ULONG BaseAddress;
    ULONG FirstComNumber;

    ULONG PortsCount;
    PPORT_INFO Ports;

    PUINT UsedComNumbers;
    UINT UsedComNumbersCount;

    BOOL IsMulti;
} PORTS_WIZARD_DATA, *PPORTS_WIZARD_DATA;



//==========================================================================
//                              Macros
//==========================================================================

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))


//==========================================================================
//                         External Declarations
//==========================================================================
//
//  DATA


//
//  exported from cpl.c
//

extern HANDLE g_hInst;
extern TCHAR  g_szClose[ ];         //  "Close" string
extern TCHAR  g_szErrMem[ ];        //  Low memory message
extern TCHAR  g_szPortsApplet[ ];   //  "Ports Control Panel Applet" title
extern TCHAR  g_szNull[];           //  Null string

extern DWORD PollingPeriods[];

extern TCHAR  m_szRegParallelMap[];
extern TCHAR  m_szLPT[];
extern TCHAR  m_szPorts[];
extern TCHAR  m_szPortName[];

//==========================================================================
//                            Function Prototypes
//==========================================================================

//
//  ports.c
//
extern 
VOID
InitStrings(void);

typedef enum {
    PortTypeParallel,
    PortTypeSerial,
    PortTypeOther
} PortType;

extern
BOOL
GetPortType(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN          DoDrvKeyInstall
    );

BOOL
CALLBACK
AddPropSheetPageProc(
    IN HPROPSHEETPAGE hpage,
    IN LPARAM lParam
   );

void EditResources(IN HWND              hDlg,
                   IN HDEVINFO          DeviceInfoSet,
                   IN PSP_DEVINFO_DATA  DeviceInfoData,
                   IN PTCHAR            strTitle,
                   IN PTCHAR            strSettings);

//
//  util.c
//

extern 
LPTSTR 
BackslashTerm(LPTSTR pszPath);

extern 
VOID 
ErrMemDlg(HWND hParent);

extern 
int    
MyAtoi(LPTSTR  string);

extern 
int    
myatoi(LPTSTR pszInt);

extern 
int    
MyMessageBox(HWND hWnd, 
                         DWORD wText, 
                         DWORD wCaption, 
                         DWORD wType, 
                         ...);

extern 
LPTSTR 
MyItoa(INT value, 
           LPTSTR  string, 
           INT  radix);

extern 
LPTSTR 
MyUltoa(unsigned long  value, 
                LPTSTR  string, 
                INT  radix);

extern 
VOID   
SendWinIniChange(LPTSTR szSection);

extern 
LPTSTR 
strscan(LPTSTR pszString, 
                LPTSTR pszTarget);

extern 
VOID
StripBlanks(LPTSTR pszString);

#endif // PORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\pp_lpt.c ===
/** FILE: pp_lpt.c ********** Module Header *******************************
 *
 *  Control panel applet for configuring LPT ports.  This file contains
 *  the dialog and utility functions for managing the UI for setting LPT
 *  port parameters
 *
 @@BEGIN_DDKSPLIT
 * History:
 *      jsenior - 7/10/98 - created
 @@END_DDKSPLIT
 *
 *  Copyright (C) 1990-1995 Microsoft Corporation
 *
 *************************************************************************/

//==========================================================================
//                                Include files
//==========================================================================
#include "ports.h"
#include "pp_lpt.h"
#include <windowsx.h>

TCHAR m_szFilterResourceMethod[]    = TEXT("FilterResourceMethod");
TCHAR m_szParEnableLegacyZip[]      = TEXT("ParEnableLegacyZip");
TCHAR m_szParEnableLegacyZipRegPath[] = TEXT("SYSTEM\\CurrentControlSet\\Services\\Parport\\Parameters");

const DWORD LptHelpIDs[]=
{
    IDC_STATIC, IDH_NOHELP, //Filter resource method text - help not needed
    IDC_FILTERMETHOD_TRYNOT,    idh_devmgr_portset_trynot,  //first radio button
    IDC_FILTERMETHOD_NEVER, idh_devmgr_portset_never,   //second radio button
    IDC_FILTERMETHOD_ACCEPTANY, idh_devmgr_portset_acceptany,   //third radio button
    IDC_LPTNUMTEXT, idh_devmgr_portset_portnum, //Port number text
    PP_LPT_PORT_NUMBER, idh_devmgr_portset_LPTchoice,   //the list box for port number
    IDC_LPT_ENABLE_LEGACY, idh_devmgr_enable_legacy,    //Enable legacy detection checkbox
    0, 0
};

#define NUM_FILTER_RESOURCE_METHODS 3
DWORD FilterResourceMethods[NUM_FILTER_RESOURCE_METHODS] = {
            0,  // Try not to use an interrupt
            1,  // Never use an interrupt
            2   // Accept any interrupt given to the port
            };

// C Runtime
// @@BEGIN_DDKSPLIT
//
// Prototype for IsUserAdmin (in pp.c)
//
BOOL
IsUserAdmin(VOID);
// @@END_DDKSPLIT

void
InformDriverOfChanges(BOOL NeedReboot,
                      IN PLPT_PROP_PARAMS LptPropParams);

void
LptPortOnHelp(HWND       ParentHwnd,
              LPHELPINFO HelpInfo);

BOOL
LptPortOnContextMenu(HWND HwndControl,
                     WORD Xpos,
                     WORD Ypos);

BOOL
LptPortOnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam);

ULONG
LptFillPortSettings(
    IN HWND                 ParentHwnd,
    IN PLPT_PROP_PARAMS     LptPropPageData);

ULONG
LptFillPortNameCb(
    HWND                ParentHwnd,
    PLPT_PROP_PARAMS    LptPropPageData);

void LptInitializeControls(
    IN HWND           ParentHwnd,
    IN PLPT_PROP_PARAMS LptPropPageData);

ULONG
LptSetFilterResourceMethod(
    HWND                ParentHwnd,
    PLPT_PROP_PARAMS    LptPropPageData);

ULONG
LptSavePortSettings(
    IN HWND             ParentHwnd,
    IN PLPT_PROP_PARAMS LptPropParams);

BOOL
LptPortOnNotify(
    HWND    ParentHwnd,
    LPNMHDR NmHdr);

void
LptPortOnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode);

UINT
LptEnactPortNameChanges(
    IN HWND             ParentHwnd,
    IN PLPT_PROP_PARAMS LptPropParams,
    IN HKEY             hDeviceKey,
    IN UINT             NewLptNum);

void
LptEnumerateUsedPorts(
    IN HWND             ParentHwnd,
    IN PBYTE            Buffer,
    IN DWORD            BufferSize);

void
LptInitPropParams(IN OUT PLPT_PROP_PARAMS  Params,
                  IN HDEVINFO              DeviceInfoSet,
                  IN PSP_DEVINFO_DATA      DeviceInfoData);

HPROPSHEETPAGE
LptInitSettingsPage(PROPSHEETPAGE *      psp,
                    OUT PLPT_PROP_PARAMS Params);

INT_PTR
APIENTRY
LptPortSettingsDlgProc(IN HWND   hDlg,
                       IN UINT   uMessage,
                       IN WPARAM wParam,
                       IN LPARAM lParam);

UINT
CALLBACK
LptPortSettingsDlgCallback(HWND hwnd,
                           UINT uMsg,
                           LPPROPSHEETPAGE ppsp);

/*++

Routine Description: ParallelPortPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="msports.dll,thisproc"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL
APIENTRY
ParallelPortPropPageProvider(LPVOID                 Info,
                             LPFNADDPROPSHEETPAGE   AddFunc,
                             LPARAM                 Lparam)
{
   PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
   PROPSHEETPAGE             psp;
   HPROPSHEETPAGE            hpsp;
   PLPT_PROP_PARAMS          params = NULL;

   pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

   // @@BEGIN_DDKSPLIT
   //
   // Only administrators are allowed to see this page
   //
   if (!IsUserAdmin()) {
       return FALSE;
   }
   // @@END_DDKSPLIT

   //
   // Allocate and zero out memory for the struct that will contain
   // page specific data
   //
   params = (PLPT_PROP_PARAMS) LocalAlloc(LPTR, sizeof(LPT_PROP_PARAMS));

   if (!params) {
       ErrMemDlg(GetFocus());
       return FALSE;
   }

   if (pprPropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {
        LptInitPropParams(params,
                          pprPropPageRequest->DeviceInfoSet,
                          pprPropPageRequest->DeviceInfoData);

        hpsp = LptInitSettingsPage(&psp, params);

        if (!hpsp) {
            return FALSE;
        }

        if (!(*AddFunc)(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
} // ParallelPortPropPageProvider

/*++

Routine Description: LptPortSettingsDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR
APIENTRY
LptPortSettingsDlgProc(IN HWND   hDlg,
                       IN UINT   uMessage,
                       IN WPARAM wParam,
                       IN LPARAM lParam)
{
    switch(uMessage) {
    case WM_COMMAND:
        LptPortOnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CONTEXTMENU:
        return LptPortOnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        LptPortOnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_INITDIALOG:
        return LptPortOnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return LptPortOnNotify(hDlg, (NMHDR *)lParam);

    }

    return FALSE;
} // PortSettingsDialogProc

void
LptInitPropParams(IN OUT PLPT_PROP_PARAMS  Params,
                  IN HDEVINFO              DeviceInfoSet,
                  IN PSP_DEVINFO_DATA      DeviceInfoData)
{
    BOOL                        bResult;
    DWORD                       requiredSize = 0;
    SP_DEVINFO_LIST_DETAIL_DATA detailData;

    ZeroMemory(Params, sizeof(LPT_PROP_PARAMS));

    Params->DeviceInfoSet = DeviceInfoSet;
    Params->DeviceInfoData = DeviceInfoData;
    Params->ChangesEnabled = TRUE;

    //
    // Get the device ID first: if the device path is larger then
    // MAX_PATH, we will try again with a bigger buffer
    //
    bResult = SetupDiGetDeviceInstanceId(DeviceInfoSet,
                                         DeviceInfoData,
                                         NULL,
                                         MAX_PATH,
                                         &requiredSize);

    //
    // See if we are being invoked locally or over the network.  If over the net,
    // then disable all possible changes.
    //
    detailData.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &detailData) &&
        detailData.RemoteMachineHandle != NULL) {
        Params->ChangesEnabled = FALSE;
    }

} // LptInitPropParams

HPROPSHEETPAGE LptInitSettingsPage(PROPSHEETPAGE *      psp,
                                   OUT PLPT_PROP_PARAMS Params)
{
    //
    // Add the Port Settings property page
    //
    psp->dwSize      = sizeof(PROPSHEETPAGE);
    psp->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp->hInstance   = g_hInst;
    psp->pszTemplate = MAKEINTRESOURCE(DLG_PP_LPT_PORTSETTINGS);

    //
    // following points to the dlg window proc
    //
    psp->pfnDlgProc = LptPortSettingsDlgProc;
    psp->lParam     = (LPARAM) Params;

    //
    // following points to some control callback of the dlg window proc
    //
    psp->pfnCallback = LptPortSettingsDlgCallback;

    //
    // allocate our "Ports Setting" sheet
    //
    return CreatePropertySheetPage(psp);
}


UINT
CALLBACK
LptPortSettingsDlgCallback(HWND hwnd,
                           UINT uMsg,
                           LPPROPSHEETPAGE ppsp)
{
    PLPT_PROP_PARAMS params;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        params = (PLPT_PROP_PARAMS) ppsp->lParam;
        LocalFree(params);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

BOOL
LptPortOnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PLPT_PROP_PARAMS lptPropParams;
    lptPropParams = (PLPT_PROP_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    //
    // Save value away
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) lptPropParams);

    //
    // Initialize the dialog box parameters
    //
    LptFillPortSettings(ParentHwnd, lptPropParams);

    //
    // Set up the dialog box with these initialized parameters
    //
    LptInitializeControls(ParentHwnd, lptPropParams);

    return TRUE;
}

/*++

Routine Description: LptFillPortSettings

    Gets the settings out of the registry ready for initializing the dialog box
    with.

Arguments:

    LptPropPageData:        the data to fill in
    ParentHwnd:             address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
LptFillPortSettings(
    IN HWND                 ParentHwnd,
    IN PLPT_PROP_PARAMS     LptPropPageData
    )
{
    HKEY  hKey;
    DWORD dwPortNameSize, dwError;
    TCHAR szCharBuffer[81];
    DWORD dwSize, dwData, dwMethod;

    //
    // Open the device key for the source device instance, and retrieve its
    // "PortName" value.
    //
    hKey = SetupDiOpenDevRegKey(LptPropPageData->DeviceInfoSet,
                                      LptPropPageData->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_ALL_ACCESS);

    if (INVALID_HANDLE_VALUE == hKey) {
        return GetLastError();
    }

    dwPortNameSize = sizeof(LptPropPageData->szLptName);
    dwError = RegQueryValueEx(hKey,
                              m_szPortName,  // "PortName"
                              NULL,
                              NULL,
                              (PBYTE)LptPropPageData->szLptName,
                              &dwPortNameSize);

    if(ERROR_SUCCESS != dwError) {
        RegCloseKey(hKey);
        return dwError;
    }

    //
    // create "lpt#:"
    //
    lstrcpy(szCharBuffer, LptPropPageData->szLptName);
    lstrcat(szCharBuffer, m_szColon);

    dwSize = sizeof(LptPropPageData->FilterResourceMethod);
    dwError = RegQueryValueEx(hKey,
                             m_szFilterResourceMethod,
                             NULL,
                             NULL,
                             (LPBYTE)(&LptPropPageData->FilterResourceMethod),
                             &dwSize);

    if (dwError != ERROR_SUCCESS) {
        //
        // value does not exist. Create our own:
        // Get Filter Resource Method information
        //
        LptPropPageData->FilterResourceMethod =
            FilterResourceMethods[RESOURCE_METHOD_DEFAULT_IDX];

        dwError = RegSetValueEx(hKey,
                              m_szFilterResourceMethod,
                              0,
                              REG_DWORD,
                              (LPBYTE)(&LptPropPageData->FilterResourceMethod),
                              sizeof(LptPropPageData->FilterResourceMethod));
    }
    RegCloseKey(hKey);

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           m_szParEnableLegacyZipRegPath,
                           0,
                           KEY_ALL_ACCESS,
                           &hKey);
    if (dwError != ERROR_SUCCESS) {
        //
        // Don't have access maybe?
        //
        LptPropPageData->ParEnableLegacyZip = ENABLELEGACYZIPDEFAULT;
        return dwError;
    }
    dwSize = sizeof(LptPropPageData->ParEnableLegacyZip);
    dwError = RegQueryValueEx(hKey,
                              TEXT("ParEnableLegacyZip"),
                              NULL,
                              NULL,
                              (LPBYTE)(&LptPropPageData->ParEnableLegacyZip),
                              &dwSize);
    if (dwError != ERROR_SUCCESS) {
        //
        // value does not exist. Create our own
        //
        LptPropPageData->ParEnableLegacyZip = ENABLELEGACYZIPDEFAULT;
        dwError = RegSetValueEx(hKey,
                                m_szParEnableLegacyZip,
                                0,
                                REG_DWORD,
                                (LPBYTE)(&LptPropPageData->ParEnableLegacyZip),
                                sizeof(LptPropPageData->ParEnableLegacyZip));
    }
    RegCloseKey(hKey);

    return dwError;
} // LptFillPortSettings


/*++

Routine Description: LptInitializeControls

    Initializes all of the controls that represent Fifo

Arguments:

    ParentHwnd - handle to the dialog
    LptPropPageData - Contains all of the initial values

Return Value:

    None

--*/
void LptInitializeControls(
    IN HWND           ParentHwnd,
    IN PLPT_PROP_PARAMS LptPropPageData
    )
{
    TCHAR    szCurrentValue[40];
    HWND     hwnd;
    int      i, periodIdx;

    LptFillPortNameCb(ParentHwnd, LptPropPageData);

    LptSetFilterResourceMethod(ParentHwnd, LptPropPageData);

    //
    // Set the state of the Enable Legacy Detection checkbox
    //
    if (LptPropPageData->ParEnableLegacyZip) {
        CheckDlgButton(ParentHwnd,
                       IDC_LPT_ENABLE_LEGACY,
                       BST_CHECKED);
    } else {
        CheckDlgButton(ParentHwnd,
                       IDC_LPT_ENABLE_LEGACY,
                       BST_UNCHECKED);
    }

    if (!LptPropPageData->ChangesEnabled) {
//        EnableWindow(GetDlgItem(ParentHwnd, IDC_FIFO), FALSE);

    }
} // LptInitializeControls

/*++

Routine Description: LptSetFilterResourceMethod

    Checks the appropriate resource method to use

Arguments:

    LptPropPageData:    where to get the data from
    ParentHwnd:         address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
LptSetFilterResourceMethod(
    HWND                ParentHwnd,
    PLPT_PROP_PARAMS    LptPropPageData
    )
{
    switch (LptPropPageData->FilterResourceMethod) {
    case FILTERMETHOD_TRYNOT:
        CheckRadioButton( ParentHwnd, // handle to dialog box
                          IDC_FILTERMETHOD_TRYNOT, // first button in group
                          IDC_FILTERMETHOD_ACCEPTANY, // last button in group
                          IDC_FILTERMETHOD_TRYNOT // selected
                          );
        break;
    case FILTERMETHOD_ACCEPTANY:
        CheckRadioButton( ParentHwnd, // handle to dialog box
                          IDC_FILTERMETHOD_TRYNOT, // first button in group
                          IDC_FILTERMETHOD_ACCEPTANY, // last button in group
                          IDC_FILTERMETHOD_ACCEPTANY // selected
                          );
        break;
    case FILTERMETHOD_NEVER:
        CheckRadioButton( ParentHwnd, // handle to dialog box
                          IDC_FILTERMETHOD_TRYNOT, // first button in group
                          IDC_FILTERMETHOD_ACCEPTANY, // last button in group
                          IDC_FILTERMETHOD_NEVER // selected
                          );
        break;
    default:
        CheckRadioButton( ParentHwnd, // handle to dialog box
                          IDC_FILTERMETHOD_TRYNOT, // first button in group
                          IDC_FILTERMETHOD_ACCEPTANY, // last button in group
                          IDC_FILTERMETHOD_NEVER // selected
                          );
        break;
    }
    return 0;
}

/*++

Routine Description: LptFillPortNameCb

    fill in the Port Name combo box selection with a list
    of possible un-used portnames

Arguments:

    LptPropPageData:    where to get the data from
    hDlg:               address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
LptFillPortNameCb(
    HWND                ParentHwnd,
    PLPT_PROP_PARAMS    LptPropPageData
    )
{
    BYTE  portUsage[MAX_LPT_PORT];
    DWORD tmp, portsReported;
    int   i, nEntries;
    int   nCurPortNum;
    TCHAR szLpt[40];
    TCHAR szInUse[40];
    HWND  portHwnd;

    portHwnd = GetDlgItem(ParentHwnd, PP_LPT_PORT_NUMBER);

    //
    // Check if our LptName is blank. If it is, disable the lpt port selector
    //
    if (_tcscmp(LptPropPageData->szLptName, TEXT("")) == 0) {
        EnableWindow(portHwnd, FALSE);
        EnableWindow(GetDlgItem(ParentHwnd, IDC_LPTNUMTEXT), FALSE);
        return 0;
    }

    //
    // assumes szLptPort filled in...
    //
    nCurPortNum = myatoi(&LptPropPageData->szLptName[3]);

    if (!LoadString(g_hInst, IDS_IN_USE, szInUse, CharSizeOf(szInUse))) {
        wcscpy(szInUse, _T(" (in use)"));
    }

    //
    // first tally up which ports NOT to offer in list box
    //
    ZeroMemory(portUsage, MAX_LPT_PORT);

    // Find out which ports not to offer
    LptEnumerateUsedPorts(ParentHwnd,
                          portUsage,
                          MAX_LPT_PORT);

    for(i = MIN_LPT-1; i < MAX_LPT_PORT; i++) {

       wsprintf(szLpt, TEXT("LPT%d"), i+1);
       if (portUsage[i] &&
           _tcscmp(szLpt, LptPropPageData->szLptName)) {
           wcscat(szLpt, szInUse);
       }

       ComboBox_AddString(portHwnd, szLpt);
   }

   ComboBox_SetCurSel(portHwnd, nCurPortNum-1);
   return 0;
} // FillPortNamesCb

void
LptPortOnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PLPT_PROP_PARAMS params =
        (PLPT_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
    }
    else {
        switch (ControlId) {
        //
        // Because this is a prop sheet, we should never get this.
        // All notifications for ctrols outside of the sheet come through
        // WM_NOTIFY
        //
        case IDOK:
        case IDCANCEL:
            EndDialog(ParentHwnd, 0);
            return;
        }
    }
} // LptPortOnCommand

BOOL
LptPortOnNotify(
    HWND    ParentHwnd,
    LPNMHDR NmHdr
    )
{
    PLPT_PROP_PARAMS params =
        (PLPT_PROP_PARAMS) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (NmHdr->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Write out the lpt port options to the registry
        //
        LptSavePortSettings(ParentHwnd, params);
        SetWindowLongPtr(ParentHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

    default:
        return FALSE;
    }
} // LptPortOnNotify

/*++

Routine Description: LptSavePortSettings

    saves the advanced box settings back to the registry, if any were
    changed

Arguments:

    AdvancedData: holds the current settings and the location of of
                   the device in the registry
    ParentHwnd:          address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
LptSavePortSettings(
    IN HWND ParentHwnd,
    IN PLPT_PROP_PARAMS LptPropParams
    )
{
    HKEY   hKey;
    DWORD  dwSize, dwData;

    UINT  i = CB_ERR, curLptNum, newLptNum = CB_ERR;
    UINT  uiTryNotChecked, uiNeverChecked, uiAcceptAnyChecked;
    DWORD curFilterResourceMethod;
    DWORD newFilterResourceMethod = 0;
    DWORD curParEnableLegacyZip, newParEnableLegacyZip;
    ULONG error = ERROR_SUCCESS;

    SP_DEVINSTALL_PARAMS spDevInstall;

    //
    // Grab all of the new settings
    //

    // Filter resource method
    curFilterResourceMethod = newFilterResourceMethod = LptPropParams->FilterResourceMethod;
    if (BST_CHECKED ==
        IsDlgButtonChecked(ParentHwnd, IDC_FILTERMETHOD_TRYNOT))
        newFilterResourceMethod = 0;
    else if (BST_CHECKED ==
        IsDlgButtonChecked(ParentHwnd, IDC_FILTERMETHOD_NEVER))
        newFilterResourceMethod = 1;
    else if (BST_CHECKED ==
        IsDlgButtonChecked(ParentHwnd, IDC_FILTERMETHOD_ACCEPTANY))
        newFilterResourceMethod = 2;


    // LPT port number
    curLptNum = myatoi(LptPropParams->szLptName + wcslen(m_szLPT));
    newLptNum = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, PP_LPT_PORT_NUMBER));
    if (newLptNum == CB_ERR) {
        newLptNum = curLptNum;
    } else {
        newLptNum++;
    }

    // Legacy device detection
    curParEnableLegacyZip = LptPropParams->ParEnableLegacyZip;
    if (BST_CHECKED == IsDlgButtonChecked(ParentHwnd, IDC_LPT_ENABLE_LEGACY)) {
        newParEnableLegacyZip = 0x1;
    } else {
        newParEnableLegacyZip = 0x0;
    }

    //
    // See if they changed anything
    //
    if ((curLptNum == newLptNum) &&
        (curFilterResourceMethod == newFilterResourceMethod) &&
        (curParEnableLegacyZip == newParEnableLegacyZip)) {
        //
        // They didn't change anything. Just exit.
        //
        return ERROR_SUCCESS;
    }

    //
    // Open the device key for the source device instance
    //
    hKey = SetupDiOpenDevRegKey(LptPropParams->DeviceInfoSet,
                                     LptPropParams->DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DEV,
                                     KEY_ALL_ACCESS);

    if (INVALID_HANDLE_VALUE == hKey) {
        //
        // Not much we can do, just exit gracefully
        //
        return ERROR_SUCCESS;
    }

    // Check the LPT port name for changes
    if (newLptNum != curLptNum) {
        LptEnactPortNameChanges(ParentHwnd,
                                LptPropParams,
                                hKey,
                                newLptNum);
    }

    // Check the Filter resource method for changes
    if (curFilterResourceMethod != newFilterResourceMethod) {
        //
        // They changed the Filter Resource Method
        //
        dwData = newFilterResourceMethod;
        dwSize = sizeof(dwData);
        RegSetValueEx(hKey,
                m_szFilterResourceMethod,
                0,
                REG_DWORD,
                (CONST BYTE *)(&dwData),
                dwSize);
    }
    RegCloseKey(hKey);

    if (curParEnableLegacyZip != newParEnableLegacyZip) {
        //
        // Open the services path and set the new value for Legacy Parallel device
        // detection.
        //
        DWORD disposition = 0;
        error = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               m_szParEnableLegacyZipRegPath,
                               0,
                               (TCHAR *) NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               (LPSECURITY_ATTRIBUTES) NULL,
                               &hKey,
                               &disposition);

        if (error == ERROR_SUCCESS) {
            error = RegSetValueEx(hKey,
                                    m_szParEnableLegacyZip,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)(&newParEnableLegacyZip),
                                    sizeof(newParEnableLegacyZip));
            RegCloseKey(hKey);
            if (error != ERROR_SUCCESS) {
                goto ParEnableLegacyZipSetParamFailed;
            }
            if (newParEnableLegacyZip == 0) {
                //
                // We want a reboot when disabling this thing, because the parallel
                // enumerator won't get rid of legacy devices.
                //
                InformDriverOfChanges(TRUE, LptPropParams);
            } else {
                InformDriverOfChanges(FALSE, LptPropParams);
            }
        } else {
ParEnableLegacyZipSetParamFailed:
            MyMessageBox(ParentHwnd,
                         IDS_LPT_LEGACY_FAILED,
                         IDS_LPT_PROPERTIES,
                         MB_OK);
            //
            // Don't want to overload the user by telling them they have to
            // reboot. Since we were unable to set things correctly, just
            // rebuild the stack.
            //
            InformDriverOfChanges(FALSE, LptPropParams);
        }
    } else {
        InformDriverOfChanges(FALSE, LptPropParams);
    }

    return error;
} // LptSaveAdvancedSettings

UINT
LptEnactPortNameChanges(
    IN HWND             ParentHwnd,
    IN PLPT_PROP_PARAMS LptPropParams,
    IN HKEY             hDeviceKey,
    IN UINT             NewLptNum)
{
    HANDLE  hLpt;
    DWORD   dwError, dwNewLptNameLen;
    UINT    curLptNum;
    BYTE    portUsage[MAX_LPT_PORT];
    TCHAR   charBuffer[LINE_LEN],
            friendlyNameFormat[LINE_LEN],
            deviceDesc[LINE_LEN],
            buffer[BUFFER_SIZE],
            szNewLptName[20];

    //
    // Check if we're trying to rename the port to the same name.
    //
    wsprintf(szNewLptName,_T("\\DosDevices\\LPT%d"),NewLptNum);
    if (wcscmp(szNewLptName, LptPropParams->szLptName) == 0) {
        return ERROR_SUCCESS;
    }

    //
    // Check if a valid port number has been passed in
    //
    if (MAX_LPT_PORT < NewLptNum) {
        //
        // Get out of here - exceeding array bounds
        // This should never happen in the property page since it is a hardcoded
        // selection box.  The user can't simply type a number.
        //
        MyMessageBox(ParentHwnd, IDS_LPT_NUM_ERROR, IDS_LPT_PROPERTIES,
            MB_OK | MB_ICONINFORMATION);
        return ERROR_SUCCESS;
    }

    //
    // Get an array of used ports
    //
    LptEnumerateUsedPorts(ParentHwnd,
                          portUsage,
                          MAX_LPT_PORT);
    if (portUsage[NewLptNum-1]) {
        //
        // Port name is taken by another port.  Check if user wants system to
        // get into inconsistent state.
        //
        if (IDNO == MyMessageBox(ParentHwnd, IDS_LPT_PORT_INUSE,
                                 IDS_LPT_PROPERTIES, MB_YESNO |
                                 MB_ICONINFORMATION)) {
            return ERROR_SUCCESS;
        }
    }

    curLptNum = myatoi(LptPropParams->szLptName + wcslen(m_szLPT));

    //
    // Make sure that the port has not been opened by another application
    //
    wsprintf(buffer, L"\\\\.\\%ws", LptPropParams->szLptName);
    hLpt = CreateFile(buffer, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, NULL);

    //
    // If the file handle is invalid, then the Lpt port is open, warn the user
    //
    if (hLpt == INVALID_HANDLE_VALUE &&
        MyMessageBox(ParentHwnd, IDS_PORT_OPEN, IDS_LPT_PROPERTIES,
                     MB_YESNO | MB_ICONINFORMATION) == IDNO) {
        return GetLastError();
    }
    CloseHandle(hLpt);

    wsprintf(szNewLptName, _T("LPT%d"), NewLptNum);

    //
    // Open the device key for the source device instance, and write its
    // new "PortName" value.
    //
    hDeviceKey = SetupDiOpenDevRegKey(LptPropParams->DeviceInfoSet,
                                      LptPropParams->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_ALL_ACCESS);

    if (INVALID_HANDLE_VALUE == hDeviceKey) {
        return GetLastError();
    }

    dwNewLptNameLen = ByteCountOf(wcslen(szNewLptName) + 1);

    dwError = RegSetValueEx(hDeviceKey,
                            m_szPortName,
                            0,
                            REG_SZ,
                            (PBYTE) szNewLptName,
                            dwNewLptNameLen);
    if (ERROR_SUCCESS == dwError) {
        wcscpy(LptPropParams->szLptName, szNewLptName);
    } else {
        return dwError;
    }

    // Now generate a string, to be used for the device's friendly name, that
    // incorporates both the INF-specified device description, and the port
    // name.  For example,
    //
    //     ECP Printer Port (LPT1)
    //

    if (LoadString(g_hInst,
                   IDS_FRIENDLY_FORMAT,
                   friendlyNameFormat,
                   CharSizeOf(friendlyNameFormat)) &&
       SetupDiGetDeviceRegistryProperty(LptPropParams->DeviceInfoSet,
                                        LptPropParams->DeviceInfoData,
                                        SPDRP_DEVICEDESC,
                                        NULL,
                                        (PBYTE)deviceDesc,
                                        sizeof(deviceDesc),
                                        NULL)) {
        wsprintf(charBuffer, friendlyNameFormat, deviceDesc, szNewLptName);
    }
    else {
        //
        // Simply use LPT port name.
        //
        lstrcpy(charBuffer, szNewLptName);
    }

    SetupDiSetDeviceRegistryProperty(LptPropParams->DeviceInfoSet,
                                     LptPropParams->DeviceInfoData,
                                     SPDRP_FRIENDLYNAME,
                                     (PBYTE)charBuffer,
                                     ByteCountOf(lstrlen(charBuffer) + 1)
                                    );

    return ERROR_SUCCESS;

} // LptEnactPortNameChanges

void
InformDriverOfChanges(BOOL NeedReboot,
                      IN PLPT_PROP_PARAMS LptPropParams)
{
    SP_DEVINSTALL_PARAMS spDevInstall;

    //
    // Now broadcast this change to the device manager
    //
    ZeroMemory(&spDevInstall, sizeof(SP_DEVINSTALL_PARAMS));
    spDevInstall.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if (SetupDiGetDeviceInstallParams(LptPropParams->DeviceInfoSet,
                                      LptPropParams->DeviceInfoData,
                                      &spDevInstall)) {
        if (NeedReboot) {
            spDevInstall.Flags |= DI_PROPERTIES_CHANGE | DI_NEEDREBOOT;
        } else {
            spDevInstall.FlagsEx |= DI_FLAGSEX_PROPCHANGE_PENDING;
        }
        SetupDiSetDeviceInstallParams(LptPropParams->DeviceInfoSet,
                                      LptPropParams->DeviceInfoData,
                                      &spDevInstall);
    }
}

//
// Takes a Buffer of bytes and marks out which port names are taken
//
void
LptEnumerateUsedPorts(
    IN HWND             ParentHwnd,
    IN PBYTE            Buffer,
    IN DWORD            BufferSize)
{
    HKEY    hParallelMap;
    TCHAR   szParallel[BUFFER_SIZE];
    DWORD   dwParallelSize, dwLptSize, dwEnum, dwType, dwResult, dwPortNum;
    TCHAR   szLpt[BUFFER_SIZE];
    PTCHAR  szParPortNum;

    ZeroMemory(Buffer, BufferSize);

    //
    //
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     m_szRegParallelMap,
                     0,
                     KEY_ALL_ACCESS,
                     &hParallelMap) == ERROR_SUCCESS) {

        dwEnum = 0;
        do {
            dwParallelSize = CharSizeOf(szParallel);
            dwLptSize = sizeof(szLpt);
            dwResult = RegEnumValue(hParallelMap,
                                  dwEnum++,
                                  szParallel,
                                  &dwParallelSize,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)szLpt,
                                  &dwLptSize);

            if (dwResult != ERROR_SUCCESS ||
                dwType != REG_SZ) {
                continue;
            }

            szParPortNum = _tcsspnp(szLpt,_T("\\DosDevices\\LPT"));
            if (szParPortNum) {
                //
                // Find out if this is an actual port and not simply a
                // device attached to the port
                //
                if (_tcscspn(szParPortNum,_T(".")) ==
                    _tcslen(szParPortNum)) {
                    dwPortNum = myatoi(szParPortNum);
                    if (dwPortNum-1 < BufferSize) {
                        Buffer[dwPortNum-1] = TRUE;
                    }
                }
            }
        } while (dwResult == ERROR_SUCCESS);
        RegCloseKey(hParallelMap);
    }
} // LptEnumerateUsedPorts

BOOL
LptPortOnContextMenu(HWND HwndControl,
                     WORD Xpos,
                     WORD Ypos)
{
    WinHelp(HwndControl,
            _T("devmgr.hlp"),
            HELP_CONTEXTMENU,
            (ULONG_PTR) LptHelpIDs);

    return FALSE;
}

void
LptPortOnHelp(HWND       ParentHwnd,
              LPHELPINFO HelpInfo)
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                _T("devmgr.hlp"),
                HELP_WM_HELP,
                (ULONG_PTR) LptHelpIDs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\resource.h ===
// Microsoft Developer Studio generated include file.
// Used by ports.rc
//
#define INITS                           0
#define IDS_INIT_NAME                   1
#define IDS_INIT_CLOSE                  2
#define PORTS_ICON                      2
#define IDS_PORT_IN_USE                 5
#define ERRORS                          8
#define MYPORT                          10
#define IDS_PARITY                      11
#define IDS_BITS                        12
#define IDS_FLOWCONTROL                 13
#define DLG_PP_PORTSETTINGS             15
#define DLG_PP_ADVPORTS                 16
#define IDS_ADVANCED_SETTINGS_FOR       19
#define IDS_FRIENDLY_FORMAT             29
#define IDS_ADVANCED_SETTINGS           30
#define IDS_SYSSETCHANGE                50
#define IDS_COMCHANGE                   51
#define IDS_LOW                         53
#define IDS_HIGH                        54
#define IDS_NO_WRITE_PRVILEGE           55
#define IDS_NAME_PROPERTIES             56
#define IDS_COM_CONFLICT                59
#define IDS_PORT_OPEN                   59
#define IDS_COM_CONFLICT_RESOLVE        60
#define IDS_PORT_RENAME_ERROR           60
#define IDS_IN_USE                      61
#define IDS_LPT_PROPERTIES              62
#define IDS_LPT_PORT_INUSE              63
#define IDS_LPT_NUM_ERROR               64
#define IDS_LPT_LEGACY_FAILED           65
#define DLG_PP_LPT_PORTSETTINGS         102
#define PORT_BAUDRATE                   800
#define PORT_DATABITS                   801
#define PORT_PARITY                     802
#define PORT_STOPBITS                   803
#define PORT_FLOWCTL                    804
#define PORT_ADVANCED                   805
#define IDC_RECEIVE_SLIDER              821
#define IDC_ADVANCED                    840
#define PP_PORT_BAUDRATE                841
#define IDC_TRANSMIT_SLIDER             842
#define PP_PORT_DATABITS                842
#define PP_PORT_PARITY                  843
#define IDC_RESTORE                     844
#define PP_PORT_STOPBITS                844
#define PP_PORT_FLOWCTL                 845
#define PP_PORT_NUMBER                  846
#define PP_PORT_FIFO                    847
#define PP_PORT_TYPE                    848
#define IDC_FIFO                        885
#define IDC_LOW1                        886
#define IDC_LOW2                        887
#define IDC_HIGH1                       888
#define IDC_HIGH2                       889
#define IDC_RECEIVE_TEXT                890
#define IDC_TRANSMIT_TEXT               891
#define IDC_RESTORE_PORT                892
#define IDC_RXVALUE                     893
#define IDC_TXVALUE                     894
#define IDC_COMNUMTEXT                  895
#define IDC_TRANSMIT_LOW                1000
#define IDC_RECEIVE_LOW                 1001
#define IDC_RECEIVE_HIGH                1002
#define IDC_TRANSMIT_HIGH               1003
#define IDC_POLL_PERIOD                 1027
#define IDC_POLL_DESC                   1029
#define IDC_DESC_1                      1030
#define IDC_DESC_2                      1031
#define IDC_FILTERMETHOD_TRYNOT         1032
#define IDC_FILTERMETHOD_NEVER          1033
#define IDC_FILTERMETHOD_ACCEPTANY      1034
#define PP_LPT_PORT_NUMBER              1035
#define IDC_LPTNUMTEXT                  1036
#define IDC_LPT_ENABLE_LEGACY           1037
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1038
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\pp_lpt.h ===
#ifndef PP_LPT_H
#define PP_LPT_H

#include "msports.h"

// Exported from pplpt.c
extern TCHAR m_szPortName[];

typedef struct _LPT_PROP_PARAMS
{
   HDEVINFO                     DeviceInfoSet;
   PSP_DEVINFO_DATA             DeviceInfoData;
   BOOL                         ChangesEnabled;
   GUID                         ClassGuid;          // the class GUID for this device
   DWORD                        FilterResourceMethod;
   DWORD                        ParEnableLegacyZip;
//   HKEY                         hDeviceKey;
   TCHAR                        szLptName[20];
} LPT_PROP_PARAMS, *PLPT_PROP_PARAMS;

#define RESOURCE_METHOD_DEFAULT_IDX 1 
#define FILTERMETHOD_TRYNOT     0
#define FILTERMETHOD_NEVER      1
#define FILTERMETHOD_ACCEPTANY  2

#define MAX_LPT_PORT            3   // Maximum number of LPT ports NT supports
#define MIN_LPT                 1   // Minimum new LPT port number

#define ENABLELEGACYZIPDEFAULT  0

#define IDH_NOHELP		((DWORD)-1)
#define idh_devmgr_portset_trynot	15895	// Port Settings: radio button
#define idh_devmgr_portset_never	15896	// Port Settings: radio button
#define idh_devmgr_portset_acceptany	15897	// Port Settings: radio button
#define idh_devmgr_portset_portnum	15898	// Port Settings: List box text
#define idh_devmgr_portset_LPTchoice	15899	// Port Settings: List box
#define	idh_devmgr_enable_legacy	15900

////////////////////////////////////////////////////////////////////////////////
// Port Settings Property Page Prototypes
////////////////////////////////////////////////////////////////////////////////

BOOL
APIENTRY 
ParallelPortPropPageProvider(LPVOID                 Info,
                             LPFNADDPROPSHEETPAGE   AddFunc,
                             LPARAM                 Lparam);

#endif // PP_LPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\ports\util.c ===
/** FILE: util.c *********** Module Header ********************************
 *
 *  Ports applet utility library routines. This file contains string,
 *  cursor, SendWinIniChange() routines.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  15:30 on Thur  03 May 1994  -by-  Steve Cathcart   [stevecat]
 *        Increased  MyMessageBox buffers, Restart dialog changes
 *  17:00 on Mon   18 Sep 1995  -by-  Steve Cathcart   [stevecat]
 *        Changes for product update - SUR release NT v4.0
 *  Nov 1997					-by-  Doron Holan	   [stevecat]
 *        Removed obsolete cpl code
 *
 *  Copyright (C) 1990-1995 Microsoft Corporation
 *
 *************************************************************************/
/* Notes -

    Global Functions:

      U T I L I T Y

        BackslashTerm () - add backslash char to path
        ErrMemDlg () - display Memory Error message box
        MyAtoi () - To convert from Unicode to ANSI string before calling atoi
        myatoi () - local implementation of atoi for Unicode strings
        MyItoa () - To convert from ANSI to Unicode string after calling itoa
        MyMessageBox () - display message to user, with parameters
        MyUltoa () - To convert from Unicode to ANSI string before calling ultoa
        SendWinIniChange () - broadcast system change message via USER
        strscan () - Find a string within another string
        StripBlanks () - Strip leading and trailing blanks from a string


    Local Functions:

 */

//==========================================================================
//                                Include files
//==========================================================================

// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// Application specific
#include "ports.h"


#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40


LPTSTR 
BackslashTerm(LPTSTR pszPath)
{
    LPTSTR pszEnd;

    pszEnd = pszPath + lstrlen(pszPath);

    //
    //  Get the end of the source directory
    //
    switch(*CharPrev(pszPath, pszEnd)) {
    case TEXT('\\'):
    case TEXT(':'):
        break;

    default:
        *pszEnd++ = TEXT('\\');
        *pszEnd = TEXT('\0');
    }

    return pszEnd;
}

void 
ErrMemDlg(HWND hParent)
{
    MessageBox(hParent, g_szErrMem, g_szPortsApplet,
               MB_OK | MB_ICONHAND | MB_SYSTEMMODAL );
}

///////////////////////////////////////////////////////////////////////////////
//
//   MyAtoi
//
//   Desc:  To convert from Unicode to ANSI string before
//          calling CRT atoi and atol functions.
//
///////////////////////////////////////////////////////////////////////////////

int 
MyAtoi(LPTSTR  string)
{
   CHAR   szAnsi[ INT_SIZE_LENGTH ];
   BOOL   fDefCharUsed;

#ifdef UNICODE
   WideCharToMultiByte(CP_ACP, 0, string, INT_SIZE_LENGTH,
                       szAnsi, INT_SIZE_LENGTH, NULL, &fDefCharUsed);

   return atoi(szAnsi);
#else
   return atoi(string);
#endif

}


int 
myatoi(LPTSTR pszInt)
{
    int   retval;
    TCHAR cSave;

    for (retval = 0; *pszInt; ++pszInt) {
        if ((cSave = (TCHAR) (*pszInt - TEXT('0'))) > (TCHAR) 9)
            break;

        retval = (int) (retval * 10 + (int) cSave);
    }
    return (retval);
}



///////////////////////////////////////////////////////////////////////////////
//
//   MyItoa
//
//   Desc:  To convert from ANSI to Unicode string after calling
//          CRT itoa function.
//
///////////////////////////////////////////////////////////////////////////////

LPTSTR 
MyItoa(INT value, LPTSTR string, INT radix)
{
   CHAR   szAnsi[INT_SIZE_LENGTH];

#ifdef UNICODE

   _itoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, INT_SIZE_LENGTH );
#else

   _itoa(value, string, radix);

#endif

   return (string);
 
} // end of MyItoa()


LPTSTR 
MyUltoa(unsigned long value, 
		LPTSTR  string, 
		INT  radix)
{
   CHAR   szAnsi[ LONG_SIZE_LENGTH ];

#ifdef UNICODE

   _ultoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, LONG_SIZE_LENGTH );
#else

   _ultoa(value, string, radix);

#endif

   return( string );

} // end of MyUltoa()


int 
MyMessageBox(HWND hWnd, 
			 DWORD wText, 
			 DWORD wCaption, 
			 DWORD wType, 
			 ...)
{
    TCHAR   szText[4 * PATHMAX], 
			szCaption[2 * PATHMAX];
    int     ival;
    va_list parg;

    va_start(parg, wType);

    if (wText == INITS)
        goto NoMem;

    if (!LoadString(g_hInst, wText, szCaption, CharSizeOf(szCaption)))
        goto NoMem;

    wvsprintf(szText, szCaption, parg);

    if (!LoadString(g_hInst, wCaption, szCaption, CharSizeOf(szCaption)))
        goto NoMem;

    if ((ival = MessageBox(hWnd, szText, szCaption, wType)) == 0)
        goto NoMem;

    va_end(parg);

    return ival;

NoMem:
    va_end(parg);
    ErrMemDlg(hWnd);

    return 0;
}

void 
SendWinIniChange(LPTSTR lpSection)
{
// NOTE: We have (are) gone through several iterations of which USER
//       api is the correct one to use.  The main problem for the Control
//       Panel is to avoid being HUNG if another app (top-level window)
//       is HUNG.  Another problem is that we pass a pointer to a message
//       string in our address space.  SendMessage will 'thunk' this properly
//       for each window, but PostMessage and SendNotifyMessage will not.
//       That finally brings us to try to use SendMessageTimeout(). 9/21/92
//
// Try SendNotifyMessage in build 260 or later - kills earlier builds
//    SendNotifyMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//    PostMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//  [stevecat] 4/4/92
//
//    SendMessage ((HWND)-1, WM_WININICHANGE, 0L, (LPARAM)lpSection);
//
    //  NOTE: The final parameter (LPDWORD lpdwResult) must be NULL

    SendMessageTimeout((HWND)-1, 
					   WM_WININICHANGE, 
					   0L, 
					   (WPARAM) lpSection,
					   SMTO_ABORTIFHUNG,
					   1000, 
					   NULL);
}

LPTSTR 
strscan(LPTSTR pszString, 
		LPTSTR pszTarget)
{
    LPTSTR psz;

    if (psz = _tcsstr( pszString, pszTarget))
        return (psz);
    else
        return (pszString + lstrlen(pszString));
}


///////////////////////////////////////////////////////////////////////////////
//
//  StripBlanks()
//
//   Strips leading and trailing blanks from a string.
//   Alters the memory where the string sits.
//
///////////////////////////////////////////////////////////////////////////////

void 
StripBlanks(LPTSTR pszString)
{
    LPTSTR  pszPosn;

    //
    //  strip leading blanks
    //

    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
        pszPosn++;

    if (pszPosn != pszString)
        lstrcpy(pszString, pszPosn);

    //
    //  strip trailing blanks
    //

    if ((pszPosn = pszString + lstrlen(pszString)) != pszString) {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
           pszPosn = CharPrev(pszString, pszPosn);

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}

BOOL ReadRegistryByte(HKEY       hKey,
                      PTCHAR     valueName,
                      PBYTE      regData)
{
    DWORD       regDataType = 0;
    DWORD       regDataSize = 0;

    regDataSize = sizeof(*regData);
    if ((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                          valueName,
                                          NULL,
                                          &regDataType,
                                          regData,
                                          &regDataSize))
        || (regDataSize != sizeof(BYTE))
        || (regDataType != REG_BINARY))
    {
        //
        // Read was unsuccessful  or not a binary value, regData is not set
        //
        return FALSE;
    }

    //
    // Read was a success, regData contains the value read in
    //
    return TRUE;
}

// @@BEGIN_DDKSPLIT
#if 0
//
//  Turn hourglass on or off
//

void HourGlass( BOOL bOn )
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

///////////////////////////////////////////////////////////////////////////////
//
// RestartDlg
//
// The following function is the dialog procedure for bringing up a system
// restart message.  This dialog is called whenever the user is advised to
// reboot the system.  The dialog contains an IDOK and IDCANCEL button, which
// instructs the function whether to restart windows immediately.
//
// Parameters:
//
// lParam - The LOWORD portion contains an index to the resource string
//          used to compose the restart message.  This string is inserted
//          before the string IDS_RESTART.
//
// Return Value: The usual dialog return value.
//
///////////////////////////////////////////////////////////////////////////////

BOOL RestartDlg( HWND hDlg, UINT message, DWORD wParam, LONG lParam )
{
    TCHAR   szMessage[ 200 ];
    TCHAR   szTemp[ 100 ];
    BOOLEAN PreviousPriv;

    switch (message)
    {

        case WM_INITDIALOG:

            //
            //  Set up the restart message
            //

            LoadString( g_hInst, LOWORD(lParam), szMessage,
                        CharSizeOf( szMessage ) );

            if( LoadString( g_hInst, IDS_RESTART, szTemp, CharSizeOf( szTemp ) ) )
                lstrcat( szMessage, szTemp );

            SetDlgItemText( hDlg, RESTART_TEXT, szMessage );
            break;

        case WM_COMMAND:

            switch( LOWORD( wParam ) )
            {
                case IDOK:
                    RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                        TRUE, FALSE, &PreviousPriv );
                    ExitWindowsEx( EWX_REBOOT | EWX_SHUTDOWN, (DWORD) (-1) );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, 0L );
                    break;

                default:
                    return( FALSE );
            }
            return( TRUE );

        default:
            return( FALSE );
    }

    return( FALSE );
}

//
//  This does what is necessary to bring up a dialog box
//

int DoDialogBoxParam( int nDlg,
                      HWND hParent,
                      DLGPROC lpProc,
                      DWORD dwHelpContext,
                      DWORD dwParam)
{
    DWORD dwSave;

    dwSave = g_dwContext;

    g_dwContext = dwHelpContext;

    nDlg = DialogBoxParam( g_hInst, (LPTSTR) MAKEINTRESOURCE( nDlg ),
                           hParent, lpProc, dwParam);

    g_dwContext = dwSave;

    if( nDlg == -1 )
       MyMessageBox( hParent, INITS, IDS_INIT_NAME, IDOK );

    return( nDlg );
}

#endif // 0
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\alarm.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       ALARM.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Alarm dialog support.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <help.h>
#include <powercfp.h>
#include <mstask.h>
#include <shfusion.h>
#include <ntpoapi.h>

#include "powercfg.h"
#include "pwrresid.h"
#include "PwrMn_cs.h"

// Private functions implemented in ALARM.C
void     EditWorkItem(HWND, LPTSTR);
BOOLEAN  SetSliderStatusText(HWND, UINT, UINT);
BOOLEAN  SetAlarmStatusText(HWND);
#ifdef WINNT
void     HideShowRunProgram(HWND hWnd);
#endif

// Alarm dialog property sheet init data structure:
typedef struct _ALARM_POL_DLG_DATA
{
    LPTSTR  lpszTitleExt;
    WPARAM  wParam;
} ALARM_POL_DLG_DATA, *PALARM_POL_DLG_DATA;

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern HINSTANCE g_hInstance;           // Global instance handle of this DLL.

// This structure is filled in by the Power Policy Manager at CPL_INIT time.
extern SYSTEM_POWER_CAPABILITIES g_SysPwrCapabilities;
extern DWORD g_dwNumSleepStates;
extern DWORD g_dwSleepStatesMaxMin;
extern DWORD g_dwBattryLevelMaxMin;

SYSTEM_POWER_STATE g_spsMaxSleepState = PowerSystemHibernate;

extern UINT g_uiDisableWakesFlag;           // Flag mask value.
extern UINT g_uiOverrideAppsFlag;           // Flag mask value.

// A systary change requires PowerSchemeDlgProc re-init.
extern BOOL g_bSystrayChange;

// Machine is currently capable of hibernate, managed by code in hibernat.c.
extern UINT g_uiPwrActIDs[];

// Persistant storage of this data is managed by POWRPROF.DLL API's.
extern GLOBAL_POWER_POLICY  g_gpp;

// Indices into g_uiPwrActIDs
#define ID_STANDBY  0
#define ID_SHUTDOWN 1

// Local visable/enabled control state variables.
UINT g_uiSoundState;
UINT g_uiTextState;
UINT g_uiProgState;
UINT g_uiLoChangeEnable;
UINT g_uiLoChangeState;
UINT g_uiAlwaysHide = CONTROL_HIDE;

UINT g_uiNotifySoundFlag   = POWER_LEVEL_USER_NOTIFY_SOUND;
UINT g_uiNotifyTextFlag    = POWER_LEVEL_USER_NOTIFY_TEXT;

#ifdef WINNT
UINT g_uiNotifyProgFlag    = POWER_LEVEL_USER_NOTIFY_EXEC;

CONST LPTSTR g_szAlarmTaskName [NUM_DISCHARGE_POLICIES] = {
    TEXT("Critical Battery Alarm Program"),
    TEXT("Low Battery Alarm Program"),
    NULL,
    NULL
};
#endif

// Advanced alarm policies dialog controls descriptions:
#ifdef WINNT
#define NUM_ALARM_ACTIONS_CONTROLS 7
#else
#define NUM_ALARM_ACTIONS_CONTROLS 5
#endif

// Handy indicies into our AlarmActions control arrays
#define ID_NOTIFYWITHSOUND      0
#define ID_NOTIFYWITHTEXT       1
#define ID_ENABLELOWSTATE       2
#define ID_ALARMACTIONPOLICY    3
#define ID_ALARMIGNORENONRESP   4
#ifdef WINNT
#define ID_RUNPROGCHECKBOX      5
#define ID_RUNPROGWORKITEM      6
#endif

POWER_CONTROLS g_pcAlarmActions[NUM_ALARM_ACTIONS_CONTROLS] =
{// Control ID              Control Type        Data Address        Data Size                       Parameter Pointer               EnableVisible State Pointer
    IDC_NOTIFYWITHSOUND,    CHECK_BOX_ENABLE,   NULL,               sizeof(DWORD),                  &g_uiNotifySoundFlag,           &g_uiSoundState,
    IDC_NOTIFYWITHTEXT,     CHECK_BOX,          NULL,               sizeof(DWORD),                  &g_uiNotifyTextFlag,            &g_uiTextState,
    IDC_ENABLELOWSTATE,     CHECK_BOX_ENABLE,   &g_uiLoChangeEnable,sizeof(DWORD),                  NULL,                           &g_uiLoChangeState,
    IDC_ALARMACTIONPOLICY,  COMBO_BOX,          NULL,               sizeof(DWORD),                  NULL,                           &g_uiLoChangeState,
    IDC_ALARMIGNORENONRESP, CHECK_BOX,          NULL,               sizeof(DWORD),                  &g_uiOverrideAppsFlag,          &g_uiLoChangeState,
#ifdef WINNT
    IDC_RUNPROGCHECKBOX,    CHECK_BOX_ENABLE,   NULL,               sizeof(DWORD),                  &g_uiNotifyProgFlag,            &g_uiProgState,
    IDC_RUNPROGWORKITEM,    PUSHBUTTON,         NULL,               0,                              NULL,                           &g_uiProgState,
#endif
};

// Alarm policies dialog controls descriptions:
#define NUM_ALARM_CONTROLS 6

// Local visable/enabled control state variables.
UINT g_uiLoState;
UINT g_uiCritState;
UINT g_uiBatteryLevelScale;

POWER_CONTROLS g_pcAlarm[NUM_ALARM_CONTROLS] =
{// Control ID                Control Type        Data Address                                                            Data Size                       Parameter Pointer       Enable/Visible State Pointer
    IDC_LOBATALARMENABLE,     CHECK_BOX_ENABLE,   &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].Enable),             sizeof(ULONG),                  NULL,                   &g_uiLoState,
    IDC_LOWACTION,            PUSHBUTTON,         NULL,                                                                   0,                              NULL,                   &g_uiLoState,
    IDC_LOALARMSLIDER,        SLIDER,             &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel),       sizeof(ULONG),                  &g_dwBattryLevelMaxMin, &g_uiLoState,
    IDC_CRITBATALARMENABLE,   CHECK_BOX_ENABLE,   &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].Enable),        sizeof(ULONG),                  NULL,                   &g_uiCritState,
    IDC_CRITACTION,           PUSHBUTTON,         NULL,                                                                   0,                              NULL,                   &g_uiCritState,
    IDC_CRITALARMSLIDER,      SLIDER,             &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel),  sizeof(ULONG),                  &g_dwBattryLevelMaxMin, &g_uiCritState,
};

// "Alarms" Dialog Box (IDD_ALARMPOLICY == 103) help array:

const DWORD g_AlarmHelpIDs[]=
{
    IDC_POWERCFGGROUPBOX3,    IDH_103_1110,   // Alarms: "Low battery alarm groupbox" (Button)
    IDC_LOBATALARMENABLE,     IDH_103_1106,   // Alarms: "Set off &low battery alarm when power level reaches:" (Button)
    IDC_LOWALARMLEVEL,        IDH_103_1104,   // Alarms: "Low alarm level" (Static)
    IDC_LOALARMSLIDER,        IDH_103_1102,   // Alarms: "Low alarm slider" (msctls_trackbar32)
    IDC_LOWACTION,            IDH_103_1101,   // Alarms: "Alar&m Action..." (Button)
    IDC_LOALARMNOTIFICATION,  IDH_103_1108,   // Alarms: "Low alarm status text" (Static)
    IDC_LOALARMPOWERMODE,     IDH_103_1108,   // Alarms: "Low alarm status text" (Static)
#ifdef WINNT
    IDC_LOALARMPROGRAM,       IDH_103_1108,   // Alarms: "Low alarm status text" (Static)
#endif
    IDC_POWERCFGGROUPBOX4,    IDH_103_1111,   // Alarms: "Critical battery alarm groupbox" (Button)
    IDC_CRITBATALARMENABLE,   IDH_103_1107,   // Alarms: "Set off &critical battery alarm when power level reaches:" (Button)
    IDC_CRITALARMLEVEL,       IDH_103_1105,   // Alarms: "Critical alarm level" (Static)
    IDC_CRITALARMSLIDER,      IDH_103_1103,   // Alarms: "Critical alarm slider" (msctls_trackbar32)
    IDC_CRITACTION,           IDH_103_1100,   // Alarms: "Ala&rm Action..." (Button)
    IDC_CRITALARMNOTIFICATION,IDH_103_1109,   // Alarms: "Critical alarm status text" (Static)
    IDC_CRITALARMPOWERMODE,   IDH_103_1109,   // Alarms: "Critical alarm status text" (Static)
#ifdef WINNT
    IDC_CRITALARMPROGRAM,     IDH_103_1109,   // Alarms: "Critical alarm status text" (Static)
#endif
    IDC_NO_HELP_1,            NO_HELP,
    IDC_NO_HELP_2,            NO_HELP,
    IDC_NO_HELP_3,            NO_HELP,
    IDC_NO_HELP_4,            NO_HELP,
    0, 0
};

// "Alarm Actions" Dialog Box (IDD_ALARMACTIONS == 106) help array:

const DWORD g_AlarmActHelpIDs[]=
{
    IDC_POWERCFGGROUPBOX5,  IDH_106_1608,   // Alarm Actions: "Notification groupbox" (Button)
    IDC_NOTIFYWITHSOUND,    IDH_106_1603,   // Alarm Actions: "&Sound alarm" (Button)
    IDC_NOTIFYWITHTEXT,     IDH_106_1605,   // Alarm Actions: "&Display message" (Button)
    IDC_POWERCFGGROUPBOX6,  IDH_106_1609,   // Alarm Actions: "Power level groupbox" (Button)
    IDC_POWERCFGGROUPBOX7,  IDH_106_1609,   // Alarm Actions: "Run program groupbox"
    IDC_ENABLELOWSTATE,     IDH_106_1600,   // Alarm Actions: "When the &alarm goes off, the computer will:" (Button)
    IDC_ALARMACTIONPOLICY,  IDH_106_1601,   // Alarm Actions: "Alarm action dropdown" (ComboBox)
    IDC_ALARMIGNORENONRESP, IDH_106_1602,   // Alarm Actions: "&Force standby or shutdown even if a program stops responding." (Button)
#ifdef WINNT
    IDC_RUNPROGCHECKBOX,    IDH_106_1620,   // Alarm Actions: "Specifies that you want a program to run..."
    IDC_RUNPROGWORKITEM,    IDH_106_1621,   // Alarm Actions: "Displays a dialog box wher the work item is configured..."
#endif
    0, 0
};

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*   AlarmActionsDlgProc
*
*   DESCRIPTION:
*
*   PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK AlarmActionsDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static  GLOBAL_POWER_POLICY   gpp;
    static  PALARM_POL_DLG_DATA   papdd;

    static  UINT    uiIndex;
    static  UINT    uiEventId;
#ifdef WINNT
    static  LPTSTR  lpszTaskName;
    HWND    hTaskWnd;
#endif
    LPTSTR  lpszCaption;
    UINT    ii;

    switch (uMsg) {

        case WM_INITDIALOG:

            // Save a copy of the global policies to restore on cancel.
            memcpy(&gpp, &g_gpp, sizeof(gpp));

            // Set the pointers to the data of interest.
            papdd  = (PALARM_POL_DLG_DATA) lParam;
            if (papdd->wParam == IDC_LOWACTION) {
                uiIndex = DISCHARGE_POLICY_LOW;
                uiEventId = IDS_LOWSOUNDEVENT;
            }
            else {
                uiIndex = DISCHARGE_POLICY_CRITICAL;
                uiEventId = IDS_CRITSOUNDEVENT;
            }
#ifdef WINNT
            lpszTaskName = g_szAlarmTaskName [uiIndex];
#endif
            // Set up the data pointers in g_pcAlarmActions.
            g_pcAlarmActions[ID_NOTIFYWITHSOUND].lpvData =
                &(g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.EventCode);
            g_pcAlarmActions[ID_NOTIFYWITHTEXT].lpvData =
                &(g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.EventCode);
#ifdef WINNT
            g_pcAlarmActions[ID_RUNPROGCHECKBOX].lpvData =
                &(g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.EventCode);
#endif
            g_pcAlarmActions[ID_ALARMACTIONPOLICY].lpdwParam =
                (LPDWORD)&(g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.Action);
            g_pcAlarmActions[ID_ALARMIGNORENONRESP].lpvData =
                &(g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.Flags);

            //
            // Set the appropriate choices for the Alarms
            //
            ii=0;

            if (g_SysPwrCapabilities.SystemS1 ||
                    g_SysPwrCapabilities.SystemS2 || g_SysPwrCapabilities.SystemS3) {
                g_uiPwrActIDs[ii++] = IDS_STANDBY;
                g_uiPwrActIDs[ii++] = PowerActionSleep;
            }

            if (g_SysPwrCapabilities.HiberFilePresent) {
                g_uiPwrActIDs[ii++] = IDS_HIBERNATE;
                g_uiPwrActIDs[ii++] = PowerActionHibernate;
            }

            g_uiPwrActIDs[ii++] = IDS_POWEROFF;
            g_uiPwrActIDs[ii++] = PowerActionShutdownOff;
            g_uiPwrActIDs[ii++] = 0;
            g_uiPwrActIDs[ii++] = 0;

            g_pcAlarmActions[ID_ALARMACTIONPOLICY].lpvData = g_uiPwrActIDs;

            if (g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.Action == PowerActionNone) {
                g_uiLoChangeEnable = FALSE;
            }
            else {
                g_uiLoChangeEnable = TRUE;
            }
            MapPwrAct(&(g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.Action), FALSE);

            // Set the dialog caption.
            lpszCaption = LoadDynamicString(IDS_ALARMACTIONS,
                                            papdd->lpszTitleExt);
            if (lpszCaption) {
                SetWindowText(hWnd, lpszCaption);
                LocalFree(lpszCaption);
            }

            // Initialize the controls.
            SetControls(hWnd, NUM_ALARM_ACTIONS_CONTROLS, g_pcAlarmActions);

#ifdef WINNT
            HideShowRunProgram(hWnd);
#endif
            return (INT_PTR) TRUE;

        case WM_COMMAND:
            switch (wParam) {
#ifdef WINNT
                case IDC_RUNPROGWORKITEM:
                    hTaskWnd =  FindWindow( NULL, lpszTaskName);
                    if (hTaskWnd) {
                        BringWindowToTop(hTaskWnd);
                    } else {
                        EditWorkItem(hWnd, lpszTaskName);
                    }
                    break;

                case IDC_RUNPROGCHECKBOX:
                    hTaskWnd =  FindWindow( NULL, lpszTaskName);
                    if (hTaskWnd)
                    {
                        DestroyWindow(hTaskWnd);
                    }
                    // No break: Fall through to update grayed status of controls.
#endif
                case IDC_ENABLELOWSTATE:
                    GetControls(hWnd, NUM_ALARM_ACTIONS_CONTROLS, g_pcAlarmActions);
                    SetControls(hWnd, NUM_ALARM_ACTIONS_CONTROLS, g_pcAlarmActions);
#ifdef WINNT
                    HideShowRunProgram(hWnd);
#endif
                    break;

                case IDOK:
#ifdef WINNT
                    hTaskWnd =  FindWindow( NULL, lpszTaskName);
                    if (hTaskWnd) {
                        BringWindowToTop(hTaskWnd);
                    } else {
#endif
                        GetControls(hWnd, NUM_ALARM_ACTIONS_CONTROLS, g_pcAlarmActions);
                        if (!g_uiLoChangeEnable) {
                            g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.Action =
                                PowerActionNone;
                        }
                        g_gpp.user.DischargePolicy[uiIndex].MinSystemState = g_spsMaxSleepState;
                        EndDialog(hWnd, wParam);
#ifdef WINNT
                    }
#endif
                    break;

                case IDCANCEL:
#ifdef WINNT
                    hTaskWnd =  FindWindow( NULL, lpszTaskName);
                    if (hTaskWnd)
                    {
                        DestroyWindow(hTaskWnd);
                    }
#endif
                    // Restore the original global policies.
                    memcpy(&g_gpp, &gpp, sizeof(gpp));
                    EndDialog(hWnd, wParam);
                    break;
            }
            break;

        case PCWM_NOTIFYPOWER:
           // Notification from systray, user has changed a PM UI setting.
           g_bSystrayChange = TRUE;
           break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_AlarmActHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_AlarmActHelpIDs);
            return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*   AlarmDlgProc
*
*   DESCRIPTION:
*
*   PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK AlarmDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NMHDR FAR *lpnm;
    ALARM_POL_DLG_DATA apdd;
    PUINT puiPos, puiPosVar, puiOtherPosVar, puiOtherPos, puiEnableState;
    UINT  uiEnable, uiSliderStatusId, uiID;
    SYSTEM_BATTERY_STATE sbsBatteryState;
    BOOL  bAdjust;

    static HWND hWndLoSlider, hWndCritSlider;
    static UINT uiDefaultAlert1, uiLoPos, uiCritPos, uiLoPosSave, uiCritPosSave;
    static BOOL bDirty = FALSE;

    switch (uMsg) {

        case WM_INITDIALOG:
            // If we can't read the global power policies hide
            // the controls on this page.
            if (!GetGlobalPwrPolicy(&g_gpp)) {
                HideControls(hWnd, NUM_ALARM_CONTROLS, g_pcAlarm);
                return TRUE;
            }

            g_uiTextState = g_uiSoundState = CONTROL_ENABLE;

            // Set the scale value.
            if (!HIWORD(g_dwBattryLevelMaxMin)) {
                g_uiBatteryLevelScale = 1;
            }
            else {
                g_uiBatteryLevelScale = 100 / HIWORD(g_dwBattryLevelMaxMin);
            }

            g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel /=
                g_uiBatteryLevelScale;
            g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel /=
                g_uiBatteryLevelScale;

            // Read DefaultAlert1 from composite battery 
            NtPowerInformation (SystemBatteryState, NULL, 0, &sbsBatteryState, sizeof(sbsBatteryState));
            if (sbsBatteryState.MaxCapacity == 0) {
                uiDefaultAlert1 = 0;
            } else {
                uiDefaultAlert1 = (100 * sbsBatteryState.DefaultAlert1)/sbsBatteryState.MaxCapacity;
            }

            // Cache the low alarm slider window handle.
            hWndLoSlider   = GetDlgItem(hWnd, IDC_LOALARMSLIDER);
            hWndCritSlider = GetDlgItem(hWnd, IDC_CRITALARMSLIDER);

            // Initialize the local enable and position variables.
            uiLoPosSave   = uiLoPos   =
                g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel;
            uiCritPosSave = uiCritPos =
                g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel;

            // Initialize the dialog controls
            SendDlgItemMessage(hWnd, IDC_LOALARMSLIDER, TBM_SETTICFREQ, 25, 0);
            SendDlgItemMessage(hWnd, IDC_CRITALARMSLIDER, TBM_SETTICFREQ, 25, 0);
            SetControls(hWnd, NUM_ALARM_CONTROLS, g_pcAlarm);
            SetSliderStatusText(hWnd, IDC_LOWALARMLEVEL,  uiLoPos);
            SetSliderStatusText(hWnd, IDC_CRITALARMLEVEL, uiCritPos);
            SetAlarmStatusText(hWnd);

            // If we can't write the global policies disable the controls.
            if (!WriteGlobalPwrPolicyReport(hWnd, &g_gpp, FALSE)) {
                DisableControls(hWnd, NUM_ALARM_CONTROLS, g_pcAlarm);
            }
            return TRUE;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    if (bDirty)
                    {
                        GetControls(hWnd, NUM_ALARM_CONTROLS, g_pcAlarm);
                        g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel *=
                             g_uiBatteryLevelScale;
                        g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel *=
                             g_uiBatteryLevelScale;
                        WriteGlobalPwrPolicyReport(hWnd, &g_gpp, TRUE);
                        GetActivePwrScheme(&uiID);
                        SetActivePwrSchemeReport(hWnd, uiID, &g_gpp, NULL);
                        bDirty = FALSE;
                    }
                    break;
            }
            break;

        case WM_COMMAND:
            switch (wParam) {
                case IDC_CRITACTION:
                    apdd.lpszTitleExt = LoadDynamicString(IDS_CRITBAT);
                    goto do_config_alarm_act;

                case IDC_LOWACTION:
                    apdd.lpszTitleExt = LoadDynamicString(IDS_LOWBAT);

do_config_alarm_act:
                    apdd.wParam = wParam;
                    if (IDOK == DialogBoxParam(g_hInstance,
                                               MAKEINTRESOURCE(IDD_ALARMACTIONS),
                                               hWnd,
                                               AlarmActionsDlgProc,
                                               (LPARAM)&apdd)) {
                        // Enable the parent dialog Apply button on change.
                        MarkSheetDirty(hWnd, &bDirty);
                    }

                    if (apdd.lpszTitleExt) {
                        LocalFree(apdd.lpszTitleExt);
                    }
                    SetAlarmStatusText(hWnd);
                    break;

                case IDC_LOBATALARMENABLE:
                    puiPosVar = &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel);
                    puiOtherPosVar = &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel);
                    uiSliderStatusId = IDC_LOWALARMLEVEL;
                    goto do_sheet_dirty;

                case IDC_CRITBATALARMENABLE:
                    puiPosVar = &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel);
                    puiOtherPosVar = &(g_gpp.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel);
                    uiSliderStatusId = IDC_CRITALARMLEVEL;

do_sheet_dirty:
                    GetControls(hWnd, NUM_ALARM_CONTROLS, g_pcAlarm);
                    if ((uiEnable = IsDlgButtonChecked(hWnd, (int) wParam)) ==
                        BST_CHECKED) {
                        if (uiLoPos < uiCritPos) {
                            uiLoPos = uiCritPos = *puiPosVar = *puiOtherPosVar;
                            SetSliderStatusText(hWnd, uiSliderStatusId, uiCritPos);
                        }
                    }
                    SetControls(hWnd, NUM_ALARM_CONTROLS, g_pcAlarm);
                    SetAlarmStatusText(hWnd);
                    MarkSheetDirty(hWnd, &bDirty);
                    break;
            }
            break;

        case WM_HSCROLL:
            // Only handle slider controls.
            if (((HWND)lParam != hWndLoSlider) &&
                ((HWND)lParam != hWndCritSlider)) {
                break;
            }

            // Don't allow the low slider to be set lower than the critical
            // slider. Reset position on TB_ENDTRACK for this case.
            if (hWndLoSlider == (HWND)lParam) {
                puiPos           = &uiLoPos;
                puiOtherPos      = &uiCritPos;
                puiEnableState   = &g_uiCritState;
                uiSliderStatusId = IDC_LOWALARMLEVEL;
            }
            else {
                puiPos           = &uiCritPos;
                puiOtherPos      = &uiLoPos;
                puiEnableState   = &g_uiLoState;
                uiSliderStatusId = IDC_CRITALARMLEVEL;
            }

            switch (LOWORD(wParam)) {
                case TB_ENDTRACK:
                    
                    bAdjust = FALSE;

                    if (*puiEnableState & CONTROL_ENABLE) {
                        if (uiLoPos < uiCritPos) {
                            *puiPos = *puiOtherPos;
                            bAdjust = TRUE;
                        }
                    }

                    if (*puiPos < uiDefaultAlert1) {
                        *puiPos = uiDefaultAlert1;
                        bAdjust = TRUE;
                    }

                    if (bAdjust) {
                        SendMessage((HWND)lParam, TBM_SETPOS, TRUE,
                                    (LPARAM)*puiPos);
                    }

                    break;

                case TB_THUMBPOSITION:
                case TB_THUMBTRACK:
                    // New position comes with these messages.
                    *puiPos = HIWORD(wParam);
                    break;

                default:
                    // New position must be fetched for the rest.
                    *puiPos = (UINT) SendMessage((HWND)lParam, TBM_GETPOS, 0, 0);
            }

            // Update the current slider position text.
            SetSliderStatusText(hWnd, uiSliderStatusId, *puiPos);

            // Enable the parent dialog Apply button on any  change.
            MarkSheetDirty(hWnd, &bDirty);
            break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_AlarmHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_AlarmHelpIDs);
            return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  PathOnly
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PathOnly(LPTSTR sz)
{
   LPTSTR p = sz;
   LPTSTR s = NULL;

   while ( *p ) {
      if ( *p == TEXT('\\') ) {
         s = p;
      } else if ( *p == TEXT(':') ) {
         s = p + 1;
      }
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
      p = AnsiNext(p);
#else
      p++;
#endif
   }

   if ( s ) {
      if ( s == sz )
         s++;

      *s = TEXT('\0');
      return TRUE;
   }

   return FALSE;
}

#ifdef WINNT
/*******************************************************************************
*
*  FileNameOnly
*
*  DESCRIPTION: Returns a pointer to the first character after the last
*               backslash in a string
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR FileNameOnly(LPTSTR sz)
{
    LPTSTR next = sz;
    LPTSTR prev;
    LPTSTR begin = next;

    if (next == NULL) {
        return NULL;
    }

    while ( *next ) {
        prev = next;

#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
      next = AnsiNext(next);
#else
      next++;
#endif
        if ( (*prev == TEXT('\\')) || (*prev == TEXT(':')) ) {
            begin = next;
        }
    }

    return begin;
}

/*******************************************************************************
*
*  EditWorkItem
*
*  DESCRIPTION: Opens the specified task.
*
*  PARAMETERS:
*
*******************************************************************************/
void EditWorkItem(HWND hWnd, LPTSTR pszTaskName)
{
    ITaskScheduler  *pISchedAgent = NULL;
    ITask           *pITask;
    IPersistFile    *pIPersistFile;
    HRESULT     hr;

    hr = CoInitialize(NULL);

    if (FAILED(hr)) {
        DebugPrint( "EditWorkItem: CoInitialize returned hr = %08x\n", hr);
        return;
    }

    hr = CoCreateInstance( &CLSID_CSchedulingAgent,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           &IID_ISchedulingAgent,
                           (LPVOID*)&pISchedAgent);

    if (SUCCEEDED(hr)) {

        hr = pISchedAgent->lpVtbl->Activate(pISchedAgent,
                                       pszTaskName,
                                       &IID_ITask,
                                       &(IUnknown *)pITask);

        if (SUCCEEDED(hr)) {
            pITask->lpVtbl->EditWorkItem(pITask, hWnd, 0);
            pITask->lpVtbl->Release(pITask);
        }
        else if (HRESULT_CODE (hr) == ERROR_FILE_NOT_FOUND){
            hr = pISchedAgent->lpVtbl->NewWorkItem(
                    pISchedAgent,
                    pszTaskName,
                    &CLSID_CTask,
                    &IID_ITask,
                    &(IUnknown *)pITask);

            if (SUCCEEDED(hr)) {
                hr = pITask->lpVtbl->QueryInterface(pITask, &IID_IPersistFile,
                                (void **)&pIPersistFile);

                if (SUCCEEDED(hr)) {
                    hr = pIPersistFile->lpVtbl->Save(pIPersistFile, NULL, TRUE);

                    if (SUCCEEDED(hr)) {
                        pITask->lpVtbl->EditWorkItem(pITask, hWnd, 0);
                    }
                    else {
                        DebugPrint( "EditWorkItem: Save filed hr = %08x\n", hr);
                    }
                    pIPersistFile->lpVtbl->Release(pIPersistFile);
                }
                else {
                    DebugPrint( "EditWorkItem: QueryInterface for IPersistFile hr = %08x\n", hr);
                }
                pITask->lpVtbl->Release(pITask);

            }
            else {
                DebugPrint( "EditWorkItem: Activate returned hr = %08x\n", hr);
            }
        }
        else {
            DebugPrint( "EditWorkItem: NewWorkItem returned hr = %08x\n", hr);
        }

        pISchedAgent->lpVtbl->Release(pISchedAgent);
    }
    else {
        DebugPrint( "EditWorkItem: CoCreateInstance returned hr = %08x\n", hr);
    }

    CoUninitialize();

}
#endif
/*******************************************************************************
*
*  SetSliderStatusText
*
*  DESCRIPTION:
*   Update the current slider position text.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SetSliderStatusText(HWND hWnd, UINT uiStatusId, UINT uiLevel)
{
    LPTSTR  pString;

    pString = LoadDynamicString(IDS_ALARMLEVELFORMAT,
                                uiLevel * g_uiBatteryLevelScale);
    DisplayFreeStr(hWnd, uiStatusId, pString, FREE_STR);
    return TRUE;
}

/*******************************************************************************
*
*  SetAlarmStatusText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SetAlarmStatusText(HWND hWnd)
{
   TCHAR   szStatus[MAX_UI_STR_LEN];
   LPTSTR  lpsz;
   UINT    uiActionId, uiStatusId, uiIndex, uiAction;
   PUINT   puiState;
#ifdef WINNT

   LPTSTR  lpszRunProg;

#endif

   puiState    = &g_uiCritState;
   uiStatusId  = IDC_CRITALARMNOTIFICATION;
   for (uiIndex = DISCHARGE_POLICY_CRITICAL; uiIndex <= DISCHARGE_POLICY_LOW; uiIndex++) {

      // Format the alarm action notification status string.
      szStatus[0] = '\0';
      if (g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.EventCode &
          POWER_LEVEL_USER_NOTIFY_SOUND) {
         if ((lpsz = LoadDynamicString(IDS_ALARMSTATUSSOUND)) != NULL) {
            lstrcat(szStatus, lpsz);
            LocalFree(lpsz);
         }
      }

      if (g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.EventCode &
          POWER_LEVEL_USER_NOTIFY_TEXT) {
         if (szStatus[0] != '\0') {
            lstrcat(szStatus, TEXT(", "));
         }
         if ((lpsz = LoadDynamicString(IDS_ALARMSTATUSTEXT)) != NULL) {
            lstrcat(szStatus, lpsz);
            LocalFree(lpsz);
         }
      }

      if (szStatus[0] == '\0') {
         if ((lpsz = LoadDynamicString(IDS_NOACTION)) != NULL) {
            lstrcat(szStatus, lpsz);
            LocalFree(lpsz);
         }
      }
      DisplayFreeStr(hWnd, uiStatusId, szStatus, NO_FREE_STR);
      ShowWindow(GetDlgItem(hWnd, uiStatusId),
                 (*puiState & CONTROL_ENABLE) ?  SW_SHOW:SW_HIDE);
      uiStatusId++;

      // Format the alarm action power mode status string.
      uiAction = g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.Action;
      switch (uiAction) {
         case PowerActionNone:
            uiActionId = IDS_NOACTION;
            break;

         case PowerActionSleep:
            uiActionId = IDS_STANDBY;
            break;

         case PowerActionHibernate:
            uiActionId = IDS_HIBERNATE;
            break;

         case PowerActionShutdown:
         case PowerActionShutdownReset:
         case PowerActionShutdownOff:
            uiActionId = IDS_POWEROFF;
            break;

         case PowerActionReserved:
         default:
            DebugPrint( "SetAlarmStatusText, unable to map power action: %X", uiAction);
            uiActionId = IDS_NOACTION;
      }
      lpsz = LoadDynamicString(uiActionId);
      DisplayFreeStr(hWnd, uiStatusId, lpsz, FREE_STR);
      ShowWindow(GetDlgItem(hWnd, uiStatusId),
                 (*puiState & CONTROL_ENABLE) ?  SW_SHOW:SW_HIDE);
      uiStatusId++;

      // Format the alarm action run program status string.
#ifdef WINNT
      lpszRunProg = NULL;

      if (g_gpp.user.DischargePolicy[uiIndex].PowerPolicy.EventCode &
         POWER_LEVEL_USER_NOTIFY_EXEC) {
         {
            //
            // Open up the alarm action task and read the program name.
            //

            ITaskScheduler   *pISchedAgent = NULL;
            ITask            *pITask;

            HRESULT     hr;

            hr = CoInitialize(NULL);

            if (SUCCEEDED(hr)) {

               hr = CoCreateInstance( &CLSID_CSchedulingAgent,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      &IID_ISchedulingAgent,
                                      (LPVOID*)&pISchedAgent);

               if (SUCCEEDED(hr)) {

                  hr = pISchedAgent->lpVtbl->Activate(pISchedAgent,
                                                      g_szAlarmTaskName [uiIndex],
                                                      &IID_ITask,
                                                      &(IUnknown *)pITask);

                  if (SUCCEEDED(hr)) {
                     pITask->lpVtbl->GetApplicationName(pITask, &lpszRunProg);
                     pITask->lpVtbl->Release(pITask);
                  }

                  pISchedAgent->lpVtbl->Release(pISchedAgent);
               }
               else {
                  DebugPrint( "SetAlarmStatusText: CoCreateInstance returned hr = %08x\n", hr);
               }

               CoUninitialize();
            }
         }

      }
      if (lpszRunProg != NULL) {

          DisplayFreeStr(hWnd, uiStatusId, FileNameOnly(lpszRunProg), NO_FREE_STR);
          CoTaskMemFree (lpszRunProg);
          lpszRunProg = NULL;
      }
      else {
         lpsz = LoadDynamicString(IDS_NONE);
         DisplayFreeStr(hWnd, uiStatusId, lpsz, FREE_STR);
      }
      ShowWindow(GetDlgItem(hWnd, uiStatusId),
                 (*puiState & CONTROL_ENABLE) ?  SW_SHOW:SW_HIDE);
#endif
      uiStatusId++;

      puiState    = &g_uiLoState;
      uiStatusId  = IDC_LOALARMNOTIFICATION;
   }
   return TRUE;
}

#ifdef WINNT
/*******************************************************************************
*
*  HideShowRunProgram
*
*  DESCRIPTION:
*
*  PARAMETERS:
*   On WINNT, only power users may set the run program.
*   The run program is stored under HKLM.
*
*******************************************************************************/

void HideShowRunProgram(HWND hWnd)
{
    if (CanUserWritePwrScheme()) {
        ShowWindow(GetDlgItem(hWnd, IDC_POWERCFGGROUPBOX7), SW_SHOW);
        ShowWindow(GetDlgItem(hWnd, IDC_RUNPROGCHECKBOX), SW_SHOW);
        ShowWindow(GetDlgItem(hWnd, IDC_RUNPROGWORKITEM), SW_SHOW);
    }
    else {
        ShowWindow(GetDlgItem(hWnd, IDC_POWERCFGGROUPBOX7), SW_HIDE);
        ShowWindow(GetDlgItem(hWnd, IDC_RUNPROGCHECKBOX), SW_HIDE);
        ShowWindow(GetDlgItem(hWnd, IDC_RUNPROGWORKITEM), SW_HIDE);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\getset.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       GETSET.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Power management UI. Control panel applet. Support for set/get to/from
*   dialog controls.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include "powercfg.h"

// Private functions implemented in GETSET.C
LPTSTR  IDtoStr(UINT, PUINT);
VOID    DoSetSlider(HWND, UINT, DWORD, DWORD);
VOID    DoSetText(HWND, UINT, LPTSTR, DWORD);
BOOLEAN DoComboSet(HWND, UINT, PUINT, UINT);
BOOLEAN DoComboGet(HWND, UINT, PUINT, PUINT);
BOOLEAN DoGetCheckBox(HWND, UINT, PUINT, LPDWORD);
BOOLEAN DoGetCheckBoxEnable(HWND, UINT, PUINT, LPDWORD, LPDWORD);
BOOLEAN ValidateCopyData(LPDWORD, LPDWORD, DWORD);

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/


/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  DisableControls
*
*  DESCRIPTION:
*   Disable all specified controls. Only modify those which are visable.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID DisableControls(
    HWND            hWnd,
    UINT            uiNumControls,
    POWER_CONTROLS  pc[]
)
{
    UINT    i;
    HWND    hWndControl;

    for (i = 0; i < uiNumControls; i++) {

        switch (pc[i].uiType) {
            case CHECK_BOX:
            case CHECK_BOX_ENABLE:
            case SLIDER:
            case EDIT_UINT:
            case EDIT_TEXT:
            case EDIT_TEXT_RO:
            case PUSHBUTTON:
            case STATIC_TEXT:
            case COMBO_BOX:

                if (hWndControl = GetDlgItem(hWnd, pc[i].uiID)) {
                    if (GetWindowLong(hWndControl, GWL_STYLE) & WS_VISIBLE) {
                        EnableWindow(hWndControl, FALSE);

                        // Force state to disable.
                        if (pc[i].lpdwState) {
                            *pc[i].lpdwState = CONTROL_DISABLE;
                        }
                    }
                }
                else {
                    DebugPrint( "DisableControls, GetDlgItem failed, hWnd: 0x%X, ID: 0x%X, Index: %d", hWnd, pc[i].uiID, i);
                }
                break;

            default:
                DebugPrint( "DisableControls, unknown control type");
        } // switch (ppc[i].uType)
    }
}

/*******************************************************************************
*
*  HideControls
*
*  DESCRIPTION:
*   Hide all specified controls. Used to handle error cases.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID HideControls(
    HWND            hWnd,
    UINT            uiNumControls,
    POWER_CONTROLS  pc[]
)
{
    UINT    i;
    HWND    hWndControl;

    for (i = 0; i < uiNumControls; i++) {

        switch (pc[i].uiType) {
            case CHECK_BOX:
            case CHECK_BOX_ENABLE:
            case SLIDER:
            case EDIT_UINT:
            case EDIT_TEXT:
            case EDIT_TEXT_RO:
            case PUSHBUTTON:
            case STATIC_TEXT:
            case COMBO_BOX:
                // Force state to hide.
                if (pc[i].lpdwState) {
                    *pc[i].lpdwState = CONTROL_HIDE;
                }

                if (hWndControl = GetDlgItem(hWnd, pc[i].uiID)) {
                    ShowWindow(hWndControl, SW_HIDE);
                }
                else {
                    DebugPrint( "HideControls, GetDlgItem failed, hWnd: 0x%X, ID: 0x%X, Index: %d", hWnd, pc[i].uiID, i);
                }
                break;

            default:
                DebugPrint( "HideControls, unknown control type");
        } // switch (ppc[i].uType)
    }
}

/*******************************************************************************
*
*  SetControls
*
*  DESCRIPTION:
*   Set dialogbox controls using control description array. Walks an array of
*   POWER_CONTROLS dialog controls specifiers and sets the state of the controls
*   (specified by the uiID member) to match the data value pointed to by
*   the lpdwParam member. This function is typically called during
*   WM_INITDIALOG or after a data value has changed and the UI needs to be
*   updated. The optional lpdwState member points to a state variable which
*   controls the visible/hidden status of the control.
*
*  PARAMETERS:
*   hWnd            - Dialog window handle.
*   uiNumControls   - Number of controls to set.
*   pc[]            - Aarray of POWER_CONTROLS dialog controls specifiers.
*
*******************************************************************************/

BOOL SetControls(
    HWND            hWnd,
    UINT            uiNumControls,
    POWER_CONTROLS  pc[]
)
{
    UINT    i, uiMaxMin, uiData, uiMsg;
    PUINT   pui;
    LPTSTR  lpsz;
    UINT    uiIndex;
    HWND    hWndControl;

    for (i = 0; i < uiNumControls; i++) {

        // Validate/Copy input data.
        switch (pc[i].uiType) {
            case CHECK_BOX:
            case CHECK_BOX_ENABLE:
            case SLIDER:
            case EDIT_UINT:
                if (!pc[i].lpvData) {
                    DebugPrint( "SetControls, NULL lpvData, index: %d", i);
                    return FALSE;
                }
                if (!ValidateCopyData(&uiData, pc[i].lpvData, pc[i].dwSize)) {
                    DebugPrint( "SetControls, validate/copy failed, index: %d", i);
                    return FALSE;
                }
                break;

            case EDIT_TEXT:
            case EDIT_TEXT_RO:
                if (!pc[i].lpvData) {
                    DebugPrint( "SetControls, edit text, NULL lpvData, index: %d", i);
                    return FALSE;
                }
                break;

            case COMBO_BOX:
                if (!pc[i].lpvData) {
                    DebugPrint( "SetControls, combo box, NULL lpvData, index: %d", i);
                    return FALSE;
                }
                if (!pc[i].lpdwParam) {
                    DebugPrint( "SetControls, combo box, NULL lpdwParam, index: %d", i);
                    return FALSE;
                }
                if (!ValidateCopyData(&uiData, pc[i].lpdwParam, pc[i].dwSize)) {
                    DebugPrint( "SetControls, combo box, validate/copy failed, index: %d", i);
                    return FALSE;
                }
                break;
        }

        switch (pc[i].uiType) {
            case CHECK_BOX:
                // lpdwParam points to an optional flag mask.
                if (pc[i].lpdwParam) {
                    uiData &= *pc[i].lpdwParam;
                }
                CheckDlgButton(hWnd, pc[i].uiID, uiData);
                break;

            case CHECK_BOX_ENABLE:
                // lpdwParam points to an optional flag mask.
                if (pc[i].lpdwParam) {
                    uiData &= *pc[i].lpdwParam;
                }
                if (pc[i].lpdwState) {
                    if (uiData) {
                        *pc[i].lpdwState |= CONTROL_ENABLE;
                    }
                    else {
                        *pc[i].lpdwState &= ~CONTROL_ENABLE;
                    }
                }
                CheckDlgButton(hWnd, pc[i].uiID, uiData);
                break;

            case SLIDER:
                // lpdwParam points to scale MaxMin initialization.
                if (!pc[i].lpdwParam) {
                    DebugPrint( "SetControls, NULL slider scale pointer, index: %d", i);
                    return FALSE;
                }
                DoSetSlider(hWnd, pc[i].uiID, uiData, *pc[i].lpdwParam);
                break;

            case EDIT_UINT:
                if (pc[i].lpdwParam) {
                    PSPIN_DATA psd = (PSPIN_DATA)pc[i].lpdwParam;

                    SendDlgItemMessage(hWnd, psd->uiSpinId, UDM_SETRANGE, 0,
                                       (LPARAM) *(psd->puiRange));
                }
                SetDlgItemInt(hWnd, pc[i].uiID, uiData, FALSE);
                break;


            case EDIT_TEXT:
            case EDIT_TEXT_RO:
                DoSetText(hWnd, pc[i].uiID, pc[i].lpvData, pc[i].dwSize);
                break;


            case COMBO_BOX:
                if (!DoComboSet(hWnd, pc[i].uiID, pc[i].lpvData, uiData)) {
                    DebugPrint( "SetControls, DoComboSet failed, control: %d", i);
                }
                break;

            case PUSHBUTTON:
            case STATIC_TEXT:
                // Just set visable/enable for this one.
                break;

            default:
                DebugPrint( "SetControls, unknown control type");
                return FALSE;
        } // switch (ppc[i].uType)

        // Control type CHECK_BOX_ENABLE is always visible and enabled.
        if ((pc[i].uiType != CHECK_BOX_ENABLE) && pc[i].lpdwState) {
            if (hWndControl = GetDlgItem(hWnd, pc[i].uiID)) {
                ShowWindow(hWndControl, (*pc[i].lpdwState & CONTROL_HIDE) ?  SW_HIDE:SW_SHOW);
                EnableWindow(hWndControl, (*pc[i].lpdwState & CONTROL_ENABLE) ? TRUE:FALSE);
            }
            else {
                DebugPrint( "SetControls, GetDlgItem failed, hWnd: 0x%X, ID: 0x%X, Index: %d", hWnd, pc[i].uiID, i);
            }
        }
    }
    return TRUE;
}

/*******************************************************************************
*
*  GetControls
*
*  DESCRIPTION:
*   Get dialogbox controls values using control description array. Walks an
*   array of POWER_CONTROLS dialog controls specifiers and gets the state of the
*   controls (specified by the uiID member). The control states are placed in
*   the data values pointed to by the lpdwParam members of the description array.
*   This function is typically called during WM_COMMAND processing when the
*   state of a control has changed and the cooresponding data value needs to be
*   updated. The optional lpdwState member points to a state variable which
*   controls the visible/hidden status of the control. These state values will
*   be updated by CHECK_BOX_ENABLE controls.
*
*  PARAMETERS:
*   hWnd            - Dialog window handle.
*   uiNumControls   - Number of controls to set.
*   pc[]            - Aarray of POWER_CONTROLS dialog controls specifiers.
*
*******************************************************************************/

BOOL GetControls(
    HWND            hWnd,
    UINT            uiNumControls,
    POWER_CONTROLS  pc[]
)
{
    UINT    i, uiIndex, uiDataOut, uiMsg, uiDataIn = 0;
    BOOL    bSuccess;

    for (i = 0; i < uiNumControls; i++) {

        // Validate output data pointers.
        switch (pc[i].uiType) {
            case CHECK_BOX:
            case CHECK_BOX_ENABLE:
            case SLIDER:
            case EDIT_UINT:
                if (!pc[i].lpvData) {
                    DebugPrint( "GetControls, NULL lpvData, index: %d", i);
                    return FALSE;
                }
                if (!ValidateCopyData(&uiDataIn, pc[i].lpvData, pc[i].dwSize)) {
                    DebugPrint( "GetControls, validate/copy input data failed, index: %d", i);
                    return FALSE;
                }
                uiDataOut = uiDataIn;
                break;

            case COMBO_BOX:
                if (!pc[i].lpvData) {
                    DebugPrint( "GetControls, combo box, NULL lpvData, index: %d", i);
                    return FALSE;
                }
                if (!pc[i].lpdwParam) {
                    DebugPrint( "SetControls, COMBO_BOX, NULL lpdwParam, index: %d", i);
                    return FALSE;
                }
                if (!ValidateCopyData(&uiDataIn, pc[i].lpdwParam, pc[i].dwSize)) {
                    DebugPrint( "GetControls, combo box, validate/copy input data failed, index: %d", i);
                    return FALSE;
                }
                uiDataOut = uiDataIn;
                break;

            case EDIT_TEXT:
                if (!pc[i].lpvData) {
                    DebugPrint( "GetControls, edit text, NULL lpvData, index: %d", i);
                    return FALSE;
                }
                break;
        }

        switch (pc[i].uiType) {
            case CHECK_BOX:
                // lpdwParam points to a flag mask.
                DoGetCheckBox(hWnd, pc[i].uiID, &uiDataOut, pc[i].lpdwParam);
                break;

            case CHECK_BOX_ENABLE:
                // lpdwParam points to a flag mask.
                DoGetCheckBoxEnable(hWnd, pc[i].uiID, &uiDataOut,
                                    pc[i].lpdwParam, pc[i].lpdwState);
                break;

            case EDIT_UINT:
                uiDataOut = GetDlgItemInt(hWnd, pc[i].uiID, &bSuccess, FALSE);
                if (!bSuccess) {
                    DebugPrint( "GetControls, GetDlgItemInt failed, index: %d", i);
                    return FALSE;
                }
                break;

            case EDIT_TEXT:
                GetDlgItemText(hWnd, pc[i].uiID, pc[i].lpvData,
                               (pc[i].dwSize / sizeof(TCHAR)) - 1);
                break;

            case SLIDER:
                uiDataOut = (UINT) SendDlgItemMessage(hWnd, pc[i].uiID, TBM_GETPOS, 0, 0);
                break;

            case COMBO_BOX:
                if (!DoComboGet(hWnd, pc[i].uiID, pc[i].lpvData, &uiDataOut)) {
                    DebugPrint( "GetControls, DoComboGet failed, control: %d", i);
                }
                break;

            case EDIT_TEXT_RO:
            case PUSHBUTTON:
            case STATIC_TEXT:
                // Do nothing, these control types can only be set.
                break;

            default:
                DebugPrint( "GetControls, unknown control type");
                return FALSE;
        } // switch (pc[i].uType)

        // Copy output data.
        switch (pc[i].uiType) {
            case CHECK_BOX:
            case CHECK_BOX_ENABLE:
            case SLIDER:
            case EDIT_UINT:
                if (!ValidateCopyData(pc[i].lpvData, &uiDataOut, pc[i].dwSize)) {
                    DebugPrint( "GetControls, validate/copy output data failed, index: %d", i);
                    return FALSE;
                }
                break;
            case COMBO_BOX:
                if (!ValidateCopyData(pc[i].lpdwParam, &uiDataOut, pc[i].dwSize)) {
                    DebugPrint( "GetControls, combo box, validate/copy output data failed, index: %d", i);
                    return FALSE;
                }
        }
    }
    return TRUE;
}

/*******************************************************************************
*
*  RangeLimitIDarray
*
*  DESCRIPTION:
*   Limit the range of values in a ID array based on the passed in Min and Max
*   values.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID RangeLimitIDarray(UINT uiID[], UINT uiMin, UINT uiMax)
{
    UINT i, j;

    // Find the min value and slide the other entries down so that
    // it is the first entry in the array.
    if (uiMin != (UINT) -1) {
        i = 0;
        while (uiID[i++]) {
            if (uiID[i++] >= uiMin) {
                break;
            }
        }
        if (i > 1) {
            i -= 2;
            j = 0;
            while (uiID[i]) {
                uiID[j++] = uiID[i++];
                uiID[j++] = uiID[i++];
            }
        }
        uiID[j++] = 0; uiID[j] = 0;
    }

    // Find the max value and terminate the array so that it's the last entry.
    if (uiMax != (UINT) -1) {
        i = 0;
        while (uiID[i++]) {
            // Don't mess with timeouts of value zero ("Never").
            if (uiID[i] == 0) {
                break;
            }
            if (uiID[i++] > uiMax) {
                uiID[--i] = 0; uiID[--i] = 0;
                break;
            }
        }
    }
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  IDtoStr
*
*  DESCRIPTION:
*   Builds a string from an array of string resource ID's.
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR IDtoStr(
    UINT uiCount,
    UINT uiStrID[]
)
{
    TCHAR   szTmp[MAX_UI_STR_LEN];
    LPTSTR  lpsz = NULL;

    szTmp[0] = '\0';
    while (uiCount) {
        lpsz = LoadDynamicString(uiStrID[--uiCount]);
        if (lpsz) {
            if ((lstrlen(lpsz) + lstrlen(szTmp)) < (MAX_UI_STR_LEN - 3)) {
                if (szTmp[0]) {
                    lstrcat(szTmp, TEXT(", "));
                }
                lstrcat(szTmp, lpsz);
            }
            LocalFree(lpsz);
            lpsz = LocalAlloc(0, STRSIZE(szTmp));
            if (lpsz) {
                lstrcpy(lpsz, szTmp);
            }
        }
    }
    return lpsz;
}

/*******************************************************************************
*
*  DoSetSlider
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID DoSetSlider(HWND hWnd, UINT uiID, DWORD dwData, DWORD dwMaxMin)
{
    if (dwMaxMin) {
        SendDlgItemMessage(hWnd, uiID, TBM_SETRANGE, FALSE, (LPARAM) dwMaxMin);
    }

    SendDlgItemMessage(hWnd, uiID, TBM_SETPOS, TRUE, (LPARAM) dwData);
}

/*******************************************************************************
*
*  DoSetText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID DoSetText(HWND hWnd, UINT uiID, LPTSTR lpsz, DWORD dwSize)
{
    if (dwSize) {
        SendDlgItemMessage(hWnd, uiID, EM_SETLIMITTEXT,
        dwSize - sizeof(TCHAR), 0);
    }
    SetDlgItemText(hWnd, uiID, lpsz);
}

/*******************************************************************************
*
*  DoComboSet
*
*  DESCRIPTION:
*   Reset and populate a combo box with the data pointed to by uiId. Select the
*   item pointed to by uiData.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DoComboSet(
    HWND    hWnd,
    UINT    uiID,
    UINT    uiId[],
    UINT    uiData
)
{
    UINT    uiSelIndex, uiIndex = 0, i = 0;
    BOOL    bFoundSel = FALSE;
    LPTSTR  lpsz;

    SendDlgItemMessage(hWnd, uiID, CB_RESETCONTENT, 0, 0);

    // Populate the combo list box.
    while (uiId[i]) {
        lpsz = LoadDynamicString(uiId[i++]);
        if (lpsz) {
            if (uiIndex != (UINT) SendDlgItemMessage(hWnd, uiID, CB_ADDSTRING,
                                                     0, (LPARAM)lpsz)) {
                DebugPrint( "DoComboSet, CB_ADDSTRING failed: %s", lpsz);
                LocalFree(lpsz);
                return FALSE;
            }
            LocalFree(lpsz);

            if (uiId[i] == uiData) {
                bFoundSel = TRUE;
                uiSelIndex = uiIndex;
            }
            if (SendDlgItemMessage(hWnd, uiID, CB_SETITEMDATA,
                                   uiIndex++, (LPARAM)uiId[i++]) == CB_ERR) {
                DebugPrint( "DoComboSet, CB_SETITEMDATA failed, index: %d", --uiIndex);
                return FALSE;
            }
        }
        else {
            DebugPrint( "DoComboSet, unable to load string, index: %d", --i);
            return FALSE;
        }
    }

    if (bFoundSel) {
        if ((UINT)SendDlgItemMessage(hWnd, uiID, CB_SETCURSEL,
                                     (WPARAM)uiSelIndex, 0) != uiSelIndex) {
            DebugPrint( "DoComboSet, CB_SETCURSEL failed, index: %d", uiSelIndex);
            return FALSE;
        }
    }
    else {
        DebugPrint( "DoComboSet unable to find data: 0x%X", uiData);
        return FALSE;
    }
    return TRUE;
}

/*******************************************************************************
*
*  DoComboGet
*
*  DESCRIPTION:
*   Get data for currently selected combo box item.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DoComboGet(
    HWND    hWnd,
    UINT    uiID,
    UINT    uiId[],
    PUINT   puiData
)
{
    UINT    uiIndex, uiData;

    uiIndex = (UINT) SendDlgItemMessage(hWnd, uiID, CB_GETCURSEL,0, 0);
    if (uiIndex == CB_ERR) {
         DebugPrint( "DoComboGet, CB_GETCURSEL failed");
         return FALSE;
    }
    uiData = (UINT) SendDlgItemMessage(hWnd, uiID, CB_GETITEMDATA, uiIndex, 0);
    if (uiData == CB_ERR) {
         DebugPrint( "DoComboGet, CB_GETITEMDATA failed, index: %d", uiIndex);
         return FALSE;
    }
    *puiData = uiData;
    return TRUE;
}

/*******************************************************************************
*
*  DoGetCheckBox
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DoGetCheckBox(
    HWND    hWnd,
    UINT    uiID,
    PUINT   puiData,
    LPDWORD lpdwMask
)
{
    UINT    uiButtonState;
    BOOLEAN bRet;

    uiButtonState = IsDlgButtonChecked(hWnd, uiID);
    if (lpdwMask) {
        if (uiButtonState == BST_CHECKED) {
            bRet = TRUE;
            *puiData |= *lpdwMask;
        }
        else {
            bRet = FALSE;
            *puiData &= ~(*lpdwMask);
        }
    }
    else {
        if (uiButtonState == BST_CHECKED) {
            bRet = *puiData = TRUE;
        }
        else {
            bRet = *puiData = FALSE;
        }
    }
    return bRet;
}

/*******************************************************************************
*
*  DoGetCheckBoxEnable
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DoGetCheckBoxEnable(
    HWND    hWnd,
    UINT    uiID,
    PUINT   puiData,
    LPDWORD lpdwMask,
    LPDWORD lpdwEnableState
)
{
    UINT    uiData;

    if (DoGetCheckBox(hWnd, uiID, puiData, lpdwMask)) {
        if (lpdwEnableState) {
            *lpdwEnableState |= CONTROL_ENABLE;
        }
        return TRUE;
    }
    else {
        if (lpdwEnableState) {
            *lpdwEnableState &= ~CONTROL_ENABLE;
        }
        return FALSE;
    }
}

/*******************************************************************************
*
*  ValidateCopyData
*
*  DESCRIPTION:
*   Data size must be BYTE, SHORT or DWORD.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ValidateCopyData(LPDWORD lpDst, LPDWORD lpSrc, DWORD dwSize)
{
    switch (dwSize) {
        case sizeof(BYTE):
        case sizeof(SHORT):
        case sizeof(DWORD):
            *lpDst = 0;
            memcpy(lpDst, lpSrc, dwSize);
            return TRUE;

        default:
            DebugPrint( "ValidateCopyData, invalid variable size: %d", dwSize);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\batmtrcf.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       BATMTRCF.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Support for the battery meter configuration page of PowerCfg.Cpl.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <powercfp.h>
#include <dbt.h>

#include <objbase.h>
#include <initguid.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "powercfg.h"
#include "pwrresid.h"
#include "PwrMn_cs.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern UINT g_uiEnableSysTrayFlag;

// A systary change requires PowerSchemeDlgProc re-init.
extern BOOL g_bSystrayChange;

// Persistant storage of this data is managed by POWRPROF.DLL API's.
extern GLOBAL_POWER_POLICY  g_gpp;

// Subclass variables:
WNDPROC g_fnOldPropShtProc;

// BatMeter creation parameters.
HWND    g_hwndBatMeter;
BOOL    g_bShowMulti;
HWND    g_hwndBatMeterFrame;

// Show/hide multi-bat display check box.
DWORD g_dwShowMultiBatDispOpt = CONTROL_ENABLE;

// Static flags:
UINT g_uiEnableMultiFlag = EnableMultiBatteryDisplay;

#ifdef WINNT
// Used to track registration for WM_DEVICECHANGED message.
HDEVNOTIFY g_hDevNotify;
#endif

// Battery meter policies dialog controls descriptions:
#define NUM_BATMETERCFG_CONTROLS 1

POWER_CONTROLS g_pcBatMeterCfg[NUM_BATMETERCFG_CONTROLS] =
{// Control ID          Control Type    Data Address                  Data Size                         Parameter Pointer       Enable/Visible State Pointer
    IDC_ENABLEMULTI,    CHECK_BOX,      &(g_gpp.user.GlobalFlags),    sizeof(g_gpp.user.GlobalFlags),   &g_uiEnableMultiFlag,   &g_dwShowMultiBatDispOpt,
};

// "Battery Meter" Dialog Box (IDD_BATMETERCFG == 102) help arrays:

const DWORD g_BatMeterCfgHelpIDs[]=
{
    IDC_ENABLEMULTI,    IDH_102_1204,   // Battery Meter: "Show the status of all &batteries." (Button)
    IDC_STATIC_FRAME_BATMETER,  IDH_102_1205,   // Battery Meter: "Batmeter frame" (Static)
    IDC_POWERSTATUSGROUPBOX,    IDH_102_1201,   // Battery Meter: "Power status" (Button)
    0, 0
};

#ifdef WINNT
// Private function prototypes
BOOL RegisterForDeviceNotification(HWND hWnd);
void UnregisterForDeviceNotification(void);
#endif

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  PropShtSubclassProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT PropShtSubclassProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
   LRESULT lRet;

   lRet = CallWindowProc(g_fnOldPropShtProc, hWnd, uiMsg, wParam, lParam);

   if ((uiMsg == WM_POWERBROADCAST) && (wParam == PBT_APMPOWERSTATUSCHANGE)) {
      UpdateBatMeter(g_hwndBatMeter, g_bShowMulti, TRUE, NULL);
   }
   return lRet;
}

/*******************************************************************************
*
*  BatMeterCfgDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK BatMeterCfgDlgProc
(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    static BOOL bDirty = FALSE;
#ifdef WINNT
    static BOOL bRegisteredForDC = FALSE;
#endif

    NMHDR *lpnm;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // If we can't read the global power policies
            // disable the controls on this page.
            if (!GetGlobalPwrPolicy(&g_gpp))
            {
                DisableControls(hWnd, NUM_BATMETERCFG_CONTROLS, g_pcBatMeterCfg);
            }
            else
            {
                if (g_gpp.user.GlobalFlags & EnableMultiBatteryDisplay)
                {
                    g_bShowMulti = TRUE;
                }
                else
                {
                    g_bShowMulti = FALSE;
                }

                // If we can't write the global power policies disable
                // the controls this page.
                if (!WriteGlobalPwrPolicyReport(hWnd, &g_gpp, FALSE))
                {
                    HideControls(hWnd, NUM_BATMETERCFG_CONTROLS, g_pcBatMeterCfg);
                }

                SetControls(hWnd, NUM_BATMETERCFG_CONTROLS, g_pcBatMeterCfg);
            }
            g_hwndBatMeterFrame = GetDlgItem(hWnd, IDC_STATIC_FRAME_BATMETER);
            g_hwndBatMeter = CreateBatMeter(hWnd,
                                            g_hwndBatMeterFrame,
                                            g_bShowMulti,
                                            NULL);

            // The top level window must be subclassed to receive
            // the WM_POWERBROADCAST message.
            if (g_hwndBatMeter) {
                g_fnOldPropShtProc =
                    (WNDPROC) SetWindowLongPtr(GetParent(hWnd), DWLP_DLGPROC,
                                            (LONG_PTR)PropShtSubclassProc);

#ifdef WINNT
                // Do onetime registration for WM_DEVICECHANGED.
                if (!bRegisteredForDC) {
                   bRegisteredForDC = RegisterForDeviceNotification(hWnd);
                }
#endif
            }
            return TRUE;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    if (bDirty)
                    {
                        GetControls(hWnd, NUM_BATMETERCFG_CONTROLS, g_pcBatMeterCfg);
                        WriteGlobalPwrPolicyReport(hWnd, &g_gpp, TRUE);
                        bDirty = FALSE;
                    }
                    break;
            }
            break;

        case WM_COMMAND:
            switch (wParam) {
                case IDC_ENABLEMULTI:
                    GetControls(hWnd, NUM_BATMETERCFG_CONTROLS, g_pcBatMeterCfg);
                    if (g_gpp.user.GlobalFlags & EnableMultiBatteryDisplay) {
                        g_bShowMulti = TRUE;
                    }
                    else {
                        g_bShowMulti = FALSE;
                    }

                    UpdateBatMeter(g_hwndBatMeter, g_bShowMulti, TRUE, NULL);

                    // Enable the parent dialog Apply button on change.
                    MarkSheetDirty(hWnd, &bDirty);
                    break;

                default:
                    // Notify battery meter of enter key events.
                    if (HIWORD(wParam) == BN_CLICKED) {
                        SendMessage(g_hwndBatMeter, uMsg, wParam, lParam);
                    }
            }
            break;

        case PCWM_NOTIFYPOWER:
            // Systray changed something. Get the flags and update controls.
            if (GetGlobalPwrPolicy(&g_gpp)) {
                SetControls(hWnd, NUM_BATMETERCFG_CONTROLS, g_pcBatMeterCfg);
            }
            g_bSystrayChange = TRUE;
            break;

        case WM_DEVICECHANGE:
            if ((wParam == DBT_DEVICEARRIVAL) ||
#ifndef WINNT
                (wParam == DBT_DEVICEREMOVECOMPLETE) ||
#endif
                (wParam == DBT_DEVICEQUERYREMOVEFAILED)) {

               if (g_hwndBatMeter) {
                  g_hwndBatMeter = DestroyBatMeter(g_hwndBatMeter);
               }
               g_hwndBatMeter = CreateBatMeter(hWnd,
                                               g_hwndBatMeterFrame,
                                               g_bShowMulti,
                                               NULL);
               InvalidateRect(hWnd, NULL, TRUE);
            }
            return TRUE;

#ifdef WINNT
        case WM_DESTROY:
            UnregisterForDeviceNotification();
            break;
#endif

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_BatMeterCfgHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_BatMeterCfgHelpIDs);
            return TRUE;
    }

    return FALSE;
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

#ifdef WINNT
/*******************************************************************************
*
*  RegisterForDeviceNotification
*
*  DESCRIPTION:
*    Do onetime registration for WM_DEVICECHANGED.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RegisterForDeviceNotification(HWND hWnd)
{
   DEV_BROADCAST_DEVICEINTERFACE dbc;

   memset(&dbc, 0, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
   dbc.dbcc_size         = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
   dbc.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
   dbc.dbcc_classguid    = GUID_DEVICE_BATTERY;
   g_hDevNotify = RegisterDeviceNotification(hWnd,
                                             &dbc,
                                             DEVICE_NOTIFY_WINDOW_HANDLE);
   if (!g_hDevNotify) {
      DebugPrint( "RegisterForDeviceNotification failed");
      return FALSE;
   }
   return TRUE;
}

/*******************************************************************************
*
*  UnregisterForDeviceNotification
*
*  DESCRIPTION:
*
*
*  PARAMETERS:
*
*******************************************************************************/

void UnregisterForDeviceNotification(void)
{
   if (g_hDevNotify) {
      UnregisterDeviceNotification(g_hDevNotify);
      g_hDevNotify = NULL;
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ntapm.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       APM.H
*
*  VERSION:     2.0
*
*  AUTHOR:      Patrickf
*
*  DATE:        09 November, 1998
*
*******************************************************************************/
#include "setupapi.h"
#include "dbt.h"
#include "stdlib.h"
#include "tchar.h"
#include "regstr.h"
#include "cfgmgr32.h"
#include "initguid.h"
#include "devguid.h"
#include "winioctl.h"


#define APM_DISABLE     0x00000000
#define APM_ENABLE      0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\hibernat.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       HIBERNAT.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Support for hibernate page of PowerCfg.Cpl.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <help.h>
#include <powercfp.h>

#include "powercfg.h"
#include "pwrresid.h"
#include "PwrMn_cs.h"

// Private functions implemented in HIBERNAT.C

VOID SetNumberMB(LPTSTR, DWORD);
VOID InsertSeparators(LPTSTR);
UINT UpdateFreeSpace(HWND, UINT);
UINT UpdatePhysMem(void);

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

// This structure is filled in by the Power Policy Manager at CPL_INIT time.
extern SYSTEM_POWER_CAPABILITIES g_SysPwrCapabilities;
extern BOOL g_bRunningUnderNT;

// A systary change requires PowerSchemeDlgProc re-init.
extern BOOL g_bSystrayChange;

// Persistant storage of this data is managed by POWRPROF.DLL API's.
extern GLOBAL_POWER_POLICY  g_gpp;

// Power button power action string ID's. With and without hibernate.
UINT g_uiPwrActIDs[] =
{
    IDS_NONE,       PowerActionNone,
    IDS_PROMPT,     PowerActionNone,
    IDS_STANDBY,    PowerActionSleep,
    IDS_HIBERNATE,  PowerActionHibernate,
    IDS_POWEROFF,   PowerActionShutdownOff,
    0,              0
};

// Lid action string ID's. With and without hibernate.
UINT g_uiLidActIDs[] =
{
    IDS_NONE,       PowerActionNone,
    IDS_STANDBY,    PowerActionSleep,
    IDS_HIBERNATE,  PowerActionHibernate,
    IDS_POWEROFF,   PowerActionShutdownOff,
    0,              0
};

// UI state variables
TCHAR   g_szRequiredSpace[128];
DWORD   g_dwShowHibernate;
DWORD   g_dwShowNoDiskSpace;
DWORD   g_dwShowDiskSpace;
DWORD   g_dwTrueFlag = (DWORD) TRUE;
BOOLEAN g_bHibernate;

// Globals for DoHibernateApply:
BOOL    g_bHibernateDirty;
HWND    g_hwndHibernateDlg;
UINT    g_uiRequiredMB;

// Hibernate policies dialog controls descriptions:

#define NUM_HIBERNATE_POL_CONTROLS 7

// Handy indicies into our g_pcHibernatePol array:
#define ID_REQUIREDSPACE    0
#define ID_NOTENOUGHSPACE   1
#define ID_HIBERNATE        2

POWER_CONTROLS g_pcHibernatePol[NUM_HIBERNATE_POL_CONTROLS] =
{// Control ID              Control Type    Data Address        Data Size               Parameter Pointer    Enable/Visible State Pointer
    IDC_REQUIREDSPACE,      EDIT_TEXT_RO,   &g_szRequiredSpace, 0,                      NULL,                &g_dwShowDiskSpace,
    IDC_NOTENOUGHSPACE,     STATIC_TEXT,    NULL,               0,                      NULL,                &g_dwShowNoDiskSpace,
    IDC_HIBERNATE,          CHECK_BOX,      &g_bHibernate,      sizeof(g_bHibernate),   &g_dwTrueFlag,       &g_dwShowHibernate,
    IDC_DISKSPACEGROUPBOX,  STATIC_TEXT,    NULL,               0,                      NULL,                &g_dwShowDiskSpace,
    IDC_FREESPACETEXT,      STATIC_TEXT,    NULL,               0,                      NULL,                &g_dwShowDiskSpace,
    IDC_REQUIREDSPACETEXT,  STATIC_TEXT,    NULL,               0,                      NULL,                &g_dwShowDiskSpace,
    IDC_FREESPACE,          STATIC_TEXT,    NULL,               0,                      NULL,                &g_dwShowDiskSpace,
};

// "Hibernate" Dialog Box (IDD_HIBERNATE == 105) help array:

const DWORD g_HibernateHelpIDs[]=
{
    IDC_HIBERNATE,          IDH_105_1400,   // Hibernate: "After going on standby, &hibernate." (Button)
    IDC_FREESPACE,          IDH_105_1401,   // Hibernate: "Free space" (Static)
    IDC_REQUIREDSPACE,      IDH_105_1402,   // Hibernate: "Required space to hibernate" (Static)
    IDC_NOTENOUGHSPACE,     IDH_105_1403,   // Hibernate: "You must free up some disk space before your computer can hibernate." (Static)
    IDC_DISKSPACEGROUPBOX,  IDH_105_1402,
    IDC_FREESPACETEXT,      IDH_105_1401,
    IDC_REQUIREDSPACETEXT,  IDH_105_1402,
    IDC_HIBERNATEGROUPBOX,  IDH_105_1400,
    IDI_HIBERNATE,          NO_HELP,
    IDC_NO_HELP_6,          NO_HELP,
    IDI_PWRMNG,             NO_HELP,
    0, 0
};

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  MapPwrAct
*
*  DESCRIPTION:
*   Map power action to one of a lesser number of UI supported actions.
*   Depends on state of hibernate so implemented here.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL MapPwrAct(
    PPOWER_ACTION   ppa,
    BOOL            bNone
)
{
    switch (*ppa) {
        case PowerActionNone:
            if (bNone) {
                *ppa = PowerActionNone;
                break;
            }
        case PowerActionReserved:
        case PowerActionSleep:
            *ppa = PowerActionSleep;
            break;

        case PowerActionHibernate:
            if (g_SysPwrCapabilities.HiberFilePresent) {
                *ppa = PowerActionHibernate;
            }
            else {
                *ppa = PowerActionSleep;
            }
            break;

        case PowerActionShutdown:
        case PowerActionShutdownReset:
        case PowerActionShutdownOff:
            *ppa = PowerActionShutdownOff;
            break;

        default:
            DebugPrint( "MapPwrAct, unknown power action: %X", *ppa);
            *ppa = PowerActionShutdownOff;
            return FALSE;
    }
    return TRUE;
}

/*******************************************************************************
*
*  DoHibernateApply
*
*  DESCRIPTION:
*   Handle the WM_NOTIFY, PSN_APPLY message for HibernateDlgProc. Updates
*   global hibernate state.
*
*  PARAMETERS:
*
*******************************************************************************/

void DoHibernateApply(void)
{
    NTSTATUS    status;

    // Only handle if hibernate page is dirty.
    if (g_bHibernateDirty) {
        // Fetch data from dialog controls.
        GetControls(g_hwndHibernateDlg,
                    NUM_HIBERNATE_POL_CONTROLS,
                    g_pcHibernatePol);

        status = CallNtPowerInformation(SystemReserveHiberFile,
                                        &g_bHibernate,
                                        sizeof(g_bHibernate),
                                        NULL,
                                        0);
        if (status != STATUS_SUCCESS) {
            ErrorMsgBox(g_hwndHibernateDlg,
#ifdef WINNT
                        RtlNtStatusToDosError(status),
#else
                        NO_ERROR,
#endif
                        IDS_UNABLETOSETHIBER);
        }

        // Get the current hibernate state from the PPM.
        if (GetPwrCapabilities(&g_SysPwrCapabilities)) {
            g_bHibernate = g_SysPwrCapabilities.HiberFilePresent;

            // Map power actions to allowed UI values.
            MapPwrAct(&g_gpp.user.LidCloseDc.Action, TRUE);
            MapPwrAct(&g_gpp.user.PowerButtonDc.Action, FALSE);
            MapPwrAct(&g_gpp.user.SleepButtonDc.Action, FALSE);
        }
        SetControls(g_hwndHibernateDlg, 1, &g_pcHibernatePol[ID_HIBERNATE]);
        UpdateFreeSpace(g_hwndHibernateDlg, g_uiRequiredMB);
        g_bHibernateDirty = FALSE;
    }
}

/*******************************************************************************
*
*  HibernateDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK HibernateDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
   NMHDR FAR   *lpnm;
   LPTSTR      pszUPS;

   switch (uMsg) {
      case WM_INITDIALOG:

         // Save the hibernate dialog hwnd for use by DoHibernateApply.
         g_hwndHibernateDlg = hWnd;

         // Get the current hibernate state from the PPM.
         if (GetPwrCapabilities(&g_SysPwrCapabilities)) {
            g_bHibernate = g_SysPwrCapabilities.HiberFilePresent;
         }

         // Get the disk free and required space only under NT.
         if (g_bRunningUnderNT) {
            g_dwShowDiskSpace = CONTROL_ENABLE;

            // Get the required space from the power capabilities.
            g_uiRequiredMB = UpdatePhysMem();

            // Update the disk free space and enable/disable
            // disk space warning and hibernate time out.
            UpdateFreeSpace(hWnd, g_uiRequiredMB);

         } else {
            g_dwShowHibernate = CONTROL_ENABLE;
            g_dwShowDiskSpace = CONTROL_HIDE;
            g_dwShowNoDiskSpace = CONTROL_HIDE;
         }

         SetControls(hWnd, NUM_HIBERNATE_POL_CONTROLS, g_pcHibernatePol);

         //
         // Disable the checkbox is the user doesn't have permission to
         // change it. We do this by trying to set the same value we
         // retrieved earlier.
         //
         {
             NTSTATUS status;
             status = CallNtPowerInformation(SystemReserveHiberFile,
                                    &g_bHibernate,
                                    sizeof(g_bHibernate),
                                    NULL,
                                    0);
             if ( ERROR_SUCCESS != status )
             {
                 EnableWindow( GetDlgItem( hWnd, IDC_HIBERNATE ), FALSE );
             }
         }

         return TRUE;

      case WM_ACTIVATE:
         // If user switches away, check the disk space when they come back.
         if (g_bRunningUnderNT) {
            GetControls(hWnd, NUM_HIBERNATE_POL_CONTROLS, g_pcHibernatePol);
            UpdateFreeSpace(hWnd, g_uiRequiredMB);
            SetControls(hWnd, NUM_HIBERNATE_POL_CONTROLS-1, g_pcHibernatePol);
         }
         break;

      case WM_NOTIFY:
         lpnm = (NMHDR FAR *)lParam;
         switch (lpnm->code) {
            case PSN_APPLY:
               DoHibernateApply();
               break;
         }
         break;

      case WM_COMMAND:
         switch (LOWORD(wParam)) {
            case IDC_HIBERNATE:
               MarkSheetDirty(hWnd, &g_bHibernateDirty);
               break;
         }
         break;

      case PCWM_NOTIFYPOWER:
         // Notification from systray, user has changed a PM UI setting.
         g_bSystrayChange = TRUE;
         break;

      case WM_HELP:             // F1
         WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_HibernateHelpIDs);
         return TRUE;

      case WM_CONTEXTMENU:      // right mouse click
         WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_HibernateHelpIDs);
         return TRUE;
   }
   return FALSE;
}


/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  SetNumberMB
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID SetNumberMB(LPTSTR psz, DWORD dwValue)
{
    LPTSTR      pszNumber;
    TCHAR       szBuf[128];
    TCHAR       szBufLow[64];

    wsprintf(szBuf, TEXT("%u"), dwValue);
    InsertSeparators(szBuf);
    pszNumber = LoadDynamicString(IDS_MBYTES, szBuf);
    if (pszNumber) {
        lstrcpy(psz, pszNumber);
        LocalFree(pszNumber);
    }
}


/*******************************************************************************
*
*  InsertSeparators
*
*  DESCRIPTION:
*   Passed string must be large enough to hold seperators.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID InsertSeparators(LPTSTR pszNumber)
{
    TCHAR szSeparator[10];
    TCHAR Separator;
    TCHAR szBuf[128];
    ULONG cchNumber;
    UINT  Triples;
    LPTSTR  pch;

    if (GetLocaleInfo(GetUserDefaultLCID(),
                      LOCALE_STHOUSAND,
                      szSeparator,
                      sizeof(szSeparator)/sizeof(TCHAR))) {
        Separator = szSeparator[0];
        cchNumber = lstrlen(pszNumber);
        Triples = 0;
        szBuf[127] = '\0';
        pch = &szBuf[126];
        while (cchNumber > 0) {
            *pch-- = pszNumber[--cchNumber];
            ++Triples;
            if ((0 == (Triples % 3)) && (cchNumber > 0)) {
                *pch-- = Separator;
            }
        }
        lstrcpy(pszNumber, pch + 1);
    }
}

/*******************************************************************************
*
*  UpdateFreeSpace
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT UpdateFreeSpace(HWND hWnd, UINT uiRequiredMB)
{
   DWORD      dwSectorsPerCluster, dwBytesPerSector;
   DWORD      dwFreeClusters, dwTotalClusters;
   ULONGLONG  ullFreeBytes = 0;
   UINT       uiFreeMB = 0;
   TCHAR      szTmp[MAX_PATH];

   // Get the free space on the system drive.
   if (GetSystemDirectory(szTmp, sizeof(szTmp)/sizeof(TCHAR))) {
      szTmp[3] = '\0';
      if (GetDiskFreeSpace(szTmp,
                           &dwSectorsPerCluster,
                           &dwBytesPerSector,
                           &dwFreeClusters,
                           &dwTotalClusters)) {
         ullFreeBytes =  dwBytesPerSector * dwSectorsPerCluster;
         ullFreeBytes *= dwFreeClusters;
         uiFreeMB = (UINT) (ullFreeBytes /= 0x100000);
         SetNumberMB(szTmp, uiFreeMB);
         SetDlgItemText(hWnd, IDC_FREESPACE, szTmp);

         // Logic to enable/disable disk space warning and hibernate time out.
         if ((uiFreeMB >= uiRequiredMB) || g_bHibernate) {
            g_dwShowHibernate   = CONTROL_ENABLE;
            g_dwShowNoDiskSpace = CONTROL_HIDE;
         } else {
            if (g_bHibernate) {
               g_dwShowHibernate   = CONTROL_ENABLE;
            }
            else {
               g_dwShowHibernate   = CONTROL_DISABLE;
            }
            g_dwShowNoDiskSpace = CONTROL_ENABLE;
         }

      }
   }
   return uiFreeMB;
}

/*******************************************************************************
*
*  UpdatePhysMem
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT UpdatePhysMem(void)
{
   UINT           uiPhysMemMB;

#ifdef WINNT
   MEMORYSTATUSEX msex;

   msex.dwLength = sizeof(msex);

   GlobalMemoryStatusEx(&msex);
   uiPhysMemMB = (UINT) (msex.ullTotalPhys / 0x100000);

   if (msex.ullTotalPhys % 0x100000) {
      uiPhysMemMB++;
   }
#else
   MEMORYSTATUS ms;

   ms.dwLength = sizeof(ms);

   GlobalMemoryStatus(&ms);
   uiPhysMemMB = (UINT) (ms.dwTotalPhys / 0x100000);

   if (ms.dwTotalPhys % 0x100000) {
      uiPhysMemMB++;
   }
#endif

   SetNumberMB(g_szRequiredSpace, uiPhysMemMB);
   return uiPhysMemMB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\powercfg.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       POWERCFG.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Power management UI. Control panel applet.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <cpl.h>
#include <help.h>
#include <regstr.h>

#include "powercfg.h"
#include "pwrresid.h"
#include <shfusion.h>

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

HINSTANCE   g_hInstance;        // Global instance handle of this DLL.
UINT        wHelpMessage;       // Registered help message.

// Registry path to optional top level powercfg pages.
TCHAR g_szRegOptionalPages[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Power");

// Array which defines the property tabs/pages in the applet.
// The contents of this array are built dynamically, since they
// depend on the machine power management capabilities.

POWER_PAGES g_TopLevelPages[MAX_PAGES] =
{
    MAKEINTRESOURCE(IDS_APPNAME),   NULL,   0,   // Caption
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0,
    0,                              NULL,   0
};

// Specifies which OS, filled in at init CPL time.
BOOL g_bRunningUnderNT;

// This structure is filled in by the Power Policy Manager at CPL_INIT time.
SYSTEM_POWER_CAPABILITIES g_SysPwrCapabilities;

// The following globals are derived from g_SysPwrCapabilities:
DWORD g_dwNumSleepStates = 1;   // Every one suports PowerSystemWorking.
DWORD g_dwSleepStatesMaxMin;    // Specs sleep states slider range.
DWORD g_dwBattryLevelMaxMin;    // Specs battery level slider range.
DWORD g_dwFanThrottleMaxMin;    // Specs fan throttle slider range.
BOOL  g_bVideoLowPowerSupported;// This will be moved to g_SysPwrCapabilities

UINT  g_uiVideoTimeoutMaxMin;   // May be set from registry.
UINT  g_uiSpindownMaxMin;       // May be set from registry.
PUINT g_puiBatCount;            // Number of displayable batteries.
BOOL  g_bIsUserAdministrator;   // The current user has admin. privileges.

// Static flags:
UINT g_uiOverrideAppsFlag = POWER_ACTION_OVERRIDE_APPS;
UINT g_uiDisableWakesFlag = POWER_ACTION_DISABLE_WAKES;

int  BuildPages(PSYSTEM_POWER_CAPABILITIES, PPOWER_PAGES);
VOID SyncRegPPM(VOID);


/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  DllInitialize
*
*  DESCRIPTION:
*   Library entry point
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL DllInitialize(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL)
{

    UNREFERENCED_PARAMETER(pctx);

    switch (ulReason) {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hmod;
            DisableThreadLibraryCalls(g_hInstance);
            wHelpMessage = RegisterWindowMessage(TEXT("ShellHelp"));
            InitSchemesList();
            SHFusionInitializeFromModuleID(hmod, 124);
            break;

        case DLL_PROCESS_DETACH:
            SHFusionUninitialize();
            break;
    }
    return TRUE;
}


/*******************************************************************************
*
*  CplApplet
*
*  DESCRIPTION:
*   Called by control panel.
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT APIENTRY
CPlApplet(
    HWND hCPLWnd,
    UINT Message,
    LPARAM wParam,
    LPARAM lParam
    )
{
    LPNEWCPLINFO  lpNewCPLInfo;
    LPCPLINFO     lpCPlInfo;
    WNDCLASS      cls;
    DWORD         dwSize, dwSessionId, dwTry = 0;
    OSVERSIONINFO osvi;

    switch (Message) {

        case CPL_INIT:              // Is there an applet ?
            // Set OS global.
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_bRunningUnderNT = (osvi.dwMajorVersion >= 5) &&
                                (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);

            // If we're running under NT don't allow power management UI
            // unless we have power management capabilities.
            if (g_bRunningUnderNT) {
                if (!PowerCapabilities()) {
                    return FALSE;
                }
            }

            // Set global variables based on the machine capabilities.
            return InitCapabilities(&g_SysPwrCapabilities);

        case CPL_GETCOUNT:          // PowerCfg.Cpl supports one applet.
            return 1;

        case CPL_INQUIRE:           // Fill CplInfo structure
            lpCPlInfo = (LPCPLINFO)lParam;
            lpCPlInfo->idIcon = IDI_PWRMNG;
            lpCPlInfo->idName = IDS_APPNAME;
            lpCPlInfo->idInfo = IDS_INFO; // we have to use this in order to support infotips greater than 64 chars, which
                                          // is the max that the NEWCPLINFO struct supports
            lpCPlInfo->lData  = 0;
            return 1;

        case CPL_NEWINQUIRE:
            lpNewCPLInfo = (LPNEWCPLINFO)lParam;
            memset(lpNewCPLInfo, 0, sizeof(NEWCPLINFO));
            lpNewCPLInfo->dwSize = sizeof(NEWCPLINFO);
            lpNewCPLInfo->hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_PWRMNG));
            LoadString(g_hInstance, IDS_APPNAME, lpNewCPLInfo->szName, sizeof(lpNewCPLInfo->szName));
            LoadString(g_hInstance, IDS_INFO, lpNewCPLInfo->szInfo, sizeof(lpNewCPLInfo->szInfo));
            lstrcpy(lpNewCPLInfo->szHelpFile, TEXT(""));
            return 1;

        case CPL_DBLCLK:          // This applet has been chosen to run
        case CPL_STARTWPARMS:     // Started from RUNDLL

            // Initialize the common controls.
            InitCommonControls();

            // Sync the current scheme registry and PPM.
            SyncRegPPM();

            // Build the displayed pages base on system capabilities.
            BuildPages(&g_SysPwrCapabilities, g_TopLevelPages);

            // Will return FALSE if we didn't display any pages.
            return DoPropSheetPages(hCPLWnd, &(g_TopLevelPages[0]),
                                    g_szRegOptionalPages);

        case CPL_EXIT:            // This applet must die
        case CPL_STOP:
            break;

        case CPL_SELECT:          // This applet has been selected
            break;
    }

    return FALSE;
}


/*******************************************************************************
*
*  LoadDynamicString
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*  PARAMETERS:
*     StringID, resource identifier of the string to use.
*     (optional), parameters to use to format the string message.
*
*******************************************************************************/

LPTSTR CDECL LoadDynamicString( UINT StringID, ... )
{
    va_list Marker;
    TCHAR Buffer[256];
    LPTSTR pStr;
    int   iLen;

    // va_start is a macro...it breaks when you use it as an assign...on ALPHA.
    va_start(Marker, StringID);

    iLen = LoadString(g_hInstance, StringID, Buffer, ARRAYSIZE(Buffer));

    if (iLen == 0) {
        DebugPrint( "LoadDynamicString: LoadString on: %X failed", StringID);
        return NULL;
    }

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPVOID) (LPTSTR) Buffer, 0, 0, (LPTSTR) &pStr, 0, &Marker);

    return pStr;
}

/*******************************************************************************
*
*  DisplayFreeStr
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR DisplayFreeStr(HWND hWnd, UINT uID, LPTSTR  pStr, BOOL bFree)
{
    if (pStr) {
        SetDlgItemText(hWnd, uID, pStr);
        ShowWindow(GetDlgItem(hWnd, uID), SW_SHOWNOACTIVATE);
        if (bFree) {
            LocalFree(pStr);
            return NULL;
        }
    }
    else {
        ShowWindow(GetDlgItem(hWnd, uID), SW_HIDE);
    }
    return pStr;
}

/*******************************************************************************
*
*  ValidateUISchemeFields
*
*  DESCRIPTION:
*   Validate only the data values which are set by our UI.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ValidateUISchemeFields(PPOWER_POLICY ppp)
{
    POWER_POLICY pp;
    static PGLOBAL_POWER_POLICY pgpp;

    memcpy(&pp, ppp, sizeof(pp));

    if (ValidatePowerPolicies(NULL, &pp)) {

        if (g_SysPwrCapabilities.HiberFilePresent) {
            ppp->mach.DozeS4TimeoutAc = pp.mach.DozeS4TimeoutAc;
            ppp->mach.DozeS4TimeoutDc = pp.mach.DozeS4TimeoutDc;
        }

        if (g_SysPwrCapabilities.SystemS1 ||
            g_SysPwrCapabilities.SystemS2 ||
            g_SysPwrCapabilities.SystemS3) {
            ppp->user.IdleTimeoutAc = pp.user.IdleTimeoutAc;
            ppp->user.IdleTimeoutDc = pp.user.IdleTimeoutDc;
        }

        if (g_bVideoLowPowerSupported) {
            ppp->user.VideoTimeoutAc = pp.user.VideoTimeoutAc;
            ppp->user.VideoTimeoutDc = pp.user.VideoTimeoutDc;
        }

        if (g_SysPwrCapabilities.DiskSpinDown) {
             ppp->user.SpindownTimeoutAc = pp.user.SpindownTimeoutAc;
             ppp->user.SpindownTimeoutDc = pp.user.SpindownTimeoutDc;
        }
        return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*  GetGlobalPwrPolicy
*
*  DESCRIPTION:
*   Read the global power policy and validate only the data values which are
*   set by our UI.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetGlobalPwrPolicy(PGLOBAL_POWER_POLICY pgpp)
{
    int i;
    GLOBAL_POWER_POLICY gpp;

    if (ReadGlobalPwrPolicy(pgpp)) {

        memcpy(&gpp, pgpp, sizeof(gpp));

        if (ValidatePowerPolicies(&gpp, NULL)) {

            if (g_SysPwrCapabilities.PowerButtonPresent &&
                !g_SysPwrCapabilities.SleepButtonPresent) {
                pgpp->user.PowerButtonAc = gpp.user.PowerButtonAc;
                pgpp->user.PowerButtonDc = gpp.user.PowerButtonDc;
            }
            if (g_SysPwrCapabilities.LidPresent) {
                pgpp->user.LidCloseAc = gpp.user.LidCloseAc;
                pgpp->user.LidCloseDc = gpp.user.LidCloseDc;
            }
            if (g_SysPwrCapabilities.SystemBatteriesPresent) {
                for (i = 0; i < NUM_DISCHARGE_POLICIES; i++) {
                    pgpp->user.DischargePolicy[i] = gpp.user.DischargePolicy[i];
                }
            }
            pgpp->user.GlobalFlags = gpp.user.GlobalFlags;
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  ErrorMsgBox
*
*  DESCRIPTION:
*   Display a messag box for system message strings specified by dwErr and
*   title string specified by uiTitleID.
*
*  PARAMETERS:
*
*******************************************************************************/

int ErrorMsgBox(
    HWND    hwnd,
    DWORD   dwErr,
    UINT    uiTitleID)
{
   LPTSTR pszErr   = NULL;
   LPTSTR pszTitle = NULL;
   TCHAR  szUnknownErr[64];
   UINT   idRet;

   if (dwErr == NO_ERROR)
   {
      dwErr = GetLastError();
   }

   pszTitle = LoadDynamicString(uiTitleID);
   if (dwErr != NO_ERROR)
   {
      FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, dwErr, 0, (LPTSTR)&pszErr, 1, NULL);
   }

   if (NULL == pszErr)
   {
       LoadString(g_hInstance, IDS_UNKNOWN_ERROR, szUnknownErr, ARRAYSIZE(szUnknownErr));
       pszErr = szUnknownErr;
   }

   idRet = MessageBox(hwnd, pszErr, pszTitle, MB_ICONEXCLAMATION);
   if (pszTitle)
      LocalFree(pszTitle);

   if ((pszErr) && (pszErr != szUnknownErr))
      LocalFree(pszErr);

   return idRet;
}

/*******************************************************************************
*
*  WritePwrSchemeReport
*
*  DESCRIPTION:
*   Cover for WritePwrScheme with error reporting.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WritePwrSchemeReport(
    HWND            hwnd,
    PUINT           puiID,
    LPTSTR          lpszSchemeName,
    LPTSTR          lpszDescription,
    PPOWER_POLICY   lpScheme
)
{
   if (WritePwrScheme(puiID, lpszSchemeName, lpszDescription, lpScheme)) {
      return TRUE;
   }
   else {
      ErrorMsgBox(hwnd, NO_ERROR, IDS_UNABLETOSETPOLICY);
      return FALSE;
   }
}

/*******************************************************************************
*
*  WriteGlobalPwrPolicyReport
*
*  DESCRIPTION:
*   Cover for WriteGlobalPwrPolicy with error reporting.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WriteGlobalPwrPolicyReport(
    HWND                   hwnd,
    PGLOBAL_POWER_POLICY   pgpp,
    BOOL                    fDisplayErrorUI
)
{
   if (WriteGlobalPwrPolicy(pgpp))
   {
      return TRUE;
   }
   else
   {
       if (fDisplayErrorUI)
       {
            ErrorMsgBox(hwnd, NO_ERROR, IDS_UNABLETOSETGLOBALPOLICY);
       }

      return FALSE;
   }
}

/*******************************************************************************
*
*  SetActivePwrSchemeReport
*
*  DESCRIPTION:
*   Cover for WriteGlobalPwrPolicy with error reporting.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SetActivePwrSchemeReport(
    HWND                    hwnd,
    UINT                    uiID,
    PGLOBAL_POWER_POLICY    pgpp,
    PPOWER_POLICY           ppp)
{
   if (SetActivePwrScheme(uiID, pgpp, ppp)) {
      return TRUE;
   }
   else {
      ErrorMsgBox(hwnd, NO_ERROR, IDS_UNABLETOSETACTIVEPOLICY);
      return FALSE;
   }
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  BuildPages
*
*  DESCRIPTION:
*   Build the g_TopLevelPages array based on the machine capabilities. The
*   order of the tabs\pages is set here.
*
*  PARAMETERS:
*
*******************************************************************************/

int BuildPages(PSYSTEM_POWER_CAPABILITIES pspc, PPOWER_PAGES ppp)
{
    int     iPageCount = 1;     // We always have at least the power scheme page.


    // Do we have system batteries? Different dialog templates will be used
    // depending on the answer to this question.
    if (pspc->SystemBatteriesPresent) {
        AppendPropSheetPage(ppp, IDD_POWERSCHEME, PowerSchemeDlgProc);
        AppendPropSheetPage(ppp, IDD_ALARMPOLICY, AlarmDlgProc);
        iPageCount++;

        // Is there a battery driver that the battery meter can query?
        if (BatMeterCapabilities(&g_puiBatCount)) {
            AppendPropSheetPage(ppp, IDD_BATMETERCFG, BatMeterCfgDlgProc);
            iPageCount++;
        }
    }
    else {
        // No battery pages.
        AppendPropSheetPage(ppp, IDD_POWERSCHEME_NOBAT, PowerSchemeDlgProc);
    }

    // Always show the Advanced page.
    AppendPropSheetPage(ppp, IDD_ADVANCEDPOLICY, AdvancedDlgProc);
    iPageCount++;

    // Can we put up the hibernate page?
    if (pspc->SystemS4) {
        AppendPropSheetPage(ppp, IDD_HIBERNATE, HibernateDlgProc);
        iPageCount++;
    }

#ifdef WINNT
    if (pspc->ApmPresent) {
        //
        // Is APM present on the machine?  This page is
        // not shown if ACPI is present
        //
        AppendPropSheetPage(ppp, IDD_APM, APMDlgProc);
        iPageCount++;
    }

    if (pspc->UpsPresent) {
        AppendPropSheetPage(ppp, IDD_UPS, UPSMainPageProc);
        iPageCount++;
    }

#endif

    return iPageCount;
}

/*******************************************************************************
*
*  InitCapabilities
*
*  DESCRIPTION:
*   Call down to the PPM to get power management capabilities and set
*   global variables based on the results.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL InitCapabilities(PSYSTEM_POWER_CAPABILITIES pspc)
{
    UINT i, uiGran = 0, uiMax, uiMin;
    ADMINISTRATOR_POWER_POLICY app;
    int   dummy;

    // Set hard limits. These may be overridden by optional registry values.
    g_uiVideoTimeoutMaxMin = MAKELONG((short) MAX_VIDEO_TIMEOUT, (short) 1);
    g_uiSpindownMaxMin     = MAKELONG((short) MAX_SPINDOWN_TIMEOUT,(short) 1);

    g_dwNumSleepStates = 0;
    if (!GetPwrCapabilities(pspc)) {
            return FALSE;
    }


    if (pspc->SystemS1) {
            g_dwNumSleepStates++;
    }

    if (pspc->SystemS2) {
            g_dwNumSleepStates++;
    }

    if (pspc->SystemS3) {
            g_dwNumSleepStates++;
    }

    if (pspc->SystemS4) {
            g_dwNumSleepStates++;
    }

    // Get administrator overrides if present.
    if (IsAdminOverrideActive(&app)) {
        if (app.MaxVideoTimeout > -1) {
            uiMin = LOWORD(g_uiVideoTimeoutMaxMin);
            uiMax = app.MaxVideoTimeout;
            g_uiVideoTimeoutMaxMin = MAKELONG((short) uiMax,(short) uiMin);
        }

        if (app.MaxSleep < PowerSystemHibernate) {
            g_dwNumSleepStates = (DWORD)app.MaxSleep;
        }
    }

    // Get the optional disk spindown timeout range.
    if (GetPwrDiskSpindownRange(&uiMax, &uiMin)) {
        g_uiSpindownMaxMin = MAKELONG((short) uiMax,(short) uiMin);
    }

    if (g_dwNumSleepStates > 1) {
        g_dwSleepStatesMaxMin =
            MAKELONG((short) 0, (short) g_dwNumSleepStates - 1);
    }

    g_dwBattryLevelMaxMin = MAKELONG((short)0, (short)100);

    g_dwFanThrottleMaxMin =  MAKELONG((short)0, (short)100);


    // Call will fail if monitor or adapter don't support DPMS.
    g_bVideoLowPowerSupported = SystemParametersInfo(SPI_GETLOWPOWERACTIVE,
                                                     0, &dummy, 0);
    if (!g_bVideoLowPowerSupported) {
        g_bVideoLowPowerSupported = SystemParametersInfo(SPI_GETPOWEROFFACTIVE,
                                                         0, &dummy, 0);
    }

#ifdef WINNT
    //
    // Check to see if APM is present
    //
    pspc->ApmPresent = IsNtApmPresent(pspc);
    pspc->UpsPresent = IsUpsPresent(pspc);
#endif

    return TRUE;
}

/*******************************************************************************
*
*  SyncRegPPM
*
*  DESCRIPTION:
*   Call down to the PPM to get the current power policies and write them
*   to the registry. This is done in case the PPM is out of sync with the
*   PowerCfg registry settings. Requested by JVert.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID SyncRegPPM(VOID)
{
   GLOBAL_POWER_POLICY  gpp;
   POWER_POLICY         pp;
   UINT                 uiID, uiFlags = 0;

   if (ReadGlobalPwrPolicy(&gpp)) {
       uiFlags = gpp.user.GlobalFlags;
   }

   if (GetActivePwrScheme(&uiID)) {
      // Get the current PPM settings.
      if (GetCurrentPowerPolicies(&gpp, &pp)) {
         SetActivePwrScheme(uiID, &gpp, &pp);
      }
   }

   gpp.user.GlobalFlags |= uiFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\powercfg.inc ===
#
#  Common settings for powercfg
#

CCSHELL_DIR=$(PROJECT_ROOT)
!include $(PROJECT_ROOT)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(PROJECT_ROOT)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ntapm.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       NTAPM.C
*
*  VERSION:     2.0
*
*  AUTHOR:      Patrickf
*
*  DATE:        09 November, 1998
*
*  DESCRIPTION:
*   Implements the "APM" tab of the Power Management CPL Applet.
*
*******************************************************************************/
#ifdef WINNT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <help.h>
#include <powercfp.h>
#include "powercfg.h"
#include "pwrresid.h"
#include "PwrMn_cs.h"
#include "ntapm.h"

BOOL    g_fDirty       = FALSE;     // Has state changed since last apply?

CHAR    RegPropBuff[MAX_PATH];
TCHAR   CharBuffer[MAX_PATH];

TCHAR   m_szApmActive[]     = TEXT ("Start");
TCHAR   m_szApmActiveKey[]  = TEXT("System\\CurrentControlSet\\Services\\NtApm");
TCHAR   m_szACPIActive[]    = TEXT ("Start");
TCHAR   m_szACPIActiveKey[] = TEXT("System\\CurrentControlSet\\Services\\ACPI");

extern HINSTANCE g_hInstance;           // Global instance handle of this DLL.

const DWORD g_NtApmHelpIDs[]=
{
    IDC_APMENABLE,          IDH_ENABLE_APM_SUPPORT,   // Save Scheme: "Save Name Power scheme"
    0, 0
};


/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

/*******************************************************************************
*
*   NtApmEnableAllPrivileges
*
*   DESCRIPTION:  This function is used to allow this thread to shudown the
*                 system.
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL NtApmEnableAllPrivileges()
{
    BOOL                Result = FALSE;
    ULONG               ReturnLen;
    ULONG               Index;

    HANDLE              Token = NULL;
    PTOKEN_PRIVILEGES   NewState = NULL;


    //
    // Open Process Token
    //
    Result = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &Token);

    if (Result) {
        ReturnLen = 4096;
        NewState = LocalAlloc(LMEM_FIXED, ReturnLen);

        if (NewState != NULL) {
            Result =  GetTokenInformation(Token, TokenPrivileges, NewState, ReturnLen, &ReturnLen);
            if (Result) {
                if (NewState->PrivilegeCount > 0) {
                    for (Index=0; Index < NewState->PrivilegeCount; Index++) {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges(Token, FALSE, NewState, ReturnLen, NULL, &ReturnLen);
            }
        }
    }

    if (NewState != NULL) {
        LocalFree(NewState);
    }

    if (Token != NULL) {
        CloseHandle(Token);
    }

    return(Result);
}

/*******************************************************************************
*
*   NtApmACPIEnabled
*
*   DESCRIPTION:  This function gets called to determine if APM is present on
*                 and started on the machine.   If APM is present then the
*                 tab needs to appear.
*
*                 This functions check for ACPI, MP and then if APM is actually
*                 on the machine.  If ACPI and MP then APM may be running but is
*                 disabled.
*
*   RETURNS:      TRUE if APM is present, FALSE if APM is no present
*
*******************************************************************************/
BOOL NtApmACPIEnabled()
{
    BOOL        RetVal;
    DWORD       CharBufferSize;
    DWORD       ACPIStarted;
    HKEY        hPortKey;

    //
    // Initialize - Assume the machine is not ACPI
    //
    RetVal = FALSE;


    //
    // Check if ACPI is Present on the machine.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     m_szACPIActiveKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hPortKey) != ERROR_SUCCESS) {

    } else if (RegQueryValueEx(hPortKey,
                               m_szACPIActive,
                               NULL,
                               NULL,
                               (PBYTE) CharBuffer,
                               &CharBufferSize) != ERROR_SUCCESS) {

        RegCloseKey(hPortKey);

    } else {
        ACPIStarted = (DWORD) CharBuffer[0];

        if (ACPIStarted == SERVICE_BOOT_START) {
            RetVal = TRUE;
        }
        RegCloseKey(hPortKey);
    }

    return(RetVal);
}

/*******************************************************************************
*
*   NtApmTurnOnDiFlags
*
*   DESCRIPTION: This function sets the DI flags
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL
NtApmTurnOnDiFlags (
        HDEVINFO ApmDevInfo,
        PSP_DEVINFO_DATA ApmDevInfoData,
        DWORD FlagsMask)
{
    BOOL                    RetVal;
    SP_DEVINSTALL_PARAMS    DevParams;

    //
    // Turn on Device Interface flags
    //
    DevParams.cbSize = sizeof(DevParams);
    RetVal = SetupDiGetDeviceInstallParams(ApmDevInfo,
                                            ApmDevInfoData, &DevParams);

    if (RetVal) {
        DevParams.Flags |= FlagsMask;
        RetVal = SetupDiSetDeviceInstallParams(ApmDevInfoData,
                                                NULL, &DevParams);
    }

    return(RetVal);
}

/*******************************************************************************
*
*   NtApmTurnOffDiFlags
*
*   DESCRIPTION: This function sets the DI flags
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL
NtApmTurnOffDiFlags (
        HDEVINFO ApmDevInfo,
        PSP_DEVINFO_DATA ApmDevInfoData,
        DWORD FlagsMask)
{
    BOOL                    RetVal;
    SP_DEVINSTALL_PARAMS    DevParams;

    //
    // Turn on Device Interface flags
    //
    DevParams.cbSize = sizeof(DevParams);
    RetVal = SetupDiGetDeviceInstallParams(ApmDevInfo,
                                            ApmDevInfoData, &DevParams);

    if (RetVal) {
        DevParams.Flags &= ~FlagsMask;
        RetVal = SetupDiSetDeviceInstallParams(ApmDevInfoData,
                                                NULL, &DevParams);
    }

    return(RetVal);
}

/*******************************************************************************
*
*   NtApmGetHwProfile
*
*   DESCRIPTION: This function is called to retrieve the current H/W Profile
*
*   PARAMETERS:  Pointer to store HW Profile Info
*
*
*******************************************************************************/
BOOL NtApmGetHwProfile(
    DWORD           ProfIdx,
    HWPROFILEINFO   *NtApmHwProf)
{
    CONFIGRET       CmRetVal;

    CmRetVal = CM_Get_Hardware_Profile_Info_Ex(ProfIdx, NtApmHwProf, 0, NULL);

    if (CmRetVal == CR_SUCCESS) {
        return(TRUE);
    } else {
        return(FALSE);
    }

}

/*******************************************************************************
*
*   NtApmCleanup
*
*   DESCRIPTION:  This function is called to Destroy the DevInfo and DevInfoData
*                 list that were created.
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL NtApmCleanup(
    HDEVINFO         NtApmDevInfo,
    PSP_DEVINFO_DATA NtApmDevInfoData)
{

    SetupDiDeleteDeviceInfo(NtApmDevInfo, NtApmDevInfoData);
    SetupDiDestroyDeviceInfoList(NtApmDevInfo);

    return(TRUE);

}

/*******************************************************************************
*
*   NtApmGetDevInfo
*
*   DESCRIPTION:  This function is called to retrieve the HDEVINFO for NTAPM
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL NtApmGetDevInfo(
    HDEVINFO         *NtApmDevInfo,
    PSP_DEVINFO_DATA NtApmDevInfoData)
{
    BOOL    RetVal = FALSE;          // Assume Failure

    *NtApmDevInfo =
        SetupDiGetClassDevsEx((LPGUID)&GUID_DEVCLASS_APMSUPPORT, NULL, NULL,
                                              DIGCF_PRESENT, NULL, NULL, NULL);

    if(*NtApmDevInfo != INVALID_HANDLE_VALUE) {

        //
        // Retrieve the DEVINFO_DATA for APM
        //
        NtApmDevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
        if (!SetupDiEnumDeviceInfo(*NtApmDevInfo, 0, NtApmDevInfoData)) {
            SetupDiDestroyDeviceInfoList(*NtApmDevInfo);
        } else {
            RetVal = TRUE;
        }
    }

    return(RetVal);
}

/*******************************************************************************
*
*   NtApmDisable
*
*   DESCRIPTION:  This function is called to Disable NT APM
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL NtApmDisable()
{
    DWORD                   ii;
    BOOL                    Canceled;
    SP_PROPCHANGE_PARAMS    pcp;

    HDEVINFO                NtApmDevInfo;
    SP_DEVINFO_DATA         NtApmDevInfoData;
    HWPROFILEINFO           NtApmHwProfile;



    //
    // Get handles to the device and the device information
    // If unable to get Device Info immediately return.
    //
    if (!NtApmGetDevInfo(&NtApmDevInfo, &NtApmDevInfoData)) {
        return(FALSE);
    }

    //
    // Turn on the Device Interface Flags
    //
    NtApmTurnOnDiFlags(NtApmDevInfo, &NtApmDevInfoData, DI_NODI_DEFAULTACTION);

    //
    // Ask the class installer if the device can be generally enabled/disabled
    //
    pcp.StateChange = DICS_DISABLE;
    pcp.Scope       = DICS_FLAG_CONFIGGENERAL;

    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
        goto NtApmDisableError;
    }

    if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                       NtApmDevInfo, &NtApmDevInfoData)) {
        goto NtApmDisableError;
    }

    Canceled = (ERROR_CANCELLED == GetLastError());

    if (!Canceled) {
        pcp.Scope       = DICS_FLAG_CONFIGSPECIFIC;
        pcp.StateChange = DICS_DISABLE;

        for (ii=0; NtApmGetHwProfile(ii, &NtApmHwProfile); ii++) {
            pcp.HwProfile = NtApmHwProfile.HWPI_ulHWProfile;

            if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                    (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
                goto NtApmDisableError;
            }

            if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE, NtApmDevInfo, &NtApmDevInfoData)) {
                goto NtApmDisableError;
            }

            Canceled = (ERROR_CANCELLED == GetLastError());

            if (!Canceled) {
                if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
                    goto NtApmDisableError;
                }

                if (!SetupDiChangeState(NtApmDevInfo, &NtApmDevInfoData)) {
                    goto NtApmDisableError;
                }
            }
        }
    }

    //
    // Turn off Flags
    //
    NtApmTurnOnDiFlags(NtApmDevInfo, &NtApmDevInfoData, DI_PROPERTIES_CHANGE);
    if (!SetupDiSetClassInstallParams(NtApmDevInfo, NULL, NULL, 0)) {
        goto NtApmDisableError;
    }
    NtApmTurnOffDiFlags(NtApmDevInfo, &NtApmDevInfoData, DI_NODI_DEFAULTACTION);
    NtApmCleanup(NtApmDevInfo, &NtApmDevInfoData);
    return(TRUE);

NtApmDisableError:
    NtApmCleanup(NtApmDevInfo, &NtApmDevInfoData);
    return (FALSE);

}

/*******************************************************************************
*
*   NtApmEnable
*
*   DESCRIPTION:  This function is called to Enable NT APM
*
*   PARAMETERS:
*
*
*******************************************************************************/
BOOL NtApmEnable()
{
    DWORD                   ii;
    BOOL                    Canceled;
    SP_PROPCHANGE_PARAMS    pcp;

    HDEVINFO                NtApmDevInfo;
    SP_DEVINFO_DATA         NtApmDevInfoData;
    HWPROFILEINFO           NtApmHwProfile;



    //
    // Get handles to the device and the device information
    // (If unable to get Device Info immediately return)
    //
    if (!NtApmGetDevInfo(&NtApmDevInfo, &NtApmDevInfoData)) {
        return(FALSE);
    }

    //
    // Turn on the Device Interface Flags
    //
    NtApmTurnOnDiFlags(NtApmDevInfo, &NtApmDevInfoData, DI_NODI_DEFAULTACTION);

    //
    // Ask the class installer if the device can be generally enabled/disabled
    //
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope       = DICS_FLAG_CONFIGGENERAL;

    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                 (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
        goto NtApmEnableError;
    }

    if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                        NtApmDevInfo, &NtApmDevInfoData)) {
        goto NtApmEnableError;
    }

    Canceled = (ERROR_CANCELLED == GetLastError());

    if (!Canceled) {
        pcp.Scope       = DICS_FLAG_CONFIGSPECIFIC;
        pcp.StateChange = DICS_ENABLE;

        for (ii=0; NtApmGetHwProfile(ii, &NtApmHwProfile); ii++) {
            pcp.HwProfile = NtApmHwProfile.HWPI_ulHWProfile;

            if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                    (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
                goto NtApmEnableError;
            }

            if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE, NtApmDevInfo, &NtApmDevInfoData)) {
                goto NtApmEnableError;
            }

            Canceled = (ERROR_CANCELLED == GetLastError());

            //
            // If still good, keep going
            //
            if (!Canceled) {
                if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
                    goto NtApmEnableError;
                }

                if (!SetupDiChangeState(NtApmDevInfo, &NtApmDevInfoData)) {
                    goto NtApmEnableError;
                }

                //
                // This call will start the device if it is not started
                //
                pcp.Scope = DICS_FLAG_GLOBAL;
                if (!SetupDiSetClassInstallParams(NtApmDevInfo, &NtApmDevInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&pcp, sizeof(pcp))) {
                    goto NtApmEnableError;
                }

                if (!SetupDiChangeState(NtApmDevInfo, &NtApmDevInfoData)) {
                    goto NtApmEnableError;
                }
            }
        }
    }

    NtApmTurnOnDiFlags(NtApmDevInfo, &NtApmDevInfoData, DI_PROPERTIES_CHANGE);
    SetupDiSetClassInstallParams(NtApmDevInfo, NULL, NULL, 0);
    NtApmTurnOffDiFlags(NtApmDevInfo, &NtApmDevInfoData, DI_NODI_DEFAULTACTION);

    NtApmCleanup(NtApmDevInfo, &NtApmDevInfoData);
    return(TRUE);

NtApmEnableError:
    NtApmCleanup(NtApmDevInfo, &NtApmDevInfoData);
    return (FALSE);

}


/*******************************************************************************
*
*   NtApmEnabled
*
*   DESCRIPTION:  This function is used to determine if APM is actually
*                 Enabled or Disabled.
*
*   PARAMETERS:   hDlg - handle to the dialog box.
*                 fEnable - TRUE if APM is to be enabled, FALSE if APM is to
*                 be disabled.
*
*
*******************************************************************************/
NtApmEnabled()
{
    DWORD                   Err;
    DWORD                   HwProf;
    DWORD                   pFlags;
    DWORD                   GlobalConfigFlags;

    SP_PROPCHANGE_PARAMS    pcp;
    HDEVINFO                NtApmDevInfo;
    SP_DEVINFO_DATA         NtApmDevInfoData;
    CONFIGRET               CmRetVal;
    HWPROFILEINFO           HwProfileInfo;
    TCHAR                   DeviceId[MAX_DEVICE_ID_LEN + 1];

    //
    // Registry Property Variables
    //
    DWORD                   RegProp;
    DWORD                   RegPropType;
    DWORD                   RegPropBuffSz;

    //
    // Retrieve the Handle the Device Information for APM.
    //
    if (!NtApmGetDevInfo(&NtApmDevInfo, &NtApmDevInfoData)) {
        return (FALSE);
    }

    //
    // Get the Global Flags (Just-in-case it is globally enabled)
    //
    RegProp       = SPDRP_CONFIGFLAGS;
    RegPropBuffSz = sizeof(RegPropBuff) + 1;
    if (SetupDiGetDeviceRegistryProperty(NtApmDevInfo, &NtApmDevInfoData,
                                            RegProp, &RegPropType,
                                            RegPropBuff, RegPropBuffSz, 0))
    {
        if (RegPropType != REG_DWORD) {
            GlobalConfigFlags = 0;
        } else {
            GlobalConfigFlags = (DWORD) RegPropBuff[0];
        }

        //
        // Only Want the disabled bit
        //
        GlobalConfigFlags = GlobalConfigFlags & CONFIGFLAG_DISABLED;
    }

    //
    // Get the current HW Profile
    //
    if (!NtApmGetHwProfile(0xffffffff, &HwProfileInfo)) {
        goto NtApmEnabledError;
    }

    //
    // Get the Device ID for the given profile
    //
    HwProf   = HwProfileInfo.HWPI_ulHWProfile;
    CmRetVal = CM_Get_Device_ID_Ex(NtApmDevInfoData.DevInst,
                                    DeviceId, sizeof(DeviceId), 0, NULL);

    if (CmRetVal != CR_SUCCESS) {
        Err = GetLastError();
        goto NtApmEnabledError;
    }

    //
    // Now get the flags
    //
    CmRetVal = CM_Get_HW_Prof_Flags_Ex((LPTSTR)DeviceId,
                                        HwProf, &pFlags, 0, NULL);

    if (CmRetVal != CR_SUCCESS) {
        Err = GetLastError();
        goto NtApmEnabledError;
    }


    NtApmCleanup(NtApmDevInfo, &NtApmDevInfoData);
    if (GlobalConfigFlags || (pFlags & CSCONFIGFLAG_DISABLED)) {
        return(FALSE);
    } else {
        return(TRUE);
    }

NtApmEnabledError:
    NtApmCleanup(NtApmDevInfo, &NtApmDevInfoData);
    return(FALSE);
}


/*******************************************************************************
*
*   NtApmToggle
*
*   DESCRIPTION:  This function gets called when the user clicks OK or Apply
*                 and does the work of enabling or disabling APM support.
*
*   PARAMETERS:   fEnable - Indicates if APM is to enabled or disabled
*                 SilentDisable - Do not put up dialog to reboot machine.
*
*
*******************************************************************************/
BOOL
NtApmToggle(
    IN BOOL fEnable,
    IN BOOL SilentDisable)
{
    int     MBoxRetVal;
    TCHAR   Str1[2048];
    TCHAR   Str2[2048];

    if (fEnable == APM_ENABLE) {
        NtApmEnable();
    } else {
        if (NtApmDisable()) {

            if (!SilentDisable) {
                LoadString(g_hInstance, IDS_DEVCHANGE_RESTART, (LPTSTR) Str1, ARRAYSIZE(Str1));
                LoadString(g_hInstance, IDS_DEVCHANGE_CAPTION, (LPTSTR) Str2, ARRAYSIZE(Str2));

                MBoxRetVal = MessageBox(NULL, Str1, Str2, MB_ICONQUESTION | MB_YESNO);

                if (MBoxRetVal == IDYES) {
                    NtApmEnableAllPrivileges();
                    ExitWindowsEx(EWX_REBOOT | EWX_FORCEIFHUNG, 0);
                }
            }
        }
    }

    // Return TRUE for success, FALSE for failure
    return(TRUE);
}


/*******************************************************************************
*
*   APMDlgHandleInit
*
*   DESCRIPTION:  Handles WM_INITDIALOG messages sent to APMDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
APMDlgHandleInit(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{

    CheckDlgButton( hDlg,
                    IDC_APMENABLE,
                    NtApmEnabled() ? BST_CHECKED : BST_UNCHECKED);
    return(TRUE);
}

/*******************************************************************************
*
*   APMDlgHandleCommand
*
*   DESCRIPTION:  Handles WM_COMMAND messages sent to APMDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
APMDlgHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL    RetVal;
    WORD    idCtl   = LOWORD(wParam);
    WORD    wNotify = HIWORD(wParam);

    //
    // Assume there is nothing to do and return false;
    //
    RetVal = FALSE;

    switch (idCtl) {
        case IDC_APMENABLE:
            if (BN_CLICKED == wNotify) {
                //
                // State changed.  Enable the Apply button.
                //
                g_fDirty = TRUE;
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            RetVal = TRUE;
            break;

        default:
            break;
    }

    return(RetVal);
}

/*******************************************************************************
*
*   APMDlgHandleNotify
*
*   DESCRIPTION:  Handles WM_NOTIFY messages sent to APMDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
APMDlgHandleNotify(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    int idCtl = (int) wParam;
    LPNMHDR pnmhdr = (LPNMHDR) lParam;
    UINT uNotify = pnmhdr->code;
    BOOL fResult;

    switch (uNotify) {
        case PSN_APPLY:
            if (g_fDirty) {
                if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_APMENABLE)) {
                    fResult = NtApmToggle(APM_ENABLE, FALSE);
                } else {
                    fResult = NtApmToggle(APM_DISABLE, FALSE);
                }

                if (fResult) {
                    g_fDirty = FALSE;
                }

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT,
                        fResult ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);
            }

            return(TRUE);
            break;

        default:
            return(FALSE);
            break;
    }

    return(FALSE);
}

/*******************************************************************************
*
*   IsNtApmPresent
*
*   DESCRIPTION:  This function gets called to determine if APM is present on
*                 and started on the machine.   If APM is present then the
*                 tab needs to appear.
*
*                 This functions check for ACPI, MP and then if APM is actually
*                 on the machine.  If ACPI and MP then APM may be running but is
*                 disabled.
*
*   RETURNS:      TRUE if APM is present, FALSE if APM is no present
*
*
*******************************************************************************/
BOOLEAN IsNtApmPresent(PSYSTEM_POWER_CAPABILITIES pspc)
{
    BOOLEAN         RetVal;

    BOOL            APMMachine;
    BOOL            ACPIMachine;
    BOOL            MPMachine;

    DWORD           CharBufferSize;
    DWORD           ApmStarted;
    HKEY            hPortKey;
    SYSTEM_INFO     SystemInfo;

    //
    // Assume nothing about the machine
    //
    ACPIMachine     = FALSE;
    MPMachine       = FALSE;
    APMMachine      = FALSE;
    CharBufferSize  = sizeof(CharBuffer);

    //
    // We do the following checks:
    //
    //      * check for ACPI
    //      * check for MP system
    //
    if (NtApmACPIEnabled()) {
        ACPIMachine = TRUE;

    } else {
        GetSystemInfo(&SystemInfo);
        if (SystemInfo.dwNumberOfProcessors > 1) {
            MPMachine = TRUE;
        }
    }

    //
    // If the machine is ACPI or MP we still need to check if APM
    // is enabled so that we can disable it.  This is a bug in APM
    // code, but it is easiest to just fix it up here.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     m_szApmActiveKey,
                     0,
                     KEY_ALL_ACCESS,
                     &hPortKey) != ERROR_SUCCESS) {

    } else if (RegQueryValueEx(hPortKey,
                               m_szApmActive,
                               NULL,
                               NULL,
                               (PBYTE) CharBuffer,
                               &CharBufferSize) != ERROR_SUCCESS) {

        RegCloseKey(hPortKey);
    } else {
        if (CharBuffer[0] != (TCHAR) 0) {
            ApmStarted = (DWORD) CharBuffer[0];

            if (ApmStarted != SERVICE_DISABLED) {
                APMMachine = TRUE;
            }
        }
        RegCloseKey(hPortKey);
    }


    //
    // If APM is Present and Enabled it needs to be
    // silently disabled if the machine is ACPI or MP.
    //
    if (ACPIMachine || MPMachine) {
        if (APMMachine && NtApmEnabled()) {
            NtApmToggle(APM_DISABLE, TRUE);
        }
        RetVal = FALSE;

    } else if (APMMachine) {
        RetVal = TRUE;

    } else {
        RetVal = FALSE;

    }

    return(RetVal);
}

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/


/*******************************************************************************
*
*   APMDlgProc
*
*   DESCRIPTION:
*
*   PARAMETERS:
*
*******************************************************************************/
INT_PTR CALLBACK APMDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) {
    case WM_INITDIALOG:
        return(APMDlgHandleInit(hDlg, wParam, lParam));
        break;

    case WM_COMMAND:
        return(APMDlgHandleCommand(hDlg, wParam, lParam));
        break;

    case WM_NOTIFY:
        return(APMDlgHandleNotify(hDlg, wParam, lParam));
        break;


    case WM_HELP:             // F1
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP,
                        HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_NtApmHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_NtApmHelpIDs);
        return TRUE;

    default:
        return(FALSE);
        break;
    } // switch (uMsg)

    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\prshthlp.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       PRSHTHLP.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        6 May, 1997
*
*  DESCRIPTION:
*   Property sheet helper functions.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <help.h>

#include "powercfg.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern  HINSTANCE   g_hInstance;    // Global instance handle of this DLL.

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  AppendPropSheetPage
*
*  DESCRIPTION:
*   Append a power page entry to an array of power pages.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL AppendPropSheetPage(
    PPOWER_PAGES    pppArray,
    UINT            uiDlgId,
    DLGPROC         pfnDlgProc
)
{
        UINT    i = 0;

    // Find the end.
    while (pppArray[++i].pfnDlgProc);

    pppArray[i].pfnDlgProc   = pfnDlgProc;
    pppArray[i].pDlgTemplate = MAKEINTRESOURCE(uiDlgId);
    return TRUE;
}

/*******************************************************************************
*
*  GetNumPropSheetPages
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetNumPropSheetPages(
    PPOWER_PAGES    pppArray
)
{
    UINT    i = START_OF_PAGES;

    // Find the end.
    while (pppArray[i++].pfnDlgProc);

    return i - 1;
}

/*******************************************************************************
*
*  _AddPowerPropSheetPage
*
*  DESCRIPTION:
*   Adds optional pages for outside callers.

*  PARAMETERS:
*
*******************************************************************************/

BOOL CALLBACK _AddPowerPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *)lParam;

    if (hpage && (ppsh->nPages < MAX_PAGES )) {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*  DoPropSheetPages
*
*  DESCRIPTION:
*   Bring up the specified property sheet pages. Return FALSE if no pages
*   were displayed.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PASCAL DoPropSheetPages(
    HWND         hwnd,
    POWER_PAGES  PowerPages[],
    LPTSTR       lpszOptionalPages
)
{
    HPROPSHEETPAGE  rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;

    HPSXA   hpsxa = NULL;
    ULONG   uPage;
    BOOLEAN bRet = TRUE;

    // Fill in the sheet header
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = hwnd;
    psh.hInstance  = g_hInstance;

    psh.pszCaption = PowerPages[CAPTION_INDEX].pDlgTemplate;
    psh.nStartPage = 0;
    psh.nPages     = 0;
    psh.phpage     = rPages;

    // Fill in the page constants
    psp.dwSize     = sizeof(PROPSHEETPAGE);
    psp.dwFlags    = PSP_DEFAULT;
    psp.hInstance  = g_hInstance;

    for (uPage = START_OF_PAGES; uPage < MAX_PAGES; uPage++) {

        if (PowerPages[uPage].pDlgTemplate == NULL) {
            break;
        }

        (PPOWER_PAGES)psp.lParam    = &(PowerPages[uPage]);
        psp.pszTemplate             = PowerPages[uPage].pDlgTemplate;
        psp.pfnDlgProc              = PowerPages[uPage].pfnDlgProc;

        rPages[psh.nPages] = CreatePropertySheetPage(&psp);
        PowerPages[uPage].hPropSheetPage = rPages[psh.nPages];

        if (rPages[psh.nPages] != NULL) {
            psh.nPages++;
        }
    }

    // Add any optional pages specified in the registry.
    if (lpszOptionalPages) {
        hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE,
                                          lpszOptionalPages, MAX_PAGES);
        if (hpsxa) {
            SHAddFromPropSheetExtArray(hpsxa, _AddPowerPropSheetPage, (LPARAM)&psh);
        }
    }

    // Did we come up with any pages to show ?
    if (psh.nPages == 0) {
        return FALSE;
    }

    // Bring up the pages.
    if (PropertySheet(&psh) < 0) {
        DebugPrint( "DoPropSheetPages, PropertySheet failed, LastError: 0x%08X", GetLastError());
        bRet = FALSE;
    }

    // Free any optional pages if we loaded them.
    if (hpsxa) {
        SHDestroyPropSheetExtArray(hpsxa);
    }
    return bRet;
}

/*******************************************************************************
*
*  MarkSheetDirty
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID MarkSheetDirty(HWND hWnd, PBOOL pb)
{
    SendMessage(GetParent(hWnd), PSM_CHANGED, (WPARAM)hWnd, 0L);
    *pb = TRUE;
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\pwrmn_cs.h ===
// "Power Schemes" Dialog Box (IDD_POWERSCHEME == 100)

#define IDH_100_1000	65536100	// Power Schemes: "Power schemes" (ComboBox)
#define IDH_100_1001	65601636	// Power Schemes: "&Save As..." (Button)
#define IDH_100_1002	65667172	// Power Schemes: "&Delete" (Button)
#define IDH_100_1004	65798244	// Power Schemes: "Settings for groupbox" (Button)
// #define IDH_100_1011	66256996	// Power Schemes: "When computer is:" (Static)
// #define IDH_100_1012	66322532	// Power Schemes: "Plugged in" (Static)
// #define IDH_100_1013	66388068	// Power Schemes: "Running on batteries" (Static)
#define IDH_100_1009	66125924	// Power Schemes: "Go on s&tandby:" (Static)
#define IDH_100_1005	65863780	// Power Schemes: "Standby AC time" (ComboBox)
#define IDH_100_1006	65929316	// Power Schemes: "Standby DC time" (ComboBox)
#define IDH_100_1010	66191460	// Power Schemes: "Turn off &monitor:" (Static)
#define IDH_100_1007	65994852	// Power Schemes: "Monitor AC time" (ComboBox)
#define IDH_100_1008	66060388	// Power Schemes: "Monitor DC time" (ComboBox)
#define IDH_100_1003	65732708	// Power Schemes: "Ad&vanced..." (Button)


// "Power Schemes" Dialog Box (IDD_POWERSCHEME_NOBAT == 101)

#define IDH_101_1000	65536101	// Power Schemes: "Power schemes" (ComboBox)
#define IDH_101_1001	65601637	// Power Schemes: "&Save As..." (Button)
#define IDH_101_1002	65667173	// Power Schemes: "&Delete" (Button)
#define IDH_101_1004	65798245	// Power Schemes: "Settings for groupbox" (Button)
#define IDH_101_1009	66125925	// Power Schemes: "Go on s&tandby:" (Static)
#define IDH_101_1005	65863781	// Power Schemes: "Standby AC time" (ComboBox)
#define IDH_101_1010	66191461	// Power Schemes: "Turn off &monitor:" (Static)
#define IDH_101_1007	65994853	// Power Schemes: "Monitor AC time" (ComboBox)
#define IDH_101_1003	65732709	// Power Schemes: "Ad&vanced..." (Button)


// "Advanced Power Scheme Settings" Dialog Box (IDD_ADVPOWERSCHEME == 107)

#define IDH_107_1504	98566251	// Advanced Power Scheme Settings: "Adv Settings for groupbox" (Button)
#define IDH_107_1500	98304107	// Advanced Power Scheme Settings: "Prompt for &password when bringing computer out of standby." (Button)
// #define IDH_107_1011	66257003	// Advanced Power Scheme Settings: "When computer is:" (Static)
// #define IDH_107_1012	66322539	// Advanced Power Scheme Settings: "Plugged in" (Static)
// #define IDH_107_1013	66388075	// Advanced Power Scheme Settings: "Running on batteries" (Static)
#define IDH_107_1509	98893931	// Advanced Power Scheme Settings: "Turn off hard &disks:" (Static)
#define IDH_107_1505	98631787	// Advanced Power Scheme Settings: "Disk off time AC" (ComboBox)
#define IDH_107_1506	98697323	// Advanced Power Scheme Settings: "Disk off time DC" (ComboBox)
// #define IDH_107_1510	98959467	// Advanced Power Scheme Settings: "&Optimize for:" (Static)
// #define IDH_107_1507	98762859	// Advanced Power Scheme Settings: "Optimize time AC" (ComboBox)
// #define IDH_107_1508	98828395	// Advanced Power Scheme Settings: "Optimize time DC" (ComboBox)




// "Advanced Power Scheme Settings" Dialog Box (IDD_ADVPOWERSCHEME_NOBAT == 108)

#define IDH_108_1500    98304108    // Advanced Power Scheme Settings: "Prompt for &password when bringing computer out of standby." (Check box)
#define IDH_108_1503    98566253    // Advanced Power Scheme Settings: "Dim display when running on batteries." (CheckBox)
#define IDH_108_1504    98566252    // Advanced Power Scheme Settings: "Adv Settings for groupbox" (Button)
#define IDH_108_1505    98631788    // Advanced Power Scheme Settings: "Disk off time AC" (ComboBox)
#define IDH_108_1509    98893932    // Advanced Power Scheme Settings: "Turn off hard &disks:" (Static)
// #define IDH_108_1510	98959468	// Advanced Power Scheme Settings: "&Optimize for:" (Static)
// #define IDH_108_1507	98762860	// Advanced Power Scheme Settings: "Optimize time AC" (ComboBox)




// "Save Scheme" Dialog Box (IDD_SAVE == 109)

#define IDH_109_1700	111411309	// Save Scheme: "Save name power scheme" (Edit)


// "Alarms" Dialog Box (IDD_ALARMPOLICY == 103)

#define IDH_103_1110	72745063	// Alarms: "Low battery alarm groupbox" (Button)
#define IDH_103_1106	72482919	// Alarms: "Set off &low battery alarm when power level reaches:" (Button)
#define IDH_103_1104	72351847	// Alarms: "Low alarm level" (Static)
#define IDH_103_1102	72220775	// Alarms: "Low alarm slider" (msctls_trackbar32)
#define IDH_103_1101	72155239	// Alarms: "Alar&m Action..." (Button)
#define IDH_103_1108	72613991	// Alarms: "Low alarm status text" (Static)
#define IDH_103_1111	72810599	// Alarms: "Critical battery alarm groupbox" (Button)
#define IDH_103_1107	72548455	// Alarms: "Set off &critical battery alarm when power level reaches:" (Button)
#define IDH_103_1105	72417383	// Alarms: "Critical alarm level" (Static)
#define IDH_103_1103	72286311	// Alarms: "Critical alarm slider" (msctls_trackbar32)
#define IDH_103_1100	72089703	// Alarms: "Ala&rm Action..." (Button)
#define IDH_103_1109	72679527	// Alarms: "Critical alarm status text" (Static)


// "Alarm Actions" Dialog Box (IDD_ALARMACTIONS == 106)

#define IDH_106_1608	105381994	// Alarm Actions: "Notification groupbox" (Button)
#define IDH_106_1603	105054314	// Alarm Actions: "&Sound alarm" (Button)
#define IDH_106_1605	105185386	// Alarm Actions: "&Display message" (Button)
#define IDH_106_1609	105447530	// Alarm Actions: "Power level groupbox" (Button)
#define IDH_106_1600	104857706	// Alarm Actions: "When the &alarm goes off, the computer will:" (Button)
#define IDH_106_1601	104923242	// Alarm Actions: "Alarm action dropdown" (ComboBox)
#define IDH_106_1602	104988778	// Alarm Actions: "&Force standby or shutdown even if a program stops responding." (Button)
#define IDH_106_1620    86999989    // Alarm Actions: "Specifies that you want a program to run..."
#define IDH_106_1621    86999988	// Alarm Actions: "The name of the program..." 
#define IDH_106_1622    86999987	// Alarm Actions: "Displays a dialog box in which you can browse..."


// "APM Actions"
#define IDH_ENABLE_APM_SUPPORT 665554444 // APM Enable: "Displays APM Information"


// "Power Switches" Dialog Box (IDD_BUTTONPOLICY == 104)

// #define IDH_104_1300	85196904	// Power Switches: "&When I close the lid of my portable computer:" (Static)
#define IDH_104_1301	85262440	// Power Switches: "Lid close action dropdown" (ComboBox)
// #define IDH_104_1302	85327976	// Power Switches: "Wh&en I press the Power button on my computer:" (Static)
#define IDH_104_1303	85393512	// Power Switches: "Power button action dropdown" (ComboBox)
#define IDH_104_1304    85393513    // Power Switches: "Sleep button action dropdown" (ComboBox)

// "Hibernate" Dialog Box (IDD_HIBERNATE == 105)

#define IDH_105_1401	91816041	// Hibernate: "Free space" (Static)
#define IDH_105_1402	91881577	// Hibernate: "Required space to hibernate" (Static)
#define IDH_105_1400	91750505	// Hibernate: "After going on standby, &hibernate." (Button)
#define IDH_105_1403	91947113	// Hibernate: "You must free up some disk space before your computer can hibernate." (Static)

// "Power Meter" tab (IDD_BATMETERCFG == 102)
#define IDH_102_1203	78839910	// Battery Meter: "&Show meter on taskbar." (Button)
#define IDH_102_1204	78905446	// Battery Meter: "Show the status of all &batteries." 
#define IDH_102_1205	78970982	// Battery Meter: "Batmeter frame" (Static)
#define IDH_102_1201	78708838	// Battery Meter: "Power status" (Button)
#define IDH_102_1206	91926322	//Advanced tab, "Turn on computer to recv ph calls..."

//"Power Status" group on Power Meter tab (IDD_BATMETER )
#define IDH_BATMETER_CURPOWERSOURCE	86999997
#define IDH_BATMETER_TOTALBATPOWER	86999996
#define IDH_BATMETER_TOTALTIME	86999995
#define IDH_BATMETER_CHARGING_ICON	86999994

// "Detailed Battery Information" dbox (IDD_BATDETAIL )
#define IDH_DETAILED_BATINFO_LABELS	86999999	//for all 6 labels
#define IDH_DETAILED_BATINFO_REFRESH	86999998	//Refresh button

#define IDH_SYSTEMHIBERNATES	86999993
#define IDH_HIBERACCOMBO	86999992
#define IDH_HIBERDCCOMBO	86999991

#define IDH_DESK_LOWPOWERCFG    4828 //Power button on Screen Saver tab
#define idh_manufacturer 8920500
#define idh_model 8920501
#define idh_current_power_source 8920502
#define idh_estimated_ups_runtime 8920503
#define idh_estimated_ups_capacity 8920504
#define idh_battery_condition 8920505
#define idh_select_ups 8920506
#define idh_configure_ups 8920507
#define idh_apc_logo_link 8920508
#define idh_select_manufacturer 8920509
#define idh_select_model 8920510
#define idh_on_port 8920511
#define idh_next 8920512
#define idh_finish 8920513
#define idh_positive_negative_powerfail 8920514
#define idh_positive_negative_low_battery 8920515
#define idh_positive_negative_shutdown 8920516
#define idh_enable_notification 8920518
#define idh_first_warning_delay 8920519
#define idh_warning_message_interval 8920520
#define idh_time_before_critical_action 8920521
#define idh_low_battery 8920522
#define idh_run_program 8920523
#define idh_configure_program 8920524
#define idh_shutdown_or_hibernate 8920525
#define idh_ups_turn_off 8920526
#define idh_ok 8920527
#define idh_serialnumber 8920528
#define idh_firmware 89205290
#define idh_back 0x3023
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\powercfg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       POWERCFG.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*******************************************************************************/

#include "powrprofp.h"
#include "batmeter.h"

// String constants and macros:
#define MAX_UI_STR_LEN          256
#define MAX_FRIENDLY_NAME_LEN   32      // Resource layout depends on this.
#define FREE_STR                TRUE
#define NO_FREE_STR             FALSE

#define PWRMANHLP TEXT("PWRMN.HLP")

// Policy settings

#define POWER_POLICY_KEY        TEXT("Software\\Policies\\Microsoft\\Windows\\System\\Power")
#define LOCK_ON_RESUME          TEXT("PromptPasswordOnResume")

// Hard limits, many are overridden by machine capabilities
// or registry settings:
#define MAX_VIDEO_TIMEOUT      300
#define MAX_SPINDOWN_TIMEOUT   300

#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))


/*******************************************************************************
*
*  Structures and constants to manage property pages in the applet.
*
*******************************************************************************/

#define MAX_PAGES      16+2         // Max number pages + caption & sentinal.
#define START_OF_PAGES 1            // Index to the property sheet pages.
#define CAPTION_INDEX  0            // Index to the overall caption.

typedef struct _POWER_PAGES
{
    LPCTSTR         pDlgTemplate;
    DLGPROC         pfnDlgProc;
    HPROPSHEETPAGE  hPropSheetPage;
} POWER_PAGES, *PPOWER_PAGES;

/*******************************************************************************
*
*  Structures and constants which manage dialog control information.
*
*******************************************************************************/

// Constants for MapXXXIndex functions:
#define VALUE_TO_INDEX TRUE
#define INDEX_TO_VALUE FALSE

// Constants used by SetControls in GETSET.C:
#define CONTROL_DISABLE     0
#define CONTROL_HIDE        1
#define CONTROL_ENABLE      2

// Proto for MapXXXIndex functions
typedef BOOL (*MAPFUNC)(LPVOID, PUINT, BOOL);

// Structure to manage the spin control data:
typedef struct _SPIN_DATA
{
    UINT    uiSpinId;
    PUINT   puiRange;
} SPIN_DATA, *PSPIN_DATA;

// Structure to manage the dialog controls specification:
typedef struct _POWER_CONTROLS
{
    UINT    uiID;
    UINT    uiType;
    LPVOID  lpvData;
    DWORD   dwSize;
    LPDWORD lpdwParam;
    LPDWORD lpdwState;

} POWER_CONTROLS, *PPOWER_CONTROLS;

// Dialog control constants:
#define CHECK_BOX               0
#define CHECK_BOX_ENABLE        1
#define SLIDER                  2
#define EDIT_UINT               3
#define EDIT_TEXT               6
#define EDIT_TEXT_RO            7
#define COMBO_BOX               8
#define PUSHBUTTON              9
#define STATIC_TEXT             10
#define GROUPBOX_TEXT           11

/*******************************************************************************
*
*                 P u b l i c   P r o t o t y p e s
*
*******************************************************************************/

// Public functions implemented in ALARM.C
INT_PTR CALLBACK AlarmDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AlarmActionsDlgProc(HWND, UINT, WPARAM, LPARAM);

// Public functions implemented in BATMTRCF.C
INT_PTR CALLBACK BatMeterCfgDlgProc(HWND, UINT, WPARAM, LPARAM);

// Public functions implemented in APM.C
INT_PTR CALLBACK APMDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOLEAN IsNtApmPresent(PSYSTEM_POWER_CAPABILITIES);

// Public functions implemented in ups.lib
INT_PTR CALLBACK UPSMainPageProc(HWND, UINT, WPARAM, LPARAM);
BOOLEAN IsUpsPresent(PSYSTEM_POWER_CAPABILITIES);

// Public functions implemented in GETSET.C
DWORD SelToFromPowerAction(HWND, UINT, LPVOID, LPARAM, BOOL);
DWORD PowerActionToStatus(HWND, UINT, LPVOID, LPARAM, BOOL);
VOID  DisableControls(HWND, UINT, PPOWER_CONTROLS);
VOID  HideControls(HWND, UINT, PPOWER_CONTROLS);
BOOL  SetControls(HWND, UINT, PPOWER_CONTROLS);
BOOL  GetControls(HWND, UINT, PPOWER_CONTROLS);
VOID  RangeLimitIDarray(PUINT, UINT, UINT);

// Public functions implemented in HIBERNAT.C:
void DoHibernateApply(void);
INT_PTR CALLBACK HibernateDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL MapPwrAct(PPOWER_ACTION, BOOL);

// Public functions implemented in POWERCFG.C:
LPTSTR CDECL   LoadDynamicString(UINT StringID, ... );
LPTSTR         DisplayFreeStr(HWND, UINT, LPTSTR, BOOL);
BOOLEAN        ValidateUISchemeFields(PPOWER_POLICY);
BOOLEAN        GetGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN        WritePwrSchemeReport(HWND, PUINT, LPTSTR, LPTSTR, PPOWER_POLICY);
BOOLEAN        WriteGlobalPwrPolicyReport(HWND, PGLOBAL_POWER_POLICY, BOOL);
BOOLEAN        SetActivePwrSchemeReport(HWND, UINT, PGLOBAL_POWER_POLICY, PPOWER_POLICY);
int            ErrorMsgBox(HWND, DWORD, UINT);
BOOL           InitCapabilities(PSYSTEM_POWER_CAPABILITIES);

// Public functions implemented in PRSHTHLP.C:
BOOL AppendPropSheetPage(PPOWER_PAGES, UINT, DLGPROC);
UINT GetNumPropSheetPages(PPOWER_PAGES);
BOOL CALLBACK _AddPowerPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);
BOOL PASCAL DoPropSheetPages(HWND, PPOWER_PAGES, LPTSTR);
VOID MarkSheetDirty(HWND, PBOOL);

// Public functions implemented in PWRSCHEM.C
VOID InitSchemesList(VOID);
INT_PTR CALLBACK PowerSchemeDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AdvPowerSchemeDlgProc(HWND, UINT, WPARAM, LPARAM);

// Public functions implemented in PWRSWTCH.C
INT_PTR CALLBACK AdvancedDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\pwrschem.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       PWRSCHEM.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Support for power scheme page (front page) of PowerCfg.Cpl.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <regstr.h>
#include <help.h>
#include <powercfp.h>

#include "powercfg.h"
#include "pwrresid.h"
#include "PwrMn_cs.h"
#include <shfusion.h>

// Structure to manage the scheme list information.
typedef struct _SCHEME_LIST
{
    LIST_ENTRY              leSchemeList;
    UINT                    uiID;
    LPTSTR                  lpszName;
    LPTSTR                  lpszDesc;
    PPOWER_POLICY           ppp;
} SCHEME_LIST, *PSCHEME_LIST;

// Structure to manage the power scheme dialog proc info.
typedef struct _POWER_SCHEME_DLG_INFO
{
    HWND  hwndSchemeList;
} POWER_SCHEME_DLG_INFO, *PPOWER_SCHEME_DLG_INFO;

// Private functions implemented in PWRSCHEM.C:
UINT StripBlanks(LPTSTR);
UINT RangeLimitHiberTimeOuts(UINT uiIdleTimeout, UINT *uiHiberToIDs);
VOID RefreshSchemes(HWND, PSCHEME_LIST);
VOID HandleIdleTimeOutChanged(HWND hWnd, UINT uMsg, WPARAM wParam, BOOL *pbDirty);
LONG MsgBoxId(HWND, UINT, UINT, LPTSTR, UINT);

BOOLEAN DoDeleteScheme(HWND, LPTSTR);
BOOLEAN DoSaveScheme(HWND);
BOOLEAN ClearSchemeList(VOID);
BOOLEAN RemoveScheme(PSCHEME_LIST, LPTSTR);
BOOLEAN PowerSchemeDlgInit(HWND, PPOWER_SCHEME_DLG_INFO);
BOOLEAN CALLBACK PowerSchemeEnumProc(UINT, DWORD, LPTSTR, DWORD, LPTSTR, PPOWER_POLICY, LPARAM);
BOOLEAN HandleCurSchemeChanged(HWND hWnd);
BOOLEAN MapHiberTimer(PPOWER_POLICY ppp, BOOLEAN Get);

PSCHEME_LIST GetCurSchemeFromCombo(HWND hWnd);
PSCHEME_LIST FindScheme(LPTSTR, BOOLEAN);
PSCHEME_LIST AddScheme(UINT, LPTSTR, UINT, LPTSTR, UINT, PPOWER_POLICY);
PSCHEME_LIST FindNextScheme(LPTSTR);

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern HINSTANCE g_hInstance;           // Global instance handle of this DLL.

// This structure is filled in by the Power Policy Manager at CPL_INIT time.
extern SYSTEM_POWER_CAPABILITIES g_SysPwrCapabilities;
extern BOOLEAN  g_bVideoLowPowerSupported;
extern DWORD    g_dwNumSleepStates;
extern UINT     g_uiSpindownMaxMin;
extern BOOL     g_bRunningUnderNT;

UINT g_uiTimeoutIDs[] =                 // Timeout string ID's.
{
    IDS_01_MIN,     60 * 1,         // 1 Min.
    IDS_02_MIN,     60 * 2,
    IDS_03_MIN,     60 * 3,
    IDS_05_MIN,     60 * 5,
    IDS_10_MIN,     60 * 10,
    IDS_15_MIN,     60 * 15,
    IDS_20_MIN,     60 * 20,
    IDS_25_MIN,     60 * 25,
    IDS_30_MIN,     60 * 30,
    IDS_45_MIN,     60 * 45,
    IDS_01_HOUR,    60 * 60 * 1,    // 1 Hour
    IDS_02_HOUR,    60 * 60 * 2,
    IDS_03_HOUR,    60 * 60 * 3,
    IDS_04_HOUR,    60 * 60 * 4,
    IDS_05_HOUR,    60 * 60 * 5,
    IDS_NEVER,      0,
    0,              0
};

UINT g_uiHiberToIDs[] =                 // Hiber timeout string ID's.
{
    IDS_01_MIN,     60 * 1,         // 1 Min.
    IDS_02_MIN,     60 * 2,
    IDS_03_MIN,     60 * 3,
    IDS_05_MIN,     60 * 5,
    IDS_10_MIN,     60 * 10,
    IDS_15_MIN,     60 * 15,
    IDS_20_MIN,     60 * 20,
    IDS_25_MIN,     60 * 25,
    IDS_30_MIN,     60 * 30,
    IDS_45_MIN,     60 * 45,
    IDS_01_HOUR,    60 * 60 * 1,    // 1 Hour
    IDS_02_HOUR,    60 * 60 * 2,
    IDS_03_HOUR,    60 * 60 * 3,
    IDS_04_HOUR,    60 * 60 * 4,
    IDS_05_HOUR,    60 * 60 * 5,
    IDS_06_HOUR,    60 * 60 * 6,
    IDS_NEVER,      0,
    0,              0
};

UINT g_uiHiberToAcIDs[sizeof(g_uiHiberToIDs)]; // Hibernate AC timeout string ID's.
UINT g_uiHiberToDcIDs[sizeof(g_uiHiberToIDs)]; // Hibernate DC timeout string ID's.

UINT g_uiSpinDownIDs[] =            // Disk spin down timeout string ID's.
{
    IDS_01_MIN,     60 * 1,         // 1 Min.
    IDS_02_MIN,     60 * 2,
    IDS_03_MIN,     60 * 3,
    IDS_05_MIN,     60 * 5,
    IDS_10_MIN,     60 * 10,
    IDS_15_MIN,     60 * 15,
    IDS_20_MIN,     60 * 20,
    IDS_25_MIN,     60 * 25,
    IDS_30_MIN,     60 * 30,
    IDS_45_MIN,     60 * 45,
    IDS_01_HOUR,    60 * 60 * 1,    // 1 Hour
    IDS_02_HOUR,    60 * 60 * 2,
    IDS_03_HOUR,    60 * 60 * 3,
    IDS_04_HOUR,    60 * 60 * 4,
    IDS_05_HOUR,    60 * 60 * 5,
    IDS_NEVER,      0,
    0,              0
};

// Show/hide UI state variables for power schemes dialog.
UINT g_uiWhenComputerIsState;
UINT g_uiStandbyState;
UINT g_uiMonitorState;
UINT g_uiDiskState;
UINT g_uiHiberState;
UINT g_uiHiberTimeoutAc;
UINT g_uiHiberTimeoutDc;
UINT g_uiIdleTimeoutAc;
UINT g_uiIdleTimeoutDc;

// Power schemes dialog controls descriptions:
UINT g_uiNumPwrSchemeCntrls;
#define NUM_POWER_SCHEME_CONTROLS       17
#define NUM_POWER_SCHEME_CONTROLS_NOBAT 8

// Handy indicies into our g_pcPowerScheme control array
#define ID_GOONSTANDBY         0
#define ID_STANDBYACCOMBO      1
#define ID_TURNOFFMONITOR      2
#define ID_MONITORACCOMBO      3
#define ID_TURNOFFHARDDISKS    4
#define ID_DISKACCOMBO         5
#define ID_SYSTEMHIBERNATES    6
#define ID_HIBERACCOMBO        7
#define ID_STANDBYDCCOMBO      8
#define ID_MONITORDCCOMBO      9
#define ID_DISKDCCOMBO         10
#define ID_HIBERDCCOMBO        11
#define ID_WHENCOMPUTERIS      12
#define ID_PLUGGEDIN           13
#define ID_RUNNINGONBAT        14
#define ID_PLUG                15
#define ID_BATTERY             16

POWER_CONTROLS g_pcPowerScheme[NUM_POWER_SCHEME_CONTROLS] =
{// Control ID              Control Type        Data Address        Data Size                       Parameter Pointer               EnableVisible State Pointer
    IDC_GOONSTANDBY,        STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiStandbyState,
    IDC_STANDBYACCOMBO,     COMBO_BOX,          &g_uiTimeoutIDs,    sizeof(DWORD),                  &g_uiIdleTimeoutAc,             &g_uiStandbyState,
    IDC_TURNOFFMONITOR,     STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiMonitorState,
    IDC_MONITORACCOMBO,     COMBO_BOX,          &g_uiTimeoutIDs,    sizeof(DWORD),                  NULL,                           &g_uiMonitorState,
    IDC_TURNOFFHARDDISKS,   STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiDiskState,
    IDC_DISKACCOMBO,        COMBO_BOX,          &g_uiSpinDownIDs,   sizeof(DWORD),                  NULL,                           &g_uiDiskState,
    IDC_SYSTEMHIBERNATES,   STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiHiberState,
    IDC_HIBERACCOMBO,       COMBO_BOX,          &g_uiHiberToAcIDs,  sizeof(DWORD),                  &g_uiHiberTimeoutAc,            &g_uiHiberState,
    IDC_STANDBYDCCOMBO,     COMBO_BOX,          &g_uiTimeoutIDs,    sizeof(DWORD),                  &g_uiIdleTimeoutDc,             &g_uiStandbyState,
    IDC_MONITORDCCOMBO,     COMBO_BOX,          &g_uiTimeoutIDs,    sizeof(DWORD),                  NULL,                           &g_uiMonitorState,
    IDC_DISKDCCOMBO,        COMBO_BOX,          &g_uiSpinDownIDs,   sizeof(DWORD),                  NULL,                           &g_uiDiskState,
    IDC_HIBERDCCOMBO,       COMBO_BOX,          &g_uiHiberToDcIDs,  sizeof(DWORD),                  &g_uiHiberTimeoutDc,            &g_uiHiberState,
    IDC_WHENCOMPUTERIS,     STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiWhenComputerIsState,
    IDC_PLUGGEDIN,          STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiWhenComputerIsState,
    IDC_RUNNINGONBAT,       STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiWhenComputerIsState,
    IDI_PLUG,               STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiWhenComputerIsState,
    IDI_BATTERY,            STATIC_TEXT,        NULL,               0,                              NULL,                           &g_uiWhenComputerIsState,
};

// Show/hide UI state variables for advanced power schemes dialog.
UINT g_uiAdvWhenComputerIsState;
UINT g_uiOptimizeState;


// Globals to manage the power schemes list:
SCHEME_LIST     g_sl;               // Head of the power schemes list.
PSCHEME_LIST    g_pslCurActive;     // Currently active power scheme.
PSCHEME_LIST    g_pslCurSel;        // Currently selected power scheme.
PSCHEME_LIST    g_pslValid;         // A valid scheme for error recovery.
UINT            g_uiSchemeCount;    // Number of power schemes.
LIST_ENTRY      g_leSchemeList;     // Head of the power schemes list.
BOOL            g_bSystrayChange;   // A systary change requires PowerSchemeDlgProc re-init.

// "Power Schemes" Dialog Box (IDD_POWERSCHEME == 100) help arrays:

const DWORD g_PowerSchemeHelpIDs[]=
{
    IDC_SCHEMECOMBO,        IDH_100_1000,   // Power Schemes: "Power schemes" (ComboBox)
    IDC_POWERSCHEMESTEXT,   IDH_COMM_GROUPBOX,
    IDC_SAVEAS,             IDH_100_1001,   // Power Schemes: "&Save As..." (Button)
    IDC_DELETE,             IDH_100_1002,   // Power Schemes: "&Delete" (Button)
    IDC_SETTINGSFOR,        IDH_COMM_GROUPBOX,   // Power Schemes: "Settings for groupbox" (Button)
    IDC_GOONSTANDBY,        IDH_100_1009,   // Power Schemes: "Go on s&tandby:" (Static)
    IDC_STANDBYACCOMBO,     IDH_100_1005,   // Power Schemes: "Standby AC time" (ComboBox)
    IDC_STANDBYDCCOMBO,     IDH_100_1006,   // Power Schemes: "Standby DC time" (ComboBox)
    IDC_SYSTEMHIBERNATES,   IDH_SYSTEMHIBERNATES,
    IDC_HIBERACCOMBO,       IDH_HIBERACCOMBO,
    IDC_HIBERDCCOMBO,       IDH_HIBERDCCOMBO,
    IDC_TURNOFFMONITOR,     IDH_100_1010,   // Power Schemes: "Turn off &monitor:" (Static)
    IDC_MONITORACCOMBO,     IDH_100_1007,   // Power Schemes: "Monitor AC time" (ComboBox)
    IDC_MONITORDCCOMBO,     IDH_100_1008,   // Power Schemes: "Monitor DC time" (ComboBox)
    IDC_TURNOFFHARDDISKS,   IDH_107_1509,   // Advanced Power Scheme Settings: "Turn off hard &disks:" (Static)
    IDC_DISKACCOMBO,        IDH_107_1505,   // Advanced Power Scheme Settings: "Disk off time AC" (ComboBox)
    IDC_DISKDCCOMBO,        IDH_107_1506,   // Advanced Power Scheme Settings: "Disk off time DC" (ComboBox)
    IDC_PLUGGEDIN,          NO_HELP,
    IDC_NO_HELP_0,          NO_HELP,
    IDC_NO_HELP_7,          NO_HELP,
    IDI_PWRMNG,             NO_HELP,
    IDI_PLUG,               NO_HELP,
    IDI_BATTERY,            NO_HELP,
    IDC_WHENCOMPUTERIS,     NO_HELP,
    IDC_PLUGGEDIN,          NO_HELP,
    IDC_RUNNINGONBAT,       NO_HELP,
    0, 0
};

// "Save Scheme" Dialog Box (IDD_SAVE == 109) help ID's:

#define IDH_109_1700    111411309   // Save Scheme: "Save name power scheme" (Edit)

// "Save Scheme" Dialog Box (IDD_SAVE == 109) help array:

const DWORD g_SaveAsHelpIDs[]=
{
    IDC_SAVENAMEEDIT,   IDH_109_1700,   // Save Scheme: "Save name power scheme" (Edit)
    IDC_SAVETEXT,       IDH_109_1700,
    0, 0
};

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  InitSchemesList
*
*  DESCRIPTION:
*   Called once at DLL initialization time.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID InitSchemesList(VOID)
{
    InitializeListHead(&g_leSchemeList);
}

/*******************************************************************************
*
*  SaveAsDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*   Dialog procedure for the advanced power scheme dialog.
*
*******************************************************************************/

INT_PTR CALLBACK SaveAsDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    TCHAR           szBuf[2 * MAX_FRIENDLY_NAME_LEN]; // Leave room for DBCS
    PSCHEME_LIST    pslNew;
    static PBOOLEAN pbSavedCurrent;

    switch (uMsg) {
        case WM_INITDIALOG:
            SetDlgItemText(hWnd, IDC_SAVENAMEEDIT,  g_pslCurSel->lpszName);
            SendDlgItemMessage(hWnd, IDC_SAVENAMEEDIT, EM_SETSEL, 0, -1);
            SendDlgItemMessage(hWnd, IDC_SAVENAMEEDIT, EM_LIMITTEXT, MAX_FRIENDLY_NAME_LEN-2, 0L);
            EnableWindow(GetDlgItem(hWnd, IDOK), (g_pslCurSel->lpszName[0] != TEXT('\0')));
            pbSavedCurrent = (PBOOLEAN) lParam;
            *pbSavedCurrent = FALSE;
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_SAVENAMEEDIT:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        GetDlgItemText(hWnd, IDC_SAVENAMEEDIT, szBuf, 2);
                        if (*szBuf) {
                            EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);
                        }
                    }
                    break;

                case IDOK:
                    GetDlgItemText(hWnd, IDC_SAVENAMEEDIT, szBuf, MAX_FRIENDLY_NAME_LEN-1);

                    // Strip trailing blanks, don't allow blank scheme name.
                    if (!StripBlanks(szBuf)) {
                        MsgBoxId(hWnd, IDS_SAVESCHEME, IDS_BLANKNAME,
                                 NULL, MB_OK | MB_ICONEXCLAMATION);
                        return TRUE;
                    }

                    // Insert a new policies element in the policies list.
                    pslNew = AddScheme(NEWSCHEME, szBuf, STRSIZE(szBuf),
                             TEXT(""), sizeof(TCHAR), g_pslCurSel->ppp);

                    // Write out the Scheme.
                    if (pslNew) {
                        if ( WritePwrSchemeReport(hWnd,
                                                  &(pslNew->uiID),
                                                  pslNew->lpszName,
                                                  pslNew->lpszDesc,
                                                  pslNew->ppp) )
                        {
                            if ( g_pslCurSel == pslNew )
                            {
                                *pbSavedCurrent = TRUE;
                            }
                            else
                            {
                                g_pslCurSel = pslNew;
                            }
                        }
                    }
                    // fall thru to IDCANCEL

                case IDCANCEL:
                    EndDialog(hWnd, wParam);
                    break;
            }
            break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_SaveAsHelpIDs);
            return TRUE;
    }

    return FALSE;
}

/*******************************************************************************
*
*  PowerSchemeDlgProc
*
*  DESCRIPTION:
*   Dialog procedure for power scheme page.
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK PowerSchemeDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    NMHDR  FAR  *lpnm;
    UINT   uiNewSel, uiNewState;
    LPTSTR pszUPS;
    static POWER_SCHEME_DLG_INFO  psdi;
    static BOOL bDirty = FALSE;
    static BOOL bInitFailed = FALSE;

    if (bInitFailed) {
        return FALSE;
    }

    switch (uMsg) {

        case WM_INITDIALOG:
            // Set the control count to match the dialog template we're using.
            if (g_SysPwrCapabilities.SystemBatteriesPresent) {
                g_uiNumPwrSchemeCntrls = NUM_POWER_SCHEME_CONTROLS;
                if (g_SysPwrCapabilities.BatteriesAreShortTerm) {
                   pszUPS = LoadDynamicString(IDS_POWEREDBYUPS);
                   DisplayFreeStr(hWnd, IDC_RUNNINGONBAT, pszUPS, FREE_STR);
                }
            }
            else {
                g_uiNumPwrSchemeCntrls = NUM_POWER_SCHEME_CONTROLS_NOBAT;
            }
            if (!PowerSchemeDlgInit(hWnd, &psdi)) {
                bInitFailed = TRUE;
            }
            return TRUE;

        case WM_CHILDACTIVATE:
            // If Systray changed something while another property page (dialog)
            // had the focus reinitialize the dialog.
            if (g_bSystrayChange) {
                PowerSchemeDlgInit(hWnd, &psdi);
                g_bSystrayChange = FALSE;
            }

            // Reinitialize hibernate timer since the hibernate tab
            // may have changed it's state.


            if (GetPwrCapabilities(&g_SysPwrCapabilities)) {
                if (g_bRunningUnderNT &&
                        g_SysPwrCapabilities.SystemS4 &&
                        g_SysPwrCapabilities.SystemS5 &&
                        g_SysPwrCapabilities.HiberFilePresent) {
                    uiNewState = CONTROL_ENABLE;
                } else {
                    uiNewState = CONTROL_HIDE;
                }

                if (g_bRunningUnderNT && (g_uiStandbyState == CONTROL_HIDE) &&
                        (g_SysPwrCapabilities.SystemS1 || 
                         g_SysPwrCapabilities.SystemS2 ||
                         g_SysPwrCapabilities.SystemS3)) {
                    
                    g_uiStandbyState = CONTROL_ENABLE;
                }
            }


            if (g_uiHiberState != uiNewState) {
                g_uiHiberState = uiNewState;
                MapHiberTimer(g_pslCurSel->ppp, FALSE);
                SetControls(hWnd, g_uiNumPwrSchemeCntrls, g_pcPowerScheme);
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code) {
                case PSN_APPLY:
                    if (bDirty) {

                        // Do the hibernate PSN_APPLY since the
                        // PowerSchemeDlgProc PSN_APPLY logic depends
                        // on hibernate state.
                        DoHibernateApply();

                        GetControls(hWnd, g_uiNumPwrSchemeCntrls,
                                    g_pcPowerScheme);
                        MapHiberTimer(g_pslCurSel->ppp, TRUE);

                        // Set active scheme.
                        if (SetActivePwrSchemeReport(hWnd,
                                                     g_pslCurSel->uiID,
                                                     NULL,
                                                     g_pslCurSel->ppp)) {

                            if (g_pslCurSel != g_pslCurActive) {
                                g_pslCurActive = g_pslCurSel;
                                RefreshSchemes(hWnd, g_pslCurSel);
                            }
                        }
                        bDirty = FALSE;

                        // The Power Policy Manager may have changed
                        // the scheme during validation.
                        MapHiberTimer(g_pslCurSel->ppp, FALSE);
                        SetControls(hWnd, g_uiNumPwrSchemeCntrls,
                                    g_pcPowerScheme);

                    }
                    break;
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_SCHEMECOMBO:
                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        if (g_pslCurSel = GetCurSchemeFromCombo(hWnd)) {
                            HandleCurSchemeChanged(hWnd);
                            MarkSheetDirty(hWnd, &bDirty);
                        }
                    }
                    break;

                case IDC_STANDBYACCOMBO:
                case IDC_STANDBYDCCOMBO:
                    HandleIdleTimeOutChanged(hWnd, uMsg, wParam, &bDirty);
                    break;

                case IDC_MONITORACCOMBO:
                case IDC_MONITORDCCOMBO:
                case IDC_DISKACCOMBO:
                case IDC_DISKDCCOMBO:
                case IDC_HIBERACCOMBO:
                case IDC_HIBERDCCOMBO:
                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        MarkSheetDirty(hWnd, &bDirty);
                    }
                    break;

                case IDC_SAVEAS:
                    if (DoSaveScheme(hWnd)) {
                        HandleCurSchemeChanged(hWnd);
                        MarkSheetDirty(hWnd, &bDirty);
                    }
                    break;

                case IDC_DELETE:
                    if (DoDeleteScheme(hWnd, g_pslCurSel->lpszName)) {
                        HandleCurSchemeChanged(hWnd);
                    }
                    break;

                default:
                    return FALSE;

            }
            break;

        case PCWM_NOTIFYPOWER:
            // Notification from systray, user has changed a PM UI setting.
            PowerSchemeDlgInit(hWnd, &psdi);
            break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_PowerSchemeHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_PowerSchemeHelpIDs);
            return TRUE;

    }
    return FALSE;
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  HandleIdleTimeOutChanged
*
*  DESCRIPTION:
*   Range limit the hibernate timeout combo boxes based on the value of the
*   idle timeouts.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID HandleIdleTimeOutChanged(HWND hWnd, UINT uMsg, WPARAM wParam, BOOL *pbDirty)
{
    UINT uiIdleTo, uiLimitedTo;

    if (HIWORD(wParam) == CBN_SELCHANGE) {

        MarkSheetDirty(hWnd, pbDirty);

        if (LOWORD(wParam) == IDC_STANDBYACCOMBO) {
            GetControls(hWnd, 1, &g_pcPowerScheme[ID_STANDBYACCOMBO]);
            GetControls(hWnd, 1, &g_pcPowerScheme[ID_HIBERACCOMBO]);
            uiIdleTo = g_uiIdleTimeoutAc;
            uiLimitedTo = RangeLimitHiberTimeOuts(uiIdleTo, g_uiHiberToAcIDs);
            if (g_uiHiberTimeoutAc && (uiIdleTo >= g_uiHiberTimeoutAc)) {
                g_uiHiberTimeoutAc = uiLimitedTo;
            }
            SetControls(hWnd, 1, &g_pcPowerScheme[ID_HIBERACCOMBO]);
        }
        else {
            GetControls(hWnd, 1, &g_pcPowerScheme[ID_STANDBYDCCOMBO]);
            GetControls(hWnd, 1, &g_pcPowerScheme[ID_HIBERDCCOMBO]);
            uiIdleTo = g_uiIdleTimeoutDc;
            uiLimitedTo = RangeLimitHiberTimeOuts(uiIdleTo, g_uiHiberToDcIDs);
            if (g_uiHiberTimeoutDc && (uiIdleTo >= g_uiHiberTimeoutDc)) {
                g_uiHiberTimeoutDc = uiLimitedTo;
            }
            SetControls(hWnd, 1, &g_pcPowerScheme[ID_HIBERDCCOMBO]);
        }
    }
}

/*******************************************************************************
*
*  RangeLimitHiberTimeOuts
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT RangeLimitHiberTimeOuts(UINT uiIdleTimeout, UINT *uiHiberToIDs)
{
    UINT i, uiNewMin;

    // Initialize the hiber timout ID's to full range.
    memcpy(uiHiberToIDs, g_uiHiberToIDs, sizeof(g_uiHiberToIDs));

    if (uiIdleTimeout) {
        i = 0;
        while (uiHiberToIDs[i++]) {
            if (uiHiberToIDs[i] >= uiIdleTimeout) {
                i += 2;
                uiNewMin = uiHiberToIDs[i];
                RangeLimitIDarray(uiHiberToIDs, uiNewMin, (UINT) -1);
                return uiNewMin;
            }
            i++;
        }
        DebugPrint( "RangeLimitHiberTimeOuts: couldn't find value larger than: %d", uiIdleTimeout);
    }
    return (UINT) -1;
}

/*******************************************************************************
*
*  MapHiberTimer
*
*  DESCRIPTION:
*   Displayed hibernate timeout may never be less than the idle timeout. This
*   function handles the mapping. The following table (per KenR) specifies the
*   Idle action to be set by  the UI for different combinations of Idle and
*   Hibernate timeouts. It is understood that the Hibernate timeout UI only
*   appears when HiberFilePresent is TRUE. For case E, the HiberTimeout will be
*   set in the IdleTimeout member. For case F, the UI will adjust the
*   DozeS4Timeout member to be the displayed HiberTimeout plus the IdleTimeout.
*
* Case HiberFilePresent UiHiberTimeout UiIdleTimeout IdleAction           DozeS4Timeout   IdleTimeout
* ---------------------------------------------------------------------------------------------------------------
* A.   FALSE            N/A            0 (Never)     PowerActionNone      0               0
* B.   FALSE            N/A            !0            PowerActionSleep     0               UiIdleTimeout
* C.   TRUE             0 (Never)      0 (Never)     PowerActionNone      0               0
* D.   TRUE             0 (Never)      !0            PowerActionSleep     0               UiIdleTimeout
* E.   TRUE             !0             0 (Never)     PowerActionHibernate 0               UiHiberTimeout
* F.   TRUE             !0             !0            PowerActionSleep     UiHiber-UiIdle  UiIdleTimeout
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN MapHiberTimer(PPOWER_POLICY ppp, BOOLEAN Get)
{
   if (Get) {

      // Get values from the UI. AC.
      ppp->mach.DozeS4TimeoutAc =  0;
      ppp->user.IdleTimeoutAc   =  g_uiIdleTimeoutAc;
      if (g_uiHiberTimeoutAc) {
         if (g_uiIdleTimeoutAc) {
            ppp->mach.DozeS4TimeoutAc = g_uiHiberTimeoutAc - g_uiIdleTimeoutAc;
         }
         else {
            ppp->user.IdleTimeoutAc   = g_uiHiberTimeoutAc;
         }
      }

      // DC.
      ppp->mach.DozeS4TimeoutDc =  0;
      ppp->user.IdleTimeoutDc   =  g_uiIdleTimeoutDc;
      if (g_uiHiberTimeoutDc) {
         if (g_uiIdleTimeoutDc) {
            ppp->mach.DozeS4TimeoutDc = g_uiHiberTimeoutDc - g_uiIdleTimeoutDc;
         }
         else {
            ppp->user.IdleTimeoutDc   = g_uiHiberTimeoutDc;
         }
      }

      // Set the correct idle action. AC.
      ppp->user.IdleAc.Action = PowerActionNone;
      if (g_uiIdleTimeoutAc) {
         ppp->user.IdleAc.Action = PowerActionSleep;
      }
      else {
         if (g_SysPwrCapabilities.HiberFilePresent) {
            if (g_uiHiberTimeoutAc) {
               ppp->user.IdleAc.Action = PowerActionHibernate;
            }
         }
      }

      // DC.
      ppp->user.IdleDc.Action = PowerActionNone;
      if (g_uiIdleTimeoutDc) {
         ppp->user.IdleDc.Action = PowerActionSleep;
      }
      else {
         if (g_SysPwrCapabilities.HiberFilePresent) {
            if (g_uiHiberTimeoutDc) {
               ppp->user.IdleDc.Action = PowerActionHibernate;
            }
         }
      }
   }
   else {

      // Set values to the UI. AC.
      if (ppp->user.IdleAc.Action == PowerActionHibernate) {
         g_uiHiberTimeoutAc = ppp->user.IdleTimeoutAc;
         g_uiIdleTimeoutAc  = 0;
      }
      else {
         g_uiIdleTimeoutAc  = ppp->user.IdleTimeoutAc;
         if (ppp->mach.DozeS4TimeoutAc && g_SysPwrCapabilities.HiberFilePresent) {
            g_uiHiberTimeoutAc = ppp->user.IdleTimeoutAc +
                                 ppp->mach.DozeS4TimeoutAc;
         }
         else {
            g_uiHiberTimeoutAc = 0;
         }
      }

      // DC.
      if (ppp->user.IdleDc.Action == PowerActionHibernate) {
         g_uiHiberTimeoutDc = ppp->user.IdleTimeoutDc;
         g_uiIdleTimeoutDc  = 0;
      }
      else {
         g_uiIdleTimeoutDc  = ppp->user.IdleTimeoutDc;
         if (ppp->mach.DozeS4TimeoutDc && g_SysPwrCapabilities.HiberFilePresent) {
            g_uiHiberTimeoutDc = ppp->user.IdleTimeoutDc +
                                 ppp->mach.DozeS4TimeoutDc;
         }
         else {
            g_uiHiberTimeoutDc = 0;
         }
      }

      // Range limit the hibernate timeout combo boxes based
      // on the value of the idle timeouts.
      RangeLimitHiberTimeOuts(g_uiIdleTimeoutAc, g_uiHiberToAcIDs);
      RangeLimitHiberTimeOuts(g_uiIdleTimeoutDc, g_uiHiberToDcIDs);
   }
   return TRUE;
}

/*******************************************************************************
*
*  HandleCurSchemeChanged
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN HandleCurSchemeChanged(HWND hWnd)
{
    LPTSTR  pString;
    BOOL    bEnable;

    // Update the group box text if enabled.
    if ((g_uiStandbyState != CONTROL_HIDE) ||
        (g_uiMonitorState != CONTROL_HIDE) ||
        (g_uiDiskState    != CONTROL_HIDE) ||
        (g_uiHiberState   != CONTROL_HIDE)) {
        pString = LoadDynamicString(IDS_SETTINGSFORMAT, g_pslCurSel->lpszName);
        DisplayFreeStr(hWnd, IDC_SETTINGSFOR, pString, FREE_STR);
    }
    else {
        ShowWindow(GetDlgItem(hWnd, IDC_SETTINGSFOR), SW_HIDE);
    }

    // Update the power schemes combobox list.
    RefreshSchemes(hWnd, g_pslCurSel);

    // Setup the data pointers in the g_pcPowerScheme array.
    g_pcPowerScheme[ID_MONITORACCOMBO].lpdwParam =
        &(g_pslCurSel->ppp->user.VideoTimeoutAc);
    g_pcPowerScheme[ID_MONITORDCCOMBO].lpdwParam =
        &(g_pslCurSel->ppp->user.VideoTimeoutDc);
    g_pcPowerScheme[ID_DISKACCOMBO].lpdwParam =
        &(g_pslCurSel->ppp->user.SpindownTimeoutAc);
    g_pcPowerScheme[ID_DISKDCCOMBO].lpdwParam =
        &(g_pslCurSel->ppp->user.SpindownTimeoutDc);

    // Update the rest of the controls.
    MapHiberTimer(g_pslCurSel->ppp, FALSE);
    SetControls(hWnd, g_uiNumPwrSchemeCntrls, g_pcPowerScheme);

    // Set the delete push button state.
    if (g_uiSchemeCount < 2) {
        bEnable = FALSE;
    }
    else {
        bEnable = TRUE;
    }
    EnableWindow(GetDlgItem(hWnd, IDC_DELETE), bEnable);
    return TRUE;
}

/*******************************************************************************
*
*  GetCurSchemeFromCombo
*
*  DESCRIPTION:
*   Get the current selection from the power schemes combobox list.
*
*  PARAMETERS:
*
*******************************************************************************/

PSCHEME_LIST GetCurSchemeFromCombo(HWND hWnd)
{
    UINT            uiCBRet;
    PSCHEME_LIST    psl;

    uiCBRet = (UINT) SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO, CB_GETCURSEL, 0, 0);
    if (uiCBRet != CB_ERR) {
        psl = (PSCHEME_LIST) SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO,
                                                CB_GETITEMDATA, uiCBRet, 0);
        if (psl != (PSCHEME_LIST) CB_ERR) {
            return FindScheme(psl->lpszName, TRUE);
        }
    }
    DebugPrint( "GetCurSchemeFromCombo, CB_GETITEMDATA or CB_GETCURSEL failed");
    return FALSE;
}

/*******************************************************************************
*
*  ClearSchemeList
*
*  DESCRIPTION:
*   Clear the scheme list if it's not already empty. Return TRUE if there's
*   a change to the contents of power scheme list.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ClearSchemeList(VOID)
{
    PSCHEME_LIST psl, pslNext;

    if (IsListEmpty(&g_leSchemeList)) {
        return FALSE;
    }

    for (psl = (PSCHEME_LIST)g_leSchemeList.Flink;
         psl != (PSCHEME_LIST)&g_leSchemeList; psl = pslNext) {

        pslNext = (PSCHEME_LIST) psl->leSchemeList.Flink;
        RemoveScheme(psl, NULL);
    }
    g_pslCurActive  = NULL;
    g_pslCurSel     = NULL;
    g_uiSchemeCount = 0;
    return TRUE;
}

/*******************************************************************************
*
*  RemoveScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN RemoveScheme(PSCHEME_LIST psl, LPTSTR lpszName)
{
    if (lpszName) {
        psl = FindScheme(lpszName, TRUE);
    }

    if (psl == &g_sl) {
        DebugPrint( "RemoveScheme, Attempted to delete head!");
        return FALSE;
    }

    if (psl) {
        LocalFree(psl->lpszName);
        LocalFree(psl->lpszDesc);
        RemoveEntryList(&psl->leSchemeList);
        LocalFree(psl);
        g_uiSchemeCount--;
        return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*  FindScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

PSCHEME_LIST FindScheme(LPTSTR lpszName, BOOLEAN bShouldExist)
{
    PSCHEME_LIST  psl, pslNext;

    if (!lpszName) {
        DebugPrint( "FindScheme, invalid parameters");
        return NULL;
    }

    // Search by name.
    for (psl = (PSCHEME_LIST)g_leSchemeList.Flink;
        psl != (PSCHEME_LIST)&g_leSchemeList; psl = pslNext) {

        pslNext = (PSCHEME_LIST) psl->leSchemeList.Flink;

        if (!lstrcmpi(lpszName, psl->lpszName)) {
            return psl;
        }
    }
    if (bShouldExist) {
        DebugPrint( "FindScheme, couldn't find: %s", lpszName);
    }
    return NULL;
}

/*******************************************************************************
*
*  AddScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

PSCHEME_LIST AddScheme(
    UINT                    uiID,
    LPTSTR                  lpszName,
    UINT                    uiNameSize,
    LPTSTR                  lpszDesc,
    UINT                    uiDescSize,
    PPOWER_POLICY           ppp
)
{
    PSCHEME_LIST psl;

    if (!lpszName || !lpszDesc) {
        DebugPrint( "AddScheme, invalid parameters");
        return NULL;
    }

    // If a scheme of this name already exists just return a pointer to it.
    psl = FindScheme(lpszName, FALSE);
    if ( NULL == psl )
    {
        // Allocate and initalize a Scheme element for the scheme list.
        psl = LocalAlloc(0, sizeof(SCHEME_LIST) );
        if ( NULL == psl )
            return psl; // out of memory
    }
    else
    {
        //  remove the entry from the list and free allocated memory
        RemoveEntryList(&psl->leSchemeList);
        g_uiSchemeCount --;
        LocalFree( psl->lpszName );
        LocalFree( psl->lpszDesc );
        LocalFree( psl->ppp );
    }

    //  Update the Scheme
    psl->uiID     = uiID;
    psl->lpszName = LocalAlloc(0, uiNameSize);
    psl->lpszDesc = LocalAlloc(0, uiDescSize);
    psl->ppp      = LocalAlloc(0, sizeof(POWER_POLICY));

    if (psl->lpszName && psl->lpszDesc && psl->ppp) {
        lstrcpy(psl->lpszName, lpszName);
        lstrcpy(psl->lpszDesc, lpszDesc);
        memcpy(psl->ppp, ppp, sizeof(POWER_POLICY));
        InsertTailList(&g_leSchemeList, &psl->leSchemeList);
        g_uiSchemeCount++;
        return psl;
    }

    LocalFree(psl->lpszName);
    LocalFree(psl->lpszDesc);
    LocalFree(psl->ppp);
    LocalFree(psl);
    psl = NULL;

    return psl;
}

/*******************************************************************************
*
*  PowerSchemeEnumProc
*   Builds the policies list.
*
*  DESCRIPTION:
*
*  PARAMETERS:
*   lParam  - Is the ID of the currently active power scheme.
*
*******************************************************************************/

BOOLEAN CALLBACK PowerSchemeEnumProc(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPTSTR                  lpszName,
    DWORD                   dwDescSize,
    LPTSTR                  lpszDesc,
    PPOWER_POLICY           ppp,
    LPARAM                  lParam
)
{
    PSCHEME_LIST psl;

    // Validate the new scheme.
    if (ValidateUISchemeFields(ppp)) {

        // Allocate and initalize a policies element.
        if ((psl = AddScheme(uiID, lpszName, dwNameSize, lpszDesc,
                             dwDescSize, ppp)) != NULL) {

            // Save a valid entry for error recovery.
            g_pslValid = psl;

            // Setup currently active policies pointer.
            if ((UINT)lParam == uiID) {
                g_pslCurActive = psl;
            }
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  PowerSchemeDlgInit
*
*  DESCRIPTION:
*   Initialize the power scheme dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN PowerSchemeDlgInit(
    HWND                    hWnd,
    PPOWER_SCHEME_DLG_INFO  ppsdi
)
{
    UINT uiCurrentSchemeID;
    UINT i;

    // On WINNT, only power users may add new power schemes.
    if (CanUserWritePwrScheme()) {
        ShowWindow(GetDlgItem(hWnd, IDC_SAVEAS), SW_SHOW);
        ShowWindow(GetDlgItem(hWnd, IDC_DELETE), SW_SHOW);
    }
    else {
        ShowWindow(GetDlgItem(hWnd, IDC_SAVEAS), SW_HIDE);
        ShowWindow(GetDlgItem(hWnd, IDC_DELETE), SW_HIDE);
    }

    ppsdi->hwndSchemeList = GetDlgItem(hWnd, IDC_SCHEMECOMBO);
    ClearSchemeList();

    // Get the currently active power scheme.
    if (GetActivePwrScheme(&uiCurrentSchemeID)) {

        // Get the Policies list from PowrProf.
        for (i = 0; i < 2; i++) {
            if (EnumPwrSchemes(PowerSchemeEnumProc, (LPARAM)uiCurrentSchemeID) &&
                g_pslCurActive) {

                g_pslCurSel = g_pslCurActive;

                // Setup UI show/hide state variables.
                g_uiWhenComputerIsState = CONTROL_HIDE;
                if (g_SysPwrCapabilities.SystemS1 ||
                    g_SysPwrCapabilities.SystemS2 ||
                    g_SysPwrCapabilities.SystemS3) {
                    g_uiStandbyState = CONTROL_ENABLE;
                    g_uiWhenComputerIsState = CONTROL_ENABLE;
                }
                else {
                    g_uiStandbyState = CONTROL_HIDE;
                }

                if (g_bVideoLowPowerSupported) {
                    g_uiMonitorState = CONTROL_ENABLE;
                    g_uiWhenComputerIsState = CONTROL_ENABLE;
                }
                else {
                    g_uiMonitorState = CONTROL_HIDE;
                }

                if (g_SysPwrCapabilities.DiskSpinDown) {
                    g_uiDiskState = CONTROL_ENABLE;
                    RangeLimitIDarray(g_uiSpinDownIDs,
                                      HIWORD(g_uiSpindownMaxMin)*60,
                                      LOWORD(g_uiSpindownMaxMin)*60);
                }
                else {
                    g_uiDiskState = CONTROL_HIDE;
                }

                if (g_bRunningUnderNT &&
                    g_SysPwrCapabilities.SystemS4 &&
                    g_SysPwrCapabilities.SystemS5 &&
                    g_SysPwrCapabilities.HiberFilePresent) {
                    g_uiHiberState = CONTROL_ENABLE;
                }
                else {
                    g_uiHiberState = CONTROL_HIDE;
                }

                // Update the UI.
                HandleCurSchemeChanged(hWnd);
                return TRUE;
            }
            else {
                DebugPrint( "PowerSchemeDlgInit, failure enumerating schemes. g_pslCurActive: %X", g_pslCurActive);
                if (g_pslValid) {
                    if (SetActivePwrScheme(g_pslValid->uiID, NULL, g_pslValid->ppp)) {
                        uiCurrentSchemeID = g_pslValid->uiID;
                        ClearSchemeList();
                    }
                    else {
                        DebugPrint( "PowerSchemeDlgInit, unable to set valid scheme");
                    }
                }
                else {
                    DebugPrint( "PowerSchemeDlgInit, no valid schemes");
                    break;
                }
            }
        }
    }

    DisableControls(hWnd, g_uiNumPwrSchemeCntrls, g_pcPowerScheme);
    return FALSE;
}

/*******************************************************************************
*
*  RefreshSchemes
*
*  DESCRIPTION:
*   Update the power schemes combobox list.
*
*  PARAMETERS:
*   hWnd    - Power schemes dialog hWnd.
*   pslSel  - Power scheme to leave selected on exit.
*
*******************************************************************************/

VOID RefreshSchemes(
    HWND            hWnd,
    PSCHEME_LIST    pslSel
)
{
    PSCHEME_LIST    psl, pslNext;
    UINT            uiIndex;

    SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO, CB_RESETCONTENT, FALSE, 0L);

    for (psl = (PSCHEME_LIST)g_leSchemeList.Flink;
         psl != (PSCHEME_LIST)&g_leSchemeList; psl = pslNext) {

        pslNext = (PSCHEME_LIST) psl->leSchemeList.Flink;

        // Add the schemes to the combo list box.
        uiIndex = (UINT) SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO, CB_ADDSTRING,
                                            0, (LPARAM) psl->lpszName);
        if (uiIndex != CB_ERR) {
            SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO, CB_SETITEMDATA,
                               uiIndex, (LPARAM) psl);
        }
        else {
            DebugPrint( "RefreshSchemes, CB_ADDSTRING failed: %s", psl->lpszName);
        }
    }

    // Select the passed entry.
    if (pslSel) {
        uiIndex = (UINT) SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO, CB_FINDSTRINGEXACT,
                                            (WPARAM)-1, (LPARAM)pslSel->lpszName);
        if (uiIndex != CB_ERR) {
            uiIndex = (UINT) SendDlgItemMessage(hWnd, IDC_SCHEMECOMBO, CB_SETCURSEL,
                                                (WPARAM)uiIndex, 0);
            if (uiIndex == CB_ERR) {
                DebugPrint( "RefreshSchemes, CB_SETCURSEL failed: %s, index: %d", psl->lpszName, uiIndex);
            }
        }
        else {
            DebugPrint( "RefreshSchemes, CB_FINDSTRINGEXACT failed: %s", psl->lpszName);
        }
    }
}

/*******************************************************************************
*
*  StripBlanks
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT StripBlanks(LPTSTR lpszString)
{
    LPTSTR lpszPosn, lpszSrc;

    /* strip leading blanks */
    lpszPosn = lpszString;
    while(*lpszPosn == TEXT(' ')) {
            lpszPosn++;
    }
    if (lpszPosn != lpszString)
        lstrcpy(lpszString, lpszPosn);

    /* strip trailing blanks */
    if ((lpszPosn=lpszString+lstrlen(lpszString)) != lpszString) {
        lpszPosn = CharPrev(lpszString, lpszPosn);
        while(*lpszPosn == TEXT(' '))
           lpszPosn = CharPrev(lpszString, lpszPosn);
        lpszPosn = CharNext(lpszPosn);
        *lpszPosn = TEXT('\0');
    }
    return lstrlen(lpszString);
}

/*******************************************************************************
*
*  MsgBoxId
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LONG MsgBoxId(
    HWND    hWnd,
    UINT    uiCaption,
    UINT    uiFormat,
    LPTSTR  lpszParam,
    UINT    uiFlags
)
{
    LPTSTR  lpszCaption;
    LPTSTR  lpszText;
    LONG    lRet = 0;

    lpszCaption = LoadDynamicString(uiCaption);
    if (lpszCaption) {
        lpszText = LoadDynamicString(uiFormat, lpszParam);
        if (lpszText) {
            lRet = MessageBox(hWnd, lpszText, lpszCaption, uiFlags);
            LocalFree(lpszText);
        }
        LocalFree(lpszCaption);
    }
    return lRet;
}

/*******************************************************************************
*
*  DoDeleteScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DoDeleteScheme(HWND hWnd, LPTSTR lpszName)
{
    LPTSTR          lpszCaption;
    LPTSTR          lpszText;
    PSCHEME_LIST    psl, pslDelete;

    // Dont't allow delete unless we have at least two schemes.
    if ((g_uiSchemeCount < 2) || !(pslDelete = FindScheme(lpszName, TRUE))) {
        return FALSE;
    }

    // Get confirmation from the user.
    if (IDYES == MsgBoxId(hWnd, IDS_CONFIRMDELETECAPTION, IDS_CONFIRMDELETE,
                          lpszName, MB_YESNO | MB_ICONQUESTION)) {

        // If we deleted the currently active scheme set the next scheme active.
        if (pslDelete == g_pslCurActive) {
            if ((psl = FindNextScheme(lpszName)) &&
                (SetActivePwrSchemeReport(hWnd, psl->uiID, NULL, psl->ppp))) {
                g_pslCurActive = psl;
            }
            else {
                return FALSE;
            }
        }

        // Remove requested scheme.
        if (DeletePwrScheme(pslDelete->uiID)) {
            RemoveScheme(NULL, lpszName);
            g_pslCurSel = g_pslCurActive;
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  FindNextScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

PSCHEME_LIST FindNextScheme(LPTSTR lpszName)
{
    PSCHEME_LIST psl, pslFirst, pslNext;

    for (pslFirst = psl = (PSCHEME_LIST)g_leSchemeList.Flink;
        psl != (PSCHEME_LIST)&g_leSchemeList; psl = pslNext) {

        pslNext = (PSCHEME_LIST) psl->leSchemeList.Flink;

        if (!lstrcmpi(lpszName, psl->lpszName)) {
            if (pslNext != (PSCHEME_LIST)&g_leSchemeList) {
                return pslNext;
            }
            else {
                return pslFirst;
            }
        }
    }
    DebugPrint( "FindNextScheme, unable to find: %s", lpszName);
    return NULL;
}

/*******************************************************************************
*
*  DoSaveScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DoSaveScheme(HWND hWnd)
{
    POWER_POLICY    ppSave;
    BOOLEAN         bSavedCurrent;
    PSCHEME_LIST    pslTemplateScheme = g_pslCurSel;

    // Make a copy of the template scheme to restore after the save.
    memcpy(&ppSave, pslTemplateScheme->ppp, sizeof(ppSave));

    // Get any changes the user might have made for the new scheme.
    GetControls(hWnd, g_uiNumPwrSchemeCntrls, g_pcPowerScheme);
    MapHiberTimer(g_pslCurSel->ppp, TRUE);


    if (IDOK != DialogBoxParam(g_hInstance,
                               MAKEINTRESOURCE(IDD_SAVE),
                               hWnd,
                               SaveAsDlgProc,
                               (LPARAM)&bSavedCurrent)) {
        return FALSE;
    }

    // Restore the template scheme if we didn't save the current scheme.
    if (!bSavedCurrent) {
        memcpy(pslTemplateScheme->ppp, &ppSave, sizeof(ppSave));
        return TRUE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\pwrresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       PWRRESID.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*******************************************************************************/

#ifndef _INC_PWRRESID
#define _INC_PWRRESID

#define IDC_STATIC                      -1

// Top level dialog box control identifiers.
#define IDD_POWERSCHEME                 100
#define IDD_POWERSCHEME_NOBAT           101
#define IDD_BATMETERCFG                 102
#define IDD_ALARMPOLICY                 103
#define IDD_ADVANCEDPOLICY              104
#define IDD_HIBERNATE                   105
#define IDD_APM                         110
#define IDD_UPS							111

// UPS dialog box ID's 
#define IDD_APCABOUT					112
#define IDD_UPSDETAILS					113
#define IDD_UPSSELECT					114
#define IDD_UPSCUSTOM					115
#define IDD_UPSCONFIGURATION			116

// Advanced dialogs box control identifiers.
#define IDD_ALARMACTIONS                106
#define IDD_ADVPOWERSCHEME              107
#define IDD_ADVPOWERSCHEME_NOBAT        108

// Misc. dialog box control identifiers.
#define IDD_SAVE                        109

//  Control identifiers of IDD_POWERSCHEME and IDD_POWERSCHEME_NOBAT

#define IDC_SCHEMECOMBO                 1000
#define IDC_SAVEAS                      1001
#define IDC_DELETE                      1002
#define IDC_SETTINGSFOR                 1004
#define IDC_STANDBYACCOMBO              1005
#define IDC_STANDBYDCCOMBO              1006
#define IDC_MONITORACCOMBO              1007
#define IDC_MONITORDCCOMBO              1008
#define IDC_GOONSTANDBY                 1009
#define IDC_TURNOFFMONITOR              1010
#define IDC_WHENCOMPUTERIS              1011
#define IDC_PLUGGEDIN                   1012
#define IDC_RUNNINGONBAT                1013
#define IDC_NO_HELP_0                   1014
#define IDC_POWERSCHEMESTEXT            1015
#define IDC_DISKACCOMBO                 1016
#define IDC_DISKDCCOMBO                 1017
#define IDC_TURNOFFHARDDISKS            1018
#define IDC_HIBERACCOMBO                1019
#define IDC_HIBERDCCOMBO                1020
#define IDC_SYSTEMHIBERNATES            1021
#define IDC_NO_HELP_7                   1022

//  Control identifiers of IDD_ALARMPOLICY
#define IDC_CRITACTION                  1100
#define IDC_LOWACTION                   1101
#define IDC_LOALARMSLIDER               1102
#define IDC_CRITALARMSLIDER             1103
#define IDC_LOWALARMLEVEL               1104
#define IDC_CRITALARMLEVEL              1105
#define IDC_LOBATALARMENABLE            1106
#define IDC_CRITBATALARMENABLE          1107
#define IDC_POWERCFGGROUPBOX3           1110
#define IDC_POWERCFGGROUPBOX4           1111
#define IDC_NO_HELP_1                   1112
#define IDC_NO_HELP_2                   1113
#define IDC_NO_HELP_3                   1114
#define IDC_NO_HELP_4                   1115

// Maintain order
#define IDC_LOALARMNOTIFICATION         1120
#define IDC_LOALARMPOWERMODE            1121
#ifdef WINNT
#define IDC_LOALARMPROGRAM              1122
#endif
#define IDC_CRITALARMNOTIFICATION       1123
#define IDC_CRITALARMPOWERMODE          1124
#ifdef WINNT
#define IDC_CRITALARMPROGRAM            1125
#endif

//  Control identifiers of IDD_BATMETERCFG
#define IDC_POWERSTATUSGROUPBOX         1201
#define IDC_SHOWTIME                    1202
#define IDC_ENABLEMULTI                 1204
#define IDC_STATIC_FRAME_BATMETER       1205

//  Control identifiers of IDD_ADVANCEDPOLICY
#define IDC_LIDCLOSETEXT                1300
#define IDC_LIDCLOSEACTION              1301
#define IDC_PWRBUTTONTEXT               1302
#define IDC_PWRBUTACTION                1303
#define IDC_POWERBUTGROUP               1304
#define IDC_ENABLEMETER                 1306
#define IDC_PASSWORD                    1307
#define IDC_NO_HELP_5                   1308
#define IDC_OPTIONSGROUPBOX             1309
#define IDC_SLPBUTTONTEXT               1310
#define IDC_SLPBUTACTION                1311
#define IDC_VIDEODIM                    1312

//  Control identifiers of IDD_HIBERNATE
#define IDC_HIBERNATE                   1400
#define IDC_FREESPACE                   1401
#define IDC_REQUIREDSPACE               1402
#define IDC_NOTENOUGHSPACE              1403
#define IDC_DISKSPACEGROUPBOX           1404
#define IDC_FREESPACETEXT               1405
#define IDC_REQUIREDSPACETEXT           1406
#define IDC_HIBERNATEGROUPBOX           1407
#define IDC_NO_HELP_6                   1408

// Control identifiers of IDD_APM
#define IDC_APMENABLE                   1500


//  Control identifiers of IDD_ALARMACTIONS.

#define IDC_ENABLELOWSTATE              1600
#define IDC_ALARMACTIONPOLICY           1601
#define IDC_ALARMIGNORENONRESP          1602
#define IDC_NOTIFYWITHSOUND             1603
#define IDC_NOTIFYWITHTEXT              1605
#define IDC_POWERCFGGROUPBOX5           1608
#define IDC_POWERCFGGROUPBOX6           1609
#define IDC_POWERCFGGROUPBOX7           1610
#ifdef WINNT
#define IDC_RUNPROGCHECKBOX             1611
#define IDC_RUNPROGWORKITEM             1612
#endif

//  Control identifiers of IDD_SAVE
#define IDC_SAVENAMEEDIT                1700
#define IDC_SAVETEXT                    1701

// Control identifiers of IDD_UPS
// UPS Selection dialog (1800-1819)
#define IDC_VENDOR_TEXT                 1800
#define IDC_VENDOR_LIST                 1801
#define IDC_MODEL_TEXT                  1802
#define IDC_MODEL_LIST                  1803
#define IDC_PORT_TEXT                   1804
#define IDC_PORT_LIST                   1805
#define IDB_SELECT_FINISH               1806
#define IDB_SELECT_NEXT					1807

// UPS Custom pin settings dialog  (1820-1839)
#define IDC_CUSTOM_FRAME                1820
#define IDC_ONBAT_CHECK                 1821
#define IDC_ONBAT_POS                   1822
#define IDC_ONBAT_NEG                   1823
#define IDC_LOWBAT_CHECK                1824
#define IDC_LOWBAT_POS                  1825
#define IDC_LOWBAT_NEG                  1826
#define IDC_TURNOFF_CHECK               1827
#define IDC_TURNOFF_POS                 1828
#define IDC_TURNOFF_NEG                 1829
#define IDB_CUSTOM_BACK                 1830
#define IDB_CUSTOM_FINISH               1831
#define IDC_CUSTOM_CAVEAT               1832

// UPS Configuration dialog  (1840 - 1879)
#define IDC_NOTIFYCHECKBOX              1840
#define IDC_WAITTEXT	                1841
#define IDC_WAITEDITBOX                 1842
#define IDC_WAITSPIN                    1843
#define IDC_REPEATTEXT	                1844
#define IDC_REPEATEDITBOX               1845
#define IDC_REPEATSPIN                  1846

#define IDC_SHUTDOWNGROUPBOX            1847
#define IDC_SHUTDOWNTEXT                1848
#define IDC_SHUTDOWNTIMEREDITBOX        1849
#define IDC_TIMERSPIN                   1850
#define IDC_LOWBATTERYSHUTDOWNTEXT      1851
#define IDC_POWERACTIONTEXT             1852
#define IDC_POWERACTIONCOMBO            1853
#define IDC_RUNTASKCHECKBOX             1854
#define IDC_CONFIGURETASKBUTTON         1855
#define IDC_LOWBATTERYCHECKBOX          1856
#define IDC_SHUTDOWNTIMERCHECKBOX       1857
#define IDC_TASKNAMETEXT                1858
#define IDC_TURNOFFCHECKBOX             1859

// UPS Details dialog (1880 - 1899)
#define IDC_UPS_INFO					1880
#define IDC_NO_DETAILED_INFO            1881
#define IDC_MANUFACTURER_LHS            1882
#define IDC_MANUFACTURER                1883
#define IDC_MODEL_LHS                   1884
#define IDC_MODEL                       1885
#define IDC_SERIAL_NUMBER_LHS           1886
#define IDC_SERIAL_NUMBER               1887
#define IDC_FIRMWARE_REVISION_LHS       1888
#define IDC_FIRMWARE_REVISION           1889


// UPS Page (1900 - 1949)

#define IDC_STATUS_GROUPBOX             1900
#define IDC_POWER_SOURCE_ICON			1901
#define IDC_POWER_SOURCE_LHS            1902
#define IDC_POWER_SOURCE                1903
#define IDC_RUNTIME_REMAINING_LHS       1904
#define IDC_RUNTIME_REMAINING           1905
#define IDC_BATTERY_CAPACITY_LHS        1906
#define IDC_BATTERY_CAPACITY            1907
#define IDC_BATTERY_STATUS_LHS          1908
#define IDC_BATTERY_STATUS              1909

#define IDC_DETAILS_GROUPBOX            1920
#define IDC_VENDOR_NAME_LHS             1921
#define IDC_VENDOR_NAME                 1922
#define IDC_MODEL_TYPE_LHS              1923
#define IDC_MODEL_TYPE                  1924

#define IDC_MESSAGE_ICON				1931
#define IDC_MESSAGE_TEXT                1932
#define IDC_SERVICE_TEXT                1933
#define IDC_SERVICE_PROGRESS            1934
#define IDC_SERVICE_CLOSE               1935

#define IDB_APCLOGO_SMALL               1940
#define IDB_APCLOGO_LARGE               1941
#define IDB_UPS_ICON_BUTTON             1942
#define IDB_INSTALL_UPS                 1943
#define IDB_CONFIGURE_SVC               1944
#define IDC_APC1						1945
#define IDC_APC2						1946
#define IDC_UPS_TITLE                   1947

// UPS About dialog ID's (2000-2010)
#define IDC_APCURL                      2000

// UPS String ID's
#define IDS_APCURL						300
#define IDS_OUTOFWAITRANGE              301
#define IDS_OUTOFREPEATRANGE            302
#define IDS_NOTIFYCAPTION               303
#define IDS_OUTOFSHUTDELAYRANGE         304
#define IDS_SHUTDOWNCAPTION             305
#define IDS_SHUTDOWN_TASKNAME			306

#define IDS_LOW_BATTERY_SHUTDOWN        310
#define IDS_ON_BATTERY_SHUTDOWN         311
#define IDS_NO_SHUTDOWN                 312
#define IDS_UPS_TURNOFF_IMMEDIATELY     313
#define IDS_UPS_TURNOFF_AFTER           314
#define IDS_UPS_NO_TURNOFF              315
#define IDS_DWORD                       316
#define IDS_STRING                      317
#define IDS_RUNTIME_REMAINING           318
#define IDS_CAPACITY					319
#define IDS_CAPACITY_CHARGING			320
#define IDS_UTILITYPOWER_UNKNOWN        321
#define IDS_UTILITYPOWER_ON             322
#define IDS_UTILITYPOWER_OFF            323
#define IDS_BATTERYSTATUS_UNKNOWN       324
#define IDS_BATTERYSTATUS_OK            325
#define IDS_BATTERYSTATUS_BAD           326
#define IDS_URLLINK                     327
#define IDS_NO_UPS_VENDOR               328
#define IDS_OTHER_UPS_VENDOR            329
#define IDS_CUSTOM_UPS_MODEL            330
#define IDS_COM_PORT_PREFIX             331
#define IDS_CUSTOM_CAPTION              332
#define IDS_CAVEAT_TEXT                 333
#define IDS_NO_UPS_INSTALLED			334		//info
#define IDS_UPS_STOPPED                 335		//warning
#define IDS_START_UPS                   336		//progress
#define IDS_STOP_UPS                    337		//progress
#define IDS_PRESS_APPLY                 338		//info
#define IDS_COMM_LOST                   339		//critical


//  String ID's.
#define IDS_APPNAME                     90
#define IDS_INFO                        91
#define IDS_LOWSOUNDEVENT               94
#define IDS_CRITSOUNDEVENT              95
#define IDS_ALARMACTIONS                96
#define IDS_ALARMLEVELFORMAT            97
#define IDS_ALARMSTATUSSOUND            98
#define IDS_ALARMSTATUSTEXT             99
#define IDS_CRITBAT                     102
#define IDS_LOWBAT                      103
#define IDS_SETTINGSFORMAT              104
#define IDS_ADVSETTINGSFORMAT           105
#define IDS_BLANKNAME                   106
#define IDS_CONFIRMDELETECAPTION        107
#define IDS_CONFIRMDELETE               108
#define IDS_SAVESCHEME                  109
#define IDS_BYTES                       110
#define IDS_MBYTES                      111
#define IDS_POWEREDBYUPS                112
#define IDS_NOACTION                    113
#define IDS_BROWSETITLE                 114

#define IDS_UNKNOWN                     150
#define IDS_NONE                        151
#define IDS_STANDBY                     153
#define IDS_HIBERNATE                   154
//#define IDS_SHUTDOWN                    155   FREE - USE ME
#define IDS_POWEROFF                    156
#define IDS_DONOTHING                   157
#define IDS_PROMPT                      158

#define IDS_NEVER                       160
#define IDS_01_MIN                      161
#define IDS_02_MIN                      162
#define IDS_03_MIN                      163
#define IDS_05_MIN                      164
#define IDS_10_MIN                      165
#define IDS_15_MIN                      166
#define IDS_20_MIN                      167
#define IDS_25_MIN                      168
#define IDS_30_MIN                      169
#define IDS_45_MIN                      170
#define IDS_01_HOUR                     171
#define IDS_02_HOUR                     172
#define IDS_03_HOUR                     173
#define IDS_04_HOUR                     174
#define IDS_05_HOUR                     175
#define IDS_06_HOUR                     176

// Error string ID's
#define IDS_UNKNOWN_ERROR               177
#define IDS_UNABLETOSETHIBER            178
#define IDS_UNABLETOSETPOLICY           179
#define IDS_UNABLETOSETGLOBALPOLICY     180
#define IDS_UNABLETOSETACTIVEPOLICY     181
#define IDS_UNABLETOSETRUNPROG          182

// Icon ID's
#define IDI_PLUG                        200
#define IDI_BATTERY                     201
#define IDI_PWRMNG                      202
#define IDI_HIBERNATE                   203
#define IDI_UPS							204
#define IDI_INFO						205
#define IDI_ALERT						206
#define IDI_CRITICAL					207

// APM ID's
#define IDS_DEVCHANGE_RESTART           220
#define IDS_DEVCHANGE_CAPTION           221

#endif // _INC_PWRRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by powercfg.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\apcabout.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright 1999 American Power Conversion, All Rights Reserved
//
//  Name:   apcabout.h
//
//  Author: PaulB
//
//  Description
//  ===========
//  

#ifndef _APC_ABOUT_H_
#define _APC_ABOUT_H_

void DisplayAboutDialogBox (HWND aParentWnd);

#endif //_APC_ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

!ENDIF

!include ..\powercfg.inc

SOURCES_USED    = $(SOURCES_USED) ..\powercfg.inc

TARGETNAME      = powercfg
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
DLLENTRY        = DllInitialize
TARGETEXT       = cpl

TARGETLIBS      = $(SDK_LIB_PATH)\advapi32.lib       \
                  $(SDK_LIB_PATH)\user32.lib         \
                  $(SDK_LIB_PATH)\gdi32.lib          \
                  $(SDK_LIB_PATH)\kernel32.lib       \
                  $(SHELL_LIB_PATH)\shfusion.lib     \
                  $(SHELL_LIB_PATH)\shell32p.lib     \
                  $(DDK_LIB_PATH)\batmeter.lib     \
                  $(SDK_LIB_PATH)\powrprof.lib       \
                  $(SDK_LIB_PATH)\ntdll.lib          \
                  $(SDK_LIB_PATH)\setupapi.lib       \
                  $(SDK_LIB_PATH)\shlwapi.lib        \
!ifndef TARGET_WIN95
                  $(SDK_LIB_PATH)\oleaut32.lib       \
                  $(SDK_LIB_PATH)\uuid.lib       \
!endif
                  ..\ups\lib\$(O)\ups.lib

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217 

USE_MSVCRT      = 1

DLLDEF          = $O\powercfg.def


SOURCES         = ..\powercfg.c      \
                  ..\alarm.c         \
                  ..\batmtrcf.c      \
                  ..\getset.c        \
                  ..\hibernat.c      \
                  ..\prshthlp.c      \
                  ..\pwrschem.c      \
                  ..\pwrswtch.c      \
                  ..\ntapm.c         \
                  ..\powercfg.rc
 
 
# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\pwrswtch.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       PWRSWTCH.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Support for Advanced page of PowerCfg.Cpl.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>
#include <systrayp.h>
#include <help.h>
#include <powercfp.h>

#include "powercfg.h"
#include "pwrresid.h"
#include "PwrMn_cs.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

// This structure is filled in by the Power Policy Manager at CPL_INIT time.
extern SYSTEM_POWER_CAPABILITIES g_SysPwrCapabilities;
extern BOOL g_bRunningUnderNT;

// Machine is currently capable of hibernate, managed by code in hibernat.c.
extern UINT g_uiPwrActIDs[];
extern UINT g_uiLidActIDs[];

// A systary change requires PowerSchemeDlgProc re-init.
extern BOOL g_bSystrayChange;

// Persistant storage of this data is managed by POWRPROF.DLL API's.
GLOBAL_POWER_POLICY  g_gpp;

// Show/hide UI state variables.
DWORD g_dwShowPowerButtonUI;
DWORD g_dwShowSleepButtonUI;
DWORD g_dwShowLidUI;
DWORD g_dwShowPwrButGrpUI;
DWORD g_dwShowEnableSysTray;
DWORD g_uiPasswordState;
DWORD g_uiVideoDimState;

// Static flags:
UINT g_uiEnableSysTrayFlag       = EnableSysTrayBatteryMeter;
UINT g_uiEnablePWLogonFlag       = EnablePasswordLogon;
UINT g_uiEnableVideoDimDisplay   = EnableVideoDimDisplay;

// Indicies into combobox selections
UINT g_uiDoNothing;
UINT g_uiAskMeWhatToDo;
UINT g_uiShutdown;

// Global marking whether sheet is dirty
BOOL g_bDirty;

// Button policies dialog controls descriptions:

#define NUM_BUTTON_POL_CONTROLS 10

// Handy indicies into our g_pcButtonPol control array:
#define ID_LIDCLOSETEXT     0
#define ID_LIDCLOSEACTION   1
#define ID_PWRBUTTONTEXT    2
#define ID_PWRBUTACTION     3
#define ID_SLPBUTTONTEXT    4
#define ID_SLPBUTACTION     5
#define ID_ENABLEMETER      6
#define ID_PASSWORD         7
#define ID_VIDEODIM         8
#define ID_POWERBUTGROUP    9

POWER_CONTROLS g_pcButtonPol[NUM_BUTTON_POL_CONTROLS] =
{// Control ID              Control Type    Data Address                        Data Size                                   Parameter Pointer                           Enable/Visible State Pointer
    IDC_LIDCLOSETEXT,       STATIC_TEXT,    NULL,                               0,                                          NULL,                                       &g_dwShowLidUI,
    IDC_LIDCLOSEACTION,     COMBO_BOX,      NULL,                               sizeof(g_gpp.user.LidCloseDc.Action),       (LPDWORD)&g_gpp.user.LidCloseDc.Action,     &g_dwShowLidUI,
    IDC_PWRBUTTONTEXT,      STATIC_TEXT,    NULL,                               0,                                          NULL,                                       &g_dwShowPowerButtonUI,
    IDC_PWRBUTACTION,       COMBO_BOX,      NULL,                               sizeof(g_gpp.user.PowerButtonDc.Action),    (LPDWORD)&g_gpp.user.PowerButtonDc.Action,  &g_dwShowPowerButtonUI,
    IDC_SLPBUTTONTEXT,      STATIC_TEXT,    NULL,                               0,                                          NULL,                                       &g_dwShowSleepButtonUI,
    IDC_SLPBUTACTION,       COMBO_BOX,      NULL,                               sizeof(g_gpp.user.SleepButtonDc.Action),    (LPDWORD)&g_gpp.user.SleepButtonDc.Action,  &g_dwShowSleepButtonUI,
    IDC_ENABLEMETER,        CHECK_BOX,      &g_gpp.user.GlobalFlags,            sizeof(g_gpp.user.GlobalFlags),             &g_uiEnableSysTrayFlag,                     &g_dwShowEnableSysTray,
    IDC_PASSWORD,           CHECK_BOX,      &g_gpp.user.GlobalFlags,            sizeof(g_gpp.user.GlobalFlags),             &g_uiEnablePWLogonFlag,                     &g_uiPasswordState,
    IDC_VIDEODIM,           CHECK_BOX,      &g_gpp.user.GlobalFlags,            sizeof(g_gpp.user.GlobalFlags),             &g_uiEnableVideoDimDisplay,                 &g_uiVideoDimState,
    IDC_POWERBUTGROUP,      STATIC_TEXT,    NULL,                               0,                                          NULL,                                       &g_dwShowPwrButGrpUI,
};

// "Power Switches" Dialog Box (IDD_BUTTONPOLICY == 104) help array:

const DWORD g_PowerSwitchHelpIDs[]=
{
    IDC_OPTIONSGROUPBOX,IDH_COMM_GROUPBOX,
    IDC_POWERBUTGROUP,  IDH_COMM_GROUPBOX,
    IDC_LIDCLOSEACTION, IDH_104_1301,   // "Lid close action dropdown" (ComboBox)
    IDC_LIDCLOSETEXT,   IDH_104_1301,
    IDC_PWRBUTACTION,   IDH_104_1303,   // "Power button action dropdown" (ComboBox)
    IDC_PWRBUTTONTEXT,  IDH_104_1303,
    IDC_SLPBUTACTION,   IDH_104_1304,   // "Sleep button action dropdown" (ComboBox)
    IDC_SLPBUTTONTEXT,  IDH_104_1304,
    IDC_ENABLEMETER,    IDH_102_1203,   // "&Show meter on taskbar." (Button)
    IDC_PASSWORD,       IDH_107_1500,   // "Prompt for &password when bringing computer out of standby." (Button)
    IDC_VIDEODIM,       IDH_108_1503,   // "&Dim display when running on batteries." (Button)
    IDI_PWRMNG,         NO_HELP,
    IDC_NO_HELP_5,      NO_HELP,
    0, 0
};

void ActionEventCodeToSelection (HWND hwnd, int iDlgItem, const POWER_ACTION_POLICY *pPAP)

{
    ULONG   ulEventCode;
    DWORD   dwSelection;

    //  Special case PowerActionNone. This could be:
    //      "Shut Down"
    //      "Ask me what to do"
    //      "Do nothing"

    if (pPAP->Action == PowerActionNone)
    {
        ulEventCode = pPAP->EventCode & (POWER_USER_NOTIFY_BUTTON | POWER_USER_NOTIFY_SHUTDOWN);
        if ((ulEventCode & POWER_USER_NOTIFY_SHUTDOWN) != 0)
        {
            dwSelection = g_uiShutdown;
        }
        else if ((ulEventCode & POWER_USER_NOTIFY_BUTTON) != 0)
        {
            dwSelection = g_uiAskMeWhatToDo;
        }
        else
        {
            dwSelection = g_uiDoNothing;
        }
        (LRESULT)SendDlgItemMessage(hwnd, iDlgItem, CB_SETCURSEL, dwSelection, 0);
    }
}

void SelectionToActionEventCode (HWND hwnd, int iDlgItem, DWORD dwMissingItems, POWER_ACTION_POLICY *pPAP)

{
    ULONG   ulEventCode;
    DWORD   dwSelection;

    // Special case the "Power Switch" UI. Always turn off the POWER_USER_NOTIFY_POWER_BUTTON
    // and POWER_USER_NOTIFY_SLEEP_BUTTON flag because it doesn't mean anything for action
    // other than PowerActionNone. Turn it on for PowerActionNone otherwise the SAS
    // window will not get the message posted. The SAS window has the logic to check
    // the registry setting.

    pPAP->EventCode &= ~(POWER_USER_NOTIFY_BUTTON | POWER_USER_NOTIFY_SHUTDOWN | POWER_FORCE_TRIGGER_RESET);
    if (pPAP->Action == PowerActionNone)
    {
        dwSelection = (DWORD)SendDlgItemMessage(hwnd, iDlgItem, CB_GETCURSEL, 0, 0);

        // dwMissingItems is a special variable that's used SOLELY for the purpose of
        // getting the lid switch to work. The other switches have 5 options available:
        //
        //  Do nothing
        //  Ask me what to do
        //  Sleep
        //  Hibernate
        //  Shut Down
        //
        // The lid switch doesn't allow "Ask me what to do" so all of the items get
        // shifted by one and the comparisons are wrong. What the lid switch selection
        // extractor passes in to this function is the "fudge factor" to get this right.
        // Note because "Do nothing" is always available there's no need to compromise
        // for it. Just keep doing the same old same old.

        if (dwSelection == g_uiDoNothing)
        {
            ulEventCode = POWER_FORCE_TRIGGER_RESET;
        }
        else if ((dwSelection + dwMissingItems) == g_uiAskMeWhatToDo)
        {
            ulEventCode = POWER_USER_NOTIFY_BUTTON;
        }
        else if ((dwSelection + dwMissingItems) == g_uiShutdown)
        {
            ulEventCode = POWER_USER_NOTIFY_SHUTDOWN;
        }
        else
        {
            ulEventCode = 0;
        }
        pPAP->EventCode |= ulEventCode;
    }
}

/*******************************************************************************
*
*  SetAdvancedDlgProcData
*
*  DESCRIPTION:
*   Set up the data pointers in g_pcButtonPol depending on hibernate state.
*   Set the data to the controls. If bPreserve is TRUE get the current
*   values UI values and restore them after updating the listboxes.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID SetAdvancedDlgProcData(HWND hWnd, BOOL bRestoreCurrent)
{
    UINT    ii;
    UINT    jj;

    // Set the state of the show/hide UI state variables.
    if (g_SysPwrCapabilities.SystemS1 ||
        g_SysPwrCapabilities.SystemS2 ||
        g_SysPwrCapabilities.SystemS3 ||
        (g_SysPwrCapabilities.SystemS4 &&
         g_SysPwrCapabilities.HiberFilePresent)) {
        int err;
        HKEY hPowerPolicy;
        DWORD Value;
        DWORD dwType ;
        DWORD dwSize ;

        g_uiPasswordState = CONTROL_ENABLE;

        //
        // Check for policy forcing the password always on
        //
        err = RegOpenKeyEx( HKEY_CURRENT_USER,
                            POWER_POLICY_KEY,
                            0,
                            KEY_READ,
                            &hPowerPolicy );
        if (err == 0) {
            dwSize = sizeof(Value);
            err = RegQueryValueEx(hPowerPolicy,
                                  LOCK_ON_RESUME,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&Value,
                                  &dwSize);
            if ( (err == 0) && (dwType == REG_DWORD) && (Value != 0)) {
                g_uiPasswordState = CONTROL_DISABLE;
                g_gpp.user.GlobalFlags |= EnablePasswordLogon;
            }
        }

        RegCloseKey( hPowerPolicy );

    }
    else {
        g_uiPasswordState = CONTROL_HIDE;
    }

    if (bRestoreCurrent) {
        GetControls(hWnd, NUM_BUTTON_POL_CONTROLS, g_pcButtonPol);
    }

    //
    // Build the Action ID's for the Lid, Power Button and/or Sleep Button
    //
    ii=0;
    jj=0;

    g_uiLidActIDs[jj++] = IDS_DONOTHING;
    g_uiLidActIDs[jj++] = PowerActionNone;

    g_uiDoNothing = ii / 2;
    g_uiPwrActIDs[ii++] = IDS_DONOTHING;
    g_uiPwrActIDs[ii++] = PowerActionNone;
    g_uiAskMeWhatToDo = ii / 2;
    g_uiPwrActIDs[ii++] = IDS_PROMPT;
    g_uiPwrActIDs[ii++] = PowerActionNone;

    if (g_SysPwrCapabilities.SystemS1 ||
            g_SysPwrCapabilities.SystemS2 || g_SysPwrCapabilities.SystemS3) {
        g_uiPwrActIDs[ii++] = IDS_STANDBY;
        g_uiPwrActIDs[ii++] = PowerActionSleep;

        g_uiLidActIDs[jj++] = IDS_STANDBY;
        g_uiLidActIDs[jj++] = PowerActionSleep;
    }

    if (g_SysPwrCapabilities.HiberFilePresent) {
        g_uiPwrActIDs[ii++] = IDS_HIBERNATE;
        g_uiPwrActIDs[ii++] = PowerActionHibernate;

        g_uiLidActIDs[jj++] = IDS_HIBERNATE;
        g_uiLidActIDs[jj++] = PowerActionHibernate;
    }

    g_uiShutdown = ii / 2;
    g_uiPwrActIDs[ii++] = IDS_POWEROFF;
    g_uiPwrActIDs[ii++] = PowerActionNone;
    //g_uiLidActIDs[jj++] = IDS_POWEROFF;       WinBug 5.1 #352752 - "Shutdown" isn't valid for
    //g_uiLidActIDs[jj++] = PowerActionNone;    closing the lid.

    g_uiPwrActIDs[ii++] = 0;
    g_uiPwrActIDs[ii++] = 0;
    g_uiLidActIDs[jj++] = 0;
    g_uiLidActIDs[jj++] = 0;

    g_pcButtonPol[ID_LIDCLOSEACTION].lpvData = g_uiLidActIDs;
    g_pcButtonPol[ID_PWRBUTACTION].lpvData   = g_uiPwrActIDs;
    g_pcButtonPol[ID_SLPBUTACTION].lpvData   = g_uiPwrActIDs;

    //  Special case PowerActionShutdownOff. This is no longer
    //  supported in the UI. Convert this to "Shut Down".

    if (g_gpp.user.PowerButtonDc.Action == PowerActionShutdownOff)
    {
        g_gpp.user.PowerButtonDc.Action = PowerActionNone;
        g_gpp.user.PowerButtonDc.EventCode = POWER_USER_NOTIFY_SHUTDOWN;
        g_bDirty = TRUE;
    }
    if (g_gpp.user.SleepButtonDc.Action == PowerActionShutdownOff)
    {
        g_gpp.user.SleepButtonDc.Action = PowerActionNone;
        g_gpp.user.SleepButtonDc.EventCode = POWER_USER_NOTIFY_SHUTDOWN;
        g_bDirty = TRUE;
    }

    // Map power actions to allowed UI values.
    MapPwrAct(&g_gpp.user.LidCloseDc.Action, TRUE);
    MapPwrAct(&g_gpp.user.PowerButtonDc.Action, TRUE);
    MapPwrAct(&g_gpp.user.SleepButtonDc.Action, TRUE);

    // Only update the list boxes.
    SetControls(hWnd, NUM_BUTTON_POL_CONTROLS, g_pcButtonPol);

    // Map action and event code group to combobox selection.
    ActionEventCodeToSelection(hWnd, IDC_PWRBUTACTION, &g_gpp.user.PowerButtonDc);
    ActionEventCodeToSelection(hWnd, IDC_SLPBUTACTION, &g_gpp.user.SleepButtonDc);
    ActionEventCodeToSelection(hWnd, IDC_LIDCLOSEACTION, &g_gpp.user.LidCloseDc);
}

/*******************************************************************************
*
*  InitAdvancedDlg
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN InitAdvancedDlg(HWND hWnd)
{
    // Start off with the page not dirty.
    g_bDirty = FALSE;

    // If we can't read the global power policies hide
    // the controls on this page.
    if (!GetGlobalPwrPolicy(&g_gpp)) {
        HideControls(hWnd, NUM_BUTTON_POL_CONTROLS, g_pcButtonPol);
        return TRUE;
    }

    // Get the enable systray icon mask based on AC online/offline.
    g_uiEnableSysTrayFlag = EnableSysTrayBatteryMeter;

    if (g_SysPwrCapabilities.VideoDimPresent) {
        g_uiVideoDimState = CONTROL_ENABLE;
    }
    else {
        g_uiVideoDimState = CONTROL_HIDE;
    }

    g_dwShowEnableSysTray = CONTROL_ENABLE;
    g_dwShowPwrButGrpUI = CONTROL_HIDE;
    if (g_SysPwrCapabilities.LidPresent) {
        g_dwShowLidUI = CONTROL_ENABLE;
        g_dwShowPwrButGrpUI = CONTROL_ENABLE;
    }
    else {
        g_dwShowLidUI = CONTROL_HIDE;
    }


    //
    // Don't show the Power Button if S5 is not supported on the system
    //
    if (g_SysPwrCapabilities.PowerButtonPresent && g_SysPwrCapabilities.SystemS5) {
        g_dwShowPowerButtonUI = CONTROL_ENABLE;
        g_dwShowPwrButGrpUI   = CONTROL_ENABLE;
    }
    else {
        g_dwShowPowerButtonUI = CONTROL_HIDE;
    }

    //
    // Sleep Button - Don't show the sleep button if there are not any actions. 
    //
    if (g_SysPwrCapabilities.SleepButtonPresent &&
            (g_SysPwrCapabilities.SystemS1 || 
             g_SysPwrCapabilities.SystemS2 || 
             g_SysPwrCapabilities.SystemS3 ||
             (g_SysPwrCapabilities.SystemS4 && g_SysPwrCapabilities.HiberFilePresent)))
    {
        g_dwShowSleepButtonUI = CONTROL_ENABLE;
        g_dwShowPwrButGrpUI = CONTROL_ENABLE;
    }
    else {
        g_dwShowSleepButtonUI = CONTROL_HIDE;
    }

    SetAdvancedDlgProcData(hWnd, FALSE);

    // If we can't write the global power policies disable
    // the controls this page.
    if (!WriteGlobalPwrPolicyReport(hWnd, &g_gpp, FALSE))
    {
        DisableControls(hWnd, NUM_BUTTON_POL_CONTROLS, g_pcButtonPol);
    }
    return TRUE;
}

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  AdvancedDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK AdvancedDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    NMHDR FAR   *lpnm;
    UINT        uiID;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return InitAdvancedDlg(hWnd);

#ifdef WINNT
        case WM_CHILDACTIVATE:
            // Reinitialize since the hibernate tab may have changed
            // the hibernate state, NT only.
            SetAdvancedDlgProcData(hWnd, TRUE);
            break;
#endif

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY:
                    // Fetch data from dialog controls.
                    if (g_bDirty)
                    {
                        GetControls(hWnd, NUM_BUTTON_POL_CONTROLS, g_pcButtonPol);

                        // Map combobox selection to action and event code group.

                        SelectionToActionEventCode(hWnd, IDC_PWRBUTACTION, 0, &g_gpp.user.PowerButtonDc);
                        SelectionToActionEventCode(hWnd, IDC_SLPBUTACTION, 0, &g_gpp.user.SleepButtonDc);
                        SelectionToActionEventCode(hWnd, IDC_LIDCLOSEACTION, 1, &g_gpp.user.LidCloseDc);

                        g_gpp.user.LidCloseAc.Action =
                            g_gpp.user.LidCloseDc.Action;
                        g_gpp.user.LidCloseAc.EventCode =
                            g_gpp.user.LidCloseDc.EventCode;
                        g_gpp.user.PowerButtonAc.Action =
                            g_gpp.user.PowerButtonDc.Action;
                        g_gpp.user.PowerButtonAc.EventCode =
                            g_gpp.user.PowerButtonDc.EventCode;
                        g_gpp.user.SleepButtonAc.Action =
                            g_gpp.user.SleepButtonDc.Action;
                        g_gpp.user.SleepButtonAc.EventCode =
                            g_gpp.user.SleepButtonDc.EventCode;

                        if (WriteGlobalPwrPolicyReport(hWnd, &g_gpp, TRUE))
                        {
                            GetActivePwrScheme(&uiID);
                            SetActivePwrSchemeReport(hWnd, uiID, &g_gpp, NULL);

                            // Enable or disable battery meter service on systray.
                            SysTray_EnableService(STSERVICE_POWER,
                                                  g_gpp.user.GlobalFlags &
                                                  g_uiEnableSysTrayFlag);
                            g_bDirty = FALSE;
                        }
                    }
                    break;

                case PSN_SETACTIVE:
                    // Hibernate page may have changed the hibernate state,
                    // reinitialize the dependent part of Advanced page.
                    SetAdvancedDlgProcData(hWnd, TRUE);
                    break;
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_SLPBUTACTION:
                case IDC_PWRBUTACTION:
                case IDC_LIDCLOSEACTION:
                    if (HIWORD(wParam) == LBN_SELCHANGE) {
                        // Let parent know something changed.
                        MarkSheetDirty(hWnd, &g_bDirty);
                    }
                    break;

                case IDC_VIDEODIM:
                case IDC_PASSWORD:
                case IDC_ENABLEMETER:
                    // Enable the parent dialog Apply button on change.
                    MarkSheetDirty(hWnd, &g_bDirty);
                    break;

            }
            break;

        case PCWM_NOTIFYPOWER:
            // Notification from systray, user has changed a PM UI setting.
            g_bSystrayChange = TRUE;
            break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_PowerSwitchHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_PowerSwitchHelpIDs);
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\apcabout.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       APCABOUT.C
*
*  VERSION:     1.0
*
*  AUTHOR:      PaulB
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:
*******************************************************************************/

#include "upstab.h"
#include "..\pwrresid.h"
#pragma hdrstop

// functions
///////////////////////////////////////////////////////////////////////////////

static INT_PTR CALLBACK APCAboutDlgProc (HWND aDlgHWND,
                                      UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam);
static BOOL APCAboutDlgHandleInit    (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
static BOOL APCAboutDlgHandleCommand (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void DisplayAboutDialogBox (HWND aParentWnd);
//
// Description: This function displays the about dialog box.
//
// Additional Information:
//
// Parameters:
//
//   HWND aParentWnd :- Handle to the main UPS page.
//
// Return Value: None
//
void DisplayAboutDialogBox (HWND aParentWnd) {
  DialogBox(GetUPSModuleHandle(), MAKEINTRESOURCE(IDD_APCABOUT), aParentWnd, APCAboutDlgProc);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL CALLBACK APCAboutDlgProc (HWND aDlgHWND,
//                                UINT uMsg,
//                                WPARAM wParam,
//                                LPARAM lParam);
//
// Description: This is the
// \<A HREF="ms-its:C:\Program%20Files\Microsoft%20Visual%20Studio\MSDN98\98VS\1033\winui.chm::/devdoc/live/pdui/dlgboxes_5lib.htm">DialogProc\</A>
//              for the APC about box.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Identifies the dialog box.
//
//   UINT uMsg :- Specifies the message.
//
//   WPARAM wParam :- Specifies additional message-specific information.
//
//   LPARAM lParam :- Specifies additional message-specific information.
//
// Return Value: Except in response to the WM_INITDIALOG message, the dialog
//               box procedure should return nonzero if it processes the
//               message, and zero if it does not.
//
INT_PTR CALLBACK APCAboutDlgProc (HWND aDlgHWND,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam) {
  BOOL bRes = FALSE;

  switch (uMsg) {
    case WM_INITDIALOG: {
      //The dialog box procedure should return TRUE to direct the system to
      //set the keyboard focus to the control given by wParam.
      bRes = APCAboutDlgHandleInit(aDlgHWND, wParam, lParam);
      break;
      }
    case WM_COMMAND: {
      //If an application processes this message, it should return zero.
      bRes = APCAboutDlgHandleCommand(aDlgHWND, wParam, lParam);
      break;
      }
    case WM_CLOSE: {
      EndDialog( aDlgHWND, IDOK);
      bRes = TRUE;
      break;
      }
    default: {
      break;
      }
    } // switch (uMsg)

  return(FALSE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL APCAboutDlgHandleInit (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
//
// Description: This is the handler function for the APC about box
//              WM_INITDIALOG message.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Identifies the dialog box.
//
//   WPARAM wParam :- Handle of control to receive focus
//
//   LPARAM lParam :- Initialization parameter
//
// Return Value: The dialog box procedure should return TRUE to direct the
//               system to set the keyboard focus to the control given by
//               wParam.
//
BOOL APCAboutDlgHandleInit (HWND aDlgHWND, WPARAM wParam, LPARAM lParam) {

	TCHAR urlBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
	HWND hControl = NULL;

	LoadString( GetUPSModuleHandle(),
				IDS_APCURL,
				urlBuffer,
				sizeof(urlBuffer)/sizeof(TCHAR));

	if ((hControl = GetDlgItem(aDlgHWND, IDC_APCURL)) != NULL)
	{
		SetWindowText(hControl, urlBuffer);
	}

	return(TRUE);
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL APCAboutDlgHandleCommand (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
//
// Description: This is the handler function for the APC about box WM_COMMAND
//              message.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Handle to dialog box
//
//   WPARAM wParam :- HIWORD(wParam) gives the notification code.
//                    LOWORD(wParam) gives the control id.
//
//   LPARAM lParam :- Gives the HWND or handle of the control.
//
// Return Value: If an application processes this message, it should return 0.
//
BOOL APCAboutDlgHandleCommand (HWND aDlgHWND, WPARAM wParam, LPARAM lParam) {
  BOOL bRes = FALSE;
  DWORD ctrlID = LOWORD(wParam);

  switch (ctrlID) {
    case IDOK:
    case IDCANCEL: { //The escape key
      EndDialog(aDlgHWND, ctrlID);
      break;
      }
    default: {
      break;
      }
    }//end switch

  //If an application processes this message, it should return zero.
  return(bRes);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\regdefs.h ===
//Generated code, do not edit...


#ifndef _REGDEFS_H_
#define _REGDEFS_H_


#ifdef __cplusplus
extern "C"{
#endif


  ServiceProviderStructure _theStaticProvidersTable[] = {
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Back-UPS"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Back-UPS Pro"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Basic Port on Communications Accessory"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Basic signaling to any APC UPS"), TEXT("0x77;")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Matrix-UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("PowerStack"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Smart-UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Smart signaling to any APC UPS"), TEXT("0x7F;apcups.dll")},
    {TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders\\American Power Conversion"), TEXT("Symmetra Power Array"), TEXT("0x7F;apcups.dll")},
    {NULL, NULL, NULL}
  };


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsapplet.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright 1999 American Power Conversion, All Rights Reserved
//
//  Name:   upsapplet.cpp
//
//  Author: Noel Fegan
//
//  Description
//  ===========
//  
//  Revision History
//  ================
//  04 May 1999 - nfegan@apcc.com : Added this comment block.
//  04 May 1999 - nfegan@apcc.com : Preparing for code inspection
//

#include "upstab.h"

#include <objbase.h>
#include <shlobj.h>
#include <initguid.h>
#include "upsapplet.h"
#pragma hdrstop

extern "C" HINSTANCE   g_theInstance = 0;
UINT        g_cRefThisDll = 0;          // Reference count for this DLL

// {DE5637D2-E12D-11d2-8844-00600844D03F}
DEFINE_GUID(CLSID_ShellExtension, 
0xde5637d2, 0xe12d, 0x11d2, 0x88, 0x44, 0x0, 0x60, 0x8, 0x44, 0xd0, 0x3f);

//
// DllMain is the DLL's entry point.
//
// Input parameters:
//   hInstance  = Instance handle
//   dwReason   = Code specifying the reason DllMain was called
//   lpReserved = Reserved (do not use)
//
// Returns:
//   TRUE if successful, FALSE if not
//

///////////////////////////////////////////////////////////////////////////////

extern "C" int APIENTRY DllMain (HINSTANCE hInstance, DWORD dwReason,
    LPVOID lpReserved)
{
    //
    // If dwReason is DLL_PROCESS_ATTACH, save the instance handle so it
    // can be used again later.
    //
    if (dwReason == DLL_PROCESS_ATTACH) 
    {
        g_theInstance = hInstance;
        DisableThreadLibraryCalls(g_theInstance);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// In-process server functions

//
// DllGetClassObject is called by the shell to create a class factory object.
//
// Input parameters:
//   rclsid = Reference to class ID specifier
//   riid   = Reference to interface ID specifier
//   ppv    = Pointer to location to receive interface pointer
//
// Returns:
//   HRESULT code signifying success or failure
//

STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;
    //
    // Make sure the class ID is CLSID_ShellExtension. Otherwise, the class
    // factory doesn't support the object type specified by rclsid.
    //
    if (!IsEqualCLSID (rclsid, CLSID_ShellExtension))
  {
    //Error
    return ResultFromScode (CLASS_E_CLASSNOTAVAILABLE);
  }

    //
    // Instantiate a class factory object.
    //
    CClassFactory *pClassFactory = new CClassFactory ();

    if (pClassFactory == NULL)
  {
    //Error
        return ResultFromScode (E_OUTOFMEMORY);
  }

    //
    // Get the interface pointer from QueryInterface and copy it to *ppv.
    //

    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);
    pClassFactory->Release ();
    return hr;
}

//
// DllCanUnloadNow is called by the shell to find out if the DLL can be
// unloaded. The answer is yes if (and only if) the module reference count
// stored in g_cRefThisDll is 0.
//
// Input parameters:
//   None
//
// Returns:
//   HRESULT code equal to S_OK if the DLL can be unloaded, S_FALSE if not
//

STDAPI DllCanUnloadNow (void)
{
    return ResultFromScode ((g_cRefThisDll == 0) ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CClassFactory member functions

CClassFactory::CClassFactory ()
{
    m_cRef = 1;
    g_cRefThisDll++;
}

CClassFactory::~CClassFactory ()
{
    g_cRefThisDll--;
}

STDMETHODIMP CClassFactory::QueryInterface (REFIID riid, LPVOID FAR *ppv)
{

    if (IsEqualIID (riid, IID_IUnknown)) {
        *ppv = (LPUNKNOWN) (LPCLASSFACTORY) this;
        m_cRef++;
    return NOERROR;
    }

    else if (IsEqualIID (riid, IID_IClassFactory)) {
        *ppv = (LPCLASSFACTORY) this;
        m_cRef++;
        return NOERROR;
    }

    else {  
        *ppv = NULL;
        return ResultFromScode (E_NOINTERFACE);


    }
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef ()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassFactory::Release ()
{
    if (--m_cRef == 0)
        delete this;
    return m_cRef;
}

//
// CreateInstance is called by the shell to create a shell extension object.
//
// Input parameters:
//   pUnkOuter = Pointer to controlling unknown
//   riid      = Reference to interface ID specifier
//   ppvObj    = Pointer to location to receive interface pointer
//
// Returns:
//   HRESULT code signifying success or failure
//

STDMETHODIMP CClassFactory::CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
    LPVOID FAR *ppvObj)
{
    *ppvObj = NULL;

    //
    // Return an error code if pUnkOuter is not NULL, because we don't
    // support aggregation.
    //
    if (pUnkOuter != NULL)
        return ResultFromScode (CLASS_E_NOAGGREGATION);

    //
    // Instantiate a shell extension object.
    //
    CShellExtension *pShellExtension = new CShellExtension ();

    if (pShellExtension == NULL)
        return ResultFromScode (E_OUTOFMEMORY);

    // Get the interface pointer from QueryInterface and copy it to *ppvObj.
    //
    HRESULT hr = pShellExtension->QueryInterface (riid, ppvObj);
    pShellExtension->Release ();
    return hr;
}

//
// LockServer increments or decrements the DLL's lock count.
//

STDMETHODIMP CClassFactory::LockServer (BOOL fLock)
{
    return ResultFromScode (E_NOTIMPL);
}

/////////////////////////////////////////////////////////////////////////////
// CShellExtension member functions

CShellExtension::CShellExtension ()
{
    m_cRef = 1;
    g_cRefThisDll++;
}

CShellExtension::~CShellExtension ()
{
    g_cRefThisDll--;
}

STDMETHODIMP CShellExtension::QueryInterface (REFIID riid, LPVOID FAR *ppv)
{
    if (IsEqualIID (riid, IID_IUnknown)) {
        *ppv = (LPUNKNOWN) (LPSHELLPROPSHEETEXT) this;
        m_cRef++;
        return NOERROR;
    }

    else if (IsEqualIID (riid, IID_IShellPropSheetExt)) {
        *ppv = (LPSHELLPROPSHEETEXT) this;
        m_cRef++;
        return NOERROR;
    }

    else if (IsEqualIID (riid, IID_IShellExtInit)) {
        *ppv = (LPSHELLEXTINIT) this;
        m_cRef++;
        return NOERROR;
    }
    
    else {
        *ppv = NULL;  
        return ResultFromScode (E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CShellExtension::AddRef ()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CShellExtension::Release () {
  if (--m_cRef == 0) {
    delete this;
    }

  return(m_cRef);
  }

//
// AddPages is called by the shell to give property sheet shell extensions
// the opportunity to add pages to a property sheet before it is displayed.
//
// Input parameters:
//   lpfnAddPage = Pointer to function called to add a page
//   lParam      = lParam parameter to be passed to lpfnAddPage
//
// Returns:
//   HRESULT code signifying success or failure
//

STDMETHODIMP CShellExtension::AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,
                                        LPARAM lParam) {
  PROPSHEETPAGE psp;
  HPROPSHEETPAGE hUPSPage = NULL;
  HMODULE hModule = GetUPSModuleHandle();
  
  ZeroMemory(&psp, sizeof(psp));

  psp.dwSize = sizeof(psp);
  psp.dwFlags = PSP_USEREFPARENT;
  psp.hInstance = hModule;
  psp.pszTemplate = TEXT("IDD_UPS_EXT");
  psp.pfnDlgProc = UPSMainPageProc;
  psp.pcRefParent = &g_cRefThisDll;
  
  hUPSPage = CreatePropertySheetPage (&psp);

  //
  // Add the pages to the property sheet.
  //
  if (hUPSPage != NULL) {      
    if (!lpfnAddPage(hUPSPage, lParam)) {
      DestroyPropertySheetPage(hUPSPage);
      }
    }

  return(NOERROR);
  }

//
// ReplacePage is called by the shell to give control panel extensions the
// opportunity to replace control panel property sheet pages. It is never
// called for conventional property sheet extensions, so we simply return
// a failure code if called.
//
// Input parameters:
//   uPageID         = Page to replace
//   lpfnReplaceWith = Pointer to function called to replace a page
//   lParam          = lParam parameter to be passed to lpfnReplaceWith
//
// Returns:
//   HRESULT code signifying success or failure
//

STDMETHODIMP CShellExtension::ReplacePage (UINT uPageID,
                       LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return ResultFromScode (E_FAIL);
}

//
// Initialize is called by the shell to initialize a shell extension.
//
// Input parameters:
//   pidlFolder = Pointer to ID list identifying parent folder
//   lpdobj     = Pointer to IDataObject interface for selected object(s)
//   hKeyProgId = Registry key handle
//
// Returns:
//   HRESULT code signifying success or failure
//

STDMETHODIMP CShellExtension::Initialize (LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpdobj, HKEY hKeyProgID)
{
  return ResultFromScode (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ups
TARGETTYPE=LIBRARY

INCLUDES=..\..\;$(BASEDIR)\private\ntos\inc;

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_ -DNTOS_KERNEL=1 -DUNICODE -D_UNICODE


SOURCES=..\apcabout.c \
        ..\upscommon.c \
        ..\upsconfig.c \
        ..\upscustom.c \
        ..\upsinfo.c \
        ..\upsreg.c \
        ..\upsselect.c \
        ..\upstab.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upscommon.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSCOMMON.H
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION: This file contains common decls and defs used by the UPS dialogs.
********************************************************************************/


#ifndef _UPS_COMMON_H_
#define _UPS_COMMON_H_


#ifdef __cplusplus
extern "C" {
#endif

#define PWRMANHLP       TEXT("PWRMN.HLP")
#define UPS_EXE_FILE     _T("upsapplet.dll") // the executable
#define UPS_SERVICE_NAME _T("UPS")

#define DATA_NO_CHANGE      0x00
#define SERVICE_DATA_CHANGE 0x01
#define CONFIG_DATA_CHANGE  0x02

//////////////////////////////////////////////////////////////////////////_/_//
// HMODULE GetUPSModuleHandle (void);
//
// Description: This function gets the HMODULE of the module that created
//              the UPS tab dialog.
//
// Additional Information: 
//
// Parameters: None
//
// Return Value: Returns the HMODULE of the module that created the dialog.
//
HMODULE GetUPSModuleHandle (void);

void InitializeApplyButton (HWND hDlg);
void EnableApplyButton     (void);

BOOL RestartService  (LPCTSTR aServiceName, BOOL bWait);
BOOL StartOffService (LPCTSTR aServiceName, BOOL bWaitForService);
void StopService     (LPCTSTR aServiceName);

BOOL  IsServiceRunning     (LPCTSTR aServiceName);

DWORD GetActiveDataState (void);
void  SetActiveDataState (DWORD aNewValue);
void  AddActiveDataState (DWORD aBitToSet);

#ifdef __cplusplus
}
#endif

#endif // _UPS_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upscommon.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSCOMMON.C
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION: This file contains functions that are used by various different module,
*				or are generic enough to be used by varoius different modules even if 
*				they are only being used in one place at present.
********************************************************************************/

#include "upstab.h"
#include "prsht.h"
#pragma hdrstop

// static data
///////////////////////////////////////////////////////////////////////////////

static HWND g_hUPSPage = 0;                //Used in
                                           //InitializeApplyButton and
                                           //EnableApplyButton

static DWORD g_CurrentActiveDataState = 0; //Used in
                                           //AddActiveDataState
                                           //GetActiveDataState and
                                           //SetActiveDataState

extern HINSTANCE g_hInstance;			   //Global instance handle of this DLL

// functions
///////////////////////////////////////////////////////////////////////////////

DWORD GetServiceStatus_Control (LPCTSTR aServiceName, LPDWORD lpStatus);
DWORD GetServiceStatus_Query   (LPCTSTR aServiceName, LPDWORD lpStatus);
DWORD GetServiceStatus_Enum    (LPCTSTR aServiceName, LPDWORD lpStatus);

DWORD ManageService       (LPCTSTR aServiceName,
                           DWORD aDesiredSCAccess,
                           DWORD aDesiredServiceAccess,
                           DWORD aAction,
                           BOOL bWait,
                           DWORD aWaitStatus,
						   LPDWORD lpStatus);

BOOL WaitForServiceStatus (SC_HANDLE aHandle, DWORD aStatus);
DWORD LoadUPSString       (DWORD aMsgID,
                           LPTSTR aMessageBuffer,
                           DWORD * aBufferSizePtr);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// HMODULE GetUPSModuleHandle (void);
//
// Description: This function gets the HMODULE of the module that created
//              the UPS tab dialog.
//
// Additional Information: 
//
// Parameters: None
//
// Return Value: Returns the HMODULE of the module that created the dialog.
//
HMODULE GetUPSModuleHandle (void) {
  static HMODULE hModule = NULL;
  
  if (hModule == NULL) {
#ifdef _APC_
    hModule = GetModuleHandle(UPS_EXE_FILE);
#else
    hModule = g_hInstance;
#endif
    }

  return(hModule);
  }


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void InitializeApplyButton (HWND aDlgHWND);
//
// Description: This function sets the data needed to allow the
//              EnableApplyButton to 
//
// Additional Information: 
//
// Parameters:
//
//   HWND aDlgHWND :- 
//
// Return Value: None
//
void InitializeApplyButton (HWND aDlgHWND) {
  _ASSERT(g_hUPSPage == 0);
  _ASSERT(aDlgHWND != 0);

  g_hUPSPage = aDlgHWND;
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void EnableApplyButton (void);
//
// Description: This function enables the "Apply" button on the main UPS page
//
// Additional Information: 
//
// Parameters: None
//
// Return Value: None
//
void EnableApplyButton (void) {
  HWND hParent = 0;

  _ASSERT(g_hUPSPage != 0); //Should call InitializeApplyButton
                            //to initialize.

  hParent = GetParent(g_hUPSPage);
  PropSheet_Changed(hParent, g_hUPSPage);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL RestartService (LPCTSTR aServiceName, BOOL bWait);
//
// Description: This function restarts the specified service
//
// Additional Information: 
//
// Parameters:
//
//   LPCTSTR aServiceName :- The name of the service to restart
//
//   BOOL bWait :- A BOOL that specifies if the process should wait for the
//                 the service to fully restart. If TRUE then this process
//                 returns when the service has fully restarted. If FALSE
//                 then this process tells the service to start but does
//                 not wait around for it to be fully started before returning.
//
// Return Value: If the given service restarts successfully then this function
//               returns TRUE, otherwise it returns FALSE.
//
BOOL RestartService (LPCTSTR aServiceName, BOOL bWait) {
  StopService(aServiceName);

  return(StartOffService(aServiceName, bWait));
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL StartOffService (LPCTSTR aServiceName, BOOL bWaitForService);
//
// Description: This function starts the specified service
//
// Additional Information: 
//
// Parameters:
//
//   LPCTSTR aServiceName :- The name of the service to start
//
//   BOOL bWaitForService :- A BOOL that specifies if the process should wait
//                           for the the service to fully start. If TRUE then
//                           this process returns when the service has fully
//                           started. If FALSE then this process tells the
//                           service to start but does not wait around for it
//                           to be fully started before returning.
//
// Return Value: If the given service starts successfully then this function
//               returns TRUE, otherwise it returns FALSE.
//
BOOL StartOffService (LPCTSTR aServiceName, BOOL bWaitForService) {
  BOOL bStartedOK = FALSE;
  SC_HANDLE hManager = NULL;

  if ((hManager = OpenSCManager(NULL, NULL, GENERIC_READ)) != NULL) {
    SC_HANDLE service_handle = NULL;
    
    if ((service_handle = OpenService(hManager,
                                      aServiceName,
                                      SERVICE_START | SERVICE_INTERROGATE | SERVICE_QUERY_STATUS)) != NULL) {
      SERVICE_STATUS service_status;

      SetLastError(0);

      ZeroMemory(&service_status, sizeof(service_status));

      if ((bStartedOK = StartService(service_handle,
                                     0,
                                     NULL)) == TRUE) {
        SetLastError(0);
        if (bWaitForService == TRUE) {
          bStartedOK = WaitForServiceStatus(service_handle, SERVICE_RUNNING);
          }
        }
      else {
        _ASSERT(FALSE);
        }

      if (CloseServiceHandle(service_handle) == FALSE) {
        _ASSERT(FALSE);
        //error closing service configuration manager
        }
      }

    if (CloseServiceHandle(hManager) == FALSE) {
      //error closing service configuration manager
      _ASSERT(FALSE);
      }
    }

  return(bStartedOK);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL WaitForServiceStatus (SC_HANDLE aHandle, DWORD aStatus);
//
// Description: This function waits for the service identified by the given
//              service handle to enter the given state.
//
// Additional Information: 
//
// Parameters:
//
//   SC_HANDLE aHandle :- A handle to an open service.
//
//   DWORD aStatus :- The status to wait for. The allows value for this
//                    parameter are defined by the dwCurrentState member of the
//                    structure.
//
// Return Value: 
//
BOOL WaitForServiceStatus (SC_HANDLE aHandle, DWORD aStatus) {
  SERVICE_STATUS service_status;
  DWORD dwOldCheck = 0;
  BOOL bStatusSet = FALSE;
  
  ZeroMemory(&service_status, sizeof(service_status));

  bStatusSet = QueryServiceStatus(aHandle, &service_status);

  if (bStatusSet == FALSE) {
    return(bStatusSet);
    }

  while (service_status.dwCurrentState != aStatus) {
    dwOldCheck = service_status.dwCheckPoint;

    Sleep(service_status.dwWaitHint);

    if ((bStatusSet = QueryServiceStatus(aHandle, &service_status)) == FALSE) {
      break;
      }

    if (dwOldCheck >= service_status.dwCheckPoint) {
      break;
      }
    }//end while

  if (service_status.dwCurrentState == aStatus) {
    bStatusSet = TRUE;
    }
  else {
    TCHAR errMessageBuffer[MAX_PATH] = TEXT("");
    DWORD errMessageBufferSize = MAX_PATH;
    bStatusSet = FALSE;

    //Must load the error message from "netmsg.dll"

    if ((LoadUPSString(service_status.dwWin32ExitCode,
                       errMessageBuffer,
                       &errMessageBufferSize) == ERROR_SUCCESS) &&
        (*errMessageBuffer != TEXT('\0'))) {
      MessageBox(NULL, errMessageBuffer, NULL, MB_OK | MB_ICONEXCLAMATION);
      }
    }

  return(bStatusSet);
  }


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD LoadUPSString (DWORD aMsgID, 
//                      LPTSTR aMessageBuffer, 
//                      DWORD * aBufferSizePtr);
//
// Description: This function load the string resource identified by aMsgID
//              into the buffer identified by aMessageBuffer
//
// Additional Information: 
//
// Parameters:
//
//   DWORD aMsgID :- ID of string resource to load
//
//   LPTSTR aMessageBuffer :- Pointer to a buffer where the string is to be
//                            copied.
//
//   DWORD * aBufferSizePtr :- The size of the buffer. 
//
// Return Value: Returns a Win32 error code. ERROR_SUCCESS on success.
//
DWORD LoadUPSString (DWORD aMsgID,
                     LPTSTR aMessageBuffer,
                     DWORD * aBufferSizePtr) {
  LPTSTR lpBuf = NULL; // Will Hold text of the message (allocated by FormatMessage
  DWORD errStatus = ERROR_SUCCESS;
  DWORD numChars = 0;
  HMODULE hNetMsg = LoadLibrary(TEXT("netmsg.dll"));

  if (hNetMsg != NULL) {
    if (numChars = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                  (LPCVOID) hNetMsg,
                                  aMsgID,
                                  0,
                                  (LPTSTR) &lpBuf,
                                  *aBufferSizePtr,
                                  (va_list *)0) == 0) {

      *aBufferSizePtr = 0;
      *aMessageBuffer = TEXT('\0');
      }
    else {
      if (aBufferSizePtr != NULL) {
        if (numChars < *aBufferSizePtr) {
          //the given buffer is big enough to hold the string

          if (aMessageBuffer != NULL) {
            _tcscpy(aMessageBuffer, lpBuf);
            }
          }
        *aBufferSizePtr = numChars;
        }

      LocalFree(lpBuf);
      }

    FreeLibrary(hNetMsg);
    }

  return(errStatus);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void StopService (LPCTSTR aServiceName);
//
// Description: This function stops the service named.
//
// Additional Information: 
//
// Parameters:
//
//   LPCTSTR aServiceName :- The name of the service
//
// Return Value: None
//
void StopService (LPCTSTR aServiceName) {
	DWORD dwStatus = SERVICE_STOPPED;
	DWORD dwError = ERROR_SUCCESS;

	dwError = ManageService(aServiceName,
                GENERIC_READ,
                SERVICE_STOP | SERVICE_INTERROGATE | SERVICE_QUERY_STATUS,
                SERVICE_CONTROL_STOP,
                TRUE,
                SERVICE_STOPPED,
				&dwStatus);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL IsServiceRunning (LPCTSTR aServiceName);
//
// Description: This function checks if the service named is running.
//
// Additional Information: 
//
// Parameters:
//
//   LPCTSTR aServiceName :- The name of the service
//
// Return Value: TRUE if the service is running, FALSE otherwise.
//
BOOL IsServiceRunning (LPCTSTR aServiceName)
{
	DWORD dwStatus = SERVICE_STOPPED;

	// There are three methods of retrieving the service status
	// 1. Interrogate the service using ControlService()	- most accurate
	// 2. Query the service using QueryServiceStatus()		- most efficient
	// 3. Query the service using EnumServicesStatus()		- most accessible

	if (GetServiceStatus_Control(aServiceName, &dwStatus) != ERROR_SUCCESS)
	{
		if (GetServiceStatus_Query(aServiceName, &dwStatus) != ERROR_SUCCESS)
		{
			GetServiceStatus_Enum(aServiceName, &dwStatus);
		}
    }

  return(SERVICE_RUNNING == dwStatus);
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD GetServiceStatus_Control (LPCTSTR aServiceName, LPDWORD lpStatus);
//
// Description: This function returns the status of the service named
//              using the Win32 API call ControlService().  This is the
//              most accurate way to retrieve the service staus.
//
// Parameters:
//
//   IN
//   LPCTSTR aServiceName :- The name of the service
//
//   OUT
//   LPDWORD  lpStatus     :- The service status  
//
// Return Value: Returns a Win32 error code. ERROR_SUCCESS on success.
//
DWORD GetServiceStatus_Control (LPCTSTR aServiceName, LPDWORD lpStatus)
{
	DWORD dwError = ERROR_SUCCESS;
	*lpStatus = SERVICE_STOPPED;

	dwError = ManageService(aServiceName,
							SC_MANAGER_ENUMERATE_SERVICE,
							SERVICE_INTERROGATE | SERVICE_QUERY_STATUS,
							SERVICE_CONTROL_INTERROGATE,
							FALSE,
							0,
							lpStatus);

	return dwError;
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD GetServiceStatus_Query (LPCTSTR aServiceName, LPDWORD lpStatus);
//
// Description: This function returns the status of the service named.
//              using the Win32 API call QueryServiceStatus().  This is the
//              most efficient way to retrieve the service staus.
//
// Parameters:
//
//   IN
//   LPCTSTR aServiceName :- The name of the service
//
//   OUT
//   LPDWORD  lpStatus     :- The service status  
//
// Return Value: Returns a Win32 error code. ERROR_SUCCESS on success.
//
DWORD GetServiceStatus_Query (LPCTSTR aServiceName, LPDWORD lpStatus)
{
	DWORD dwError = ERROR_SUCCESS;
	SC_HANDLE hManager = NULL;

	*lpStatus = SERVICE_STOPPED;

	if (NULL != (hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE)))
	{
		SC_HANDLE service_handle = NULL;
		if (NULL != (service_handle = OpenService(hManager,
										  aServiceName,
										  SERVICE_QUERY_STATUS)))
		{
		  SERVICE_STATUS service_status;
		  ZeroMemory(&service_status, sizeof(service_status));

		  if( QueryServiceStatus(service_handle, &service_status) != 0 )
		  {
			  *lpStatus = service_status.dwCurrentState;
		  }
		  else
		  {
			  dwError = GetLastError();
		  }

          if (CloseServiceHandle(service_handle) == FALSE)
          {
            _ASSERT(FALSE);
            //error closing service configuration manager
          }
		}
		else
		{
			dwError = GetLastError();
		}

	    if (CloseServiceHandle(hManager) == FALSE)
        {
	      //error closing service configuration manager
	      _ASSERT(FALSE);
        }
	}
	else
	{
		dwError = GetLastError();
	}

	return dwError;
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD GetServiceStatus_Enum (LPCTSTR aServiceName, LPDWORD lpStatus);
//
// Description: This function returns the status of the service named.
//              using the Win32 API call EnumServicesStatus().  This call
//              requires the mimimum access privileges but is the most
//              inefficient accurate way to retrieve the service staus.
//
// Parameters:
//
//   IN
//   LPCTSTR aServiceName :- The name of the service
//
//   OUT
//   LPDWORD  lpStatus     :- The service status  
//
// Return Value: Returns a Win32 error code. ERROR_SUCCESS on success.
//
DWORD GetServiceStatus_Enum (LPCTSTR aServiceName, LPDWORD lpStatus)
{
    DWORD dwError = ERROR_SUCCESS;
    SC_HANDLE hManager;

    _ASSERT( NULL != lpStatus );
    *lpStatus = SERVICE_STOPPED;

    hManager = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );
    if ( NULL != hManager )
    {
        SC_HANDLE hService = OpenService( hManager, aServiceName, SERVICE_QUERY_STATUS );
        if ( NULL != hService )
        {
            SERVICE_STATUS ss;

            BOOL bRet = QueryServiceStatus( hService, &ss );
            if ( bRet )
            {
                *lpStatus = ss.dwCurrentState;
            }
            else
            {
                dwError = GetLastError( );
            }

            CloseServiceHandle( hService );
            // what do you do if this fails?
        }
        else
        {
            dwError = GetLastError( );
        }

        CloseServiceHandle( hManager );
        // what do you do if this fails?
    }
    else
    {
        dwError = GetLastError( );
    }

    return dwError;
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ManageService (LPCTSTR aServiceName, 
//                      DWORD aDesiredSCAccess, 
//                      DWORD aDesiredServiceAccess, 
//                      DWORD aAction, 
//                      BOOL bWait, 
//                      DWORD aWaitStatus
//						LPDWORD lpStatus);
//
// Description: This function opens the service named and performs the
//              specified control request on the given service. The
//              function optionally waits on the service to enter the
//              specified status.
//
// Additional Information: 
//
// Parameters:
//
//   LPCTSTR aServiceName :- The name of the service
//
//   DWORD aDesiredSCAccess :- The access to use to open the service control
//                             manager.
//
//   DWORD aDesiredServiceAccess :- The access to use to open the service.
//
//   DWORD aAction :- Specifies the requested control code.
//
//   BOOL bWait :- TRUE specifies that this process should wait for the service
//                 to reach the state identified by aWaitStatus.
//
//   DWORD aWaitStatus :- The service state to wait for.
//
//   OUT
//   LPDWORD lpStatus :- The service status
//
// Return Value: Returns a Win32 error code. ERROR_SUCCESS on success.
//
DWORD ManageService (LPCTSTR aServiceName,
                     DWORD aDesiredSCAccess,
                     DWORD aDesiredServiceAccess,
                     DWORD aAction,
                     BOOL bWait,
                     DWORD aWaitStatus,
					 LPDWORD lpStatus)
{
  DWORD dwError = ERROR_SUCCESS;
  SC_HANDLE hManager = NULL;

  *lpStatus = SERVICE_STOPPED;
  
  if ((hManager = OpenSCManager(NULL, NULL, aDesiredSCAccess)) != NULL) {
    SC_HANDLE service_handle = NULL;
    
    if ((service_handle = OpenService(hManager,
                                      aServiceName,
                                      aDesiredServiceAccess)) != NULL) {
      SERVICE_STATUS service_status;

      ZeroMemory(&service_status, sizeof(service_status));

      if (ControlService(service_handle,
                          aAction,
                          &service_status) == TRUE) {
        //OK we should now know the current state

        if (bWait == TRUE) {
          if (WaitForServiceStatus(service_handle, aWaitStatus) == TRUE) {
            *lpStatus = aWaitStatus;
            }
          else {
            dwError = GetServiceStatus_Enum(aServiceName,lpStatus);
            }
          }
        else {
          *lpStatus = service_status.dwCurrentState;
          }
        }
	  else {
		  dwError = GetLastError();
	  }

      if (CloseServiceHandle(service_handle) == FALSE) {
        _ASSERT(FALSE);
        //error closing service configuration manager
        }
      }
	else {
		dwError = GetLastError();
	}

    if (CloseServiceHandle(hManager) == FALSE) {
      //error closing service configuration manager
      _ASSERT(FALSE);
      }
    }
  else
  {
	  dwError = GetLastError();
  }

  return(dwError);
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void ConfigureService (BOOL aSetToAutoStartBool);
//
// Description: This function sets the UPS service configuration to either
//              automatic or manual.
//
// Additional Information: 
//
// Parameters:
//
//   BOOL aSetToAutoStartBool :- TRUE for automatic. FALSE for manual.
//
// Return Value: None
//
void ConfigureService (BOOL aSetToAutoStartBool) {
  SC_HANDLE hSCM = 0;

  if ((hSCM = OpenSCManager(NULL, NULL, GENERIC_READ | GENERIC_EXECUTE)) != NULL) {
    SC_LOCK hLock = 0;

    if ((hLock = LockServiceDatabase(hSCM)) != NULL) {
      SC_HANDLE hService = 0;

      if ((hService = OpenService(hSCM, UPS_SERVICE_NAME, SERVICE_CHANGE_CONFIG)) != NULL) {
        DWORD dwStartType = 0;

        dwStartType = (aSetToAutoStartBool == TRUE) ? SERVICE_AUTO_START : SERVICE_DEMAND_START;

        ChangeServiceConfig(hService,
                            SERVICE_NO_CHANGE,
                            dwStartType,
                            SERVICE_NO_CHANGE,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

        CloseServiceHandle(hService);
        }//end Open
      UnlockServiceDatabase(hLock);
      }//end Lock
    CloseServiceHandle(hSCM);
    }//end OpenSCM
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void AddActiveDataState (DWORD aBitToSet);
//
// Description: This function adds the given bit to current active data state.
//              The active data state is the state of the current UPS data set.
//              The UPS data set can include SERVICE_DATA_CHANGE and
//              CONFIG_DATA_CHANGE which signify that the service data like UPS
//              vendor, model name, etc, has changed. SERVICE_DATA_CHANGE is
//              for data the require the service to be restarted when changed.
//              CONFIG_DATA_CHANGE is for data that has changed but that does
//              not require a service restart.
//
// Additional Information: 
//
// Parameters:
//
//   DWORD aBitToSet :- The bit to set. Can be either SERVICE_DATA_CHANGE or
//                      CONFIG_DATA_CHANGE.
//
// Return Value: None
//
void AddActiveDataState (DWORD aBitToSet) {
  g_CurrentActiveDataState |= aBitToSet;
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD GetActiveDataState (void);
//
// Description: This function returns the current value of the active data
//              set. This value should be & with SERVICE_DATA_CHANGE and
//              CONFIG_DATA_CHANGE to determine the current active data state.
//
// Additional Information: 
//
// Parameters: None
//
// Return Value: Returns the current active data state.
//
DWORD GetActiveDataState (void) {
  return(g_CurrentActiveDataState);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void SetActiveDataState (DWORD aNewValue);
//
// Description: This function replaces the current value of the active data
//              state.
//
// Additional Information: 
//
// Parameters:
//
//   DWORD aNewValue :- The new value for the active data state.
//
// Return Value: None
//
void SetActiveDataState (DWORD aNewValue) {
  g_CurrentActiveDataState = aNewValue;
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsconfig.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSCONFIG.C
*
*  VERSION:     1.0
*
*  AUTHOR:      TedC
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:  Dialog for configuring UPS service behavior:
*                                       - display popup messages on power failure
*                                       - wait X seconds before displaying warnings
*                                       - repeat warning messages every  X  seconds
*                                       - shutdown X minutes after power fails
*                                       - ALWAYS shutdown when low battery
*                                       - execute a task before shutdown
*                                       - turn off the UPS after shutdown
******************************************************************************/
/*********************  Header Files  ************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "upstab.h"
#include "..\powercfg.h"
#include "..\pwrresid.h"
#include "..\PwrMn_cs.h"

#define VALIDDIGITS             3       // number of digits allowed in each edit box

//
// This structure is filled in by the Power Policy Manager at CPL_INIT time.
//
extern SYSTEM_POWER_CAPABILITIES g_SysPwrCapabilities;

// local copy of UPS Configuration settings
static DWORD   g_ulWaitSeconds = 0;
static DWORD   g_ulRepeatSeconds = 0;
static DWORD   g_ulOnBatteryMinutes = 0;
static DWORD   g_ulNotifyEnable = 0;
static DWORD   g_ulShutdownOnBattery = 0;
static DWORD   g_ulCriticalPowerAction = 0;
static DWORD   g_ulRunTaskEnable = 0;
static DWORD   g_ulTurnOffUPS = 0;
static TCHAR   g_szTaskName[MAX_PATH] = _T("");
static DWORD   g_ulOptions = 0;
static BOOL    g_bPowerFailSignal = FALSE;
static BOOL    g_bLowBatterySignal = FALSE;
static BOOL    g_bShutOffSignal = FALSE;


// context-sensitive help table
const DWORD g_UPSConfigHelpIDs[]=
{
        IDC_NOTIFYCHECKBOX,idh_enable_notification,
        IDC_WAITTEXT,idh_first_warning_delay,
        IDC_WAITEDITBOX,idh_first_warning_delay,
        IDC_WAITSPIN,idh_first_warning_delay,
        IDC_REPEATTEXT,idh_warning_message_interval,
        IDC_REPEATEDITBOX,idh_warning_message_interval,
        IDC_REPEATSPIN,idh_warning_message_interval,
        IDC_SHUTDOWNTIMERCHECKBOX,idh_time_before_critical_action,
        IDC_SHUTDOWNTIMEREDITBOX,idh_time_before_critical_action,
        IDC_TIMERSPIN,idh_time_before_critical_action,
        IDC_SHUTDOWNTEXT,idh_time_before_critical_action,
        IDC_LOWBATTERYSHUTDOWNTEXT,idh_low_battery,
        IDC_POWERACTIONTEXT,idh_shutdown_or_hibernate,
        IDC_POWERACTIONCOMBO,idh_shutdown_or_hibernate,
        IDC_RUNTASKCHECKBOX,idh_run_program,
        IDC_TASKNAMETEXT,idh_run_program,
        IDC_CONFIGURETASKBUTTON,idh_configure_program,
        IDC_TURNOFFCHECKBOX,idh_ups_turn_off,
        IDC_STATIC, NO_HELP,
        IDC_SHUTDOWNGROUPBOX, NO_HELP,
        0, 0
};



/*******************************************************************************
*
*   GetRegistryValues
*
*   DESCRIPTION:  Initialize UPS configuration settings from the registry
*
*   PARAMETERS:
*
*******************************************************************************/
void GetRegistryValues()
{
        GetUPSConfigFirstMessageDelay(&g_ulWaitSeconds);
        GetUPSConfigNotifyEnable(&g_ulNotifyEnable);
        GetUPSConfigMessageInterval(&g_ulRepeatSeconds);
        GetUPSConfigShutdownOnBatteryEnable(&g_ulShutdownOnBattery);
        GetUPSConfigShutdownOnBatteryWait(&g_ulOnBatteryMinutes);
        GetUPSConfigCriticalPowerAction(&g_ulCriticalPowerAction);
        GetUPSConfigRunTaskEnable(&g_ulRunTaskEnable);
        GetUPSConfigTaskName(g_szTaskName);

        if (!_tcsclen(g_szTaskName)) {
                // The taskname in the registry is NULL so
                // get the default taskname from the resource file.
            LoadString(GetUPSModuleHandle(),
                                   IDS_SHUTDOWN_TASKNAME,
                                   (LPTSTR) g_szTaskName,
                                   sizeof(g_szTaskName)/sizeof(TCHAR));
        }
        GetUPSConfigTurnOffEnable(&g_ulTurnOffUPS);
        GetUPSConfigOptions(&g_ulOptions);
}

/*******************************************************************************
*
*   SetRegistryValues
*
*   DESCRIPTION:  Flush UPS configuration settings to the registry
*
*   PARAMETERS:
*
*******************************************************************************/
void SetRegistryValues()
{
        SetUPSConfigFirstMessageDelay(g_ulWaitSeconds);
        SetUPSConfigNotifyEnable(g_ulNotifyEnable);
        SetUPSConfigMessageInterval(g_ulRepeatSeconds);
        SetUPSConfigShutdownOnBatteryEnable(g_ulShutdownOnBattery);
        SetUPSConfigShutdownOnBatteryWait(g_ulOnBatteryMinutes);
        SetUPSConfigCriticalPowerAction(g_ulCriticalPowerAction);
        SetUPSConfigRunTaskEnable(g_ulRunTaskEnable);
        SetUPSConfigTaskName(g_szTaskName);
        SetUPSConfigTurnOffEnable(g_ulTurnOffUPS);
}


/*******************************************************************************
*
*   ErrorBox
*
*   DESCRIPTION:  used to display error messagebox when data is out of range
*
*   PARAMETERS:   hWnd
*                                 wText
*                                 wCaption
*                                 wType
*
*******************************************************************************/
void ErrorBox (HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType)
{
        TCHAR szText[256+MAX_PATH], szCaption[256];
        HANDLE hModule;

        hModule = GetUPSModuleHandle ();

        LoadString(hModule, wCaption, szCaption, sizeof (szCaption)/sizeof(TCHAR));
        LoadString(hModule, wText, szText, sizeof (szText)/sizeof(TCHAR));
        MessageBox(hWnd, szText, szCaption, MB_OK|MB_ICONSTOP);
}

/*******************************************************************************
*
*   ValidWaitSeconds
*
*   DESCRIPTION:  check if user's data is in range
*
*   PARAMETERS:   hDlg
*
*******************************************************************************/
BOOL ValidWaitSeconds(HWND hDlg)
{
        // Popup warning if g_ulWaitSeconds is not in the valid range:
        if ( g_ulWaitSeconds > (DWORD)WAITSECONDSLASTVAL )
        {
                ErrorBox(hDlg, IDS_OUTOFWAITRANGE, IDS_NOTIFYCAPTION, MB_OK|MB_ICONSTOP);
                SetFocus (GetDlgItem (hDlg, IDC_WAITEDITBOX));
                SendMessage(GetDlgItem (hDlg, IDC_WAITEDITBOX),EM_SETSEL, 0, -1L);
                return FALSE;
        }

        return TRUE;
}

/*******************************************************************************
*
*   ValidRepeatSeconds
*
*   DESCRIPTION:  check if user's data is in range
*
*   PARAMETERS:   hDlg
*
*******************************************************************************/
BOOL ValidRepeatSeconds(HWND hDlg)
{
        // Popup warning if g_ulWaitSeconds is not in the valid range:
        if ((g_ulRepeatSeconds < (DWORD)REPEATSECONDSFIRSTVAL) ||
                (g_ulRepeatSeconds > (DWORD)REPEATSECONDSLASTVAL ))
        {
                ErrorBox(hDlg, IDS_OUTOFREPEATRANGE, IDS_NOTIFYCAPTION, MB_OK|MB_ICONSTOP);
                SetFocus (GetDlgItem (hDlg, IDC_REPEATEDITBOX));
                SendMessage(GetDlgItem (hDlg, IDC_REPEATEDITBOX),EM_SETSEL, 0, -1L);
                return FALSE;
        }

        return TRUE;
}

/*******************************************************************************
*
*   ValidShutdownDelay
*
*   DESCRIPTION:  check if user's data is in range
*
*   PARAMETERS:   hDlg
*
*******************************************************************************/
BOOL ValidShutdownDelay(HWND hDlg)
{
        // Popup warning if shutdown delay is not in the valid range:
        if ((g_ulOnBatteryMinutes< (DWORD)SHUTDOWNTIMERMINUTESFIRSTVAL) ||
                (g_ulOnBatteryMinutes > (DWORD)SHUTDOWNTIMERMINUTESLASTVAL ))
        {
                ErrorBox(hDlg, IDS_OUTOFSHUTDELAYRANGE, IDS_SHUTDOWNCAPTION, MB_OK|MB_ICONSTOP);
                SetFocus (GetDlgItem (hDlg,IDC_SHUTDOWNTIMEREDITBOX));
                SendMessage(GetDlgItem (hDlg,IDC_SHUTDOWNTIMEREDITBOX),EM_SETSEL, 0, -1L);
                return FALSE;
        }

        return TRUE;
}

/*******************************************************************************
*
*   ValidateFields
*
*   DESCRIPTION:  Validate all the user's data before we save the values
*
*   PARAMETERS:   hDlg
*
*******************************************************************************/
BOOL ValidateFields(HWND hDlg)
{
        BOOL    bOK;

        // get the Notification configuration
        if (g_ulNotifyEnable = IsDlgButtonChecked (hDlg, IDC_NOTIFYCHECKBOX))
        {
                //g_ulNotifyEnable = 1;
                g_ulWaitSeconds = (DWORD) GetDlgItemInt (hDlg,IDC_WAITEDITBOX, &bOK, FALSE);
                g_ulRepeatSeconds = (DWORD) GetDlgItemInt (hDlg,IDC_REPEATEDITBOX, &bOK, FALSE);
                // check that the delay & interval are in valid range
                if ((!ValidWaitSeconds(hDlg)) || (!ValidRepeatSeconds(hDlg)))
                          return FALSE;
        }

        // get the Shutdown configuration
        if (g_ulShutdownOnBattery = IsDlgButtonChecked (hDlg, IDC_SHUTDOWNTIMERCHECKBOX))
        {
                //g_ulShutdownOnBattery = 1;
                g_ulOnBatteryMinutes = (DWORD) GetDlgItemInt (hDlg,IDC_SHUTDOWNTIMEREDITBOX, &bOK, FALSE);
                // check that the shutdown delay is in valid range
                if (!ValidShutdownDelay(hDlg))
                          return FALSE;
        }

        // get the Shutdown Actions configuration
        g_ulRunTaskEnable = IsDlgButtonChecked (hDlg, IDC_RUNTASKCHECKBOX);


        g_ulTurnOffUPS = IsDlgButtonChecked (hDlg, IDC_TURNOFFCHECKBOX);

        // all configuration data is captured & validated
        return TRUE;
}


/*******************************************************************************
*
*  APCFileNameOnly
*
*  DESCRIPTION: Returns a pointer to the first character after the last
*               backslash in a string
*
*  PARAMETERS:  sz: string from which to strip the path
*
*******************************************************************************/
LPTSTR APCFileNameOnly(LPTSTR sz)
{
 LPTSTR next = sz;
 LPTSTR prev;
 LPTSTR begin = next;

  if (next == NULL) {
      return NULL;
    }

  while ( *next ) {
        prev = next;
        next++;

        if ( (*prev == TEXT('\\')) || (*prev == TEXT(':')) ) {
            begin = next;
        }
  }
 return begin;
}


/*******************************************************************************
*
*  GetTaskApplicationInfo
*
*  DESCRIPTION: if the UPS System Shutdown task exists get the application name
*
*  PARAMETERS:  aBuffer:
*
*******************************************************************************/
BOOL GetTaskApplicationInfo(LPTSTR aBuffer){
    HRESULT hr;
    ITaskScheduler *task_sched = NULL;
    ITask *shutdown_task = NULL;
        BOOL taskExists = FALSE;

        //
        // if there is no task name, don't bother
        //
        if (_tcsclen(g_szTaskName)) {
          //
      // Get a handle to the ITaskScheduler COM Object
          //
      hr = CoCreateInstance( &CLSID_CSchedulingAgent,
                                                        NULL,
                                                        CLSCTX_INPROC_SERVER,
                            &IID_ISchedulingAgent,
                                                        (LPVOID *)&task_sched);
      if (SUCCEEDED(hr)) {
                //
        // Get an instance of the Task if it already exists
                //
        hr = task_sched->lpVtbl->Activate( task_sched,
                                                                                        g_szTaskName,
                                                                                        &IID_ITask,
                                                                                        (IUnknown**)&shutdown_task);
                if (SUCCEEDED(hr)) {
                        LPTSTR lpszTaskApplicationName;

                        if (aBuffer != NULL) {
                                //
                                // get the app name
                                //
                                shutdown_task->lpVtbl->GetApplicationName( shutdown_task,
                                                                                                                        &lpszTaskApplicationName);
                                _tcscpy(aBuffer,lpszTaskApplicationName);
                        }
                        //
                        // release the task
                        //
                        shutdown_task->lpVtbl->Release(shutdown_task);
                        shutdown_task = NULL;
                        taskExists = TRUE;
        }
                //
        // Release the instance of the Task Scheduler
                //
        task_sched->lpVtbl->Release(task_sched);
                task_sched = NULL;
          }
        }

        return taskExists;
}


/*******************************************************************************
*
*  EditWorkItem
*
*  DESCRIPTION: Opens the specified task or creates a new one if the specified
*               name is not found in the task list.
*
*  PARAMETERS:  hWnd            : handle to the parent window
*                               pszTaskName : task to edit (create or open existing)
*
*******************************************************************************/
void EditWorkItem_UPS(HWND hWnd)
{       
  HRESULT     hr;
  ITask *pITask = NULL; 
  ITaskScheduler   *pISchedAgent = NULL;
  IPersistFile     *pIPersistFile = NULL;
  TCHAR szTaskApplicationName[MAX_PATH] = _T("");
  unsigned long ulSchedAgentHandle = 0;

  //
  // if there is no task name, don't even bother
  //
  if (_tcsclen(g_szTaskName)) {
          //
          // get an instance of the scheduler
          //
    hr = CoCreateInstance( &CLSID_CSchedulingAgent,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           &IID_ISchedulingAgent,
                           (LPVOID*)&pISchedAgent);

    if (SUCCEEDED(hr)) {
                //
                // get an instance of the task if it exists...
                //
        hr = pISchedAgent->lpVtbl->Activate(pISchedAgent,
                                       g_szTaskName,
                                       &IID_ITask,
                                       &(IUnknown *)pITask);
        
            if (HRESULT_CODE (hr) == ERROR_FILE_NOT_FOUND){
                        //
                        // otherwise create a new task instance
                        //
            hr = pISchedAgent->lpVtbl->NewWorkItem(
                    pISchedAgent,
                    g_szTaskName,
                    &CLSID_CTask,
                    &IID_ITask,
                    &(IUnknown *)pITask);

            if (SUCCEEDED(hr)) {
                //
                // Commit new work item to disk before editing.
                //
                hr = pITask->lpVtbl->QueryInterface(pITask, &IID_IPersistFile,
                                                    (void **)&pIPersistFile);

                if (SUCCEEDED(hr)) {
                    hr = pIPersistFile->lpVtbl->Save(pIPersistFile, NULL, TRUE);
                    pIPersistFile->lpVtbl->Release(pIPersistFile);
                }
            }
                }

                //
                // register the task scheduler agent in the ROT table
                //
        if (SUCCEEDED(hr)) {
                    hr = RegisterActiveObject(
                                 (IUnknown *) pITask,
                                 &CLSID_CTask,
                                 ACTIVEOBJECT_WEAK,
                                 &ulSchedAgentHandle);

                        //
                        // allow the user to edit the task
                        //
                        if(SUCCEEDED(hr)) {
                pITask->lpVtbl->EditWorkItem(pITask, hWnd, 0);
                                //
                                // user is finished; remove the task scheduler agent from the ROT
                                //
                                if(ulSchedAgentHandle != 0){
                                  RevokeActiveObject(ulSchedAgentHandle, NULL);
                                }
                        }

                        //
                        // release the task
                        //
            pITask->lpVtbl->Release(pITask);
                        pITask = NULL;
        }

                //
                // release the agent
                //
        pISchedAgent->lpVtbl->Release(pISchedAgent);
                pISchedAgent = NULL;

        }

        //
    // if a task was successfully created, display the task's program name;
        //
    if (GetTaskApplicationInfo(szTaskApplicationName)){
                SetDlgItemText (hWnd, IDC_TASKNAMETEXT, APCFileNameOnly(szTaskApplicationName));
        }
  }
}

/*******************************************************************************
*
*  OnNotifyWaitSpin
*
*  DESCRIPTION: handles all notification messages for the Notification spin control
*
*  PARAMETERS:  lParam:
*
*******************************************************************************/
BOOL OnNotifyWaitSpin( LPARAM lParam )
{
        LPNMUPDOWN lpNMUpDown = (LPNMUPDOWN)lParam;
    UINT uNotify = lpNMUpDown->hdr.code;

        switch( uNotify )
        {
        case UDN_DELTAPOS:
#if WAITSECONDSFIRSTVAL // Code is dead if WAITSECONDSFIRSTVAL == 0 since unsigneds cannot go < 0
                if ((g_ulWaitSeconds < (DWORD)WAITSECONDSFIRSTVAL) && (lpNMUpDown->iDelta > 0))
                {
                        /*
                         * user has spec'd a value less than min and wants
                         * to scroll up, so first value should be min
                         */
                        g_ulWaitSeconds = WAITSECONDSFIRSTVAL;
                        lpNMUpDown->iDelta=0; // to disallow request
                }
                else
#endif
        if ((g_ulWaitSeconds > (DWORD)WAITSECONDSLASTVAL ) && (lpNMUpDown->iDelta < 0))
                {
                        /*
                         * user had spec'd a value greater than max and wants
                         * to scroll down, so first value should be max
                         */
                        g_ulWaitSeconds = WAITSECONDSLASTVAL;
                        lpNMUpDown->iDelta=0; // to disallow request
                }
                break;
        default:
                break;
        }

        return FALSE;
}

/*******************************************************************************
*
*  OnNotifyRepeatSpin
*
*  DESCRIPTION: handles all notification messages for the Repeat spin control
*
*  PARAMETERS:  lParam:
*
*******************************************************************************/
BOOL OnNotifyRepeatSpin( LPARAM lParam )
{
        LPNMUPDOWN lpNMUpDown = (LPNMUPDOWN)lParam;
    UINT uNotify = lpNMUpDown->hdr.code;

        switch( uNotify )
        {
        case UDN_DELTAPOS:
                if ((g_ulRepeatSeconds < (DWORD)REPEATSECONDSFIRSTVAL) && (lpNMUpDown->iDelta > 0))
                {
                        /*
                         * user has spec'd a value less than min and wants
                         * to scroll up, so first value should be min
                         */
                        g_ulRepeatSeconds = REPEATSECONDSFIRSTVAL;
                        lpNMUpDown->iDelta=0; // to disallow request
                }
                else if ((g_ulRepeatSeconds > (DWORD)REPEATSECONDSLASTVAL ) && (lpNMUpDown->iDelta < 0))
                {
                        /*
                         * user had spec'd a value greater than max and wants
                         * to scroll down, so first value should be max
                         */
                        g_ulRepeatSeconds = REPEATSECONDSLASTVAL;
                        lpNMUpDown->iDelta=0; // to disallow request
                }
                break;
        default:
                break;
        }

        return FALSE;
}

/*******************************************************************************
*
*  OnNotifyTimerSpin
*
*  DESCRIPTION: handles all notification messages for the Timer spin control
*
*  PARAMETERS:  lParam:
*
*******************************************************************************/
BOOL OnNotifyTimerSpin( LPARAM lParam )
{
        LPNMUPDOWN lpNMUpDown = (LPNMUPDOWN)lParam;
    UINT uNotify = lpNMUpDown->hdr.code;

        switch( uNotify )
        {
        case UDN_DELTAPOS:
                if ((g_ulOnBatteryMinutes < (DWORD)SHUTDOWNTIMERMINUTESFIRSTVAL) && (lpNMUpDown->iDelta > 0))
                {
                        /*
                         * user has spec'd a value less than min and wants
                         * to scroll up, so first value should be min
                         */
                        g_ulOnBatteryMinutes = SHUTDOWNTIMERMINUTESFIRSTVAL;
                        lpNMUpDown->iDelta=0; // to disallow request
                }
                else if ((g_ulOnBatteryMinutes > (DWORD)SHUTDOWNTIMERMINUTESLASTVAL ) && (lpNMUpDown->iDelta < 0))
                {
                        /*
                         * user had spec'd a value greater than max and wants
                         * to scroll down, so first value should be max
                         */
                        g_ulOnBatteryMinutes = SHUTDOWNTIMERMINUTESLASTVAL;
                        lpNMUpDown->iDelta=0; // to disallow request
                }
                break;
        default:
                break;
        }

        return FALSE;
}

/********************************************************************
*
* FUNCTION: handleSpinners
*
* DESCRIPTION:  this function insures that if the user enters out-of-
*                               bounds spinner values, then click on a spinner, the
*                               next value shown is the min or max valid value.
*
* PARAMETERS:   HWND hWnd - a handle to the main dialog window
*                               WPARAM wParam - the WPARAM parameter to the Window's
*                                                               CALLBACK function.
*                               LPARAM lParam - the LPARAM parameter to the Window's
*                                                               CALLBACK function
*
* RETURNS: TRUE to deny request, FALSE to allow it
*                       (NOTE: testing suggests that this has no affect)
*
*********************************************************************/


/*******************************************************************************
*
*  OnNotificationCheckBox
*
*  DESCRIPTION: Command handler for the notification check box
*
*  PARAMETERS:  hWnd:
*
*******************************************************************************/
BOOL OnNotificationCheckBox( HWND hWnd )
{
        g_ulNotifyEnable = IsDlgButtonChecked( hWnd, IDC_NOTIFYCHECKBOX );
    EnableWindow( GetDlgItem( hWnd, IDC_WAITEDITBOX ), g_ulNotifyEnable );
    EnableWindow( GetDlgItem( hWnd, IDC_WAITTEXT ), g_ulNotifyEnable );
        EnableWindow( GetDlgItem( hWnd, IDC_REPEATEDITBOX ), g_ulNotifyEnable );
    EnableWindow( GetDlgItem( hWnd, IDC_REPEATTEXT ), g_ulNotifyEnable );
    EnableWindow( GetDlgItem( hWnd, IDC_REPEATSPIN ), g_ulNotifyEnable );
    EnableWindow( GetDlgItem( hWnd, IDC_WAITSPIN ), g_ulNotifyEnable );
        return TRUE;
}

/*******************************************************************************
*
*  OnShutdownTimerCheckBox
*
*  DESCRIPTION: Command handler for the Timer check box
*
*  PARAMETERS:  hWnd:
*
*******************************************************************************/
BOOL OnShutdownTimerCheckBox( HWND hWnd )
{
        g_ulShutdownOnBattery = IsDlgButtonChecked( hWnd, IDC_SHUTDOWNTIMERCHECKBOX );
        EnableWindow( GetDlgItem( hWnd, IDC_SHUTDOWNTIMEREDITBOX ), g_ulShutdownOnBattery );
        EnableWindow( GetDlgItem( hWnd, IDC_TIMERSPIN ), g_ulShutdownOnBattery );
        return TRUE;
}

/*******************************************************************************
*
*  OnRunTaskCheckBox
*
*  DESCRIPTION: Command handler for the run task check box
*
*  PARAMETERS:  hWnd:
*
*******************************************************************************/
BOOL OnRunTaskCheckBox( HWND hWnd )
{
        g_ulRunTaskEnable = IsDlgButtonChecked( hWnd, IDC_RUNTASKCHECKBOX );
        EnableWindow( GetDlgItem( hWnd, IDC_RUNTASKCHECKBOX ), TRUE );
        EnableWindow( GetDlgItem( hWnd, IDC_TASKNAMETEXT ), g_ulRunTaskEnable );
        EnableWindow( GetDlgItem( hWnd, IDC_CONFIGURETASKBUTTON ), g_ulRunTaskEnable );
        return TRUE;
}

/*******************************************************************************
*
*  OnTurnOffCheckBox
*
*  DESCRIPTION: Command handler for the turn off UPS check box
*
*  PARAMETERS:  hWnd:
*
*******************************************************************************/
BOOL OnTurnOffCheckBox( HWND hWnd )
{
        g_ulTurnOffUPS = IsDlgButtonChecked( hWnd, IDC_TURNOFFCHECKBOX );
        return TRUE;
}

/*******************************************************************************
*
*  OnConfigureTaskButton
*
*  DESCRIPTION: Command handler for the configure task button
*
*  PARAMETERS:  hWnd:
*
*******************************************************************************/
BOOL OnConfigureTaskButton( HWND hWnd )
{
        HWND    hTaskWnd;
        ITask *pITask = NULL;   

        // if task scheduler window is not already active, start it
        if (GetActiveObject(&CLSID_CTask, NULL,&(IUnknown*)pITask) != S_OK)
        {
                EditWorkItem_UPS(hWnd);
        }
        else
        {
           // task scheduler window already active, pop to foreground
           hTaskWnd =  FindWindow( NULL, g_szTaskName);
           BringWindowToTop(hTaskWnd);
        }

        return TRUE;
}

/*******************************************************************************
*
*  OnPowerActionCombo
*
*  DESCRIPTION: Command handler for the power action combobox
*
*  PARAMETERS:  hWnd:
*                               wParam:
*                               lParam
*
*******************************************************************************/
BOOL OnPowerActionCombo(
    IN HWND hWnd,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
        BOOL bRetVal = FALSE;

        switch(HIWORD(wParam))
        {
                case CBN_SELCHANGE:
                {
                        g_ulCriticalPowerAction = (DWORD) SendDlgItemMessage( hWnd,
                                                                IDC_POWERACTIONCOMBO,
                                                                CB_GETCURSEL,
                                                                0,0);

                        // if Hibernate selected, uncheck the run task
                        // and disable all associated controls
                        if( UPS_SHUTDOWN_HIBERNATE == g_ulCriticalPowerAction )
                        {
                                g_ulRunTaskEnable = BST_UNCHECKED;
                                CheckDlgButton( hWnd, IDC_RUNTASKCHECKBOX, (BOOL) BST_UNCHECKED );
                                EnableWindow( GetDlgItem( hWnd, IDC_RUNTASKCHECKBOX ), FALSE );
                                EnableWindow( GetDlgItem( hWnd, IDC_TASKNAMETEXT ), FALSE );
                                EnableWindow( GetDlgItem( hWnd, IDC_CONFIGURETASKBUTTON ), FALSE );
                        }
                        else
                        {
                                EnableWindow( GetDlgItem( hWnd, IDC_RUNTASKCHECKBOX ), TRUE );
                        }

                }

                bRetVal = TRUE;
                break;
        default:
                break;
        }

        return bRetVal;
}


/*******************************************************************************
*
*   OnInitDialog
*
*   DESCRIPTION:  Handles WM_INITDIALOG message sent to UPSConfigDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
OnInitDialog(
    IN HWND hWnd,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
        #define SHORTBZ 16
        TCHAR   szNum[SHORTBZ];
        UDACCEL accel;
        TCHAR szTaskApplicationName[MAX_PATH] = _T("");
        TCHAR szShutdown[SHORTBZ], szHibernate[SHORTBZ];
        HANDLE g_hInstance;
    BOOL   fCallCoUninitialize;

        g_hInstance = GetUPSModuleHandle ();


        // Initialize COM
        fCallCoUninitialize = (S_OK == CoInitialize(NULL));

    SetWindowLong(hWnd, DWLP_USER, fCallCoUninitialize);

        // Get data from the registry
    GetRegistryValues();

        g_bPowerFailSignal = g_ulOptions & UPS_POWERFAILSIGNAL;
        g_bLowBatterySignal = g_ulOptions & UPS_LOWBATTERYSIGNAL;
        g_bShutOffSignal = g_ulOptions & UPS_SHUTOFFSIGNAL;

        // Set the number of valid digits in each editbox
        SendDlgItemMessage( hWnd,
                                                IDC_WAITEDITBOX,
                                                EM_LIMITTEXT,
                                                VALIDDIGITS, 0L );
        SendDlgItemMessage( hWnd,
                                                IDC_REPEATEDITBOX,
                                                EM_LIMITTEXT,
                                                VALIDDIGITS, 0L );
        SendDlgItemMessage( hWnd,
                                                IDC_SHUTDOWNTIMEREDITBOX,
                                                EM_LIMITTEXT,
                                                VALIDDIGITS,0L );

        // (reverse default behavior)
    // set up spinners so that uparrow increases value & downarrow decreases
        accel.nSec = 0;
        accel.nInc = -1;

        SendDlgItemMessage( hWnd, IDC_WAITSPIN, UDM_SETACCEL, 1, (LPARAM)&accel );
        SendDlgItemMessage( hWnd, IDC_REPEATSPIN, UDM_SETACCEL, 1, (LPARAM)&accel );
        SendDlgItemMessage( hWnd, IDC_TIMERSPIN, UDM_SETACCEL, 1, (LPARAM)&accel );

    // Set the range of valid integers for each spinner
    SendDlgItemMessage( hWnd,
                                                IDC_WAITSPIN,
                                                UDM_SETRANGE,
                                                0L,
                                                MAKELONG(WAITSECONDSFIRSTVAL, WAITSECONDSLASTVAL) );
    SendDlgItemMessage( hWnd,
                                                IDC_REPEATSPIN,
                                                UDM_SETRANGE,
                                                0L,
                                                MAKELONG(REPEATSECONDSFIRSTVAL,REPEATSECONDSLASTVAL) );
    SendDlgItemMessage( hWnd,
                                                IDC_TIMERSPIN,
                                                UDM_SETRANGE,
                                                0L,
                                                MAKELONG(SHUTDOWNTIMERMINUTESFIRSTVAL,SHUTDOWNTIMERMINUTESLASTVAL) );

        // Set the initial editbox values
        _itow (g_ulWaitSeconds, szNum, 10);
        SetDlgItemText (hWnd, IDC_WAITEDITBOX, (LPTSTR)szNum);
        _itow (g_ulRepeatSeconds, szNum, 10);
        SetDlgItemText (hWnd, IDC_REPEATEDITBOX, (LPTSTR)szNum);
        _itow (g_ulOnBatteryMinutes, szNum, 10);
        SetDlgItemText (hWnd, IDC_SHUTDOWNTIMEREDITBOX, (LPTSTR)szNum);

        // Set the initial state of the notification checkbox
        // and enable/disable associated controls
        CheckDlgButton (hWnd, IDC_NOTIFYCHECKBOX, (BOOL) g_ulNotifyEnable);
        OnNotificationCheckBox(hWnd);

        // Set the initial state of the shutdown timer checkbox
        // and enable/disable associated controls
        CheckDlgButton (hWnd, IDC_SHUTDOWNTIMERCHECKBOX, (BOOL) g_ulShutdownOnBattery);
        OnShutdownTimerCheckBox(hWnd);

        // Set the initial state of the run task checkbox
        // and enable/disable associated controls
        CheckDlgButton (hWnd, IDC_RUNTASKCHECKBOX, (BOOL) g_ulRunTaskEnable);
        OnRunTaskCheckBox(hWnd);

        // Display the task's program name
        if (GetTaskApplicationInfo(szTaskApplicationName))
        {
                SetDlgItemText (hWnd, IDC_TASKNAMETEXT, APCFileNameOnly(szTaskApplicationName));
        }

	// Initialize the power action combo box
    LoadString(g_hInstance, IDS_POWEROFF, (LPTSTR) szShutdown, sizeof(szShutdown)/sizeof(TCHAR));
    LoadString(g_hInstance, IDS_HIBERNATE, (LPTSTR) szHibernate, sizeof(szHibernate)/sizeof(TCHAR));

        SendDlgItemMessage( hWnd,
                                            IDC_POWERACTIONCOMBO,
                                                CB_ADDSTRING,
                                                0,
                                                (LPARAM) szShutdown);

    //
        // Offer Hibernate as an option if the Hiberfile is present
    //
        if(g_SysPwrCapabilities.SystemS4 && g_SysPwrCapabilities.HiberFilePresent) {
            SendDlgItemMessage( hWnd,
                                                        IDC_POWERACTIONCOMBO,
                                                        CB_ADDSTRING,
                                                        0,
                                                        (LPARAM) szHibernate );
        }

        SendDlgItemMessage( hWnd,
                                                IDC_POWERACTIONCOMBO,
                                                CB_SETCURSEL,
                                                g_ulCriticalPowerAction,0);

        // if Hibernate selected, disable the run task
        if( UPS_SHUTDOWN_HIBERNATE == g_ulCriticalPowerAction )
        {
                g_ulRunTaskEnable = BST_UNCHECKED;
                CheckDlgButton (hWnd, IDC_RUNTASKCHECKBOX, (BOOL) g_ulRunTaskEnable);
                OnRunTaskCheckBox(hWnd);
                EnableWindow( GetDlgItem( hWnd, IDC_RUNTASKCHECKBOX ), g_ulRunTaskEnable );
        }

        // Set the initial state of the turn off UPS checkbox
        // and enable/disable associated controls
        CheckDlgButton (hWnd, IDC_TURNOFFCHECKBOX , (BOOL) g_ulTurnOffUPS);
        OnTurnOffCheckBox(hWnd);

        // Finally, hide controls that aren't supported based on options key
//      ShowWindow(GetDlgItem( hWnd, IDC_WAITEDITBOX ), g_bPowerFailSignal ?  SW_SHOW : SW_HIDE);
//      ShowWindow(GetDlgItem( hWnd, IDC_WAITSPIN ), g_bPowerFailSignal ?  SW_SHOW : SW_HIDE);
//      ShowWindow(GetDlgItem( hWnd, IDC_WAITTEXT ), g_bPowerFailSignal ?  SW_SHOW : SW_HIDE);
//      ShowWindow(GetDlgItem( hWnd, IDC_REPEATEDITBOX ), g_bPowerFailSignal ?  SW_SHOW : SW_HIDE);
//      ShowWindow(GetDlgItem( hWnd, IDC_REPEATSPIN ), g_bPowerFailSignal ?  SW_SHOW : SW_HIDE);
//      ShowWindow(GetDlgItem( hWnd, IDC_REPEATTEXT ), g_bPowerFailSignal ?  SW_SHOW : SW_HIDE);

        ShowWindow(GetDlgItem(hWnd,IDC_LOWBATTERYSHUTDOWNTEXT), g_bLowBatterySignal ?  SW_SHOW : SW_HIDE);

        ShowWindow(GetDlgItem(hWnd,IDC_TURNOFFCHECKBOX), g_bShutOffSignal ?  SW_SHOW : SW_HIDE);

        return  TRUE;
}


/*******************************************************************************
*
*   OnClose
*
*   DESCRIPTION:  Handles WM_CLOSE message sent to UPSConfigDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
OnClose(
    IN HWND hWnd,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
        HWND taskHwnd = NULL;

        // if task scheduler window is still up, kill it
        taskHwnd =  FindWindow( NULL, g_szTaskName);
        if (taskHwnd)
        {
                DestroyWindow(taskHwnd);
        }

    if (GetWindowLong(hWnd, DWLP_USER))
            CoUninitialize();
        EndDialog(hWnd, wParam);

        return TRUE;
}


/*******************************************************************************
*
*   OnOK
*
*   DESCRIPTION:  Handles WM_COMMAND message sent to IDOK
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL OnOK(
    IN HWND hWnd,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
        if (ValidateFields(hWnd))
        {
                 SetRegistryValues();

                 AddActiveDataState(CONFIG_DATA_CHANGE);

                 EnableApplyButton();

                 return OnClose(hWnd, wParam, lParam);
        }

        return FALSE;
}


/*******************************************************************************
*
*   OnCommand
*
*   DESCRIPTION:  Handles WM_COMMAND messages sent to UPSConfigDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
OnCommand(
    IN HWND hWnd,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL    bRetVal;
    WORD    idCtl   = LOWORD(wParam);
    WORD    wNotify = HIWORD(wParam);

    //
    // Assume we handle the command, the default switch will catch exceptions.
    //
    bRetVal = TRUE;

    switch (idCtl)
        {
                case IDC_NOTIFYCHECKBOX:
                        bRetVal = OnNotificationCheckBox(hWnd);
                        break;

                case IDC_SHUTDOWNTIMERCHECKBOX:
                        bRetVal = OnShutdownTimerCheckBox(hWnd);
                        break;

                case IDC_POWERACTIONCOMBO:
                        bRetVal = OnPowerActionCombo(hWnd, wParam, lParam);
                        break;

                case IDC_RUNTASKCHECKBOX:
                        bRetVal = OnRunTaskCheckBox(hWnd);
                        break;

                case IDC_CONFIGURETASKBUTTON:
                        bRetVal = OnConfigureTaskButton(hWnd);
                        break;

                case IDOK:
                        bRetVal = OnOK(hWnd, wParam, lParam);
                        break;

                case IDCANCEL:                          // escape key,cancel buttion
                        bRetVal = OnClose(hWnd, wParam, lParam);
                        break;

                default:
                        bRetVal = FALSE;                // unhandled command, return FALSE
        }
        
        return bRetVal;
}



/*******************************************************************************
*
*   OnNotify
*
*   DESCRIPTION:  Handles WM_NOTIFY messages sent to UPSConfigDlgProc
*
*   PARAMETERS:
*
*******************************************************************************/
BOOL
OnNotify(
    IN HWND hWnd,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    int idCtl = (int) wParam;

        switch (idCtl) {
                case IDC_WAITSPIN:
                        OnNotifyWaitSpin( lParam );
                        break;
                case IDC_REPEATSPIN:
                        OnNotifyRepeatSpin( lParam );
                        break;
                case IDC_TIMERSPIN:
                        OnNotifyTimerSpin( lParam );
                        break;
                default:
                        break;
        }

        return FALSE;
}


/*******************************************************************************
*
*   UPSConfigDlgProc
*
*   DESCRIPTION:
*
*   PARAMETERS:
*
*******************************************************************************/
INT_PTR CALLBACK UPSConfigDlgProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
        BOOL bRet = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
                OnInitDialog(hWnd,wParam,lParam);
                break;

    case WM_COMMAND:
                OnCommand(hWnd,wParam,lParam);
                break;

    case WM_HELP:             // F1
        WinHelp(((LPHELPINFO)lParam)->hItemHandle,
                                PWRMANHLP,
                                HELP_WM_HELP,
                                (ULONG_PTR)(LPTSTR)g_UPSConfigHelpIDs);
                break;

    case WM_CONTEXTMENU:      // right mouse click
                WinHelp((HWND)wParam,
                                PWRMANHLP,
                                HELP_CONTEXTMENU,
                                (ULONG_PTR)(LPTSTR)g_UPSConfigHelpIDs);
                break;

        case WM_CLOSE:
                OnClose(hWnd,wParam,lParam);
                break;

        case WM_NOTIFY:
                OnNotify(hWnd,wParam,lParam);
                break;

        default:
                bRet = FALSE;
                break;
    } // switch (uMsg)

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsapplet.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright 1999 American Power Conversion, All Rights Reserved
//
//  Name:   upsapplet.h
//
//  Author: Noel Fegan
//
//  Description
//  ===========
//  
//  Revision History
//  ================
//  04 May 1999 - nfegan@apcc.com : Added this comment block.
//  04 May 1999 - nfegan@apcc.com : Preparing for code inspection
//

#ifndef _FD352732_E757_11d2_884C_00600844D03F //prevent multiple inclusion
#define _FD352732_E757_11d2_884C_00600844D03F

//
// CClassFactory defines a shell extension class factory object.
//
class CClassFactory : public IClassFactory
{
protected:
    ULONG   m_cRef;         // Object reference count
    
public:
    CClassFactory ();
    ~CClassFactory ();
        
    // IUnknown methods
    STDMETHODIMP            QueryInterface (REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef ();
    STDMETHODIMP_(ULONG)    Release ();
    
    // IClassFactory methods
    STDMETHODIMP    CreateInstance (LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP    LockServer (BOOL);
};

//
// CShellExtension defines a property sheet shell extension object.
//
class CShellExtension : public IShellPropSheetExt, IShellExtInit
{
protected:
    DWORD           m_cRef;             // Object reference count

public:
    CShellExtension  (void);
    ~CShellExtension (void);
    
    // IUnknown methods
    STDMETHODIMP            QueryInterface (REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef ();
    STDMETHODIMP_(ULONG)    Release ();
    
    // IShellPropSheetExt methods
    STDMETHODIMP    AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP    ReplacePage (UINT uPageID,
                        LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IShellExtInit method
    STDMETHODIMP    Initialize (LPCITEMIDLIST pidlFolder,
                        LPDATAOBJECT lpdobj, HKEY hKeyProgID);
};


#endif //_FD352732_E757_11d2_884C_00600844D03F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsconfig.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSCONFIG.H
*
*  VERSION:     1.0
*
*  AUTHOR:      TedC
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:	
********************************************************************************/

#ifndef _UPS_CONFIG_H_
#define _UPS_CONFIG_H_


/*********************  Prototypes  ***********************/
INT_PTR CALLBACK UPSConfigDlgProc( HWND, UINT, WPARAM, LPARAM );


#endif // _UPS_CONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upscustom.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSCUSTOM.C
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:  This file contains all of the functions that support the
*				 custom UPS Interface Configuration dialog.
********************************************************************************/


#include "upstab.h"
#include "..\pwrresid.h"
#include "..\PwrMn_cs.h"


/*
 * forward declarations
 */
void initUPSCustomDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void setRadioButtons(HWND hDlg, DWORD dwTmpConfig);
DWORD getRadioButtons(HWND hDlg, DWORD dwTmpConfig);

static struct _customData *g_CustomData;

/*
 * local declarations
 */

static const DWORD g_UPSCustomHelpIDs[] =
{
	IDC_CUSTOM_CAVEAT, NO_HELP,
	IDC_ONBAT_CHECK,idh_positive_negative_powerfail,
	IDC_ONBAT_POS,idh_positive_negative_powerfail,
	IDC_ONBAT_NEG,idh_positive_negative_powerfail,
	IDC_LOWBAT_CHECK,idh_positive_negative_low_battery,
	IDC_LOWBAT_POS,idh_positive_negative_low_battery,
	IDC_LOWBAT_NEG,idh_positive_negative_low_battery,
	IDC_TURNOFF_CHECK,idh_positive_negative_shutdown,
	IDC_TURNOFF_POS,idh_positive_negative_shutdown,
	IDC_TURNOFF_NEG,idh_positive_negative_shutdown,
	IDB_CUSTOM_BACK,idh_back,
	IDB_CUSTOM_FINISH,idh_finish,
	IDC_STATIC, NO_HELP,
	IDC_CUSTOM_FRAME, NO_HELP,
	0,0
};


/*
 * BOOL CALLBACK UPSCustomDlgProc (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: This is a standard DialogProc associated with the UPS custom dialog
 *
 * Additional Information: See help on DialogProc
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value: Except in response to the WM_INITDIALOG message, the dialog
 *               box procedure should return nonzero if it processes the
 *               message, and zero if it does not.
 */
INT_PTR CALLBACK UPSCustomDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRes = TRUE;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		{
			initUPSCustomDlg(hDlg,uMsg,wParam,lParam);
			break;
		}
	case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
			case IDC_ONBAT_CHECK:
				EnableWindow( GetDlgItem( hDlg, IDC_ONBAT_POS ), (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_ONBAT_CHECK)) );
				EnableWindow( GetDlgItem( hDlg, IDC_ONBAT_NEG ), (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_ONBAT_CHECK)) );
				break;

			case IDC_LOWBAT_CHECK:
				EnableWindow( GetDlgItem( hDlg, IDC_LOWBAT_POS ), (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_LOWBAT_CHECK)) );
				EnableWindow( GetDlgItem( hDlg, IDC_LOWBAT_NEG ), (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_LOWBAT_CHECK)) );
				break;

			case IDC_TURNOFF_CHECK:
				EnableWindow( GetDlgItem( hDlg, IDC_TURNOFF_POS ), (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_TURNOFF_CHECK)) );
				EnableWindow( GetDlgItem( hDlg, IDC_TURNOFF_NEG ), (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_TURNOFF_CHECK)) );
				break;

			case IDB_CUSTOM_BACK:
			case IDB_CUSTOM_FINISH:
				{
					// save the options settings
					*(g_CustomData->lpdwCurrentCustomOptions) = getRadioButtons( hDlg,
															*(g_CustomData->lpdwCurrentCustomOptions));
					EndDialog(hDlg,wParam);
					break;
				}
			case IDCANCEL: // escape key
				{
					EndDialog(hDlg,wParam);
					break;
				}
			default:
				bRes = FALSE;
			}
			break;
		}
	case WM_CLOSE:
		{
			EndDialog(hDlg,IDCANCEL);
			break;
		}
	case WM_HELP: //F1 or question box
		{
			WinHelp(((LPHELPINFO)lParam)->hItemHandle,
					PWRMANHLP,
					HELP_WM_HELP,
					(ULONG_PTR)(LPTSTR)g_UPSCustomHelpIDs);
			break;
		}
	case WM_CONTEXTMENU: // right mouse click help
		{
			WinHelp((HWND)wParam,
				PWRMANHLP,
				HELP_CONTEXTMENU,
				(ULONG_PTR)(LPTSTR)g_UPSCustomHelpIDs);
			break;
		}
	default:
		{
			bRes = FALSE;
		}
	}
	return bRes;
}

/*
 * void  initUPSCustomDlg (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: initializes global data and controls for UPS custom dialog
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value:  none
 */
void initUPSCustomDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	TCHAR szCustomCaption[MAX_PATH] = _T("");

	g_CustomData = (struct _customData*)lParam;

	/*
	 * initialize the title of the dialog box
	 * We can't get "here" without a port being
	 * defined, so there's no need to check that
	 * one is returned; is has to have been
	 */
	LoadString( GetUPSModuleHandle(),
				IDS_CUSTOM_CAPTION,
				szCustomCaption,
				sizeof(szCustomCaption)/sizeof(TCHAR));

	_tcscat( szCustomCaption, g_CustomData->lpszCurrentPort);

	SetWindowText( hDlg, szCustomCaption);

	/*
	 * init the radio buttons according to the UPS options flags.
	 */
	setRadioButtons( hDlg, *(g_CustomData->lpdwCurrentCustomOptions));
}

/*
 * void  setRadioButtons (HWND hDlg);
 *
 * Description: updates the polarity radio buttons
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void setRadioButtons(HWND hDlg, DWORD dwTmpConfig)
{
/*
 * set the radio buttons
 * NOTE: These funcs require the button IDs to be sequential
 */

	CheckDlgButton (hDlg, IDC_ONBAT_CHECK , (BOOL) dwTmpConfig & UPS_POWERFAILSIGNAL);
	CheckDlgButton (hDlg, IDC_LOWBAT_CHECK , (BOOL) dwTmpConfig & UPS_LOWBATTERYSIGNAL);
	CheckDlgButton (hDlg, IDC_TURNOFF_CHECK , (BOOL) dwTmpConfig & UPS_SHUTOFFSIGNAL);

	CheckRadioButton( hDlg,
					IDC_ONBAT_POS,
					IDC_ONBAT_NEG,
					(dwTmpConfig & UPS_POSSIGONPOWERFAIL)?IDC_ONBAT_POS:IDC_ONBAT_NEG);
    EnableWindow( GetDlgItem( hDlg, IDC_ONBAT_POS ), (BOOL) dwTmpConfig & UPS_POWERFAILSIGNAL );
    EnableWindow( GetDlgItem( hDlg, IDC_ONBAT_NEG ), (BOOL) dwTmpConfig & UPS_POWERFAILSIGNAL );

	CheckRadioButton( hDlg,
					IDC_LOWBAT_POS,
					IDC_LOWBAT_NEG,
					(dwTmpConfig & UPS_POSSIGONLOWBATTERY)?IDC_LOWBAT_POS:IDC_LOWBAT_NEG);
    EnableWindow( GetDlgItem( hDlg, IDC_LOWBAT_POS ), (BOOL) dwTmpConfig & UPS_LOWBATTERYSIGNAL );
    EnableWindow( GetDlgItem( hDlg, IDC_LOWBAT_NEG ), (BOOL) dwTmpConfig & UPS_LOWBATTERYSIGNAL );

	CheckRadioButton( hDlg,
					IDC_TURNOFF_POS,
					IDC_TURNOFF_NEG,
					(dwTmpConfig & UPS_POSSIGSHUTOFF)?IDC_TURNOFF_POS:IDC_TURNOFF_NEG);
    EnableWindow( GetDlgItem( hDlg, IDC_TURNOFF_POS ), (BOOL) dwTmpConfig & UPS_SHUTOFFSIGNAL );
    EnableWindow( GetDlgItem( hDlg, IDC_TURNOFF_NEG ), (BOOL) dwTmpConfig & UPS_SHUTOFFSIGNAL );
}

/*
 * void  getRadioButtons (HWND hDlg);
 *
 * Description: reads the polarity radio buttons
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
DWORD getRadioButtons(HWND hDlg, DWORD dwTmpConfig)
{
	/*
	 * NOTE: We are forcing the UPS, PowerFail signal, Low Battery signal
	 * and Turn Off signal bits to true, just as a precautionary measure.
	 */
//	dwTmpConfig |= UPS_DEFAULT_SIGMASK;
//	dwTmpConfig |= UPS_INSTALLED;

	dwTmpConfig = (BST_CHECKED==IsDlgButtonChecked(hDlg,IDC_ONBAT_CHECK)) ?
							(dwTmpConfig | UPS_POWERFAILSIGNAL) :
							(dwTmpConfig & ~UPS_POWERFAILSIGNAL);

	dwTmpConfig = (BST_CHECKED==IsDlgButtonChecked(hDlg,IDC_LOWBAT_CHECK)) ?
							(dwTmpConfig | UPS_LOWBATTERYSIGNAL) :
							(dwTmpConfig & ~UPS_LOWBATTERYSIGNAL);

	dwTmpConfig = (BST_CHECKED==IsDlgButtonChecked(hDlg,IDC_TURNOFF_CHECK)) ?
							(dwTmpConfig | UPS_SHUTOFFSIGNAL) :
							(dwTmpConfig & ~UPS_SHUTOFFSIGNAL);

	dwTmpConfig = (BST_CHECKED==IsDlgButtonChecked(hDlg,IDC_ONBAT_POS)) ?
							(dwTmpConfig | UPS_POSSIGONPOWERFAIL) :
							(dwTmpConfig & ~UPS_POSSIGONPOWERFAIL);

	dwTmpConfig = (BST_CHECKED==IsDlgButtonChecked(hDlg,IDC_LOWBAT_POS)) ?
							(dwTmpConfig | UPS_POSSIGONLOWBATTERY) :
							(dwTmpConfig & ~UPS_POSSIGONLOWBATTERY);

	dwTmpConfig = (BST_CHECKED==IsDlgButtonChecked(hDlg,IDC_TURNOFF_POS)) ?
							(dwTmpConfig | UPS_POSSIGSHUTOFF) :
							(dwTmpConfig & ~UPS_POSSIGSHUTOFF);

	return dwTmpConfig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsinfo.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSINFO.H
*
*  VERSION:     1.0
*
*  AUTHOR:      PaulB
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:
********************************************************************************/


#ifndef _UPS_INFO_H_
#define _UPS_INFO_H_

void DisplayUPSInfoDialogBox (HWND aParentWnd);
void DoUpdateUPSInfo         (HWND hDlg);

#endif // _UPS_INFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upscustom.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSCUSTOM.H
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION: This file contains declarations of the functions that support the
*				custom UPS Interface Configuration dialog.
********************************************************************************/


#ifndef _UPS_CUSTOM_H_
#define _UPS_CUSTOM_H_


#ifdef __cplusplus
extern "C" {
#endif

/*
 * BOOL CALLBACK UPSCustomDlgProc (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: This is a standard DialogProc associated with the UPS custom dialog
 *
 * Additional Information: See help on DialogProc
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value: Except in response to the WM_INITDIALOG message, the dialog
 *               box procedure should return nonzero if it processes the
 *               message, and zero if it does not.
 */
INT_PTR CALLBACK UPSCustomDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // _UPSCUSTOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsinfo.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSINFO.C
*
*  VERSION:     1.0
*
*  AUTHOR:      PaulB
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:
********************************************************************************/


#include "upstab.h"
#include "..\pwrresid.h"
#include "..\PwrMn_cs.h"
#pragma hdrstop

// static data
///////////////////////////////////////////////////////////////////////////////

static HWND g_hUPSPageWnd = NULL;

static DialogAssociations g_InfoAssocs[] = {
  MAKE_ARRAY(VENDOR_NAME,       IDS_STRING, IDS_STRING, RESOURCE_FIXED, 0, eDeepGet, 0, 0),
  MAKE_ARRAY(MODEL_TYPE,        IDS_STRING, IDS_STRING, RESOURCE_FIXED, 0, eDeepGet, 0, 0),
  MAKE_ARRAY(SERIAL_NUMBER,     IDS_STRING, IDS_STRING, RESOURCE_FIXED, 0, eDeepGet, 0, 0),
  MAKE_ARRAY(FIRMWARE_REVISION, IDS_STRING, IDS_STRING, RESOURCE_FIXED, 0, eDeepGet, 0, 0) };

static DWORD g_NoServiceControls[] = { IDC_NO_DETAILED_INFO };

// context-sensitive help table
const DWORD g_UPSInfoHelpIDs[]=
{
	IDC_MANUFACTURER_LHS, idh_manufacturer,
	IDC_MANUFACTURER, idh_manufacturer,
	IDC_MODEL_LHS, idh_model,
	IDC_MODEL, idh_model,
	IDC_SERIAL_NUMBER_LHS, idh_serialnumber,
	IDC_SERIAL_NUMBER, idh_serialnumber,
	IDC_FIRMWARE_REVISION_LHS, idh_firmware,
	IDC_FIRMWARE_REVISION, idh_firmware,
	IDC_UPS_INFO, NO_HELP, 
	IDC_NO_DETAILED_INFO, NO_HELP,
	0, 0
};


// static functions
///////////////////////////////////////////////////////////////////////////////

static INT_PTR CALLBACK UPSInfoDlgProc (HWND aDlgHWND,
                                     UINT uMsg,
                                     WPARAM wParam,
                                     LPARAM lParam);

static BOOL UPSInfoDlgHandleInit     (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
static BOOL UPSInfoDlgHandleCommand  (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void DisplayUPSInfoDialogBox (HWND aParentWnd);
//
// Description: This function creates and displays the UPS Information dialog
//              as a modal dialog. This dialog is displayed when the UPS icon
//              button is pressed.
//
// Additional Information:
//
// Parameters:
//
//   HWND aParentWnd :- Handle to the parent window.
//
// Return Value: None
//
void DisplayUPSInfoDialogBox (HWND aParentWnd) {
  g_hUPSPageWnd = aParentWnd;

  DialogBox(GetUPSModuleHandle(), MAKEINTRESOURCE(IDD_UPSDETAILS), aParentWnd, UPSInfoDlgProc);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL CALLBACK UPSInfoDlgProc (HWND aDlgHWND,
//                               UINT uMsg,
//                               WPARAM wParam,
//                               LPARAM lParam);
//
// Description: This is the
// \<A HREF="ms-its:C:\Program%20Files\Microsoft%20Visual%20Studio\MSDN98\98VS\1033\winui.chm::/devdoc/live/pdui/dlgboxes_5lib.htm">DialogProc\</A>
//              for the UPS Information dialog box.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Identifies the dialog box.
//
//   UINT uMsg :- Specifies the message.
//
//   WPARAM wParam :- Specifies additional message-specific information.
//
//   LPARAM lParam :- Specifies additional message-specific information.
//
// Return Value: Except in response to the WM_INITDIALOG message, the dialog
//               box procedure should return nonzero if it processes the
//               message, and zero if it does not.
//
INT_PTR CALLBACK UPSInfoDlgProc (HWND aDlgHWND,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam) {
  BOOL bRet = TRUE;

  switch (uMsg) {
    case WM_INITDIALOG: {
      //The dialog box procedure should return TRUE to direct the system to
      //set the keyboard focus to the control given by wParam.
      bRet = UPSInfoDlgHandleInit(aDlgHWND, wParam, lParam);
      break;
      }
    case WM_COMMAND: {
      //If an application processes this message, it should return zero.
      bRet = UPSInfoDlgHandleCommand(aDlgHWND, wParam, lParam);
      break;
      }
	case WM_HELP: {			//Help for WM_HELP says: Returns TRUE
	  bRet = WinHelp(((LPHELPINFO)lParam)->hItemHandle,
					 PWRMANHLP,
	  				 HELP_WM_HELP,
	  				 (ULONG_PTR)(LPTSTR)g_UPSInfoHelpIDs);
	  break;
	  }

	case WM_CONTEXTMENU: {     // right mouse click
	  bRet = WinHelp((HWND)wParam,
					 PWRMANHLP,
					 HELP_CONTEXTMENU,
					 (ULONG_PTR)(LPTSTR)g_UPSInfoHelpIDs);
	  break;
	  }
    default: {
      bRet = FALSE;
      break;
      }
    } // switch (uMsg)

  return(bRet);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL UPSInfoDlgHandleInit (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
//
// Description: This is the handler function for the UPS Information
//              WM_INITDIALOG message.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Identifies the dialog box.
//
//   WPARAM wParam :- Handle of control to receive focus
//
//   LPARAM lParam :- Initialization parameter
//
// Return Value: The dialog box procedure should return TRUE to direct the
//               system to set the keyboard focus to the control given by
//               wParam.
//
BOOL UPSInfoDlgHandleInit (HWND aDlgHWND, WPARAM wParam, LPARAM lParam) {
  DoUpdateUPSInfo(aDlgHWND);

  return(TRUE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void DoUpdateUPSInfo (HWND aDlgHWND);
//
// Description: This function updates the information displayed in the
//              UPS Information dialog.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Identifies the dialog box.
//
// Return Value: None
//
void DoUpdateUPSInfo (HWND aDlgHWND) {
  static const DWORD numRunningFields = DIMENSION_OF(g_InfoAssocs);
  static const DWORD numNoServiceFields = DIMENSION_OF(g_NoServiceControls);

  BOOL bShowNoDataItemsField = DoUpdateInfo(aDlgHWND,
                                            g_InfoAssocs,
                                            numRunningFields,
                                            (DWORD *) &g_NoServiceControls,
                                            numNoServiceFields,
                                            TRUE);

  ShowWindow(GetDlgItem(aDlgHWND, IDC_NO_DETAILED_INFO), !bShowNoDataItemsField ? SW_SHOW : SW_HIDE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL UPSInfoDlgHandleCommand (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
//
// Description: This is the handler function for the APC about box WM_COMMAND
//              message.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Handle to dialog box
//
//   WPARAM wParam :- HIWORD(wParam) gives the notification code.
//                    LOWORD(wParam) gives the control id.
//
//   LPARAM lParam :- Gives the HWND or handle of the control.
//
// Return Value: If an application processes this message, it should return 0.
//
BOOL UPSInfoDlgHandleCommand (HWND aDlgHWND, WPARAM wParam, LPARAM lParam) {
  BOOL bRes = FALSE;
  DWORD ctrlID = LOWORD(wParam);

  switch (ctrlID) {
    case IDOK:
    case IDCANCEL: { //The escape key
      EndDialog(aDlgHWND, ctrlID);
      break;
      }
//    case IDB_REFRESH: {
//    DoUpdateUPSInfo(aDlgHWND);
//      break;
//      }
    default: {
      break;
      }
    }//end switch

  //If an application processes this message, it should return zero.
  return(bRes);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsselect.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSSELECT.C
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION: This file contains all of the functions that support the
*				UPS Type Selection dialog.
*******************************************************************************/
#include "upstab.h"

//#include "..\powercfg.h"
#include "..\pwrresid.h"
#include "..\PwrMn_cs.h"


/*
 * forward declarations
 */
void initUPSSelectDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

void updateVendorList(HWND hDlg) ;
void updateModelList(HWND hDlg) ;
void updatePortList(HWND hDlg) ;

void handleVendorList(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) ;
void handleModelList(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void handlePortList(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) ;

void setServiceData(HWND hDlg);

void configPortList(HWND hDlg);
void configModelList(HWND hDlg);
void configFinishButton(HWND hDlg);

BOOL processUPSSelectCtrls(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

/*
 * local allocations
 */
static TCHAR g_szCurrentVendor[MAX_PATH]	= _T("");
static TCHAR g_szCurrentModel[MAX_PATH]		= _T("");
static TCHAR g_szCurrentPort[MAX_PATH]		= _T("");
static TCHAR g_szCurrentServiceDLL[MAX_PATH]= _T("");

static DWORD g_dwCurrentOptions		  = UPS_DEFAULT_SIGMASK;
static DWORD g_dwCurrentCustomOptions = UPS_DEFAULT_SIGMASK;

static struct _customData g_CustomData = { g_szCurrentPort, &g_dwCurrentCustomOptions};

static TCHAR g_szNoUPSVendor[MAX_PATH]    = _T("");
static TCHAR g_szOtherUPSVendor[MAX_PATH] = _T("");
static TCHAR g_szCustomUPSModel[MAX_PATH] = _T("");
static TCHAR g_szCOMPortPrefix[MAX_PATH]  = _T("");

static const DWORD g_UPSSelectHelpIDs[] =
{
    IDC_VENDOR_TEXT,idh_select_manufacturer,
    IDC_VENDOR_LIST,idh_select_manufacturer,
    IDC_MODEL_TEXT,idh_select_model,
    IDC_MODEL_LIST,idh_select_model,
    IDC_PORT_TEXT,idh_on_port,
    IDC_PORT_LIST,idh_on_port,
    IDB_SELECT_FINISH,idh_finish,
	IDB_SELECT_NEXT,idh_next,
	0,0
};

/*
 * define the possible "states" of the controls.
 * these states are set whenever a control is altered,
 * and are generally used to speed up processing by
 * basing decisions on states rather than having to
 * continually query controls to find out what they're
 * displaying.
 */
static enum _vendorStates {eVendorUnknown, eVendorSelected, eVendorGeneric, eVendorNone} g_vendorState;
static enum _modelStates  {eModelUnknown, eModelSelected, eModelCustom} g_modelState;
static enum _portStates   {ePortUnknown, ePortSelected} g_portState;
static enum _finishStates {eFinish, eNext} g_finishButtonState;

/*
 * Load all used values here
 */
void getUPSConfigValues()
{
	GetUPSConfigVendor( g_szCurrentVendor);
	GetUPSConfigModel( g_szCurrentModel);
	GetUPSConfigPort( g_szCurrentPort);
	GetUPSConfigOptions( &g_dwCurrentOptions);
	GetUPSConfigCustomOptions( &g_dwCurrentCustomOptions);
	GetUPSConfigServiceDLL( g_szCurrentServiceDLL);
}

/*
 * Save all used values here
 */
void setUPSConfigValues()
{
	SetUPSConfigVendor( g_szCurrentVendor);
	SetUPSConfigModel( g_szCurrentModel);
	SetUPSConfigPort( g_szCurrentPort);
	SetUPSConfigOptions( g_dwCurrentOptions);
	SetUPSConfigCustomOptions( g_dwCurrentCustomOptions);
	SetUPSConfigServiceDLL( g_szCurrentServiceDLL);

  AddActiveDataState(SERVICE_DATA_CHANGE);

  EnableApplyButton();
}

/*
 * BOOL CALLBACK UPSSelectDlgProc (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: This is a standard DialogProc associated with the UPS select dialog
 *
 * Additional Information: See help on DialogProc
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value: Except in response to the WM_INITDIALOG message, the dialog
 *               box procedure should return nonzero if it processes the
 *               message, and zero if it does not.
 */
INT_PTR CALLBACK UPSSelectDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRes = TRUE;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			{
				initUPSSelectDlg(hDlg,uMsg,wParam,lParam);
				break;
			}
		case WM_CLOSE:
			{

				EndDialog( hDlg, IDCANCEL);
				break;
			}
		case WM_COMMAND:
			{
				bRes = processUPSSelectCtrls( hDlg, uMsg, wParam,  lParam);
				break;
			}
		case WM_HELP: //F1 or question box
			{
				WinHelp(((LPHELPINFO)lParam)->hItemHandle,
						PWRMANHLP,
						HELP_WM_HELP,
						(ULONG_PTR)(LPTSTR)g_UPSSelectHelpIDs);
				break;
			}
		case WM_CONTEXTMENU: // right mouse click help
			{
				WinHelp((HWND)wParam,
						PWRMANHLP,
						HELP_CONTEXTMENU,
						(ULONG_PTR)(LPTSTR)g_UPSSelectHelpIDs);
				break;
			}
		default:
			{
				bRes = FALSE;
				break;
			}
	}

	return bRes;
}

/*
 * BOOL  processUPSSelectCtrls (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: processes WM_COMMAND messages for the UPS select dialog
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value:  returns TRUE unless the control specified is unknown
 */
BOOL processUPSSelectCtrls(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRes = TRUE;

	switch (LOWORD(wParam))
	{
	case IDB_SELECT_FINISH:
		{
			setServiceData(hDlg);
			setUPSConfigValues();
			EndDialog(hDlg,wParam);
			break;
		}
	case IDB_SELECT_NEXT:
		{
			/*
			 * the user has selected Custom...
			 */
			INT_PTR iCustomRes;

			/*
			 * bring up the custom config dialog
			 */
			// ShowWindow(hDlg,SW_HIDE);

			iCustomRes = DialogBoxParam(
							GetUPSModuleHandle(),					
							MAKEINTRESOURCE(IDD_UPSCUSTOM),
							hDlg,								
							UPSCustomDlgProc,
							(LPARAM)&g_CustomData);

			switch (iCustomRes)
			{
				case IDB_CUSTOM_FINISH:
					{
						/*
						 * Save Custom signal values
						 */
						setServiceData(hDlg);
						setUPSConfigValues();
						EndDialog(hDlg,wParam);
						break;
					}
				case IDCANCEL: // the escape key
					{
						EndDialog(hDlg,wParam);
						break;
					}
				case IDB_CUSTOM_BACK:
					{
						ShowWindow(hDlg,SW_SHOW);
						break;
					}
			}
			break;
		}
	case IDCANCEL: // the escape key
		{
			EndDialog(hDlg,wParam);
			break;
		}
	case IDC_VENDOR_LIST:
		{
			handleVendorList(hDlg,uMsg,wParam,lParam);
			break;
		}
	case IDC_MODEL_LIST:
		{
			handleModelList(hDlg,uMsg,wParam,lParam);
			break;
		}
	case IDC_PORT_LIST:
		{
			handlePortList(hDlg,uMsg,wParam,lParam);
			break;
		}
	default:
		{
			bRes = FALSE;
			break;
		}
	}
	
	return bRes;
}

/*
 * void  initUPSSelectDlg (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: initializes global data and controls for UPS select dialog
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value:  none
 */
void initUPSSelectDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	/*
	 * load registry settings
	 */
	getUPSConfigValues();

	/*
	 * load string resources
	 */
	LoadString( GetUPSModuleHandle(),
				IDS_NO_UPS_VENDOR,
				g_szNoUPSVendor,
				sizeof(g_szNoUPSVendor)/sizeof(TCHAR));

	LoadString( GetUPSModuleHandle(),
				IDS_OTHER_UPS_VENDOR,
				g_szOtherUPSVendor,
				sizeof(g_szOtherUPSVendor)/sizeof(TCHAR));

	LoadString( GetUPSModuleHandle(),
				IDS_CUSTOM_UPS_MODEL,
				g_szCustomUPSModel,
				sizeof(g_szCustomUPSModel)/sizeof(TCHAR));

	LoadString( GetUPSModuleHandle(),
				IDS_COM_PORT_PREFIX,
				g_szCOMPortPrefix,
				sizeof(g_szCOMPortPrefix)/sizeof(TCHAR));

	/*
	 * disable the Finish button, just in case its not disabled by default
	 */
	//EnableWindow( GetDlgItem( hDlg, IDB_SELECT_FINISH), FALSE);

	/*
	 * init the list controls
	 */
	updateVendorList( hDlg);
    updateModelList( hDlg);
    updatePortList( hDlg);
    configFinishButton(hDlg);

}

/*
 * void  updateVendorList (HWND hDlg);
 *
 * Description: updates the vendor list control in UPS select dialog
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void updateVendorList(HWND hDlg)
{	
	HKEY hkResult;
	LRESULT lListRes;

	g_vendorState = eVendorUnknown;

	/*
	 * clear and disable the list
	 */
	lListRes = SendDlgItemMessage( hDlg, IDC_VENDOR_LIST, CB_RESETCONTENT,0,0);
	EnableWindow( GetDlgItem( hDlg, IDC_VENDOR_LIST), FALSE);
	EnableWindow( GetDlgItem( hDlg, IDC_VENDOR_TEXT), FALSE);

	// Add "None" as the first item in the list
	lListRes = SendDlgItemMessage( hDlg,
								   IDC_VENDOR_LIST,
								   CB_ADDSTRING,
								   0,
								   (LPARAM)g_szNoUPSVendor);

	/*
	 * Build the rest of the Vendor list from the registry
	 */
	
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							UPS_SERVICE_ROOT,
							0,
							KEY_ENUMERATE_SUB_KEYS,
							&hkResult))
	{
		DWORD dwIndex = 0;
		LONG  lRes = ERROR_SUCCESS;
		TCHAR szKeyName[MAX_PATH] = _T("");
		DWORD dwKeyLen;
		FILETIME ftLast;

		while (ERROR_SUCCESS == lRes)
		{
			dwKeyLen = sizeof(szKeyName)/sizeof(TCHAR);

			lRes = RegEnumKeyEx(hkResult,
						dwIndex,
						szKeyName,  // address of buffer for subkey name
						&dwKeyLen,	// address for size of subkey buffer
						NULL,		// reserved
						NULL,		// address of buffer for class string
						NULL,		// address for size of class buffer
						&ftLast);	// address for time key last written to

			// The "NoUPS" and "OtherUPS" options are added manually
			// before and after spinning through the registry
			// (unlike mfg names, these string require localization).
			// In RC2 registry keys were created with these values (English only).
			// To avoid duplicate entries in the combo, if the registry key name
			// matches the "NoUPS" or "OtherUPS" strings then skip over it.
			if( (ERROR_SUCCESS == lRes) &&
				(0 != _tcsicmp( szKeyName, g_szNoUPSVendor)) &&
				(0 != _tcsicmp( szKeyName, g_szOtherUPSVendor)) )
			{
				lListRes = SendDlgItemMessage( hDlg,
												IDC_VENDOR_LIST,
												CB_ADDSTRING,
												0,
												(LPARAM)szKeyName);
			}

			dwIndex++;
		}

		RegCloseKey(hkResult);

	}

	// Add the "Generic" vendor at the end of the list
	lListRes = SendDlgItemMessage( hDlg,
								   IDC_VENDOR_LIST,
								   CB_ADDSTRING,
								   0,
								   (LPARAM)g_szOtherUPSVendor);

	EnableWindow( GetDlgItem( hDlg, IDC_VENDOR_LIST), TRUE);
	EnableWindow( GetDlgItem( hDlg, IDC_VENDOR_TEXT), TRUE);

	// Now find the current vendor in the combo box...
	//
	lListRes = SendDlgItemMessage(hDlg,
							  IDC_VENDOR_LIST,
							  CB_FINDSTRINGEXACT,
							  -1,
							  (LPARAM)g_szCurrentVendor);

	// ... and select it.
	if( CB_ERR != lListRes )
	{
		lListRes = SendDlgItemMessage( hDlg,
									   IDC_VENDOR_LIST,
									   CB_SETCURSEL,
									   lListRes,
									   0);
	}

	// Set the vendor state
	//
	if (0 == _tcsicmp( g_szCurrentVendor, g_szNoUPSVendor))
	{
		g_vendorState = eVendorNone;
	}
	else
	{
		if (0 == _tcsicmp( g_szCurrentVendor, g_szOtherUPSVendor))
		{
			g_vendorState = eVendorGeneric;
		}
		else
		{
			g_vendorState = eVendorSelected;
		}
	}
}


/*
 * void  updateModelList (HWND hDlg);
 *
 * Description: updates the UPS model list control in UPS select dialog
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void updateModelList(HWND hDlg)
{
	LRESULT lListRes;

	g_modelState = eModelUnknown;

	/*
	 * clear and disable the list
	 */
	lListRes = SendDlgItemMessage( hDlg, IDC_MODEL_LIST, LB_RESETCONTENT,0,0);
	configModelList( hDlg);

	/*
	 * load the list, but only if:
	 * 1) the current vendor is valid and not NONE
	 */
	if (eVendorGeneric == g_vendorState)
	{
		lListRes = SendDlgItemMessage( hDlg,
								       IDC_MODEL_LIST,
									   LB_ADDSTRING,
									   0,
									   (LPARAM)g_szCustomUPSModel);
	}

	if (eVendorSelected == g_vendorState)
	{
		HKEY hkResult;
		TCHAR szVendorKey[MAX_PATH] = _T("");

		wsprintf(szVendorKey,_T("%s\\%s"),UPS_SERVICE_ROOT,g_szCurrentVendor);
		
		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								szVendorKey,
								0,
								KEY_QUERY_VALUE,
								&hkResult))
		{
			DWORD dwIndex = 0;
			LONG  lRes = ERROR_SUCCESS;
			TCHAR szValueName[MAX_PATH] = _T("");
			DWORD dwValueLen;
			
			while (ERROR_SUCCESS == lRes)
			{
				dwValueLen = sizeof(szValueName)/sizeof(TCHAR);

				lRes = RegEnumValue(hkResult,
							dwIndex,
							szValueName,	// address of buffer for subkey name
							&dwValueLen,	// address for size of subkey buffer
							NULL,			// reserved
							NULL,			// address of buffer for type code
							NULL,			// address of buffer for value data
							NULL);			// address for size of data buffer

				if (ERROR_SUCCESS == lRes)
				{
					lListRes = SendDlgItemMessage( hDlg,
													IDC_MODEL_LIST,
													LB_ADDSTRING,
													0,
													(LPARAM)szValueName);
				}

				dwIndex++;
			}

			RegCloseKey(hkResult);

		}

		// Now find the current model in the list box...
		//
		lListRes = SendDlgItemMessage(hDlg,
								  IDC_VENDOR_LIST,
								  LB_FINDSTRINGEXACT,
								  -1,
								  (LPARAM)g_szCurrentModel);

		// ... and select it.
		if( CB_ERR != lListRes )
		{
			lListRes = SendDlgItemMessage( hDlg,
										   IDC_VENDOR_LIST,
										   LB_SETCURSEL,
										   lListRes,
										   0);
		}
	}

	/*
	 * set the model state
	 */
	if (0 == _tcsicmp( g_szCurrentModel, g_szCustomUPSModel))
	{
		g_modelState = eModelCustom;
	}
	else
	{
		g_modelState = eModelSelected;
	}

	configModelList( hDlg);
}

/*
 * void  updatePortList (HWND hDlg);
 *
 * Description: updates the UPS port list control in UPS select dialog
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void updatePortList(HWND hDlg)
{
	HKEY hkResult;
	LPTSTR lpColon;

	g_portState = ePortUnknown;

	/*
	 * disable the list
	 */
	configPortList( hDlg);

	/*
	 * remove possible trailing colon from COM port setting
	 */
	if (NULL != (lpColon = _tcschr( g_szCurrentPort, (TCHAR)':')))
	{
		*lpColon = (TCHAR)'\0';
	}

	/*
	 * (re)building the port list, its ok to wipe it out
	 */
	SendDlgItemMessage( hDlg, IDC_PORT_LIST, CB_RESETCONTENT,0,0);

	if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
										UPS_PORT_ROOT,
										0,
										KEY_QUERY_VALUE,
										&hkResult))
	{
		DWORD dwIndex = 0;
		LONG  lRes = ERROR_SUCCESS;
		TCHAR szPortValue[MAX_PATH] = _T("");
		TCHAR szPortData[MAX_PATH] = _T("");
		DWORD dwPortLen;
		
		while (ERROR_SUCCESS == lRes)
		{
			dwPortLen = sizeof(szPortValue)/sizeof(TCHAR);

			lRes = RegEnumValue(hkResult,
						dwIndex,
						szPortValue,// address of buffer for subkey name
						&dwPortLen,	// address for size of subkey buffer
						NULL,		// reserved
						NULL,		// address of buffer for type code
						NULL,		// address of buffer for value data
						NULL);		// address for size of data buffer

			if (ERROR_SUCCESS == lRes)
			{
				DWORD dwValueLen;
				DWORD dwValueType;

				// Once we have the szPortValue we need to get its data.
				// This is what we'll put in the combobox.
				dwValueLen = sizeof(szPortData)/sizeof(TCHAR);

				lRes = RegQueryValueEx(
						  hkResult,				// handle to key to query
						  szPortValue,			// address of name of value to query
						  NULL,					// reserved
						  &dwValueType,			// address of buffer for value type
						  (LPBYTE)szPortData,	// address of data buffer
						  &dwValueLen			// address of data buffer size
						);
					
				if (ERROR_SUCCESS == lRes)
				{
					LONG_PTR listRes;
					// Add szPortData to the combobox
					listRes = SendDlgItemMessage( hDlg,
													IDC_PORT_LIST,
													CB_ADDSTRING,
													0,
													(LPARAM)szPortData);

					/*
					 * this item matches the currentPort, so select it.
					 */
					if (0 ==_tcsicmp( szPortData, g_szCurrentPort) &&
						CB_ERR != listRes &&
						CB_ERRSPACE != listRes)
					{
						if( CB_ERR != SendDlgItemMessage( hDlg,
														  IDC_PORT_LIST,
														  CB_SETCURSEL,
														  listRes,0) )
						{
							// the combobox is enabled based on whether or not
							// a port is selected so if the CB_SETCURSEL call
							// is successful, we should set the port state accordingly
							g_portState = ePortSelected;
						}

					}
				}	// RegQueryValueEx
			}	// RegEnumValue

			dwIndex++;

		}	// while loop

		// If I haven't already set the current selection then
		// default to the 0th item in the combobox and set the
		// g_portState to indicate that we have a selection
		if( g_portState != ePortSelected )
		{
			if( CB_ERR != SendDlgItemMessage( hDlg,
											  IDC_PORT_LIST,
											  CB_SETCURSEL,
											  0,0) )
			{
				// the combobox is enabled based on whether or not
				// a port is selected so if the CB_SETCURSEL call
				// is successful, we should set the port state accordingly
				g_portState = ePortSelected;
			}
		}

		RegCloseKey(hkResult);
	}

	configPortList( hDlg);
}

/*
 * void  handleVendorList (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: handles messages specific to the Vendor List control
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value:  none
 */
void handleVendorList(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (HIWORD(wParam))
	{
	case CBN_SELCHANGE://CBN_CLOSEUP:
		{
			LONG_PTR  lVendorRes;
			TCHAR szVendorName[MAX_PATH] = _T("");

			/*
			 * Get the user's selection
			 */
			lVendorRes = SendDlgItemMessage( hDlg,
											IDC_VENDOR_LIST,
											CB_GETCURSEL,
											0,0);
			if (CB_ERR != lVendorRes)
			{
				lVendorRes = SendDlgItemMessage( hDlg,
												IDC_VENDOR_LIST,
												CB_GETLBTEXT,
												lVendorRes,
												(LPARAM)szVendorName);
				if (CB_ERR != lVendorRes)
				{
					/*
					 * if its different from the current value, affect a change
					 */
					_tcscpy(g_szCurrentVendor, szVendorName);

					/*
					 * set new vendor state
					 */
					if (0 == _tcsicmp(szVendorName,g_szNoUPSVendor))
					{
						g_vendorState = eVendorNone;
					}
					else
					{
						if (0 == _tcsicmp(szVendorName,g_szOtherUPSVendor))
						{
							g_vendorState = eVendorGeneric;
						}
						else
						{
							g_vendorState = eVendorSelected;
						}

					}

					/*
					 * force user to select a new model
					 */
					_tcscpy(g_szCurrentModel, _T(""));

					/*
					 * disable the model and port lists
					 * forcing the user to reselect them
					 */
					updateModelList(hDlg);
					configPortList( hDlg);
				}
			}

			configFinishButton( hDlg);
			break;
		}
	}
}

/*
 * void  handleModelList (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: handles messages specific to the Model list control
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value:  none
 */
void handleModelList(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LONG_PTR lModelRes;

	switch (HIWORD(wParam))
	{
	case LBN_SETFOCUS:
		{
			/*
			 * focus has come into the list, make sure
			 * selected item is visible
			 */
			lModelRes = SendDlgItemMessage( hDlg,
											IDC_MODEL_LIST,
											LB_GETCURSEL,
											0,0);
			if (LB_ERR != lModelRes)
			{
				lModelRes = SendDlgItemMessage( hDlg,
												IDC_MODEL_LIST,
												LB_SETTOPINDEX,
												lModelRes,
												0);
			}
			break;
		}

	case LBN_DBLCLK:
	case LBN_SELCHANGE:
		{
			TCHAR szModelName[MAX_PATH] = _T("");

			/*
			 * get the user selection
			 */
			lModelRes = SendDlgItemMessage( hDlg,
											IDC_MODEL_LIST,
											LB_GETCURSEL,
											0,0);
			if (LB_ERR != lModelRes)
			{
				lModelRes = SendDlgItemMessage( hDlg,
												IDC_MODEL_LIST,
												LB_GETTEXT,
												lModelRes,
												(LPARAM)szModelName);
				if (LB_ERR != lModelRes)
				{
					_tcscpy( g_szCurrentModel, szModelName);

					/*
					 * set new model state
					 */
					if (0==_tcsicmp( szModelName,g_szCustomUPSModel))
					{
						g_modelState = eModelCustom;
					}
					else
					{
						g_modelState = eModelSelected;
					}

					/*
					 * enable port selection in the event that
					 * changing Vendors disabled the port selector
					 */
					configPortList( hDlg);
				}
			}

			configFinishButton( hDlg);
			break;
		}
	}
}

/*
 * void  handlePortList (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: handles messages specific to the Port list control
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value:  none
 */
void handlePortList(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (HIWORD(wParam))
	{
	case CBN_SELCHANGE: //CBN_CLOSEUP:
		{
			LONG_PTR lPortRes;
			TCHAR szPortName[MAX_PATH] = _T("");

			/*
			 * get the user selection
			 */
			lPortRes = SendDlgItemMessage( hDlg,
											IDC_PORT_LIST,
											CB_GETCURSEL,
											0,0);
			if (CB_ERR != lPortRes)
			{
				lPortRes = SendDlgItemMessage( hDlg,
												IDC_PORT_LIST,
												CB_GETLBTEXT,
												lPortRes,
												(LPARAM)szPortName);
				if (CB_ERR != lPortRes)
				{
					_tcscpy( g_szCurrentPort, szPortName);

					/*
					 * set port state
					 */
					g_portState = ePortSelected;
				}
			}

			configFinishButton( hDlg);
			break;
		}
	}
}

/*
 * void  setServiceData (HWND hDlg);
 *
 * Description: utility to configure the registry entries that
 *				contain info used by the UPS service
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void setServiceData(HWND hDlg)
{
	TCHAR szModelEntry[MAX_PATH] = _T("");

	DWORD dwTmpOpts = 0;
	LPTSTR lpTmpDLL = _T("");

	/*
	 * check that a vendor and model have been selected. If None
	 * were selected, that is considered a bad model.. and this
	 * check will fail, however, Custom/Generic is a valid selection
	 */
	if ((eModelSelected == g_modelState &&
		 eVendorSelected == g_vendorState)||
		(eModelCustom   == g_modelState &&
		 eVendorGeneric  == g_vendorState))
	{
		/*
		 * If the custom UPS model is selected, don't bother
		 * reading the registry entry. Custom can only be simple
		 * signalling and the options come from the custom dialog
		 */
		if (eModelCustom == g_modelState)
		{
			dwTmpOpts = g_dwCurrentCustomOptions;
		}
		else
		{
			HKEY hkResult;
			TCHAR szVendorKey[MAX_PATH] = _T("");

			wsprintf( szVendorKey, _T("%s\\%s"), UPS_SERVICE_ROOT, g_szCurrentVendor);
			
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
									szVendorKey,
									0,
									KEY_QUERY_VALUE,
									&hkResult))
			{
				LONG  lRes;
				DWORD dwValueLen;
				DWORD dwValueType;

				dwValueLen = sizeof(szModelEntry); //BYTES HERE, NOT CHARS

				lRes = RegQueryValueEx(
						  hkResult,				// handle to key to query
						  g_szCurrentModel,		// address of name of value to query
						  NULL,					// reserved
						  &dwValueType,			// address of buffer for value type
						  (LPBYTE)szModelEntry,	// address of data buffer
						  &dwValueLen			// address of data buffer size
						);

				if ((ERROR_SUCCESS == lRes) &&
					(0 != dwValueLen))
				{
					LPTSTR lpColon = NULL;
					/*
					 * seperate the DLL from the options data
					 */
					if (NULL != (lpColon = _tcschr( szModelEntry, (TCHAR)';')))
					{
						*lpColon = (TCHAR)'\0';
						lpColon++;

						lpTmpDLL = lpColon;
					}

					/*
					 * convert options data from string to int
					 * WARNING:
					 * wscanf doesn't work
					 * _tscanf doesn't work
					 * swscanf does
					 * _stscanf does
					 */
					 swscanf( szModelEntry, _T("%x"), &dwTmpOpts);
				}

				RegCloseKey( hkResult);
			}
		}
	}

	/*
	 * Move values into the registry
	 */
	g_dwCurrentOptions = dwTmpOpts;
	_tcscpy(g_szCurrentServiceDLL, lpTmpDLL);
}

/*
 * void  configPortList (HWND hDlg);
 *
 * Description: utility to configure port selection list ctrl
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void configPortList(HWND hDlg)
{
	/*
	 * enable the Port selection list, if
	 * 1) there is a valid vendor/model selection
	 *    this includes Custom/Generic but NOT (none)
	 * 2) there is a port or some type specified
	 */
	if (((eModelSelected == g_modelState &&
		  eVendorSelected == g_vendorState)||
		 (eModelCustom   == g_modelState &&
		  eVendorGeneric  == g_vendorState)) &&
		  ePortUnknown != g_portState)
	{
		EnableWindow( GetDlgItem( hDlg, IDC_PORT_LIST), TRUE);
		EnableWindow( GetDlgItem( hDlg, IDC_PORT_TEXT), TRUE);
	}
	else
	{
		EnableWindow( GetDlgItem( hDlg, IDC_PORT_LIST), FALSE);
		EnableWindow( GetDlgItem( hDlg, IDC_PORT_TEXT), FALSE);
	}
}

/*
 * void  configModelList (HWND hDlg);
 *
 * Description: utility to configure model selection list ctrl
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void configModelList(HWND hDlg)
{
	LRESULT lModelRes;

	/*
	 * to enable the model list, there has to
	 * be a valid or generic vendor selection (NOT none)
	 */
	if ((eVendorGeneric == g_vendorState ||
		 eVendorSelected == g_vendorState))
	{
		EnableWindow( GetDlgItem( hDlg, IDC_MODEL_LIST), TRUE);
		EnableWindow( GetDlgItem( hDlg, IDC_MODEL_TEXT), TRUE);

		/*
		 * make sure the selected item is visible
		 */
		lModelRes = SendDlgItemMessage( hDlg,
										IDC_MODEL_LIST,
										LB_GETCURSEL,
										0,0);
		if (LB_ERR != lModelRes)
		{
			SendDlgItemMessage( hDlg,
								IDC_MODEL_LIST,
								LB_SETTOPINDEX,
								lModelRes,0);
		}
	}
	else
	{
		EnableWindow( GetDlgItem( hDlg, IDC_MODEL_LIST), FALSE);
		EnableWindow( GetDlgItem( hDlg, IDC_MODEL_TEXT), FALSE);
	}
}

/*
 * void  configFinishButton (HWND hDlg);
 *
 * Description: utility to configure the Finish button ctrl
 *
 * Additional Information:
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 * Return Value:  none
 */
void configFinishButton(HWND hDlg)
{
	BOOL bFinState = FALSE;

	g_finishButtonState = eFinish; // default

	/*
	 * enable Finish if vendor is NONE
	 */
	if (eVendorNone == g_vendorState)
	{
		bFinState = TRUE;
	}
	else
	{
		/*
		 * If all other fields are valid, enable the button
		 */
		if (eVendorUnknown != g_vendorState &&
			eModelUnknown != g_modelState &&
			ePortUnknown != g_portState)
		{
			bFinState = TRUE;

			/*
			 * if the vendor/model is other/custom, the text of
			 * the button is Next
			 */
			if (eVendorGeneric == g_vendorState &&
				eModelCustom == g_modelState)
			{
				g_finishButtonState = eNext;
			}
		}
	}

	/*
	 * toggle between the finish and next buttons
	 */
    SendDlgItemMessage( hDlg, 
                        IDB_SELECT_FINISH, 
                        BM_SETSTYLE, 
                        eFinish == g_finishButtonState ? BS_DEFPUSHBUTTON:BS_PUSHBUTTON, 
                        (LPARAM) TRUE);

    //
    // Set the NExt Button's style
    //
    SendDlgItemMessage( hDlg, 
                        IDB_SELECT_NEXT, 
                        BM_SETSTYLE,
                        eNext == g_finishButtonState ? BS_DEFPUSHBUTTON:BS_PUSHBUTTON, 
                        (LPARAM) TRUE);

    //
    // Set the default push button's control ID.
    //
    SendMessage ( hDlg, 
                  DM_SETDEFID,
                  eFinish == g_finishButtonState ? IDB_SELECT_FINISH: IDB_SELECT_NEXT, 
                  0L);


	ShowWindow( GetDlgItem( hDlg, IDB_SELECT_FINISH),
				(eFinish == g_finishButtonState ? SW_SHOW : SW_HIDE));

	ShowWindow( GetDlgItem( hDlg, IDB_SELECT_NEXT),
			(eFinish == g_finishButtonState ? SW_HIDE : SW_SHOW));

	EnableWindow( GetDlgItem( hDlg, eFinish == g_finishButtonState ?
				  IDB_SELECT_FINISH : IDB_SELECT_NEXT), bFinState);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsreg.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSREG.H
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
********************************************************************************/

// This file contains declarations that support accessing
// registry data passed between the UPS service and the
// UPS UI.


#ifndef _UPSREG_H_
#define _UPSREG_H_

#ifdef __cplusplus
extern "C" {
#endif

LONG getStringValue(struct _reg_entry *aRegEntry, LPTSTR aBuffer); 
LONG getDwordValue(struct _reg_entry *aRegEntry, LPDWORD aValue); 

/* 
 * Public Config function declarations
 */
LONG GetUPSConfigVendor( LPTSTR aBuffer);
LONG GetUPSConfigModel( LPTSTR aBuffer);
LONG GetUPSConfigPort( LPTSTR aBuffer);
LONG GetUPSConfigOptions( LPDWORD aValue);
LONG GetUPSConfigShutdownWait( LPDWORD aValue);			
LONG GetUPSConfigFirstMessageDelay( LPDWORD aValue);			
LONG GetUPSConfigMessageInterval( LPDWORD aValue);	
LONG GetUPSConfigServiceDLL( LPTSTR aBuffer);
LONG GetUPSConfigNotifyEnable( LPDWORD aValue);
LONG GetUPSConfigShutdownOnBatteryEnable( LPDWORD aValue);
LONG GetUPSConfigShutdownOnBatteryWait( LPDWORD aValue);
LONG GetUPSConfigRunTaskEnable( LPDWORD aValue);
LONG GetUPSConfigTaskName( LPTSTR aBuffer);
LONG GetUPSConfigTurnOffEnable( LPDWORD aValue);
LONG GetUPSConfigAPCLinkURL( LPTSTR aBuffer);
LONG GetUPSConfigUpgrade( LPDWORD aValue);
LONG GetUPSConfigCustomOptions( LPDWORD aValue);
LONG GetUPSConfigCriticalPowerAction( LPDWORD aValue);
LONG GetUPSConfigTurnOffWait( LPDWORD aValue);
LONG GetUPSConfigImagePath( LPTSTR aBuffer);
LONG GetUPSConfigObjectName( LPTSTR aBuffer);
LONG GetUPSConfigShowUPSTab( LPDWORD aValue);
LONG GetUPSConfigErrorControl( LPDWORD aValue);
LONG GetUPSConfigStart( LPDWORD aValue);
LONG GetUPSConfigType( LPDWORD aValue);

LONG SetUPSConfigVendor( LPCTSTR aBuffer);
LONG SetUPSConfigModel( LPCTSTR aBuffer);
LONG SetUPSConfigPort( LPCTSTR aBuffer);
LONG SetUPSConfigOptions( DWORD aValue);
LONG SetUPSConfigShutdownWait( DWORD aValue);			
LONG SetUPSConfigFirstMessageDelay( DWORD aValue);			
LONG SetUPSConfigMessageInterval( DWORD aValue);		
LONG SetUPSConfigServiceDLL( LPCTSTR aBuffer);
LONG SetUPSConfigNotifyEnable( DWORD aValue);
LONG SetUPSConfigShutdownOnBatteryEnable( DWORD aValue); 
LONG SetUPSConfigShutdownOnBatteryWait( DWORD aValue);
LONG SetUPSConfigRunTaskEnable( DWORD aValue);
LONG SetUPSConfigTaskName( LPCTSTR aBuffer);
LONG SetUPSConfigTurnOffEnable( DWORD aValue);
LONG SetUPSConfigAPCLinkURL( LPCTSTR aBuffer);
LONG SetUPSConfigUpgrade( DWORD aValue);
LONG SetUPSConfigCustomOptions( DWORD aValue);
LONG SetUPSConfigCriticalPowerAction( DWORD aValue);
LONG SetUPSConfigTurnOffWait( DWORD aValue);
LONG SetUPSConfigImagePath( LPCTSTR aBuffer);
LONG SetUPSConfigObjectName( LPCTSTR aBuffer);
LONG SetUPSConfigShowUPSTab( DWORD aValue);
LONG SetUPSConfigErrorControl( DWORD aValue);
LONG SetUPSConfigStart( DWORD aValue);
LONG SetUPSConfigType( DWORD aValue);

/*
 * Public Status function declarations
 */
LONG GetUPSStatusSerialNum( LPTSTR aBuffer);
LONG GetUPSStatusFirmRev( LPTSTR aBuffer);
LONG GetUPSStatusUtilityStatus( LPDWORD aValue);
LONG GetUPSStatusRuntime( LPDWORD aValue);
LONG GetUPSStatusBatteryStatus( LPDWORD aValue);
LONG GetUPSStatusCommStatus( LPDWORD aValue);
LONG GetUPSStatusBatteryCapacity( LPDWORD aValue);

LONG SetUPSStatusSerialNum( LPCTSTR aBuffer);
LONG SetUPSStatusFirmRev( LPCTSTR aBuffer);
LONG SetUPSStatusUtilityStatus( DWORD aValue);
LONG SetUPSStatusRuntime( DWORD aValue);
LONG SetUPSStatusBatteryStatus( DWORD aValue);
LONG SetUPSStatusCommStatus( DWORD aValue);
LONG SetUPSStatusBatteryCapacity( DWORD aValue);

/*
 * Public Reg Entry function declarations
 */
void InitUPSConfigBlock();
void InitUPSStatusBlock();
void RestoreUPSConfigBlock();
void RestoreUPSStatusBlock();
void SaveUPSConfigBlock(BOOL forceAll);
void SaveUPSStatusBlock(BOOL forceAll);
void FreeUPSConfigBlock();
void FreeUPSStatusBlock();

/*
 * Reg entry path string declarations
 */
#define UPS_DEFAULT_ROOT _T("SYSTEM\\CurrentControlSet\\Services\\UPS")
#define UPS_STATUS_ROOT  _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\Status")
#define UPS_CONFIG_ROOT  _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")
#define UPS_SERVICE_ROOT _T("SYSTEM\\CurrentControlSet\\Services\\UPS\\ServiceProviders")
#define UPS_PORT_ROOT    _T("HARDWARE\\DEVICEMAP\\SERIALCOMM")

#define UPS_UTILITYPOWER_UNKNOWN 0
#define UPS_UTILITYPOWER_ON      1
#define UPS_UTILITYPOWER_OFF     2

#define UPS_BATTERYSTATUS_UNKNOWN 0
#define UPS_BATTERYSTATUS_GOOD    1
#define UPS_BATTERYSTATUS_REPLACE 2

#define UPS_COMMSTATUS_UNKNOWN 0
#define UPS_COMMSTATUS_OK      1
#define UPS_COMMSTATUS_LOST    2

// Defines the values for the 'Options' bitmask registry key
#define UPS_INSTALLED               0x00000001
#define UPS_POWERFAILSIGNAL         0x00000002
#define UPS_LOWBATTERYSIGNAL        0x00000004
#define UPS_SHUTOFFSIGNAL           0x00000008
#define UPS_POSSIGONPOWERFAIL       0x00000010
#define UPS_POSSIGONLOWBATTERY      0x00000020
#define UPS_POSSIGSHUTOFF           0x00000040
#define UPS_RUNCMDFILE              0x00000080

#define UPS_DEFAULT_SIGMASK			0x0000007f
#define DEFAULT_CONFIG_IMAGEPATH    TEXT("%SystemRoot%\\System32\\ups.exe")

// Min / Max / Default values for  FirstMessageDelay (seconds)
#define WAITSECONDSFIRSTVAL				0
#define WAITSECONDSLASTVAL				120
#define WAITSECONDSDEFAULT				5

// Min / Max / Default values for  MessageInterval (seconds)
#define REPEATSECONDSFIRSTVAL			5
#define REPEATSECONDSLASTVAL			300
#define REPEATSECONDSDEFAULT			120

// Min / Max / Default values for  ShutdownOnBatteryWait (minutes)
#define SHUTDOWNTIMERMINUTESFIRSTVAL	2
#define SHUTDOWNTIMERMINUTESLASTVAL		720
#define SHUTDOWNTIMERMINUTESDEFAULT     2

// Shutdown behavior values
#define UPS_SHUTDOWN_SHUTDOWN   0
#define UPS_SHUTDOWN_HIBERNATE  1

/** ServiceProvider structure.  The structure defines the entries in the
*  ServiceProviders registry key.
*/
typedef struct {
LPTSTR  theVendorKey;		  // Vendor registry subkey
LPTSTR  theModelName;     // UPS model name
LPTSTR  theValue;         // UPS value data
} ServiceProviderStructure;


/**
* InitializeRegistry
*
* Description:
*   This function initiates the registry for the UPS service and the 
*   configuration application.  When called, this function examines 
*   the registry to determine if it needs to be initalized.  If the key
*   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UPS\Config\ServiceProviderDLL
*   is present, the registry is assumed to be initialized and no initialization
*   is done.  If the key is not present the following Keys are updated:
*        Status
*        Config
*        ServiceProviders
*
*   The values for the ServiceProviders key is supplied in the regdefs.h
*   header file.
*
* Parameters:
*   none
*
* Returns:
*   TRUE if able to open registry keys with write access.
*/
BOOL InitializeRegistry();


///////////////
// upsdefines.h
#ifndef _ASSERT
#define _ASSERT(x) 
#endif

#define DIMENSION_OF(array) (sizeof(array)/sizeof(array[0]))

//This value is used in most of the text buffers in various places throughout
//the application.
#define MAX_MESSAGE_LENGTH      1024

//The following three strings are the registry value names where all
//the UPS data is stored. These values are used in the RegField array
//in datacces.c
#define UPS_KEY_NAME    TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS")
#define STATUS_KEY_NAME TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Status")
#define CONFIG_KEY_NAME TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")

//The following values are used in the DialogAssociations arrays in updatdlg.c
//and upsinfo.c
#define RESOURCE_FIXED     0
#define RESOURCE_INCREMENT 1
#define REG_ANY_DWORD_TYPE (REG_DWORD | REG_DWORD_BIG_ENDIAN | REG_DWORD_LITTLE_ENDIAN)

//This is a helper macro to help form a DialogAssociations array members.
#define MAKE_ARRAY(stub, insertID, indexID, stringType, indexMax, regAccessType, shallowAccessPtr, regEntryPtr)\
  { eREG_##stub, IDC_##stub##_LHS, IDC_##stub, insertID, indexID, stringType, indexMax, regAccessType, shallowAccessPtr, regEntryPtr }

//The following are all the registry values supported by the application.
//The amount and values to these enums correspond to the size of the array
//g_upsRegFields
typedef enum _tUPSDataItemID { eREG_VENDOR_NAME = 0,
                               eREG_MODEL_TYPE,
                               eREG_SERIAL_NUMBER,
                               eREG_FIRMWARE_REVISION,
                               eREG_POWER_SOURCE,
                               eREG_RUNTIME_REMAINING,
							   eREG_BATTERY_CAPACITY,
                               eREG_BATTERY_STATUS,
                               eREG_UPS_OPTIONS,
                               eREG_SERVICE_PROVIDER_DLL,
                               eREG_SHUTDOWN_ON_BATTERY_ENABLE,
                               eREG_SHUTDOWN_ON_BATTERY_WAIT,
                               eREG_TURN_UPS_OFF_ENABLE,
                               eREG_APC_LINKURL,
                               eREG_UPGRADE_ENABLE,
                               eREG_COMM_STATUS,
                               eREG_PORT } tUPSDataItemID;

//This enum is used in DialogAssociations below. This defines the
//type of registry query to perform when reading registry values.
//There are only two options, to perform a deep get, that is, go
//right to the registry every time, re-reading it from the registry, or to
//use the regfunc buffer value (shallow get).
typedef enum _tRegAccessType { eDeepGet = 0,
                               eShallowGet } tRegAccessType;

//This struct links the registry field and the dialog controls.
typedef struct _DialogAssociations {
  const tUPSDataItemID theFieldTypeID;              //the eREG_... id. This is used to read the
                                                    //registry data.
  DWORD                theStaticFieldID;            //A control id (usually for a static control). This
                                                    //is the left-hand side control. For example, in the
                                                    //on-screen text "Model Type: Back-UPS Pro" there are
                                                    //actually two controls the left-hand side (LHS) is
                                                    //"Model Type:" and the right-hand side is "Back-UPS Pro".
                                                    //These controls are separated as the LHS's behavior is
                                                    //different to the RHS when no data is present.
  DWORD                theDisplayControlID;         //A control id (usually an edit field or a static)
  DWORD                theResourceInsertID;         //The id of the string resource to insert the value into
                                                    //If the registry value is a DWORD then
                                                    //the insertion point should be %n!lu!, if
                                                    //it's a string then the insertion point can be just %n
  DWORD                theResourceIndexID;          //This is only relevant if theResourceStringType is
                                                    //of type RESOURCE_INCREMENT. This identifies the id
                                                    //of the string when the value read for this item is 0,
                                                    //it is assumed that the other string values are stored
                                                    //consequtively in the string table following this value.
                                                    //For an example see below.
  DWORD                theResourceStringType;       //This can be RESOURCE_FIXED or RESOURCE_INCREMENT.
                                                    //RESOURCE_FIXED means that the value needs no special
                                                    //handling. Simple insert the value into the string
                                                    //identified by theResourceInsertID. If it's equal to
                                                    //RESOURCE_INCREMENT then the string inserted is determined
                                                    //by reading the value from the registry (say it's equal
                                                    //to 1). The theResourceIndexID indentifies the id of the
                                                    //string resource corresponding to a value. A value of 1
                                                    //gives up the string with id theResourceIndexID + 1. This
                                                    //string is loaded and inserted into the string identified
                                                    //by theResourceInsertID.
  DWORD                theResourceIndexMax;         //This is only relevant if theResourceStringType is
                                                    //of type RESOURCE_INCREMENT. This identifies the maximum
                                                    //index value that is support for this increment type. This
                                                    //is to protect from unsupported registry value causing the
                                                    //"theResourceIndexID + value" addition going beyond the
                                                    //range of supported string resource values.
  tRegAccessType       theRegAccessType;            //This define whether the access to the registry value
                                                    //should use a "shallow" or "deep" get. See help on
                                                    //tUPSDataItemID above.
  void *               theShallowAccessFunctionPtr; //This point to the regfuncs function to use when performing
                                                    //a shallow get. This parameter is only required if
                                                    //theRegAccessType is set to eShallowGet, otherwise it can
                                                    //be 0.
  struct _reg_entry *  theRegEntryPtr;              //This is the _reg_entry * parameter passed to the regfuncs
                                                    //function (theShallowAccessFunctionPtr member) when
                                                    //performing a shallow get. This parameter is only required if
                                                    //theRegAccessType is set to eShallowGet, otherwise it can
                                                    //be 0.
  } DialogAssociations;

/*

  The following example helps to explain more the members of the DialogAssociations struct.

  Say we have an instance of this struct as follows:

  DialogAssociations da = { eREG_POWER_SOURCE,
                            IDC_POWER_SOURCE_LHS,
                            IDC_POWER_SOURCE,
                            IDS_STRING,
                            IDS_UTILITYPOWER_UNKNOWN,
                            RESOURCE_INCREMENT,
                            2,
                            eDeepGet,
                            0,
                            0 };

  This describes a registry field called eREG_POWER_SOURCE. If we look at
  tUPSDataItemID above we see that eREG_POWER_SOURCE has a value of 4. If
  we then look at g_upsRegFields in datacces.c we that the RegField at index
  4 has the following data:

  { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("UtilityPowerStatus"), REG_DWORD },

  The DoUpdateInfo function, for example, takes this information when updating
  the onscreen data in the main UPS page. The function gets the RegField
  information, as above. It then looks to see if it needs to do a deep get (read
  directly from the registry), or a shallow get (take data from the current
  values stored in the regfuncs buffers. If the registry item theValueType is
  one of the string type then the string value is copied into the resource
  string identified by theResourceInsertID. In this case theValueType is
  REG_DWORD. In this case the DWORD is read from the registry directly. Its
  value (say it had a value of 1) is then added to IDS_UTILITYPOWER_UNKNOWN
  giving a value which corresponds to IDS_UTILITYPOWER_ON. The string
  IDS_UTILITYPOWER_ON is then loaded and used as a parameter value when
  loaded the parameterized string resource identified by the
  theResourceInsertID string id. This string (which should include the inserted
  text) is then displayed in the control identified by theDisplayControlID.
*/


//this struct describes a registy field item 
typedef struct _RegField {
  HKEY    theRootKey;   //Handle to an existing registry key.
  LPCTSTR theKeyName;   //The name of the subkey relative to the above handle.
  LPCTSTR theValueName; //The name of the registry value.
  DWORD   theValueType; //The type of the value.
  } RegField;

///////////////////////////////////////////////////////////////////////////////

RegField * GetRegField      (DWORD index);

// upsdata.h
//Note that the order and numbering of the enums in tUPSDataItemID is linked to
//the contents of the array of RegFields defined in datacces.h. 
//Do not change these value without due care and attention. It's OK to change
//it as long as the array of RegFields is updated to match.

DWORD ReadRegistryValueData (HKEY aRootKey,
                             LPCTSTR aKeyName,
                             LPCTSTR aValueName,
                             DWORD aAllowedTypes,
                             DWORD * aTypePtr,
                             LPTSTR aReturnBuffer,
                             DWORD * aBufferSizePtr);

BOOL GetUPSDataItemDWORD  (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr);
BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID, LPTSTR aBufferPtr, DWORD * pSizeOfBufferPtr);



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsreg.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSREG.C
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*******************************************************************************/

/*
 * system includes
 */
#include <windows.h>
#include <tchar.h>

/*
 * local includes
 */
//#include "upsdefines.h"
#include "upsreg.h"
#include "regdefs.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Reg entry info structure declaration
 */
struct _reg_entry
{
  HKEY    hKey;			/* the key */
  LPTSTR  lpSubKey;		/* address of SubKey name */
  LPTSTR  lpValueName;  /* address of name of value to query */
  DWORD   ulType;       /* buffer for value type */
  LPBYTE  lpData;       /* address of data buffer */
  DWORD   cbData;       /* data buffer size */
  BOOL    changed;		/* ID of dialog that changed this entry */
};

/*
 * local function pre-declarations
 */
void freeBlock(struct _reg_entry *aBlock[]);
void readBlock(struct _reg_entry *aBlock[], BOOL changed); 
void writeBlock(struct _reg_entry *aBlock[], BOOL forceAll);
LONG setDwordValue(struct _reg_entry *aRegEntry, DWORD aValue);
LONG setStringValue(struct _reg_entry *aRegEntry, LPCTSTR aBuffer);

static BOOL isRegistryInitialized();
static void CheckForUpgrade();
static void InitializeServiceKeys();
static void InitializeServiceProviders();
static void InitializeConfigValues();
static void InitializeStatusValues();


/* 
 * Reg entry value name declarations
 */
#define UPS_VENDOR				_T("Vendor")
#define UPS_MODEL				_T("Model")
#define UPS_SERIALNUMBER		_T("SerialNumber")
#define UPS_FIRMWAREREV			_T("FirmwareRev")
#define UPS_UTILITYSTATUS		_T("UtilityPowerStatus")
#define UPS_RUNTIME				_T("TotalUPSRuntime")
#define UPS_BATTERYSTATUS		_T("BatteryStatus")
#define UPS_PORT				_T("Port")
#define UPS_OPTIONS				_T("Options")
#define UPS_SHUTDOWNWAIT		_T("ShutdownWait")
#define UPS_FIRSTMESSAGEDELAY	_T("FirstMessageDelay")
#define UPS_MESSAGEINTERVAL		_T("MessageInterval")
#define UPS_SERVICEDLL			_T("ServiceProviderDLL")
#define UPS_NOTIFYENABLE		_T("NotifyEnable")
#define UPS_SHUTBATTENABLE		_T("ShutdownOnBatteryEnable")
#define UPS_SHUTBATTWAIT		_T("ShutdownOnBatteryWait")
#define UPS_RUNTASKENABLE		_T("RunTaskEnable")
#define UPS_TASKNAME			_T("TaskName")
#define UPS_TURNUPSOFFENABLE	_T("TurnUPSOffEnable")
#define UPS_APCLINKURL			_T("APCLinkURL")
#define UPS_CUSTOMOPTIONS       _T("CustomOptions")
#define UPS_UPGRADE				_T("Upgrade")
#define UPS_COMMSTATUS			_T("CommStatus")
#define UPS_CRITICALPOWERACTION  _T("CriticalPowerAction")
#define UPS_TURNUPSOFFWAIT           _T("TurnUPSOffWait")
#define UPS_SHOWTAB              _T("ShowUPSTab")
#define UPS_BATTERYCAPACITY       _T("BatteryCapacity")
#define UPS_IMAGEPATH			    _T("ImagePath")
#define UPS_ERRORCONTROL      _T("ErrorControl")
#define UPS_OBJECTNAME        _T("ObjectName")
#define UPS_START             _T("Start")
#define UPS_TYPE              _T("Type")

// This specifies the key to examine to determine if the registry
// has been updated for the UPS Service.
#define UPS_SERVICE_INITIALIZED_KEY   TEXT("SYSTEM\\CurrentControlSet\\Services\\UPS\\Config")

// Specifies the name of the BatteryLife key used in the NT 4.0 UPS Service
#define UPS_BATTLIFE_KEY              TEXT("BatteryLife")

// This specifies the default name for the shutdown Task
#define DEFAULT_SHUTDOWN_TASK_NAME    TEXT("") 

// Default values for the Config settings
#define DEFAULT_CONFIG_VENDOR_OLD               TEXT("\\(NONE)")
#define DEFAULT_CONFIG_VENDOR                   TEXT("")
#define DEFAULT_CONFIG_MODEL                    TEXT("")
#define DEFAULT_CONFIG_PORT                     TEXT("COM1")
#define DEFAULT_CONFIG_OPTIONS                  0x7e
#define DEFAULT_CONFIG_FIRSTMSG_DELAY           5  
#define DEFAULT_CONFIG_MESSAGE_INTERVAL         120
#define DEFAULT_CONFIG_PROVIDER_DLL             TEXT("")
#define DEFAULT_CONFIG_NOTIFY_ENABLE            1
#define DEFAULT_CONFIG_SHUTDOWN_ONBATT_ENABLE   FALSE
#define DEFAULT_CONFIG_SHUTDOWN_ONBATT_WAIT     2
#define DEFAULT_CONFIG_RUNTASK_ENABLE           FALSE
#define DEFAULT_CONFIG_TASK_NAME                DEFAULT_SHUTDOWN_TASK_NAME
#define DEFAULT_CONFIG_TURNOFF_UPS_ENABLE       TRUE
#define DEFAULT_CONFIG_CUSTOM_OPTIONS           UPS_DEFAULT_SIGMASK
#define DEFAULT_CONFIG_CRITICALPOWERACTION      UPS_SHUTDOWN_SHUTDOWN
#define DEFAULT_CONFIG_TURNOFF_UPS_WAIT         180
#define DEFAULT_CONFIG_ERRORCONTROL             1
#define DEFAULT_CONFIG_OBJECTNAME               TEXT("LocalSystem")
#define DEFAULT_CONFIG_START                    SERVICE_DEMAND_START
#define DEFAULT_CONFIG_TYPE                     16
#define DEFAULT_CONFIG_SHOWUPSTAB               FALSE

// Default values for the Status settings
#define DEFAULT_STATUS_SERIALNO                 TEXT("")
#define DEFAULT_STATUS_FIRMWARE_REV             TEXT("")
#define DEFAULT_STATUS_UTILITY_STAT             0
#define DEFAULT_STATUS_TOTAL_RUNTIME            0
#define DEFAULT_STATUS_BATTERY_STAT             0
#define DEFAULT_STATUS_BATTERY_CAPACITY         0

// Default values for upgraded services
#define UPGRADE_CONFIG_VENDOR_OLD               TEXT("\\Generic")
#define UPGRADE_CONFIG_VENDOR                   TEXT("")
#define UPGRADE_CONFIG_MODEL                    TEXT("")

/* 
 * Allocate the individual Configuration Reg entry records 
 */
struct _reg_entry UPSConfigVendor			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_VENDOR,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigModel			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_MODEL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigPort				= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_PORT,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigOptions			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_OPTIONS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigServiceDLL		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SERVICEDLL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigNotifyEnable		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_NOTIFYENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigFirstMessageDelay= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_FIRSTMESSAGEDELAY,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigMessageInterval	= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_MESSAGEINTERVAL,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShutBattEnable   = {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SHUTBATTENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShutBattWait     = {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_SHUTBATTWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigRunTaskEnable	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_RUNTASKENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigTaskName			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TASKNAME,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigTurnOffEnable	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TURNUPSOFFENABLE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigCustomOptions	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_CUSTOMOPTIONS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigAPCLinkURL		= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_APCLINKURL,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigShutdownWait		= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_SHUTDOWNWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigUpgrade			= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_UPGRADE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigCriticalPowerAction	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_CRITICALPOWERACTION,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigTurnOffWait	= {HKEY_LOCAL_MACHINE,UPS_CONFIG_ROOT,UPS_TURNUPSOFFWAIT,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigImagePath			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_IMAGEPATH,REG_EXPAND_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigObjectName			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_OBJECTNAME,REG_EXPAND_SZ,NULL,0,FALSE};
struct _reg_entry UPSConfigErrorControl			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_ERRORCONTROL,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigStart			    = {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_START,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigType     			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_TYPE,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSConfigShowUPSTab			= {HKEY_LOCAL_MACHINE,UPS_DEFAULT_ROOT,UPS_SHOWTAB,REG_DWORD,NULL,0,FALSE};

/* 
 * Allocate the individual Status Reg entry records 
 */
struct _reg_entry UPSStatusSerialNum	= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_SERIALNUMBER,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSStatusFirmRev		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_FIRMWAREREV,REG_SZ,NULL,0,FALSE};
struct _reg_entry UPSStatusUtilityStatus= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_UTILITYSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusRuntime		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_RUNTIME,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusBatteryStatus= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_BATTERYSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusCommStatus	= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_COMMSTATUS,REG_DWORD,NULL,0,FALSE};
struct _reg_entry UPSStatusBatteryCapacity		= {HKEY_LOCAL_MACHINE,UPS_STATUS_ROOT,UPS_BATTERYCAPACITY,REG_DWORD,NULL,0,FALSE};

/* 
 * Allocate an array of pointers to the Configuration Reg entry records
 */
struct _reg_entry *ConfigBlock[] =  {&UPSConfigVendor,
									&UPSConfigModel,
									&UPSConfigPort,
									&UPSConfigOptions,
									&UPSConfigServiceDLL,
									&UPSConfigNotifyEnable,
									&UPSConfigFirstMessageDelay,
									&UPSConfigMessageInterval,
									&UPSConfigShutBattEnable,
									&UPSConfigShutBattWait,
									&UPSConfigRunTaskEnable,
									&UPSConfigTaskName,
									&UPSConfigTurnOffEnable,
									&UPSConfigCustomOptions,
									&UPSConfigAPCLinkURL,
									&UPSConfigShutdownWait,
									&UPSConfigUpgrade,
									&UPSConfigCriticalPowerAction,
									&UPSConfigTurnOffWait,
                  &UPSConfigImagePath,
                  &UPSConfigObjectName,
                  &UPSConfigErrorControl,
                  &UPSConfigStart,
                  &UPSConfigType,   		
									&UPSConfigShowUPSTab,
									NULL};

/* 
 * Allocate an array of pointers to the Status Reg entry records
 */
struct _reg_entry *StatusBlock[] = {&UPSStatusSerialNum,
									&UPSStatusFirmRev,
									&UPSStatusUtilityStatus,
									&UPSStatusRuntime,
									&UPSStatusBatteryStatus,
									&UPSStatusCommStatus,
									&UPSStatusBatteryCapacity,
									NULL};


/******************************************************************
 * Public functions
 */

LONG GetUPSConfigVendor( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigVendor, aBuffer);
}

LONG GetUPSConfigModel( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigModel, aBuffer);
}

LONG GetUPSConfigPort( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigPort, aBuffer);
}

LONG GetUPSConfigOptions( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigOptions, aValue);
}

LONG GetUPSConfigServiceDLL( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigServiceDLL, aBuffer);
}

LONG GetUPSConfigNotifyEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigNotifyEnable, aValue);
}

LONG GetUPSConfigFirstMessageDelay( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigFirstMessageDelay, aValue);
}

LONG GetUPSConfigMessageInterval( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigMessageInterval, aValue);
}

LONG GetUPSConfigShutdownOnBatteryEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutBattEnable, aValue);
}

LONG GetUPSConfigShutdownOnBatteryWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutBattWait, aValue);
}

LONG GetUPSConfigRunTaskEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigRunTaskEnable, aValue);
}

LONG GetUPSConfigTaskName( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigTaskName, aBuffer);
}

LONG GetUPSConfigTurnOffEnable( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigTurnOffEnable, aValue);
}

LONG GetUPSConfigCustomOptions( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigCustomOptions, aValue);
}

LONG GetUPSConfigAPCLinkURL( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigAPCLinkURL, aBuffer);
}

LONG GetUPSConfigShutdownWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShutdownWait, aValue);
}

LONG GetUPSConfigUpgrade( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigUpgrade, aValue);
}

LONG GetUPSConfigCriticalPowerAction( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigCriticalPowerAction, aValue);
}

LONG GetUPSConfigTurnOffWait( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigTurnOffWait, aValue);
}

LONG GetUPSConfigShowUPSTab( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigShowUPSTab, aValue);
}

LONG GetUPSConfigImagePath( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigImagePath, aBuffer);
}

LONG GetUPSConfigObjectName( LPTSTR aBuffer)
{
	return getStringValue( &UPSConfigObjectName, aBuffer);
}

LONG GetUPSConfigErrorControl( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigErrorControl, aValue);
}

LONG GetUPSConfigStart( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigStart, aValue);
}

LONG GetUPSConfigType( LPDWORD aValue)
{
	return getDwordValue( &UPSConfigType, aValue);
}

///////////////////////////////////////////

LONG SetUPSConfigVendor( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigVendor, aBuffer);
}

LONG SetUPSConfigModel( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigModel, aBuffer);
}

LONG SetUPSConfigPort( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigPort, aBuffer);
}

LONG SetUPSConfigOptions( DWORD aValue)
{
	return setDwordValue( &UPSConfigOptions, aValue);
}

LONG SetUPSConfigServiceDLL( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigServiceDLL, aBuffer);
}

LONG SetUPSConfigNotifyEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigNotifyEnable, aValue);
}

LONG SetUPSConfigFirstMessageDelay( DWORD aValue)
{
	return setDwordValue( &UPSConfigFirstMessageDelay, aValue);
}

LONG SetUPSConfigMessageInterval( DWORD aValue)
{
	return setDwordValue( &UPSConfigMessageInterval, aValue);
}

LONG SetUPSConfigShutdownOnBatteryEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigShutBattEnable, aValue);
}

LONG SetUPSConfigShutdownOnBatteryWait( DWORD aValue) 
{
	return setDwordValue( &UPSConfigShutBattWait, aValue); 
}

LONG SetUPSConfigRunTaskEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigRunTaskEnable, aValue);
}

LONG SetUPSConfigTaskName( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigTaskName, aBuffer);
}

LONG SetUPSConfigTurnOffEnable( DWORD aValue)
{
	return setDwordValue( &UPSConfigTurnOffEnable, aValue);
}

LONG SetUPSConfigCustomOptions( DWORD aValue)
{
	return setDwordValue( &UPSConfigCustomOptions, aValue);
}

LONG SetUPSConfigAPCLinkURL( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigAPCLinkURL, aBuffer);
}

LONG SetUPSConfigShutdownWait( DWORD aValue)
{
	return setDwordValue( &UPSConfigShutdownWait, aValue);
}

LONG SetUPSConfigUpgrade( DWORD aValue)
{
	return setDwordValue( &UPSConfigUpgrade, aValue);
}

LONG SetUPSConfigCriticalPowerAction( DWORD aValue)
{
	return setDwordValue( &UPSConfigCriticalPowerAction, aValue);
}

LONG SetUPSConfigTurnOffWait( DWORD aValue)
{
	return setDwordValue( &UPSConfigTurnOffWait, aValue);
}

LONG SetUPSConfigShowUPSTab( DWORD aValue)
{
	return setDwordValue( &UPSConfigShowUPSTab, aValue);
}

LONG SetUPSConfigImagePath( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigImagePath, aBuffer);
}

LONG SetUPSConfigObjectName( LPCTSTR aBuffer)
{
	return setStringValue( &UPSConfigObjectName, aBuffer);
}

LONG SetUPSConfigErrorControl( DWORD aValue)
{
	return setDwordValue( &UPSConfigErrorControl, aValue);
}

LONG SetUPSConfigStart( DWORD aValue)
{
	return setDwordValue( &UPSConfigStart, aValue);
}

LONG SetUPSConfigType( DWORD aValue)
{
	return setDwordValue( &UPSConfigType, aValue);
}


////////////////////////////////////////////////

LONG GetUPSStatusSerialNum( LPTSTR aBuffer)
{
	return getStringValue( &UPSStatusSerialNum, aBuffer);
}

LONG GetUPSStatusFirmRev( LPTSTR aBuffer)
{
	return getStringValue( &UPSStatusFirmRev, aBuffer);
}

LONG GetUPSStatusUtilityStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusUtilityStatus, aValue);
}

LONG GetUPSStatusRuntime( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusRuntime, aValue);
}

LONG GetUPSStatusBatteryStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusBatteryStatus, aValue);
}

LONG GetUPSStatusCommStatus( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusCommStatus, aValue);
}

LONG GetUPSBatteryCapacity( LPDWORD aValue)
{
	return getDwordValue( &UPSStatusBatteryCapacity, aValue);
}

/////////////////////////////////////////

LONG SetUPSStatusSerialNum( LPCTSTR aBuffer)
{
	return setStringValue( &UPSStatusSerialNum, aBuffer);
}

LONG SetUPSStatusFirmRev( LPCTSTR aBuffer)
{
	return setStringValue( &UPSStatusFirmRev, aBuffer);
}

LONG SetUPSStatusUtilityStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusUtilityStatus,aValue);
}

LONG SetUPSStatusRuntime( DWORD aValue)
{
	return setDwordValue( &UPSStatusRuntime,aValue);
}

LONG SetUPSStatusBatteryStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusBatteryStatus,aValue);
}

LONG SetUPSStatusCommStatus( DWORD aValue)
{
	return setDwordValue( &UPSStatusCommStatus,aValue);
}

LONG SetUPSStatusBatteryCapacity( DWORD aValue)
{
	return setDwordValue( &UPSStatusBatteryCapacity,aValue);
}

//////////////////////////////////////////////////////////////

void FreeUPSConfigBlock()
{
	freeBlock(ConfigBlock);
}

void FreeUPSStatusBlock()
{
	freeBlock(StatusBlock);
}

void InitUPSConfigBlock()
{
	readBlock(ConfigBlock,FALSE);
}

void InitUPSStatusBlock()
{
	readBlock(StatusBlock,FALSE);
}

void RestoreUPSConfigBlock()
{
	readBlock(ConfigBlock, TRUE);
}

void RestoreUPSStatusBlock()
{
	readBlock(StatusBlock, TRUE);
}

void SaveUPSConfigBlock(BOOL forceAll)
{
	writeBlock(ConfigBlock, forceAll);
}

void SaveUPSStatusBlock(BOOL forceAll)
{
	writeBlock(StatusBlock, forceAll);
}

/******************************************************************
 * Local functions
 */

/*
 * freeBlock()
 *
 * Description: Frees storage allocated when a block of registry 
 *				entries is read
 *
 * Parameters: aBlock - pointer to an array of _reg_entry structures
 *
 * Returns:
 */
void freeBlock(struct _reg_entry *aBlock[]) 
{
	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		if (NULL != anEntry->lpData)
		{
			LocalFree(anEntry->lpData);
		}
		anEntry->lpData = NULL;
		anEntry->cbData = 0;
		anEntry->changed = FALSE; 

		aBlock++;
	}
}

/*
 * readBlock()
 *
 * Description: Loads all of the items in a array of registry entries
 *
 * Parameters:  aBlock - pointer to an array of _reg_entry structures
 *				changed - boolean which, when true, causes only the
 *				structures that are marked as changed to be loaded.
 *
 * Returns:
 */
void readBlock(struct _reg_entry *aBlock[], BOOL changed) 
{
	LONG res;
	HKEY hkResult;

	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		/* 
		 * if changed is FALSE, we read all entries
		 * otherwise, only re-read the changed entries
		 */
		if ((FALSE == changed) || (TRUE == anEntry->changed))
		{
			/* 
			 * delete current value, in case this is a reload 
			 */
			if (NULL != anEntry->lpData)
			{
				LocalFree(anEntry->lpData);
			}
			anEntry->lpData = NULL;
			anEntry->cbData = 0;
			anEntry->changed = FALSE;

			/* 
			 * open key 
			 */
			res = RegOpenKeyEx( anEntry->hKey,
								anEntry->lpSubKey,
								0,
								KEY_QUERY_VALUE,
								&hkResult);

			if (ERROR_SUCCESS == res) 
			{
				DWORD ulTmpType;

				/* 
				 * query for the data size 
				 */
				res = RegQueryValueEx( hkResult,
										anEntry->lpValueName,
										NULL,
										&ulTmpType,
										NULL,
										&anEntry->cbData);

				/* 
				 * if the data has 0 size, we don't read it 
				 */
				if ((ERROR_SUCCESS == res) && 
					(anEntry->cbData > 0) && 
					(anEntry->ulType == ulTmpType) &&
					(NULL != (anEntry->lpData = (LPBYTE)LocalAlloc(LMEM_FIXED, anEntry->cbData))))
//					(NULL != (anEntry->lpData = (LPBYTE)malloc(anEntry->cbData))))
				{
					/* 
					 * query for data 
					 */
					res = RegQueryValueEx( hkResult,
											anEntry->lpValueName,
											NULL,
											&ulTmpType,
											anEntry->lpData,
											&anEntry->cbData);
					
					/* 
					 * something went wrong; reset 
					 */
					if (ERROR_SUCCESS != res)
					{
						LocalFree(anEntry->lpData);
						anEntry->lpData = NULL;
						anEntry->cbData = 0;
					}
				}
				else
				{
					anEntry->cbData = 0;
				}

				RegCloseKey(hkResult);
			}
		}

		aBlock++;
	}
}

/*
 * writeBlock()
 *
 * Description: Stores all of the items in a array of registry entries
 *
 * Parameters:  aBlock - pointer to an array of _reg_entry structures
 *				forceAll - boolean which, when true, causes all of the
 *				structures to be written to the registry, otherwise only
 *				those entries that are marked as changed are stored.
 *
 * Returns:
 */
void writeBlock(struct _reg_entry *aBlock[], BOOL forceAll) 
{
	LONG res;
	HKEY hkResult;

	while ((NULL != aBlock) && (NULL != *aBlock))
	{
		struct _reg_entry *anEntry = *aBlock;

		/*
		 * if forcall is true, write out everything
		 * otherwise only write out the changed entries
		 */
		if ((NULL != anEntry->lpData) &&
			((TRUE == forceAll) || (TRUE == anEntry->changed)))
		{
			/* 
			 * open key 
			 */
			res = RegOpenKeyEx( anEntry->hKey,
								anEntry->lpSubKey,
								0,
								KEY_SET_VALUE,
								&hkResult);

			if (ERROR_SUCCESS == res) 
			{
				/* 
				 * set data 
				 */
				res = RegSetValueEx( hkResult,
										anEntry->lpValueName,
										0,
										anEntry->ulType,
										anEntry->lpData,
										anEntry->cbData);
				
				RegCloseKey(hkResult);
			}

			anEntry->changed = FALSE;  
		}

		aBlock++;
	}
}

/*
 * setDwordValue()
 *
 * Description: Sets the value of a REG_DWORD entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aValue - the value to store in the entry
 *
 * Returns: ERROR_SUCCESS, E_OUTOFMEMORY, ERROR_INVALID_PARAMETER
 */
LONG setDwordValue(struct _reg_entry *aRegEntry, DWORD aValue)
{
	LONG res = ERROR_SUCCESS;

	if (NULL != aRegEntry)
	{
		/*
		 * if a value already exists, delete it
		 */
		if (NULL != aRegEntry->lpData)
		{
			LocalFree (aRegEntry->lpData);
			aRegEntry->lpData = NULL;
			aRegEntry->cbData = 0;
		}

		/*
		 * set value
		 */
		aRegEntry->cbData = sizeof(DWORD);
		if (NULL != (aRegEntry->lpData = LocalAlloc(LMEM_FIXED, aRegEntry->cbData)))
		{
			*((DWORD*)aRegEntry->lpData) = aValue;
			aRegEntry->changed = TRUE;
		}
		else 
		{ 
			res = E_OUTOFMEMORY;
			aRegEntry->cbData = 0;
		}
	}
	else 
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}

/*
 * setStringValue()
 *
 * Description: Sets the value of a REG_SZ entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aBuffer - pointer to the string to store in the entry
 *
 * Returns: ERROR_SUCCESS, E_OUTOFMEMORY, ERROR_INVALID_PARAMETER
 */
LONG setStringValue(struct _reg_entry *aRegEntry, LPCTSTR aBuffer)
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aBuffer))
	{
		/*
		 * if value already exists, delete it
		 */
		if (NULL != aRegEntry->lpData)
		{
			LocalFree(aRegEntry->lpData);
			aRegEntry->lpData = NULL;
			aRegEntry->cbData = 0;
		}

		/*
		 * set value
		 */
		aRegEntry->cbData = (_tcslen(aBuffer)+1)*sizeof(TCHAR);
		if (NULL != (aRegEntry->lpData = LocalAlloc(LMEM_FIXED, aRegEntry->cbData)))
		{
			_tcscpy((LPTSTR)aRegEntry->lpData,aBuffer);
			aRegEntry->changed = TRUE;
		}
		else 
		{ 
			res = E_OUTOFMEMORY;
			aRegEntry->cbData = 0;
		}
	}
	else 
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/*
 * getStringValue()
 *
 * Description: Gets the value of a REG_SZ entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aBuffer - pointer to the string to receive the string
 *
 * Returns: ERROR_SUCCESS, REGDB_E_INVALIDVALUE, ERROR_INVALID_PARAMETER
 */
LONG getStringValue(struct _reg_entry *aRegEntry, LPTSTR aBuffer) 
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aBuffer))
	{
		if (NULL != aRegEntry->lpData)
		{
			_tcscpy(aBuffer, (LPCTSTR)aRegEntry->lpData);
		}
		else 
		{
			res = REGDB_E_INVALIDVALUE;
		}
	}
	else
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}

/*
 * getDwordValue()
 *
 * Description: Gets the value of a REG_DWORD entry record.
 *
 * Parameters:  aRegEntry - pointer to a _reg_entry structure
 *				aValue - pointer to the variable to receive the value
 *
 * Returns: ERROR_SUCCESS, REGDB_E_INVALIDVALUE, ERROR_INVALID_PARAMETER
 */
LONG getDwordValue(struct _reg_entry *aRegEntry, LPDWORD aValue) 
{
	LONG res = ERROR_SUCCESS;

	if ((NULL != aRegEntry) && (NULL != aValue))
	{
		if (NULL != aRegEntry->lpData)
		{
			*aValue = *((DWORD*)aRegEntry->lpData);
		}
		else
		{
			res = REGDB_E_INVALIDVALUE;
		}
	}
	else
	{
		res = ERROR_INVALID_PARAMETER;
	}

	return res;
}


/**
* InitializeRegistry
*
* Description:
*   This function initiates the registry for the UPS service and the 
*   configuration application.  When called, this function calls the
*   function isRegistryInitialized(..) to determine if the registry
*   has been initialied.  If it has not, the following Keys are updated:
*        Status
*        Config
*        ServiceProviders
*
*   The values for the ServiceProviders key is supplied in the regdefs.h
*   header file.
*
* Parameters:
*   none
*
* Returns:
*   TRUE if able to open registry keys with write access.
*/
BOOL InitializeRegistry() {
    BOOL ret_val = FALSE;
    HKEY key;

    TCHAR szKeyName[MAX_PATH] = _T("");

  // Initialize UPS Service registry keys 
  InitializeServiceKeys();

  // Check to see if the registry is already initialized
  if (isRegistryInitialized() == FALSE) {
    CheckForUpgrade();
    InitializeServiceProviders();
    InitializeConfigValues();
    InitializeStatusValues();
  }

    /*
     * Remove "(None)" and "Generic" Service Provider keys if they exist
     * This fixes a localization bug introduced in RC2
     */
  _tcscpy(szKeyName, UPS_SERVICE_ROOT);
  _tcscat(szKeyName, DEFAULT_CONFIG_VENDOR_OLD);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);
  _tcscpy(szKeyName, UPS_SERVICE_ROOT);
  _tcscat(szKeyName, UPGRADE_CONFIG_VENDOR_OLD);
  RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName);

  // ...and check if we have write access
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                   UPS_DEFAULT_ROOT,
                   0,
                   KEY_WRITE,
                   &key) == ERROR_SUCCESS )
  {
    RegCloseKey(key);
    ret_val = TRUE;
  }

  return ret_val;
}


/**
* isRegistryInitialized
*
* Description:
*   This function determines if the registry has been initialized for
*   the UPS service.  This is done by examine the registry key specified
*   by the identifier UPS_SERVICE_INITIALIED_KEY.  If the key is present,
*   the registry is assumed to be initialized and TRUE is returned.  
*   Otherwise, FALSE is returned.
*
* Parameters:
*   none
*
* Returns:
*   TRUE  - if the registry has been initialized for the UPS service
*   FALSE - otherwise
*/
static BOOL isRegistryInitialized() {
BOOL ret_val = FALSE;
HKEY key;

if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, UPS_SERVICE_INITIALIZED_KEY,
  0, KEY_QUERY_VALUE, &key) == ERROR_SUCCESS) {
  ret_val = TRUE;

  RegCloseKey(key);
}
return ret_val;
}

/**
* CheckForUpgrade
*
* Description:
*   This function determines if this installation is an upgrade from
*   the WINNT 4.x UPS service.  This is done by checking to see if the 
*   Config registry key is present.  If it is not present and the Options 
*   key is set to UPS_INSTALLED, then the Upgrade registry key is set to 
*   TRUE.  Otherwise, it is set to FALSE.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void CheckForUpgrade() {
DWORD result;
HKEY key;
DWORD options = 0;

// Create the Config key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_CONFIG_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Check to see if the Config key was present
    if (result != REG_OPENED_EXISTING_KEY) {
      // Config key was not found
      InitUPSConfigBlock();

      // Check the port value
      if (ERROR_SUCCESS != GetUPSConfigOptions(&options)) {
        // Options key is not found
        SetUPSConfigUpgrade(FALSE);
      }
      else if (options & UPS_INSTALLED) {
        // The Options key is present and UPS_INSTALLED is set
        // This is an upgrade
        SetUPSConfigUpgrade(TRUE);
      }
      else {
        // The Config key is present and UPS_INSTALLED is not set
        SetUPSConfigUpgrade(FALSE);
      }
    }
    else {
      // Config key does not exist
      SetUPSConfigUpgrade(FALSE);
    }

    // Write the Config values, force a save of all values
    SaveUPSConfigBlock(TRUE);

    // Free the Config block
    FreeUPSConfigBlock();
}
}

/**
* InitializeServiceKeys
*
* Description:
*   This function initializes the UPS service registry keys to
*   default values, if the values are not present.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeServiceKeys() {
  TCHAR tmpString[MAX_PATH];
  DWORD tmpDword;

  // Initialize the registry functions
  InitUPSConfigBlock();
  
  // Check the service keys and initialize any missing keys
  if (GetUPSConfigImagePath(tmpString) != ERROR_SUCCESS) {
    SetUPSConfigImagePath(DEFAULT_CONFIG_IMAGEPATH);
  }

  if (GetUPSConfigObjectName(tmpString) != ERROR_SUCCESS) {
    SetUPSConfigObjectName(DEFAULT_CONFIG_OBJECTNAME);
  }

  if (GetUPSConfigErrorControl(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigErrorControl(DEFAULT_CONFIG_ERRORCONTROL);
  }

  if (GetUPSConfigStart(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigStart(DEFAULT_CONFIG_START);
  }

  if (GetUPSConfigType(&tmpDword) != ERROR_SUCCESS) {
    SetUPSConfigType(DEFAULT_CONFIG_TYPE);
  }

  // Write the Config values, force a save of all values
  SaveUPSConfigBlock(TRUE);
  
  // Free the Status block
  FreeUPSConfigBlock();
}

/**
* InitializeServiceProviders
*
* Description:
*   This function initializes the ServiceProviders registry keys with the
*   data provided in the global structure _theStaticProvidersTable.  This
*   structure is defined in the file regdefs.h and is automatically 
*   generated.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeServiceProviders() {
DWORD result;
HKEY key;

int index = 0;

// Loop through the list of Service Providers
while (_theStaticProvidersTable[index].theModelName != NULL) {
  // Open the vendor registry key
  if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, _theStaticProvidersTable[index].theVendorKey, 
    0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // Set the model value
    RegSetValueEx(key, _theStaticProvidersTable[index].theModelName, 0, REG_SZ, 
      (LPSTR) _theStaticProvidersTable[index].theValue, 
      wcslen(_theStaticProvidersTable[index].theValue)*sizeof(TCHAR));

    RegCloseKey(key);
  }

  // Increment counter
  index++;
}
}

/**
* InitializeConfigValues
*
* Description:
*   This function initializes the Config registry keys with
*   default values.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeConfigValues() {
DWORD result;
HKEY  key;
DWORD options_val, batt_life, type; 
DWORD batt_life_size = sizeof(DWORD);

// Create the Config key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_CONFIG_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Initialize the registry functions
    InitUPSConfigBlock();

    // Set default values
    SetUPSConfigServiceDLL(DEFAULT_CONFIG_PROVIDER_DLL);
    SetUPSConfigNotifyEnable(DEFAULT_CONFIG_NOTIFY_ENABLE);
    SetUPSConfigShutdownOnBatteryEnable(DEFAULT_CONFIG_SHUTDOWN_ONBATT_ENABLE);
    SetUPSConfigShutdownOnBatteryWait(DEFAULT_CONFIG_SHUTDOWN_ONBATT_WAIT);
    SetUPSConfigRunTaskEnable(DEFAULT_CONFIG_RUNTASK_ENABLE);
    SetUPSConfigTaskName(DEFAULT_CONFIG_TASK_NAME);
    SetUPSConfigTurnOffEnable(DEFAULT_CONFIG_TURNOFF_UPS_ENABLE);
    SetUPSConfigCustomOptions(DEFAULT_CONFIG_CUSTOM_OPTIONS);
    SetUPSConfigCriticalPowerAction(DEFAULT_CONFIG_CRITICALPOWERACTION);
    SetUPSConfigTurnOffWait(DEFAULT_CONFIG_TURNOFF_UPS_WAIT);

    // If this is not an upgrade, set the appropriate values
    if ((GetUPSConfigUpgrade(&result) != ERROR_SUCCESS) || (result == FALSE)) {
      SetUPSConfigVendor(DEFAULT_CONFIG_VENDOR);
      SetUPSConfigModel(DEFAULT_CONFIG_MODEL);
      SetUPSConfigPort(DEFAULT_CONFIG_PORT);
      SetUPSConfigOptions(DEFAULT_CONFIG_OPTIONS);
      SetUPSConfigFirstMessageDelay(DEFAULT_CONFIG_FIRSTMSG_DELAY);
      SetUPSConfigMessageInterval(DEFAULT_CONFIG_MESSAGE_INTERVAL);
    }
    else {
      // This is an upgrade
      SetUPSConfigVendor(UPGRADE_CONFIG_VENDOR);
      SetUPSConfigModel(UPGRADE_CONFIG_MODEL);

      // Migrate the run command file option bit to the RunTaskEnable key
      if ((GetUPSConfigOptions(&options_val) == ERROR_SUCCESS) && 
        (options_val & UPS_RUNCMDFILE)) {
        // Run command file is enabled, set RunTaskEnable to TRUE
        SetUPSConfigRunTaskEnable(TRUE);
      }
      else {
        // Run command file is not enabled
        SetUPSConfigRunTaskEnable(FALSE);
      }

      // Migrate the BatteryLife value to the ShutdownOnBatteryWait value
      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, UPS_DEFAULT_ROOT, 0, KEY_ALL_ACCESS, &key) == ERROR_SUCCESS) {

        result = RegQueryValueEx(key, UPS_BATTLIFE_KEY, NULL, &type, (LPBYTE) &batt_life,  &batt_life_size);

        if ((result == ERROR_SUCCESS) && (type == REG_DWORD)) {

          // Migrate the value and enable shutdown on battery
          SetUPSConfigShutdownOnBatteryWait(batt_life);
		  SetUPSConfigShutdownOnBatteryEnable(TRUE);

          // Delete the value
          RegDeleteValue(key, UPS_BATTLIFE_KEY);
        }

        // Close the key
        RegCloseKey(key);
      }
    }

    // Write the Config values, force a save of all values
    SaveUPSConfigBlock(TRUE);

    // Free the Config block
    FreeUPSConfigBlock();
  }
}

/**
* InitializeStatusValues
*
* Description:
*   This function initializes the Status registry keys with 
*   default values.
*
* Parameters:
*   none
*
* Returns:
*   nothing
*/
static void InitializeStatusValues() {
DWORD result;
HKEY key;

// Create the Status key
if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, UPS_STATUS_ROOT, 0, NULL, 
    REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &key, &result) == ERROR_SUCCESS) {

    // close the key, we only needed to create it
    RegCloseKey(key);

    // Initialize the registry functions
    InitUPSStatusBlock();

    // Put in default values
    SetUPSStatusSerialNum(DEFAULT_STATUS_SERIALNO);
    SetUPSStatusFirmRev(DEFAULT_STATUS_FIRMWARE_REV);
    SetUPSStatusUtilityStatus(DEFAULT_STATUS_UTILITY_STAT);
    SetUPSStatusRuntime(DEFAULT_STATUS_TOTAL_RUNTIME);
    SetUPSStatusBatteryStatus(DEFAULT_STATUS_BATTERY_STAT);
	SetUPSStatusBatteryCapacity(DEFAULT_STATUS_BATTERY_CAPACITY);

    // Write the Config values, force a save of all values
    SaveUPSStatusBlock(TRUE);

    // Free the Status block
    FreeUPSStatusBlock();
  }
}



///////////////////////////////////////////////////////////////////////////////
// upsdata.c
///////////////////////////////////////////////////////////////////////////////

//Note that the order of the following RegField is linked to the enum
//tUPSDataItemID.
//Do not change these value without due care and attention. It's OK to change
//them as long as the enum is updated to match.

//To access the RegField associated with Firmware, for example, use
//g_upsRegFields[(DWORD) eREG_FIRMWARE_REVISION]

static RegField g_upsRegFields[] = {
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Vendor"),                  REG_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Model"),                   REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("SerialNumber"),            REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("FirmwareRev"),             REG_SZ },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("UtilityPowerStatus"),      REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("TotalUPSRuntime"),         REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("BatteryCapacity"),         REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("BatteryStatus"),           REG_DWORD },
    { HKEY_LOCAL_MACHINE, UPS_KEY_NAME,    TEXT("Options"),                 REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ServiceProviderDLL"),      REG_EXPAND_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ShutdownOnBatteryEnable"), REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("ShutdownOnBatteryWait"),   REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("TurnUPSOffEnable"),        REG_DWORD },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("APCLinkURL"),              REG_SZ },
    { HKEY_LOCAL_MACHINE, CONFIG_KEY_NAME, TEXT("Upgrade"),                 REG_DWORD },
    { HKEY_LOCAL_MACHINE, STATUS_KEY_NAME, TEXT("CommStatus"),              REG_DWORD },
    { HKEY_LOCAL_MACHINE, UPS_KEY_NAME,    TEXT("Port"),                    REG_SZ } };

// functions
///////////////////////////////////////////////////////////////////////////////

DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID,
                         DWORD aAllowedTypes,
                         DWORD * aTypePtr,
                         LPBYTE aReturnBuffer,
                         DWORD * aBufferSizePtr);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// RegField * GetRegField (DWORD aIndex);
//
// Description: This function returns a pointer to a RegField from the
//              static array of RegFields named g_upsRegFields. The parameter
//              aIndex is an index into this array.
//
// Additional Information: 
//
// Parameters:
//
//   DWORD aIndex :- A index into array of known RegFields g_upsRegFields
//
// Return Value: If aIndex is within range this function returns a point to
//               the corresponding RegField, otherwise it ASSERTs and returns
//               NULL.
//
RegField * GetRegField (DWORD aIndex) {
  static const DWORD numRegFields = DIMENSION_OF(g_upsRegFields);
  RegField * pRequiredReg = NULL;

  if (aIndex < numRegFields) {
    pRequiredReg = &g_upsRegFields[aIndex];
    }
  else {
    _ASSERT(FALSE);
    }

  return(pRequiredReg);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL GetUPSDataItemDWORD (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr);
//
// Description: This function reads the DWORD value from the registry that
//              corresponds to the registry field identified by aDataItemID.
//              The registry value must be one of the DWORD types (REG_DWORD,
//              REG_DWORD_LITTLE_ENDIAN, REG_DWORD_BIG_ENDIAN)
//
//              For example, if aDataItemID is eREG_UPS_OPTIONS (=7), the
//              RegField at index 7 in g_upsRegFields identifies the required
//              registry information. The RegField identifies that the registry
//              key is HKLM\SYSTEM\CurrentControlSet\Services\UPS and the
//              value name is Options and it's of type DWORD. Using this
//              information this function gets the information from the
//              registry and puts the result in aReturnValuePtr.
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried. The value ranges
//                                       from eREG_VENDOR_NAME (which equals 0)
//                                       to eREG_PORT, the values incrementing
//                                       by 1 for each enum in the range. The
//                                       range of values in tUPSDataItemID
//                                       corresponds directly to the number of
//                                       elements in the array g_upsRegFields
//                                       because this enum is used to index the
//                                       elements in g_upsRegFields.
//
//   DWORD * aReturnValuePtr :- The DWORD value is returned through this
//                              pointer.
//
// Return Value: 
//
BOOL GetUPSDataItemDWORD (const tUPSDataItemID aDataItemID, DWORD * aReturnValuePtr) {
  BOOL bGotValue = FALSE;
  DWORD nDWORDSize = sizeof(DWORD);

  if (ReadRegistryValue(aDataItemID, REG_DWORD, NULL, (LPBYTE) aReturnValuePtr, &nDWORDSize) == ERROR_SUCCESS) {
    bGotValue = TRUE;
    }

  return(bGotValue);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID, 
//                            LPTSTR aBufferPtr, 
//                            DWORD * pSizeOfBufferPtr);
//
// Description: This function reads the string value from the registry that
//              corresponds to the registry field identified by aDataItemID.
//              The registry value must be one of the string types (REG_SZ or
//              REG_EXPAND_SZ)
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried. The value must be
//                                       one of the string types (REG_SZ or
//                                       REG_EXPAND_SZ).
//
//   LPTSTR aBufferPtr :- The buffer into which the data is to be placed. This
//                        parameter can be NULL in which case no data is
//                        retrieved.
//
//   DWORD * pSizeOfBufferPtr :- This should point to a DWORD that contains the
//                               size of the buffer. This parameter cannot be
//                               NULL. When this function returns this value
//                               will contain the size actually required. This
//                               is useful if the user want to determine how
//                               big a buffer is required by calling this
//                               function with aBufferPtr set to NULL and
//                               pSizeOfBufferPtr pointing to a DWORD that
//                               is set to 0. When the function returns the
//                               DWORD pointed to by pSizeOfBufferPtr should
//                               contain the size of string required. This can
//                               then be used to dynamically allocate memory
//                               and call this function again with the buffer
//                               included this time.
//
// Return Value: The function returns TRUE if successful, FALSE otherwise.
//
BOOL GetUPSDataItemString (const tUPSDataItemID aDataItemID,
                           LPTSTR aBufferPtr,
                           DWORD * pSizeOfBufferPtr) {
  BOOL bGotValue = FALSE;
  DWORD nType = 0;

  if (ReadRegistryValue(aDataItemID,
                        REG_SZ | REG_EXPAND_SZ,
                        &nType,
                        (LPBYTE) aBufferPtr,
                        pSizeOfBufferPtr) == ERROR_SUCCESS) {
    //RegQueryValueEx stores the size of the data, in bytes, in the variable
    //pointed to by lpcbData. If the data has the REG_SZ, REG_MULTI_SZ or
    //REG_EXPAND_SZ type, then lpcbData will also include the size of the
    //terminating null character.
    //For Unicode the terminating NULL character is two-bytes.
    if ((pSizeOfBufferPtr != NULL) && (*pSizeOfBufferPtr > sizeof(TCHAR))) {
      if (nType == REG_EXPAND_SZ) {
        TCHAR expandBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
        DWORD expandBufferSize = DIMENSION_OF(expandBuffer);

        //ExpandEnvironmentStrings return number of bytes(ANSI) or
        //number of character(UNICODE) including the NULL character
        if (ExpandEnvironmentStrings(aBufferPtr, expandBuffer, expandBufferSize) > 0) {
          _tcscpy(aBufferPtr, expandBuffer);
          }
        }

      bGotValue = TRUE;
      }
    }

  return(bGotValue);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID, 
//                          DWORD aAllowedTypes, 
//                          DWORD * aTypePtr, 
//                          LPBYTE aReturnBuffer, 
//                          DWORD * aBufferSizePtr);
//
// Description: This function reads the registry value identified by
//              aDataItemID. This function can read any type of registry value
//              but the value must match that identified in the RegField
//              description for this field.
//              
//              For example, if aDataItemID is eREG_UPS_OPTIONS (=7), the
//              RegField at index 7 in g_upsRegFields identifies the required
//              registry information. The RegField identifies that the registry
//              key is HKLM\SYSTEM\CurrentControlSet\Services\UPS and the
//              value name is Options and it's of type DWORD. This function
//              will succeed only if it's called with an aAllowedTypes value
//              equal to REG_DWORD.
//
// Additional Information: 
//
// Parameters:
//
//   const tUPSDataItemID aDataItemID :- This parameter identifies the registry
//                                       value being queried.
//
//   DWORD aAllowedTypes :- This identifies the allowed type of the registry
//                          data. The registry value types are not bit value
//                          that can be |'d (the types are sequentially
//                          numbered 0, 1, 2, 3, 4, not 0, 1, 2, 4, 8).
//                          However, the parameter is still called
//                          aAllowedTypes because we actually call the function
//                          with a value of REG_SZ | REG_EXPAND_SZ (1 | 2) to
//                          allow the same function to work if the value is
//                          either of these. Except for this case assume that
//                          the aAllowedTypes is actually aAllowedType.
//
//   DWORD * aTypePtr :- A pointer to the buffer that will receive the type.
//                       If the type is not required then this parameter can be
//                       set to NULL.
//
//   LPBYTE aReturnBuffer :- The buffer into which the data is to be placed.
//                           This parameter can be NULL in which case no data
//                           is retrieved.
//
//   DWORD * aBufferSizePtr :- This should point to a DWORD that contains the
//                             size of the buffer. This parameter cannot be
//                             NULL. When this function returns this value
//                             will contain the size actually required.
//
// Return Value: This function returns a Win32 error code, ERROS_SUCCESS on
//               success.
//
DWORD ReadRegistryValue (const tUPSDataItemID aDataItemID,
                         DWORD aAllowedTypes,
                         DWORD * aTypePtr,
                         LPBYTE aReturnBuffer,
                         DWORD * aBufferSizePtr) {
  RegField * pRegField = GetRegField((DWORD) aDataItemID);

  _ASSERT(pRegField != NULL);
  _ASSERT((pRegField->theValueType & aAllowedTypes) == pRegField->theValueType);

  return(ReadRegistryValueData(pRegField->theRootKey,
                               pRegField->theKeyName,
                               pRegField->theValueName,
                               aAllowedTypes,
                               aTypePtr,
                               (LPTSTR) aReturnBuffer,
                               aBufferSizePtr));
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD ReadRegistryValueData (HKEY aRootKey, 
//                              LPCTSTR aKeyName, 
//                              LPCTSTR aValueName, 
//                              DWORD aAllowedTypes, 
//                              DWORD * aTypePtr, 
//                              LPTSTR aReturnBuffer, 
//                              DWORD * aBufferSizePtr);
//
// Description: 
//
// Additional Information: 
//
// Parameters:
//
//   HKEY aRootKey :- A handle to an open registry key.
//
//   LPCTSTR aKeyName :- The name of the key relative to the open key.
//
//   LPCTSTR aValueName :- The name of the value to read
//
//   DWORD aAllowedTypes :- See help on ReadRegistryValue.
//
//   DWORD * aTypePtr :- A pointer to the buffer that will receive the type.
//                       If the type is not required then this parameter can be
//                       set to NULL.
//
//   LPBYTE aReturnBuffer :- The buffer into which the data is to be placed.
//                           This parameter can be NULL in which case no data
//                           is retrieved.
//
//   DWORD * aBufferSizePtr :- This should point to a DWORD that contains the
//                             size of the buffer. This parameter cannot be
//                             NULL. When this function returns this value
//                             will contain the size actually required.
//
// Return Value: This function returns a Win32 error code, ERROS_SUCCESS on
//               success.
//
DWORD ReadRegistryValueData (HKEY aRootKey,
                             LPCTSTR aKeyName,
                             LPCTSTR aValueName,
                             DWORD aAllowedTypes,
                             DWORD * aTypePtr,
                             LPTSTR aReturnBuffer,
                             DWORD * aBufferSizePtr) {
  DWORD nType = 0;
  DWORD errCode = ERROR_INVALID_PARAMETER;
  HKEY hOpenKey = NULL;

  if ((errCode = RegOpenKeyEx(aRootKey,
                              aKeyName,
                              0,
                              KEY_READ,
                              &hOpenKey)) == ERROR_SUCCESS) {

    _ASSERT(hOpenKey != NULL);

    //Key exists and is now open

    if ((errCode = RegQueryValueEx(hOpenKey,
                                   aValueName,
                                   NULL,
                                   &nType,
                                   (LPBYTE) aReturnBuffer,
                                   aBufferSizePtr)) == ERROR_SUCCESS) {
      if (aTypePtr != NULL) {
        *aTypePtr = nType;
        }

      if ((nType & aAllowedTypes) == 0) {
        //The value type in the registry does not match the expected
        //type for this function call.
        _ASSERT(FALSE);
        }

      if ((aReturnBuffer != NULL) && (*aBufferSizePtr == 1)) {
        //If the registry entry was in fact empty, the buffer needs to
        //be 1 character, for the NULL termination.
        *aReturnBuffer = TEXT('\0');
        }
      }
    else {
      //Something prevented us from reading the value.
      //The value may not exist, the buffer size might
      //not be large enough. May be using the function to
      //read a DWORD value on a registry value that is a
      //shorter string.

      if (errCode == ERROR_MORE_DATA) {
        //There is most likely a mismatch between the type we expect
        //and the actual type of this registry value.
        _ASSERT(FALSE);
        }
      }

    RegCloseKey(hOpenKey);
    }

  return(errCode);
  }



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upsselect.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSSELECT.H
*
*  VERSION:     1.0
*
*  AUTHOR:      SteveT
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION:
*******************************************************************************/


#ifndef _UPS_SELECT_H_
#define _UPS_SELECT_H_


#ifdef __cplusplus
extern "C" {
#endif

/*
 * this structure is used to pass data between the Select
 * dialog and the Custom dialog.
 */
struct _customData {
	LPTSTR lpszCurrentPort;
	LPDWORD lpdwCurrentCustomOptions;
};


/*
 * BOOL CALLBACK UPSSelectDlgProc (HWND hDlg,
 *                                UINT uMsg,
 *                                WPARAM wParam,
 *                                LPARAM lParam);
 *
 * Description: This is a standard DialogProc associated with the UPS select dialog
 *
 * Additional Information: See help on DialogProc
 *
 * Parameters:
 *
 *   HWND hDlg :- Handle to dialog box
 *
 *   UINT uMsg :- message ID
 *
 *   WPARAM wParam :- Specifies additional message-specific information.
 *
 *   LPARAM lParam :- Specifies additional message-specific information.
 *
 * Return Value: Except in response to the WM_INITDIALOG message, the dialog
 *               box procedure should return nonzero if it processes the
 *               message, and zero if it does not.
 */
INT_PTR CALLBACK UPSSelectDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}
#endif

#endif // _UPS_SELECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\debug.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DEBUG.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        21 Jan, 1997
*
*  DESCRIPTION:
*
*   Private debug routines implemented here.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntpoapi.h>
#include <stdio.h>
#include <powrprofp.h>

#ifdef DEBUG

LPTSTR lpszDebugPwrState[] = {
    TEXT("PwrSysUnspecified"),
    TEXT("S0, PwrSysWorking"),
    TEXT("S1, PwrSysSleeping1"),
    TEXT("S2, PwrSysSleeping2"),
    TEXT("S3, PwrSysSleeping3"),
    TEXT("S4, PwrSysHibernate"),
    TEXT("S5, PwrSysShutdown"),
    TEXT("PwrSysMaximum")
};

LPTSTR lpszDebugPwrAction[] = {
    TEXT("PwrActionNone"),
    TEXT("PwrActionDoze"),
    TEXT("PwrActionSleep"),
    TEXT("PwrActionHibernate"),
    TEXT("PwrActionShutdown"),
    TEXT("PwrActionShutdownReset"),
    TEXT("PwrActionShutdownOff")
};

extern int g_iShowValidationChanges;

#endif

/*******************************************************************************
*
*  DebugPrintA
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
void CDECL DebugPrintA(LPCSTR pszFmt, ...)
{
   char szDebug[MAX_PATH];

   va_list  arglist;

   va_start(arglist, pszFmt);
   wvsprintfA(szDebug, pszFmt, arglist);
   OutputDebugStringA(szDebug);
   OutputDebugStringA("\n");
}

#ifdef DEBUG
/*******************************************************************************
*
*  GetIndent
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
#define MAX_INDENT 32

void GetIndent(LPSTR lpsz, LPSTR lpszIndent)
{
    UINT i;

    for (i = 0; i < MAX_INDENT; i++) {
        if (*lpsz != ' ') {
            break;
        }
        lpsz++;
        *lpszIndent++ = ' ';
    }
    *lpszIndent = '\0';
}

/*******************************************************************************
*
*  DumpPowerActionPolicy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DumpPowerActionPolicy(
    LPSTR                  lpszLabel,
    PPOWER_ACTION_POLICY   ppap
)
{
    char szLabel[MAX_INDENT], szIndent[MAX_INDENT];

    GetIndent(lpszLabel, szIndent);
    DebugPrint("%s, POWER_ACTION_POLICY: %08X", lpszLabel, ppap);
    if (ppap->Action <= PowerActionShutdownOff) {
        DebugPrint("%s  Action:    %08X, %s", szIndent, ppap->Action, lpszDebugPwrAction[ppap->Action]);
    }
    else {
        DebugPrint("%s  Action:    %08X, Invalid!", szIndent, ppap->Action);
    }
    DebugPrint("%s  Flags:     %08X", szIndent, ppap->Flags);
    DebugPrint("%s  EventCode: %08X", szIndent, ppap->EventCode);
}

/*******************************************************************************
*
*  DumpSystemPowerLevel
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DumpSystemPowerLevel(
    LPSTR                  lpszLabel,
    PSYSTEM_POWER_LEVEL     pspl
)
{
    char   szLabel[MAX_INDENT], szIndent[MAX_INDENT];

    GetIndent(lpszLabel, szIndent);
    DebugPrint("%s, SYSTEM_POWER_LEVEL: %08X", lpszLabel, pspl);
    DebugPrint("%s  Enable:         %08X", szIndent, pspl->Enable);
    DebugPrint("%s  BatteryLevel:   %08X", szIndent, pspl->BatteryLevel);
    wsprintfA(szLabel, "%s  PowerPolicy", szIndent);
    DumpPowerActionPolicy(szLabel, &pspl->PowerPolicy);
    if (pspl->MinSystemState <= PowerSystemMaximum) {
        DebugPrint("%s  MinSystemState: %08X, %s", szIndent, pspl->MinSystemState, lpszDebugPwrState[pspl->MinSystemState]);
    }
    else {
        DebugPrint("%s  MinSystemState: %08X, Invalid!!", szIndent, pspl->MinSystemState);
    }
}

/*******************************************************************************
*
*  DumpSystemPowerPolicy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DumpSystemPowerPolicy(
    LPSTR                  lpszLabel,
    PSYSTEM_POWER_POLICY    pspp
)
{
    UINT    i;
    char   szLabel[MAX_INDENT], szIndent[MAX_INDENT];

    GetIndent(lpszLabel, szIndent);
    DebugPrint("%s, SYSTEM_POWER_POLICY: %08X", lpszLabel, pspp);
    DebugPrint("%s  Revision: %08X", szIndent, pspp->Revision);
    wsprintfA(szLabel, "%s  PowerButton", szIndent);
    DumpPowerActionPolicy( szLabel, &pspp->PowerButton);
    wsprintfA(szLabel, "%s  SleepButton", szIndent);
    DumpPowerActionPolicy( szLabel, &pspp->SleepButton);
    wsprintfA(szLabel, "%s  LidClose", szIndent);
    DumpPowerActionPolicy( szLabel,    &pspp->LidClose);
    DebugPrint("%s  LidOpenWake:                   %08X, %s", szIndent, pspp->LidOpenWake, lpszDebugPwrState[pspp->LidOpenWake]);
    wsprintfA(szLabel, "%s  Idle", szIndent);
    DumpPowerActionPolicy( szLabel, &pspp->Idle);
    DebugPrint("%s  IdleTimeout:                   %08X", szIndent, pspp->IdleTimeout);
    DebugPrint("%s  IdleSensitivity:               %08X", szIndent, pspp->IdleSensitivity);
    DebugPrint("%s  MinSleep:                      %08X, %s", szIndent, pspp->MinSleep, lpszDebugPwrState[pspp->MinSleep]);
    DebugPrint("%s  MaxSleep:                      %08X, %s", szIndent, pspp->MaxSleep, lpszDebugPwrState[pspp->MaxSleep]);
    DebugPrint("%s  ReducedLatencySleep:           %08X, %s", szIndent, pspp->ReducedLatencySleep, lpszDebugPwrState[pspp->ReducedLatencySleep]);
    DebugPrint("%s  WinLogonFlags:                 %08X", szIndent, pspp->WinLogonFlags);
    DebugPrint("%s  DozeS4Timeout:                 %08X", szIndent, pspp->DozeS4Timeout);
    DebugPrint("%s  BroadcastCapacityResolution:   %08X", szIndent, pspp->BroadcastCapacityResolution);
    for (i = 0; i < NUM_DISCHARGE_POLICIES; i++) {
        wsprintfA(szLabel, "%s  DischargePolicy[%d]", szIndent, i);
        DumpSystemPowerLevel( szLabel, &pspp->DischargePolicy[i]);
    }
    DebugPrint("%s  VideoTimeout:                  %08X", szIndent, pspp->VideoTimeout);
    DebugPrint("%s  VideoDimDisplay:               %08X", szIndent, pspp->VideoDimDisplay);
    DebugPrint("%s  SpindownTimeout:               %08X", szIndent, pspp->SpindownTimeout);
    DebugPrint("%s  OptimizeForPower:              %08X", szIndent, pspp->OptimizeForPower);
    DebugPrint("%s  FanThrottleTolerance:          %08X", szIndent, pspp->FanThrottleTolerance);
    DebugPrint("%s  ForcedThrottle:                %08X", szIndent, pspp->ForcedThrottle);
    DebugPrint("%s  MinThrottle:                   %08X", szIndent, pspp->MinThrottle);
    wsprintfA(szLabel, "%s  OverThrottled", szIndent);
    DumpPowerActionPolicy( szLabel, &pspp->OverThrottled);
    DebugPrint("\n\n");
}

/*******************************************************************************
*
*  DumpSystemPowerCapabilities
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DumpSystemPowerCapabilities(
    LPSTR                      lpszLabel,
    PSYSTEM_POWER_CAPABILITIES  pspc
)
{
    UINT    i;
    char   szLabel[MAX_INDENT], szIndent[MAX_INDENT];

    GetIndent(lpszLabel, szIndent);
    DebugPrint("%s, SYSTEM_POWER_CAPABILITIES: %08X", lpszLabel, pspc);
    DebugPrint("%s  PowerButtonPresent:           %08X", szIndent, pspc->PowerButtonPresent);
    DebugPrint("%s  SleepButtonPresent:           %08X", szIndent, pspc->SleepButtonPresent);
    DebugPrint("%s  LidPresent:                   %08X", szIndent, pspc->LidPresent);
    DebugPrint("%s  SystemS1:                     %08X", szIndent, pspc->SystemS1);
    DebugPrint("%s  SystemS2:                     %08X", szIndent, pspc->SystemS2);
    DebugPrint("%s  SystemS3:                     %08X", szIndent, pspc->SystemS3);
    DebugPrint("%s  SystemS4:                     %08X", szIndent, pspc->SystemS4);
    DebugPrint("%s  SystemS5:                     %08X", szIndent, pspc->SystemS5);
    DebugPrint("%s  HiberFilePresent:             %08X", szIndent, pspc->HiberFilePresent);
    DebugPrint("%s  ThermalControl:               %08X", szIndent, pspc->ThermalControl);
    DebugPrint("%s  ProcessorThrottle:            %08X", szIndent, pspc->ProcessorThrottle);
    DebugPrint("%s  ProcessorMinThrottle:             %02X", szIndent, pspc->ProcessorMinThrottle);
    DebugPrint("%s  ProcessorMaxThrottle:             %02X", szIndent, pspc->ProcessorMaxThrottle);
    DebugPrint("%s  VideoDimPresent:              %08X", szIndent, pspc->VideoDimPresent);
    DebugPrint("%s  DiskSpinDown:                 %08X", szIndent, pspc->DiskSpinDown);
    DebugPrint("%s  SystemBatteriesPresent:       %08X", szIndent, pspc->SystemBatteriesPresent);
    DebugPrint("%s  BatteriesAreShortTerm:        %08X", szIndent, pspc->BatteriesAreShortTerm);

    // Not implemented:   BATTERY_REPORTING_SCALE BatteryScale[3];

    DebugPrint("%s  AcOnLineWake:                 %08X, %s", szIndent, pspc->AcOnLineWake, lpszDebugPwrState[pspc->AcOnLineWake]);
    DebugPrint("%s  SoftLidWake:                  %08X, %s", szIndent, pspc->SoftLidWake, lpszDebugPwrState[pspc->SoftLidWake]);
    DebugPrint("%s  RtcWake:                      %08X, %s", szIndent, pspc->RtcWake, lpszDebugPwrState[pspc->RtcWake]);
    DebugPrint("%s  MinDeviceWakeState:           %08X, %s", szIndent, pspc->MinDeviceWakeState, lpszDebugPwrState[pspc->MinDeviceWakeState]);
    DebugPrint("%s  DefaultLowLatencyWake:        %08X, %s", szIndent, pspc->DefaultLowLatencyWake, lpszDebugPwrState[pspc->DefaultLowLatencyWake]);
    DebugPrint("\n\n");
}

/*******************************************************************************
*
*  DifSystemPowerPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DifSystemPowerPolicies(
    LPSTR               lpszLabel,
    PSYSTEM_POWER_POLICY pspp1,
    PSYSTEM_POWER_POLICY pspp2
)
{
    UINT    i;
    char   szLabel[MAX_INDENT], szIndent[MAX_INDENT];

    if (!g_iShowValidationChanges) {
        return;
    }

    if (memcmp(pspp1, pspp2, sizeof(SYSTEM_POWER_POLICY))) {

        GetIndent(lpszLabel, szIndent);
        DebugPrint("%s, spp1: %08X, spp2: %08X", lpszLabel, pspp1, pspp2);
        if (pspp1->Revision != pspp2->Revision) {
            DebugPrint("%s  Revision, spp1: %08X, spp2: %08X", szIndent, pspp1->Revision, pspp2->Revision);
        }
        if (memcmp(&pspp1->PowerButton, &pspp2->PowerButton, sizeof(POWER_ACTION_POLICY))) {
            wsprintfA(szLabel, "%s  spp1, PowerButton", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp1->PowerButton);
            wsprintfA(szLabel, "%s  spp2, PowerButton", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp2->PowerButton);
        }
        if (memcmp(&pspp1->SleepButton, &pspp2->SleepButton, sizeof(POWER_ACTION_POLICY))) {
            wsprintfA(szLabel, "%s  spp1, SleepButton", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp1->SleepButton);
            wsprintfA(szLabel, "%s  spp2, SleepButton", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp2->SleepButton);
        }
        if (memcmp(&pspp1->LidClose, &pspp2->LidClose, sizeof(POWER_ACTION_POLICY))) {
            wsprintfA(szLabel, "%s  spp1, LidClose", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp1->LidClose);
            wsprintfA(szLabel, "%s  spp2, LidClose:", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp2->LidClose);
        }
        if (pspp1->LidOpenWake != pspp2->LidOpenWake) {
            DebugPrint("%s  spp1, LidOpenWake: %08X, %s", szIndent, pspp1->LidOpenWake, lpszDebugPwrState[pspp1->LidOpenWake]);
            DebugPrint("%s  spp2, LidOpenWake: %08X, %s", szIndent, pspp2->LidOpenWake, lpszDebugPwrState[pspp2->LidOpenWake]);
        }
        if (memcmp(&pspp1->Idle, &pspp2->Idle, sizeof(POWER_ACTION_POLICY))) {
            wsprintfA(szLabel, "%s  spp1, Idle", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp1->Idle);
            wsprintfA(szLabel, "%s  spp2, Idle", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp2->Idle);
        }
        if (pspp1->IdleTimeout != pspp2->IdleTimeout) {
            DebugPrint("%s  IdleTimeout, spp1: %08X, spp2: %08X", szIndent, pspp1->IdleTimeout, pspp2->IdleTimeout);
        }
        if (pspp1->IdleSensitivity != pspp2->IdleSensitivity) {
            DebugPrint("%s  IdleSensitivity, spp1: %08X, spp2: %08X", szIndent, pspp1->IdleSensitivity, pspp2->IdleSensitivity);
        }
        if (pspp1->MinSleep != pspp2->MinSleep) {
            DebugPrint("%s  MinSleep, spp1: %08X, %s", szIndent, pspp1->MinSleep, lpszDebugPwrState[pspp1->MinSleep]);
            DebugPrint("%s  MinSleep, spp2: %08X, %s", szIndent, pspp2->MinSleep, lpszDebugPwrState[pspp2->MinSleep]);
        }
        if (pspp1->MaxSleep != pspp2->MaxSleep) {
            DebugPrint("%s  MaxSleep, spp1: %08X, %s", szIndent, pspp1->MaxSleep, lpszDebugPwrState[pspp1->MaxSleep]);
            DebugPrint("%s  MaxSleep, spp2: %08X, %s", szIndent, pspp2->MaxSleep, lpszDebugPwrState[pspp2->MaxSleep]);
        }
        if (pspp1->ReducedLatencySleep != pspp2->ReducedLatencySleep) {
            DebugPrint("%s  ReducedLatencySleep, spp1: %08X, %s", szIndent, pspp1->ReducedLatencySleep, lpszDebugPwrState[pspp1->ReducedLatencySleep]);
            DebugPrint("%s  ReducedLatencySleep, spp2: %08X, %s", szIndent, pspp2->ReducedLatencySleep, lpszDebugPwrState[pspp2->ReducedLatencySleep]);
        }
        if (pspp1->WinLogonFlags != pspp2->WinLogonFlags) {
            DebugPrint("%s  WinLogonFlags, spp1: %08X, spp2: %08X", szIndent, pspp1->WinLogonFlags, pspp2->WinLogonFlags);
        }
        if (pspp1->DozeS4Timeout != pspp2->DozeS4Timeout) {
            DebugPrint("%s  DozeS4Timeout, spp1: %08X, spp2: %08X", szIndent, pspp1->DozeS4Timeout, pspp2->DozeS4Timeout);
        }
        if (pspp1->BroadcastCapacityResolution != pspp2->BroadcastCapacityResolution) {
            DebugPrint("%s  BroadcastCapacityResolution, spp1: %08X, spp2: %08X", szIndent, pspp1->BroadcastCapacityResolution, pspp2->BroadcastCapacityResolution);
        }
        for (i = 0; i < NUM_DISCHARGE_POLICIES; i++) {
            if (memcmp(&(pspp1->DischargePolicy[i]), &(pspp2->DischargePolicy[i]), sizeof(SYSTEM_POWER_LEVEL))) {
                wsprintfA(szLabel, "%s  DischargePolicy[%d], spp1:", szIndent, i);
                DumpSystemPowerLevel( szLabel, &pspp1->DischargePolicy[i]);
                wsprintfA(szLabel, "%s  DischargePolicy[%d], spp2:", szIndent, i);
                DumpSystemPowerLevel( szLabel, &pspp2->DischargePolicy[i]);
            }
        }
        if (pspp1->VideoTimeout != pspp2->VideoTimeout) {
            DebugPrint("%s  VideoTimeout, spp1: %08X, spp2: %08X", szIndent, pspp1->VideoTimeout, pspp2->VideoTimeout);
        }
        if (pspp1->VideoDimDisplay != pspp2->VideoDimDisplay) {
            DebugPrint("%s  VideoDimDisplay, spp1: %08X, spp2: %08X", szIndent, pspp1->VideoDimDisplay, pspp2->VideoDimDisplay);
        }
        if (pspp1->SpindownTimeout != pspp2->SpindownTimeout) {
            DebugPrint("%s  SpindownTimeout, spp1: %08X, spp2: %08X", szIndent, pspp1->SpindownTimeout, pspp2->SpindownTimeout);
        }
        if (pspp1->OptimizeForPower != pspp2->OptimizeForPower) {
            DebugPrint("%s  OptimizeForPower, spp1: %08X, spp2: %08X", szIndent, pspp1->OptimizeForPower, pspp2->OptimizeForPower);
        }
        if (pspp1->FanThrottleTolerance != pspp2->FanThrottleTolerance) {
            DebugPrint("%s  FanThrottleTolerance, spp1: %08X, spp2: %08X", szIndent, pspp1->FanThrottleTolerance, pspp2->FanThrottleTolerance);
        }
        if (pspp1->ForcedThrottle != pspp2->ForcedThrottle) {
            DebugPrint("%s  ForcedThrottle, spp1: %08X, spp2: %08X", szIndent, pspp1->ForcedThrottle, pspp2->ForcedThrottle);
        }
        if (pspp1->MinThrottle != pspp2->MinThrottle) {
            DebugPrint("%s  MinThrottle, spp1: %08X, spp2: %08X", szIndent, pspp1->MinThrottle, pspp2->MinThrottle);
        }
        if (memcmp(&pspp1->OverThrottled, &pspp2->OverThrottled, sizeof(POWER_ACTION_POLICY))) {
            wsprintfA(szLabel, "%s  spp1, OverThrottled", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp1->OverThrottled);
            wsprintfA(szLabel, "%s  spp2, OverThrottled", szIndent);
            DumpPowerActionPolicy( szLabel, &pspp2->OverThrottled);
        }
        DebugPrint("\n\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\merge.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       MERGE.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Helper for merging/splitting and dumping various power profile structures.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <ntpoapi.h>

#include "powrprofp.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

/*******************************************************************************
*
*  MergeSplitPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN MergePolicies(
    PUSER_POWER_POLICY      pupp,
    PMACHINE_POWER_POLICY   pmpp,
    PPOWER_POLICY           ppp
)
{
    if ((pupp->Revision == CURRENT_REVISION) &&
        (pmpp->Revision == CURRENT_REVISION))
    {
        memcpy(&(ppp->user), pupp, sizeof(USER_POWER_POLICY));
        memcpy(&(ppp->mach), pmpp, sizeof(MACHINE_POWER_POLICY));
        return TRUE;
    }

    SetLastError(ERROR_REVISION_MISMATCH);
    DebugPrint("MergePolicies, failed, LastError: 0x%08X", ERROR_REVISION_MISMATCH);
    return FALSE;
}

/*******************************************************************************
*
*  SplitPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SplitPolicies(
    PPOWER_POLICY           ppp,
    PUSER_POWER_POLICY      pupp,
    PMACHINE_POWER_POLICY   pmpp
)
{
    if ((ppp->user.Revision == CURRENT_REVISION) &&
        (ppp->mach.Revision == CURRENT_REVISION)) {
        memcpy(pupp, &(ppp->user), sizeof(USER_POWER_POLICY));
        memcpy(pmpp, &(ppp->mach), sizeof(MACHINE_POWER_POLICY));
        return TRUE;
    }

    SetLastError(ERROR_REVISION_MISMATCH);
    DebugPrint("SplitPolicies, failed, LastError: 0x%08X", ERROR_REVISION_MISMATCH);
    return FALSE;
}

/*******************************************************************************
*
*  MergeGlobalPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN MergeGlobalPolicies(
    PGLOBAL_USER_POWER_POLICY      pgupp,
    PGLOBAL_MACHINE_POWER_POLICY   pgmpp,
    PGLOBAL_POWER_POLICY           pgpp
)
{
    if ((pgupp->Revision == CURRENT_REVISION) &&
        (pgmpp->Revision == CURRENT_REVISION)) {

        memcpy(&(pgpp->user), pgupp, sizeof(GLOBAL_USER_POWER_POLICY));
        memcpy(&(pgpp->mach), pgmpp, sizeof(GLOBAL_MACHINE_POWER_POLICY));
        return TRUE;
    }

    SetLastError(ERROR_REVISION_MISMATCH);
    DebugPrint("MergeGlobalPolicies, failed, LastError: 0x%08X", ERROR_REVISION_MISMATCH);
    return FALSE;
}

/*******************************************************************************
*
*  SplitGlobalPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SplitGlobalPolicies(
    PGLOBAL_POWER_POLICY           pgpp,
    PGLOBAL_USER_POWER_POLICY      pgupp,
    PGLOBAL_MACHINE_POWER_POLICY   pgmpp
)
{
    if ((pgpp->user.Revision == CURRENT_REVISION) &&
        (pgpp->mach.Revision == CURRENT_REVISION)) {
        memcpy(pgupp, &(pgpp->user), sizeof(GLOBAL_USER_POWER_POLICY));
        memcpy(pgmpp, &(pgpp->mach), sizeof(GLOBAL_MACHINE_POWER_POLICY));
        return TRUE;
    }

    SetLastError(ERROR_REVISION_MISMATCH);
    DebugPrint("SplitGlobalPolicies, failed, LastError: 0x%08X", ERROR_REVISION_MISMATCH);
    return FALSE;
}

/*******************************************************************************
*
*  MergeToSystemPowerPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN MergeToSystemPowerPolicies(
    PGLOBAL_POWER_POLICY pgpp,
    PPOWER_POLICY        ppp,
    PSYSTEM_POWER_POLICY psppAc,
    PSYSTEM_POWER_POLICY psppDc
)
{
    UINT i;

    if ((pgpp->user.Revision != CURRENT_REVISION) ||
        (pgpp->mach.Revision != CURRENT_REVISION) ||
        (ppp->user.Revision  != CURRENT_REVISION) ||
        (ppp->mach.Revision  != CURRENT_REVISION))
    {
        DebugPrint("MergeToSystemPowerPolicies, failed, LastError: 0x%08X", ERROR_REVISION_MISMATCH);
        SetLastError(ERROR_REVISION_MISMATCH);
        return FALSE;
    }

    psppAc->Revision                        = ppp->user.Revision;
    psppAc->Idle                            = ppp->user.IdleAc;
    psppAc->IdleTimeout                     = ppp->user.IdleTimeoutAc;
    psppAc->IdleSensitivity                 = ppp->user.IdleSensitivityAc;
    psppAc->DynamicThrottle                 = ppp->user.ThrottlePolicyAc;
    psppAc->MinSleep                        = ppp->mach.MinSleepAc;
    psppAc->MaxSleep                        = ppp->user.MaxSleepAc;
    psppAc->ReducedLatencySleep             = ppp->mach.ReducedLatencySleepAc;
    psppAc->DozeS4Timeout                   = ppp->mach.DozeS4TimeoutAc;
    psppAc->VideoTimeout                    = ppp->user.VideoTimeoutAc;
    psppAc->SpindownTimeout                 = ppp->user.SpindownTimeoutAc;
    psppAc->OptimizeForPower                = ppp->user.OptimizeForPowerAc;
    psppAc->FanThrottleTolerance            = ppp->user.FanThrottleToleranceAc;
    psppAc->ForcedThrottle                  = ppp->user.ForcedThrottleAc;
    psppAc->MinThrottle                     = ppp->mach.MinThrottleAc;
    psppAc->OverThrottled                   = ppp->mach.OverThrottledAc;

    psppAc->PowerButton                     = pgpp->user.PowerButtonAc;
    psppAc->SleepButton                     = pgpp->user.SleepButtonAc;
    psppAc->LidClose                        = pgpp->user.LidCloseAc;
    psppAc->LidOpenWake                     = pgpp->mach.LidOpenWakeAc;
    psppAc->BroadcastCapacityResolution     = pgpp->mach.BroadcastCapacityResolution;

    psppDc->Revision                        = ppp->user.Revision;
    psppDc->Idle                            = ppp->user.IdleDc;
    psppDc->IdleTimeout                     = ppp->user.IdleTimeoutDc;
    psppDc->IdleSensitivity                 = ppp->user.IdleSensitivityDc;
    psppDc->DynamicThrottle                 = ppp->user.ThrottlePolicyDc;
    psppDc->MinSleep                        = ppp->mach.MinSleepDc;
    psppDc->MaxSleep                        = ppp->user.MaxSleepDc;
    psppDc->ReducedLatencySleep             = ppp->mach.ReducedLatencySleepDc;
    psppDc->DozeS4Timeout                   = ppp->mach.DozeS4TimeoutDc;
    psppDc->VideoTimeout                    = ppp->user.VideoTimeoutDc;
    psppDc->SpindownTimeout                 = ppp->user.SpindownTimeoutDc;
    psppDc->OptimizeForPower                = ppp->user.OptimizeForPowerDc;
    psppDc->FanThrottleTolerance            = ppp->user.FanThrottleToleranceDc;
    psppDc->ForcedThrottle                  = ppp->user.ForcedThrottleDc;
    psppDc->MinThrottle                     = ppp->mach.MinThrottleDc;
    psppDc->OverThrottled                   = ppp->mach.OverThrottledDc;

    psppDc->PowerButton                     = pgpp->user.PowerButtonDc;
    psppDc->SleepButton                     = pgpp->user.SleepButtonDc;
    psppDc->LidClose                        = pgpp->user.LidCloseDc;
    psppDc->LidOpenWake                     = pgpp->mach.LidOpenWakeDc;
    psppDc->BroadcastCapacityResolution     = pgpp->mach.BroadcastCapacityResolution;

    if (pgpp->user.GlobalFlags & EnablePasswordLogon)
    {
        psppAc->WinLogonFlags = psppDc->WinLogonFlags = WINLOGON_LOCK_ON_SLEEP;
    }
    else
    {
        psppAc->WinLogonFlags = psppDc->WinLogonFlags = 0;
    }
    
    if (pgpp->user.GlobalFlags & EnableVideoDimDisplay)
    {
        psppDc->VideoDimDisplay = TRUE;
    }
    else
    {
        psppDc->VideoDimDisplay = FALSE;
    }
    
    for (i = 0; i < NUM_DISCHARGE_POLICIES; i++)
    {
        psppDc->DischargePolicy[i]          = pgpp->user.DischargePolicy[i];
        psppAc->DischargePolicy[i]          = pgpp->user.DischargePolicy[i];

        // HIWORD of EventCode contains index.
        psppDc->DischargePolicy[i].PowerPolicy.EventCode |= (i << 16);
        psppAc->DischargePolicy[i].PowerPolicy.EventCode |= (i << 16);
    }

    return TRUE;
}

/*******************************************************************************
*
*  SplitFromSystemPowerPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SplitFromSystemPowerPolicies(
    PSYSTEM_POWER_POLICY psppAc,
    PSYSTEM_POWER_POLICY psppDc,
    PGLOBAL_POWER_POLICY pgpp,
    PPOWER_POLICY        ppp
)
{
    UINT i;

    if ((psppAc->Revision != CURRENT_REVISION) ||
        (psppDc->Revision != CURRENT_REVISION)) {
        SetLastError(ERROR_REVISION_MISMATCH);
        DebugPrint("SplitFromSystemPowerPolicies, failed, LastError: 0x%08X", ERROR_REVISION_MISMATCH);
        return FALSE;
    }

    if (ppp) {
        ppp->user.Revision  = ppp->mach.Revision  = CURRENT_REVISION;

        ppp->user.IdleAc                        = psppAc->Idle;
        ppp->user.IdleTimeoutAc                 = psppAc->IdleTimeout;
        ppp->user.IdleSensitivityAc             = psppAc->IdleSensitivity;
        ppp->user.ThrottlePolicyAc              = psppAc->DynamicThrottle;
        ppp->mach.MinSleepAc                    = psppAc->MinSleep;
        ppp->user.MaxSleepAc                    = psppAc->MaxSleep;
        ppp->mach.ReducedLatencySleepAc         = psppAc->ReducedLatencySleep;
        ppp->mach.DozeTimeoutAc                 = 0;
        ppp->mach.DozeS4TimeoutAc               = psppAc->DozeS4Timeout;
        ppp->user.VideoTimeoutAc                = psppAc->VideoTimeout;
        ppp->user.SpindownTimeoutAc             = psppAc->SpindownTimeout;
        ppp->user.OptimizeForPowerAc            = psppAc->OptimizeForPower;
        ppp->user.FanThrottleToleranceAc        = psppAc->FanThrottleTolerance;
        ppp->user.ForcedThrottleAc              = psppAc->ForcedThrottle;
        ppp->mach.MinThrottleAc                 = psppAc->MinThrottle;
        ppp->mach.OverThrottledAc               = psppAc->OverThrottled;

        ppp->user.IdleDc                        = psppDc->Idle;
        ppp->user.IdleTimeoutDc                 = psppDc->IdleTimeout;
        ppp->user.IdleSensitivityDc             = psppDc->IdleSensitivity;
        ppp->user.ThrottlePolicyDc              = psppDc->DynamicThrottle;
        ppp->mach.MinSleepDc                    = psppDc->MinSleep;
        ppp->user.MaxSleepDc                    = psppDc->MaxSleep;
        ppp->mach.ReducedLatencySleepDc         = psppDc->ReducedLatencySleep;
        ppp->mach.DozeTimeoutDc                 = 0;
        ppp->mach.DozeS4TimeoutDc               = psppDc->DozeS4Timeout;
        ppp->user.VideoTimeoutDc                = psppDc->VideoTimeout;
        ppp->user.SpindownTimeoutDc             = psppDc->SpindownTimeout;
        ppp->user.OptimizeForPowerDc            = psppDc->OptimizeForPower;
        ppp->user.FanThrottleToleranceDc        = psppDc->FanThrottleTolerance;
        ppp->user.ForcedThrottleDc              = psppDc->ForcedThrottle;
        ppp->mach.MinThrottleDc                 = psppDc->MinThrottle;
        ppp->mach.OverThrottledDc               = psppDc->OverThrottled;
    }

    if (pgpp) {
        pgpp->user.Revision = pgpp->mach.Revision = CURRENT_REVISION;

        pgpp->user.PowerButtonAc                = psppAc->PowerButton;
        pgpp->user.SleepButtonAc                = psppAc->SleepButton;
        pgpp->user.LidCloseAc                   = psppAc->LidClose;
        pgpp->mach.LidOpenWakeAc                = psppAc->LidOpenWake;
        pgpp->mach.BroadcastCapacityResolution  = psppAc->BroadcastCapacityResolution;

        pgpp->user.PowerButtonDc                = psppDc->PowerButton;
        pgpp->user.SleepButtonDc                = psppDc->SleepButton;
        pgpp->user.LidCloseDc                   = psppDc->LidClose;
        pgpp->mach.LidOpenWakeDc                = psppDc->LidOpenWake;
        pgpp->mach.BroadcastCapacityResolution  = psppDc->BroadcastCapacityResolution;

        if ((psppDc->WinLogonFlags & WINLOGON_LOCK_ON_SLEEP) ||
            (psppAc->WinLogonFlags & WINLOGON_LOCK_ON_SLEEP)) {
            pgpp->user.GlobalFlags |= EnablePasswordLogon;
        }
        else {
            pgpp->user.GlobalFlags &= ~EnablePasswordLogon;
        }
        
        if (psppDc->VideoDimDisplay) {
            pgpp->user.GlobalFlags |= EnableVideoDimDisplay;
        }
        else {
            pgpp->user.GlobalFlags &= ~EnableVideoDimDisplay;
        }
        
        for (i = 0; i < NUM_DISCHARGE_POLICIES; i++) {
            pgpp->user.DischargePolicy[i]       = psppDc->DischargePolicy[i];
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upstab.h ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSTAB.H
*
*  VERSION:     1.0
*
*  AUTHOR:      PaulB
*
*  DATE:        07 June, 1999
*
*******************************************************************************/

#ifndef _UPSTAB_H_
#define _UPSTAB_H_

#include <windows.h>
#include <tchar.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <initguid.h>
#include <mstask.h>
#include <help.h>
#include <powercfp.h>

#include "upsreg.h"
#include "upsinfo.h"
#include "upsselect.h"
#include "upscommon.h"
#include "upsconfig.h"
#include "upscustom.h"
#include "apcabout.h"


#ifdef __cplusplus
  extern "C" {
#endif

  INT_PTR CALLBACK UPSMainPageProc  (HWND, UINT, WPARAM, LPARAM);
  HMODULE GetUPSModuleHandle        (void);
  void    GetURLInfo                (LPTSTR aBuffer, DWORD aBufSize);
  DWORD   GetMessageFromStringTable (DWORD aMessageID,
                                     LPVOID * alpDwords,
                                     LPTSTR aMessageBuffer,
                                     DWORD * aBufferSizePtr);
  void    ConfigureService          (BOOL aSetToAutoStartBool);
  BOOL    IsUPSInstalled            (void);

  BOOL    DoUpdateInfo     (HWND hDlg,
                             DialogAssociations * aDialogAssociationsArray,
                             DWORD aNumRunningFields,
                             DWORD * aNoServiceControlIDs,
                             DWORD aNumNoServiceControls,
                             BOOL aChangeVisibilityBool);

#ifdef __cplusplus
  }
#endif


#endif // _UPSTAB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powercfg\ups\upstab.c ===
/*******************************************************************************
*
*  Copyright 1999 American Power Conversion, All Rights Reserved
*
*  TITLE:       UPSTAB.C
*
*  VERSION:     1.0
*
*  AUTHOR:      PaulB
*
*  DATE:        07 June, 1999
*
*  DESCRIPTION: This file contains the main body of code for the UPS Tab.
*               This dialog procedure is implemented in this file, along with
*               some of the support functions.
*
*******************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <shlobj.h>
#include <shellapi.h>

#include "upstab.h"
#include "..\powercfg.h"
#include "..\pwrresid.h"
#include "..\PwrMn_cs.h"
#pragma hdrstop

// data
///////////////////////////////////////////////////////////////////////////////

HWND    g_hwndDlg       = 0;
HICON   g_hIconUPS      = 0;
HICON   g_hIconPlug     = 0;

// context-sensitive help table
const DWORD g_UPSPageHelpIDs[]=
{
	IDC_STATIC, NO_HELP,
	IDC_STATUS_GROUPBOX, NO_HELP,
	IDC_POWER_SOURCE_ICON, idh_current_power_source,
	IDC_POWER_SOURCE_LHS, idh_current_power_source,
	IDC_POWER_SOURCE, idh_current_power_source,
	IDC_RUNTIME_REMAINING_LHS, idh_estimated_ups_runtime,
	IDC_RUNTIME_REMAINING, idh_estimated_ups_runtime,
	IDC_BATTERY_CAPACITY_LHS, idh_estimated_ups_capacity,
	IDC_BATTERY_CAPACITY, idh_estimated_ups_capacity,
	IDC_BATTERY_STATUS_LHS, idh_battery_condition,
	IDC_BATTERY_STATUS, idh_battery_condition,
    IDC_DETAILS_GROUPBOX, NO_HELP,
	IDB_UPS_ICON_BUTTON, idh_apc_logo_link,
	IDC_VENDOR_NAME_LHS, idh_manufacturer,
	IDC_VENDOR_NAME, idh_manufacturer,
	IDC_MODEL_TYPE_LHS, idh_model,
	IDC_MODEL_TYPE, idh_model,
	IDB_INSTALL_UPS, idh_select_ups,
	IDB_CONFIGURE_SVC, idh_configure_ups,
	IDC_MESSAGE_ICON, NO_HELP,
	IDC_MESSAGE_TEXT, NO_HELP,
	IDC_APC1, NO_HELP,
	IDC_APC2, NO_HELP,
    IDB_APCLOGO_SMALL, NO_HELP,
	0, 0
};


// data
///////////////////////////////////////////////////////////////////////////////

extern struct _reg_entry UPSConfigVendor;
extern struct _reg_entry UPSConfigModel;


//static LPCTSTR cUPSStateFormatString = TEXT("%s %s");
static UINT_PTR         g_UpdateTimerID = 0;
static const DWORD      cUpdateTimerID  = 100;
static BOOL             g_bIsAdmin      = TRUE;


// functions
///////////////////////////////////////////////////////////////////////////////

static DWORD FormatMessageText               (LPCTSTR aFormatString,
                                              LPVOID * alpDwords,
                                              LPTSTR aMessageBuffer,
                                              DWORD * aBufferSizePtr);
static BOOL UPSMainPageHandleInit            (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
static BOOL UPSMainPageHandleCommand         (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);
static BOOL UPSMainPageHandleNotify          (HWND aDlgHWND, WPARAM wParam, LPARAM lParam);

//All these functions are commented in the source file updatdlg.c
static BOOL UPSMainPageHandleDestroy   (HWND hDlg,
                                 WPARAM wParam,
                                 LPARAM lParam);
static BOOL CreateUPSIconButton(HWND hDlg, HICON aUPSIconHandle);

static void DoUpdateDialogInfo         (HWND hDlg);
static void ManageConfigureButtonState (HWND hDlg);
DWORD SetUpdateTimer(HWND hwnd);
DWORD KillUpdateTimer(HWND hwnd);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL CALLBACK UPSMainPageProc (HWND aDlgHWND,
//                                UINT aMsgID,
//                                WPARAM wParam,
//                                LPARAM lParam);
//
// Description: This is a standard DialogProc associated with the UPS tab dialog.
//
// Additional Information: See help on
// \<A HREF="ms-its:C:\Program%20Files\Microsoft%20Visual%20Studio\MSDN98\98VS\1033\winui.chm::/devdoc/live/pdui/dlgboxes_5lib.htm">DialogProc\</A>
//
// Parameters:
//
//   HWND aDlgHWND :- Handle to dialog box
//
//   UINT aMsgID :- message ID
//
//   WPARAM wParam :- Specifies additional message-specific information.
//
//   LPARAM lParam :- Specifies additional message-specific information.
//
// Return Value: Except in response to the WM_INITDIALOG message, the dialog
//               box procedure should return nonzero if it processes the
//               message, and zero if it does not.
//

INT_PTR CALLBACK UPSMainPageProc (HWND aDlgHWND,
                               UINT aMsgID,
                               WPARAM wParam,
                               LPARAM lParam) {

	BOOL bRet = TRUE;

	switch (aMsgID) {
	case WM_INITDIALOG: {
	  //The dialog box procedure should return TRUE to direct the system to
	  //set the keyboard focus to the control given by wParam.
	  bRet = UPSMainPageHandleInit(aDlgHWND, wParam, lParam);
	  break;
	  }

	case WM_COMMAND: {
	  //If an application processes this message, it should return zero.
	  bRet = UPSMainPageHandleCommand(aDlgHWND, wParam, lParam);
	  break;
	  }

	case WM_NOTIFY: {
	  bRet = UPSMainPageHandleNotify(aDlgHWND, wParam, lParam);
	  break;
	  }

	case WM_TIMER: {
	  //If an application processes this message, it should return zero.
	  DoUpdateDialogInfo(aDlgHWND);
	  bRet = FALSE;
	  break;
	  }

	case WM_HELP: {			//Help for WM_HELP says: Returns TRUE
	  bRet = WinHelp(((LPHELPINFO)lParam)->hItemHandle,
                PWRMANHLP,
                HELP_WM_HELP,
                (ULONG_PTR)(LPTSTR)g_UPSPageHelpIDs);
	  break;
	  }

	case WM_CONTEXTMENU: {     // right mouse click
      //
      // Kill the update timer while context help is active.  
      // Otherwise the code in the timer handler interferes with the help UI.
      //
      KillUpdateTimer(aDlgHWND);
	  bRet = WinHelp((HWND)wParam,
                PWRMANHLP,
                HELP_CONTEXTMENU,
                (ULONG_PTR)(LPTSTR)g_UPSPageHelpIDs);
      SetUpdateTimer(aDlgHWND);
	  break;
	  }

	case WM_DESTROY: {
	  //An application returns 0 if it processes WM_DESTROY
	  bRet = UPSMainPageHandleDestroy(aDlgHWND, wParam, lParam);
	  break;
	  }

	default: {
	  bRet = FALSE;
	  break;
	  }
	} // switch (aMsgID)

	return(bRet);
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL UPSMainPageHandleInit (HWND aDlgHWND,
//                             WPARAM wParam,
//                             LPARAM lParam);
//
// Description: This is the handler function for WM_INITDIALOG. It creates the
//              tooltip window, initialize the controls and creates the update
//              timer.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Identifies the dialog box.
//
//   WPARAM wParam :- Handle of control to receive focus
//
//   LPARAM lParam :- Initialization parameter
//
// Return Value: The dialog box procedure should return TRUE to direct the
//               system to set the keyboard focus to the control given by
//               wParam.
//
BOOL UPSMainPageHandleInit (HWND aDlgHWND,
                            WPARAM wParam,
                            LPARAM lParam) {

    /*
	 * The dialog is being created. By default many of the controls in the UPS
	 * page will appear disabled. If there is no data to display then this is
	 * the required behavior. We need to get the UPS data. When an individual
	 * data item is retrieved we then enable the field associated with that data
	 * item. If the data item is not available we disabled the field. We have
	 * to disable even though in this case the field is already disabled
	 * due to the fact that it's disabled in the RC file and we are in startup.
	 * But this same code is used in the "Refresh" scenario, requiring the the
	 * status of the field be able to be changed from enabled to disabled.
     */

	static BOOL bIsInitialized = FALSE;
	
	TCHAR   szVendorName[MAX_PATH] = _T("");
	TCHAR   szModelName[MAX_PATH] = _T("");

	g_hwndDlg = aDlgHWND;

    /*
	 * Determine if the registry needs to be initialized for the UPS service.
	 * if it is already initialized, do nothing
     */
	g_bIsAdmin = InitializeRegistry();

    /*
	 * Disable or hide the configure and select buttons depending on
	 * whether or not we can write to the registry.
     */
	EnableWindow( GetDlgItem( aDlgHWND, IDB_INSTALL_UPS ), g_bIsAdmin );
	EnableWindow( GetDlgItem( aDlgHWND, IDB_CONFIGURE_SVC ), g_bIsAdmin );

	InitializeApplyButton(aDlgHWND);

	// Load icon images for Power Source and UPS Info button
    g_hIconUPS = LoadImage(GetUPSModuleHandle(),
                           MAKEINTRESOURCE(IDI_UPS),
                           IMAGE_ICON,
                           0, 0,
                           LR_LOADMAP3DCOLORS | LR_SHARED);

    g_hIconPlug = LoadImage(GetUPSModuleHandle(),
                            MAKEINTRESOURCE(IDI_PLUG),
                            IMAGE_ICON,
                            0, 0,
                            LR_LOADMAP3DCOLORS | LR_SHARED);

    if( NULL != g_hIconUPS )
		CreateUPSIconButton(aDlgHWND, g_hIconUPS);

	// Init the Registry info blocks ONCE
	if (!bIsInitialized) {
		InitUPSConfigBlock();
		InitUPSStatusBlock();
		bIsInitialized = TRUE;
	}

    /*
     * NOTE:
     * This is a workaround to fix previously hard-coded default
     * strings in upsreg.c If the Vendor Name is null then we assume
     * that we should apply
     * default values from the resource file
     */
    GetUPSConfigVendor( szVendorName);
    GetUPSConfigModel( szModelName);

    /*
     * The function IsUPSInstalled assumes the config
     * block has been initialized.
     */
	if (!_tcsclen(szVendorName) && IsUPSInstalled()) {
		// Get the "Generic" vendor name from the resource file.
		LoadString(GetUPSModuleHandle(),
				   IDS_OTHER_UPS_VENDOR,
				   (LPTSTR) szVendorName,
				   sizeof(szVendorName)/sizeof(TCHAR));

		// Get the "Custom" model name from the resource file.
		LoadString(GetUPSModuleHandle(),
				   IDS_CUSTOM_UPS_MODEL,
				   (LPTSTR) szModelName,
				   sizeof(szModelName)/sizeof(TCHAR));

		SetUPSConfigVendor( szVendorName);
		SetUPSConfigModel( szModelName);
		SaveUPSConfigBlock(FALSE);
	}

	if (!_tcsclen(szVendorName) && !IsUPSInstalled()) {
		// Get the "No UPS" vendor name from the resource file.
		LoadString(GetUPSModuleHandle(),
				   IDS_NO_UPS_VENDOR,
				   (LPTSTR) szVendorName,
				   sizeof(szVendorName)/sizeof(TCHAR));

		SetUPSConfigVendor( szVendorName);
		SaveUPSConfigBlock(FALSE);
	}

	DoUpdateDialogInfo(aDlgHWND);
    SetUpdateTimer(aDlgHWND);
	return(FALSE);
}


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL UPSMainPageHandleCommand (HWND aDlgHWND,
//                                WPARAM wParam,
//                                LPARAM lParam);
//
// Description: This is the handler function for WM_COMMAND.
//
// Additional Information: See help on WM_COMMAND
//
// Parameters:
//
//   HWND aDlgHWND :- Handle to dialog box
//
//   WPARAM wParam :- HIWORD(wParam) gives the notification code.
//                    LOWORD(wParam) gives the control id.
//
//   LPARAM lParam :- Gives the HWND or handle of the control.
//
// Return Value: If an application processes this message, it should return 0.
//
BOOL UPSMainPageHandleCommand (HWND aDlgHWND,
                               WPARAM wParam,
                               LPARAM lParam) {
  switch (LOWORD(wParam)) {// control ID
    case IDB_INSTALL_UPS: {
      DialogBoxParam( GetUPSModuleHandle(),
      MAKEINTRESOURCE(IDD_UPSSELECT),
      aDlgHWND,
      UPSSelectDlgProc, (LPARAM) aDlgHWND);
      break;
      }

    case IDB_UPS_ICON_BUTTON: {
      DisplayUPSInfoDialogBox(aDlgHWND);
      break;
      }
	case IDC_APC1:
	case IDC_APC2:
    case IDB_APCLOGO_SMALL: {
      DisplayAboutDialogBox(aDlgHWND);
      break;
      }
    case IDB_CONFIGURE_SVC: {
      DialogBoxParam( GetUPSModuleHandle(),
      MAKEINTRESOURCE(IDD_UPSCONFIGURATION),
      aDlgHWND, UPSConfigDlgProc, (LPARAM) aDlgHWND);
      break;
      }
    default: {
      break;
      }
    }//end switch

  //If an application processes this message, it should return zero.
  return(FALSE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL UPSMainPageHandleNotify (HWND aDlgHWND,
//                               WPARAM wParam,
//                               LPARAM lParam);
//
// Description: Sent by a common control to its parent window when an event has
//              occurred in the control or the control requires some kind of
//              information.
//
// Additional Information: See help on NMHDR
//
// Parameters:
//
//   HWND aDlgHWND :- Handle to dialog box
//
//   WPARAM wParam :- Identifier of the common control sending the message.
//
//   LPARAM lParam :- Address of an NMHDR structure that contains the
//                    notification code and additional information.
//
// Return Value: If an application processes this message, it should return 0.
//
BOOL UPSMainPageHandleNotify (HWND aDlgHWND,
                              WPARAM wParam,
                              LPARAM lParam) {
  LPNMHDR pnmhdr = (LPNMHDR) lParam;
  UINT uNotify = pnmhdr->code;
  BOOL bWait = FALSE;

  switch(uNotify) {
    case PSN_APPLY: {
      DWORD dataState = GetActiveDataState();

       /*
        * Indicates that the user clicked the OK or Apply button and wants
        * all changes to take effect.
        * A page should not call the EndDialog function when processing this
        * notification message.
        */

		// Has anything changed? Do nothing otherwise.
		if (DATA_NO_CHANGE != dataState) {
			// Yes - make changes permanent
			SetUPSConfigUpgrade(FALSE);		// this really only needs to be done the first time, but...
			SaveUPSConfigBlock(FALSE);
			SetWindowLongPtr(aDlgHWND, DWLP_MSGRESULT, PSNRET_NOERROR);

			// Did the service data change?
			if ((dataState & SERVICE_DATA_CHANGE) == SERVICE_DATA_CHANGE) {
				// Yes - need to restart the service for the changes to take effect
				StopService(UPS_SERVICE_NAME);		// Stop the service if it's running
				ConfigureService(IsUPSInstalled());	// Set the UPS service to automatic or manual

				// Was the change that No UPS is installed?
				if (IsUPSInstalled() == TRUE) {
					//
					if (StartOffService(UPS_SERVICE_NAME, TRUE) == FALSE) {
						// If OK was selected this will stop the applet from closing
						// so that you can see that the service didn't start properly.
						SetWindowLongPtr(aDlgHWND, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
						// Since we've committed our changes, disable the Apply button.
						PropSheet_UnChanged(GetParent(aDlgHWND), aDlgHWND);
					}
				}
			}

			SetActiveDataState(DATA_NO_CHANGE);
		}

		break;
	}

	case PSN_RESET: {
      //Notifies a page that the user has clicked the Cancel button and the
      //property sheet is about to be destroyed.
      break;
      }
	default:
		return(FALSE);

    }//end switch

  return(TRUE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL IsUPSInstalled (void);
//
// Description: This function checks the "internal" values to determine if a
//              UPS is installed or not.
//
// Additional Information:
//
// Parameters: None
//
// Return Value: Returns TRUE if a UPS is installed, FALSE otherwise.
//
BOOL IsUPSInstalled (void) {
  BOOL bIsInstalled = FALSE;
  DWORD options = 0;

  if (GetUPSConfigOptions(&options) == ERROR_SUCCESS) {
    //If Options includes UPS_INSTALLED
    if ((options & UPS_INSTALLED) == UPS_INSTALLED) {
      bIsInstalled = TRUE;
      }
    }
  else {
    //The Options value should exist at this stage, or something is wrong
    //with SaveUPSConfigBlock()
    _ASSERT(FALSE);
    }

  return(bIsInstalled);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD FormatMessageText (LPCTSTR aFormatString,
//                          LPVOID * alpDwords,
//                          LPTSTR aMessageBuffer,
//                          DWORD * aBufferSizePtr);
//
// Description: This function wraps FormatMessage and is used to put inserts
//              into a given string. The inserts must be stored in an array of
//              32-bit values that represent the arguments.
//
// Additional Information: FormatMessage
//
// Parameters:
//
//   LPCTSTR aFormatString :- Pointer to the format string containing  inserts
//                            of the form %1, %2 etc.
//
//   LPVOID * alpDwords :- A pointer to an array of 32-bit values that
//                         represent the arguments.
//
//   LPTSTR aMessageBuffer :- Buffer to which the fully formatted string is
//                            written, if successful.
//
//   DWORD * aBufferSizePtr :- Pointer to a DWORD that holds the size of the
//                             buffer to write to. If this function returns
//                             successfully this will contain the number
//                             of bytes written.
//
// Return Value: Function returns ERROR_SUCCESS on success and a Win32 error
//               code if an error occurs.
//
DWORD FormatMessageText (LPCTSTR aFormatString,
                         LPVOID * alpDwords,
                         LPTSTR aMessageBuffer,
                         DWORD * aBufferSizePtr) {
  LPTSTR lpBuf = NULL; // Will Hold text of the message (allocated by FormatMessage
  DWORD errStatus = ERROR_SUCCESS;
  DWORD numChars = 0;

  if ((numChars = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCVOID) aFormatString,
                                0,
                                0,
                                (LPTSTR) &lpBuf,
                                MAX_MESSAGE_LENGTH,
                                (va_list *)alpDwords)) == 0) {

    *aBufferSizePtr = 0;
    *aMessageBuffer = TEXT('\0');
    }
  else {
    if (aBufferSizePtr != NULL) {
      if (numChars < *aBufferSizePtr) {
        //the given buffer is big enough to hold the string

        if (aMessageBuffer != NULL) {
          _tcscpy(aMessageBuffer, lpBuf);
          }
        }
      *aBufferSizePtr = numChars;
      }

    LocalFree(lpBuf);
    }

  return(errStatus);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// DWORD GetMessageFromStringTable (DWORD aMessageID,
//                                  LPVOID * alpDwords,
//                                  LPTSTR aMessageBuffer,
//                                  DWORD * aBufferSizePtr);
//
// Description: This function reads a string resource from the resource table
//              inserting the given string inserts.
//
// Additional Information:
//
// Parameters:
//
//   DWORD aMessageID :- Message ID of the string resource to get.
//
//   LPVOID * alpDwords :- A pointer to an array of 32-bit values that
//                         represent the arguments.
//
//   LPTSTR aMessageBuffer :- Buffer to which the fully formatted string is
//                            written, if successful.
//
//   DWORD * aBufferSizePtr :- Pointer to a DWORD that holds the size of the
//                             buffer to write to. If this function returns
//                             successfully this will contain the number
//                             of bytes written.
//
// Return Value: Function returns ERROR_SUCCESS on success and a Win32 error
//               code if an error occurs.
//
DWORD GetMessageFromStringTable (DWORD aMessageID,
                                 LPVOID * alpDwords,
                                 LPTSTR aMessageBuffer,
                                 DWORD * aBufferSizePtr) {
  TCHAR resourceTemplateString[MAX_MESSAGE_LENGTH] = TEXT("");
  DWORD resStringBufSize = DIMENSION_OF(resourceTemplateString);
  HMODULE hUPSModule = GetUPSModuleHandle();
  DWORD errStatus = ERROR_INVALID_PARAMETER;

  if (LoadString(hUPSModule,
                 aMessageID,
                 resourceTemplateString,
                 resStringBufSize) > 0) {
   //Now we have the resource string

    errStatus = FormatMessageText(resourceTemplateString,
                                  alpDwords,
                                  aMessageBuffer,
                                  aBufferSizePtr);
    }

  return(errStatus);
  }



// UPDATDLG.C

// static data
///////////////////////////////////////////////////////////////////////////////


static DialogAssociations g_DialogAssocs[] = {
  MAKE_ARRAY ( VENDOR_NAME,       IDS_STRING,            IDS_STRING,                RESOURCE_FIXED,     0, eShallowGet, getStringValue, &UPSConfigVendor),
  MAKE_ARRAY ( MODEL_TYPE,        IDS_STRING,            IDS_STRING,                RESOURCE_FIXED,     0, eShallowGet, getStringValue, &UPSConfigModel),
  MAKE_ARRAY ( POWER_SOURCE,      IDS_STRING,            IDS_UTILITYPOWER_UNKNOWN,  RESOURCE_INCREMENT, 2, eDeepGet,    0,              0),
  MAKE_ARRAY ( RUNTIME_REMAINING, IDS_RUNTIME_REMAINING, IDS_STRING,                RESOURCE_FIXED,     0, eDeepGet,    0,              0),
  MAKE_ARRAY ( BATTERY_CAPACITY,  IDS_CAPACITY,			 IDS_STRING,				RESOURCE_FIXED,		0, eDeepGet,    0,              0),
  MAKE_ARRAY ( BATTERY_STATUS,    IDS_STRING,            IDS_BATTERYSTATUS_UNKNOWN, RESOURCE_INCREMENT, 2, eDeepGet,    0,              0) };

static DWORD g_NoServiceControls[] = { IDC_MESSAGE_TEXT };


// functions
///////////////////////////////////////////////////////////////////////////////

static void SelectServiceTextMessage    (HWND aDlgHWND, HWND aNoServiceControlHwnd, HWND aServiceControlHwnd);
static void ChangeTextIfDifferent       (HWND aWindowHandle, LPTSTR aBuffer);

//static void GetServiceTextMessages      (HWND  aNoServiceControlHwnd, LPTSTR aOriginalTextBuffer,         DWORD aOriginalTextBufferSize,
//                                         DWORD aCommListStringID,     LPTSTR aCommStringBuffer,           DWORD aCommStringBufferSize,
//                                         DWORD aPressApplyStringID,   LPTSTR aPressApplyStringBuffer,     DWORD aPressApplyStringBufferSize,
//                                         DWORD aNoUPSStringID,        LPTSTR aNoUPSInstalledStringBuffer, DWORD aNoUPSInstalledStringBufferSize);

//static void GetServiceTextMessage       (DWORD aStringID, LPTSTR aBuffer, DWORD aBufferSize);

static BOOL IsDataOKToDisplay           (void);
static BOOL IsDataUpToDate              (void);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void UPSMainPageHandleDestroy (HWND aDlgHWND,
//                                WPARAM wParam,
//                                LPARAM lParam);
//
// Description: This function is called when the UPS page is being destroyed.
//              It is responsible for any cleanup that is required.
//
// Additional Information: See KillTimer
//
// Parameters:
//
//   HWND aDlgHWND :- Dialog window handle.
//
//   WPARAM wParam :- Specifies additional message-specific information.
//                    For WM_DESTROY this parameter is ignored.
//
//   LPARAM lParam :- Specifies additional message-specific information.
//                    For WM_DESTROY this parameter is ignored.
//
// Return Value: An application returns 0 if it processes WM_DESTROY
//
BOOL UPSMainPageHandleDestroy (HWND aDlgHWND,
                               WPARAM wParam,
                               LPARAM lParam) {

  // deallocate the registry block memory
  FreeUPSConfigBlock();
  FreeUPSStatusBlock();

  KillUpdateTimer(aDlgHWND);

  //An application returns 0 if it processes WM_DESTROY
  return(FALSE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL CreateUPSIconButton (HWND aDlgHWND, HICON aUPSIconHandle);
//
// Description: Creates the small UPS icon button on the UPS page.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Dialog window handle.
//
//   HICON aUPSIconHandle :- Handle to the icon to display in the button.
//
// Return Value: Returns TRUE.
//
BOOL CreateUPSIconButton (HWND aDlgHWND, HICON aUPSIconHandle) {
  HWND hAPCLogoButton = GetDlgItem(aDlgHWND, IDB_UPS_ICON_BUTTON);
  POINT pt = { 0, 0 };
  ICONINFO info;
  BITMAP bm;

  _ASSERT(aDlgHWND != NULL);
  _ASSERT(aUPSIconHandle != NULL);
  _ASSERT(hAPCLogoButton != NULL);

  ZeroMemory(&info, sizeof(ICONINFO));

  if (GetIconInfo(aUPSIconHandle, &info) == TRUE) {
    //Now determine the size of the icon's color bitmap

    _ASSERT(info.fIcon == TRUE);
    _ASSERT(info.hbmColor != NULL);

    ZeroMemory(&bm, sizeof(BITMAP));

    if (GetObject(info.hbmColor, sizeof(BITMAP), &bm) != 0) {
      pt.x = bm.bmWidth;
      pt.y = bm.bmHeight;
      }

    //GetIconInfo creates bitmaps for the hbmMask and hbmColor members of
    //ICONINFO. The calling application must manage these bitmaps and delete
    //them when they are no longer necessary.
    DeleteObject(info.hbmColor);
    DeleteObject(info.hbmMask);
    }

  //Resize the button control.
  SetWindowPos(hAPCLogoButton,
               HWND_NOTOPMOST,
               -1,
               -1,
               pt.x,
               pt.y,
               SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOZORDER);

  //This sets the button's icon image.
  SendMessage(hAPCLogoButton, BM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) aUPSIconHandle);

  return(TRUE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void DoUpdateDialogInfo (HWND aDlgHWND);
//
// Description: This functions gets the latest UPS information and updates the
//              contents/form of the various controls within the dialog, based
//              on the availability and content of the various settings.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- Dialog window handle.
//
// Return Value: None
//
void DoUpdateDialogInfo (HWND aDlgHWND) {
  //Get the UPS data and for each item that's available display the appropriate
  //value and enable the associated controls. All other fields
  static const DWORD numRunningFields = DIMENSION_OF(g_DialogAssocs);
  static const DWORD numNoServiceFields = DIMENSION_OF(g_NoServiceControls);
  HWND hMessageControl = GetDlgItem(aDlgHWND, IDC_MESSAGE_TEXT);
  HWND hServiceControl = GetDlgItem(aDlgHWND, IDC_SERVICE_TEXT);

  DWORD dwUtilityStatus = 0;
  BOOL bIsUPSInstalled = IsUPSInstalled();

  //The IDC_MESSAGE_TEXT control contains default information in the
  //Static control in the dialog resource. This text message can be
  //changed to the "service not running" message, the "no comm" message
  //or the "press apply to commit" message depending on the current
  //state of the registry, the upsreg data buffer, the UPS service
  //and the status of the UPS communication. However, if conditions
  //dictate we want the original text from the control to be displayed.
  //For this reason we must store the original text so that the control
  //text can be set to this text without having to have the actual
  //text as a string resource.

  DoUpdateInfo(aDlgHWND,
               g_DialogAssocs,
               numRunningFields,
               (DWORD *) &g_NoServiceControls,
               numNoServiceFields,
               FALSE);


  //Now the IDC_MESSAGE_TEXT control may need to be changed to display different information.
  SelectServiceTextMessage(aDlgHWND, hMessageControl, hServiceControl);

  // Update the Power Source Icon
  if( (TRUE == IsUPSInstalled()) &&
	  (TRUE == GetUPSDataItemDWORD(eREG_POWER_SOURCE, &dwUtilityStatus)) &&
	  (UPS_UTILITYPOWER_OFF == dwUtilityStatus) )
	SendMessage(GetDlgItem(aDlgHWND, IDC_POWER_SOURCE_ICON),STM_SETICON,(WPARAM)g_hIconUPS,0);
  else
	SendMessage(GetDlgItem(aDlgHWND, IDC_POWER_SOURCE_ICON),STM_SETICON,(WPARAM)g_hIconPlug,0);

  //Finally if no UPS is installed then disable the IDB_CONFIGURE_SVC control otherwise
  //enable it.
  ManageConfigureButtonState(aDlgHWND);
  }


//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void SelectServiceTextMessage (HWND aDlgHWND, HWND aNoServiceControlHwnd, HWND aServiceControlHwnd);
//
// Description: This function changes the text displayed in the bottom half
//              of the UPS page. There are two control because the
//              IDC_SERVICE_TEXT control needs to be positioned to the left
//              of the "Configure..." button, while the other messages need
//              to be centered in the group box. The first control is not
//              as wide and is off centre. The second control is centered.
//              If the requirements were different this could have been
//              one control whose text changed.
//
//              If the first control is visible, the second one is made
//              invisible, and vice versa, as their contents are mutually
//              exclusive.
//
// Additional Information:
//
// Parameters:
//
//   HWND aNoServiceControlHwnd :- Handle to the IDC_MESSAGE_TEXT control.
//
//   HWND aServiceControlHwnd :- Handle to the IDC_SERVICE_TEXT control.
//
// Return Value: None
//
void SelectServiceTextMessage (HWND aDlgHWND, HWND aNoServiceControlHwnd, HWND aServiceControlHwnd) {
  static BOOL bGotServiceTextMessages = FALSE;
  static TCHAR originalControlTextBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  static TCHAR noCommStringBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  static TCHAR pressApplyStringBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  static TCHAR noUPSInstalledStringBuffer[MAX_MESSAGE_LENGTH] = TEXT("");

  static HICON hInfoIcon;
  static HICON hWarningIcon;
  static HICON hErrorIcon;

  BOOL bShow = TRUE;

  DWORD commStatus = 0;
  BOOL bIsRunning = IsServiceRunning(UPS_SERVICE_NAME);
  BOOL bIsDataUpToDate = IsDataUpToDate();
  BOOL bIsUPSInstalled = IsUPSInstalled();
  BOOL bIsDataOK = IsDataOKToDisplay();
  DWORD dataState = GetActiveDataState();


  _ASSERT(aNoServiceControlHwnd != NULL);

  //Determine which control should be shown. Is it the "everything OK" control
  //or the second control that is used for all other messages.

  ShowWindow(aServiceControlHwnd, (bIsRunning == TRUE) &&
                                        (bIsDataUpToDate == TRUE) &&
                                        (bIsDataOK == TRUE) && FALSE ? SW_SHOW : SW_HIDE);


  //Get the strings if this is the first time into this function.
  if (bGotServiceTextMessages == FALSE) {
//    GetServiceTextMessages(aNoServiceControlHwnd, originalControlTextBuffer,  DIMENSION_OF(originalControlTextBuffer),
//                           IDS_COMM_LOST,         noCommStringBuffer,         DIMENSION_OF(noCommStringBuffer),
//                           IDS_PRESS_APPLY,       pressApplyStringBuffer,     DIMENSION_OF(pressApplyStringBuffer),
//                           IDS_NO_UPS_INSTALLED,  noUPSInstalledStringBuffer, DIMENSION_OF(noUPSInstalledStringBuffer));
    bGotServiceTextMessages = TRUE;


	if (LoadString( GetUPSModuleHandle(),
					IDS_UPS_STOPPED,
					originalControlTextBuffer,
					DIMENSION_OF(originalControlTextBuffer)) > 0) {}

	if (LoadString( GetUPSModuleHandle(),
					IDS_COMM_LOST,
					noCommStringBuffer,
					DIMENSION_OF(noCommStringBuffer)) > 0) {}

	if (LoadString( GetUPSModuleHandle(),
					IDS_PRESS_APPLY,
					pressApplyStringBuffer,
					DIMENSION_OF(pressApplyStringBuffer)) > 0) {}
		
	if (LoadString( GetUPSModuleHandle(),
					IDS_NO_UPS_INSTALLED,
					noUPSInstalledStringBuffer,
					DIMENSION_OF(noUPSInstalledStringBuffer)) > 0) {}
		

    hInfoIcon = LoadImage(NULL,
                          MAKEINTRESOURCE(IDI_INFORMATION),
                          IMAGE_ICON,
                          0,0,
                          LR_LOADMAP3DCOLORS | LR_SHARED);
    hWarningIcon = LoadImage(NULL,
                             MAKEINTRESOURCE(IDI_WARNING),
                             IMAGE_ICON,
                             0,0,
                             LR_LOADMAP3DCOLORS | LR_SHARED);
    hErrorIcon = LoadImage(NULL,
                           MAKEINTRESOURCE(IDI_ERROR),
                           IMAGE_ICON,
                           0,0,
                           LR_LOADMAP3DCOLORS | LR_SHARED);
    }

  //Determime which string to display in the second control.
  if( (bIsDataUpToDate == FALSE) ||
	  (dataState & CONFIG_DATA_CHANGE) ) {
    ChangeTextIfDifferent(aNoServiceControlHwnd, pressApplyStringBuffer);
	SendMessage(GetDlgItem(aDlgHWND, IDC_MESSAGE_ICON),STM_SETICON,(WPARAM)hInfoIcon,0);
    }
  else if (bIsRunning == FALSE) {
    ChangeTextIfDifferent(aNoServiceControlHwnd, originalControlTextBuffer);
	SendMessage(GetDlgItem(aDlgHWND, IDC_MESSAGE_ICON),STM_SETICON,(WPARAM)hWarningIcon,0);
    }
  else if (GetUPSDataItemDWORD(eREG_COMM_STATUS, &commStatus) == TRUE) {
    if ((commStatus == UPS_COMMSTATUS_LOST) && (bIsRunning == TRUE)) {
      ChangeTextIfDifferent(aNoServiceControlHwnd, noCommStringBuffer);
	  SendMessage(GetDlgItem(aDlgHWND, IDC_MESSAGE_ICON),STM_SETICON,(WPARAM)hErrorIcon,0);
      }//End Comm Lost
    else
	  bShow = FALSE;
    }//end if GetUPSDataItemDWORD(eREG_COMM_STATUS...
	
	ShowWindow(GetDlgItem(aDlgHWND,IDC_MESSAGE_TEXT), bShow ? SW_SHOW : SW_HIDE);
	ShowWindow(GetDlgItem(aDlgHWND,IDC_MESSAGE_ICON), bShow ? SW_SHOW : SW_HIDE);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void ChangeTextIfDifferent (HWND aWindowHandle, LPTSTR aBuffer);
//
// Description: This function set a window's text to the given value, unless
//              the window text is matches this string already in which case
//              the function does nothing.
//
// Additional Information:
//
// Parameters:
//
//   HWND aWindowHandle :- Handle to a control.
//
//   LPTSTR aBuffer :- Pointer to new window text. This parameter should not be
//                     NULL, although it can point to an empty string.
//
// Return Value: None
//
void ChangeTextIfDifferent (HWND aWindowHandle, LPTSTR aBuffer) {
  TCHAR controlTextBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  DWORD controlTextBufferSize = DIMENSION_OF(controlTextBuffer);
  HICON hMsgIcon = NULL;

  _ASSERT(aWindowHandle != NULL);
  _ASSERT(aBuffer != NULL);

//  if (GetWindowText(aWindowHandle, controlTextBuffer, controlTextBufferSize) > 0) {
  GetWindowText(aWindowHandle, controlTextBuffer, controlTextBufferSize);
    if (_tcscmp(controlTextBuffer, aBuffer) != 0) {
      //Only set the window text if it has changed (reduces screen flicker).
      SetWindowText(aWindowHandle, aBuffer);
      }
//    }
//  else {
//    SetWindowText(aWindowHandle, aBuffer);
//    }
 }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// void ManageConfigureButtonState (HWND aDlgHWND);
//
// Description: This "Configure..." button (IDB_CONFIGURE_SVC) should be
//              enabled only if a UPS is installed and the system is on AC Power.
//			    This function enables
//              this button if a UPS is currently selected and disables
//              it if one isn't.
//
//              The state of the Configure button reflects the state of
//              the "cached" values, not the actual committed registry
//              values.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- A handle to the main UPS window.
//
// Return Value: None
//
void ManageConfigureButtonState (HWND aDlgHWND) {
	DWORD bIsUpgrade = 0;
	DWORD dwUtilityStatus = 0;
	HWND hControl = GetDlgItem(aDlgHWND, IDB_CONFIGURE_SVC);

  if (hControl != NULL)
  {
    BOOL bIsUPSInstalled = IsUPSInstalled();
	GetUPSConfigUpgrade(&bIsUpgrade);

	GetUPSDataItemDWORD(eREG_POWER_SOURCE, &dwUtilityStatus);

	if( !bIsUPSInstalled ||
		!g_bIsAdmin ||
		bIsUpgrade ||
		(UPS_UTILITYPOWER_OFF == dwUtilityStatus) )
	{
		EnableWindow(hControl, FALSE);
	}
	else
	{
		EnableWindow(hControl, TRUE);
	}
  }
}

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL DoUpdateInfo (HWND aDlgHWND,
//                    DialogAssociations * aDialogAssociationsArray,
//                    DWORD aNumRunningFields,
//                    BOOL aShowWindowBool);
//
// Description: This function updates the current information in the main
//              UPS page to reflect the current UPS status information.
//
// Additional Information:
//
// Parameters:
//
//   HWND aDlgHWND :- A handle to the main UPS window.
//
//   DialogAssociations * aDialogAssociationsArray :- Pointer to an array of
//                                                    DialogAssociations's.
//
//   DWORD aNumRunningFields :- This is the number of elements in the above array.
//
//   BOOL aShowWindowBool :- Indicates whether the visibility of the
//                                 controls that have no data should be
//                                 affected. For the main UPS page the
//                                 visibility is not changed. For the
//                                 Advanced data the visibility is changed.
//
// Return Value: TRUE if any one of the data item has data associated with it.
//
BOOL DoUpdateInfo (HWND aDlgHWND,
                   DialogAssociations * aDialogAssociationsArray,
                   DWORD aNumRunningFields,
                   DWORD * aNoServiceControlIDs,
                   DWORD aNumNoServiceControls,
                   BOOL aShowWindowBool) {
  //Get the UPS data and for each item that's available display the appropriate
  //value and enable the associated controls. All other fields
  TCHAR upsDataBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  TCHAR resourceStringBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  TCHAR controlBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  DWORD dwordValue = 0;
  DWORD i=0;
  DWORD firstControlID = 0;
  DWORD secondControlID = 0;
  HWND hFirstControl = NULL;
  HWND hSecondControl = NULL;
  LPVOID lppArgs[1];
  BOOL bShowField = FALSE;
  BOOL bIsDataOK = IsDataOKToDisplay();

  bIsDataOK &= IsDataUpToDate();


  //Display/hide the NO service controls and hide/display all the
  //DialogAssociations fields.

  for (i=0; i<aNumNoServiceControls; i++) {
    HWND hNoServiceControl = GetDlgItem(aDlgHWND, *(aNoServiceControlIDs + i));
    ShowWindow(hNoServiceControl, SW_SHOW);
//    ShowWindow(hNoServiceControl, !bIsDataOK ? SW_SHOW : SW_HIDE);
    }

  for (i=0; i<aNumRunningFields; i++) {
    DialogAssociations * pCurrentEntryDetails = aDialogAssociationsArray + i;
    DWORD upsDataBufSize = DIMENSION_OF(upsDataBuffer);
    DWORD resStringBufSize = DIMENSION_OF(resourceStringBuffer);
    DWORD fieldID = (DWORD) pCurrentEntryDetails->theFieldTypeID;
    RegField * pRegField = GetRegField(fieldID);
    BOOL bGotData = FALSE;
    BOOL bValueSupported = TRUE;

    lppArgs[0] = (VOID *) 0;

    if (pRegField != NULL) {

  #ifdef _DEBUG
        {
        //If pCurrentEntryDetails->theResourceStringType is of type RESOURCE_INCREMENT
        //then pRegField->theValueType must be some DWORD type
        if (pCurrentEntryDetails->theResourceStringType == RESOURCE_INCREMENT) {
          DWORD allowedTypesDbg = REG_ANY_DWORD_TYPE;
          _ASSERT((pRegField->theValueType & allowedTypesDbg) == pRegField->theValueType);
          }
        }
  #endif
      if (pCurrentEntryDetails->theRegAccessType == eDeepGet) {
        if (bIsDataOK == TRUE) {
          if ((pRegField->theValueType & (REG_SZ | REG_EXPAND_SZ)) == pRegField->theValueType) {
            bGotData = GetUPSDataItemString(fieldID, upsDataBuffer, &upsDataBufSize);
            lppArgs[0] = (VOID *) (LPCTSTR) upsDataBuffer;
            }
          else {
      #ifdef _DEBUG
            {
            DWORD allowedTypesDbg = REG_ANY_DWORD_TYPE;

            _ASSERT((pRegField->theValueType & allowedTypesDbg) == pRegField->theValueType);
            }
      #endif

            if ((bGotData = GetUPSDataItemDWORD(fieldID, &dwordValue)) == TRUE) {
              //Need some special handling here if the
              if (pCurrentEntryDetails->theResourceStringType == RESOURCE_INCREMENT) {
                //This DWORD value represents an offset into the resource string table
                //to identify a string that is to be displayed, not a DWORD value
                //If the index is 0 then the value is unknown and the associated
                //fields are shown disabled. 0 is a special case that will do this
                //for all fields of this type.
                DWORD realResID = 0;

                //If the given value is greater than the given maximum value
                //then the field is "not supported" and the associated
                //fields are hidden.

                if (dwordValue > pCurrentEntryDetails->theResourceIndexMax) {
                  bValueSupported = FALSE;
                  bGotData = FALSE;
                  }
                else if (dwordValue == 0) {
                  bGotData = FALSE;
                  }
                else {
                  realResID = pCurrentEntryDetails->theResourceIndexID + dwordValue;

                  if (LoadString(GetUPSModuleHandle(),
								 realResID,
                                 upsDataBuffer,
                                 upsDataBufSize) > 0) {
                    lppArgs[0] = (VOID *) (LPCTSTR) upsDataBuffer;
                    }
                  }
                }
              else {
                lppArgs[0] = IntToPtr(dwordValue);

                //If the value of a regular number field is 0 then it is not supported.
                if (dwordValue == 0) {
                  bGotData = FALSE;
                  }
                }
              }
            }
          }//end bIsDataOK
        }
      else {
        _ASSERT(pCurrentEntryDetails->theRegAccessType == eShallowGet);
        _ASSERT((pCurrentEntryDetails->theShallowAccessFunctionPtr == getDwordValue) ||
                (pCurrentEntryDetails->theShallowAccessFunctionPtr == getStringValue));
        _ASSERT(pCurrentEntryDetails->theRegEntryPtr != 0);

        if (pCurrentEntryDetails->theShallowAccessFunctionPtr == getDwordValue) {
          if (getDwordValue(pCurrentEntryDetails->theRegEntryPtr, &dwordValue) == ERROR_SUCCESS) {
            lppArgs[0] = IntToPtr(dwordValue);
            bGotData = TRUE;
            }
          }
        else {
          if (getStringValue(pCurrentEntryDetails->theRegEntryPtr, upsDataBuffer) == ERROR_SUCCESS) {
            lppArgs[0] = (VOID *) (LPCTSTR) upsDataBuffer;
            bGotData = TRUE;
            }
          }
        }

      //If bGotData == TRUE then the field was active in the registry and we react accordingly
      //by enabling the associated controls.

      firstControlID = pCurrentEntryDetails->theStaticFieldID;
      secondControlID = pCurrentEntryDetails->theDisplayControlID;

      hFirstControl = GetDlgItem(aDlgHWND, firstControlID);
      hSecondControl = GetDlgItem(aDlgHWND, secondControlID);

      _ASSERT(firstControlID > 0);
      _ASSERT(secondControlID > 0);

      _ASSERT(hFirstControl != NULL);
      _ASSERT(hSecondControl != NULL);

      EnableWindow(hFirstControl, bGotData);
      EnableWindow(hSecondControl, bGotData);

      if (bValueSupported == FALSE) {
        ShowWindow(hFirstControl, bValueSupported ? SW_SHOW : SW_HIDE);
        ShowWindow(hSecondControl, bValueSupported ? SW_SHOW : SW_HIDE);
        }

      if (aShowWindowBool == TRUE) {
        ShowWindow(hFirstControl, bGotData ? SW_SHOW : SW_HIDE);
        ShowWindow(hSecondControl, bGotData ? SW_SHOW : SW_HIDE);
        }

      if (bGotData == TRUE) {
        bShowField = TRUE;
        //Now we want to form the string to display.
        if (GetMessageFromStringTable(pCurrentEntryDetails->theResourceInsertID,
                                      lppArgs,
                                      resourceStringBuffer,
                                      &resStringBufSize) == ERROR_SUCCESS) {
          if (GetWindowText(hSecondControl, controlBuffer, DIMENSION_OF(controlBuffer)) > 0) {
            if (_tcscmp(controlBuffer, resourceStringBuffer) != 0) {
              SetWindowText(hSecondControl, resourceStringBuffer);
              }
            }
          else {
            SetWindowText(hSecondControl, resourceStringBuffer);
            }
          }
#ifdef _DEBUG
        else {
          //An unexpected error occurred. The number of parameters identified
          //in the resource string and the number passed may not match
          _ASSERT(FALSE);
          }
#endif
        }
      else {
        //Empty the contents of the second control
        SetWindowText(hSecondControl, TEXT(""));
        }
      }
    }//end for

  return(bShowField);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL IsDataOKToDisplay (void);
//
// Description: This function determines how suitable it is to display the
//              UPS status information. The UPS statius information is only
//              accurate if the service is running and communication exists
//              between the UPS service and the UPS. If this is not the
//              case then this function returns FALSE.
//
// Additional Information:
//
// Parameters: None
//
// Return Value: Returns TRUE if it is OK to display UPS status information.
//
BOOL IsDataOKToDisplay (void) {
  BOOL bIsRunning = IsServiceRunning(UPS_SERVICE_NAME);
  DWORD commStatus = 0;
  BOOL bIsCommEstablished = FALSE;
  BOOL bIsDataOK = bIsRunning;

  if (GetUPSDataItemDWORD(eREG_COMM_STATUS, &commStatus) == TRUE) {
    if (commStatus == 1) {
      bIsCommEstablished = TRUE;
      }

    bIsDataOK &= bIsCommEstablished;
    }

  return(bIsDataOK);
  }

//////////////////////////////////////////////////////////////////////////_/_//
//////////////////////////////////////////////////////////////////////////_/_//
// BOOL IsDataUpToDate (void);
//
// Description: If the user changes the vendor, model or COM port then
//              the main UPS page should not display the UPS status
//              information.
//
// Additional Information:
//
// Parameters: None
//
// Return Value: This function returns FALSE if the values currently stored in
//               the registry for vendor, model, or port differs from the
//               "internal" values (that is the value stored in the upsreg
//               buffers, see upsreg.h and upsreg.c).
//
BOOL IsDataUpToDate (void) {
  //if the Vendor or Model Type or Port in the registry differs from
  //upsreg value then the data is out of sync.
  TCHAR vendorBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  DWORD vendorBufferSize = DIMENSION_OF(vendorBuffer);
  TCHAR modelBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  DWORD modelBufferSize = DIMENSION_OF(modelBuffer);
  TCHAR portBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  DWORD portBufferSize = DIMENSION_OF(portBuffer);
  TCHAR vendorOtherBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  TCHAR modelOtherBuffer[MAX_MESSAGE_LENGTH] = TEXT("");
  TCHAR portOtherBuffer[MAX_MESSAGE_LENGTH] = TEXT("");

  GetUPSDataItemString(eREG_VENDOR_NAME, vendorBuffer, &vendorBufferSize);
  GetUPSConfigVendor(vendorOtherBuffer);

  GetUPSDataItemString(eREG_MODEL_TYPE, modelBuffer, &modelBufferSize);
  GetUPSConfigModel(modelOtherBuffer);

  GetUPSDataItemString(eREG_PORT, portBuffer, &portBufferSize);
  GetUPSConfigPort(portOtherBuffer);

  return((_tcscmp(vendorBuffer,     vendorOtherBuffer) == 0) &&
         (_tcscmp(modelOtherBuffer, modelBuffer) == 0) &&
         (_tcscmp(portBuffer,       portOtherBuffer) == 0));
  }


/*******************************************************************************
*
*   IsUpsPresent
*
*   DESCRIPTION:  This function gets called to determine if UPS is present
*                 and should be displayed in a tab.  For now this functions
*                 returns TRUE
*
*   RETURNS:      TRUE if UPS is present, FALSE if UPS is no present
*
*
*******************************************************************************/
BOOLEAN IsUpsPresent(PSYSTEM_POWER_CAPABILITIES pspc)
{
    BOOLEAN         UpsPresent;
    DWORD           dwShowTab;
    TCHAR           szImagePath[MAX_PATH];

    InitUPSConfigBlock();


    if ((ERROR_SUCCESS == GetUPSConfigShowUPSTab(&dwShowTab)) && dwShowTab) {
        UpsPresent = TRUE;

    } else if (pspc->SystemBatteriesPresent) {
        UpsPresent = FALSE;

    } else if (!(ERROR_SUCCESS == GetUPSConfigImagePath(szImagePath))) {
        UpsPresent = TRUE;

    } else if (!_tcsicmp(DEFAULT_CONFIG_IMAGEPATH, szImagePath)) {
        UpsPresent = TRUE;

    } else {
        UpsPresent = FALSE;
    }

    return(UpsPresent);
}


//
// Kill the 1-second update timer.
//
DWORD KillUpdateTimer(HWND hwnd)
{
    if (0 != g_UpdateTimerID)
    {
        KillTimer(hwnd, g_UpdateTimerID);
        g_UpdateTimerID = 0;
    }
    return ERROR_SUCCESS;
}


//
// Create the 1-second update timer.
//
DWORD SetUpdateTimer(HWND hwnd)
{
    DWORD dwResult = ERROR_SUCCESS;

    KillUpdateTimer(hwnd);
    g_UpdateTimerID = SetTimer(hwnd, cUpdateTimerID, 1000, NULL);
    if (0 == g_UpdateTimerID)
    {
        dwResult = GetLastError();
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\parse.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       PARSE.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        1 Jan, 1997
*
*  DESCRIPTION:
*   Helper parsing code for the default power schemes generator, MAKEINI.EXE.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <ntpoapi.h>

#include "parse.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

char *g_pszSrc[MAX_SKUS];
char *g_pszLines[MAX_SKUS][MAX_LINES];

UINT g_uiLineCount;
UINT g_uiPoliciesCount[MAX_SKUS];

PMACHINE_POWER_POLICY       g_pmpp[MAX_SKUS][MAX_PROFILES];
PUSER_POWER_POLICY          g_pupp[MAX_SKUS][MAX_PROFILES];
PMACHINE_PROCESSOR_POWER_POLICY g_ppmpp[MAX_SKUS][MAX_PROFILES];

GLOBAL_USER_POWER_POLICY    g_gupp[MAX_SKUS];
GLOBAL_MACHINE_POWER_POLICY g_gmpp[MAX_SKUS];

char *g_pszSkuNames[MAX_SKUS] = {
    "..\\DEFAULTS.CSV",
    "..\\PER.CSV",
    "..\\PRO.CSV",
    "..\\SRV.CSV",
    "..\\ADS.CSV",
    "..\\DTC.CSV"
};

char g_pszSkuDecoration[MAX_SKUS];

/*******************************************************************************
*
*  StrTrimTrailingBlanks
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void StrTrimTrailingBlanks(char *psz)
{
    UINT i = 0;

    if (psz) {
        while (*psz) {
            psz++;
        }

        while (*--psz == ' ') {
            *psz = '\0';
        }
    }
}

/*******************************************************************************
*
*  StrToUpper
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void StrToUpper(char *pszDest, char *pszSrc)
{
    UINT i = 0;

    while (*pszSrc) {
        *pszDest = (char)toupper(*pszSrc);
        pszSrc++;
        pszDest++;
        if (++i == MAX_STR) {
            DefFatalExit(FALSE, "StrToUpper failure, source too large: %s\n", pszSrc);
        }
    }
    *pszDest = '\0';
}

/*******************************************************************************
*
*  GetTokens
*
*  DESCRIPTION:
*   Fill an array with tokens.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetTokens(
    char    *pszSrc,
    UINT    uiMaxTokenSize,
    char    **pszTokens,
    UINT    uiMaxTokens,
    char    *pszDelimiters
)
{
    char    *psz;
    DWORD   dwSize;
    UINT    i = 0;

    psz = strtok(pszSrc, pszDelimiters);
    StrTrimTrailingBlanks(psz);

    while (psz) {

        if (i % 2) {
            printf(".");
        }
        dwSize = strlen(psz) + 1;
        if (dwSize > uiMaxTokenSize) {
            printf("GetTokens, Token to large: %s\n", psz);
            return 0;
        }
        if ((pszTokens[i] = (char *) malloc(dwSize)) != NULL) {
            strcpy(pszTokens[i], psz);
        }
        else {
            printf("GetTokens, Unable to allocate token buffer: %s\n", psz);
            return 0;
        }
        i++;
        if (i == uiMaxTokens) {
            printf("GetTokens, Too many tokens: %d\n", i);
            return 0;
        }
        psz = strtok(NULL, pszDelimiters);
        StrTrimTrailingBlanks(psz);
    }
    return i;
}

/*******************************************************************************
*
*  GetCheckLabelToken
*
*  DESCRIPTION:
*   Consume a label token. Check to be sure it matches the passed parameter.
*   Call fatal exit if it doesn't. Labels are always comma delimited. Sets up
*   strtok for subsequent calls.
*
*  PARAMETERS:
*   uiLine  - One based line index.
*
*******************************************************************************/

VOID GetCheckLabelToken(UINT uiLine, char *pszCheck, UINT uiSku)
{
    char szUpperCheck[MAX_STR];
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;

    pszTok = strtok(g_pszLines[uiSku][uiLine - 1], DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE, "GetStringTokens failure, out of tokens. Last token: %s\n", szUpperTok);
    }

    StrToUpper(szUpperTok, pszTok);
    StrToUpper(szUpperCheck, pszCheck);

    if (strcmp(szUpperCheck, szUpperTok)) {
        DefFatalExit(FALSE, "GetStringTokens failure, check: %s doesn't match: %s\n",szUpperCheck, szUpperTok);
    }
}

/*******************************************************************************
*
*  GetPowerActionToken
*
*  DESCRIPTION:
*   Consume a token and return a power action.
*
*  PARAMETERS:
*
*******************************************************************************/

POWER_ACTION GetPowerActionToken(VOID)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE,"GetPowerActionToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (!strcmp(szUpperTok, "NONE")) {
        return PowerActionNone;
    }

    if (!strcmp(szUpperTok, "DOZE")) {
        return PowerActionReserved;
    }

    if (!strcmp(szUpperTok, "SLEEP")) {
        return PowerActionSleep;
    }

    if (!strcmp(szUpperTok, "HIBERNATE")) {
        return PowerActionHibernate;
    }

    if (!strcmp(szUpperTok, "SHUTDOWN")) {
        return PowerActionShutdown;
    }

    if (!strcmp(szUpperTok, "SHUTDOWNRESET")) {
        return PowerActionShutdownReset;
    }

    if (!strcmp(szUpperTok, "SHUTDOWNOFF")) {
        return PowerActionShutdownOff;
    }

    DefFatalExit(FALSE,"GetPowerActionToken failure, check: %s doesn't match: \nNONE, DOZE, SLEEP, SHUTDOWN, SHUTDOWNRESET or SHUTDOWNOFF\n", szUpperTok);
    return 0;
}

/*******************************************************************************
*
*  GetFlagToken
*
*  DESCRIPTION:
*   Consume a token and return a flag value.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetFlagToken(UINT uiFlag)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE, "GetFlagToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (!strcmp(szUpperTok, "YES")) {
        return uiFlag;
    }

    if (!strcmp(szUpperTok, "TRUE")) {
        return uiFlag;
    }

    if (!strcmp(szUpperTok, "FALSE")) {
        return 0;
    }

    if (!strcmp(szUpperTok, "NO")) {
        return 0;
    }

    if (!strcmp(szUpperTok, "N/A")) {
        return 0;
    }
    DefFatalExit(FALSE, "GetFlagToken failure, check: %s doesn't match: YES, NO or N/A\n", szUpperTok);
    return 0;
}

/*******************************************************************************
*
*  GetPowerStateToken
*
*  DESCRIPTION:
*   Consume a token and return a power state.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetPowerStateToken(VOID)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE,"GetPowerStateToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (!strcmp(szUpperTok, "S0")) {
        return PowerSystemWorking;
    }
    if (!strcmp(szUpperTok, "S1")) {
        return PowerSystemSleeping1;
    }
    if (!strcmp(szUpperTok, "S2")) {
        return PowerSystemSleeping2;
    }
    if (!strcmp(szUpperTok, "S3")) {
        return PowerSystemSleeping3;
    }
    if (!strcmp(szUpperTok, "S4")) {
        return PowerSystemHibernate;
    }
    if (!strcmp(szUpperTok, "S5")) {
        return PowerSystemShutdown;
    }

    if (!strcmp(szUpperTok, "N/A")) {
        return PowerSystemUnspecified;
    }
    DefFatalExit(FALSE,"GetPowerStateToken failure, check: %s doesn't match: S0, S1, S2, S3, S4 or S5\n", szUpperTok);
    return PowerSystemUnspecified;
}

/*******************************************************************************
*
*  GetINFTypeToken
*
*  DESCRIPTION:
*   Consume a token and return an INF type.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetINFTypeToken(VOID)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;
    UINT uiRet = 0;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE,"GetINFTypeToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);
    if (strstr(szUpperTok, "TYPICALINSTALL")) {
        uiRet |= TYPICAL;
    }
    if (strstr(szUpperTok, "COMPACTINSTALL")) {
        uiRet |= COMPACT;
    }
    if (strstr(szUpperTok, "CUSTOMINSTALL")) {
        uiRet |= CUSTOM;
    }
    if (strstr(szUpperTok, "PORTABLEINSTALL")) {
        uiRet |= PORTABLE;
    }
    if (strstr(szUpperTok, "SERVERINSTALL")) {
        uiRet |= SERVER;
    }

    if (!uiRet) {
        DefFatalExit(FALSE,"GetINFTypeToken failure, check: %s doesn't match install file type\n", szUpperTok);
    }
    return uiRet;
}

/*******************************************************************************
*
*  GetOSTypeToken
*
*  DESCRIPTION:
*   Consume a token and return an OS type.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetOSTypeToken(VOID)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;
    UINT uiRet = 0;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE,"GetOSTypeToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (strstr(szUpperTok, "WIN95")) {
        uiRet |= WIN_95;
    }
    if (strstr(szUpperTok, "NT")) {
        uiRet |= WIN_NT;
    }

    if (!uiRet) {
        DefFatalExit(FALSE,"GetOSTypeToken failure, check: %s doesn't match: WINNT, WIN95\n", szUpperTok);
    }
    return uiRet;
}



/*******************************************************************************
*
*  GetIntToken
*
*  DESCRIPTION:
*   Consume a token and return an integer. Verify the units if passed.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetIntToken(char *pszUnits)
{
    char szUpperUnits[MAX_STR];
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;
    UINT i, uiMult = 1;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE,"GetIntToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (!strcmp(szUpperTok, "N/A")) {
        return 0;
    }

    if (!strcmp(szUpperTok, "DISABLED")) {
        return 0;
    }

    if (pszUnits) {
        StrToUpper(szUpperUnits, pszUnits);

        if (!strcmp(szUpperUnits, "%")) {

            // Percentages are a special case.  Excel sometimes saves
            // 50% as 0.5.
            
            if ((pszUnits = strstr(szUpperTok, szUpperUnits)) != NULL) {

                // Strip off units.
                *pszUnits = '\0';

                if (sscanf(szUpperTok, "%d", &i) == 1) {
                    return i;
                }
            }

            if (*szUpperTok == '1') {
                return 100;
            }

            while ((*pszTok == '0') &&
                   (*(pszTok + 1) == '.')) {

                pszTok += 2;
            }

            // Get the first digit after the decimal.
            i = *pszTok++ - '0';
            i *= 10;

            // if there is a second digit, get that, too.
            if ((*pszTok >= '0') && (*pszTok <= '9')) {
            
                i = i + (*pszTok - '0');
            }

            return i;

        } else {

            if ((pszUnits = strstr(szUpperTok, szUpperUnits)) == NULL) {
                DefFatalExit(FALSE, "GetIntToken failure, units: %s doesn't match: %s\n", szUpperTok, szUpperUnits);
            }

            if (!strcmp(szUpperUnits, "MIN")) {
                uiMult = 60;
            } else if (!strcmp(szUpperUnits, "US")) {
                uiMult = 1;
            } else {
                    DefFatalExit(FALSE, "GetIntToken failure, unknown  units: %s\n", szUpperUnits);
            }
            
            // Strip off units.
            *pszUnits = '\0';
            
            if (sscanf(szUpperTok, "%d", &i) == 1) {
                return i * uiMult;
            }
        }
    }

    DefFatalExit(FALSE,"GetIntToken failure, error converting: %s to integer\n", szUpperTok);
    return 0;
}

/*******************************************************************************
*
*  GetNAToken
*
*  DESCRIPTION:
*   Consume a N/A token.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetNAToken(VOID)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE, "GetNAToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (!strcmp(szUpperTok, "N/A")) {
        return;
    }
    DefFatalExit(FALSE, "GetNAToken failure, check: %s doesn't match: N/A\n", szUpperTok);
}
/*******************************************************************************
*
*  GetThrottleToken
*
*  DESCRIPTION:
*   Consume a N/A token.
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetThrottleToken(VOID)
{
    static char szUpperTok[MAX_STR] = "No last token";
    char *pszTok;

    pszTok = strtok(NULL, DELIMITERS);
    StrTrimTrailingBlanks(pszTok);

    if (!pszTok) {
        DefFatalExit(FALSE, "GetNAToken failure, out of tokens. Last token: %s\n", szUpperTok);
    }
    StrToUpper(szUpperTok, pszTok);

    if (!strcmp(szUpperTok, "NONE")) {
        return PO_THROTTLE_NONE;
    }
    
    if (!strcmp(szUpperTok, "CONSTANT")) {
        return PO_THROTTLE_CONSTANT;
    }
    
    if (!strcmp(szUpperTok, "DEGRADE")) {
        return PO_THROTTLE_DEGRADE;
    }
    
    if (!strcmp(szUpperTok, "ADAPTIVE")) {
        return PO_THROTTLE_ADAPTIVE;
    }
    
    DefFatalExit(FALSE, "GetThrottleToken failure, check: %s doesn't match.\n", szUpperTok);
    return PO_THROTTLE_NONE;
}
/*******************************************************************************
*
*  DefFatalExit
*
*  DESCRIPTION:
*   Print error and exit.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID CDECL DefFatalExit(BOOLEAN bGetLastError, char *pszFormat, ... )
{
    va_list Marker;

    va_start(Marker, pszFormat);
    printf("\n\n");
    vprintf(pszFormat, Marker);
    if (bGetLastError) {
         printf("Last error: %d\n", GetLastError());
    }
    printf("\n\nDefault Processing Failure. Output files are invalid.\n");
    exit(1);
}

/*******************************************************************************
*
*  ReadSource
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ReadSource(void)
{
    HANDLE  fh;
    DWORD   dwSize, dwRead, sku;
    BOOLEAN bRet;

    for (sku = 0; sku < MAX_SKUS; sku++) {
    
        bRet = FALSE;

        fh = CreateFile(g_pszSkuNames[sku], GENERIC_READ,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 0, NULL);

        if (fh != INVALID_HANDLE_VALUE) {

            // Allocate the source buffer.
            if ((dwSize = GetFileSize(fh, NULL)) != INVALID_FILE_SIZE) {
                if ((g_pszSrc[sku] = (char *) malloc(dwSize + 1)) != NULL) {
                    // Read in the file buffer.
                    SetFilePointer(fh, 0, NULL, FILE_BEGIN);
                    if (ReadFile(fh, g_pszSrc[sku], dwSize, &dwRead, NULL)) {
                        printf("ReadSource successful.\n");
                        g_pszSrc[sku][dwSize] = 0;
                        bRet = TRUE;
                    }
                }
            }
            CloseHandle(fh);
        }
        if (!bRet) {
            DefFatalExit(TRUE, "ReadSource failed reading: %s\n", g_pszSkuNames[sku]);
        }
    }
    
    return bRet;
}

/*******************************************************************************
*
*  BuildLineArray
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT BuildLineArray(void)
{
    char    *psz;
    UINT    sku, lineCount;

    for (sku = 0; sku < MAX_SKUS; sku++) {
        printf("\nBuilding the line array.");
        lineCount = GetTokens(g_pszSrc[sku], MAX_LINE_SIZE,
                              g_pszLines[sku], MAX_LINES, LINE_DELIMITERS);
        printf("\nFound %d lines in file %s.\n\n", lineCount, g_pszSrc[sku]);
    }
    return lineCount;
}

/*******************************************************************************
*
*  GetSleepActionFlags
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetSleepActionFlags(
    UINT    uiStartLine,
    UINT    uiFlagsAC[],
    UINT    uiFlagsDC[],
    PUINT   puiCount,
    UINT    sku
)
{
    UINT    i;

    for (i = 0; i < *puiCount; i++) {
        uiFlagsAC[i] = 0;
        uiFlagsDC[i] = 0;
    }
    GetCheckLabelToken(uiStartLine, "Sleep action flags", sku);
    GetCheckLabelToken(uiStartLine+QUERY_APPS, "Query apps", sku);
    for (i = 0; i < *puiCount; i++) {
        uiFlagsAC[i] += GetFlagToken(POWER_ACTION_QUERY_ALLOWED);
        uiFlagsDC[i] += GetFlagToken(POWER_ACTION_QUERY_ALLOWED);
    }
    GetCheckLabelToken(uiStartLine+ALLOW_UI, "Allow UI", sku);
    for (i = 0; i < *puiCount; i++) {
        uiFlagsAC[i] += GetFlagToken(POWER_ACTION_UI_ALLOWED);
        uiFlagsDC[i] += GetFlagToken(POWER_ACTION_UI_ALLOWED);
    }
    GetCheckLabelToken(uiStartLine+IGNORE_NON_RESP, "Ignore non-responsive apps", sku);
    for (i = 0; i < *puiCount; i++) {
        uiFlagsAC[i] += GetFlagToken(POWER_ACTION_OVERRIDE_APPS);
        uiFlagsDC[i] += GetFlagToken(POWER_ACTION_OVERRIDE_APPS);
    }
    GetCheckLabelToken(uiStartLine+IGNORE_WAKE, "Ignore wakeup events", sku);
    for (i = 0; i < *puiCount; i++) {
        uiFlagsAC[i] += GetFlagToken(POWER_ACTION_DISABLE_WAKES);
        uiFlagsDC[i] += GetFlagToken(POWER_ACTION_DISABLE_WAKES);
    }
    GetCheckLabelToken(uiStartLine+IGNORE_CRITICAL, "Critical (go to sleep immediately)", sku);
    for (i = 0; i < *puiCount; i++) {
        uiFlagsAC[i] += GetFlagToken(POWER_ACTION_CRITICAL);
        uiFlagsDC[i] += GetFlagToken(POWER_ACTION_CRITICAL);
    }
}

/*******************************************************************************
*
*  GetSleepActionFlagsGlobal
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetSleepActionFlagsGlobal(
    UINT                    uiStartLine,
    PPOWER_ACTION_POLICY    ppapAC,
    PPOWER_ACTION_POLICY    ppapDC,
    UINT    sku
)
{
    UINT    uiOne = 1;
    UINT    uiFlagsAC[MAX_PROFILES];
    UINT    uiFlagsDC[MAX_PROFILES];

    GetSleepActionFlags(uiStartLine, uiFlagsAC, uiFlagsDC, &uiOne, sku);
    if (ppapAC) {
        ppapAC->Flags = uiFlagsAC[0];
    }
    ppapDC->Flags = uiFlagsDC[0];
}

/*******************************************************************************
*
*  GetSleepActionFlagsPolicy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetSleepActionFlagsUserPolicy(
    UINT    uiStartLine,
    ULONG   ulAcPowerPolicyOffset,
    ULONG   ulDcPowerPolicyOffset,
    PUINT   puiCount,
    UINT    sku
)
{
    UINT    i;
    UINT    uiFlagsAC[MAX_PROFILES];
    UINT    uiFlagsDC[MAX_PROFILES];
    PPOWER_ACTION_POLICY ppap;

    GetSleepActionFlags(uiStartLine, uiFlagsAC, uiFlagsDC, puiCount, sku);
    for (i = 0; i < *puiCount; i++) {

        ppap = (PPOWER_ACTION_POLICY)((BYTE*)(g_pupp[sku][i]) + ulAcPowerPolicyOffset);
        ppap->Flags = uiFlagsAC[i];

        ppap = (PPOWER_ACTION_POLICY)((BYTE*)(g_pupp[sku][i]) + ulDcPowerPolicyOffset);
        ppap->Flags = uiFlagsDC[i];
    }
}

/*******************************************************************************
*
*  GetSleepActionFlagsMachinePolicy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetSleepActionFlagsMachinePolicy(
    UINT    uiStartLine,
    ULONG   ulAcPowerPolicyOffset,
    ULONG   ulDcPowerPolicyOffset,
    PUINT   puiCount,
    UINT    sku
)
{
    UINT    i;
    UINT    uiFlagsAC[MAX_PROFILES];
    UINT    uiFlagsDC[MAX_PROFILES];
    PPOWER_ACTION_POLICY ppap;

    GetSleepActionFlags(uiStartLine, uiFlagsAC, uiFlagsDC, puiCount, sku);
    for (i = 0; i < *puiCount; i++) {
        ppap = (PPOWER_ACTION_POLICY)((BYTE*)(g_pmpp[sku][i]) + ulAcPowerPolicyOffset);
        ppap->Flags = uiFlagsAC[i];

        ppap = (PPOWER_ACTION_POLICY)((BYTE*)(g_pmpp[sku][i]) + ulDcPowerPolicyOffset);
        ppap->Flags = uiFlagsDC[i];
    }
}

VOID GetEventCodes(
    UINT                    uiStartLine,
    PPOWER_ACTION_POLICY    ppapAC,
    PPOWER_ACTION_POLICY    ppapDC,
    UINT                    flagToken,
    UINT                    sku
)
{
    UINT i;

    GetCheckLabelToken(uiStartLine, "Event Code", sku);
    GetCheckLabelToken(uiStartLine+NOTIFY_USER_CODE, "Notify User", sku);
    ppapAC->EventCode += GetFlagToken(flagToken);
    ppapDC->EventCode += GetFlagToken(flagToken);
}

/*******************************************************************************
*
*  GetCStateThresholds
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetCStateThresholds(
    UINT    uiStartLine,
    UINT    uiCState,
    PUINT   puiCount,
    UINT    sku
)
{
    UINT    i;

    uiCState -= 1;

    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.PolicyCount = 3;
        g_ppmpp[sku][i]->ProcessorPolicyDc.PolicyCount = 3;
    }

    GetCheckLabelToken(uiStartLine+C_TIME_CHECK, "Time Check", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].TimeCheck = GetIntToken("us");
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].TimeCheck = GetIntToken("us");
    }
    GetCheckLabelToken(uiStartLine+C_PROMOTE_LIMIT, "Promote Limit", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].PromoteLimit = GetIntToken("us");
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].PromoteLimit = GetIntToken("us");
    }
    GetCheckLabelToken(uiStartLine+C_DEMOTE_LIMIT, "Demote Limit", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].DemoteLimit = GetIntToken("us");
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].DemoteLimit = GetIntToken("us");
    }
    GetCheckLabelToken(uiStartLine+C_PROMOTE_PERCENT, "Promote Percent", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].PromotePercent = (UCHAR)GetIntToken("%");
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].PromotePercent = (UCHAR)GetIntToken("%");
    }
    GetCheckLabelToken(uiStartLine+C_DEMOTE_PERCENT, "Demote Percent", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].DemotePercent = (UCHAR)GetIntToken("%");
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].DemotePercent = (UCHAR)GetIntToken("%");
    }
    GetCheckLabelToken(uiStartLine+C_ALLOW_PROMOTION, "Allow Promotion", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].Reserved = 0;
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].AllowPromotion = GetFlagToken(TRUE);
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].AllowPromotion = GetFlagToken(TRUE);
    }
    GetCheckLabelToken(uiStartLine+C_ALLOW_DEMOTION, "Allow Demotion", sku);
    for (i = 0; i < *puiCount; i++) {
        g_ppmpp[sku][i]->ProcessorPolicyAc.Policy[uiCState].AllowDemotion = GetFlagToken(TRUE);
        g_ppmpp[sku][i]->ProcessorPolicyDc.Policy[uiCState].AllowDemotion = GetFlagToken(TRUE);
    }
}
/*******************************************************************************
*
*  GetDischargePolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID GetDischargePolicies(
    UINT uiLine,
    UINT uiNum,
    UINT uiIndex,
    UINT    sku
)
{
    UINT    i, uiOne = 1;
    char szLabel[] = "Discharge Policy 1";

    sprintf(szLabel, "Discharge Policy %d", uiNum);
    GetCheckLabelToken(uiLine, szLabel, sku);

    GetCheckLabelToken(uiLine+DP_ENABLE, "Enable", sku);
    GetNAToken();
    g_gupp[sku].DischargePolicy[uiIndex].Enable = (BOOLEAN)GetFlagToken(TRUE);

    GetCheckLabelToken(uiLine+DP_BAT_LEVEL, "Battery Level", sku);
    GetNAToken();
    g_gupp[sku].DischargePolicy[uiIndex].BatteryLevel = GetIntToken("%");

    GetCheckLabelToken(uiLine + DP_POWER_POLICY, "Power Policy", sku);
    GetNAToken();
    g_gupp[sku].DischargePolicy[uiIndex].PowerPolicy.Action = GetPowerActionToken();

    GetCheckLabelToken(uiLine + DP_MIN_SLEEP_STATE, "Min system sleep state", sku);
    GetNAToken();
    g_gupp[sku].DischargePolicy[uiIndex].MinSystemState = GetPowerStateToken();

    GetCheckLabelToken(uiLine + DP_TEXT_NOTIFY, "Text Notify", sku);
    GetNAToken();
    g_gupp[sku].DischargePolicy[uiIndex].PowerPolicy.EventCode =
        GetFlagToken(POWER_LEVEL_USER_NOTIFY_TEXT);
    GetCheckLabelToken(uiLine+DP_SOUND_NOTIFY, "Sound Notify", sku);
    GetNAToken();
    g_gupp[sku].DischargePolicy[uiIndex].PowerPolicy.EventCode |=
        GetFlagToken(POWER_LEVEL_USER_NOTIFY_SOUND);

    GetSleepActionFlagsGlobal(uiLine + DP_SLEEP_ACT_FLAGS, NULL,
                              &(g_gupp[sku].DischargePolicy[uiIndex].PowerPolicy), sku);

    printf("  Parsed %s\n", szLabel);
}

/*******************************************************************************
*
*  GetGlobalPolicies
*
*  DESCRIPTION:
*   Parse the global policies into the USER: and HKEY_LOCAL_MACHINE global
*   power policies structures.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetGlobalPolicies(void)
{
    UINT    i, uiOne = 1, sku;

    for (sku = 0; sku < MAX_SKUS; sku++) {
        
        printf("Parsing global power policies\n");

        // Set both User and Local Machine revision levels
        g_gupp[sku].Revision = DATA_REV;
        g_gmpp[sku].Revision = DATA_REV;

        //**********************************************************************
        // Advanced
        //**********************************************************************
        GetCheckLabelToken(ADVANCED_LINE, "Advanced", sku);
        GetCheckLabelToken(LOCK_ON_SLEEP_LINE, "Lock Workstation", sku);
        g_gupp[sku].GlobalFlags = GetFlagToken(EnablePasswordLogon);
        if (g_gupp[sku].GlobalFlags != GetFlagToken(EnablePasswordLogon)) {
                DefFatalExit(FALSE,"AC and DC Lock Workstation entries don't match");
        }

        GetCheckLabelToken(WAKE_ON_RING_LINE, "Wake on Ring", sku);
        g_gupp[sku].GlobalFlags |= GetFlagToken(EnableWakeOnRing);
        if ((g_gupp[sku].GlobalFlags & EnableWakeOnRing) !=
            GetFlagToken(EnableWakeOnRing)) {
                DefFatalExit(FALSE,"AC and DC Wake on Ring entries don't match");
        }

        GetCheckLabelToken(VIDEO_DIM_DISPLAY_LINE, "Video Dim Display on DC", sku);
        GetFlagToken(0);
        g_gupp[sku].GlobalFlags |= GetFlagToken(EnableVideoDimDisplay);

        //**********************************************************************
        // Power button
        //**********************************************************************
        GetCheckLabelToken(POWER_BUTTON_LINE, "Power button", sku);

        g_gupp[sku].PowerButtonAc.Action = GetPowerActionToken();
        g_gupp[sku].PowerButtonDc.Action = GetPowerActionToken();
        GetSleepActionFlagsGlobal(POWER_BUTTON_SLEEP_ACTION_FLAGS_LINE,
                                  &(g_gupp[sku].PowerButtonAc),
                                  &(g_gupp[sku].PowerButtonDc),
                                  sku);
        
        GetEventCodes(POWER_BUTTON_SLEEP_EVENT_CODE_LINE, 
                      &(g_gupp[sku].PowerButtonAc),
                      &(g_gupp[sku].PowerButtonDc),
                      POWER_USER_NOTIFY_BUTTON,
                      sku);

        printf("  Parsed Power Button Policies\n");

        //**********************************************************************
        // Sleep button
        //**********************************************************************
        GetCheckLabelToken(SLEEP_BUTTON_LINE, "Sleep button", sku);

        g_gupp[sku].SleepButtonAc.Action = GetPowerActionToken();
        g_gupp[sku].SleepButtonDc.Action = GetPowerActionToken();
        GetSleepActionFlagsGlobal(SLEEP_BUTTON_SLEEP_ACTION_FLAGS_LINE,
                                  &(g_gupp[sku].SleepButtonAc),
                                  &(g_gupp[sku].SleepButtonDc),
                                  sku);
        GetEventCodes(SLEEP_BUTTON_SLEEP_EVENT_CODE_LINE, 
                      &(g_gupp[sku].PowerButtonAc),
                      &(g_gupp[sku].PowerButtonDc),
                      POWER_USER_NOTIFY_BUTTON,
                      sku);

        printf("  Parsed Sleep Button Policies\n");

        //**********************************************************************
        // Lid Closed
        //**********************************************************************
        GetCheckLabelToken(LID_CLOSE_LINE, "Lid close", sku);
        g_gupp[sku].LidCloseAc.Action = GetPowerActionToken();
        g_gupp[sku].LidCloseDc.Action = GetPowerActionToken();
        GetSleepActionFlagsGlobal(LID_CLOSE_SLEEP_ACTION_FLAGS_LINE,
                                  &(g_gupp[sku].LidCloseAc),
                                  &(g_gupp[sku].LidCloseDc),
                                  sku);
        printf("  Parsed Lid Close Policies\n");

        //**********************************************************************
        // Lid Open Wake
        //**********************************************************************
        GetCheckLabelToken(LID_OPEN_WAKE_LINE, "Lid Open Wake", sku);
        g_gmpp[sku].LidOpenWakeAc = GetPowerStateToken();
        g_gmpp[sku].LidOpenWakeDc = GetPowerStateToken();
        printf("  Parsed Lid Open Wake Policies\n");

        //**********************************************************************
        // Battery Policies
        //**********************************************************************
        GetCheckLabelToken(BROADCAST_CAP_RES_LINE, "Broadcast capacity resolution", sku);
        GetIntToken(NULL);
        g_gmpp[sku].BroadcastCapacityResolution = GetIntToken("%");
        GetCheckLabelToken(BATMETER_ENABLE_SYSTRAY_FLAG_LINE, "Force Systray Battery Meter", sku);
        g_gupp[sku].GlobalFlags |= GetFlagToken(EnableSysTrayBatteryMeter);
        GetFlagToken(0);
        GetCheckLabelToken(BATMETER_ENABLE_MULTI_FLAG_LINE, "Enable Multi-Battery Display", sku);
        GetFlagToken(0);
        g_gupp[sku].GlobalFlags |= GetFlagToken(EnableMultiBatteryDisplay);
        printf("  Parsed Battery Policies\n");

        //**********************************************************************
        // Discharge Policies 1, Low Battery
        //**********************************************************************
        GetDischargePolicies(DISCHARGE_POLICY_1_LINE, 1, DISCHARGE_POLICY_LOW, sku);

        //**********************************************************************
        // Discharge Policies 2, Critical Battery
        //**********************************************************************
        GetDischargePolicies(DISCHARGE_POLICY_2_LINE, 2, DISCHARGE_POLICY_CRITICAL, sku);

    }
    
    return TRUE;
}

/*******************************************************************************
*
*  GetPolicies
*
*  DESCRIPTION:
*   Parse the power policies into the USER: and HKEY_LOCAL_MACHINE global
*   power policies structures arrays.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetPolicies(void)
{
    UINT    i, sku;
    BOOLEAN bRet = FALSE;

    for (sku = 0; sku < MAX_SKUS; sku++) {
    
        printf("Processing SKU# %d\n\n", sku);
        
        printf("Parsing power policies\n");

        // First get a place to put the data.
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i] = (PUSER_POWER_POLICY)malloc(sizeof(USER_POWER_POLICY));
            g_pmpp[sku][i] = (PMACHINE_POWER_POLICY)malloc(sizeof(MACHINE_POWER_POLICY));
            g_ppmpp[sku][i] = (PMACHINE_PROCESSOR_POWER_POLICY)malloc(sizeof(MACHINE_PROCESSOR_POWER_POLICY));
            if (!g_pupp[sku][i] || !g_pmpp[sku][i] || !g_ppmpp[sku][i]) {
                goto gp_leave;
            }

            FillMemory(g_pupp[sku][i], sizeof(USER_POWER_POLICY), 0);
            FillMemory(g_pmpp[sku][i], sizeof(MACHINE_POWER_POLICY), 0);
            FillMemory(g_ppmpp[sku][i], sizeof(MACHINE_PROCESSOR_POWER_POLICY), 0);
        }

        // Initialize revision data.
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->Revision = DATA_REV;
            g_pmpp[sku][i]->Revision = DATA_REV;
            g_ppmpp[sku][i]->Revision = DATA_REV;
        }

        printf("  Allocated policies\n");

        //**********************************************************************
        // System Idle
        //**********************************************************************
        GetCheckLabelToken(SYSTEM_IDLE_LINE, "Idle action", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->IdleAc.Action = GetPowerActionToken();
            g_pupp[sku][i]->IdleDc.Action = GetPowerActionToken();
        }
        GetCheckLabelToken(SYSTEM_IDLE_TIMEOUT_LINE, "Idle timeout", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->IdleTimeoutAc = GetIntToken("MIN");
            g_pupp[sku][i]->IdleTimeoutDc = GetIntToken("MIN");
        }
        GetSleepActionFlagsUserPolicy(SYSTEM_IDLE_SLEEP_ACTION_FLAGS_LINE,
                                      FIELD_OFFSET(USER_POWER_POLICY, IdleAc),
                                      FIELD_OFFSET(USER_POWER_POLICY, IdleDc),
                                      &g_uiPoliciesCount[sku],
                                      sku);
        GetCheckLabelToken(SYSTEM_IDLE_SENSITIVITY_LINE, "Idle sensitivity", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->IdleSensitivityAc = (UCHAR)GetIntToken("%");
            g_pupp[sku][i]->IdleSensitivityDc = (UCHAR)GetIntToken("%");
        }
        printf("  Parsed System Idle Policies\n");

        //**********************************************************************
        // Sleep Policies
        //**********************************************************************
        GetCheckLabelToken(MIN_SLEEP_LINE, "Minimum sleep", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pmpp[sku][i]->MinSleepAc = GetPowerStateToken();
            g_pmpp[sku][i]->MinSleepDc = GetPowerStateToken();
        }
        GetCheckLabelToken(MAX_SLEEP_LINE, "Max sleep", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->MaxSleepAc = GetPowerStateToken();
            g_pupp[sku][i]->MaxSleepDc = GetPowerStateToken();
        }
        GetCheckLabelToken(REDUCED_LATENCY_SLEEP_LINE, "Reduced latency sleep", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pmpp[sku][i]->ReducedLatencySleepAc = GetPowerStateToken();
            g_pmpp[sku][i]->ReducedLatencySleepDc = GetPowerStateToken();
        }
        GetCheckLabelToken(DOZE_TIMEOUT_LINE, "Doze timeout", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pmpp[sku][i]->DozeTimeoutAc = GetIntToken("MIN");
            g_pmpp[sku][i]->DozeTimeoutDc = GetIntToken("MIN");
        }
        GetCheckLabelToken(DOZE_S4_TIMEOUT_LINE, "DozeS4Timeout", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pmpp[sku][i]->DozeS4TimeoutAc = GetIntToken("MIN");
            g_pmpp[sku][i]->DozeS4TimeoutDc = GetIntToken("MIN");
        }

        printf("  Parsed Sleep Policies\n");

        //**********************************************************************
        // Device Power Management
        //**********************************************************************
        GetCheckLabelToken(VIDEO_TIMEOUT_LINE, "Video timeout", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->VideoTimeoutAc = GetIntToken("MIN");
            g_pupp[sku][i]->VideoTimeoutDc = GetIntToken("MIN");
        }
        GetCheckLabelToken(SPINDOWN_TIMEOUT_LINE, "Spindown timeout", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->SpindownTimeoutAc = GetIntToken("MIN");
            g_pupp[sku][i]->SpindownTimeoutDc = GetIntToken("MIN");
        }
        printf("  Parsed Device Power Management Policies\n");


        //**********************************************************************
        // CPU Policies
        //**********************************************************************
        GetCheckLabelToken(OPTIMIZE_FOR_POWER_LINE, "Optimize for power", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->OptimizeForPowerAc = (BOOLEAN)GetFlagToken(TRUE);
            g_pupp[sku][i]->OptimizeForPowerDc = (BOOLEAN)GetFlagToken(TRUE);
        }
        GetCheckLabelToken(FAN_THROTTLE_TOL_LINE, "Fan throttle Tolerance", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->FanThrottleToleranceAc = (UCHAR)GetIntToken("%");
            g_pupp[sku][i]->FanThrottleToleranceDc = (UCHAR)GetIntToken("%");
        }
        GetCheckLabelToken(FORCED_THROTTLE_LINE, "Forced throttle", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pupp[sku][i]->ForcedThrottleAc = (UCHAR)GetIntToken("%");
            g_pupp[sku][i]->ForcedThrottleDc = (UCHAR)GetIntToken("%");
        }
        GetCheckLabelToken(MIN_THROTTLE_LINE, "Min throttle", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pmpp[sku][i]->MinThrottleAc = (UCHAR)GetIntToken("%");
            g_pmpp[sku][i]->MinThrottleDc = (UCHAR)GetIntToken("%");
        }
        GetCheckLabelToken(OVERTHROTTLED_LINE, "Overthrottled", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_pmpp[sku][i]->OverThrottledAc.Action = GetPowerActionToken();
            g_pmpp[sku][i]->OverThrottledDc.Action = GetPowerActionToken();
        }
        GetSleepActionFlagsMachinePolicy(OVERTHROTTLED_SLEEP_ACTION_FLAGS_LINE,
                                         FIELD_OFFSET(MACHINE_POWER_POLICY, OverThrottledAc),
                                         FIELD_OFFSET(MACHINE_POWER_POLICY, OverThrottledDc),
                                         &g_uiPoliciesCount[sku],
                                         sku);

        //
        // Processor Policies
        //



        GetCheckLabelToken(DYNAMIC_THROTTLE_LINE, "Dynamic Throttle", sku);
        for (i = 0; i < g_uiPoliciesCount[sku]; i++) {
            g_ppmpp[sku][i]->ProcessorPolicyAc.Revision = 1;
            g_ppmpp[sku][i]->ProcessorPolicyDc.Revision = 1;
            g_ppmpp[sku][i]->ProcessorPolicyAc.DynamicThrottle = g_pupp[sku][i]->ThrottlePolicyAc = (UCHAR)GetThrottleToken();
            g_ppmpp[sku][i]->ProcessorPolicyDc.DynamicThrottle = g_pupp[sku][i]->ThrottlePolicyDc = (UCHAR)GetThrottleToken();
        }

        GetCStateThresholds(C1_THRESHOLDS_LINE, 1, &g_uiPoliciesCount[sku], sku);
        GetCStateThresholds(C2_THRESHOLDS_LINE, 2, &g_uiPoliciesCount[sku], sku);
        GetCStateThresholds(C3_THRESHOLDS_LINE, 3, &g_uiPoliciesCount[sku], sku);

        printf("  Parsed CPU Policies\n");
    }
    

    bRet = TRUE;
    printf("Parsing power policies success!\n\n");

gp_leave:
    if (!bRet) {
        printf("GetPolicies failed, Last Error: %d\n", GetLastError());
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\reghelp.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       REGHELP.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <regstr.h>
#include <commctrl.h>

#include <ntpoapi.h>

#include "powrprofp.h"
#include "reghelp.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern HINSTANCE   g_hInstance;        // Global instance handle of this DLL.
extern HANDLE      g_hSemRegistry;     // Registry semaphore.
extern UINT        g_uiLastID;         // The last ID value used, per machine.

extern TCHAR c_szREGSTR_PATH_MACHINE_POWERCFG[];
extern TCHAR c_szREGSTR_VAL_LASTID[];

// Global semaphore name.
const TCHAR c_szSemRegistry[] = TEXT("PowerProfileRegistrySemaphore");


/*******************************************************************************
*
*  OpenCurrentUser
*
*  DESCRIPTION:
*   
*  PARAMETERS:
*
*******************************************************************************/

DWORD OpenCurrentUser2(PHKEY phKey)
{
#ifdef WINNT

    // Since powerprof can be called in the Winlogon context when
    // a user is being impersonated, use RegOpenCurrentUser to get HKCU.
    LONG lRet = RegOpenCurrentUser(KEY_ALL_ACCESS, phKey);
    if (lRet != ERROR_SUCCESS)
    {
        DebugPrint("RegOpenCurrentUser, failed, LastError: 0x%08X", lRet);
    }

    return lRet;

#else
    *phKey = HKEY_CURRENT_USER;
    return ERROR_SUCCESS; 
#endif
}


BOOLEAN OpenCurrentUser(PHKEY phKey)
{
    DWORD dwError = OpenCurrentUser2(phKey);
    BOOLEAN fSucceeded = TRUE;
    
    if (ERROR_SUCCESS != dwError)
    {
        fSucceeded = FALSE;
        SetLastError(dwError);
    }

    return fSucceeded;
}



/*******************************************************************************
*
*  CloseCurrentUser
*
*  DESCRIPTION:
*   
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN CloseCurrentUser(HKEY hKey)
{
#ifdef WINNT
    RegCloseKey(hKey);
#endif
    return TRUE;
}

/*******************************************************************************
*
*  OpenMachineUserKeys
*
*  DESCRIPTION:
*   
*  PARAMETERS:
*
*******************************************************************************/

DWORD OpenMachineUserKeys2(
    LPTSTR  lpszUserKeyName,
    LPTSTR  lpszMachineKeyName,
    PHKEY   phKeyUser,
    PHKEY   phKeyMachine
)
{
    HKEY hKeyCurrentUser;
    DWORD dwError = OpenCurrentUser2(&hKeyCurrentUser);

    if (ERROR_SUCCESS == dwError)  // Sets Last Error
    {
        dwError = RegOpenKey(hKeyCurrentUser, lpszUserKeyName, phKeyUser);
        if (dwError == ERROR_SUCCESS)
        {
            dwError = RegOpenKey(HKEY_LOCAL_MACHINE, lpszMachineKeyName, phKeyMachine);
            if (dwError == ERROR_SUCCESS)
            {
                CloseCurrentUser(hKeyCurrentUser);
                return dwError;
            }
            else
            {
                DebugPrint("OpenMachineUserKeys, failure opening  HKEY_LOCAL_MACHINE\\%s", lpszMachineKeyName);
            }

            RegCloseKey(*phKeyUser);
        }
        else
        {
            DebugPrint("OpenMachineUserKeys, failure opening HKEY_CURRENT_USER\\%s", lpszUserKeyName);
        }

        CloseCurrentUser(hKeyCurrentUser);
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

    DebugPrint("OpenMachineUserKeys, failed, LastError: 0x%08X", dwError);
    return dwError;
}


BOOLEAN OpenMachineUserKeys(
    LPTSTR  lpszUserKeyName,
    LPTSTR  lpszMachineKeyName,
    PHKEY   phKeyUser,
    PHKEY   phKeyMachine)
{
    DWORD dwError = OpenMachineUserKeys2(lpszUserKeyName, lpszMachineKeyName, phKeyUser, phKeyMachine);
    BOOLEAN fSucceeded = TRUE;
    
    if (ERROR_SUCCESS != dwError)
    {
        fSucceeded = FALSE;
        SetLastError(dwError);
    }

    return fSucceeded;
}


/*******************************************************************************
*
*  OpenPathKeys
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

DWORD OpenPathKeys(
    LPTSTR  lpszUserKeyName,
    LPTSTR  lpszMachineKeyName,
    LPTSTR  lpszSchemeName,
    PHKEY   phKeyUser,
    PHKEY   phKeyMachine,
    BOOLEAN bMustExist,
    REGSAM  sam
)
{
    HKEY     hKeyUser, hKeyMachine;

    DWORD dwError = OpenMachineUserKeys2(lpszUserKeyName, lpszMachineKeyName, &hKeyUser, &hKeyMachine);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwDisposition;

        dwError = RegCreateKeyEx(hKeyUser, lpszSchemeName, 0, TEXT(""), REG_OPTION_NON_VOLATILE, sam, NULL, phKeyUser, &dwDisposition);
        if (dwError == ERROR_SUCCESS)
        {
            if (!bMustExist || (dwDisposition == REG_OPENED_EXISTING_KEY))
            {
                dwError = RegCreateKeyEx(hKeyMachine,
                                           lpszSchemeName,
                                           0,
                                           TEXT(""),
                                           REG_OPTION_NON_VOLATILE,
                                           sam,
                                           NULL,
                                           phKeyMachine,
                                           &dwDisposition);
                if (dwError == ERROR_SUCCESS)
                {
                    if (!bMustExist ||
                        (dwDisposition == REG_OPENED_EXISTING_KEY))
                    {
                        // This is the success case.
                    }
                    else
                    {
                        dwError = ERROR_ACCESS_DENIED;
                    }
                }
                else
                {
                   RegCloseKey(*phKeyUser);
                   DebugPrint("OpenPathKeys, unable to create machine key %s\\%s", lpszMachineKeyName, lpszSchemeName);
                }
            }
            else
            {
                dwError = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
           DebugPrint("OpenPathKeys, unable to create user key %s\\%s", lpszUserKeyName, lpszSchemeName);
        }

        RegCloseKey(hKeyUser);
        RegCloseKey(hKeyMachine);

        if (ERROR_SUCCESS != dwError)
        {
            DebugPrint("OpenPathKeys, failed, LastError: 0x%08X", dwError);
        }
    }

    return dwError;
}

PACL    BuildSemaphoreACL (void)

//  2000-06-22 vtan:
//
//  This function builds an ACL which allows everybody access to the named
//  semaphore for SYNCHRONIZE | READ_CONTROL | SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE.
//  It gives full access for the local SYSTEM or members of the local administrators
//  group. If something goes wrong the return result is NULL and no security descriptor
//  is built then.

{
    static  SID_IDENTIFIER_AUTHORITY    worldSIDAuthority       =   SECURITY_WORLD_SID_AUTHORITY;
    static  SID_IDENTIFIER_AUTHORITY    securityNTAuthority     =   SECURITY_NT_AUTHORITY;

    PSID        pSIDWorld;
    PACL        pACL;

    pACL = NULL;
    if (AllocateAndInitializeSid(&worldSIDAuthority,
                                 1,
                                 SECURITY_WORLD_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSIDWorld) != FALSE)
    {
        PSID    pSIDLocalSystem;

        if (AllocateAndInitializeSid(&securityNTAuthority,
                                     1,
                                     SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pSIDLocalSystem) != FALSE)
        {
            PSID    pSIDLocalAdministrators;

            if (AllocateAndInitializeSid(&securityNTAuthority,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_ADMINS,
                                         0, 0, 0, 0, 0, 0,
                                         &pSIDLocalAdministrators) != FALSE)
            {
                DWORD       dwACLSize;

                dwACLSize = sizeof(ACL) +
                            ((sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)) * 3) +
                            GetLengthSid(pSIDWorld) +
                            GetLengthSid(pSIDLocalSystem) +
                            GetLengthSid(pSIDLocalAdministrators);
                pACL = (PACL)LocalAlloc(LMEM_FIXED, dwACLSize);
                if (pACL != NULL)
                {
                    if ((InitializeAcl(pACL, dwACLSize, ACL_REVISION) == FALSE) ||
                        (AddAccessAllowedAce(pACL,
                                             ACL_REVISION,
                                             SYNCHRONIZE | READ_CONTROL | SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE,
                                             pSIDWorld) == FALSE) ||
                        (AddAccessAllowedAce(pACL,
                                             ACL_REVISION,
                                             SEMAPHORE_ALL_ACCESS,
                                             pSIDLocalSystem) == FALSE) ||
                        (AddAccessAllowedAce(pACL,
                                             ACL_REVISION,
                                             SEMAPHORE_ALL_ACCESS,
                                             pSIDLocalAdministrators) == FALSE))
                    {
                        (HLOCAL)LocalFree(pACL);
                        pACL = NULL;
                    }
                }
                (PVOID)FreeSid(pSIDLocalAdministrators);
            }
            (PVOID)FreeSid(pSIDLocalSystem);
        }
        (PVOID)FreeSid(pSIDWorld);
    }
    return(pACL);
}


/*******************************************************************************
*
*  CreateRegSemaphore
*
*  DESCRIPTION: Attempts to open/create the registry semaphore. g_hSemRegistry
*               is initialized on success.
*
*  PARAMETERS:  None
*
*******************************************************************************/

BOOLEAN CreateRegSemaphore(VOID)
{
    HANDLE Semaphore=NULL;

    // First try to open the named semaphore with only required access.

    // NOTE: the named object is per terminal server session. Therefore
    // this semaphore is really bogus because it protects HKEY_LOCAL_MACHINE
    // as well as HKEY_CURRENT_USER. Making it "Global\" is very dangerous
    // and you don't know the side effects without complete retesting.
    // Not worth it.

    Semaphore = OpenSemaphore(SYNCHRONIZE | SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE,
                              FALSE,
                              c_szSemRegistry);
    if ((Semaphore == NULL) && (GetLastError() != ERROR_ACCESS_DENIED))
    {
        SECURITY_ATTRIBUTES     securityAttributes, *pSA;
        SECURITY_DESCRIPTOR     securityDescriptor;
        PACL                    pACL;

        // If this fails then create the semaphore and ACL it so that everybody
        // can get SYNCHRONIZE | SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE
        // access. This allows a service (such as UPS) running in the SYSTEM context
        // to grant limited access to anybody who needs it to synchronize against
        // this semaphore. It also prevents C2 violation by NOT putting a NULL
        // DACL on the named semaphore. If an ACL for the semaphore cannot be
        // built then no security descriptor is given and the default ACL is used.

        pSA = NULL;
        pACL = BuildSemaphoreACL();
        if (pACL != NULL)
        {
            if ((InitializeSecurityDescriptor(&securityDescriptor, SECURITY_DESCRIPTOR_REVISION) != FALSE) &&
                (SetSecurityDescriptorDacl(&securityDescriptor, TRUE, pACL, FALSE) != FALSE))
            {
                securityAttributes.nLength = sizeof(securityAttributes);
                securityAttributes.bInheritHandle = FALSE;
                securityAttributes.lpSecurityDescriptor = &securityDescriptor;
                pSA = &securityAttributes;
            }
        }

        // Create the registry semaphore.
        Semaphore = CreateSemaphore(pSA, 1, 1, c_szSemRegistry);

        if (pACL != NULL)
        {
            (HLOCAL)LocalFree(pACL);
        }
    }

    //
    // If we successfully opened a handle, update the global g_hSemRegistry now
    //
    if (Semaphore) {
        if (InterlockedCompareExchangePointer(&g_hSemRegistry, Semaphore, NULL) != NULL) {
            CloseHandle(Semaphore);
        }
        return(TRUE);
    } else {
        return(FALSE);
    }

}

/*******************************************************************************
*
*  TakeRegSemaphore
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN TakeRegSemaphore(VOID)
{
    if (g_hSemRegistry == NULL) {
        if (!CreateRegSemaphore()) {
            return FALSE;
        }
    }
    if (WaitForSingleObject(g_hSemRegistry, SEMAPHORE_TIMEOUT) != WAIT_OBJECT_0) {
        ReleaseSemaphore(g_hSemRegistry, 1, NULL);
        DebugPrint("WaitForSingleObject, failed");
        SetLastError(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return TRUE;
}

/*******************************************************************************
*
*  ReadPowerValueOptional
*
*  DESCRIPTION:
*   Value may not exist.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ReadPowerValueOptional(
    HKEY    hKey,
    LPTSTR  lpszPath,
    LPTSTR  lpszValueName,
    LPTSTR  lpszValue,
    LPDWORD lpdwSize
)
{
    HKEY     hKeyPath;
    BOOLEAN  bRet = FALSE;
    DWORD    dwSize;
    LONG     lRet;

    if ((lRet = RegOpenKey(hKey,
                           lpszPath,
                           &hKeyPath)) != ERROR_SUCCESS) {
        goto RPVO_exit;
    }

    if ((lRet = RegQueryValueEx(hKeyPath,
                                lpszValueName,
                                NULL,
                                NULL,
                                (PBYTE) lpszValue,
                                lpdwSize)) == ERROR_SUCCESS) {
            bRet = TRUE;
    }

    RegCloseKey(hKeyPath);

RPVO_exit:
    return bRet;
}

/*******************************************************************************
*
*  ReadPowerIntOptional
*
*  DESCRIPTION:
*   Integer value may not exist.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ReadPowerIntOptional(
    HKEY    hKey,
    LPTSTR  lpszPath,
    LPTSTR  lpszValueName,
    PINT    piVal
)
{
    HKEY     hKeyPath;
    BOOLEAN  bRet = FALSE;
    DWORD    dwSize;
    TCHAR    szNum[NUM_DEC_DIGITS];
    LONG     lRet;

    if ((lRet = RegOpenKey(hKey,
                           lpszPath,
                           &hKeyPath)) != ERROR_SUCCESS) {
        goto RPVO_exit;
    }

    dwSize = sizeof(szNum);
    if ((lRet = RegQueryValueEx(hKeyPath,
                                lpszValueName,
                                NULL,
                                NULL,
                                (PBYTE) szNum,
                                &dwSize)) == ERROR_SUCCESS) {
        if (MyStrToInt(szNum, piVal)) {
            bRet = TRUE;
        }
    }

    RegCloseKey(hKeyPath);

RPVO_exit:
    return bRet;
}

/*******************************************************************************
*
*  CreatePowerValue
*
*  DESCRIPTION:
*   Value may not exist.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN CreatePowerValue(
    HKEY    hKey,
    LPCTSTR  lpszPath,
    LPCTSTR  lpszValueName,
    LPCTSTR  lpszValue
)
{
   DWORD    dwDisposition, dwDescSize;
   HKEY     hKeyPath;
   BOOLEAN  bRet = FALSE;
   DWORD    dwSize;
   LONG     lRet;
    
    // Wait on/take the registry semaphore.
    if (!TakeRegSemaphore())        // Will SetLastError
    {
        return FALSE;
    }

    if ((lRet = RegCreateKeyEx(hKey,
                               lpszPath,
                               0,
                               TEXT(""),
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               NULL,
                               &hKeyPath,
                               &dwDisposition)) == ERROR_SUCCESS)
    {
       if (lpszValue)
       {
           dwSize = (lstrlen(lpszValue) + 1) * sizeof(TCHAR);
           if ((lRet = RegSetValueEx(hKeyPath,
                                     lpszValueName,
                                     0,
                                     REG_SZ,
                                     (PBYTE) lpszValue,
                                     dwSize)) == ERROR_SUCCESS)
           {
               bRet = TRUE;
           }
       }
       else
       {
           lRet = ERROR_INVALID_PARAMETER;
       }

       RegCloseKey(hKeyPath);
    }
    
    if (!bRet)
    {
       SetLastError(lRet);
    }

    ReleaseSemaphore(g_hSemRegistry, 1, NULL);
    return bRet;
}


/*******************************************************************************
*
*  ReadWritePowerValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ReadWritePowerValue(
    HKEY    hKey,
    LPTSTR  lpszPath,
    LPTSTR  lpszValueName,
    LPTSTR  lpszValue,
    LPDWORD lpdwSize,
    BOOLEAN bWrite,
    BOOLEAN bTakeSemaphore
)
{
    // This function will set the Last Error correctly on failure
    HKEY     hKeyPath;
    BOOLEAN  bRet = FALSE;
    DWORD    dwSize;
    LONG     lRet;

    if ((lRet = RegOpenKey(hKey,
                           lpszPath,
                           &hKeyPath)) != ERROR_SUCCESS)
    {
        goto RWPV_exit;
    }

    // Wait on/take the registry semaphore.
    if (bTakeSemaphore)
    {
        if (!TakeRegSemaphore())        // Will Set last error
        {
            return FALSE;
        }
    }

    if (bWrite)
    {
        // Write current case.
        if (lpszValue)
        {
            dwSize = (lstrlen(lpszValue) + 1) * sizeof(TCHAR);
            if ((lRet = RegSetValueEx(hKeyPath,
                                      lpszValueName,
                                      0,
                                      REG_SZ,
                                      (PBYTE) lpszValue,
                                      dwSize)) == ERROR_SUCCESS)
            {
                bRet = TRUE;
            }
        }
        else
        {
            lRet = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // Read current case.
        if ((lRet = RegQueryValueEx(hKeyPath,
                                    lpszValueName,
                                    NULL,
                                    NULL,
                                    (PBYTE) lpszValue,
                                    lpdwSize)) == ERROR_SUCCESS)
        {
            bRet = TRUE;
        }
    }

    if (bTakeSemaphore)
    {
        ReleaseSemaphore(g_hSemRegistry, 1, NULL);
    }
    RegCloseKey(hKeyPath);

RWPV_exit:
    if (!bRet)
    {
        if (lRet == ERROR_SUCCESS)
        {
            lRet = GetLastError();
        }

        SetLastError(lRet);

        // Access denied is a valid result. 
        if (lRet != ERROR_ACCESS_DENIED)
        {
            DebugPrint("ReadWritePowerValue, failed, lpszValueName: %s, LastError: 0x%08X", lpszValueName, lRet);
        }
    }
    return bRet;
}

/*******************************************************************************
*
*  ReadPwrPolicyEx
*
*  DESCRIPTION:
*   Supports ReadPwrScheme and ReadGlobalPwrPolicy
*
*  PARAMETERS:
*   lpdwDescSize - Pointer to size of optional description buffer.
*   lpszDesc     - Optional description buffer.
*
*******************************************************************************/

DWORD ReadPwrPolicyEx2(
    LPTSTR  lpszUserKeyName,
    LPTSTR  lpszMachineKeyName,
    LPTSTR  lpszSchemeName,
    LPTSTR  lpszDesc,
    LPDWORD lpdwDescSize,
    LPVOID  lpvUser,
    DWORD   dwcbUserSize,
    LPVOID  lpvMachine,
    DWORD   dwcbMachineSize
)
{
    HKEY     hKeyUser, hKeyMachine;
    DWORD    dwType, dwSize;
    DWORD dwError = ERROR_SUCCESS;
    BOOLEAN  bRet = FALSE;

    if ((!lpszUserKeyName || !lpszMachineKeyName) ||
        (!lpszSchemeName  || !lpvUser || !lpvMachine) ||
        (!lpdwDescSize    && lpszDesc) ||
        (lpdwDescSize     && !lpszDesc))
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        // Wait on/take the registry semaphore.
        if (!TakeRegSemaphore())        // Will Set Last Error 
        {
            return GetLastError();
        }

        dwError = OpenPathKeys(lpszUserKeyName, lpszMachineKeyName, lpszSchemeName, &hKeyUser, &hKeyMachine, TRUE, KEY_READ);
        if (ERROR_SUCCESS != dwError)
        {
            ReleaseSemaphore(g_hSemRegistry, 1, NULL);
            return dwError;
        }

        dwSize = dwcbUserSize;
        dwError = RegQueryValueEx(hKeyUser,
                               TEXT("Policies"),
                               NULL,
                               &dwType,
                               (PBYTE) lpvUser,
                               &dwSize);

        if (dwError == ERROR_SUCCESS)
        {
            if (dwType == REG_BINARY)
            {
                dwSize = dwcbMachineSize;
                dwError = RegQueryValueEx(hKeyMachine,
                                       TEXT("Policies"),
                                       NULL,
                                       &dwType,
                                       (PBYTE) lpvMachine,
                                       &dwSize);
            }
            else
            {
                dwError = ERROR_INVALID_DATATYPE;
            }
        }

        if (dwError == ERROR_SUCCESS)
        {
            if (dwType == REG_BINARY)
            {
                if (lpdwDescSize)
                {
                    dwError = RegQueryValueEx(hKeyUser, TEXT("Description"), NULL, &dwType, (PBYTE) lpszDesc, lpdwDescSize);
                }
            }
            else
            {
                dwError = ERROR_INVALID_DATATYPE;
            }
        }

        RegCloseKey(hKeyUser);
        RegCloseKey(hKeyMachine);
        ReleaseSemaphore(g_hSemRegistry, 1, NULL);
    }

    if (ERROR_SUCCESS != dwError)
    {
        DebugPrint("ReadPwrPolicyEx, failed, LastError: 0x%08X", dwError);
        DebugPrint("  lpszUserKeyName: %s, lpszSchemeName: %s", lpszUserKeyName, lpszSchemeName);
        SetLastError(dwError);
    }

    return dwError;
}

DWORD 
ReadProcessorPwrPolicy(
    LPTSTR lpszMachineKeyName, 
    LPTSTR lpszSchemeName, 
    LPVOID lpvMachineProcessor, 
    DWORD dwcbMachineProcessorSize
    )
{
    HKEY    hKeyMachine = NULL;
    HKEY    hKeyPolicy = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwDisposition, dwSize, dwType;

    if (!lpszMachineKeyName || !lpvMachineProcessor) {
        dwError = ERROR_INVALID_PARAMETER;
        goto ReadProcessorPwrPolicyEnd;
    }

    // Wait on/take the registry semaphore.
    if (!TakeRegSemaphore())        // Will Set Last Error 
    {
        return GetLastError();
    }

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszMachineKeyName, 0, KEY_READ, &hKeyMachine);
    if (ERROR_SUCCESS != dwError) goto ReadProcessorPwrPolicyExit;

    dwError = RegCreateKeyEx(hKeyMachine, lpszSchemeName, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKeyPolicy, &dwDisposition);
    if (ERROR_SUCCESS != dwError) goto ReadProcessorPwrPolicyExit;

    dwSize = dwcbMachineProcessorSize;
    dwError = RegQueryValueEx(hKeyPolicy,
                           TEXT("Policies"),
                           NULL,
                           &dwType,
                           (PBYTE) lpvMachineProcessor,
                           &dwSize);

    if (REG_BINARY != dwType) {
        dwError = ERROR_INVALID_DATATYPE;
    }
    
ReadProcessorPwrPolicyExit:

    if (hKeyPolicy) RegCloseKey(hKeyPolicy);
    if (hKeyMachine) RegCloseKey(hKeyMachine);
    ReleaseSemaphore(g_hSemRegistry, 1, NULL);

ReadProcessorPwrPolicyEnd:

    if (ERROR_SUCCESS != dwError)
    {
        DebugPrint("ReadProcessorPwrPolicy, failed, LastError: 0x%08X", dwError);
        DebugPrint("  lpszMachineKeyName: %s, lpszSchemeName: %s", lpszMachineKeyName, lpszSchemeName);
        SetLastError(dwError);
    }

    return dwError;
}

DWORD 
WriteProcessorPwrPolicy(
    LPTSTR lpszMachineKeyName, 
    LPTSTR lpszSchemeName, 
    LPVOID lpvMachineProcessor, 
    DWORD dwcbMachineProcessorSize
    )
{
    HKEY    hKeyMachine = NULL;
    HKEY    hKeyPolicy = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwDisposition;

    if (!lpszMachineKeyName || !lpvMachineProcessor) {
        dwError = ERROR_INVALID_PARAMETER;
        goto WriteProcessorPwrPolicyEnd;
    }

    // Wait on/take the registry semaphore.
    if (!TakeRegSemaphore())        // Will Set Last Error 
    {
        return GetLastError();
    }

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszMachineKeyName, 0, KEY_WRITE, &hKeyMachine);
    if (ERROR_SUCCESS != dwError) goto WriteProcessorPwrPolicyExit;

    dwError = RegCreateKeyEx(hKeyMachine, lpszSchemeName, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyPolicy, &dwDisposition);
    if (ERROR_SUCCESS != dwError) goto WriteProcessorPwrPolicyExit;

    dwError = RegSetValueEx(hKeyPolicy,
                           TEXT("Policies"),
                           0,
                           REG_BINARY,
                           (PBYTE) lpvMachineProcessor,
                           dwcbMachineProcessorSize);

WriteProcessorPwrPolicyExit:

    if (hKeyPolicy) RegCloseKey(hKeyPolicy);
    if (hKeyMachine) RegCloseKey(hKeyMachine);
    ReleaseSemaphore(g_hSemRegistry, 1, NULL);

WriteProcessorPwrPolicyEnd:

    if (ERROR_SUCCESS != dwError)
    {
        DebugPrint("WriteProcessorPwrPolicy, failed, LastError: 0x%08X", dwError);
        DebugPrint("  lpszMachineKeyName: %s, lpszSchemeName: %s", lpszMachineKeyName, lpszSchemeName);
        SetLastError(dwError);
    }

    return dwError;
}

/*******************************************************************************
*
*  WritePwrPolicyEx
*
*  DESCRIPTION:
*   Supports WritePwrScheme and
*   WriteGlobalPwrPolicy
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WritePwrPolicyEx(
    LPTSTR  lpszUserKeyName,
    LPTSTR  lpszMachineKeyName,
    PUINT   puiID,
    LPTSTR  lpszName,
    LPTSTR  lpszDescription,
    LPVOID  lpvUser,
    DWORD   dwcbUserSize,
    LPVOID  lpvMachine,
    DWORD   dwcbMachineSize
)
{
    // The function will set the last error if it fails.
    HKEY     hKeyUser, hKeyMachine;
    LONG     lRet = ERROR_SUCCESS;
    DWORD    dwDisposition, dwSize;
    TCHAR    szNum[NUM_DEC_DIGITS];
    LPTSTR   lpszKeyName;

    if ((!lpszUserKeyName || !lpszMachineKeyName || !lpvUser || !lpvMachine) || (!puiID && !lpszName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        lRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        // If a scheme ID was passed
        if (puiID)
        {
            if (*puiID == NEWSCHEME)
            {
                *puiID = ++g_uiLastID;
                wsprintf(szNum, TEXT("%d"), *puiID);

                // This ReadWritePowerValue will SetLastError
                if (!ReadWritePowerValue(HKEY_LOCAL_MACHINE,
                                         c_szREGSTR_PATH_MACHINE_POWERCFG,
                                         c_szREGSTR_VAL_LASTID,
                                         szNum, &dwSize, TRUE, TRUE))
                {
                    return FALSE;
                }
            }
            else
            {
                wsprintf(szNum, TEXT("%d"), *puiID);
            }
            lpszKeyName = szNum;
        }
        else
        {
            lpszKeyName = lpszName;
        }

        // Wait on/take the registry semaphore.
        if (!TakeRegSemaphore())    // Will set last error
        {
            return FALSE;
        }

        lRet = OpenPathKeys(lpszUserKeyName, lpszMachineKeyName, lpszKeyName, &hKeyUser, &hKeyMachine, FALSE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
        {
            ReleaseSemaphore(g_hSemRegistry, 1, FALSE);
            SetLastError(lRet);
            return FALSE;
        }

        // Write the binary policies data
        if ((lRet = RegSetValueEx(hKeyUser,
                                  TEXT("Policies"),
                                  0,
                                  REG_BINARY,
                                  (PBYTE) lpvUser,
                                  dwcbUserSize)) == ERROR_SUCCESS)
        {
            // Write the binary policies data
            if ((lRet = RegSetValueEx(hKeyMachine,
                                      TEXT("Policies"),
                                      0,
                                      REG_BINARY,
                                      (PBYTE) lpvMachine,
                                      dwcbMachineSize)) == ERROR_SUCCESS)
            {
                // Write the name text if an ID was provided.
                if (lpszName && puiID)
                {
                    dwSize = (lstrlen(lpszName) + 1) * sizeof(TCHAR);
                    lRet = RegSetValueEx(hKeyUser, TEXT("Name"), 0, REG_SZ, (PBYTE) lpszName, dwSize);
                }

                // Write the description text.
                if (lpszDescription && (lRet == ERROR_SUCCESS))
                {
                    dwSize = (lstrlen(lpszDescription) + 1) * sizeof(TCHAR);
                    lRet = RegSetValueEx(hKeyUser, TEXT("Description"), 0, REG_SZ, (PBYTE) lpszDescription, dwSize);
                }
            }
        }
        RegCloseKey(hKeyUser);
        RegCloseKey(hKeyMachine);
        ReleaseSemaphore(g_hSemRegistry, 1, NULL);
    }

    if (lRet != ERROR_SUCCESS)
    {
        DebugPrint("WritePwrPolicyEx, failed, LastError: 0x%08X", lRet);
        DebugPrint("  lpszUserKeyName: %s, lpszKeyName: %s", lpszUserKeyName, lpszKeyName);

        SetLastError(lRet);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\powrprof.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       POWRPROF.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   User power management profile maintenance library. Implements persistent
*   power mamagement data storage. To minimize registry storage and simplify
*   user power profile management, power scheme's are divided into two parts,
*   GLOBAL_POWER_POLICY and POWER_POLICY:
*
*   User Level              Registry Storage
*   GLOBAL_POWER_POLICY =                               - Common scheme data.
*                           GLOBAL_MACHINE_POWER_POLICY - Per machine data.
*                        +  GLOBAL_USER_POWER_POLICY    - Per user data.
*
*   POWER_POLICY        =                              - Unique scheme data.
*                           MACHINE_POWER_POLICY       - Per machine data.
*                         + USER_POWER_POLICY          - Per user data.
*
*   The interface to the power policy manager is by AC and DC
*   SYSTEM_POWER_POLICY which is formed by merging the above structures.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <initguid.h>
#include <devguid.h>
#include <string.h>
#include <regstr.h>
#include <commctrl.h>

#include <ntpoapi.h>

#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>

#include "powrprofp.h"
#include "reghelp.h"


/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

HINSTANCE   g_hInstance;        // Global instance handle of this DLL.
HANDLE      g_hSemRegistry;     // Registry semaphore.
UINT        g_uiLastID;         // The last ID value used, per machine.

// Variables and definitions to manage dynamic link to  NtPowerInformation.
typedef NTSTATUS (NTAPI *PFNNTPOWERINFORMATION)(POWER_INFORMATION_LEVEL, PVOID, ULONG, PVOID, ULONG);

#ifdef WINNT
// Global administrator power policy variables. Initialize to allow everything.
BOOLEAN g_bAdminOverrideActive = FALSE;
ADMINISTRATOR_POWER_POLICY g_app =
{
    // Meaning of power action "sleep" Min, Max.
    PowerSystemSleeping1, PowerSystemHibernate,

    // Video policies Min, Max.
    0, -1,

    // Disk spindown policies Min, Max.
    0, -1
};
#endif

// Debug strings for Power Policy Manager POWER_INFORMATION_LEVEL:
#ifdef DEBUG
LPTSTR lpszInfoLevel[] =
{
    TEXT("SystemPowerPolicyAc"),
    TEXT("SystemPowerPolicyDc"),
    TEXT("VerifySystemPolicyAc"),
    TEXT("VerifySystemPolicyDc"),
    TEXT("SystemPowerCapabilities"),
    TEXT("SystemBatteryState"),
    TEXT("SystemPowerStateHandler"),
    TEXT("ProcessorStateHandler"),
    TEXT("SystemPowerPolicyCurrent"),
    TEXT("AdministratorPowerPolicy"),
    TEXT("SystemReserveHiberFile"),
    TEXT("ProcessorInformation"),
    TEXT("SystemPowerInformation"),
    TEXT("ProcessorStateHandler2"),
    TEXT("LastWakeTime"),
    TEXT("LastSleepTime"),
    TEXT("SystemExecutionState"),
    TEXT("SystemPowerStateNotifyHandler"),
    TEXT("ProcessorPowerPolicyAc"),
    TEXT("ProcessorPowerPolicyDc"),
    TEXT("VerifyProcessorPowerPolicyAc"),
    TEXT("VerifyProcessorPowerPolicyDc"),
    TEXT("ProcessorPowerPolicyCurrent")
};

int g_iShowValidationChanges;
int g_iShowCapabilities;
int g_iShowSetPPM;
#endif

// Global value for storing a single registry value name/path. Multithread
// protection is provided by the Registry semaphore.
TCHAR g_szRegValue[REGSTR_MAX_VALUE_LENGTH];


// Strings used to access the registry. REGSTR_* string constants can be
// found in sdk\inc\regstr.h, USER strings are under HKEY_CURRENT_USER,
// MACHINE strings are under HKEY_LOCAL_MACHINE.

TCHAR c_szREGSTR_PATH_MACHINE_POWERCFG[]  = REGSTR_PATH_CONTROLSFOLDER TEXT("\\PowerCfg");
TCHAR c_szREGSTR_PATH_USER_POWERCFG[]     = REGSTR_PATH_CONTROLPANEL TEXT("\\PowerCfg");

TCHAR c_szREGSTR_PATH_MACHINE_POWERCFG_POLICIES[]  = REGSTR_PATH_CONTROLSFOLDER TEXT("\\PowerCfg\\PowerPolicies");
TCHAR c_szREGSTR_PATH_MACHINE_PROCESSOR_POLICIES[]  = REGSTR_PATH_CONTROLSFOLDER TEXT("\\PowerCfg\\ProcessorPolicies");
TCHAR c_szREGSTR_PATH_USER_POWERCFG_POLICIES[]     = REGSTR_PATH_CONTROLPANEL   TEXT("\\PowerCfg\\PowerPolicies");

TCHAR c_szREGSTR_VAL_GLOBALPOWERPOLICY[]  = TEXT("GlobalPowerPolicy");
TCHAR c_szREGSTR_VAL_CURRENTPOWERPOLICY[] = TEXT("CurrentPowerPolicy");

// These values are provided to help OEM's meet disk drive warranty requirements.
TCHAR c_szREGSTR_VAL_SPINDOWNMAX[]        = TEXT("DiskSpinDownMax");
TCHAR c_szREGSTR_VAL_SPINDOWNMIN[]        = TEXT("DiskSpinDownMin");

// These values are provided to support administrator power policies.
TCHAR c_szREGSTR_VAL_ADMINMAXVIDEOTIMEOUT[]       = TEXT("AdminMaxVideoTimeout");
TCHAR c_szREGSTR_VAL_ADMINMAXSLEEP[]              = TEXT("AdminMaxSleep");

// This value manages the policy ID's.
TCHAR c_szREGSTR_VAL_LASTID[] = TEXT("LastID");

// This value turns on debug logging of PPM Validation Changes
#ifdef DEBUG
TCHAR c_szREGSTR_VAL_SHOWVALCHANGES[] = TEXT("ShowValidationChanges");
TCHAR c_szREGSTR_VAL_SHOWCAPABILITIES[] = TEXT("ShowCapabilities");
TCHAR c_szREGSTR_VAL_SHOWSETPPM[] = TEXT("ShowSetPPM");
#endif


/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/


/*******************************************************************************
*
*  DllInitialize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DllInitialize(IN PVOID hmod, IN ULONG ulReason, IN PCONTEXT pctx OPTIONAL)
{

    UNREFERENCED_PARAMETER(pctx);

    switch (ulReason) {

        case DLL_PROCESS_ATTACH:
        {
            DisableThreadLibraryCalls(hmod);
            g_hInstance = hmod;

#ifdef DEBUG
            // Get the debug optional settings from HKCU.
            ReadOptionalDebugSettings();
#endif

#ifdef WINNT
            // Initialize an administrator power policy.
            InitAdmin(&g_app);
#endif
            // One time registry related initialization.
            if (!RegistryInit(&g_uiLastID)) {
                return FALSE;
            }
            break;
        }
        case DLL_PROCESS_DETACH:
            CloseHandle(g_hSemRegistry);
            g_hSemRegistry = NULL;
            break;
    }
    return TRUE;
}

/*******************************************************************************
*
*  IsAdminOverrideActive
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN IsAdminOverrideActive(PADMINISTRATOR_POWER_POLICY papp)
{
#ifdef WINNT
    if ((g_bAdminOverrideActive) && (papp)) {
        memcpy(papp, &g_app, sizeof(g_app));
    }
    return g_bAdminOverrideActive;
#else
    return FALSE;
#endif
}

/*******************************************************************************
*
*  IsPwrSuspendAllowed
*
*  DESCRIPTION:
*   Called by Explorer to determine whether suspend is supported.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN IsPwrSuspendAllowed(VOID)
{
    SYSTEM_POWER_CAPABILITIES   spc;

    if (GetPwrCapabilities(&spc)) {
        if (spc.SystemS1 || spc.SystemS2 || spc.SystemS3) {
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  IsPwrHibernateAllowed
*
*  DESCRIPTION:
*   Called by Explorer to determine whether hibernate is supported.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN IsPwrHibernateAllowed(VOID)
{
    SYSTEM_POWER_CAPABILITIES   spc;

    if (GetPwrCapabilities(&spc)) {
        if (spc.SystemS4 && spc.HiberFilePresent) {
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  IsPwrShutdownAllowed
*
*  DESCRIPTION:
*   Called by Explorer to determine whether shutdown is supported.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN IsPwrShutdownAllowed(VOID)
{
    SYSTEM_POWER_CAPABILITIES   spc;

    if (GetPwrCapabilities(&spc)) {
        if (spc.SystemS5) {
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  CanUserWritePwrScheme
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN CanUserWritePwrScheme(VOID)
{
    DWORD   dwSize;
    TCHAR   szNum[NUM_DEC_DIGITS];
    LONG    lErr;

    // Read in the last ID this value must be present.
    dwSize = sizeof(szNum);

    // ReadWritePowerValue will set last error
    if (ReadWritePowerValue(HKEY_LOCAL_MACHINE,
                            c_szREGSTR_PATH_MACHINE_POWERCFG,
                            c_szREGSTR_VAL_LASTID,
                            szNum, &dwSize, FALSE, TRUE))
    {
        // Write the value back out, this may fail if user doesn't have write access.
        if (ReadWritePowerValue(HKEY_LOCAL_MACHINE,
                                c_szREGSTR_PATH_MACHINE_POWERCFG,
                                c_szREGSTR_VAL_LASTID,
                                szNum, &dwSize, TRUE, TRUE))
        {
            return TRUE;
        }
        else
        {
            lErr = GetLastError();
            if (lErr != ERROR_ACCESS_DENIED)
            {
                DebugPrint( "CanUserWritePwrScheme, Unable to write last ID, Error: %d", lErr);
            }
        }
    }
    else
    {
        lErr = GetLastError();
        DebugPrint( "CanUserWritePwrScheme, Unable to fetch last ID, Error: %d", lErr);
    }

    return FALSE;
}

/*******************************************************************************
*
*  GetPwrDiskSpindownRange
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetPwrDiskSpindownRange(PUINT puiMax, PUINT puiMin)
{
    if (!puiMax || !puiMin) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (ReadPowerIntOptional(HKEY_LOCAL_MACHINE,
                             c_szREGSTR_PATH_MACHINE_POWERCFG,
                             c_szREGSTR_VAL_SPINDOWNMAX,
                             puiMax) &&
        ReadPowerIntOptional(HKEY_LOCAL_MACHINE,
                             c_szREGSTR_PATH_MACHINE_POWERCFG,
                             c_szREGSTR_VAL_SPINDOWNMIN,
                             puiMin)) {
            return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*  EnumPwrSchemes
*
*  DESCRIPTION:
*   Calls back the PWRSCHEMESENUMPROC with the ID, a pointer to the name,
*   the size in bytes of the name, a pointer to the description, the size in
*   bytes of the description, a pointer to the power policies and a user
*   defined value. Returns ERROR_SUCCESS on success, else error code. Callback
*   data is not allocated and is only valid during the scope of the callback.
*
*   Note: No calls to any other API's in this library should be made during
*   the call back to PWRSCHEMESENUMPROC. The registry semaphore is held at
*   this time and a deadlock will result.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN EnumPwrSchemes(
    PWRSCHEMESENUMPROC  lpfn,
    LPARAM              lParam
)
{
    HKEY            hKeyPolicyUser, hKeyPolicyMachine;
    HKEY            hKeyUser    = INVALID_HANDLE_VALUE;
    HKEY            hKeyMachine = INVALID_HANDLE_VALUE;
    DWORD           dwDescSize;
    DWORD           dwSize, dwNameSize, dwIndex = 0;
    BOOLEAN         bOneCallBackOk = FALSE;
    LONG            lRet = ERROR_SUCCESS;
    LPTSTR          lpszDescBuf, lpszDesc;
    TCHAR           szNameBuf[MAX_NAME_LEN+1];
    FILETIME        ft;
    UINT            uiID;

    MACHINE_POWER_POLICY    mpp;
    USER_POWER_POLICY       upp;
    POWER_POLICY            pp;

    if (!lpfn) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto WESPSP_exit;
    }

    // Wait on/take the registry semaphore.
    if (!TakeRegSemaphore()) {
        return FALSE;
    }

    // Allocate a description buffer.
    lpszDescBuf = LocalAlloc(0, (MAX_DESC_LEN + 1) * sizeof(TCHAR));
    if (!lpszDescBuf) {
        goto WESPSP_exit;
    }

    if (ERROR_SUCCESS != OpenMachineUserKeys2(c_szREGSTR_PATH_USER_POWERCFG_POLICIES,
                             c_szREGSTR_PATH_MACHINE_POWERCFG_POLICIES,
                             &hKeyUser, &hKeyMachine))
    {
        ReleaseSemaphore(g_hSemRegistry, 1, NULL);
        return FALSE;
    }

    // Enumerate the schemes
    while (lRet == ERROR_SUCCESS) {
        dwSize = REGSTR_MAX_VALUE_LENGTH - 1;
        if ((lRet = RegEnumKeyEx(hKeyUser,
                                 dwIndex,
                                 g_szRegValue,
                                 &dwSize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &ft)) == ERROR_SUCCESS) {

            // Open the Policies Key. The key name is the policies ID.
            lpszDesc = NULL;
            if (MyStrToInt(g_szRegValue, &uiID)) {
                if ((lRet = RegOpenKeyEx(hKeyUser,
                                         g_szRegValue,
                                         0,
                                         KEY_READ,
                                         &hKeyPolicyUser)) == ERROR_SUCCESS) {

                    if ((lRet = RegOpenKeyEx(hKeyMachine,
                                             g_szRegValue,
                                             0,
                                             KEY_READ,
                                             &hKeyPolicyMachine)) == ERROR_SUCCESS) {

                        // Get the friendly name..
                        dwNameSize = MAX_NAME_SIZE;
                        if ((lRet = RegQueryValueEx(hKeyPolicyUser,
                                                    TEXT("Name"),
                                                    NULL,
                                                    NULL,
                                                    (PBYTE) szNameBuf,
                                                    &dwNameSize)) == ERROR_SUCCESS) {

                            // Descriptions are optional.
                            dwDescSize = MAX_DESC_SIZE;
                            if ((lRet = RegQueryValueEx(hKeyPolicyUser,
                                                        TEXT("Description"),
                                                        NULL,
                                                        NULL,
                                                        (PBYTE) lpszDescBuf,
                                                        &dwDescSize)) == ERROR_SUCCESS) {
                                lpszDesc = lpszDescBuf;
                            }

                            // Read the user and machine policies.
                            dwSize = sizeof(upp);
                            if ((lRet = RegQueryValueEx(hKeyPolicyUser,
                                                        TEXT("Policies"),
                                                        NULL,
                                                        NULL,
                                                        (PBYTE) &upp,
                                                        &dwSize)) == ERROR_SUCCESS) {

                                dwSize = sizeof(mpp);
                                if ((lRet = RegQueryValueEx(hKeyPolicyMachine,
                                                            TEXT("Policies"),
                                                            NULL,
                                                            NULL,
                                                            (PBYTE) &mpp,
                                                            &dwSize)) == ERROR_SUCCESS) {


                                    // Merge the user and machine policies.
                                    if (MergePolicies(&upp, &mpp, &pp)) {

                                        // Call the enumerate proc.
                                        if (!lpfn(uiID,
                                                  dwNameSize, szNameBuf,
                                                  dwDescSize, lpszDesc,
                                                  &pp, lParam)) {
                                            RegCloseKey(hKeyPolicyMachine);
                                            RegCloseKey(hKeyPolicyUser);
                                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                            break;
                                        }
                                        else {
                                            bOneCallBackOk = TRUE;
                                        }
                                    }
                                }
                            }
                        }
                        RegCloseKey(hKeyPolicyMachine);
                    }
                    RegCloseKey(hKeyPolicyUser);
                }
            }
        }
        dwIndex++;
    }

    RegCloseKey(hKeyUser);
    RegCloseKey(hKeyMachine);
    ReleaseSemaphore(g_hSemRegistry, 1, NULL);
    if (lpszDescBuf) {
        LocalFree(lpszDescBuf);
    }

WESPSP_exit:
    if (lRet != ERROR_NO_MORE_ITEMS) {
        DebugPrint( "EnumPwrSchemes, failed, LastError: 0x%08X",
                 (lRet == ERROR_SUCCESS) ? GetLastError():lRet);
    }
    return bOneCallBackOk;
}

/*******************************************************************************
*
*  ReadGlobalPwrPolicy
*
*  DESCRIPTION:
*   Function reads the users global power policy profile and returns it.
*   If there is no such profile FALSE is returned. A global power policy
*   profile is per user, and contains values which apply to all of a users
*   power policies.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ReadGlobalPwrPolicy(
    PGLOBAL_POWER_POLICY  pgpp
)
{
    GLOBAL_MACHINE_POWER_POLICY gmpp;
    GLOBAL_USER_POWER_POLICY    gupp;
    DWORD dwError = ReadPwrPolicyEx2(c_szREGSTR_PATH_USER_POWERCFG, c_szREGSTR_PATH_MACHINE_POWERCFG, c_szREGSTR_VAL_GLOBALPOWERPOLICY,
                        NULL, NULL, &gupp, sizeof(gupp), &gmpp, sizeof(gmpp));

    if (ERROR_SUCCESS == dwError)
    {
        return MergeGlobalPolicies(&gupp, &gmpp, pgpp); // Sets Last Error
    }
    else
    {
        SetLastError(dwError);
    }

    return FALSE;
}

/*******************************************************************************
*
*  WritePwrScheme
*
*  DESCRIPTION:
*   Function to write a users power policy profile.  If the profile already
*   exists it is replaced.  Otherwise a new profile is created.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WritePwrScheme(
    PUINT           puiID,
    LPTSTR          lpszSchemeName,
    LPTSTR          lpszDescription,
    PPOWER_POLICY   lpScheme
)
{
    MACHINE_POWER_POLICY    mpp;
    USER_POWER_POLICY       upp;

    if (SplitPolicies(lpScheme, &upp, &mpp))
    {
        // WritePwrPolicyEx will set the last error on failure.
        return WritePwrPolicyEx(c_szREGSTR_PATH_USER_POWERCFG_POLICIES,
                                c_szREGSTR_PATH_MACHINE_POWERCFG_POLICIES,
                                puiID,
                                lpszSchemeName,
                                lpszDescription,
                                &upp,
                                sizeof(upp),
                                &mpp,
                                sizeof(mpp));
    }
    return FALSE;
}

/*******************************************************************************
*
*  WriteGlobalPwrPolicy
*
*  DESCRIPTION:
*   Function to write a users global power policy profile.  If the profile
*   already exists it is replaced.  Otherwise a new profile is created.
*   A global power policy profile is per user, and contains values which
*   apply to all of a users power policies. Otherwise a new profile is created.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WriteGlobalPwrPolicy (
    PGLOBAL_POWER_POLICY   pgpp
)
{
    GLOBAL_MACHINE_POWER_POLICY gmpp;
    GLOBAL_USER_POWER_POLICY    gupp;

    if (SplitGlobalPolicies(pgpp, &gupp, &gmpp))     // Will set last error
    {
        // WritePwrPolicyEx will set the last error on failure.
        return WritePwrPolicyEx(c_szREGSTR_PATH_USER_POWERCFG,
                                c_szREGSTR_PATH_MACHINE_POWERCFG,
                                NULL,
                                c_szREGSTR_VAL_GLOBALPOWERPOLICY,
                                NULL,
                                &gupp,
                                sizeof(gupp),
                                &gmpp,
                                sizeof(gmpp));
    }
    return FALSE;
}

/*******************************************************************************
*
*  DeletePwrScheme
*
*  DESCRIPTION:
*   Function to delete a users power policy profile. An attempt to delete the
*   currently active power policy profile will fail with last error set to
*   ERROR_ACCESS_DENIED.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN DeletePwrScheme(UINT uiID)
{
    HKEY    hKeyUser;
    DWORD   dwSize = REGSTR_MAX_VALUE_LENGTH * sizeof(TCHAR);
    BOOLEAN bRet = FALSE;
    LONG    lRet = ERROR_SUCCESS;
    TCHAR   szNum[NUM_DEC_DIGITS];
    int     iCurrent;
    HKEY     hKeyCurrentUser;

    // Wait on/take the registry semaphore.
    if (!TakeRegSemaphore())
    {
        return FALSE;
    }

    if (ERROR_SUCCESS == OpenCurrentUser2(&hKeyCurrentUser))
    {
        // Don't allow the currently active power policy profile to be deleted.
        // ReadWritePowerValue will set last error
        if (ReadWritePowerValue(hKeyCurrentUser,
                                c_szREGSTR_PATH_USER_POWERCFG,
                                c_szREGSTR_VAL_CURRENTPOWERPOLICY,
                                g_szRegValue, &dwSize, FALSE, FALSE) &&
            MyStrToInt(g_szRegValue, &iCurrent))
        {
            if (uiID != (UINT) iCurrent)
            {
                // For now we only delete the user portion of a policy. We may
                // want a ref count on the machine portion which allows deletion
                // of the machine portion when no user portion references it.
                lRet = RegOpenKey(hKeyCurrentUser, c_szREGSTR_PATH_USER_POWERCFG_POLICIES, &hKeyUser);
                if (lRet == ERROR_SUCCESS)
                {
                    wsprintf(szNum, TEXT("%d"), uiID);

                    lRet = RegDeleteKey(hKeyUser, szNum);
                    if (lRet == ERROR_SUCCESS)
                    {
                       bRet = TRUE;
                    }
                    RegCloseKey(hKeyUser);
                }
            }
            else
            {
                SetLastError(ERROR_ACCESS_DENIED);
            }
        }
        CloseCurrentUser(hKeyCurrentUser);
    }

    ReleaseSemaphore(g_hSemRegistry, 1, NULL);
    if (!bRet)
    {
        DebugPrint( "DeletePwrScheme, failed, LastError: 0x%08X", (lRet == ERROR_SUCCESS) ? GetLastError():lRet);
    }
    return bRet;
}

/*******************************************************************************
*
*  GetActivePwrScheme
*
*  DESCRIPTION:
*   Retrieves the ID of the currently active power policy profile. This value
*   is set by SetActivePwrScheme.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN
GetActivePwrScheme(PUINT puiID)
{
    BOOLEAN bRet = FALSE;
    TCHAR   szNum[NUM_DEC_DIGITS];
    DWORD   dwSize = SIZE_DEC_DIGITS;
    HKEY    hKey;

    if (ERROR_SUCCESS == OpenCurrentUser2(&hKey))
    {
        // ReadWritePowerValue will set last error
        if (ReadWritePowerValue(hKey,
                                c_szREGSTR_PATH_USER_POWERCFG,
                                c_szREGSTR_VAL_CURRENTPOWERPOLICY,
                                szNum, &dwSize, FALSE, TRUE) &&
            MyStrToInt(szNum, puiID))
        {
            bRet = TRUE;
        }
        CloseCurrentUser(hKey);
    }
    return bRet;
}

/*******************************************************************************
*
*  SetActivePwrScheme
*
*  DESCRIPTION:
*   Set the currently active power policy profile.
*
*  PARAMETERS:
*   uiID           - ID of the new active power scheme.
*   lpGlobalPolicy - Optional global policies to merge with active power scheme.
*   lpPowerPolicy  - Optional power policies to merge with active power scheme.
*
*******************************************************************************/

BOOLEAN
SetActivePwrScheme(
    UINT                    uiID,
    PGLOBAL_POWER_POLICY    pgpp,
    PPOWER_POLICY           ppp
)
{
    DWORD                       dwSize;
    NTSTATUS                    ntsRetVal, status;
    TCHAR                       szNum[NUM_DEC_DIGITS];
    POWER_POLICY                pp;
    GLOBAL_POWER_POLICY         gpp;
    MACHINE_POWER_POLICY        mpp;
    USER_POWER_POLICY           upp;
    GLOBAL_MACHINE_POWER_POLICY gmpp;
    GLOBAL_USER_POWER_POLICY    gupp;
    SYSTEM_POWER_POLICY         sppAc, sppDc;
    MACHINE_PROCESSOR_POWER_POLICY mppp;


    HKEY     hKeyCurrentUser;
    DWORD dwError;
    BOOLEAN  bRet = FALSE;

    // If a new scheme is not passed, fetch the target scheme.
    if (!ppp)
    {
        if (!ReadPwrScheme(uiID, &pp))  //  Will SetLastError
        {
            return FALSE;
        }
        ppp = &pp;
    }

    // If a new global policy is not passed, fetch the target global policy.
    if (!pgpp)
    {
        if (!ReadGlobalPwrPolicy(&gpp)) // Sets last error
        {
            return FALSE;
        }
        pgpp = &gpp;
    }

    if (!ReadProcessorPwrScheme(uiID, &mppp)) {
        return FALSE;
    }

    // Merge global policy and user scheme if a global policy was passed.
    if (!MergeToSystemPowerPolicies(pgpp, ppp, &sppAc, &sppDc))     // Sets last error
    {
        return FALSE;
    }

    // Write out what was requested to the registry.
    SplitPolicies(ppp, &upp, &mpp);     // Will set last error

    if (!WritePwrPolicyEx(c_szREGSTR_PATH_USER_POWERCFG_POLICIES, c_szREGSTR_PATH_MACHINE_POWERCFG_POLICIES,
                          &uiID, NULL, NULL, &upp, sizeof(upp), &mpp, sizeof(mpp)))
    {
        // WritePwrPolicyEx will set the last error on failure.
        return FALSE;
    }

    SplitGlobalPolicies(pgpp, &gupp, &gmpp);     // Will set last error
    if (!WritePwrPolicyEx(c_szREGSTR_PATH_USER_POWERCFG,
                          c_szREGSTR_PATH_MACHINE_POWERCFG,
                          NULL,
                          c_szREGSTR_VAL_GLOBALPOWERPOLICY,
                          NULL,
                          &gupp,
                          sizeof(gupp),
                          &gmpp,
                          sizeof(gmpp)))
    {
        // WritePwrPolicyEx will set the last error on failure.
        return FALSE;
    }

    // Call down to the power policy manager to set the scheme.
    // I'm working under the assumption that CallNtSetValidateAcDc will call SetLastError() with any
    // error values.
    status = CallNtSetValidateAcDc(FALSE, FALSE, &(mppp.ProcessorPolicyAc), &(mppp.ProcessorPolicyAc), &(mppp.ProcessorPolicyDc), &(mppp.ProcessorPolicyDc));
    ntsRetVal = CallNtSetValidateAcDc(FALSE, TRUE, &sppAc, &sppAc, &sppDc, &sppDc);
    //if ((ntsRetVal == STATUS_SUCCESS) && (status = STATUS_SUCCESS))
    if ((ntsRetVal == STATUS_SUCCESS))
    {
        dwError = OpenCurrentUser2(&hKeyCurrentUser);
        if (ERROR_SUCCESS == dwError)
        {
            // On success, set the current active power scheme in the registry.
            wsprintf(szNum, TEXT("%d"), uiID);

            // ReadWritePowerValue will set last error
            bRet =  ReadWritePowerValue(hKeyCurrentUser,
                                       c_szREGSTR_PATH_USER_POWERCFG,
                                       c_szREGSTR_VAL_CURRENTPOWERPOLICY,
                                       szNum, NULL, TRUE, TRUE);

            dwError = GetLastError();
            CloseCurrentUser(hKeyCurrentUser);
            SetLastError(dwError);
        }
        else
        {
            SetLastError(dwError);
        }
    }

    return bRet;
}

/*******************************************************************************
*
*  LoadCurrentPwrScheme
*
*  DESCRIPTION:
*   A Memphis only cover to call SetActivePwrScheme using RunDLL32 calling
*   convention. Do not change parameter list.
*
*  PARAMETERS:
*
*******************************************************************************/

void WINAPI LoadCurrentPwrScheme(
    HWND hwnd,
    HINSTANCE hAppInstance,
    LPSTR lpszCmdLine,
    int nCmdShow)
{
    UINT uiID;

    if (GetActivePwrScheme(&uiID)) {
        SetActivePwrScheme(uiID, NULL, NULL);
    }
}

/*******************************************************************************
*
*  MergeLegacyPwrScheme
*
*  DESCRIPTION:
*   A Memphis only call to merge legacy power management registry info into the
*   currently active power scheme.
*   Called using the RunDLL32 calling convention. Do not change parameter list.
*
*  PARAMETERS:
*
*******************************************************************************/

void WINAPI MergeLegacyPwrScheme(
    HWND hwnd,
    HINSTANCE hAppInstance,
    LPSTR lpszCmdLine,
    int nCmdShow)
{
    DWORD                       dwSize, dwLegacy;
    POWER_POLICY                pp;
    GLOBAL_POWER_POLICY         gpp;
    UINT                        uiID;
    HKEY                        hKeyCurrentUser;

    // Get the active power scheme from the registry.
    if (!GetActivePwrScheme(&uiID)) 
    {
        return;
    }
    if (!ReadPwrScheme(uiID, &pp))
    {
        return;
    }
    if (!ReadGlobalPwrPolicy(&gpp))
    {
        return;
    }

    if (ERROR_SUCCESS == OpenCurrentUser2(&hKeyCurrentUser))
    {
        // Get the legacy video monitor power down information.
        if (ReadPowerIntOptional(hKeyCurrentUser,
                                 REGSTR_PATH_SCREENSAVE,
                                 REGSTR_VALUE_POWEROFFACTIVE,
                                 &pp.user.VideoTimeoutAc))
        {
            DebugPrint( "MergeLegacyPwrScheme, found legacy %s: %d", REGSTR_VALUE_POWEROFFACTIVE, pp.user.VideoTimeoutAc);
            pp.user.VideoTimeoutDc = pp.user.VideoTimeoutAc;
        }
        CloseCurrentUser(hKeyCurrentUser);
    }


    // Get the legacy disk spin down information.
    if (ReadPowerIntOptional(HKEY_LOCAL_MACHINE,
                             REGSTR_PATH_FILESYSTEM,
                             REGSTR_VAL_ACDRIVESPINDOWN,
                             &pp.user.SpindownTimeoutAc)) {
        DebugPrint( "MergeLegacyPwrScheme, found legacy %s: %d", REGSTR_VAL_ACDRIVESPINDOWN, pp.user.SpindownTimeoutAc);
    }

    if (ReadPowerIntOptional(HKEY_LOCAL_MACHINE,
                               REGSTR_PATH_FILESYSTEM,
                               REGSTR_VAL_BATDRIVESPINDOWN,
                               &pp.user.SpindownTimeoutDc)) {
        DebugPrint( "MergeLegacyPwrScheme, found legacy %s: %d", REGSTR_VAL_BATDRIVESPINDOWN, pp.user.SpindownTimeoutDc);
    }

    // Get the legacy battery meter information.
    dwSize = sizeof(dwLegacy);
    if (ReadPowerValueOptional(HKEY_LOCAL_MACHINE,
                               REGSTR_PATH_VPOWERD,
                               REGSTR_VAL_VPOWERDFLAGS,
                               (LPTSTR)&dwLegacy, &dwSize)) {
        if (dwLegacy & VPDF_SHOWMULTIBATT) {
            gpp.user.GlobalFlags |= EnableSysTrayBatteryMeter;
        }
        else {
            gpp.user.GlobalFlags &= ~EnableSysTrayBatteryMeter;
        }
        DebugPrint( "MergeLegacyPwrScheme, found legacy %s: %X", REGSTR_VAL_VPOWERDFLAGS, dwLegacy);
    }

    // Write out the modified active power scheme.
    if (!WriteGlobalPwrPolicy(&gpp)) {
        return;
    }

    WritePwrScheme(&uiID, NULL, NULL, &pp);
}

/*******************************************************************************
*
*  GetPwrCapabilities
*
*  DESCRIPTION:
*   Get the system power capabilities from the Power Policy Manager.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetPwrCapabilities(PSYSTEM_POWER_CAPABILITIES lpspc)
{
    NTSTATUS ntsRetVal = STATUS_SUCCESS;

    if (!lpspc) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ntsRetVal = CallNtPowerInformation(SystemPowerCapabilities, NULL, 0, lpspc,
                                       sizeof(SYSTEM_POWER_CAPABILITIES));

    if (ntsRetVal == STATUS_SUCCESS) {
#ifdef DEBUG
        if (g_iShowCapabilities) {
            DumpSystemPowerCapabilities("GetPwrCapabilities, returned:", lpspc);
        }
#ifdef SIM_BATTERY
        lpspc->SystemBatteriesPresent = TRUE;
#endif
#endif
        return TRUE;
    }
    else {
        return FALSE;
    }
}

/*******************************************************************************
*
*  CallNtPowerInformation
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

NTSTATUS CallNtPowerInformation(
    POWER_INFORMATION_LEVEL InformationLevel,
    PVOID InputBuffer OPTIONAL,
    ULONG InputBufferLength,
    PVOID OutputBuffer OPTIONAL,
    ULONG OutputBufferLength
)
{
    NTSTATUS ntsRetVal;
    DWORD dwOldState, dwStatus;
    DWORD dwErrorSave;
    LPCTSTR PrivilegeName;

    if (InformationLevel == SystemReserveHiberFile) {
        PrivilegeName = SE_CREATE_PAGEFILE_NAME;
    } else {
        PrivilegeName = SE_SHUTDOWN_NAME;
    }

    SetLastError(0);
    dwStatus = SetPrivilegeAttribute(PrivilegeName, SE_PRIVILEGE_ENABLED,
                                     &dwOldState);
    dwErrorSave = GetLastError();

    ntsRetVal = NtPowerInformation(InformationLevel,
                                        InputBuffer, InputBufferLength,
                                        OutputBuffer, OutputBufferLength);

    //
    // If we were able to set the privilege, then reset it.
    //
    if (NT_SUCCESS(dwStatus) && dwErrorSave == 0) {
        SetPrivilegeAttribute(PrivilegeName, dwOldState, NULL);
    }
    else {
        DebugPrint( "CallNtPowerInformation, SetPrivilegeAttribute failed: 0x%08X", GetLastError());
    }

#ifdef DEBUG
    if ((ntsRetVal != STATUS_SUCCESS) && (InformationLevel <= ProcessorPowerPolicyCurrent)) {
        DebugPrint( "NtPowerInformation, %s, failed: 0x%08X", lpszInfoLevel[InformationLevel], ntsRetVal);
    }
    else {
        if (g_iShowSetPPM && InputBuffer) {
            if ((InformationLevel == SystemPowerPolicyAc) ||
                (InformationLevel == SystemPowerPolicyDc)) {
                DumpSystemPowerPolicy("NtPowerInformation, Set to PPM, InputBuffer", InputBuffer);
            }
        }
    }
#endif

    return ntsRetVal;
}

/*******************************************************************************
*
*  SetSuspendState
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN SetSuspendState(
    BOOLEAN bHibernate,
    BOOLEAN bForce,
    BOOLEAN bWakeupEventsDisabled)
{
    NTSTATUS ntsRetVal;
    POWER_ACTION pa;
    ULONG Flags;
    DWORD dwOldState, dwStatus;
    DWORD dwErrorSave;

    SetLastError(0);
    dwStatus = SetPrivilegeAttribute(SE_SHUTDOWN_NAME, SE_PRIVILEGE_ENABLED,
                                     &dwOldState);
    dwErrorSave = GetLastError();

    if (bHibernate) {
        pa = PowerActionHibernate;
    }
    else {
        pa = PowerActionSleep;
    }

    Flags = POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED;

    if (bForce) {
        Flags |= POWER_ACTION_CRITICAL;
    }

    if (bWakeupEventsDisabled) {
        Flags |= POWER_ACTION_DISABLE_WAKES;
    }

    ntsRetVal = NtInitiatePowerAction(pa, PowerSystemSleeping1, Flags, FALSE);

    //
    // If we were able to set the privilege, then reset it.
    //
    if (NT_SUCCESS(dwStatus) && dwErrorSave == 0) {
        SetPrivilegeAttribute(SE_SHUTDOWN_NAME, dwOldState, NULL);
    }
    else {
        DebugPrint( "SetSuspendState, SetPrivilegeAttribute failed: 0x%08X", GetLastError());
    }

    if (ntsRetVal == STATUS_SUCCESS) {
        return TRUE;
    }
    else {
        DebugPrint( "NtInitiatePowerAction, failed: 0x%08X", ntsRetVal);
        return FALSE;
    }
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  ValidatePowerPolicies
*
*  DESCRIPTION:
*   Call down to the power policy manager to validate power policies.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ValidatePowerPolicies(
    PGLOBAL_POWER_POLICY    pgpp,
    PPOWER_POLICY           ppp
)
{
    POWER_POLICY        ppValid;
    GLOBAL_POWER_POLICY gppValid;
    SYSTEM_POWER_POLICY sppAc, sppDc;

    // Get current power policy data from the PPM.
    if (!GetCurrentPowerPolicies(&gppValid, &ppValid)) {
        return FALSE;
    }

    if (!pgpp) {
        pgpp = &gppValid;
    }

    if (!ppp) {
        ppp = &ppValid;
    }

    // Merge policy and global policy data.
    if (!MergeToSystemPowerPolicies(pgpp, ppp, &sppAc, &sppDc)) {
        return FALSE;
    }

    if (!ValidateSystemPolicies(&sppAc, &sppDc)) {
        return FALSE;
    }

    return SplitFromSystemPowerPolicies(&sppAc, &sppDc, pgpp, ppp);
}

/*******************************************************************************
*
*  ValidateSystemPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ValidateSystemPolicies(
    PSYSTEM_POWER_POLICY psppAc,
    PSYSTEM_POWER_POLICY psppDc
)
{
    DWORD               dwLastErr;
    NTSTATUS            ntsRetVal;

    // Call down to the power policy manager to validate the scheme.
    ntsRetVal = CallNtSetValidateAcDc(TRUE, TRUE, psppAc, psppAc, psppDc, psppDc);

    // Map any PPM errors to winerror.h values
    switch (ntsRetVal) {
        case STATUS_SUCCESS:
            return TRUE;

        case STATUS_PRIVILEGE_NOT_HELD:
            dwLastErr = ERROR_ACCESS_DENIED;
            break;

        case STATUS_INVALID_PARAMETER:
            dwLastErr = ERROR_INVALID_DATA;
            break;

        default:
            dwLastErr = ERROR_GEN_FAILURE;
            break;
    }
    SetLastError(dwLastErr);
    return FALSE;
}


/*******************************************************************************
*
*  GetCurrentPowerPolicies
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetCurrentPowerPolicies(PGLOBAL_POWER_POLICY pgpp, PPOWER_POLICY ppp)
{
    SYSTEM_POWER_POLICY sppAc, sppDc;

    if (!GetCurrentSystemPowerPolicies(&sppAc, &sppDc)) {
        return FALSE;
    }

    return SplitFromSystemPowerPolicies(&sppAc, &sppDc, pgpp, ppp);
}

/*******************************************************************************
*
*  GetCurrentSystemPowerPolicies
*
*  DESCRIPTION:
*   Call down to the power policy manager to get the current system power
*   policies.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN GetCurrentSystemPowerPolicies(
    PSYSTEM_POWER_POLICY psppAc,
    PSYSTEM_POWER_POLICY psppDc
)
{
    NTSTATUS            ntsRetVal;

    // Call down to the power policy manager to get system power policies.
    ntsRetVal = CallNtSetValidateAcDc(FALSE, TRUE, NULL, psppAc, NULL, psppDc);

    if (ntsRetVal == STATUS_SUCCESS) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

#ifdef WINNT
/*******************************************************************************
*
*  SetPrivilegeAttribute
*
*  DESCRIPTION:
*   This routine sets the security attributes for a given privilege.
*
*  PARAMETERS:
*   PrivilegeName - Name of the privilege we are manipulating.
*   NewPrivilegeAttribute - The new attribute value to use.
*   OldPrivilegeAttribute - Pointer to receive the old privilege value.
*                           OPTIONAL.
*
*******************************************************************************/

DWORD SetPrivilegeAttribute(
    LPCTSTR PrivilegeName,
    DWORD   NewPrivilegeAttribute,
    DWORD   *OldPrivilegeAttribute
)
{
    LUID             PrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    // First, find out the LUID Value of the privilege

    if(!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) {
        return GetLastError();
    }

    // Get the token handle
    if (!OpenThreadToken (GetCurrentThread(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          FALSE, &TokenHandle)) {
        if (!OpenProcessToken (GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &TokenHandle)) {
            return GetLastError();
        }
    }

    // Set up the privilege set we will need
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof(TOKEN_PRIVILEGES);
    if (!AdjustTokenPrivileges(TokenHandle, FALSE,
                               &TokenPrivileges, sizeof(TOKEN_PRIVILEGES),
                               &OldTokenPrivileges, &ReturnLength)) {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else {
        if (OldPrivilegeAttribute != NULL) {

            //
            //  If the privilege changed, store the old value.  If it did
            //  not change, store the value passed in.
            //

            if( OldTokenPrivileges.PrivilegeCount != 0 ) {

                *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;

            } else {

                *OldPrivilegeAttribute = NewPrivilegeAttribute;
            }
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}
#endif


/*******************************************************************************
*
*  CallNtSetValidateAcDc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

NTSTATUS CallNtSetValidateAcDc(
    BOOLEAN bValidate,
    BOOLEAN bSystem,
    PVOID InputBufferAc OPTIONAL,
    PVOID OutputBufferAc OPTIONAL,
    PVOID InputBufferDc OPTIONAL,
    PVOID OutputBufferDc OPTIONAL
)
{
    NTSTATUS                ntsRetVal;
    POWER_INFORMATION_LEVEL pil, pilAc, pilDc;
    ULONG                   policyLength;

#ifdef DEBUG
    SYSTEM_POWER_POLICY sppOrgAc, sppOrgDc;
#endif

#ifdef WINNT
    DWORD dwOldState, dwStatus;
    DWORD dwErrorSave;

    SetLastError(0);
    dwStatus = SetPrivilegeAttribute(SE_SHUTDOWN_NAME, SE_PRIVILEGE_ENABLED, &dwOldState);
    dwErrorSave = GetLastError();
#endif

    if (bSystem) {

        if (bValidate) {
            pil = pilAc = VerifySystemPolicyAc;
            pilDc = VerifySystemPolicyDc;
        } else {
            pil = pilAc = SystemPowerPolicyAc;
            pilDc = SystemPowerPolicyDc;
        }
    
        policyLength = sizeof(SYSTEM_POWER_POLICY);

    } else {
        if (bValidate) {
            pil = pilAc = VerifyProcessorPowerPolicyAc;
            pilDc = VerifyProcessorPowerPolicyDc;
        } else {
            pil = pilAc = ProcessorPowerPolicyAc;
            pilDc = ProcessorPowerPolicyDc;
        }
        
        policyLength = sizeof(PROCESSOR_POWER_POLICY);
    }
    
#ifdef DEBUG
    if (InputBufferAc)
    {
        memcpy(&sppOrgAc, InputBufferAc, policyLength);
    }
    if (InputBufferDc)
    {
        memcpy(&sppOrgDc, InputBufferDc, policyLength);
    }
#endif

    ntsRetVal = NtPowerInformation(pilAc,
                                   InputBufferAc,
                                   policyLength,
                                   OutputBufferAc,
                                   policyLength);

    if (ntsRetVal == STATUS_SUCCESS)
    {
        pil = pilDc;
        ntsRetVal = NtPowerInformation(pilDc,
                                       InputBufferDc,
                                       policyLength,
                                       OutputBufferDc,
                                       policyLength);
    }

#ifdef WINNT
    // If we were able to set the privilege, then reset it.
    if (NT_SUCCESS(dwStatus) && (dwErrorSave == ERROR_SUCCESS))
    {
        SetPrivilegeAttribute(SE_SHUTDOWN_NAME, dwOldState, NULL);

#ifdef DEBUG
        if (InputBufferAc && OutputBufferAc)
        {
            DifSystemPowerPolicies("PPM modified AC policies", &sppOrgAc, OutputBufferAc);
        }
        if (InputBufferDc && OutputBufferDc)
        {
            DifSystemPowerPolicies("PPM modified DC policies", &sppOrgDc, OutputBufferDc);
        }
#endif

    }
    else
    {
        DebugPrint( "SetSuspendState, SetPrivilegeAttribute failed: 0x%08X", GetLastError());
    }
#endif

#ifdef DEBUG
    if (ntsRetVal != STATUS_SUCCESS)
    {
        DebugPrint( "NtPowerInformation, %s, failed: 0x%08X", lpszInfoLevel[pil], ntsRetVal);
        switch (pil)
        {
            case SystemPowerPolicyAc:
            case VerifySystemPolicyAc:
                DumpSystemPowerPolicy("InputBufferAc", InputBufferAc);
                break;

            case SystemPowerPolicyDc:
            case VerifySystemPolicyDc:
                DumpSystemPowerPolicy("InputBufferDc", InputBufferDc);
                break;
        }
    }
    else
    {
        if (g_iShowSetPPM && InputBufferAc && InputBufferDc && !bValidate)
        {
            DumpSystemPowerPolicy("CallNtSetValidateAcDc, Set AC to PPM", InputBufferAc);
            DumpSystemPowerPolicy("CallNtSetValidateAcDc, Set DC to PPM", InputBufferDc);
        }
    }
#endif
    return ntsRetVal;
}

/*******************************************************************************
*
*  ReadPwrScheme
*
*  DESCRIPTION:
*   Function reads the specified user power policy profile and returns
*   it.  If there is no such profile FALSE is returned.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN ReadPwrScheme(
    UINT            uiID,
    PPOWER_POLICY   ppp
)
{
    MACHINE_POWER_POLICY    mpp;
    USER_POWER_POLICY       upp;
    TCHAR                   szNum[NUM_DEC_DIGITS];
    DWORD dwError;

    wsprintf(szNum, TEXT("%d"), uiID);

    dwError = ReadPwrPolicyEx2(c_szREGSTR_PATH_USER_POWERCFG_POLICIES, c_szREGSTR_PATH_MACHINE_POWERCFG_POLICIES,
                  szNum, NULL, 0, &upp, sizeof(upp), &mpp, sizeof(mpp));

    if (ERROR_SUCCESS == dwError)
    {
        return MergePolicies(&upp, &mpp, ppp);
    }
    else
    {
        SetLastError(dwError);
    }

    return FALSE;
}

/*******************************************************************************
*
*  ReadProcessorPwrScheme
*
*  DESCRIPTION:
*   Function reads the specified processor power policy profile and returns
*   it.  If there is no such profile FALSE is returned.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN
ReadProcessorPwrScheme(
    UINT                            uiID,
    PMACHINE_PROCESSOR_POWER_POLICY pmppp
    )
{
    TCHAR                   szNum[NUM_DEC_DIGITS];
    DWORD dwError;

    wsprintf(szNum, TEXT("%d"), uiID);

    dwError = ReadProcessorPwrPolicy(c_szREGSTR_PATH_MACHINE_PROCESSOR_POLICIES,
                                     szNum,
                                     pmppp,
                                     sizeof(MACHINE_PROCESSOR_POWER_POLICY));

    //
    // It's legal for there to be no Processor Power Scheme that corresponds with
    // uiID, as long as uiID is non-zero.  If this is the case, just use a 
    // default scheme.  (We use '1' as a default because this will be the 
    // default laptop scheme.  Non-laptops probably won't have power controls 
    // on the processor, so it won't matter if we get a scheme that is too aggressive.)
    //

    if ((ERROR_SUCCESS != dwError) &&
        (uiID != 0)) {

        wsprintf(szNum, TEXT("%d"), 1);

        dwError = ReadProcessorPwrPolicy(c_szREGSTR_PATH_MACHINE_PROCESSOR_POLICIES,
                                         szNum,
                                         pmppp,
                                         sizeof(MACHINE_PROCESSOR_POWER_POLICY));
    }
    
    if (ERROR_SUCCESS == dwError) {
        return TRUE;
    } else {
        SetLastError(dwError);
        return FALSE;
    }
}

/*******************************************************************************
*
*  WriteProcessorPwrScheme
*
*  DESCRIPTION:
*   Function writes the specified processor power policy profile
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN
WriteProcessorPwrScheme(
    UINT                            uiID,
    PMACHINE_PROCESSOR_POWER_POLICY pmppp
    )
{
    TCHAR                   szNum[NUM_DEC_DIGITS];
    DWORD dwError;

    wsprintf(szNum, TEXT("%d"), uiID);

    dwError = WriteProcessorPwrPolicy(c_szREGSTR_PATH_MACHINE_PROCESSOR_POLICIES,
                                     szNum,
                                     pmppp,
                                     sizeof(MACHINE_PROCESSOR_POWER_POLICY));
    
    if (ERROR_SUCCESS == dwError) {
        return TRUE;
    } else {
        SetLastError(dwError);
        return FALSE;
    }
}

/*******************************************************************************
*
*  MyStrToInt
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN MyStrToInt(LPCTSTR lpSrc, PINT pi)
{

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    if (!ISDIGIT(*lpSrc))  {
        DebugPrint( "MyStrToInt, non-integer string: %s", lpSrc);
        return FALSE;
    }

    while (ISDIGIT(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }

    if (bNeg) {
        *pi = -n;
    }
    else {
        *pi = n;
    }
    return TRUE;
}

#ifndef WINNT
/*******************************************************************************
*
*  DM32IsPCMCIAPresent
*
*  DESCRIPTION:
*   Memphis only test for existence of PCMCIA slots. From Jason Cobb.
*
*  PARAMETERS:
*
*******************************************************************************/

DEFINE_GUID(GUID_DEVICEINTERFACE_PCMCIA,0x4d36e977L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18);

BOOLEAN DM32IsPCMCIAPresent(VOID)
{
    HDEVINFO        hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    BOOLEAN         bRet = FALSE;

    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICEINTERFACE_PCMCIA,
                                   NULL, NULL, 0);

    if (hDevInfo != INVALID_HANDLE_VALUE) {
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        if (SetupDiEnumDeviceInfo(hDevInfo, 0, &DeviceInfoData)) {
            bRet = TRUE;
        }
        else {
            DebugPrint( "DM32IsPCMCIAPresent, SetupDiEnumDeviceInfo on PCMCIA failed");
        }
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    else {
        DebugPrint( "DM32IsPCMCIAPresent, SetupDiGetClassDevs on PCMCIA failed");
    }
    return bRet;
}
#endif

/*******************************************************************************
*
*  RegistryInit
*
*  DESCRIPTION:
*   Do DLL load time registry related initialization.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN RegistryInit(PUINT puiLastId)
{
    DWORD               dwSize;
    TCHAR               szNum[NUM_DEC_DIGITS];
    UINT                uiCurPwrScheme;

    // Read in the last ID this value must be present.
    dwSize = sizeof(szNum);

    // ReadWritePowerValue will set last error
    if (!ReadWritePowerValue(HKEY_LOCAL_MACHINE,
                             c_szREGSTR_PATH_MACHINE_POWERCFG,
                             c_szREGSTR_VAL_LASTID,
                             szNum, &dwSize, FALSE, TRUE) ||
        !MyStrToInt(szNum, &g_uiLastID)) {
        DebugPrint( "RegistryInit, Unable to fetch last ID, registry is corrupt");
        return FALSE;
    }

#ifndef WINNT
    // For Memphis only we check the HKCU current scheme entry. If it's not
    // valid a new entry is written. If the machine has a PCMCIA slot we set
    // Portable as the current scheme, otherwise it's Home/Office. Per RobMCK.

    if (!GetActivePwrScheme(&uiCurPwrScheme)) {
        DebugPrint( "RegistryInit, unable to validate currrent scheme");
        if (DM32IsPCMCIAPresent()) {
            uiCurPwrScheme = 1;
        }
        else {
            uiCurPwrScheme = 0;
        }
        wsprintf(szNum, TEXT("%d"), uiCurPwrScheme);
        DebugPrint( "RegistryInit, attempting to write new current ID: %s", szNum);

        // ReadWritePowerValue will set last error
        return ReadWritePowerValue(HKEY_CURRENT_USER,
                                   c_szREGSTR_PATH_USER_POWERCFG,
                                   c_szREGSTR_VAL_CURRENTPOWERPOLICY,
                                   szNum, NULL, TRUE, TRUE);
    }
#endif
    return TRUE;
}

#ifdef DEBUG
/*******************************************************************************
*
*  ReadOptionalDebugSettings
*
*  DESCRIPTION:
*   Debug only. Get the debug settings from HKCU registry entries into globals.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID ReadOptionalDebugSettings(VOID)
{
    HKEY     hKeyCurrentUser;

    if (ERROR_SUCCESS == OpenCurrentUser2(&hKeyCurrentUser))
    {
        // Optional debug logging of PPM policy validation changes.
        ReadPowerIntOptional(hKeyCurrentUser,
                             c_szREGSTR_PATH_USER_POWERCFG,
                             c_szREGSTR_VAL_SHOWVALCHANGES,
                             &g_iShowValidationChanges);

        // Optional debug logging of PPM capabilities.
        ReadPowerIntOptional(hKeyCurrentUser,
                             c_szREGSTR_PATH_USER_POWERCFG,
                             c_szREGSTR_VAL_SHOWCAPABILITIES,
                             &g_iShowCapabilities);

        // Optional debug logging of setting new policy to PPM.
        ReadPowerIntOptional(hKeyCurrentUser,
                             c_szREGSTR_PATH_USER_POWERCFG,
                             c_szREGSTR_VAL_SHOWSETPPM,
                             &g_iShowSetPPM);

        CloseCurrentUser(hKeyCurrentUser);
    }
}
#endif

#ifdef WINNT
/*******************************************************************************
*
*  InitAdmin
*
*  DESCRIPTION:
*   For NT only, initialize an administrator power policy which
*   supports an optional administrative override of certain
*   power policy settings. The PowerCfg.Cpl and PPM will use these
*   override values during validation.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID InitAdmin(PADMINISTRATOR_POWER_POLICY papp)
{
    INT         i;
    NTSTATUS    ntsRetVal;
    HKEY        hKeyCurrentUser;

    if (ERROR_SUCCESS == OpenCurrentUser2(&hKeyCurrentUser))
    {
        if (ReadPowerIntOptional(hKeyCurrentUser, c_szREGSTR_PATH_USER_POWERCFG, c_szREGSTR_VAL_ADMINMAXSLEEP, &i))
        {
            g_app.MaxSleep = (SYSTEM_POWER_STATE) i;
            g_bAdminOverrideActive = TRUE;
        }

        if (ReadPowerIntOptional(hKeyCurrentUser, c_szREGSTR_PATH_USER_POWERCFG, c_szREGSTR_VAL_ADMINMAXVIDEOTIMEOUT, &i))
        {
            g_app.MaxVideoTimeout = i;
            g_bAdminOverrideActive = TRUE;
        }

        CloseCurrentUser(hKeyCurrentUser);
    }

    // If an administration override was set, call down to the power
    // policy manager to set the administrator policy.
    if (g_bAdminOverrideActive)
    {
        ntsRetVal = CallNtPowerInformation(AdministratorPowerPolicy, &g_app, sizeof(ADMINISTRATOR_POWER_POLICY),
                                                &g_app, sizeof(ADMINISTRATOR_POWER_POLICY));
        if (ntsRetVal != STATUS_SUCCESS)
        {
            DebugPrint( "DllInitialize, Set AdministratorPowerPolicy failed: 0x%08X", ntsRetVal);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\reghelp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       REGHELP.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*******************************************************************************/




DWORD ReadPwrPolicyEx2(LPTSTR lpszUserKeyName, LPTSTR lpszMachineKeyName, LPTSTR lpszSchemeName, LPTSTR lpszDesc,
        LPDWORD lpdwDescSize, LPVOID lpvUser, DWORD dwcbUserSize, LPVOID lpvMachine, DWORD dwcbMachineSize);
DWORD OpenMachineUserKeys2(LPTSTR lpszUserKeyName, LPTSTR lpszMachineKeyName, PHKEY phKeyUser, PHKEY phKeyMachine);
DWORD OpenCurrentUser2(PHKEY phKey);
DWORD ReadProcessorPwrPolicy(LPTSTR lpszMachineKeyName, LPTSTR lpszSchemeName, LPVOID lpvMachineProcessor, DWORD dwcbMachineProcessorSize);
DWORD WriteProcessorPwrPolicy(LPTSTR lpszMachineKeyName, LPTSTR lpszSchemeName, LPVOID lpvMachineProcessor, DWORD dwcbMachineProcessorSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\parse.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       PARSE.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        1 Jan, 1997
*
*  DESCRIPTION:
*
*   Declarations and definitions for the parse helper.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <memory.h>
#include <windows.h>
#include <regstr.h>
#include <ntpoapi.h>

#include "powrprofp.h"

#define MAX_LINES           256
#define MAX_STR             128
#define DELIMITERS          ","
#define LINE_DELIMITERS     "\n\r"

// The following defines determine which zero based line of the spread sheet
// a given data will appear on. These are one based line indicies which match
// the spreadsheet line numbers as long as no blank lines are included.
 
#define SKU_LINE                                1
#define NAME_LINE                               2
#define DESCRIPTION_LINE                        3

#define PLATFORM_LINE                           4
#define INSTALL_ON_LINE                         5

#define SYSTEM_IDLE_LINE                        SKU_LINE + 7
#define SYSTEM_IDLE_TIMEOUT_LINE                SYSTEM_IDLE_LINE + 1
#define SYSTEM_IDLE_SLEEP_ACTION_FLAGS_LINE     SYSTEM_IDLE_LINE + 2
#define SYSTEM_IDLE_SENSITIVITY_LINE            SYSTEM_IDLE_LINE + 8

#define MIN_SLEEP_LINE                          SKU_LINE + 17
#define MAX_SLEEP_LINE                          MIN_SLEEP_LINE + 1
#define REDUCED_LATENCY_SLEEP_LINE              MIN_SLEEP_LINE + 2
#define DOZE_TIMEOUT_LINE                       MIN_SLEEP_LINE + 3
#define DOZE_S4_TIMEOUT_LINE                    MIN_SLEEP_LINE + 4

#define VIDEO_TIMEOUT_LINE                      SKU_LINE + 23
#define SPINDOWN_TIMEOUT_LINE                   VIDEO_TIMEOUT_LINE + 1

#define OPTIMIZE_FOR_POWER_LINE                 SKU_LINE + 26
#define FAN_THROTTLE_TOL_LINE                   OPTIMIZE_FOR_POWER_LINE + 1
#define FORCED_THROTTLE_LINE                    OPTIMIZE_FOR_POWER_LINE + 2
#define MIN_THROTTLE_LINE                       OPTIMIZE_FOR_POWER_LINE + 3
#define OVERTHROTTLED_LINE                      OPTIMIZE_FOR_POWER_LINE + 4
#define OVERTHROTTLED_SLEEP_ACTION_FLAGS_LINE   OPTIMIZE_FOR_POWER_LINE + 5

#define DYNAMIC_THROTTLE_LINE                   OPTIMIZE_FOR_POWER_LINE + 11
#define C1_THRESHOLDS_LINE                      DYNAMIC_THROTTLE_LINE + 1
#define C2_THRESHOLDS_LINE                      C1_THRESHOLDS_LINE + 8
#define C3_THRESHOLDS_LINE                      C2_THRESHOLDS_LINE + 8

// Global
#define ADVANCED_LINE                           64
#define LOCK_ON_SLEEP_LINE                      ADVANCED_LINE + 1
#define WAKE_ON_RING_LINE                       ADVANCED_LINE + 2
#define VIDEO_DIM_DISPLAY_LINE                  ADVANCED_LINE + 3
#define POWER_BUTTON_LINE                       ADVANCED_LINE + 5
#define POWER_BUTTON_SLEEP_ACTION_FLAGS_LINE    ADVANCED_LINE + 6
#define POWER_BUTTON_SLEEP_EVENT_CODE_LINE      ADVANCED_LINE + 12
#define SLEEP_BUTTON_LINE                       ADVANCED_LINE + 14
#define SLEEP_BUTTON_SLEEP_ACTION_FLAGS_LINE    ADVANCED_LINE + 15
#define SLEEP_BUTTON_SLEEP_EVENT_CODE_LINE      ADVANCED_LINE + 21
#define LID_CLOSE_LINE                          ADVANCED_LINE + 23
#define LID_CLOSE_SLEEP_ACTION_FLAGS_LINE       ADVANCED_LINE + 24
#define LID_OPEN_WAKE_LINE                      ADVANCED_LINE + 30

#define BROADCAST_CAP_RES_LINE                  96
#define BATMETER_ENABLE_SYSTRAY_FLAG_LINE       BROADCAST_CAP_RES_LINE + 2
#define BATMETER_ENABLE_MULTI_FLAG_LINE         BROADCAST_CAP_RES_LINE + 3
#define DISCHARGE_POLICY_1_LINE                 BROADCAST_CAP_RES_LINE + 4
#define DISCHARGE_POLICY_2_LINE                 BROADCAST_CAP_RES_LINE + 18

// Handy line offsets, for sleep action flags.
#define QUERY_APPS                      1
#define ALLOW_UI                        2
#define IGNORE_NON_RESP                 3
#define IGNORE_WAKE                     4
#define IGNORE_CRITICAL                 5

// offsets for sleep action event codes
#define NOTIFY_USER_CODE                1


// Handy line offsets for DISCHARGE_POLICIES
#define DP_ENABLE                       1
#define DP_BAT_LEVEL                    2
#define DP_POWER_POLICY                 3
#define DP_MIN_SLEEP_STATE              4
#define DP_TEXT_NOTIFY                  6
#define DP_SOUND_NOTIFY                 7
#define DP_SLEEP_ACT_FLAGS              8

// Handy line offsets for C-state thresholds
#define C_TIME_CHECK                    1
#define C_PROMOTE_LIMIT                 2
#define C_DEMOTE_LIMIT                  3
#define C_PROMOTE_PERCENT               4
#define C_DEMOTE_PERCENT                5
#define C_ALLOW_PROMOTION               6
#define C_ALLOW_DEMOTION                7

// Memphis INF types:

#define TYPICAL         0x01
#define COMPACT         0x02
#define CUSTOM          0x04
#define PORTABLE        0x08
#define SERVER          0x10
#define NUM_INF_TYPES   5

// OS types:
#define WIN_95          1
#define WIN_NT          2

// file locations
#define MACHINE_INF_NAME    "..\\winnt\\POWERSYS.INF"
#define USER_INF_NAME       "..\\winnt\\POWERSFT.INF"
#define INI_NAME            "POWERCFG.INI"

#define MAX_SKUS            6
#define MAX_PROFILES        16
#define MAX_LINE_SIZE       1024
#define DATA_REV            1

extern char *g_pszSrc[MAX_SKUS];
extern char *g_pszLines[MAX_SKUS][MAX_LINES];
extern char *g_pszSkuNames[MAX_SKUS];
extern char g_pszSkuDecoration[MAX_SKUS];

extern UINT g_uiPoliciesCount[MAX_SKUS];

extern PMACHINE_POWER_POLICY       g_pmpp[MAX_SKUS][MAX_PROFILES];
extern PUSER_POWER_POLICY          g_pupp[MAX_SKUS][MAX_PROFILES];
extern PMACHINE_PROCESSOR_POWER_POLICY g_ppmpp[MAX_SKUS][MAX_PROFILES];

extern GLOBAL_USER_POWER_POLICY    g_gupp[MAX_SKUS];
extern GLOBAL_MACHINE_POWER_POLICY g_gmpp[MAX_SKUS];


// Function prototypes implemented in MAKEINI.C or MAKEINF.C:
VOID CDECL DefFatalExit(BOOLEAN, char*, ... );

// Function prototypes implemented in PARSE.C:

void StrToUpper(char*, char*);
UINT GetTokens(char*, UINT, char**, UINT, char*);
VOID GetCheckLabelToken(UINT uiLine, char *pszCheck, UINT uiSku);
UINT GetFlagToken(UINT);
UINT GetPowerStateToken(VOID);
UINT GetIntToken(char*);
VOID GetNAToken(VOID);
POWER_ACTION GetPowerActionToken(VOID);
UINT GetOSTypeToken(VOID);
UINT GetINFTypeToken(VOID);
void StrTrimTrailingBlanks(char *);
UINT GetThrottleToken(VOID);
VOID CDECL DefFatalExit(BOOLEAN bGetLastError, char *pszFormat, ... );
BOOLEAN ReadSource(void);
UINT BuildLineArray(void);
VOID GetSleepActionFlags(
    UINT    uiStartLine,
    UINT    uiFlagsAC[],
    UINT    uiFlagsDC[],
    PUINT   puiCount,
    UINT    sku
    );
VOID GetSleepActionFlagsGlobal(
    UINT                    uiStartLine,
    PPOWER_ACTION_POLICY    ppapAC,
    PPOWER_ACTION_POLICY    ppapDC,
    UINT    sku
    );
VOID GetSleepActionFlagsUserPolicy(
    UINT    uiStartLine,
    ULONG   ulAcPowerPolicyOffset,
    ULONG   ulDcPowerPolicyOffset,
    PUINT   puiCount,
    UINT    sku
    );
VOID GetSleepActionFlagsMachinePolicy(
    UINT    uiStartLine,
    ULONG   ulAcPowerPolicyOffset,
    ULONG   ulDcPowerPolicyOffset,
    PUINT   puiCount,
    UINT    sku
    );
VOID GetCStateThresholds(
    UINT    uiStartLine,
    UINT    uiCState,
    PUINT   puiCount,
    UINT    sku
    );
VOID GetDischargePolicies(
    UINT uiLine,
    UINT uiNum,
    UINT uiIndex,
    UINT    sku
    );
BOOLEAN GetGlobalPolicies(void);
BOOLEAN GetPolicies(void);
VOID GetPolicyInf(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\sources.inc ===
CCSHELL_DIR=$(PROJECT_ROOT)

!include $(PROJECT_ROOT)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(PROJECT_ROOT)\common.inc

TARGETNAME      = powrprof
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
DLLENTRY        = DllInitialize

TARGETLIBS      = $(LIBRARY_PATH)\user32.lib \
                  $(LIBRARY_PATH)\kernel32.lib \
                  $(LIBRARY_PATH)\advapi32.lib

!ifdef TARGET_WIN95
USE_LIBCMT      = 1
TARGETLIBS      = $(TARGETLIBS) $(LIBRARY_PATH)\setupapi.lib
!else
USE_MSVCRT      = 1
TARGETLIBS      = $(TARGETLIBS) $(LIBRARY_PATH)\ntdll.lib
PASS1_PUBLISH={$(O)\powrprof.lib=$(SDK_LIB_PATH)\powrprof.lib}
!endif

DLLDEF          = ..\powrprof.def

UMENTRYABS      = ModuleEntry

SOURCES         = ..\powrprof.c      \
                  ..\reghelp.c       \
                  ..\merge.c         \
                  ..\debug.c         \
                  ..\powrprof.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\inf\makeinf.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       MAKEINF.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        1 Jan, 1997
*
*  DESCRIPTION:
*   Main code for the default power schemes INF generator, MAKEINF.EXE.
*   Generates INF file which can be read by Memphis setup.
*
*******************************************************************************/

#include "parse.h"

/*******************************************************************************
*
*  WriteRegBinary
*
*  DESCRIPTION:
*   Write binary data out to the registry specification file.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID WriteRegBinary(FILE *fInf, PVOID pv, UINT uiSize, char *pszIndent, char *pszDecoration)
{
    PBYTE   pb = pv;
    UINT    uiRow = 0;

    fprintf(fInf, "%s%s", pszDecoration, pszIndent);
    while (uiSize) {
        if (uiSize > 1) {
            fprintf(fInf, "%02X,", *pb++);
        }
        else {
            fprintf(fInf, "%02X", *pb++);
        }
        uiSize--;
        if (uiRow++ == 15) {
            uiRow = 0;
            if (uiSize > 1) {
                fprintf(fInf, "\\\n%s%s", pszDecoration, pszIndent);
            }
            else {
                fprintf(fInf, "\n");
            }
        }
    }

}

/*******************************************************************************
*
*  WriteInfHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WriteInfHeader(FILE *fInf)
{
    fprintf(fInf, "; POWERCFG.INF\n");
    fprintf(fInf, "; Copyright (c) 1993-2000, Microsoft Corporation\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[Version]\n");
    fprintf(fInf, "Signature  = \"$CHICAGO$\"\n");
    fprintf(fInf, "SetupClass = BASE\n");
    fprintf(fInf, "LayoutFile = layout.inf, layout1.inf\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[DestinationDirs]\n");
    fprintf(fInf, "PowerCfg.copy.inf = 17   ; LDID_INF\n");
    fprintf(fInf, "PowerCfg.copy.sys = 11   ; LDID_SYS\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[BaseWinOptions]\n");
    fprintf(fInf, "PowerCfg.base\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[PowerCfg.base]\n");
    fprintf(fInf, "CopyFiles = PowerCfg.copy.inf, PowerCfg.copy.sys\n");
    fprintf(fInf, "AddReg    = PowerCfg.addreg\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[PowerCfg.copy.inf]\n");
    fprintf(fInf, "; files to copy to \\windows\\inf directory\n");
    fprintf(fInf, "PowerCfg.inf\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[PowerCfg.copy.sys]\n");
    fprintf(fInf, "; files to copy to \\windows\\system directory\n");
    fprintf(fInf, "powercfg.cpl\n");
    fprintf(fInf, "powrprof.dll\n");
    fprintf(fInf, "batmeter.dll\n");
    fprintf(fInf, "\n");
    fprintf(fInf, "[PowerCfg.addreg]\n");

    return TRUE;
}

/*******************************************************************************
*
*  TabTo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID TabTo(FILE *fInf, UINT uiCharSoFar, UINT uiCol)
{
    UINT i;

    for (i = 0; i < (uiCol - uiCharSoFar); i++) {
        fprintf(fInf, " ");
    }
}

/*******************************************************************************
*
*  WriteNTInf
*
*  DESCRIPTION:
*   Write out the NT setup file in INF format.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WriteNTInf(
    char **pszName,
    char **pszDesc,
    char **pszDecoration,
    UINT uiCount
)
{
    UINT i, sku;
    FILE *fInf;
    static char skuDecoration[5];
    UINT    compareVal;

    //
    // First, write the Software Hive. (Machine policy.)
    //

    if ((fInf = fopen(MACHINE_INF_NAME, "w+")) != NULL) {
        printf("\nWriting Machine INF specification file: %s", MACHINE_INF_NAME);
    }
    else {
        DefFatalExit(TRUE, "Error opening INF specification file: %s for output\n", MACHINE_INF_NAME);
    }

    // Write fixed header information.
    WriteInfHeader(fInf);
    printf(".");

    //
    // Now we write the machine hives, by SKU.  SKU 0 is the default SKU.
    // it gets written without any decoration.  If another SKU is different
    // from the default SKU, it gets written, too, but with its own decoration.
    //

    for (sku = 0; sku < MAX_SKUS; sku++) {

        if (sku == 0) {

            strcpy(skuDecoration, "\0");
        
        } else {

            //printf("\nSKU decoration %s\n", pszDecoration[sku]);
            sprintf(skuDecoration, "@%s:", pszDecoration[sku]);
        }
    
        compareVal = 1;
        if (sku != 0) {

            compareVal = memcmp(&g_gmpp[sku], 
                                &g_gmpp[0], 
                                sizeof(GLOBAL_MACHINE_POWER_POLICY));
        }

        if (compareVal) {

            // Machine misc.
            fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\",\"LastID\",0x00000002,\"%d\"\n", skuDecoration,uiCount - 1);
            fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\",\"DiskSpinDownMax\",0x00000002,\"3600\"\n", skuDecoration);
            fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\",\"DiskSpinDownMin\",0x00000002,\"3\"\n", skuDecoration);
            fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\\GlobalPowerPolicy\",\"Policies\",0x00030001,\\\n", skuDecoration);
            WriteRegBinary(fInf, &g_gmpp[sku], sizeof(GLOBAL_MACHINE_POWER_POLICY),
                           "                   ", skuDecoration);
            fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\\PowerPolicies\",,0x00000012\n", skuDecoration);
            fprintf(fInf, "\n\n");
            printf(".");
        }

        for (i = 0; i < uiCount; i++) {
            
            compareVal = 1;
            if (sku != 0) {

                compareVal = memcmp(g_pmpp[sku][i], 
                                    g_pmpp[0][i], 
                                    sizeof(MACHINE_POWER_POLICY));
            }                       

            if (compareVal) {
                fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\\PowerPolicies\\%d\",\"Policies\",0x00030003,\\\n", skuDecoration, i);
                WriteRegBinary(fInf, g_pmpp[sku][i], sizeof(MACHINE_POWER_POLICY),"  ", skuDecoration);
                fprintf(fInf, "\n");
                printf(".");
            }
        }

        for (i = 0; i < uiCount; i++) {
                
           compareVal = 1;
           if (sku != 0) {
               compareVal = memcmp(g_ppmpp[sku][i], 
                                   g_ppmpp[0][i], 
                                   sizeof(MACHINE_PROCESSOR_POWER_POLICY));
           }

           if (compareVal) {
               fprintf(fInf, "%sHKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\\ProcessorPolicies\\%d\",\"Policies\",0x00030001,\\\n", skuDecoration, i);
               WriteRegBinary(fInf, g_ppmpp[sku][i], sizeof(MACHINE_PROCESSOR_POWER_POLICY),"  ", skuDecoration);
               fprintf(fInf, "\n");
               printf(".");
           }
           
        }
    }
    
    fclose(fInf);
    
    //
    // Next, write the User Hive.  (User Policy.)
    //

    if ((fInf = fopen(USER_INF_NAME, "w+")) != NULL) {
        printf("\nWriting User INF specification file: %s\n", USER_INF_NAME);
    }
    else {
        DefFatalExit(TRUE, "Error opening INF specification file: %s for output\n", USER_INF_NAME);
    }

    // Write fixed header information.
    WriteInfHeader(fInf);
    printf(".");

    // User misc.
    fprintf(fInf, "HKCU,\"Control Panel\\PowerCfg\",CurrentPowerPolicy,0x00000002,\"0\"\n");

    for (sku = 0; sku < MAX_SKUS; sku++) {

        if (sku == 0) {

            strcpy(skuDecoration, "\0");
        
        } else {

            sprintf(skuDecoration, "@%s:", pszDecoration[sku]);
        }
    
        compareVal = 1;
        if (sku != 0) {

            compareVal = memcmp(&g_gupp[sku], 
                                &g_gupp[0], 
                                sizeof(GLOBAL_USER_POWER_POLICY));
        }
        
        if (compareVal) {
            
            // User global policies.
            fprintf(fInf, "%sHKCU,\"Control Panel\\PowerCfg\\GlobalPowerPolicy\",Policies,0x00030003,\\\n", skuDecoration);
            WriteRegBinary(fInf, &g_gupp[sku], sizeof(GLOBAL_USER_POWER_POLICY), "  ", skuDecoration);
            fprintf(fInf, "\n\n");
            printf(".");

        }
    
        // User power schemes.
        for (i = 0; i < uiCount; i++) {
            
            compareVal = 1;
            if (sku != 0) {

                compareVal = memcmp(g_pupp[sku][i], 
                                    g_pupp[0][i], 
                                    sizeof(USER_POWER_POLICY));
            }

            if (compareVal) {
                fprintf(fInf, "%sHKCU,\"Control Panel\\PowerCfg\\PowerPolicies\\%d\",Name,0x00000002,\"%s\"\n", skuDecoration, i, pszName[i]);
                fprintf(fInf, "%sHKCU,\"Control Panel\\PowerCfg\\PowerPolicies\\%d\",Description,0x00000002,\"%s\"\n", skuDecoration, i, pszDesc[i]);
                fprintf(fInf, "%sHKCU,\"Control Panel\\PowerCfg\\PowerPolicies\\%d\",Policies,0x00030003,\\\n", skuDecoration, i);
                WriteRegBinary(fInf, g_pupp[sku][i], sizeof(USER_POWER_POLICY),"  ", skuDecoration);
                fprintf(fInf, "\n\n");
                printf(".");
            }
        }
    }
    
    fclose(fInf);
    printf("OK\n");
    return TRUE;
}

/*******************************************************************************
*
*  main
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void __cdecl main (int argc, char **argv)
{
    DWORD   dwSize;
    char    *psz;
    FILE    *fInf;
    UINT    uiNameCount, uiDescCount, i, sku;
    char    *p;
    char    *pszName[MAX_PROFILES];
    char    *pszDesc[MAX_PROFILES];
    char    *pszDecoration[MAX_SKUS];
    char    *pszTok;

    printf("Building name and description arrays...\n");
    ReadSource();
    BuildLineArray();

    for (sku = 0; sku < MAX_SKUS; sku++) {

        printf("  Parsing names, SKU[%d].", sku);
        GetCheckLabelToken(SKU_LINE, "SKU Decoration", sku);
        
        pszTok = strtok(NULL, DELIMITERS);
        StrTrimTrailingBlanks(pszTok);

        pszDecoration[sku] = malloc(5);
        if (!pszDecoration[sku]) {
            printf("Failed to alloc memory\n");
            exit (0);
        }
        strncpy(pszDecoration[sku], pszTok, 2);
        
        GetCheckLabelToken(NAME_LINE, "Name", sku);
        uiNameCount = GetTokens(NULL, REGSTR_MAX_VALUE_LENGTH, pszName,
                                MAX_PROFILES, DELIMITERS);
        if (uiNameCount) {
            printf("  Parsed %d names successfully.\n", uiNameCount);
            printf("  Parsing descriptions.");
            GetCheckLabelToken(DESCRIPTION_LINE, "Description", sku);
            uiDescCount = GetTokens(NULL, MAX_DESC_LEN, pszDesc,
                                    MAX_PROFILES, DELIMITERS);
            if (uiDescCount == uiNameCount) {
                printf("  Parsed %d descriptions successfully.\n", uiDescCount);
                g_uiPoliciesCount[sku] = uiNameCount;

            }
            else {
                printf("  Name count: %d != description count: %d.\n", uiNameCount, uiDescCount);
                printf("ProcessAndWrite failed, Last Error: %d\n", GetLastError());
                exit(1);
            }
        }
        else {
            printf("  Name parsing failure.\n");
            printf("ProcessAndWrite failed, Last Error: %d\n", GetLastError());
            exit(1);
        }
    }
    
    // Get the power policies, schemes
    GetPolicies();

    // Get the global power policies
    GetGlobalPolicies();

    // Write the INF specification files.
    WriteNTInf(pszName, pszDesc, pszDecoration, g_uiPoliciesCount[0]);
    printf("\n\nDefault Processing Success. Output files are valid.\n");
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\bandpage.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       BANDPAGE.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _BANDWIDTHPAGE_H
#define _BANDWIDTHPAGE_H

#include "PropPage.h"
#include "FuelBar.h"
#include "UsbItem.h"

#define idh_devmgr_usb_band_bar 300700
#define	idh_devmgr_usb_list_devices 300800
#define	idh_devmgr_usb_refresh_button 300910
#define	idh_devmgr_disable_error_detection 300912

class BandwidthPage : public UsbPropertyPage {
public:
    BandwidthPage(UsbItem *item) : UsbPropertyPage(item) {Initialize();}
    BandwidthPage(HWND HWndParent, LPCSTR DevName) : UsbPropertyPage(HWndParent, DevName) {Initialize();}
    BandwidthPage(HDEVINFO         DeviceInfoSet,        
                  PSP_DEVINFO_DATA DeviceInfoData) :
        UsbPropertyPage(DeviceInfoSet, DeviceInfoData) {Initialize();}

    HPROPSHEETPAGE Create();
    static BOOL IsErrorCheckingEnabled();

protected:
    // message handlers
    BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl);
    BOOL OnInitDialog();
    BOOL OnNotify(HWND hDlg, INT nID , LPNMHDR pnmh);
    void OnNotifyListDevices(HWND hDlg, LPNMHDR pnmh);
    UINT SetErrorCheckingEnable(BOOL ErrorCheckingEnabled);
    void EnableSystray(BOOL fEnable);

    void Refresh();

    VOID Initialize();

    BOOL newDisableErrorChecking, oldDisableErrorChecking;
    HWND hLstDevices;

    FuelBar fuelBar;
};
#endif // _BANDWIDTHPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\powrprof\ini\makeini.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       MAKEINI.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        1 Jan, 1997
*
*  DESCRIPTION:
*   Main code for the default power schemes ini file generator, MAKEINI.EXE.
*   Generates a registry specification file which can be read by REGINI.EXE.
*
*******************************************************************************/

#include "parse.h"
#define SRC_NAME "..\\DEFAULTS.CSV"

VOID GetPolicyInf(void)
{
    return;
}

/*******************************************************************************
*
*  WriteRegBinary
*
*  DESCRIPTION:
*   Write binary data out to the registry specification file.
*
*  PARAMETERS:
*
*******************************************************************************/

VOID WriteRegBinary(FILE *fIni, PVOID pv, UINT uiSize, char *pszIndent)
{
    PDWORD  pdw = pv;
    DWORD   dw;
    PBYTE   pb;
    UINT    uiRow = 2;
    UINT    uiNumDWords, uiNumBytes;

    fprintf(fIni, "REG_BINARY 0x%08X ", uiSize);

    uiNumDWords = uiSize / sizeof(DWORD);
    uiNumBytes  = uiSize % sizeof(DWORD);
    while (uiNumDWords) {
        fprintf(fIni, "0x%08X ", *pdw++);
        uiNumDWords--;
        if (uiRow++ == 3) {
            uiRow = 0;
            fprintf(fIni, "\\\n%s", pszIndent);
        }
    }

    if (uiNumBytes) {
        pb = (PBYTE)pdw;
        dw = (DWORD)*pb++;

        if (uiNumBytes >= 2) {
            dw |=  ((DWORD)*pb++ << 8);
        }

        if (uiNumBytes == 3) {
            dw |=  ((DWORD)*pb << 16);
        }
    }
}

/*******************************************************************************
*
*  WriteRegSpec
*
*  DESCRIPTION:
*   Write out the registry specification file in REGINI format.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN WriteRegSpec(FILE *fIni, char **pszName, char **pszDesc, UINT uiCount)
{
    UINT i;

    // PowerCfg sound events
    fprintf(fIni, "USER:\\AppEvents\n");
    fprintf(fIni, "    EventLabels\n");
    fprintf(fIni, "       LowBatteryAlarm\n");
    fprintf(fIni, "           = Low Battery Alarm\n");
    fprintf(fIni, "       CriticalBatteryAlarm\n");
    fprintf(fIni, "            = Critical Battery Alarm\n\n");
    fprintf(fIni, "USER:\\AppEvents\n");
    fprintf(fIni, "    Schemes\n");
    fprintf(fIni, "        Apps\n");
    fprintf(fIni, "            PowerCfg\n");
    fprintf(fIni, "                = Power Management\n");
    fprintf(fIni, "                LowBatteryAlarm\n");
    fprintf(fIni, "                    .Current\n");
    fprintf(fIni, "                        = ding.wav\n");
    fprintf(fIni, "                    .Default\n");
    fprintf(fIni, "                        =\n");
    fprintf(fIni, "                CriticalBatteryAlarm\n");
    fprintf(fIni, "                    .Current\n");
    fprintf(fIni, "                        = ding.wav\n");
    fprintf(fIni, "                    .Default\n");
    fprintf(fIni, "                        =\n\n");

    // User misc.
    fprintf(fIni, "USER:\\Control Panel\\PowerCfg\n");
    fprintf(fIni, "    CurrentPowerPolicy = 0\n");

    // User global policies.
    fprintf(fIni, "    GlobalPowerPolicy\n");
    fprintf(fIni, "        Policies = ");
    WriteRegBinary(fIni, &g_gupp, sizeof(GLOBAL_USER_POWER_POLICY),
                   "                   ");
    fprintf(fIni, "\n\n");

    // User power schemes.
    fprintf(fIni, "    PowerPolicies\n");
    for (i = 0; i < uiCount; i++) {
        fprintf(fIni, "        %d\n", i);
        fprintf(fIni, "            Name = %s\n", pszName[i]);
        fprintf(fIni, "            Description = %s\n", pszDesc[i]);
        fprintf(fIni, "            Policies = ");
        WriteRegBinary(fIni, g_pupp[i], sizeof(USER_POWER_POLICY),
                       "                       ");
        fprintf(fIni, "\n\n");
    }

    // Machine misc.
    fprintf(fIni, "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\PowerCfg\n");
    fprintf(fIni, "    DiskSpinDownMax = 3600\n");
    fprintf(fIni, "    DiskSpinDownMin = 3\n");

    fprintf(fIni, "    LastID = %d\n", uiCount - 1);

    fprintf(fIni, "    GlobalPowerPolicy\n");
    fprintf(fIni, "        Policies = ");
    WriteRegBinary(fIni, &g_gmpp, sizeof(GLOBAL_MACHINE_POWER_POLICY),
                   "                   ");
    fprintf(fIni, "\n\n");
    fprintf(fIni, "    PowerPolicies\n");
    for (i = 0; i < uiCount; i++) {
        fprintf(fIni, "        %d\n", i);
        fprintf(fIni, "            Policies = ");
        WriteRegBinary(fIni, g_pmpp[i], sizeof(MACHINE_POWER_POLICY),
                       "                       ");
        fprintf(fIni, "\n\n");
    }

    fprintf(fIni, "\n\n");
    fprintf(fIni, "    ProcessorPolicies\n");
    for (i = 0; i < uiCount; i++) {
        fprintf(fIni, "        %d\n", i);
        fprintf(fIni, "            Policies = ");
        WriteRegBinary(fIni, g_ppmpp[i], sizeof(MACHINE_PROCESSOR_POWER_POLICY),
                       "                       ");
        fprintf(fIni, "\n\n");
    }

    return TRUE;
}

/*******************************************************************************
*
*  main
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void __cdecl main (int argc, char **argv)
{
    DWORD   dwSize;
    char    *psz;
    FILE    *fIni;
    UINT    uiNameCount, uiDescCount;
    char    *pszName[MAX_PROFILES];
    char    *pszDesc[MAX_PROFILES];

    printf("Processing: %s\n", SRC_NAME);

    printf("Building name and description arrays...\n");
    ReadSource();
    BuildLineArray();

    if ((fIni = fopen(INI_NAME, "w+")) != NULL) {
        printf("Writing registry specification file: %s\n", INI_NAME);
    }
    else {
        DefFatalExit(TRUE, "Error opening registry specification file: %s for output\n", INI_NAME);
    }

            printf("  Parsing names.");
            GetCheckLabelToken(NAME_LINE, "Name", 0);
            uiNameCount = GetTokens(NULL, REGSTR_MAX_VALUE_LENGTH, pszName,
                                    MAX_PROFILES, DELIMITERS);
            if (uiNameCount) {
                printf("  Parsed %d names successfully.\n", uiNameCount);
                printf("  Parsing descriptions.");
                GetCheckLabelToken(DESCRIPTION_LINE, "Description", 0);
                uiDescCount = GetTokens(NULL, MAX_DESC_LEN, pszDesc,
                                        MAX_PROFILES, DELIMITERS);
                if (uiDescCount == uiNameCount) {
                    printf("  Parsed %d descriptions successfully.\n", uiDescCount);
                    g_uiPoliciesCount[0] = uiNameCount;

                    // Get the power policies, schemes
                    GetPolicies();

                    // Get the global power policies
                    GetGlobalPolicies();

                    // Write the registry specification file.
                    WriteRegSpec(fIni, pszName, pszDesc, g_uiPoliciesCount[0]);

                    printf("Registry specification file: %s, written sucessfully \n", INI_NAME);
                    fclose(fIni);
                    printf("\n\nDefault Processing Success. Output file is valid.\n");
                    exit(0);
                }
                else {
                    printf("  Name count: %d != description count: %d.\n", uiNameCount, uiDescCount);
                }
            }
            else {
                printf("  Name parsing failure.\n");
            }

    printf("ProcessAndWrite failed, Last Error: %d\n", GetLastError());
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\bandpage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       BANDPAGE.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include <assert.h>

#include "resource.h"

#include "BandPage.h"
#include "ItemFind.h"
#include "debug.h"
#include "UsbItem.h"
#include "usbutil.h"
#include <shellapi.h>
#include <systrayp.h>

const DWORD BandHelpIds[] = {
    IDC_STATIC, IDH_NOHELP,	//description text
    IDC_BANDWIDTH_BAR, idh_devmgr_usb_band_bar,	//bandwidth bar
    IDC_LIST_DEVICES, idh_devmgr_usb_list_devices,	//list box for devices
    IDC_REFRESH, idh_devmgr_usb_refresh_button,
	IDC_DISABLE_ERROR_DETECTION, idh_devmgr_disable_error_detection, //new radio button
    IDC_BAND_TEXT, IDH_NOHELP,
    IDC_BAND_TEXT2, IDH_NOHELP,
    0, 0
};                         

static const TCHAR g_szUsbRegValue[] = TEXT("ErrorCheckingEnabled");
static const TCHAR g_szWindowClassName[] = SYSTRAY_CLASSNAME;
static const TCHAR g_szUsbRegPath[] = 
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Usb");

VOID 
BandwidthPage::Initialize()
{
    hLstDevices = NULL;
    dlgResource = IDD_BANDWIDTH;
    HelpIds = (const DWORD *) BandHelpIds;
    newDisableErrorChecking = oldDisableErrorChecking = 0;
}

void BandwidthPage::Refresh()
{
    LVITEM item;
    UINT   interruptBW;
    int i = 0;
    UsbItem *usbItem, *controller;
    TCHAR buf[MAX_PATH];

    //
    // Clear all UI components, and then recreate the rootItem
    //
    fuelBar.ClearItems();
    ListView_DeleteAllItems(hLstDevices);
    if (rootItem) {
        DeleteChunk(rootItem);
        delete rootItem;
    }
    rootItem = new UsbItem;
    AddChunk(rootItem);

    //
    // Find out which mode we're being created in
    //
    if (preItem) {
        //
        // Control panel applet is creating the page
        //
        controller = preItem;
    } else {
        if (deviceName.empty()) {
            if (!GetDeviceName()) {
                return;
            }
        }
        controller = rootItem;
        if (deviceInfoData) {
            if (!controller->EnumerateController(0, 
                                                 deviceName, 
                                                 &imageList, 
                                                 deviceInfoData->DevInst)) {
                return;
            }
        } else {
            if (!controller->EnumerateController(0, 
                                                 deviceName, 
                                                 &imageList, 
                                                 NULL)) {
                return;
            }
        }
    }

    UsbItemActionFindIsoDevices find;
    controller->Walk(find);

    ZeroMemory(&item, sizeof(LVITEM));
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;

    // 
    // Insert the devices using more than 5% of the bus bandwidth. In other
    // words, add the devices using Isochronous BW.
    //
    UsbItemList& isoDevices = find.GetIsoDevices();
    for (usbItem = isoDevices.begin() ? *isoDevices.Current() : NULL; 
         usbItem; 
         usbItem = isoDevices.next() ? *isoDevices.Current() : NULL,
             i++) {
        item.iItem = 0;
        item.iImage = usbItem->imageIndex;
        item.lParam = (LPARAM) usbItem;
        assert(usbItem->configInfo != NULL);
        item.pszText = (LPTSTR) usbItem->configInfo->deviceDesc.c_str();

        UsbSprintf(buf, TEXT("%d%%"), usbItem->bandwidth);

        fuelBar.AddItem(usbItem->bandwidth, usbItem, usbItem->imageIndex);
        ListView_InsertItem(hLstDevices, &item);
        ListView_SetItemText(hLstDevices, 0, 1, buf);
    }

    //
    // Add an item indicating that the system always uses 10%
    //
    item.iItem = 0;
    imageList.GetClassImageIndex(MyComputerClass, &item.iImage);
    item.lParam = (LPARAM) rootItem;
    LoadString(gHInst, IDS_BANDWIDTH_CONTROLLER_RSRVD, buf, MAX_PATH);
    item.pszText = buf;

    interruptBW = 10 + UsbItem::CalculateBWPercent(find.InterruptBW());
    fuelBar.AddItem(interruptBW, (LPVOID) rootItem, item.iImage);
    ListView_InsertItem(hLstDevices, &item);
    wsprintf(buf,_T("%d%%"),interruptBW);
    ListView_SetItemText(hLstDevices, 0, 1, buf);
                                           
}

BOOL BandwidthPage::OnInitDialog()
{
    LV_COLUMN column;
    RECT rect;
    TCHAR buf[MAX_PATH];

    if (preItem) {
        SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & ~WS_CAPTION);
        //
        // Make the Refresh button go away
        //
        HWND hRefresh;
        if (NULL != (hRefresh = GetDlgItem(hwnd, IDC_REFRESH)) ) {
            SetWindowLong(hRefresh, 
                          GWL_STYLE, 
                          (GetWindowLong(hRefresh, GWL_STYLE) | WS_DISABLED) & 
                          ~WS_VISIBLE );
        }
    } else if (!deviceInfoSet && !deviceInfoData) {
        //
        // Make the Close button visible
        //
        HWND hButton;
        if (NULL != (hButton = GetDlgItem(hwnd, IDC_BANDWIDTH_CLOSE)) ) {
            SetWindowLong(hButton,
                          GWL_STYLE, 
                          (GetWindowLong(hButton, GWL_STYLE) | WS_VISIBLE) & 
                          ~WS_DISABLED);
        }
//        RegisterForDeviceNotification(hwnd);
    } else {
        //
        // Move the refresh button to where the close button is
        //
        HWND hButtonClose, hButtonRefresh, hButtonDisable;
        RECT rectClose, rectParent;
        if (NULL != (hButtonClose = GetDlgItem(hwnd, IDC_BANDWIDTH_CLOSE)) &&
            GetWindowRect(hwnd, &rectParent)) {
            if (GetWindowRect(hButtonClose, &rectClose) &&
                NULL != (hButtonRefresh = GetDlgItem(hwnd, IDC_REFRESH)) ) {
                MoveWindow(hButtonRefresh,
                           rectClose.left - rectParent.left,
                           rectClose.top - rectParent.top,
                           rectClose.right  - rectClose.left,
                           rectClose.bottom - rectClose.top,
                           TRUE);
            }
        }

#ifdef WINNT
        //
        // Set the disable error detection button appropriately.
        //
        if (IsErrorCheckingEnabled()) {
            newDisableErrorChecking = oldDisableErrorChecking = FALSE;
        } else {
            newDisableErrorChecking = oldDisableErrorChecking = TRUE;
        }
        CheckDlgButton(hwnd, IDC_DISABLE_ERROR_DETECTION, oldDisableErrorChecking);
#endif // WINNT
        
//        RegisterForDeviceNotification(hwnd);
    }

    hLstDevices = GetDlgItem(hwnd, IDC_LIST_DEVICES);
    SetTextItem(hwnd, IDC_BAND_TEXT, IDS_BANDWIDTH_PAGEHELP);
    // UI change
//    SetTextItem(hwnd, IDC_BAND_TEXT2, IDS_BANDWIDTH_PAGEHELP2);

    fuelBar.SubclassDlgItem(IDC_BANDWIDTH_BAR, hwnd);

    ListView_SetImageList(hLstDevices, imageList.ImageList(), LVSIL_SMALL);
    fuelBar.SetImageList(imageList.ImageList());

    ZeroMemory(&column, sizeof(LV_COLUMN));
    
    column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    column.fmt = LVCFMT_LEFT;
    LoadString(gHInst, IDS_DEVICE_DESCRIPTION, buf, MAX_PATH);
    column.pszText = buf;
    GetClientRect(hLstDevices, &rect);

    column.cx = (int) (.65*(rect.right - rect.left));
    ListView_InsertColumn(hLstDevices, 0, &column);
        
    ZeroMemory(&column, sizeof(LV_COLUMN));
    
    column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    column.fmt = LVCFMT_LEFT;
    LoadString(gHInst, IDS_BANDWIDTH_CONSUMED, buf, MAX_PATH);
    column.pszText = buf;
    GetClientRect(hLstDevices, &rect);
    column.cx = (int) (.35*(rect.right - rect.left));
    
    ListView_InsertColumn(hLstDevices, 1, &column);

    Refresh();

    return TRUE;
}

BOOL BandwidthPage::OnCommand(INT wNotifyCode,
                              INT wID,
                              HWND hCtl)
{
    if (wNotifyCode == BN_CLICKED) {
        switch (wID) {
        case IDC_REFRESH:
            Refresh();
            return 0;
#ifdef WINNT
        case IDC_DISABLE_ERROR_DETECTION:
            newDisableErrorChecking = !newDisableErrorChecking;
            if (newDisableErrorChecking != oldDisableErrorChecking) {
                PropSheet_Changed(hwnd, hCtl);
            }
            return 0;
#endif // WINNT
        case IDC_BANDWIDTH_CLOSE:
//            UnregisterDeviceNotification(hDevNotify);
//            UnregisterDeviceNotification(hHubNotify);
            EndDialog(hwnd, wID);
        }
    }

    return 1;
}

BOOL BandwidthPage::OnNotify(HWND hDlg, int nID, LPNMHDR pnmh)
{
    switch (pnmh->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Do what ever action is necessary
        //
        UsbSetWindowLongPtr(hwnd, USBDWLP_MSGRESULT, PSNRET_NOERROR);
        SetErrorCheckingEnable(!newDisableErrorChecking);
            
        return 0;
    default:
        switch (nID) {
        case IDC_LIST_DEVICES:
            OnNotifyListDevices(hDlg, pnmh);
            return 0;
        }
        break;
    }

    return TRUE;
}

void 
BandwidthPage::OnNotifyListDevices(HWND hDlg, LPNMHDR pnmh)
{
    if (pnmh->code == LVN_ITEMCHANGED) {
        LPNMLISTVIEW pnlv = (LPNMLISTVIEW) pnmh;
    
        // the check for lParam being non NULL is not really necessary b/c we
        // set it for each device we insert into the list...

        // 
        // Check if the item has been selected.  if not, then there is 2 possible
        // states.  Either another item is selected (and LV_GetSelectedCount != 0) 
        // or there is no selection (LV_GetSelectedCount == 0) and we need to clear
        // any selection in the fuelbar
        //
        if ((pnlv->uNewState & LVIS_SELECTED) && pnlv->lParam) {
            if (!fuelBar.HighlightItem((PVOID) pnlv->lParam)) {
                //
                // Must be one of the low consuumption devices
                //
                fuelBar.HighlightItem(0);
            }                           
        }
        else if (ListView_GetSelectedCount(hLstDevices) == 0) {
            fuelBar.HighlightItem(FuelBar::NoID);
        }
    } else if (pnmh->code == NM_DBLCLK) {
        //
        // Display properties on this specific device on double click
        //
        if (fuelBar.GetHighlightedItem() != rootItem) {
            DisplayPPSelectedListItem(hwnd, hLstDevices);
        }
    }
}

HPROPSHEETPAGE BandwidthPage::Create()
{
    //
    // Make sure that this is indeed a controller
    //
    if (deviceName.empty()) {
        if (!GetDeviceName()) {
            return NULL;
        }
    }
    return UsbPropertyPage::Create();
}

BOOL
BandwidthPage::IsErrorCheckingEnabled()
{
    DWORD ErrorCheckingEnabled, type = REG_DWORD, size = sizeof(DWORD);
    HKEY hKey;
    if (ERROR_SUCCESS != 
        RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szUsbRegPath,
                        0,
                        KEY_READ,
                        &hKey)) {
        return TRUE;
    }
    if (ERROR_SUCCESS !=
        RegQueryValueEx(hKey,
                        g_szUsbRegValue,
                        0,
                        &type,
                        (LPBYTE) &ErrorCheckingEnabled,
                        &size)) {
        return TRUE;
    }
    return (BOOL) ErrorCheckingEnabled;
}

UINT 
BandwidthPage::SetErrorCheckingEnable(BOOL ErrorCheckingEnabled)
{
    DWORD disposition, size = sizeof(DWORD), type = REG_DWORD, error;
    HKEY hKey;
    if (ERROR_SUCCESS != (error =
        RegCreateKeyEx(HKEY_LOCAL_MACHINE,    
                          g_szUsbRegPath,
                          0,
                          TEXT("REG_SZ"),
                          REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKey,
                          &disposition))) {
        return error;
    }
    error = RegSetValueEx(hKey,
                          g_szUsbRegValue,
                          0,
                          type,
                          (LPBYTE) &ErrorCheckingEnabled,
                          size);
    EnableSystray(ErrorCheckingEnabled);
    return error;
}

//
// Enable or disable USB error checking
//
void
BandwidthPage::EnableSystray(BOOL fEnable)
{
    HWND hExistWnd = FindWindow(g_szWindowClassName, NULL);

    if (hExistWnd)
    {
        //
        // NOTE: Send an enable message even if the command line parameter
        //       is 0 to force us to re-check for all enabled services.
        //
        PostMessage(hExistWnd, STWM_ENABLESERVICE, STSERVICE_USBUI, fEnable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\bndwidth.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       BNDWIDTH.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "UsbPopup.h"
#include "PropPage.h"
#include "itemfind.h"
#include "debug.h"
#include "usbutil.h"

void
UsbBandwidthPopup::AddIsoDevicesToListView(UsbItem *controller,
                                           int iIndent) {
    UINT interruptBW;
    LVITEM item;
    TCHAR buf[MAX_PATH];
    UsbItem *usbItem;

    ZeroMemory(&item, sizeof(LVITEM));
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_INDENT;
    item.iIndent = iIndent;

    UsbItemActionFindIsoDevices find;
    controller->child->Walk(find);

    //
    // Put the devices in that use very little bandwidth first so that they
    // will be shuffled to the bottom when the high consumption devices are
    // added.
    //
    UsbItemList& isoDevices = find.GetIsoDevices();
    for (usbItem = isoDevices.begin() ? *isoDevices.Current() : NULL;
         usbItem;
         usbItem = isoDevices.next() ? *isoDevices.Current() : NULL) {

        item.iImage = usbItem->imageIndex;
        item.lParam = (LPARAM) usbItem;
        assert(usbItem->configInfo != NULL);
        item.pszText = (LPTSTR) usbItem->configInfo->deviceDesc.c_str();

        UsbSprintf(buf, TEXT("%d%%"), usbItem->bandwidth);

        ListView_InsertItem(hListDevices, &item);
        ListView_SetItemText(hListDevices, 0, 1, buf);
    }

    //
    // Add an item indicating that the system always uses 10%
    //
    item.iItem = 0;
    ImageList.GetClassImageIndex(MyComputerClass, &item.iImage);
    item.lParam = (LPARAM) controller;
    LoadString(gHInst,
               IDS_BANDWIDTH_CONTROLLER_RSRVD,
               buf,
               MAX_PATH);
    item.pszText = buf;
    ListView_InsertItem(hListDevices, &item);

    interruptBW = 10 + UsbItem::CalculateBWPercent(find.InterruptBW());
    wsprintf(buf,_T("%d%%"),interruptBW);
    ListView_SetItemText(hListDevices, 0, 1, buf);
}

BOOL
UsbBandwidthPopup::Refresh()
{
    PUSB_ACQUIRE_INFO acquireInfo = 0;
    UsbItem *controller;
    LVITEM item;
    TCHAR buf[MAX_PATH];
    TCHAR formatString[MAX_PATH];

    // CWaitCursor wait;

    //
    // Clear all UI components, and then recreate the rootItem
    //
    ListView_DeleteAllItems(hListDevices);
    if (rootItem) {
        DeleteChunk(rootItem);
        delete rootItem;
    }
    rootItem = new UsbItem;
    AddChunk(rootItem);

    acquireInfo = GetControllerName(WmiHandle,
                                    InstanceName.c_str());
    if (!acquireInfo) {
        goto BandwidthRefreshError;
    }
    if (!rootItem->EnumerateAll(&ImageList)) {
        goto BandwidthRefreshError;
    }
    acquireInfo = (PUSB_ACQUIRE_INFO) LocalFree(acquireInfo);

    //
    // Set the notification using the name of the offending device
    //
    LoadString(gHInst,
               IDS_BANDWIDTH_NOTIFICATION,
               formatString,
               MAX_PATH);
    UsbSprintf(buf,
               formatString,
               deviceItem.configInfo->deviceDesc.c_str(),
               UsbItem::CalculateBWPercent(ConnectionNotification->RequestedBandwidth));
    if (!SetTextItem(hWnd, IDC_BANDWIDTH_NOTIFICATION, buf)) {
        goto BandwidthRefreshError;
    }

    ZeroMemory(&item, sizeof(LVITEM));
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;

    if (rootItem->NumChildren() == 1) {
        //
        // Computer only has one controller installed
        //
        if (!SetTextItem(hWnd, IDC_BANDWIDTH_EXPLANATION, IDS_BW_EXPLANATION) ||
            !SetTextItem(hWnd, IDC_BANDWIDTH_RECOMMENDATION, IDS_BW_RECOMMENDATION)) {
            goto BandwidthRefreshError;
        }

        AddIsoDevicesToListView(rootItem->child, 0);
    } else if (rootItem->NumChildren() > 1) {
        //
        // Computer has multiple controllers on board. Yeehaw!
        //
        LoadString(gHInst,
                   IDS_BANDWIDTH_RECOMMENDATION,
                   formatString,
                   MAX_PATH);
        UsbSprintf(buf,
                   formatString,
                   deviceItem.configInfo->deviceDesc.c_str());
        if (!SetTextItem(hWnd, IDC_BANDWIDTH_RECOMMENDATION, buf) ||
            !SetTextItem(hWnd, IDC_BANDWIDTH_EXPLANATION, IDS_BW_EXPLANATION)) {
            goto BandwidthRefreshError;
        }

        //
        // Change the column text from "Device" to "Controller"
        //
        LV_COLUMN column;
        ZeroMemory(&column, sizeof(LV_COLUMN));
        column.mask = LVCF_TEXT;
        LoadString(gHInst, IDS_CONTROLLER, buf, MAX_PATH);
        column.pszText = buf;
        ListView_SetColumn(hListDevices, 0, &column);

        //
        // Iterate through the controllers and find out how much bandwidth is
        // being used on each.  Display this in a list view control.
        //
        for (controller = rootItem->child;
             controller != NULL;
             controller = controller->sibling) {

            AddIsoDevicesToListView(controller, 1);

            item.iItem = 0;
            item.iImage = controller->imageIndex;
            item.lParam = (LPARAM) controller;
            item.pszText = (LPTSTR) controller->configInfo->deviceDesc.c_str();
            ListView_InsertItem(hListDevices, &item);
        }
    }
    return TRUE;
BandwidthRefreshError:
    if (acquireInfo) {
        LocalFree(acquireInfo);
    }
    return FALSE;
}

BOOL
UsbBandwidthPopup::OnInitDialog(HWND HWnd)
{
    hWnd = HWnd;
    LV_COLUMN column;
    RECT rect;
    HANDLE hExclamation;
    HICON hIcon;
    TCHAR buf[MAX_PATH];

    //
    // Set the Icon to an exclamation mark
    //
    if (NULL == (hIcon = LoadIcon(NULL, (LPTSTR) IDI_EXCLAMATION)) ||
        NULL == (hExclamation = GetDlgItem(hWnd, IDC_ICON_BANDWIDTH))) {
        return FALSE;
    }
    SendMessage((HWND) hExclamation, STM_SETICON, (WPARAM) hIcon, NULL);

    hListDevices = GetDlgItem(HWnd, IDC_LIST_CONTROLLERS);

    ListView_SetImageList(hListDevices, ImageList.ImageList(), LVSIL_SMALL);

    //
    // Add columns to the list box
    //
    ZeroMemory(&column, sizeof(LV_COLUMN));
    column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    column.fmt = LVCFMT_LEFT;
    LoadString(gHInst, IDS_DEVICE, buf, MAX_PATH);
    column.pszText = buf;
    GetClientRect(hListDevices, &rect);
    column.cx = (int) (.65*(rect.right - rect.left));
    ListView_InsertColumn(hListDevices, 0, &column);

    ZeroMemory(&column, sizeof(LV_COLUMN));
    column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    column.fmt = LVCFMT_LEFT;
    LoadString(gHInst, IDS_BANDWIDTH_CONSUMED, buf, MAX_PATH);
    column.pszText = buf;
    GetClientRect(hListDevices, &rect);
    column.cx = (int) (.35*(rect.right - rect.left));
    ListView_InsertColumn(hListDevices, 1, &column);

    return Refresh();
}

BOOL
UsbBandwidthPopup::OnCommand(INT wNotifyCode,
                             INT wID,
                             HWND hCtl)
{
    switch (wID) {
    case IDOK:
        EndDialog(hWnd, wID);
        return TRUE;
    case IDC_BW_REFRESH:
        Refresh();
        return TRUE;
    }

    return FALSE;
}

BOOL
UsbBandwidthPopup::IsPopupStillValid() {
    USB_BUS_NOTIFICATION busNotification;

    USBINFO((_T("Names %s, %s!\n"),
             deviceItem.configInfo->deviceDesc.c_str(),
             LastDeviceName.c_str()));

    if (!GetBusNotification(WmiHandle, &busNotification)) {
        USBERROR((_T("Failed to get bus notification!\n")));
        return FALSE;
    }

    //
    // Is this the same scenario?
    //
    if (deviceItem.configInfo->deviceDesc == LastDeviceName &&
        busNotification.ConsumedBandwidth == LastBandwidthConsumed &&
        ConnectionNotification->RequestedBandwidth == LastBandwidthRequested) {
        USBWARN((_T("Same scenario!!!")));
        return FALSE;
    }

    //
    // Change the scenario.
    //
    LastDeviceName = deviceItem.configInfo->deviceDesc;
    LastBandwidthConsumed = busNotification.ConsumedBandwidth;
    LastBandwidthRequested = ConnectionNotification->RequestedBandwidth;

    //
    // Is this notification still relevant?
    //
    USBINFO((_T("Bandwidth consumed %x, requested %x, total %x!\n"),
             busNotification.ConsumedBandwidth,
             ConnectionNotification->RequestedBandwidth,
             busNotification.TotalBandwidth));
    if (busNotification.ConsumedBandwidth +
        ConnectionNotification->RequestedBandwidth <
        busNotification.TotalBandwidth) {
        USBWARN((_T("Got BW notification when there was no need!\n")));
        return FALSE;
    }

    return TRUE;
}

UsbString UsbBandwidthPopup::LastDeviceName = _T("");
ULONG UsbBandwidthPopup::LastBandwidthRequested = 0;
ULONG UsbBandwidthPopup::LastBandwidthConsumed = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\debug.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       DEBUG.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _USBDEBUG_H
#define _USBDEBUG_H

void TRACE(LPCTSTR Format, ...);

void AddMemoryChunk(PVOID Mem, PTCHAR File, ULONG Line);
void RemoveMemoryChunk(PVOID Mem, PTCHAR File, ULONG Line);
void DumpOrphans();
HLOCAL
UsbAllocPrivate(const TCHAR *File, ULONG Line, ULONG Flags, DWORD dwBytes);

HLOCAL
UsbReAllocPrivate(const TCHAR *File, ULONG Line, HLOCAL hMem, DWORD dwBytes, ULONG Flags);

HLOCAL
UsbFreePrivate(HLOCAL hMem);

VOID
UsbCheckForLeaksPrivate(VOID);

#if DBG

#define LERROR 1
#define LWARN 2
#define LTRACE 3
#define LINFO 4

extern ULONG USBUI_Debug_Trace_Level;
#define USBUI_Print(l, _x_) if ((l) <= USBUI_Debug_Trace_Level) \
    {   TRACE (_T("USBUI: ")); \
        TRACE _x_; }
#define USBWARN(_x_) USBUI_Print(LWARN, _x_)
#define USBERROR(_x_) USBUI_Print(LERROR, _x_)
#define USBTRACE(_x_) USBUI_Print(LTRACE, _x_)
#define USBINFO(_x_) USBUI_Print(LINFO, _x_)

//
// New and Delete memory tracking
//
#define AddChunk(mem) AddMemoryChunk((PVOID) mem, TEXT(__FILE__), __LINE__)
#define DeleteChunk(mem) RemoveMemoryChunk((PVOID) mem, TEXT(__FILE__), __LINE__)
#define CheckMemory() DumpOrphans()

//
// LocalAlloc memory tracking
#define LocalAlloc(flags, dwBytes)   UsbAllocPrivate(TEXT(__FILE__), __LINE__, flags, (dwBytes))
#define LocalFree(hMem)              UsbFreePrivate((hMem))

#else // DBG

#define USBUI_Print(l, _x_)
#define USBWARN(_x_)
#define USBERROR(_x_)
#define USBTRACE(_x_)
#define USBINFO(_x_)

//
// New and delete memory tracking
#define AddChunk(mem)
#define DeleteChunk(mem)
#define CheckMemory()

#endif

#endif //  _USBDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\cpl.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       BNDWIDTH.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "resource.h"
#include "itemfind.h"
#include "debug.h"
#include "powrpage.h"
#include "bandpage.h"
#include "usbapp.h"
#include <cpl.h>
#include <dbt.h>

#define WINDOWSCALEFACTOR   15

UINT CALLBACK
UsbApplet::StaticDialogCallback(HWND            Hwnd,
                                UINT            Msg,
                                LPPROPSHEETPAGE Page)
{
/*    UsbApplet *that;

    switch (Msg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        that = (UsbPopup*) Page->lParam;
        DeleteChunk(that);
        delete that; 

        return 0;       // return value ignored

    default:
        break;
    }
  */
    return TRUE;
}

BOOL
UsbApplet::CustomDialog()
{
    InitCommonControls();
    if (NULL == (hSplitCursor = LoadCursor(gHInst, MAKEINTRESOURCE(IDC_SPLIT)))) {
        return FALSE; 
    }

    if (-1 == DialogBoxParam(gHInst,
                              MAKEINTRESOURCE(IDD_CPL_USB),
                              NULL,
                              StaticDialogProc,
                              (LPARAM) this)) {
        return FALSE;
    }
    return TRUE;
}

USBINT_PTR APIENTRY UsbApplet::StaticDialogProc(IN HWND   hDlg,
                                             IN UINT   uMessage,
                                             IN WPARAM wParam,
                                             IN LPARAM lParam)
{
    UsbApplet *that;

    that = (UsbApplet *) UsbGetWindowLongPtr(hDlg, USBDWLP_USER);

    if (!that && uMessage != WM_INITDIALOG) 
        return FALSE; //DefDlgProc(hDlg, uMessage, wParam, lParam);

    switch (uMessage) {

        HANDLE_MSG(hDlg, WM_SIZE,           that->OnSize);
        HANDLE_MSG(hDlg, WM_LBUTTONDOWN,    that->OnLButtonDown);
        HANDLE_MSG(hDlg, WM_LBUTTONUP,      that->OnLButtonUp);
        HANDLE_MSG(hDlg, WM_MOUSEMOVE,      that->OnMouseMove);
        HANDLE_MSG(hDlg, WM_CLOSE,          that->OnClose);
        HANDLE_MSG(hDlg, WM_NOTIFY,         that->OnNotify);

    case WM_DEVICECHANGE:
        return that->OnDeviceChange(hDlg, (UINT)wParam, (DWORD)wParam);
    
    case WM_COMMAND:
        return that->OnCommand(HIWORD(wParam),
                               LOWORD(wParam),
                               (HWND) lParam);     

    case USBWM_NOTIFYREFRESH:
        return that->Refresh();
    case WM_INITDIALOG:
        that = (UsbApplet *) lParam;
        UsbSetWindowLongPtr(hDlg, USBDWLP_USER, (USBLONG_PTR) that);
        that->hMainWnd = hDlg;

        return that->OnInitDialog(hDlg);

    default:
        break;
    }

    return that->ActualDialogProc(hDlg, uMessage, wParam, lParam);
}

LRESULT 
UsbApplet::OnDeviceChange(HWND hWnd, UINT wParam, DWORD lParam)
{
   if ((wParam == DBT_DEVICEARRIVAL) ||
       (wParam == DBT_DEVICEREMOVECOMPLETE)) {
        Refresh();
   }
   return TRUE;
}

BOOL 
UsbApplet::OnCommand(INT wNotifyCode,
                 INT wID,
                 HWND hCtl)
{
/*    switch (wID) {
    case IDOK:
        EndDialog(hWnd, wID);
        return TRUE;
    }*/
    return FALSE;
}

BOOL 
UsbApplet::OnInitDialog(HWND HWnd)
{
    hMainWnd = HWnd;
    RECT rc;
    HICON hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_USB));
    if (hIcon) {
        SendMessage(HWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        SendMessage(HWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
    }

    //
    // Get a persistent handle to the tree view control
    //
    if (NULL == (hTreeDevices = GetDlgItem(HWnd, IDC_TREE_USB)) ||
        NULL == (hEditControl = GetDlgItem(HWnd, IDC_EDIT1))) {
        return FALSE;
    }

    TreeView_SetImageList(hTreeDevices, ImageList.ImageList(), TVSIL_NORMAL);

    GetWindowRect(HWnd, &rc);
    barLocation = (rc.right - rc.left) / 3;
    ResizeWindows(HWnd, FALSE, 0);

    if (!Refresh()) {
        return FALSE;
    }

    //
    // Everything seems to be working fine; let's register for device change 
    // notification
    //
    return RegisterForDeviceNotification(HWnd);
}

BOOL 
UsbApplet::RegisterForDeviceNotification(HWND hWnd)
{
   DEV_BROADCAST_DEVICEINTERFACE dbc;

   memset(&dbc, 0, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
   dbc.dbcc_size         = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
   dbc.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
   dbc.dbcc_classguid    = GUID_CLASS_USBHUB;
   hDevNotify = RegisterDeviceNotification(hWnd,     
                                              &dbc,
                                              DEVICE_NOTIFY_WINDOW_HANDLE);
   if (!hDevNotify) {
      return FALSE;
   }
   return TRUE;
}

HTREEITEM
UsbApplet::InsertRoot(LPTV_INSERTSTRUCT item,
                      UsbItem *firstController)
{
    HTREEITEM hItem;
    
    ZeroMemory(item, sizeof(TV_INSERTSTRUCT));

    // Get the image index
    
    item->hParent = NULL;
    item->hInsertAfter = TVI_LAST;
    item->item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE; // TVIF_CHILDREN
    
//    item->itemex.state = TVIS_BOLD;
    item->itemex.state |= TVIS_EXPANDED;
    item->itemex.stateMask = (UINT)~(TVIS_STATEIMAGEMASK | TVIS_OVERLAYMASK);
    item->itemex.pszText = TEXT("My Computer");
    item->itemex.cchTextMax = _tcsclen(TEXT("My Computer"));
    item->itemex.iImage = 0;    
    item->itemex.iSelectedImage = 0;    
    if (firstController) {
        item->itemex.cChildren = 1;
    }
    //
    // We will be able to recognize this from usbitems because we assign it the
    // lParam value INVALID_HANDLE_VALUE instead of the address of a valid 
    // usbItem.  Cunning, no? Ok, not really...
    //
    item->itemex.lParam = (LPARAM) INVALID_HANDLE_VALUE;

    if (NULL == (hItem = (HTREEITEM) 
                 SendMessage(hTreeDevices, 
                                TVM_INSERTITEM, 
                                0, 
                                (LPARAM)(LPTV_INSERTSTRUCT)item))) {
        int i = GetLastError();
    }
    return hItem;
}

BOOL
UsbApplet::Refresh()
{
    TV_INSERTSTRUCT item;
    UsbItem deviceItem;
    HTREEITEM hTreeRoot = NULL;

    // CWaitCursor wait;
    
    //
    // Clear all UI components, and then recreate the rootItem
    //
    TreeView_DeleteAllItems(hTreeDevices);
    if (rootItem) {
        DeleteChunk(rootItem);
        delete rootItem;
    }
    rootItem = new UsbItem;
    AddChunk(rootItem);
    
    if (!rootItem->EnumerateAll(&ImageList)) {
        goto UsbAppletRefreshError;
    }

    hTreeRoot = InsertRoot(&item, rootItem->child);
    
    if (rootItem->child) {
        return UsbItem::InsertTreeItem (hTreeDevices,
                               rootItem->child,
                               hTreeRoot,
                               &item,
                               IsValid,
                               IsBold,
                               IsExpanded);
    }
    return TRUE;
UsbAppletRefreshError:
    return FALSE;
}

VOID
UsbApplet::OnSize (HWND hWnd,
                   UINT state,
                   int  cx,
                   int  cy)
{
    ResizeWindows(hWnd, FALSE, 0);
}

//*****************************************************************************
//
// ResizeWindows()
//
// Handles resizing the two child windows of the main window.  If
// bSizeBar is true, then the sizing is happening because the user is
// moving the bar.  If bSizeBar is false, the sizing is happening
// because of the WM_SIZE or something like that.
//
//*****************************************************************************

VOID
UsbApplet::ResizeWindows (HWND    hWnd,
                          BOOL    bSizeBar,
                          int     BarLocation)
{
    RECT    MainClientRect;
    RECT    MainWindowRect;
    RECT    TreeWindowRect;
//    RECT    StatusWindowRect;
    int     right;

    // Is the user moving the bar?
    //
    if (!bSizeBar)
    {
        BarLocation = barLocation;
    }

    GetClientRect(hWnd, &MainClientRect);

//    GetWindowRect(ghStatusWnd, &StatusWindowRect);

    // Make sure the bar is in a OK location
    //
    if (bSizeBar)
    {
        if (BarLocation <
            GetSystemMetrics(SM_CXSCREEN)/WINDOWSCALEFACTOR)
        {
            return;
        }

        if ((MainClientRect.right - BarLocation) <
            GetSystemMetrics(SM_CXSCREEN)/WINDOWSCALEFACTOR)
        {
            return;
        }
    }

    // Save the bar location
    //
    barLocation = BarLocation;

    // Move the tree window
    //
    MoveWindow(hTreeDevices,
               0,
               0,
               BarLocation,
               MainClientRect.bottom,// - StatusWindowRect.bottom + StatusWindowRect.top,
               TRUE);

    // Get the size of the window (in case move window failed
    //
    GetWindowRect(hTreeDevices, &TreeWindowRect);
    GetWindowRect(hWnd, &MainWindowRect);

    right = TreeWindowRect.right - MainWindowRect.left;
    
    // Move the edit window with respect to the tree window
    //
    MoveWindow(hEditControl,
               right,
               0,
               MainClientRect.right-(right),
               MainClientRect.bottom, // - StatusWindowRect.bottom + StatusWindowRect.top,
               TRUE);
	if (propPage) {
		propPage->SizeWindow(right,
							 0,
							 MainClientRect.right-(right),
							 MainClientRect.bottom);
	}

    // Move the Status window with respect to the tree window
    //
/*    MoveWindow(ghStatusWnd,
               0,
               MainClientRect.bottom - StatusWindowRect.bottom + StatusWindowRect.top,
               MainClientRect.right,
               StatusWindowRect.bottom - StatusWindowRect.top,
               TRUE);*/
}

VOID
UsbApplet::OnMouseMove (HWND hWnd,
                        int  x,
                        int  y,
                        UINT keyFlags)
{
    SetCursor(hSplitCursor);

    if (bButtonDown)
    {
        ResizeWindows(hMainWnd, TRUE, x);
    }
}

VOID
UsbApplet::OnLButtonDown (
    HWND hWnd,
    BOOL fDoubleClick,
    int  x,
    int  y,
    UINT keyFlags
)
{
    bButtonDown = TRUE;
    SetCapture(hMainWnd);
}

VOID
UsbApplet::OnLButtonUp (
    HWND hWnd,
    int  x,
    int  y,
    UINT keyFlags
)
{
    bButtonDown = FALSE;
    ReleaseCapture();
}

VOID
UsbApplet::OnClose (HWND hWnd)
{
//    DestroyTree();

    if (hDevNotify) {
       UnregisterDeviceNotification(hDevNotify);
       hDevNotify = NULL;
    }

    PostQuitMessage(0);

    EndDialog(hMainWnd, 0);
}

LRESULT
UsbApplet::OnNotify (
    HWND    hWnd,
    int     DlgItem,
    LPNMHDR lpNMHdr
)
{
    switch(lpNMHdr->code){
    case TVN_SELCHANGED: {
        UsbItem *usbItem;
//        HTREEITEM hTreeItem;

//        hTreeItem = ((NM_TREEVIEW *)lpNMHdr)->itemNew.hItem;
        usbItem = (UsbItem*) ((NM_TREEVIEW *)lpNMHdr)->itemNew.lParam;
        
        if (usbItem)
        {
            UpdateEditControl((UsbItem *) usbItem);
        }
        SetActiveWindow(hTreeDevices);
    }
    case LVN_KEYDOWN: {
        LPNMLVKEYDOWN pKey = (LPNMLVKEYDOWN) lpNMHdr;
        if (VK_F5 == pKey->wVKey) {
            return Refresh();
        }
    }                        
    case TVN_KEYDOWN: {
        LPNMTVKEYDOWN pKey = (LPNMTVKEYDOWN) lpNMHdr;
        if (VK_F5 == pKey->wVKey) {
            return Refresh();
        }
    }
/*    case NM_KEYDOWN: {
        LPNMKEY pKey = (LPNMKEY) lpNMHdr;
        if (VK_F5 == pKey->nVKey) {
            return Refresh();
        }
    }*/
/*    if (DlgItem == IDC_TREE_USB &&
        lpNMHdr->code == NM_RCLICK)
    {
        HMENU hMenu
        CreateMenu();

        return TRUE;
    }
  */

    }
    return 0;
}

VOID                      
UsbApplet::UpdateEditControl(UsbItem *usbItem)
{
    if (propPage) {
        if (propPage->DestroyChild()) {
            delete propPage;
            propPage = NULL;
        }
    }

    if (usbItem == INVALID_HANDLE_VALUE) {
        propPage = new RootPage(usbItem);
    } else if (usbItem->IsHub()) {
        propPage = new PowerPage(usbItem);
    } else if (usbItem->IsController()) {
        propPage = new BandwidthPage(usbItem);
    } else {
        propPage = new GenericPage(usbItem);
    }
    if (propPage) {
        propPage->CreateAsChild(hMainWnd, hEditControl, usbItem);
    }
}

BOOL 
UsbApplet::IsBold(UsbItem *Item)
{
    return FALSE;
}

BOOL
UsbApplet::IsValid(UsbItem *Item)
{
    return !Item->IsUnusedPort();
}

BOOL
UsbApplet::IsExpanded(UsbItem *Item) 
{
    if (Item->IsHub() || Item->IsController()) {
        return TRUE;
    }
    return FALSE;
}

extern "C" {

LONG APIENTRY 
CPlApplet(HWND hwndCPl,    
          UINT uMsg,    
          LPARAM lParam1,
          LPARAM lParam2)
{
    UsbApplet *applet;
    applet = (UsbApplet*) lParam2;

    switch (uMsg) {
    case CPL_EXIT:
        return 0;
    case CPL_INQUIRE:
    {
        CPLINFO *info = (CPLINFO *) lParam2;
        assert(lParam1 == 0);
        applet = new UsbApplet();
        info->idIcon = IDI_USB;
        info->idName = IDS_USB;
        info->idInfo = IDS_USB;
        info->lData = (USBLONG_PTR) applet;
        return 0;
    }
    case CPL_GETCOUNT:
        return 1;
    case CPL_INIT:
        return TRUE;
    case CPL_DBLCLK:
        assert(lParam1 == 0);
        if (applet->CustomDialog()) {
            return 0;
        }
        return 1;
    case CPL_STOP:
        assert(lParam1 == 0);
        applet->OnClose(hwndCPl);
        delete applet;
        return 0;
    }
    return 0;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\debug.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       DEBUG.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include <windows.h>
#include "debug.h"

#include "vec.h"

struct Info {
    PTCHAR      File;
    ULONG       Line;
    PVOID       Mem;
};

struct AllocInfo {
    PTCHAR      File;
    ULONG       Line;
    ULONG       Size;    
    HLOCAL      Mem;
};

typedef _Vec<AllocInfo> AllocInfoVector;
typedef _Vec<Info> InfoVector;
InfoVector chunks;
AllocInfoVector allocs;

void AddMemoryChunk(PVOID Mem, PTCHAR File, ULONG Line)
{
    Info info;

    info.File = File;
    info.Line = Line;
    info.Mem = Mem;

    chunks.push_back(info);
}

void RemoveMemoryChunk(PVOID Mem, PTCHAR File, ULONG Line)
{
    if (Mem) {
        Info *info;
        for (info = chunks.begin(); info; info = chunks.next()) {
            if (info->Mem == Mem) {
                chunks.eraseCurrent();
                return;
            }
        }
        TCHAR txt[1024];
        wsprintf(txt, TEXT("Invalid Delete: %s, Line %d, 0x%x\n"), File, Line, Mem);
        OutputDebugString(txt);
    }
}

void DumpOrphans()
{
    Info *info;
    TCHAR txt[1024];
    for (info = chunks.begin(); info; info = chunks.next()) {
        wsprintf(txt, TEXT("Leak at: %s, Line %d, 0x%x\n"),
                           info->File, info->Line, info->Mem);
        OutputDebugString(txt);
    }
    
    AllocInfo *aInfo;
    for (aInfo = allocs.begin(); aInfo; aInfo = allocs.next()) {
        wsprintf(txt, TEXT("Leak at: %s, Line %d, Size %d, Mem 0x%x\n"),
                           aInfo->File, aInfo->Line, aInfo->Size, aInfo->Mem);
        OutputDebugString(txt);
    }
}

#undef LocalAlloc
#undef LocalFree

HLOCAL
UsbAllocPrivate (
    const TCHAR *File,
    ULONG       Line,
    ULONG       Flags,
    DWORD       dwBytes
)
{
    DWORD bytes;
    AllocInfo info;
    HLOCAL hMem=NULL;

    if (dwBytes) {
        bytes = dwBytes;

        hMem = LocalAlloc(Flags, bytes);

        if (hMem != NULL) {
            info.File = (TCHAR*) File;
            info.Line = Line;
            info.Size = dwBytes;
            info.Mem = hMem;

            allocs.push_back(info);

            return hMem;
        }
    }

    return hMem;
}

HLOCAL
UsbFreePrivate (
    HLOCAL hMem
)
{
    if (hMem)
    {
        AllocInfo *info;
        for (info = allocs.begin(); info; info = allocs.next()) {
            if (info->Mem == hMem) {
                allocs.eraseCurrent();
                return LocalFree(hMem);
            }
        }
     
        TCHAR txt[1024];
        wsprintf(txt, TEXT("Invalid Memory Free:  Memory 0x%x\n"), hMem);
        OutputDebugString(txt);
    }
    return LocalFree(hMem);
}

#if DBG
ULONG USBUI_Debug_Trace_Level = LERROR;
#endif // DBG

void TRACE(LPCTSTR Format, ...) 
{
    va_list arglist;
    va_start(arglist, Format);

    TCHAR buf[200];

    wvsprintf(buf, Format, arglist);
    OutputDebugString(buf);

    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\genpage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       GENPAGE.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "bandpage.h"
#include "proppage.h"
#include "debug.h"
#include "resource.h"
#include "usbutil.h"

void
GenericPage::Refresh()
{
    TCHAR buf[MAX_PATH], formatString[MAX_PATH];
    UsbItem *device;

    if (preItem) {
        device = preItem;
    } else {
        //
        // Recreate the rootItem if necessary
        //
        if (rootItem) {
            DeleteChunk(rootItem);
            delete rootItem;
        }
        rootItem = new UsbItem;
        if (!rootItem) {
            return;
        }
        AddChunk(rootItem);
        
        device = rootItem;
        if (FALSE) {
//            !rootItem->EnumerateDevice(deviceInfoData->DevInst)) {
            return;
        }
    }                      

    if (device->ComputePower()) {
        LoadString(gHInst, IDS_POWER_REQUIRED, formatString, MAX_PATH);
        UsbSprintf(buf, formatString, device->power);
        SetTextItem(hwnd, IDC_GENERIC_POWER, buf);
    }

    if (device->ComputeBandwidth()) {
        LoadString(gHInst, IDS_CURRENT_BANDWIDTH, formatString, MAX_PATH);
        UsbSprintf(buf, formatString, device->bandwidth);
        SetTextItem(hwnd, IDC_GENERIC_BANDWIDTH, buf);
    }
}

VOID
GenericPage::Initialize()
{ dlgResource = IDD_GENERIC_DEVICE; }

BOOL GenericPage::OnInitDialog()
{
    if (preItem) {
        SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & ~WS_CAPTION);
    }
    Refresh();
    return TRUE;
}

void
RootPage::Refresh()
{
    ErrorCheckingEnabled = BandwidthPage::IsErrorCheckingEnabled();
    CheckDlgButton(hwnd, 
                   IDC_ERROR_DETECT_DISABLE,
                   ErrorCheckingEnabled ? BST_UNCHECKED : BST_CHECKED);
}

VOID
RootPage::Initialize()
{ 
    dlgResource = IDD_ROOT_PAGE; 
}

BOOL RootPage::OnInitDialog()
{
    if (preItem) {
        SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & ~WS_CAPTION);
    }
    Refresh();
    return TRUE;
}

BOOL
SetErrorChecking(DWORD ErrorCheckingEnabled)
{
    DWORD disposition, size = sizeof(DWORD), type = REG_DWORD;
    HKEY hKey;
    if (ERROR_SUCCESS != 
        RegCreateKeyEx(HKEY_LOCAL_MACHINE,    
                          TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Usb"),
                          0,
                          TEXT("REG_SZ"),
                          REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKey,
                          &disposition)) {
        return FALSE;
    }
    if (ERROR_SUCCESS !=
        RegSetValueEx(hKey,
                         TEXT("ErrorCheckingEnabled"),
                         0,
                         type,
                         (LPBYTE) &ErrorCheckingEnabled,
                         size)) {
        return FALSE;
    }
    return TRUE;
}

BOOL 
RootPage::OnCommand(INT wNotifyCode, 
                    INT wID, 
                    HWND hCtl) 
{
    if (wID == IDC_ERROR_DETECT_DISABLE &&
        wNotifyCode == BN_CLICKED) {
        ErrorCheckingEnabled = !ErrorCheckingEnabled;
        SetErrorChecking(ErrorCheckingEnabled);
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\enumfail.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       ENUMFAIL.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "usbpopup.h"
#include "itemfind.h"
#include "debug.h"
#include "usbutil.h"

//
// Refresh the contents of the treeview control.
// Find all hubs with unused ports on them.  If there are none, find some which
// have devices requiring less than 100 mA.
// 
BOOL UsbEnumFailPopup::Refresh()
{
    TV_INSERTSTRUCT item;
    int i=0; //, size;
    PUSB_ACQUIRE_INFO acquireInfoController = 0;
    BOOL result = FALSE;
    TCHAR buf[MAX_PATH];
    String hubName = HubAcquireInfo->Buffer;

    //
    // Set the window's title bar and the rest of the messages
    //
    LoadString(gHInst, IDS_ENUMERATION_FAILURE, buf, MAX_PATH);
    SetWindowText(hWnd, buf);

    if (!SetTextItem(hWnd, IDC_POWER_NOTIFICATION, IDS_ENUMFAIL_NOTIFICATION) ||
        !SetTextItem(hWnd, IDC_POWER_EXPLANATION, IDS_ENUMFAIL_COURSE) ||
        !SetTextItem(hWnd, IDC_POWER_RECOMMENDATION, IDS_ENUMFAIL_RECOMMENDATION)) { 
        goto OvercurrentRefreshError;
    }
    
    //
    // Clear all UI components, and then recreate the rootItem
    //
    UsbTreeView_DeleteAllItems(hTreeDevices);
    if (rootItem) {
        DeleteChunk(rootItem);
        delete rootItem;
    }
    rootItem = new UsbItem;
    AddChunk(rootItem);
    
    //
    // Get the controller name and enumerate the tree
    //
    acquireInfoController = GetControllerName(WmiHandle, 
                                              InstanceName);
    if (!acquireInfoController) {
        goto OvercurrentRefreshError;
    }
    
    if (!rootItem->EnumerateController(0,
                                      acquireInfoController->Buffer,
                                      &ImageList, 
                                      0)) {
        goto OvercurrentRefreshError;
    } 
    acquireInfoController = 
        (PUSB_ACQUIRE_INFO) LocalFree(acquireInfoController);
    
    if (rootItem->child) {
        if (!deviceItem.configInfo->devInst) {
            //
            // Device has been removed by either the hub or the user. Find the
            // hub that the device was attached to and highlight the port.
            //
            UsbItemActionFindOvercurrentHubPort f2(hubName, deviceItem.cxnAttributes.ConnectionIndex);
            rootItem->Walk(f2);
            if (f2.GetDevice()) {
                result=InsertTreeItem (hTreeDevices,
                                       rootItem->child,
                                       TreeView_GetRoot(hTreeDevices),
                                       &item,
                                       TrueAlways,
                                       UsbItemActionFindOvercurrentHubPort::IsValid,
                                       UsbItemActionFindOvercurrentHubPort::IsExpanded);
            }
        } else {
            //
            // The device hasn't been removed by either the hub or the user yet
            // Find the overcurrent device
            //
            UsbItemActionFindOvercurrentDevice f1(deviceItem.configInfo->devInst);
            rootItem->Walk(f1);
            if (f1.GetDevice()) {
                //
                // Device is still attached
                //
                result=InsertTreeItem (hTreeDevices,
                                       rootItem->child,
                                       TreeView_GetRoot(hTreeDevices),
                                       &item,
                                       TrueAlways,
                                       UsbItemActionFindOvercurrentDevice::IsValid,
                                       UsbItemActionFindOvercurrentDevice::IsExpanded);
            }
        }
    }
    return result;
OvercurrentRefreshError:
    if (acquireInfoController) {
        LocalFree(acquireInfoController);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\itemfind.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       ITEMFIND.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "ItemFind.h"
#include "debug.h"
#include "resource.h"
extern HINSTANCE gHInst;

BOOL
UsbItemActionFindIsoDevices::operator()(UsbItem *Item)
{
    AddInterruptBW(Item);
    if (Item->ComputeBandwidth()) {
        isoDevices.push_back(Item);
    }
    return TRUE;
}

UINT
UsbItemActionFindIsoDevices::InterruptBW()
{
    UINT bw = 0;
    for (int i = 0; i < USB_NUM_FRAMES; i++) {
        if (interruptBW[i] > bw) {
            bw = interruptBW[i];
        }
    }
    return bw;
}

void
UsbItemActionFindIsoDevices::AddInterruptBW(UsbItem *item)
{
    UCHAR Interval, x;
    PUSB_ENDPOINT_DESCRIPTOR endpoint = 0;
    UINT endpointBW;
    PUSB_PIPE_INFO pipeInfo;

    if (item->deviceInfo && item->deviceInfo->connectionInfo) {

        //
        // Iterate through the open pipes
        //
        for (UINT i = 0; i < item->deviceInfo->connectionInfo->NumberOfOpenPipes; i++) {
            pipeInfo = &item->deviceInfo->connectionInfo->PipeList[i];
            endpoint = &pipeInfo->EndpointDescriptor;
            
            //
            // Only interested in interrupt endpoints
            //
            if (USB_ENDPOINT_TYPE_INTERRUPT == 
                (endpoint->bmAttributes & USB_ENDPOINT_TYPE_MASK)) {
                //
                // Find the appropriate interval - Max interval = 32
                //
                Interval = endpoint->bInterval;
                for (x = 0x20; x > 0x1; x = x >> 1) {
                    if (Interval >= x) {
                        break;
                    }
                }
                Interval = x;

                //
                // Calculate the bandwidth per frame
                //
                endpointBW = UsbItem::EndpointBandwidth(
                    endpoint->wMaxPacketSize, 
                    (UCHAR)(endpoint->bmAttributes & USB_ENDPOINT_TYPE_MASK),
                    item->deviceInfo->connectionInfo->LowSpeed);

                //
                // Put the bandwidth in the appropriate frames
                //
                for (int j = pipeInfo->ScheduleOffset; j < USB_NUM_FRAMES; j += Interval) {
                    interruptBW[j] += endpointBW;
                }
            }
        } 
    }
}

BOOL 
UsbItemActionFindPower::operator()(UsbItem *Item)
{
    if (Item->ComputePower()) {
        powerDevices.push_back(Item);
    } else {
        otherDevices.push_back(Item);
    }
    Item->ComputeBandwidth();
    
    return TRUE;
}

BOOL 
UsbItemActionFindSelfPoweredHubsWithFreePorts::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindSelfPoweredHubsWithFreePorts::IsValid(UsbItem *Item)
{
    if (Item->PortPower() > 100 &&
        Item->NumPorts() > Item->NumChildren() &&
        Item->DistanceFromController() < DistanceFromControllerForDevice) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindSelfPoweredHubsWithFreePorts::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        if (IsValid(Item)) {
            return TRUE;
        }
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindSelfPoweredHubsWithFreePortsForHub::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindSelfPoweredHubsWithFreePortsForHub::IsValid(UsbItem *Item)
{
    if (Item->PortPower() > 100 &&
        Item->NumPorts() > Item->NumChildren() &&
        Item->DistanceFromController() < DistanceFromControllerForHub) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindSelfPoweredHubsWithFreePortsForHub::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        if (IsValid(Item)) {
            return TRUE;
        }
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindHubsWithFreePorts::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindHubsWithFreePorts::IsValid(UsbItem *Item)
{
    if (Item->NumPorts() > Item->NumChildren() &&
        Item->DistanceFromController() < DistanceFromControllerForHub) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindHubsWithFreePorts::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        if (IsValid(Item)) {
            return TRUE;
        }
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindFreePortsOnSelfPoweredHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindFreePortsOnSelfPoweredHubs::IsValid(UsbItem *Item)
{
    if (Item->configInfo &&
        Item->IsUnusedPort() &&
        Item->parent &&
        Item->parent->PortPower() > 100) {
            return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindFreePortsOnSelfPoweredHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    if (IsValid(Item)) {
        return TRUE;
    }
    return FALSE;
}

BOOL 
UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs::IsValid(UsbItem *Item) 
{
    if (Item->ComputePower()) {
        if (Item->power <= 100 &&
            !Item->IsHub() &&
            !(Item->cxnAttributes.PortAttributes & USB_PORTATTR_OEM_CONNECTOR) &&
            Item->parent &&
            Item->parent->IsHub() &&
            Item->parent->PortPower() > 100) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindDevicesOnHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindDevicesOnHubs::IsValid(UsbItem *Item) 
{
    if (!Item->IsHub() &&
        !(Item->cxnAttributes.PortAttributes & USB_PORTATTR_OEM_CONNECTOR) &&
        Item->parent &&
        Item->parent->IsHub() &&
        Item->parent->DistanceFromController() < DistanceFromControllerForHub) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindDevicesOnHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs::IsValid(UsbItem *Item) 
{
    if (Item->ComputePower()) {
        if (Item->power > 100 &&
            !(Item->cxnAttributes.PortAttributes & USB_PORTATTR_OEM_CONNECTOR) &&
            Item->parent &&
            Item->parent->PortPower() > 100) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs::IsValid(UsbItem *Item) 
{
    if (!Item->ComputePower()) {
        if (Item->parent &&
            Item->parent->PortPower() > 100) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

DEVINST UsbItemActionFindOvercurrentDevice::devInst = 0;

BOOL 
UsbItemActionFindOvercurrentDevice::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        device = Item;
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindOvercurrentDevice::IsValid(UsbItem *Item)
{
    if (Item->configInfo->devInst == devInst) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindOvercurrentDevice::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        if (IsValid(Item)) {
            return TRUE;
        }
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

String UsbItemActionFindOvercurrentHubPort::hubName = L"";
ULONG UsbItemActionFindOvercurrentHubPort::portIndex = 0;

BOOL 
UsbItemActionFindOvercurrentHubPort::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        device = Item;
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindOvercurrentHubPort::IsValid(UsbItem *Item)
{
    if (Item->parent) {
        if (Item->parent->deviceInfo ) {
            if (Item->parent->deviceInfo->hubName == hubName &&
                Item->cxnAttributes.ConnectionIndex == portIndex) {
                if (Item->configInfo &&
                    Item->IsUnusedPort())
                {
                    //
                    // Change the name to unknown device from unused port, 
                    // because there was probably something there originally.
                    //
                    TCHAR buf[MAX_PATH];
                    LoadString(gHInst, IDS_UNKNOWNDEVICE, buf, MAX_PATH);
                    Item->configInfo->deviceDesc = buf;
                }
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
UsbItemActionFindOvercurrentHubPort::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        if (IsValid(Item)) {
            return TRUE;
        }
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL 
UsbItemActionFindUsb2xHubsWithFreePorts::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindUsb2xHubsWithFreePorts::IsValid(UsbItem *Item)
{
    if (Item->NumPorts() > Item->NumChildren() &&       // This hub has room
        UsbItemActionFindUsb2xHubs::IsValid(Item)) {    // This is a 2.0 hub plugged into a 2.0 bus
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindUsb2xHubsWithFreePorts::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        if (IsValid(Item)) {
            return TRUE;
        }
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL 
UsbItemActionFindFreePortsOnUsb2xHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);
    }
    return TRUE;
} 

BOOL 
UsbItemActionFindFreePortsOnUsb2xHubs::IsValid(UsbItem *Item)
{
    if (Item->configInfo &&
        Item->IsUnusedPort() &&
        Item->parent &&
        UsbItemActionFindUsb2xHubs::IsValid(Item->parent)) {      
            return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindFreePortsOnUsb2xHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    if (IsValid(Item)) {
        return TRUE;
    }
    return FALSE;
}

BOOL 
UsbItemActionFindUsb1xDevicesOnUsb2xHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindUsb1xDevicesOnUsb2xHubs::IsValid(UsbItem *Item) 
{
    if (Item->UsbVersion() < 0x200 &&
        Item->parent &&
        UsbItemActionFindUsb2xHubs::IsValid(Item->parent)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindUsb1xDevicesOnUsb2xHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindUnknownDevicesOnUsb2xHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindUnknownDevicesOnUsb2xHubs::IsValid(UsbItem *Item) 
{
    if (!Item->UsbVersion()) {
        if (Item->parent &&
            UsbItemActionFindUsb2xHubs::IsValid(Item->parent)) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
UsbItemActionFindUnknownDevicesOnUsb2xHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}
                         
BOOL 
UsbItemActionFindUsb2xDevicesOnUsb2xHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindUsb2xDevicesOnUsb2xHubs::IsValid(UsbItem *Item) 
{
    if (Item->UsbVersion() >= 0x200 &&
        Item->parent &&
        UsbItemActionFindUsb2xHubs::IsValid(Item->parent)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindUsb2xDevicesOnUsb2xHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindUsb2xHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        hubs.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindUsb2xHubs::IsValid(UsbItem *Item) 
{
    if (Item->IsHub() &&                            // This is a hub
        Item->UsbVersion() >= 0x200 &&              // This is a 2.0 device
        (Item->parent->IsController() ||            // 2.0 Root hub
         (Item->parent->IsHub() && IsValid(Item->parent)))) { // Parent is valid
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItemActionFindUsb2xHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindDevicesOnSelfPoweredHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindDevicesOnSelfPoweredHubs::IsValid(UsbItem *Item) 
{
    if (!Item->IsHub() &&
        Item->parent &&
        Item->parent->IsHub() &&
        Item->parent->PortPower() > 100 &&
        Item->parent->DistanceFromController() < DistanceFromControllerForHub) {
        return TRUE;                                            
    }
    
    return FALSE;
}

BOOL
UsbItemActionFindDevicesOnSelfPoweredHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL 
UsbItemActionFindBusPoweredHubsOnSelfPoweredHubs::operator()(UsbItem *Item)
{
    if (IsValid(Item)) {
        devices.push_back(Item);        
    }
    return TRUE;
} 

BOOL
UsbItemActionFindBusPoweredHubsOnSelfPoweredHubs::IsValid(UsbItem *Item) 
{
   if (Item->ComputePower()) {
       if (Item->power <= 100 &&
           Item->IsHub() &&
           Item->parent &&
           Item->parent->IsHub() &&
           Item->parent->PortPower() > 100) {
           return TRUE;
       }
   }
   return FALSE;
}

BOOL
UsbItemActionFindBusPoweredHubsOnSelfPoweredHubs::IsExpanded(UsbItem *Item) 
{
    UsbItem *i;
    if (Item->IsHub() || Item->IsController()) {
        for (i = Item->child; i; i = i->sibling) {
            if (IsExpanded(i) ||
                IsValid(i)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\itemfind.h ===
//depot/Lab01_N/Shell/osshell/cpls/usb/itemfind.h#3 - edit change 8022 (text)
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       ITEMFIND.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _USBITEMACTIONFIND_H
#define _USBITEMACTIONFIND_H

#include "UsbItem.h"

#include "vec.h"

#define USB_NUM_FRAMES 32

typedef _Vec<UsbItem *> UsbItemList;

//
// Searching for devices
//
class UsbItemActionFindIsoDevices : public UsbItem::UsbItemAction {
public:
    UsbItemActionFindIsoDevices() {
        ZeroMemory(interruptBW, sizeof(UINT)*USB_NUM_FRAMES); }
    
    BOOL operator()(UsbItem *Item);

    UsbItemList& GetIsoDevices() {return isoDevices;}
    void AddInterruptBW(UsbItem *);
    UINT InterruptBW();

private:
    UINT interruptBW[USB_NUM_FRAMES];
    UsbItemList isoDevices;
};

class UsbItemActionFindPower : public UsbItem::UsbItemAction {
public:
    UsbItemActionFindPower(UsbItem *HubItem) : hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);

    UsbItemList& GetPowerDevices() {return powerDevices;}
    UsbItemList& GetOtherDevices() {return otherDevices;}

protected:
    UsbItemList powerDevices, otherDevices;
    UsbItem *hubItem;
};

//
// Searching for hubs
//
#define DistanceFromControllerForHub 6
#define DistanceFromControllerForDevice 7

class UsbItemActionFindHubsWithFreePorts : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindHubsWithFreePorts(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};
  
class UsbItemActionFindSelfPoweredHubsWithFreePorts : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindSelfPoweredHubsWithFreePorts(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};
  
class UsbItemActionFindSelfPoweredHubsWithFreePortsForHub : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindSelfPoweredHubsWithFreePortsForHub(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};
  
class UsbItemActionFindBusPoweredHubsOnSelfPoweredHubs :
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindBusPoweredHubsOnSelfPoweredHubs(UsbItem *Item) :
        item(Item) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetDevices() {return devices;}

protected:
    UsbItemList devices;
    UsbItem *item;
};

//
// Searching for ports
//
class UsbItemActionFindFreePortsOnSelfPoweredHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindFreePortsOnSelfPoweredHubs(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};
  
class UsbItemActionFindOvercurrentHubPort : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindOvercurrentHubPort(String &HubName, ULONG Port) : 
        device(NULL) {hubName = HubName; portIndex = Port;}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItem *GetDevice() {return device;}

protected:
    static String hubName;
    static ULONG portIndex;
    UsbItem *device;
};

//
// Searching for devices
//
class UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs(UsbItem *Item) : 
        item(Item) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetDevices() {return devices;}

protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindDevicesOnHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindDevicesOnHubs(UsbItem *Item) : 
        item(Item) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetDevices() {return devices;}

protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs(UsbItem *Item) : 
        item(Item) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetDevices() {return devices;}

protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs(UsbItem *Item) : 
        item(Item) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetDevices() {return devices;}

protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindOvercurrentDevice : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindOvercurrentDevice(DEVINST DevInst) : 
        device(NULL) {devInst = DevInst;}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItem *GetDevice() {return device;}

protected:
    static DEVINST devInst;
    UsbItem *device;
};

class UsbItemActionFindUsb2xDevicesOnUsb2xHubs :
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindUsb2xDevicesOnUsb2xHubs(UsbItem *Item) :
        item(Item) {}   
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);
    UsbItemList& GetDevices() {return devices;}
    
protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindUnknownDevicesOnUsb2xHubs :
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindUnknownDevicesOnUsb2xHubs(UsbItem *Item) :
        item(Item) {}   
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);
    UsbItemList& GetDevices() {return devices;}
    
protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindUsb1xDevicesOnUsb2xHubs :
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindUsb1xDevicesOnUsb2xHubs(UsbItem *Item) :
        item(Item) {}   
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);
    UsbItemList& GetDevices() {return devices;}
    
protected:
    UsbItemList devices;
    UsbItem *item;
};

class UsbItemActionFindFreePortsOnUsb2xHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindFreePortsOnUsb2xHubs(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};

class UsbItemActionFindUsb2xHubsWithFreePorts : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindUsb2xHubsWithFreePorts(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};

class UsbItemActionFindUsb2xHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindUsb2xHubs(UsbItem *HubItem) : 
        hubItem(HubItem) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetHubs() {return hubs;}

protected:
    UsbItemList hubs;
    UsbItem *hubItem;
};


class UsbItemActionFindDevicesOnSelfPoweredHubs : 
public UsbItem::UsbItemAction {
public:
    UsbItemActionFindDevicesOnSelfPoweredHubs(UsbItem *Item) : 
        item(Item) {}
    
    BOOL operator()(UsbItem *Item);
    static BOOL IsValid(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);

    UsbItemList& GetDevices() {return devices;}

protected:
    UsbItemList devices;
    UsbItem *item;
};

inline BOOL TrueAlways(UsbItem *item)
{
    return TRUE;
}



#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\entry.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       ENTRY.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "BandPage.h"
#include "PowrPage.h"
#include "UsbPopup.h"
#include "debug.h"
#include "usbapp.h"

HINSTANCE gHInst = 0;

extern "C" {

BOOL APIENTRY
DllMain(HANDLE hDll,
        DWORD dwReason,
        LPVOID lpReserved)
{

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        gHInst = (HINSTANCE) hDll;
        UsbPropertyPage::SetHandle(hDll);
        InitCommonControls();

        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    default:
        break;
    }

    return TRUE;
}

BOOL APIENTRY
UsbControlPanelApplet()
{
    UsbApplet *applet = new UsbApplet();
    if (applet) {
        return applet->CustomDialog();
    }
    return FALSE;
}

BOOL APIENTRY
USBControllerPropPageProvider(LPVOID               pinfo,
                              LPFNADDPROPSHEETPAGE pfnAdd,
                              LPARAM               lParam)
{
    PSP_PROPSHEETPAGE_REQUEST request;
    HPROPSHEETPAGE   hBandwidth; //, hPower;
    BandwidthPage    *bandwidth;
//    PowerPage        *power;

    request = (PSP_PROPSHEETPAGE_REQUEST) pinfo;

    if (request->PageRequested != SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
        return FALSE;

    bandwidth = new BandwidthPage(request->DeviceInfoSet,
                                  request->DeviceInfoData);
    if (!bandwidth) {
        USBERROR((_T("Out of memory!\n")));
        return FALSE;
    }
    AddChunk(bandwidth);
    hBandwidth = bandwidth->Create();
    if (!hBandwidth) {
        DeleteChunk(bandwidth);
        delete bandwidth;
        CheckMemory();
        return FALSE;
    }

    if (!pfnAdd(hBandwidth, lParam)) {
        DestroyPropertySheetPage(hBandwidth);
        DeleteChunk(bandwidth);
        delete bandwidth;
        CheckMemory();
        return FALSE;
    }
    return TRUE;
}

BOOL APIENTRY
USBDevicePropPageProvider(LPVOID               pinfo,
                          LPFNADDPROPSHEETPAGE pfnAdd,
                          LPARAM               lParam)
{
    PSP_PROPSHEETPAGE_REQUEST request;
    HPROPSHEETPAGE   hDevicePage; //, hPower;
    GenericPage     *generic;
//    PowerPage        *power;

    request = (PSP_PROPSHEETPAGE_REQUEST) pinfo;

    if (request->PageRequested != SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
        return FALSE;

    generic = new GenericPage(request->DeviceInfoSet,
                                request->DeviceInfoData);
    if (!generic) {
        USBERROR((_T("Out of memory!\n")));
        return FALSE;
    }
    AddChunk(generic);
    hDevicePage = generic->Create();
    if (!hDevicePage) {
        DeleteChunk(generic);
        delete generic;
        CheckMemory();
        return FALSE;
    }

    if (!pfnAdd(hDevicePage, lParam)) {
        DestroyPropertySheetPage(hDevicePage);
        DeleteChunk(generic);
        delete generic;
        CheckMemory();
        return FALSE;
    }
    return TRUE;
}

BOOL APIENTRY
USBHubPropPageProvider(LPVOID               pinfo,
                       LPFNADDPROPSHEETPAGE pfnAdd,
                       LPARAM               lParam)
{
    PSP_PROPSHEETPAGE_REQUEST request;
    HPROPSHEETPAGE   hPower;
    PowerPage        *power;

    request = (PSP_PROPSHEETPAGE_REQUEST) pinfo;

    if (request->PageRequested != SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
        return FALSE;

    power = new PowerPage(request->DeviceInfoSet,
                          request->DeviceInfoData);
    if (!power) {
        USBERROR((_T("Out of memory!\n")));
        return FALSE;
    }
    AddChunk(power);
    hPower = power->Create();
    if (!hPower) {
        DeleteChunk(power);
        delete power;
        CheckMemory();
        return FALSE;
    }

    if (!pfnAdd(hPower, lParam)) {
        DestroyPropertySheetPage(hPower);
        DeleteChunk(power);
        delete power;
        CheckMemory();
        return FALSE;
    }

    return TRUE;
}

BOOL
USBControllerBandwidthPage(HWND hWndParent,
                           LPCSTR DeviceName)
{
    BandwidthPage   *band;
    band = new BandwidthPage(hWndParent, DeviceName);
    if (!band) {
        USBERROR((_T("Out of memory!\n")));
        return FALSE;
    }
    AddChunk(band);
    band->CreateIndependent();
    delete band;
    return TRUE;
}

BOOL
USBHubPowerPage(HWND hWndParent,
                LPCSTR DeviceName)
{
    PowerPage   *power;
    power = new PowerPage(hWndParent, DeviceName);
    if (!power) {
        USBERROR((_T("Out of memory!\n")));
        return FALSE;
    }
    AddChunk(power);
    power->CreateIndependent();
    delete power;
    return TRUE;
}

void USBErrorHandler(PUSB_CONNECTION_NOTIFICATION    usbConnectionNotification,
                     LPTSTR                          strInstanceName)
{
    static LONG     bandwidthPopupExists = 0;
    static LONG     powerPopupExists = 0;
    static LONG     legacyPopupExists = 0;
    static LONG     overcurrentPopupExists = 0;
    static LPTSTR   currentInstanceName = NULL;
    static HANDLE   hMutex = NULL;

    if (!hMutex) {
        hMutex = CreateMutex(NULL, TRUE, NULL);
    } else {
        WaitForSingleObject(hMutex, INFINITE);
    }

    //
    // Call the appropriate handler
    //

    USBTRACE((_T("Error Notification - %d\n"), usbConnectionNotification->NotificationType));
    switch (usbConnectionNotification->NotificationType) {
    case InsufficentBandwidth:
        USBTRACE((_T("Insufficent Bandwidth\n")));
        if (InterlockedIncrement(&bandwidthPopupExists) == 1) {
            UsbBandwidthPopup popup;
            popup.Make(usbConnectionNotification, strInstanceName);
        }
        InterlockedDecrement(&bandwidthPopupExists);
        break;
    case InsufficentPower: {
        USBTRACE((_T("Insufficent Power\n")));
        UsbPowerPopup popup;
        popup.Make(usbConnectionNotification, strInstanceName);
        break; }
    case OverCurrent: {
        USBTRACE((_T("Over Current\n")));
        UsbOvercurrentPopup popup;
        popup.Make(usbConnectionNotification, strInstanceName);
        break; }
    case EnumerationFailure: {
        USBTRACE((_T("Enumeration Failure\n")));
        UsbEnumFailPopup popup;
        popup.Make(usbConnectionNotification, strInstanceName);
        break; }
    case ModernDeviceInLegacyHub: {
        USBTRACE((_T("ModernDeviceInLegacyHub\n")));
        UsbLegacyPopup popup;
        popup.Make(usbConnectionNotification, strInstanceName);
        break; }
    case HubNestedTooDeeply: {
        USBTRACE((_T("HubNestedTooDeeply\n")));
        UsbNestedHubPopup popup;
        popup.Make(usbConnectionNotification, strInstanceName);
        break; }
    case ResetOvercurrent:
    default:
        break;
    }

    CheckMemory();
    ReleaseMutex(hMutex);
}

} // extern "C"



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\fuelbar.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       FUELBAR.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _FUELBAR_H
#define _FUELBAR_H

#include <windows.h>
#include <commctrl.h>
#include "vec.h"

#ifndef WINNT

#define FUELPROC DLGPROC

#define FuelSetWindowLongPtr SetWindowLong
#define FuelGetWindowLongPtr GetWindowLong
#define FUELLONG_PTR LONG
#define FUELGWLP_USERDATA GWL_USERDATA
#define FUELGWLP_WNDPROC GWL_WNDPROC
#define FUELDWORD_PTR DWORD

#else

#define FUELPROC WNDPROC

#define FuelSetWindowLongPtr SetWindowLongPtr
#define FuelGetWindowLongPtr GetWindowLongPtr
#define FUELLONG_PTR LONG_PTR
#define FUELGWLP_USERDATA GWLP_USERDATA
#define FUELGWLP_WNDPROC GWLP_WNDPROC
#define FUELDWORD_PTR DWORD_PTR

#endif // WINNT


struct FuelBarItem {
    LPVOID id;
    UINT value;
    int imageIndex;
    RECT rect;
};

typedef _Vec<FuelBarItem> FuelBarItemList;

class FuelBar {

public:
    FuelBar();
    virtual ~FuelBar();

    BOOL SubclassDlgItem(UINT nID, HWND hParent);

    static const int NoImage;
    static const LPVOID NoID; 

    // return current total in the bar, ID may be any value but -1
    UINT AddItem(UINT Value, LPVOID ID = NoID, int ImageIndex = NoImage);
    BOOL RemoveItem(LPVOID ID);
    void ClearItems();
    BOOL HighlightItem(LPVOID ID);

    UINT GetMaxValue() const {return maxValue;}
    void SetMaxValue(UINT newMax) {maxValue  = newMax; Clear();}
    UINT GetCurrentTotalValue() const {return currentTotalValue;}

    void SetImageList(HIMAGELIST ImageList);
    LPVOID GetHighlightedItem();

protected:
    LPVOID highlightID;
    int colorIndex;
    UINT currentTotalValue, maxValue;
    BOOL calcRects;
    FuelBarItemList items;

//    CToolTipCtrl toolTip;
    WNDPROC prevWndProc;
    HWND hwnd;
    HIMAGELIST hImageList;
    int imageWidth, imageHeight;

    COLORREF colorFace, colorLight, colorDark, colorUnused; 

    void CalculateRects(const RECT& ClientRect);
    void Clear();
    void GetSysColors();
    BOOL OnToolTipNotify(UINT id, NMHDR * pNMHDR, LRESULT * pResult);
    
    void OnPaint();
    void OnSysColorChange();

    static BOOL APIENTRY StaticWndProc(IN HWND   hDlg,
                                       IN UINT   uMessage,
                                       IN WPARAM wParam,
                                       IN LPARAM lParam);
};

#endif // _FUELBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\fuelbar.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       FUELBAR.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "FuelBar.h"
#include "debug.h"
#include <assert.h>

const int FuelBar::NoImage = -1;
const LPVOID FuelBar::NoID = (const LPVOID) -1;

FuelBar::FuelBar() : currentTotalValue(0), highlightID(NoID), 
    maxValue(100), calcRects(FALSE), hImageList(0)
{
    GetSysColors(); 
}

FuelBar::~FuelBar()
{
    Clear();
}

BOOL FuelBar::SubclassDlgItem( UINT nID, HWND hParent)
{
    hwnd = GetDlgItem(hParent, nID);

    FuelSetWindowLongPtr(hwnd, FUELGWLP_USERDATA, (FUELLONG_PTR) this);
    prevWndProc = (WNDPROC) FuelSetWindowLongPtr(hwnd, 
                                              FUELGWLP_WNDPROC,
                                              (FUELDWORD_PTR) StaticWndProc); 

    return TRUE;
}

UINT FuelBar::AddItem(UINT Value, LPVOID ID, int ImageIndex)
{
    FuelBarItem item;

    if (!Value)
        return 0;

    if (currentTotalValue + Value > maxValue)
        return 0;

    currentTotalValue += Value;
    
    item.value = Value;
    item.id = ID;
    item.imageIndex = ImageIndex;
    items.push_back(item);

    calcRects = TRUE;

    return currentTotalValue;
}

BOOL FuelBar::RemoveItem(LPVOID ID)
{
    if (highlightID == ID) {
        highlightID = (LPVOID) NoID;
    }

    FuelBarItem *item;

    for (item = items.begin(); item; item = items.next()) {
        if (item->id == ID) {
            items.eraseCurrent();
 
            return TRUE;
        }
    }

    return FALSE;
}

void FuelBar::ClearItems()
{
    Clear();
    InvalidateRect(hwnd, NULL, TRUE);
}

BOOL FuelBar::HighlightItem(LPVOID ID)
{
    // do nothing if the id is the same
    if (ID == highlightID)
        return TRUE;

    FuelBarItem *item;

    highlightID = 0;
    //
    // Make sure that ID is indeed a member
    //
    for (item = items.begin(); item; item = items.next()) {
        if (item->id == ID) {
            highlightID = ID;
            break;
        }
    }

    // the total redrawing of the ctrl will erase the old and draw the new
    InvalidateRect(hwnd, NULL, FALSE);
    
    if (ID != highlightID) {
        return FALSE;
    }

    return TRUE;
}

void FuelBar::Clear()
{
    items.clear();
    currentTotalValue = 0;
    calcRects = TRUE;
}

void FuelBar::CalculateRects(const RECT& ClientRect)
{
    FuelBarItem *item, *prevItem;

    if (items.empty()) {
        calcRects = FALSE;
        return;
    }

    item = items.begin();
    item->rect = ClientRect;
    item->rect.right = ClientRect.left + 1 +
                       (item->value * (ClientRect.right - ClientRect.left))/maxValue;

    prevItem = item;
    for (item = items.next(); item; item = items.next()) {

        item->rect.top = prevItem->rect.top;
        item->rect.bottom = prevItem->rect.bottom;
        item->rect.left = prevItem->rect.right;
        // Fill rect does not render the outside edge
        item->rect.right = item->rect.left  + 1 +
                           (item->value * (ClientRect.right - ClientRect.left))/maxValue;
    
        prevItem = item;
    }

    // make sure that if the bar is full, that the last item is rendered to
    // the edge of the entire bar
    if (currentTotalValue == maxValue)
        item->rect.right = ClientRect.right;

    calcRects = FALSE;
}

void FuelBar::SetImageList(HIMAGELIST ImageList)
{
    IMAGEINFO imageInfo;
    
    hImageList = ImageList;

    ZeroMemory(&imageInfo, sizeof(IMAGEINFO));
    
    if (ImageList_GetImageInfo(hImageList, 0, &imageInfo)) {
        imageWidth = imageInfo.rcImage.right - imageInfo.rcImage.left;
        imageHeight = imageInfo.rcImage.bottom - imageInfo.rcImage.top;
    }
    else {
        assert(FALSE);
    }

}

void FuelBar::GetSysColors()
{
    colorFace = GetSysColor(COLOR_3DFACE);
    colorLight = GetSysColor(COLOR_3DHILIGHT);
    colorDark = GetSysColor(COLOR_3DSHADOW);
    colorUnused = GetSysColor(COLOR_WINDOW);
}

/////////////////////////////////////////////////////////////////////////////
// FuelBar message handlers

void FillSolidRect(HDC dc,
                   LPCRECT rect,
                   COLORREF color)
{
    SetBkColor(dc, color);
    ExtTextOut(dc, 0, 0, ETO_OPAQUE, rect, NULL, 0, NULL);
}

void FillSolidRect(HDC dc, int x, int y, int cx, int cy, COLORREF color)
{
    RECT rect;

    rect.left = x;
    rect.right = x + cx;
    rect.top = y;
    rect.bottom = y + cy;

    SetBkColor(dc, color);
    ExtTextOut(dc, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
}

void Draw3dRect(HDC dc, 
                int x, 
                int y, 
                int cx, 
                int cy,
                COLORREF clrTopLeft, 
                COLORREF clrBottomRight, 
                COLORREF clrFace)
{
    FillSolidRect(dc, x, y, cx - 1, 1, clrTopLeft);
    FillSolidRect(dc, x, y, 1, cy - 1, clrTopLeft);
    FillSolidRect(dc, x + cx, y, -1, cy, clrBottomRight);
    FillSolidRect(dc, x, y + cy, cx, -1, clrBottomRight);
    FillSolidRect(dc, x+1, y+1, cx-2, cy-2, clrFace) ;
}

void FuelBar::OnPaint() 
{
    HDC dc; 
    PAINTSTRUCT ps;
    RECT clientRect, *highlightRect, remainingRect;
    POINT pt;
    FuelBarItem *item, *prevItem;
    
    HBRUSH hBrush, hOldBrush;

    BOOL highlightFound = FALSE;

    dc = BeginPaint(hwnd, &ps);

    hBrush = CreateSolidBrush(colorFace);
    hOldBrush = (HBRUSH) SelectObject(dc, hBrush);

    GetClientRect(hwnd, &clientRect);

    FillSolidRect(dc, &clientRect, colorUnused);
    
    if (calcRects) {
        CalculateRects(clientRect);
//        FillSolidRect(dc, &clientRect, colorFace);
    }

    for (item = items.begin(); item; item = items.next()) {
        Draw3dRect(dc,
                   item->rect.left,
                   item->rect.top,
                   item->rect.right - item->rect.left,
                   item->rect.bottom - item->rect.top,
                   colorLight,
                   colorDark,
                   colorFace);

        if (item->imageIndex != NoImage && 
            (item->rect.right - item->rect.left) > imageWidth) {
            
            // render the image in the center of the rectangle
            pt.x = item->rect.left + 
                   (item->rect.right - item->rect.left)/2 - (imageWidth)/2;
            pt.y = (item->rect.bottom - item->rect.top)/2 - (imageHeight)/2;
            ImageList_Draw(hImageList, 
                           item->imageIndex, 
                           dc,
                           pt.x,
                           pt.y,
                           ILD_TRANSPARENT);
        }
         
        if (item->id == highlightID) {
            highlightRect = &item->rect;
            highlightFound = TRUE;
        }
        prevItem = item;
    }

    if (currentTotalValue < maxValue) {
        remainingRect = clientRect;
        if (!items.empty())
            remainingRect.left = prevItem->rect.right;

        FillSolidRect(dc, &remainingRect, colorUnused);
    }

    SelectObject(dc, hOldBrush);

    if (highlightFound) {

        // CPen pen(PS_SOLID, 1, RGB(0,0,0)), *oldPen;
        // oldPen = dc.SelectObject(&pen);
        HPEN hPen, hOldPen;
        
        hPen = CreatePen(PS_SOLID, 1, RGB(0,0,0));
        if (hPen) {
            hOldPen = (HPEN) SelectObject(dc, hPen);
            MoveToEx(dc, highlightRect->left, highlightRect->top, NULL);
            LineTo(dc, highlightRect->right-1, highlightRect->top);
            LineTo(dc, highlightRect->right-1, highlightRect->bottom-1);
            LineTo(dc, highlightRect->left, highlightRect->bottom-1);
            LineTo(dc, highlightRect->left, highlightRect->top);
            // dc.DrawFocusRect instead?

            SelectObject(dc, hOldPen);
            DeleteObject(hPen);
        }
    }

    EndPaint(hwnd, &ps);

    DeleteObject(hBrush);
    ValidateRect(hwnd, &clientRect);
}

BOOL FuelBar::OnToolTipNotify(UINT id, NMHDR * pNMHDR, LRESULT * pResult)
{    
    BOOL bHandledNotify = FALSE;
#ifdef TOOL
    CPoint cursorPos;
    CRect clientRect;
    VERIFY(::GetCursorPos(&cursorPos));
    
    ScreenToClient(&cursorPos);

    GetClientRect(clientRect);

    // Make certain that the cursor is in the client rect, because the
    // mainframe also wants these messages to provide tooltips for the
    // toolbar.
    if (clientRect.PtInRect(cursorPos)) {
        FuelItem* item;
        int i;

        for (i = 0; i < items.GetSize(); i++) {
            item = (FuelItem*) items[i];
        }
        bHandledNotify = TRUE;
    }
#endif 
    return bHandledNotify;
}

void FuelBar::OnSysColorChange() 
{
    GetSysColors();
}

BOOL APIENTRY FuelBar::StaticWndProc(IN HWND   hDlg,
                                     IN UINT   uMessage,
                                     IN WPARAM wParam,
                                     IN LPARAM lParam)
{
    FuelBar *that = (FuelBar*) FuelGetWindowLongPtr(hDlg, FUELGWLP_USERDATA);
    assert(that);

    switch (uMessage) {
    case WM_PAINT:
        that->OnPaint();
        break;
    }

    return (BOOL)CallWindowProc( (FUELPROC) that->prevWndProc,
                                     hDlg, 
                                     uMessage,
                                     wParam,
                                     lParam);
}

LPVOID FuelBar::GetHighlightedItem()
{
    return highlightID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\itemenum.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       ITEMENUM.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#define INITGUID
#include "UsbItem.h"
#include "debug.h"
#include "resource.h"

extern HINSTANCE gHInst;

#define NUM_HCS_TO_CHECK 10

UINT
UsbItem::TotalTreeBandwidth()
{
    UINT bw = 0;

    if (sibling) {
        bw += sibling->TotalTreeBandwidth();
    }
    if (child) {
        bw += child->TotalTreeBandwidth();
    }

    if (ComputeBandwidth()) {
        bw += bandwidth;
    }
    return bw;
}

DEVINST FindTopmostUSBDevInst(DEVINST DevInst)
{
    TCHAR buf[512];
    CONFIGRET cr = CR_SUCCESS;
    DEVINST devInst, lastUsbDevInst;
    DWORD len = 0;

    if (!DevInst)
        return 0;

    devInst = lastUsbDevInst = DevInst;
    cr = CM_Get_Parent(&devInst,
                       devInst,
                       0);

    while (cr == CR_SUCCESS) {
        len = sizeof(buf);
        cr = CM_Get_DevNode_Registry_Property(devInst,
                                              CM_DRP_CLASS,
                                              NULL,
                                              buf,
                                              &len,
                                              0);
        if (cr == CR_SUCCESS) {
            if (_tcscmp(_T("USB"), buf) == 0)
                lastUsbDevInst = devInst;
        }

        cr = CM_Get_Parent(&devInst,
                           devInst,
                           0);
    }

    return lastUsbDevInst;
}

//
// Find all USB Host controllers in the system and enumerate them
//
BOOL
UsbItem::EnumerateAll(UsbImageList* ClassImageList)
{
    String      HCName;
    WCHAR       number[5];
    BOOL        ControllerFound = FALSE;
    int         HCNum;
    HANDLE      hHCDev;
    UsbItem     *usbItem = NULL;
    UsbItem     *iter;

#if 0
    HDEVINFO                         deviceInfo;
    SP_INTERFACE_DEVICE_DATA         deviceInfoData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
#endif

    //
    // Iterate over some Host Controller names and try to open them.
    // If successful in opening, create a new UsbItem and add it to the chain
    //
    for (HCNum = 0; HCNum < NUM_HCS_TO_CHECK; HCNum++)
    {
        HCName = L"\\\\.\\HCD";
        _itow(HCNum, number, 10);
        HCName += number;

        hHCDev = GetHandleForDevice(HCName);

        // If the handle is valid, then we've successfully opened a Host
        // Controller.  Display some info about the Host Controller itself,
        // then enumerate the Root Hub attached to the Host Controller.
        //
        if (hHCDev != INVALID_HANDLE_VALUE)
        {
            ControllerFound = TRUE;
            CloseHandle(hHCDev);
            //
            // Create a new UsbItem for the found controller
            //
            usbItem = new UsbItem();
            if (!usbItem) {
                USBERROR((_T("Out of memory!\n")));
                return FALSE;
            }
            AddChunk(usbItem);
            //
            // Add this controller to the chain
            //
            if (!child) {
                child = usbItem;
            } else {
                for (iter = child; iter->sibling != NULL; iter = iter->sibling) { ; }
                iter->sibling = usbItem;
            }
            //
            // Enumerate the controller
            //
            usbItem->EnumerateController(this, HCName, ClassImageList, 0);
        }
    }

#if 0
    // Now iterate over host controllers using the new GUID based interface
    //
    deviceInfo = SetupDiGetClassDevs((LPGUID)&GUID_CLASS_USB_HOST_CONTROLLER,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_INTERFACE_DEVICE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     (LPGUID)&GUID_CLASS_USB_HOST_CONTROLLER,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetInterfaceDeviceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA) GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

        SetupDiGetInterfaceDeviceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);
        hHCDev = GetHandleForDevice(deviceDetailData->DevicePath);

        // If the handle is valid, then we've successfully opened a Host
        // Controller.  Display some info about the Host Controller itself,
        // then enumerate the Root Hub attached to the Host Controller.
        //
        if (hHCDev != INVALID_HANDLE_VALUE)
        {
           ControllerFound = TRUE;
           CloseHandle(hHCDev);
           //
           // Create a new UsbItem for the found controller
           //
           usbItem = new UsbItem();
           if (!usbItem) {
               USBERROR((_T("Out of memory!\n")));
               return FALSE;
           }
           AddChunk(usbItem);
           //
           // Add this controller to the chain
           //
           if (!child) {
               child = usbItem;
           } else {
               for (iter = child; iter->sibling != NULL; iter = iter->sibling) { ; }
               iter->sibling = usbItem;
           }
           //
           // Enumerate the controller
           //
           usbItem->EnumerateController(this, deviceDetailData->DevicePath, ClassImageList, 0);

        }

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);
#endif
    return ControllerFound;
}

BOOL
UsbItem::EnumerateController(UsbItem *Parent,
                             const String &RootName,
                             UsbImageList* ClassImageList,
                             DEVINST DevInst)
{
    CONFIGRET cr = CR_SUCCESS;
    HANDLE hController= INVALID_HANDLE_VALUE;
    String rootHubName, driverKeyName;
    UsbConfigInfo *hubConfigInfo = 0, *configInfo = 0;
    UsbDeviceInfo *hubDeviceInfo = 0;
    DWORD len = 0;
    TCHAR usbBuf[MAX_PATH];

    hController = GetHandleForDevice(RootName);
    //
    // If the handle is valid, then we've successfully opened a Host
    // Controller.  Display some info about the Host Controller itself,
    // then enumerate the Root Hub attached to the Host Controller.
    //
    if (hController == INVALID_HANDLE_VALUE) {
        goto EnumerateWholeError;
    }

    driverKeyName = GetHCDDriverKeyName(hController);
    if (driverKeyName.empty()) {
        // the devinst really wasn't the controller
        goto EnumerateWholeError;
    }

    configInfo = new UsbConfigInfo();
    if (!configInfo) {
        USBERROR((_T("Out of memory!\n")));
        goto EnumerateWholeError;
    }
    AddChunk(configInfo);

    if (DevInst) {
        configInfo->devInst = DevInst;
        len = sizeof(usbBuf);
        if (CM_Get_DevNode_Registry_Property(DevInst,
                                             CM_DRP_CLASS,
                                             NULL,
                                             usbBuf,
                                             &len,
                                             0) == CR_SUCCESS) {
            configInfo->deviceClass = usbBuf;
        }

        len = sizeof(usbBuf);
        if (CM_Get_DevNode_Registry_Property(DevInst,
                                             CM_DRP_DEVICEDESC,
                                             NULL,
                                             usbBuf,
                                             &len,
                                             0) == CR_SUCCESS) {
            configInfo->deviceDesc = usbBuf;
        }
        else {
            LoadString(gHInst, IDS_UNKNOWNCONTROLLER, usbBuf, MAX_PATH);
            configInfo->deviceDesc = usbBuf;
        }
    }
    else {
        GetConfigMgrInfo(driverKeyName, configInfo);
        if (configInfo->deviceDesc.empty()) {
            LoadString(gHInst, IDS_UNKNOWNCONTROLLER, usbBuf, MAX_PATH);
            configInfo->deviceDesc = usbBuf;
            configInfo->deviceClass = TEXT("USB");
        }
    }

    //
    // No leaf info for host controllers, so parent is 0
    //
    if (AddLeaf(0,
                0,
                UsbItem::UsbItemType::HCD,
                configInfo,
                ClassImageList)) {
        rootHubName = GetRootHubName(hController);

        if (!rootHubName.empty()) {
            EnumerateHub(rootHubName,
                         ClassImageList,
                         0,
                         this,
                         UsbItem::UsbItemType::RootHub);
        }
    }
    CloseHandle(hController);
    return TRUE;

EnumerateWholeError:
    if (hController != INVALID_HANDLE_VALUE) {
        CloseHandle(hController);
    }
    if (hubConfigInfo) {

    }
    return FALSE;
}

//
// This form of EnumerateHub should only ever be called if enumerating directly
// from this specific hub as the root. It should not be called from within
// another enumeration call.
//
BOOL
UsbItem::EnumerateHub(const String &HubName,
                      UsbImageList* ClassImageList,
                      DEVINST DevInst,
                      UsbItem *Parent,
                      UsbItem::UsbItemType itemType)
{
    CONFIGRET cr = CR_SUCCESS;
    HANDLE hHub= INVALID_HANDLE_VALUE;
    UsbConfigInfo *configInfo = 0;
    DWORD len = 0;
//    TCHAR buf[MAX_PATH];
    UsbDeviceInfo *info = 0;
    TCHAR usbBuf[MAX_PATH];
    UsbItem *item;

    //
    // If the handle is valid, then we've successfully opened a Hub.
    // Display some info about the Hub itself, then enumerate the Hub.
    //
    if (INVALID_HANDLE_VALUE == (hHub = GetHandleForDevice(HubName)))
    {
        USBERROR((_T("Invalid handle returned for hub\n")));
        goto EnumerateHubError;
    }

    configInfo = new UsbConfigInfo();
    if (!configInfo) {
        USBERROR((_T("Out of memory!\n")));
        goto EnumerateHubError;
    }
    AddChunk(configInfo);
    configInfo->deviceClass = TEXT("USB");
    if (itemType == UsbItem::UsbItemType::RootHub) {
        configInfo->deviceDesc = TEXT("USB Root Hub");
    } else {
        configInfo->deviceDesc = TEXT("USB Hub");
    }

    if (DevInst) {
        configInfo->devInst = DevInst;
        len = sizeof(usbBuf);
        if (CM_Get_DevNode_Registry_Property(DevInst,
                                             CM_DRP_CLASS,
                                             NULL,
                                             usbBuf,
                                             &len,
                                             0) == CR_SUCCESS) {
            configInfo->deviceClass = usbBuf;
        }

        len = sizeof(usbBuf);
        if (CM_Get_DevNode_Registry_Property(DevInst,
                                             CM_DRP_DEVICEDESC,
                                             NULL,
                                             usbBuf,
                                             &len,
                                             0) == CR_SUCCESS) {
            configInfo->deviceDesc = usbBuf;
        }
        else {
            LoadString(gHInst, IDS_UNKNOWNHUB, usbBuf, MAX_PATH);
            configInfo->deviceDesc = usbBuf;
        }
    }

    info = new UsbDeviceInfo();
    if (!info) {
        USBERROR((_T("Out of memory!\n")));
        goto EnumerateHubError;
    }
    AddChunk(info);

    info->hubName = HubName;

    //
    // No leaf info for this hub, so parent is 0
    //
    if (NULL == (item = AddLeaf(Parent,
                                info,
                                itemType,
                                configInfo, ClassImageList))) {
        goto EnumerateHubError;
    }
    if (item->GetHubInfo(hHub)) {
        item->EnumerateHubPorts(hHub,
                                info->hubInfo.u.HubInformation.HubDescriptor.bNumberOfPorts,
                                ClassImageList);
    }
    CloseHandle(hHub);
    return TRUE;

EnumerateHubError:
    if (hHub != INVALID_HANDLE_VALUE) {
        CloseHandle(hHub);
    }
    if (info) {
        DeleteChunk(info);
        delete info;
    }
    if (configInfo) {
        DeleteChunk(configInfo);
        delete configInfo;
    }
    return FALSE;
}

BOOL
UsbItem::GetPortAttributes(
    HANDLE HHubDevice,
    PUSB_NODE_CONNECTION_ATTRIBUTES connectionAttributes,
    ULONG index)
{
    ULONG                           nBytes;

    //
    // Now query USBHUB for the USB_NODE_CONNECTION_INFORMATION structure
    // for this port.  This will tell us if a device is attached to this
    // port, among other things.
    //
    nBytes = sizeof(USB_NODE_CONNECTION_ATTRIBUTES);
    ZeroMemory(connectionAttributes, nBytes);
    connectionAttributes->ConnectionIndex = index;

    if ( !DeviceIoControl(HHubDevice,
                          IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES,
                          connectionAttributes,
                          nBytes,
                          connectionAttributes,
                          nBytes,
                          &nBytes,
                          NULL)) {
        USBERROR((_T("Couldn't get connection attributes for hub port\n")));
        return FALSE;
    }
    return TRUE;
}

PUSB_NODE_CONNECTION_INFORMATION
UsbItem::GetConnectionInformation(HANDLE HHubDevice,
                                  ULONG  index)
{
    PUSB_NODE_CONNECTION_INFORMATION    connectionInfo = 0;
    USB_NODE_CONNECTION_INFORMATION     connectionInfoStruct;
    ULONG                               nBytes;

    nBytes = sizeof(USB_NODE_CONNECTION_INFORMATION);
    ZeroMemory(&connectionInfoStruct, nBytes);
    connectionInfoStruct.ConnectionIndex = index;

    if ( !DeviceIoControl(HHubDevice,
                          IOCTL_USB_GET_NODE_CONNECTION_INFORMATION,
                          &connectionInfoStruct,
                          nBytes,
                          &connectionInfoStruct,
                          nBytes,
                          &nBytes,
                          NULL)) {
        return NULL;
    }
    //
    // Allocate space to hold the connection info for this port.
    // Should probably size this dynamically at some point.
    //
    nBytes = sizeof(USB_NODE_CONNECTION_INFORMATION) +
        connectionInfoStruct.NumberOfOpenPipes*sizeof(USB_PIPE_INFO);
    connectionInfo = (PUSB_NODE_CONNECTION_INFORMATION) LocalAlloc(LPTR, nBytes);
    if (!connectionInfo) {
        USBERROR((_T("Out of memory!\n")));
        return NULL;
    }

    //
    // Now query USBHUB for the USB_NODE_CONNECTION_INFORMATION structure
    // for this port.  This will tell us if a device is attached to this
    // port, among other things.
    //
    connectionInfo->ConnectionIndex = index;

    if ( !DeviceIoControl(HHubDevice,
                          IOCTL_USB_GET_NODE_CONNECTION_INFORMATION,
                          connectionInfo,
                          nBytes,
                          connectionInfo,
                          nBytes,
                          &nBytes,
                          NULL)) {
        LocalFree(connectionInfo);
        USBERROR((_T("Couldn't get connection information for hub port\n")));
        return NULL;
    }
    return connectionInfo;
}
//*****************************************************************************
//
// EnumerateHubPorts()
//
// hTreeParent - Handle of the TreeView item under which the hub port should
// be added.
//
// hHubDevice - Handle of the hub device to enumerate.
//
// NumPorts - Number of ports on the hub.
//
//*****************************************************************************

void UsbItem::EnumerateHubPorts(HANDLE HHubDevice,
                                ULONG NPorts,
                                UsbImageList* ClassImageList)
{
    UsbItem*                            item = 0;
    UsbDeviceInfo*                      info= 0;
    UsbConfigInfo*                      cfgInfo= 0;

    PUSB_NODE_CONNECTION_INFORMATION    connectionInfo = 0;
    USB_NODE_CONNECTION_ATTRIBUTES      cxnAttributes;
    String                              extHubName, driverKeyName;
    DWORD                               numDevices = 0;
    ULONG                               index;
    UsbItem::UsbItemType                itemType;
    TCHAR                               buf[MAX_PATH];

    //
    // Loop over all ports of the hub. If a hub or device exists on the port,
    // add it to the tree. If it's a hub, recursively enumerate it. Add a leaf to
    // indicate the number of unused ports.
    // Port indices are 1 based, not 0 based.
    //
    for (index=1; index <= NPorts; index++) {
        if (!GetPortAttributes(HHubDevice, &cxnAttributes, index)) {
            USBWARN((_T("Couldn't get connection attribs for port %x!\n"),index));
            continue;
        }
        if (cxnAttributes.PortAttributes & USB_PORTATTR_NO_CONNECTOR) {
            USBWARN((_T("Detected port with no connector!\n")));
            continue;
        }

        if (NULL == (connectionInfo = GetConnectionInformation(HHubDevice, index))) {
            continue;
        }

        //
        // Allocate configuration information structure
        //
        cfgInfo = new UsbConfigInfo();
        if (!cfgInfo) {
            // leak.
            USBERROR((_T("Out of memory!\n")));
            break;
        }
        AddChunk(cfgInfo);

        //
        // If there is a device connected, get the Device Description
        //
        if (connectionInfo->ConnectionStatus != NoDeviceConnected) {

            numDevices++;

            //
            // Get config mgr info
            //
            driverKeyName = GetDriverKeyName(HHubDevice,index);

            if (!driverKeyName.empty()) {
                GetConfigMgrInfo(driverKeyName, cfgInfo);
            }

            if (connectionInfo->DeviceIsHub) {
                itemType = UsbItem::UsbItemType::Hub;
                if (cfgInfo->deviceDesc.empty()) {
                    LoadString(gHInst, IDS_UNKNOWNHUB, buf, MAX_PATH);
                    cfgInfo->deviceDesc = buf;
                }
                if (cfgInfo->deviceClass.empty()) {
                    cfgInfo->deviceClass = TEXT("USB");
                }
            } else {
                itemType = UsbItem::UsbItemType::Device;
                if (cfgInfo->deviceDesc.empty()) {
                    LoadString(gHInst, IDS_UNKNOWNDEVICE, buf, MAX_PATH);
                    cfgInfo->deviceDesc = buf;
                }
                if (cfgInfo->deviceClass.empty()) {
                    cfgInfo->deviceClass = TEXT("Unknown");
                }
            }

            //
            // Get device specific info
            //
            info = new UsbDeviceInfo();
            if (!info) {
                USBERROR((_T("Out of memory!\n")));
                break;
            }
            AddChunk(info);

            if (NULL != (info->configDescReq =
                         GetConfigDescriptor(HHubDevice, index))) {
                info->configDesc = (PUSB_CONFIGURATION_DESCRIPTOR)(info->configDescReq+1);
            }
            info->connectionInfo = connectionInfo;

            //
            // Add the item into the tree
            //
            if (NULL != (item = UsbItem::AddLeaf(this,
                                                 info,
                                                 itemType,
                                                 cfgInfo,
                                                 ClassImageList))) {
                item->cxnAttributes = cxnAttributes;
            }

            if (connectionInfo->DeviceIsHub) {
                //
                // The device connected to the port is an external hub; get
                // the techie name of the hub and recursively enumerate it.
                //
                extHubName = GetExternalHubName(HHubDevice, index);

                if (!extHubName.empty()) {
                    HANDLE hNewHub = INVALID_HANDLE_VALUE;
                    info->hubName = extHubName;

                    if (INVALID_HANDLE_VALUE != (hNewHub = GetHandleForDevice(extHubName))) {
                        //
                        // Recursively enumerate the ports of this hub.
                        //
                        if (item->GetHubInfo(hNewHub)) {
                            item->EnumerateHubPorts(hNewHub,
                                                    info->hubInfo.u.HubInformation.HubDescriptor.bNumberOfPorts,
                                                    ClassImageList);
                        }
                        CloseHandle(hNewHub);
                    }
                }
            }
        } else {

            LocalFree(connectionInfo);

            //
            // Empty port.
            //
            if (cxnAttributes.PortAttributes & USB_PORTATTR_OEM_CONNECTOR) {
                USBWARN((_T("Detected an OEM connector with nothing on it. Not reporting!\n"),index));
                DeleteChunk(cfgInfo);
                delete cfgInfo;
            } else {
                //
                // Add "Port n"
                //
                if (cxnAttributes.PortAttributes & USB_PORTATTR_MINI_CONNECTOR) {
                    LoadString(gHInst, IDS_UNUSEDMINIPORT, buf, MAX_PATH);
                } else {
                    LoadString(gHInst, IDS_UNUSEDPORT, buf, MAX_PATH);
                }
                cfgInfo->deviceDesc = buf;
                cfgInfo->deviceClass = TEXT("USB");

                if (NULL != (item = UsbItem::AddLeaf(this,
                                                    NULL,
                                                    UsbItem::UsbItemType::Empty,
                                                    cfgInfo,
                                                    ClassImageList
                                                    ))) {
                    item->UnusedPort = TRUE;
                    item->cxnAttributes = cxnAttributes;
                }
            }
        }
    }

    //
    // Add the number of ports to the name of the hub
    //
    TCHAR szPorts[30];
    LoadString(gHInst, IDS_PORTS, szPorts, 30);
    wsprintf(buf, szPorts, NumPorts());
    configInfo->deviceDesc += buf;
}

BOOL
UsbItem::GetHubInfo(HANDLE HHubDevice)
{
    ULONG nBytes = 0;

    //
    // Query USBHUB for the USB_NODE_INFORMATION structure for this hub.
    // This will tell us the number of downstream ports to enumerate, among
    // other things.
    //
    if(!DeviceIoControl(HHubDevice,
                        IOCTL_USB_GET_NODE_INFORMATION,
                        &deviceInfo->hubInfo,
                        sizeof(USB_NODE_INFORMATION),
                        &deviceInfo->hubInfo,
                        sizeof(USB_NODE_INFORMATION),
                        &nBytes,
                        NULL)) {
        return FALSE;
    }
#ifdef HUB_CAPS
    nBytes = 0;
    if(!DeviceIoControl(HHubDevice,
            IOCTL_USB_GET_HUB_CAPABILITIES,
            &hubCaps,
            sizeof(USB_HUB_CAPABILITIES),
            &hubCaps,
            sizeof(USB_HUB_CAPABILITIES),
            &nBytes,
            NULL)) {
        return FALSE;
    }
#endif

    return TRUE;
}

/*
BOOL
UsbItem::EnumerateDevice(DEVINST DevInst)
{
    HANDLE hDevice;
    if (INVALID_HANDLE_VALUE == (hDevice = GetHandleForDevice(DevInst)))
    {
        return FALSE;
    }
    return TRUE;
}
  */
String UsbItem::GetHCDDriverKeyName(HANDLE HController)
//*****************************************************************************
//
// Given a handle to a host controller,
// return the Driver entry in its registry key.
//
//*****************************************************************************
{
    BOOL                    success = FALSE;
    ULONG                   nBytes = 0;
    USB_HCD_DRIVERKEY_NAME  driverKeyName;
    PUSB_HCD_DRIVERKEY_NAME driverKeyNameW = 0;
    String                  name;

    driverKeyNameW = NULL;


    // Get the length of the name of the driver key of the HCD
    //
    success = DeviceIoControl(HController,
                              IOCTL_GET_HCD_DRIVERKEY_NAME,
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &nBytes,
                              NULL);

    if (!success) {
        USBWARN((_T("Failed to get driver key name for controller.\n")));
        goto GetHCDDriverKeyNameError;
    }

    // Allocate space to hold the driver key name
    //
    nBytes = driverKeyName.ActualLength;

    if (nBytes <= sizeof(driverKeyName))
    {
        USBERROR((_T("Driver key name is wrong length\n")));
        goto GetHCDDriverKeyNameError;
    }

    driverKeyNameW = (PUSB_HCD_DRIVERKEY_NAME) LocalAlloc(LPTR, nBytes);
    if (!driverKeyNameW)
    {
        USBERROR((_T("Out of memory\n")));
        goto GetHCDDriverKeyNameError;
    }

    driverKeyNameW->ActualLength = nBytes;

    // Get the name of the driver key of the device attached to
    // the specified port.
    //
    success = DeviceIoControl(HController,
                              IOCTL_GET_HCD_DRIVERKEY_NAME,
                              driverKeyNameW,
                              nBytes,
                              driverKeyNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success)
    {
        USBWARN((_T("Failed to get driver key name for controller\n")));
        goto GetHCDDriverKeyNameError;
    }

    // Convert the driver key name
    //
    name = driverKeyNameW->DriverKeyName;

    // All done, free the uncoverted driver key name and return the
    // converted driver key name
    //
    LocalFree(driverKeyNameW);

    return name;

GetHCDDriverKeyNameError:
    // There was an error, free anything that was allocated
    //
    if (driverKeyNameW)
    {
        LocalFree(driverKeyNameW);
    }

    return String();
}

String UsbItem::GetExternalHubName (HANDLE  Hub, ULONG   ConnectionIndex)
{
    BOOL                        success = FALSE;
    ULONG                       nBytes = 0;
    USB_NODE_CONNECTION_NAME    extHubName;
    PUSB_NODE_CONNECTION_NAME   extHubNameW = 0;
    String                      name;

    extHubNameW = NULL;

    // Get the length of the name of the external hub attached to the
    // specified port.
    //
    extHubName.ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(Hub,
                              IOCTL_USB_GET_NODE_CONNECTION_NAME,
                              &extHubName,
                              sizeof(extHubName),
                              &extHubName,
                              sizeof(extHubName),
                              &nBytes,
                              NULL);

    if (!success) {
        USBWARN((_T("Failed to retrieve external hub name\n")));
        goto GetExternalHubNameError;
    }

    // Allocate space to hold the external hub name
    //
    nBytes = extHubName.ActualLength;
    if (nBytes <= sizeof(extHubName)) {
        USBERROR((_T("Get node connection name returned invalid data size: %d\n"),
                       nBytes));
        goto GetExternalHubNameError;
    }


    extHubNameW = (PUSB_NODE_CONNECTION_NAME) LocalAlloc(LPTR, nBytes);
    if (!extHubNameW) {
        USBERROR((_T("External hub name alloc failed.")));
        goto GetExternalHubNameError;
    }

    extHubNameW->ActualLength = nBytes;

    //
    // Get the name of the external hub attached to the specified port
    //
    extHubNameW->ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(Hub,
                              IOCTL_USB_GET_NODE_CONNECTION_NAME,
                              extHubNameW,
                              nBytes,
                              extHubNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success) {
        USBERROR((_T("Failed to get external hub name\n")));
        goto GetExternalHubNameError;
    }

    // Convert the External Hub name
    name = extHubNameW->NodeName;
    LocalFree(extHubNameW);

    // All done, free the uncoverted external hub name and return the
    // converted external hub name
    //
    return name;


GetExternalHubNameError:
    // There was an error, free anything that was allocated
    //
    if (extHubNameW)
    {
        LocalFree(extHubNameW);
    }

    return String();
}

String GetDriverKeyName(HANDLE  Hub, ULONG ConnectionIndex)
{
    BOOL                                success = FALSE;
    ULONG                               nBytes = 0;
    USB_NODE_CONNECTION_DRIVERKEY_NAME  driverKeyName;
    PUSB_NODE_CONNECTION_DRIVERKEY_NAME driverKeyNameW = 0;
    String                              name;

    driverKeyNameW = NULL;

    // Get the length of the name of the driver key of the device attached to
    // the specified port.
    //
    driverKeyName.ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(Hub,
                              IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &nBytes,
                              NULL);

    if (!success) {
        USBWARN((_T("Couldn't retrieve driver key name\n")));
        goto GetDriverKeyNameError;
    }

    // Allocate space to hold the driver key name
    //
    nBytes = driverKeyName.ActualLength;
    if (nBytes <= sizeof(driverKeyName))
    {
        USBERROR((_T("Driver key name wrong length\n")));
        goto GetDriverKeyNameError;
    }

    driverKeyNameW = (PUSB_NODE_CONNECTION_DRIVERKEY_NAME) LocalAlloc(LPTR, nBytes);
    if (!driverKeyNameW) {
        USBERROR((_T("Driver key name alloc failed.")));
        goto GetDriverKeyNameError;
    }

    driverKeyNameW->ActualLength = nBytes;

    // Get the name of the driver key of the device attached to
    // the specified port.
    //
    driverKeyNameW->ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(Hub,
                              IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,
                              driverKeyNameW,
                              nBytes,
                              driverKeyNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success) {
        USBERROR((_T("Failed to get driver key name for port")));
        goto GetDriverKeyNameError;
    }

    // Convert the driver key name
    //
    name = driverKeyNameW->DriverKeyName;

    // All done, free the uncoverted driver key name and return the
    // converted driver key name
    //
    LocalFree(driverKeyNameW);

    return name;


GetDriverKeyNameError:
    // There was an error, free anything that was allocated
    //
    if (driverKeyNameW)
    {
        LocalFree(driverKeyNameW);
    }

    return String();
}

void GetConfigMgrInfo(const String &DriverName, UsbConfigInfo *ConfigInfo)
/*++

 Returns the Device Description of the DevNode with the matching DriverName.
 Returns NULL if the matching DevNode is not found.

 The caller should copy the returned string buffer instead of just saving
 the pointer value. Dynamically allocate the return buffer.

  --*/
{
    DEVINST     devInst;
    DEVINST     devInstNext;
    CONFIGRET   cr;
    BOOL        walkDone = FALSE;
    ULONG       len = 0;
    ULONG       status = 0, problemNumber = 0;
    HKEY        devKey;
    DWORD       failID = 0;
    TCHAR     buf[MAX_PATH];

    //
    // Get Root DevNode
    //
    cr = CM_Locate_DevNode(&devInst, NULL, 0);

    if (cr != CR_SUCCESS) {
        return;
    }

    //
    // Do a depth first search for the DevNode with a matching
    // DriverName value
    //
    while (!walkDone)
    {
        //
        // Get the DriverName value
        //
        len = sizeof(buf);
        cr = CM_Get_DevNode_Registry_Property(devInst,
                                              CM_DRP_DRIVER,
                                              NULL,
                                              buf,
                                              &len,
                                              0);

#ifndef WINNT
        WCHAR compareBuf[MAX_PATH];
        if (!MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 buf,
                                 -1,
                                 compareBuf,
                                 MAX_PATH)) {
            return;
        }
        if (cr == CR_SUCCESS && (DriverName == compareBuf)) {
#else
        //
        // If the DriverName value matches, return the DeviceDescription
        //
        if (cr == CR_SUCCESS && (DriverName == buf)) {
#endif
            //
            // Save the devnode
            //
            ConfigInfo->devInst = devInst;

            ConfigInfo->driverName = DriverName;

            //
            // Get the device description
            //
            TCHAR usbBuf[MAX_PATH];
            len = sizeof(usbBuf);
            cr = CM_Get_DevNode_Registry_Property(devInst,
                                                  CM_DRP_DEVICEDESC,
                                                  NULL,
                                                  usbBuf,
                                                  &len,
                                                  0);

            if (cr == CR_SUCCESS) {
                ConfigInfo->deviceDesc = usbBuf;
            }

            //
            // Get the device class
            //
            len = sizeof(buf);
            cr = CM_Get_DevNode_Registry_Property(devInst,
                                                  CM_DRP_CLASS,
                                                  NULL,
                                                  buf,
                                                  &len,
                                                  0);

            if (cr == CR_SUCCESS) {
                ConfigInfo->deviceClass = buf;
            }

            len = sizeof(buf);
            cr = CM_Get_DevNode_Registry_Property(devInst,
                                                  CM_DRP_BUSTYPEGUID,
                                                  NULL,
                                                  buf,
                                                  &len,
                                                  0);

            if (cr == CR_SUCCESS) {
                GUID guid = *((LPGUID) buf);
            }


            len = sizeof(buf);
            cr = CM_Get_DevNode_Registry_Property(devInst,
                                                  CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                                  NULL,
                                                  buf,
                                                  &len,
                                                  0);

            //
            // Get the failed reason
            //
            ConfigInfo->usbFailure = 0;

            if (CM_Open_DevNode_Key(devInst,
                                    KEY_QUERY_VALUE,
                                    CM_REGISTRY_HARDWARE,
                                    RegDisposition_OpenExisting,
                                    &devKey,
                                    0) == CR_SUCCESS) {
                len = sizeof(DWORD);
                if (RegQueryValueEx(devKey,
                                    _T("FailReasonID"),
                                    NULL,
                                    NULL,
                                    (LPBYTE) &failID,
                                    &len) == ERROR_SUCCESS) {
                    ConfigInfo->usbFailure = failID;
                }

                RegCloseKey(devKey);
            }

            //
            // Get the config manager status for this device
            //
            cr = CM_Get_DevNode_Status(&status,
                                       &problemNumber,
                                       devInst,
                                       0);
            if (cr == CR_SUCCESS) {
                ConfigInfo->status = status;
                ConfigInfo->problemNumber = problemNumber;
            }

            return;     // (Don't search the rest of the device tree)
        }

        //
        // This DevNode didn't match, go down a level to the first child.
        //
        cr = CM_Get_Child(&devInstNext,
                          devInst,
                          0);

        if (cr == CR_SUCCESS)
        {
            devInst = devInstNext;
            continue;
        }

        //
        // Can't go down any further, go across to the next sibling.  If
        // there are no more siblings, go back up until there is a sibling.
        // If we can't go up any further, we're back at the root and we're
        // done.
        //
        for (;;)
        {
            cr = CM_Get_Sibling(&devInstNext,
                                devInst,
                                0);

            if (cr == CR_SUCCESS) {
                devInst = devInstNext;
                break;
            }

            cr = CM_Get_Parent(&devInstNext,
                               devInst,
                               0);

            if (cr == CR_SUCCESS) {
                devInst = devInstNext;
            }
            else {
                walkDone = TRUE;
                break;
            }
        }
    }

    return;
}

String UsbItem::GetRootHubName(HANDLE HostController)
{
    BOOL                success = FALSE;
    ULONG               nBytes = 0;
    USB_ROOT_HUB_NAME   rootHubName;
    PUSB_ROOT_HUB_NAME  rootHubNameW = 0;
    String              name;

    // Get the length of the name of the Root Hub attached to the
    // Host Controller
    //
    success = DeviceIoControl(HostController,
                              IOCTL_USB_GET_ROOT_HUB_NAME,
                              0,
                              0,
                              &rootHubName,
                              sizeof(rootHubName),
                              &nBytes,
                              NULL);

    if (!success) {
        USBERROR((_T("Failed to get root hub name\n")));
        goto GetRootHubNameError;
    }

    // Allocate space to hold the Root Hub name
    //
    nBytes = rootHubName.ActualLength;
    // rootHubNameW = ALLOC(nBytes);
    rootHubNameW = (PUSB_ROOT_HUB_NAME) LocalAlloc(LPTR, nBytes);
    if (!rootHubNameW) {
        USBERROR((_T("Root hub name alloc failed.")));
        goto GetRootHubNameError;
    }
    rootHubNameW->ActualLength = nBytes;

    // Get the name of the Root Hub attached to the Host Controller
    //
    success = DeviceIoControl(HostController,
                              IOCTL_USB_GET_ROOT_HUB_NAME,
                              NULL,
                              0,
                              rootHubNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success) {
        USBERROR((_T("Failed to get root hub name\n")));
        goto GetRootHubNameError;
    }

    name = rootHubNameW->RootHubName;
    LocalFree(rootHubNameW);

    return name;


GetRootHubNameError:
    // There was an error, free anything that was allocated
    //
    if (rootHubNameW != NULL)
    {
        LocalFree(rootHubNameW);
    }

    return String();
}

PUSB_DESCRIPTOR_REQUEST
UsbItem::GetConfigDescriptor(
    HANDLE  hHubDevice,
    ULONG   ConnectionIndex
    )
{
    BOOL    success;
    ULONG   nBytes;
    ULONG   nBytesReturned;

    PUSB_DESCRIPTOR_REQUEST configDescReq = 0;

    nBytes = sizeof(USB_DESCRIPTOR_REQUEST) + sizeof(USB_CONFIGURATION_DESCRIPTOR);

    configDescReq = (PUSB_DESCRIPTOR_REQUEST) LocalAlloc(LPTR, nBytes);
    if (!configDescReq) {
        USBERROR((_T("Out of memory!\n")));
        return NULL;
    }

    // Indicate the port from which the descriptor will be requested
    //
    configDescReq->ConnectionIndex = ConnectionIndex;

    //
    // USBHUB uses URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE to process this
    // IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION request.
    //
    // USBD will automatically initialize these fields:
    //     bmRequest = 0x80
    //     bRequest  = 0x06
    //
    // We must inititialize these fields:
    //     wValue    = Descriptor Type (high) and Descriptor Index (low byte)
    //     wIndex    = Zero (or Language ID for String Descriptors)
    //     wLength   = Length of descriptor buffer
    //
    configDescReq->SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE << 8)
                                        | 0;

    configDescReq->SetupPacket.wLength = (USHORT)(nBytes - sizeof(USB_DESCRIPTOR_REQUEST));

    // Now issue the get descriptor request.
    //
    success = DeviceIoControl(hHubDevice,
                              IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,
                              configDescReq,
                              nBytes,
                              configDescReq,
                              nBytes,
                              &nBytesReturned,
                              NULL);

    if (!success ||
        nBytes != nBytesReturned) {
        // OOPS();
        LocalFree(configDescReq);
        return NULL;
    }

    return configDescReq;
}

BOOL
SearchAndReplace(LPCWSTR   FindThis,
                 LPCWSTR   FindWithin,
                 LPCWSTR   ReplaceWith,
                 String &NewString)
{
    BOOL success = FALSE;
    size_t i=0, j=0;
    for (i=0; i < wcslen(FindWithin); i++ ) {
        if (FindWithin[i] == *FindThis) {
            //
            // The first character matched.  See if we got more.
            //
            for (j=0;
                 j < wcslen(FindThis) && j+i < wcslen(FindWithin);
                 j++ ) {
                if (FindWithin[j+i] != FindThis[j]) {
                    // No match, get out
                    break;
                }
            }
            if (j == wcslen(FindThis)) {
                //
                // Since j reached the end of the substring to find, we must
                // have succeeded.
                //
                success = TRUE;
                break;
            }
        }
    }
    if (success) {
        //
        // Replace the string with the new one.  Copy the first part and then
        // append the rest.
        //
        WCHAR temp[MAX_PATH];
        wcsncpy(temp, FindWithin, i);
        temp[i] = '\0';
        NewString = temp;

        String s1= ReplaceWith;
        String s2 = (LPWSTR) &FindWithin[j+i];
        NewString += s1;
        NewString += s2; //(LPTSTR) ReplaceWith + (LPTSTR) &FindWithin[j+i-1];
    }
    return success;
}

HANDLE GetHandleForDevice(const String &DeviceName)
{
    HANDLE      hHCDev;
    String      realDeviceName;

    //
    // We have to replace \DosDevices\ and \??\ prefixes on device names with
    // \\.\ because they don't work.
    //
    if (!SearchAndReplace (L"\\DosDevices\\",
                           DeviceName.c_str(),
                           L"\\\\.\\",
                           realDeviceName)) {
        if (!SearchAndReplace (L"\\??\\",
                               DeviceName.c_str(),
                               L"\\\\.\\",
                               realDeviceName)) {
            if (!SearchAndReplace (L"\\\\.\\",
                                   DeviceName.c_str(),
                                   L"\\\\.\\",
                                   realDeviceName)) {
                if (!SearchAndReplace (L"\\\\?\\",
                                       DeviceName.c_str(),
                                       L"\\\\.\\",
                                       realDeviceName)) {

                    //
                    // It doesn't have anything on the front, put the "\\.\" there
                    //
                    realDeviceName = L"\\\\.\\";
                    realDeviceName += DeviceName;
                }
            }
        }
    }

    hHCDev = UsbCreateFile(realDeviceName.c_str(),
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
    return hHCDev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\power.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       POWER.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "UsbPopup.h"
#include "itemfind.h"
#include "debug.h"
#include "usbutil.h"

BOOL
UsbPowerPopup::Refresh()
{
    TV_INSERTSTRUCT item;
    int i=0; //, size;
    String hubName;
    int stage;
    TCHAR buf[MAX_PATH];
    TCHAR formatString[MAX_PATH];
    PUSB_ACQUIRE_INFO acquireInfo = 0;
    LPCTSTR deviceName = deviceItem.configInfo->deviceDesc.c_str();
    UsbItem *realItem;

    //
    // Clear all UI components, and then recreate the rootItem
    //
    UsbTreeView_DeleteAllItems(hTreeDevices);

    if (deviceState == DeviceReattached) {
        //
        // Set the notification using the name of the offending device
        //
        LoadString(gHInst,
                   IDS_POWER_SOLVED,
                   formatString,
                   MAX_PATH);
        LoadString(gHInst,
                   IDS_POWER_EXCEEDED,
                   buf,
                   MAX_PATH);
        MessageBox(hWnd, formatString, buf, MB_OK);
        EndDialog(hWnd, 0);
        return TRUE;
    }
    //
    // Set the notification using the name of the offending device
    //
    LoadString(gHInst,
               IDS_POWER_NOTIFICATION,
               formatString,
               MAX_PATH);
    UsbSprintf(buf, formatString, deviceName);
    if (!SetTextItem(hWnd, IDC_POWER_NOTIFICATION, buf)) {
        goto PowerRefreshError;
    }

    for (stage=0; stage < 2; stage++) {
        //
        // Recreate the rootItem for each enumeration attempt
        //
        if (rootItem) {
            DeleteChunk(rootItem);
            delete rootItem;
        }
        realItem = rootItem = new UsbItem;
        if (!realItem) {
            USBERROR((_T("Out of memory!\n")));
            goto PowerRefreshError;
        }
        AddChunk(rootItem);

        if (stage == 0) {
            acquireInfo = GetControllerName(WmiHandle,
                                            InstanceName.c_str());
            if (!acquireInfo) {
                goto PowerRefreshError;
            }

            if (!rootItem->EnumerateController(0,
                                              acquireInfo->Buffer,
                                              &ImageList,
                                              0)) {
                goto PowerRefreshError;
            }
            //
            // Usability: Rename the "Root Hub" to "My Computer" and change the
            // USB "shovel" icon to a computer icon.
            //
            LoadString(gHInst,
                       IDS_MY_COMPUTER,
                       buf,
                       MAX_PATH);
            rootItem->child->configInfo->deviceDesc = buf;
            wsprintf(buf, _T(" (%d ports)"), rootItem->child->NumPorts());
            rootItem->child->configInfo->deviceDesc += buf;
            ImageList.GetClassImageIndex(MyComputerClass,
                                         &rootItem->child->imageIndex);
            acquireInfo = (PUSB_ACQUIRE_INFO) LocalFree(acquireInfo);
        } else {
            if (!rootItem->EnumerateAll(&ImageList)) {
                goto PowerRefreshError;
            }
            if (rootItem->NumChildren() == 1) {
                realItem = rootItem->child;
                break;
            }
        }

        if (rootItem->child) {
            //
            // Find all unused ports on self powered hubs
            //
            UsbItemActionFindSelfPoweredHubsWithFreePorts find1(rootItem);
            rootItem->Walk(find1);
            UsbItemList& devices1 = find1.GetHubs();
            if (!devices1.empty()) {
                return AssembleDialog(rootItem->child,
                                      &item,
                                      deviceName,
                                      IDS_POWER_PORTS,
                                      IDS_POWER_RECOMMENDATION_PORTS,
                                      TrueAlways,
                                      UsbItemActionFindFreePortsOnSelfPoweredHubs::IsValid,
                                      UsbItemActionFindFreePortsOnSelfPoweredHubs::IsExpanded);
            }
            //
            // Find all self powered hubs that have devices attached requiring less
            // than or equal to 100 mA.  These devices can be switched with the
            // offending device.
            //
            UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs find2(rootItem);
            rootItem->Walk(find2);
            UsbItemList& devices2 = find2.GetDevices();
            if (!devices2.empty()) {
                return AssembleDialog(rootItem->child,
                                      &item,
                                      deviceName,
                                      IDS_POWER_DEVICE,
                                      IDS_POWER_RECOMMENDATION_DEVICE,
                                      TrueAlways,
                                      UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs::IsValid,
                                      UsbItemActionFindLowPoweredDevicesOnSelfPoweredHubs::IsExpanded);
            }
        }
    }

    {
        //
        // Find all self powered hubs that have devices attached requiring less
        // than or equal to 100 mA.  These devices can be switched with the
        // offending device.
        //
        UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs find2(realItem);
        realItem->Walk(find2);
        UsbItemList& devices = find2.GetDevices();
        if (!devices.empty()) {
            return AssembleDialog(realItem->child,
                                  &item,
                                  deviceName,
                                  IDS_POWER_HIGHDEVICE,
                                  IDS_POWER_RECHIGHDEVICE,
                                  TrueAlways,
                                  UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs::IsValid,
                                  UsbItemActionFindUnknownPoweredDevicesOnSelfPoweredHubs::IsExpanded);
        }
    }
    //
    // Last resort here.  Highlight high-powered devices on self-powered hubs
    // and tell the user to put it there if they want the device to work.
    //
    if (realItem->child) {
        return AssembleDialog(realItem->child,
                              &item,
                              deviceName,
                              IDS_POWER_HIGHDEVICE,
                              IDS_POWER_RECHIGHDEVICE,
                              TrueAlways,
                              UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs::IsValid,
                              UsbItemActionFindHighPoweredDevicesOnSelfPoweredHubs::IsExpanded);
    }
    return TRUE;
PowerRefreshError:
    if (acquireInfo) {
        LocalFree(acquireInfo);
    }
    return FALSE;
}

BOOL
UsbPowerPopup::AssembleDialog(UsbItem*              RootItem,
                              LPTV_INSERTSTRUCT     LvItem,
                              LPCTSTR               DeviceName,
                              UINT                  Explanation,
                              UINT                  Recommendation,
                              PUsbItemActionIsValid IsValid,
                              PUsbItemActionIsValid IsBold,
                              PUsbItemActionIsValid IsExpanded)
{
    HTREEITEM hDevice;
    TCHAR buf[MAX_PATH], formatString[MAX_PATH];

    LoadString(gHInst,
               Recommendation,
               formatString,
               MAX_PATH);
    UsbSprintf(buf, formatString, DeviceName);
    if (!SetTextItem(hWnd, IDC_POWER_RECOMMENDATION, buf) ||
        !SetTextItem(hWnd, IDC_POWER_EXPLANATION, Explanation)) {
        return FALSE;
    }

    if (!InsertTreeItem(hTreeDevices,
                        RootItem,
                        NULL,
                        LvItem,
                        IsValid,
                        IsBold,
                        IsExpanded)) {
        return FALSE;
    }
    if (NULL != (hDevice = TreeView_FindItem(hTreeDevices,
                                             DeviceName))) {
        return TreeView_SelectItem (hTreeDevices, hDevice);
    }
    return TRUE;
}

USBINT_PTR
UsbPowerPopup::OnTimer()
{
    if (deviceState == DeviceAttachedError) {
        if (S_FALSE == QueryContinue()) {
            // Update the device state
            deviceState = DeviceDetachedError;

        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\powrpage.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       POWRPAGE.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _POWERPAGE_H
#define _POWERPAGE_H

#include "PropPage.h"
#include "UsbItem.h"

#define idh_devmgr_hub_self_power 300100
#define	idh_devmgr_hub_power_avail 300200
#define	idh_devmgr_hub_protection 300300
#define	idh_devmgr_hub_devices_on_this_hub 300400
#define	idh_devmgr_hub_list_devices 300500
#define	idh_devmgr_hub_refresh_button 300600

class PowerPage : public UsbPropertyPage {
public:
    PowerPage(UsbItem *item) : UsbPropertyPage(item) {Initialize();}
    PowerPage(HWND HWndParent, LPCSTR DevName) : UsbPropertyPage(HWndParent, DevName) {Initialize();}
    PowerPage(HDEVINFO         DeviceInfoSet,        
              PSP_DEVINFO_DATA DeviceInfoData) :
        UsbPropertyPage(DeviceInfoSet, DeviceInfoData) {Initialize();}
    
    HPROPSHEETPAGE Create();

protected:
    HWND hLstDevices;

    void Refresh();
    VOID Initialize();

	void OnClickListDevices(NMHDR* pNMHDR, LRESULT* pResult);
	void OnSetFocusListDevices(NMHDR* pNMHDR, LRESULT* pResult);
	BOOL OnInitDialog();
    BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl);
    BOOL OnNotify(HWND hDlg, INT nID , LPNMHDR pnmh);
    void OnNotifyListDevices(HWND hDlg, LPNMHDR pnmh);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\nested.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       NESTED.CPP
*  VERSION:     1.0
*  AUTHOR:      randyau
*  DATE:        10/11/2000
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  9/19/2000 randyau Original implementation.
*
*******************************************************************************/
#include "UsbPopup.h"
#include "itemfind.h"
#include "debug.h"
#include "usbutil.h"

BOOL
UsbNestedHubPopup::Refresh()
{
    TV_INSERTSTRUCT item;
    int i=0; //, size;
    String hubName;
    int stage;
    TCHAR buf[MAX_PATH];
    TCHAR formatString[MAX_PATH];
    PUSB_ACQUIRE_INFO acquireInfo = 0;
    LPCTSTR deviceName = deviceItem.configInfo->deviceDesc.c_str();
    UsbItem *realItem;

    if (deviceState == DeviceReattached) {
        //
        // Set the notification using the name of the offending device
        //
        LoadString(gHInst,
                   IDS_NESTED_SOLVED,
                   formatString,
                   MAX_PATH);
        LoadString(gHInst,
                   IDS_HUB_NESTED_TOO_DEEPLY,
                   buf,
                   MAX_PATH);
        MessageBox(hWnd, formatString, buf, MB_OK);
        EndDialog(hWnd, 0);
        return TRUE;
    }

    //
    // Clear all UI components, and then recreate the rootItem
    //
    UsbTreeView_DeleteAllItems(hTreeDevices);

    //
    // Set the notification using the name of the offending device
    //
    LoadString(gHInst,
               IDS_NESTED_NOTIFICATION,
               buf,
               MAX_PATH);
    if (!SetTextItem(hWnd, IDC_NESTED_NOTIFICATION, buf)) {
        goto NestedRefreshError;
    }

    for (stage=0; stage < 2; stage++) {
        //
        // Recreate the rootItem for each enumeration attempt
        //
        if (rootItem) {
            DeleteChunk(rootItem);
            delete rootItem;
        }
        realItem = rootItem = new UsbItem;
        if (!realItem) {
            USBERROR((_T("Out of memory!\n")));
            goto NestedRefreshError;
        }
        AddChunk(rootItem);

        if (stage == 0) {
            acquireInfo = GetControllerName(WmiHandle,
                                            InstanceName.c_str());
            if (!acquireInfo) {
                goto NestedRefreshError;
            }

            if (!rootItem->EnumerateController(0,
                                              acquireInfo->Buffer,
                                              &ImageList,
                                              0)) {
                goto NestedRefreshError;
            }
            //
            // Usability: Rename the "Root Hub" to "My Computer" and change the
            // USB "shovel" icon to a computer icon.
            //
            LoadString(gHInst,
                       IDS_MY_COMPUTER,
                       buf,
                       MAX_PATH);
            rootItem->child->configInfo->deviceDesc = buf;
            wsprintf(buf, _T(" (%d ports)"), rootItem->child->NumPorts());
            rootItem->child->configInfo->deviceDesc += buf;
            ImageList.GetClassImageIndex(MyComputerClass,
                                         &rootItem->child->imageIndex);
            acquireInfo = (PUSB_ACQUIRE_INFO) LocalFree(acquireInfo);
        } else {
            if (!rootItem->EnumerateAll(&ImageList)) {
                goto NestedRefreshError;
            }
            if (rootItem->NumChildren() == 1) {
                realItem = rootItem->child;
                break;
            }
        }

        if (rootItem->child) {

            if (deviceItem.PortPower() > 100) {
                // Self powered hubs can go anywhere.

                //
                // Find all hubs with unused ports.
                //
                USBTRACE((_T("Looking for free ports on self powered hubs\n")));
                UsbItemActionFindHubsWithFreePorts find1(rootItem);
                rootItem->Walk(find1);
                UsbItemList& devices1 = find1.GetHubs();
                if (!devices1.empty()) {
                    USBTRACE((_T("Found free ports on self powered hubs\n")));
                    return AssembleDialog(rootItem->child,
                                          &item,
                                          deviceName,
                                          IDS_FREE_PORTS,
                                          IDS_FREE_PORTS_RECOMMENDATION,
                                          TrueAlways,
                                          UsbItemActionFindHubsWithFreePorts::IsValid,
                                          UsbItemActionFindHubsWithFreePorts::IsExpanded);
                }

                USBTRACE((_T("Didn't find free ports on self powered hubs\n")));

                //
                // Find all devices on hubs.
                // These devices can be switched with the
                // offending device.
                //
                UsbItemActionFindDevicesOnHubs find2(rootItem);
                rootItem->Walk(find2);
                UsbItemList& devices2 = find2.GetDevices();
                if (!devices2.empty()) {
                    return AssembleDialog(rootItem->child,
                                          &item,
                                          deviceName,
                                          IDS_DEVICE_IN_POWERED_HUB,
                                          IDS_DEVICE_IN_POWERED_HUB_RECOMMENDATION,
                                          TrueAlways,
                                          UsbItemActionFindDevicesOnHubs::IsValid,
                                          UsbItemActionFindDevicesOnHubs::IsExpanded);
                }
            } else {                //
                // Bus powered hubs need a self-powered hub.

                // Find all unused ports on self powered hubs
                //
                USBTRACE((_T("Looking for free ports on self powered hubs\n")));
                UsbItemActionFindSelfPoweredHubsWithFreePortsForHub find1(rootItem);
                rootItem->Walk(find1);
                UsbItemList& devices1 = find1.GetHubs();
                if (!devices1.empty()) {
                    USBTRACE((_T("Found free ports on self powered hubs\n")));
                    return AssembleDialog(rootItem->child,
                                          &item,
                                          deviceName,
                                          IDS_FREE_POWERED_PORTS,
                                          IDS_FREE_PORTS_RECOMMENDATION,
                                          TrueAlways,
                                          UsbItemActionFindSelfPoweredHubsWithFreePorts::IsValid,
                                          UsbItemActionFindSelfPoweredHubsWithFreePorts::IsExpanded);
                }

                USBTRACE((_T("Didn't find free ports on self powered hubs\n")));

                //
                // Find all devices on self powered hubs.
                // These devices can be switched with the
                // offending device.
                //
                UsbItemActionFindDevicesOnSelfPoweredHubs find2(rootItem);
                rootItem->Walk(find2);
                UsbItemList& devices2 = find2.GetDevices();
                if (!devices2.empty()) {
                    return AssembleDialog(rootItem->child,
                                          &item,
                                          deviceName,
                                          IDS_DEVICE_IN_POWERED_HUB,
                                          IDS_DEVICE_IN_POWERED_HUB_RECOMMENDATION,
                                          TrueAlways,
                                          UsbItemActionFindDevicesOnSelfPoweredHubs::IsValid,
                                          UsbItemActionFindDevicesOnSelfPoweredHubs::IsExpanded);
                }

            }

        }
    }

    // Shouldn't get here.
    assert(FALSE);
    return TRUE;
NestedRefreshError:
    USBTRACE((_T("NestedRefreshError\n")));

    if (acquireInfo) {
        LocalFree(acquireInfo);
    }
    return FALSE;
}

BOOL
UsbNestedHubPopup::AssembleDialog(UsbItem*              RootItem,
                               LPTV_INSERTSTRUCT     LvItem,
                               LPCTSTR               DeviceName,
                               UINT                  Explanation,
                               UINT                  Recommendation,
                               PUsbItemActionIsValid IsValid,
                               PUsbItemActionIsValid IsBold,
                               PUsbItemActionIsValid IsExpanded)
{
    HTREEITEM hDevice;
    TCHAR buf[MAX_PATH], formatString[MAX_PATH];

    LoadString(gHInst,
               Recommendation,
               formatString,
               MAX_PATH);
    UsbSprintf(buf, formatString, DeviceName);
    if (!SetTextItem(hWnd, IDC_NESTED_RECOMMENDATION, buf) ||
        !SetTextItem(hWnd, IDC_NESTED_EXPLANATION, Explanation)) {
        return FALSE;
    }

    if (!InsertTreeItem(hTreeDevices,
                        RootItem,
                        NULL,
                        LvItem,
                        IsValid,
                        IsBold,
                        IsExpanded)) {
        return FALSE;
    }
    if (NULL != (hDevice = TreeView_FindItem(hTreeDevices,
                                             DeviceName))) {
        return TreeView_SelectItem (hTreeDevices, hDevice);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\powrpage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       POWRPAGE.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include <assert.h>

#include "PowrPage.h"
#include "debug.h"

#include "ItemFind.h"
#include "resource.h"
#include "usbutil.h"

const DWORD PowerHelpIds[]=
{
	IDC_STATIC,	IDH_NOHELP,	//hub information text - help not needed
	IDC_SELF_POWER, idh_devmgr_hub_self_power,	//selfpowered or bus powered
	IDC_POWER_AVAIL, idh_devmgr_hub_power_avail,	//total power available text
	IDC_DESCRIPTION, idh_devmgr_hub_devices_on_this_hub,	//description of list box
	IDC_LIST_DEVICES, idh_devmgr_hub_list_devices,	//the list box for hub devices
	IDC_REFRESH, idh_devmgr_hub_refresh_button,
	0, 0
};

VOID
PowerPage::Initialize()
{
    dlgResource = IDD_POWER;
    hLstDevices = NULL;
    HelpIds = (const DWORD *) PowerHelpIds;
}

BOOL PowerPage::OnInitDialog()
{
    LV_COLUMN column;
    RECT rect;
    TCHAR buf[MAX_PATH];
    
    if (preItem) {
        SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & ~WS_CAPTION);
        //
        // Make the Refresh button go away
        //
        HWND hRefresh;
        if (NULL != (hRefresh =GetDlgItem(hwnd, IDC_REFRESH)) ) {
            SetWindowLong(hRefresh,
                          GWL_STYLE, 
                          (GetWindowLong(hRefresh, GWL_STYLE) | WS_DISABLED)
                           & ~WS_VISIBLE);
        }
    } else if (!deviceInfoSet && !deviceInfoData) {
        //
        // Make the Refresh button go away and make the Close button visible
        //
        HWND hButton;
        if (NULL != (hButton =GetDlgItem(hwnd, IDC_REFRESH)) ) {
            SetWindowLong(hButton, 
                          GWL_STYLE, 
                          (GetWindowLong(hButton, GWL_STYLE) | WS_DISABLED) & 
                          ~WS_VISIBLE);
        }
        if (NULL != (hButton =GetDlgItem(hwnd, IDC_POWER_CLOSE)) ) {
            SetWindowLong(hButton, 
                          GWL_STYLE, 
                          (GetWindowLong(hButton, GWL_STYLE) | WS_VISIBLE) & 
                          ~WS_DISABLED);
        }
//        if (!RegisterForDeviceNotification(hwnd))
//            MessageBox(hwnd,TEXT("Error"),TEXT("Dynamic refresh unavailable"),MB_OK);
    } else {
//        RegisterForDeviceNotification(hwnd);
    }

    hLstDevices = GetDlgItem(hwnd, IDC_LIST_DEVICES);

    ListView_SetImageList(hLstDevices, imageList.ImageList(), LVSIL_SMALL);

    ZeroMemory(&column, sizeof(LV_COLUMN));
    
    column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    column.fmt = LVCFMT_LEFT;
    LoadString(gHInst, IDS_DEVICE_DESCRIPTION, buf, MAX_PATH);
    column.pszText = buf;
    GetClientRect(hLstDevices, &rect);
    column.cx = (int)(.7*(rect.right - rect.left));
    
    // ListView_InsertColumn(hLstDevices, 0, &column);
    SendMessage(hLstDevices, LVM_INSERTCOLUMN, (WPARAM)0, (LPARAM)&column);

    ZeroMemory(&column, sizeof(LV_COLUMN));
    
    column.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    column.fmt = LVCFMT_LEFT;
    LoadString(gHInst, IDS_POWER_CONSUMED, buf, MAX_PATH);
    column.pszText = buf;
    GetClientRect(hLstDevices, &rect);
    column.cx = (int) (.3*(rect.right - rect.left));
    
    // ListView_InsertColumn(hLstDevices, 1, &column);
    SendMessage(hLstDevices, LVM_INSERTCOLUMN, (WPARAM)1, (LPARAM)&column);

    Refresh();

    return TRUE;
}

BOOL 
PowerPage::OnCommand(INT wNotifyCode,
                          INT wID,
                          HWND hCtl)
{
    if (wNotifyCode == BN_CLICKED) {
        if (wID == IDC_REFRESH) {
            Refresh();
            return FALSE;
        } else if (wID == IDC_POWER_CLOSE) {
/*            if (hDevNotify) {
               UnregisterDeviceNotification(hDevNotify);
               UnregisterDeviceNotification(hHubNotify);
               hDevNotify = NULL;
            }*/
            EndDialog(hwnd, wID);
        }
    }
    return TRUE;
}

BOOL 
PowerPage::OnNotify(HWND hDlg, int nID, LPNMHDR pnmh)
{
    switch (nID) {
    case IDC_LIST_DEVICES:
        OnNotifyListDevices(hDlg, pnmh);
        break;
    }

    return 0;
}

void 
PowerPage::OnNotifyListDevices(HWND hDlg, LPNMHDR pnmh)
{
    if (pnmh->code == NM_DBLCLK) {
        //
        // Display properties on this specific device on double click
        //
        DisplayPPSelectedListItem(hwnd, hLstDevices);
    }
}

void PowerPage::Refresh()
{
    UsbItem *usbItem = 0, *hub;
    LVITEM item;
    int i=0; //, size;
    TCHAR buf[MAX_PATH], formatString[MAX_PATH];
    // CWaitCursor wait;

    //
    // Clear all UI components
    //
    ListView_DeleteAllItems(hLstDevices);

    if (preItem) {
        hub = preItem;
    } else {
        if (deviceName.empty()) {
            if (!GetDeviceName()) {
                goto PowerPageRefreshError;
            }
        }

        //
        // Recreate the rootItem
        //
        if (rootItem) {
            DeleteChunk(rootItem);
            delete rootItem;
        }
        rootItem = new UsbItem;
        AddChunk(rootItem);
        hub = rootItem;
		if (deviceInfoData) {
			if (!hub->EnumerateHub(deviceName, 
                                   &imageList, 
                                   deviceInfoData->DevInst,
                                   NULL,
                                   UsbItem::UsbItemType::Hub)) {
                goto PowerPageRefreshError;
			}
		} else {
			if (!hub->EnumerateHub(deviceName, 
                                   &imageList, 
                                   NULL,
                                   NULL,
                                   UsbItem::UsbItemType::Hub)) {
                goto PowerPageRefreshError;
			}
		}
    }

    ZeroMemory(&item, sizeof(LVITEM));
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    
    if (hub->child) {
        for (usbItem = hub->child, i = 0; 
             usbItem; 
             usbItem = usbItem->sibling, i++) {
            
            if (!usbItem->IsDescriptionValidDevice()) {
                i--;
                continue;
            }
            item.iItem = i;
            item.iImage = usbItem->imageIndex;
            item.lParam = (LPARAM) usbItem;
            assert(usbItem->configInfo != NULL);
            item.pszText = (LPTSTR) usbItem->configInfo->deviceDesc.c_str();
            ListView_InsertItem(hLstDevices, &item);
            
            if (usbItem->ComputePower()) {
                LoadString(gHInst, IDS_POWER_CONSUMPTION, formatString, MAX_PATH);
                UsbSprintf(buf, formatString, usbItem->power);
            } else {
                LoadString(gHInst, IDS_UNKNOWN, buf, MAX_PATH);
            }
            ListView_SetItemText(hLstDevices, i, 1, buf);
        }
    }
    
    if (hub->NumPorts() - hub->NumChildren() > 0) {
        //
        // Add an item indicating the number of ports available
        //
        item.iItem = i;
        item.iImage = -1;
        item.lParam = (LPARAM) NULL;
        LoadString(gHInst, IDS_PORTS_AVAILABLE, formatString, MAX_PATH);
        UsbSprintf(buf, formatString, hub->NumPorts() - hub->NumChildren());
        item.pszText = buf;
        ListView_InsertItem(hLstDevices, &item);
        
        LoadString(gHInst, IDS_POWER_CONSUMPTION, formatString, MAX_PATH);
        UsbSprintf(buf, formatString, 0);
        ListView_SetItemText(hLstDevices, i, 1, buf);
    }

    LoadString(gHInst, IDS_TOTAL_POWER, formatString, MAX_PATH);
    UsbSprintf(buf, formatString, hub->PortPower());
    SetTextItem(hwnd, IDC_POWER_AVAIL, buf);

    if (hub->PortPower() > 100) {
        SetTextItem(hwnd, IDC_SELF_POWER, IDS_POWER_SELF);
    } else {
        SetTextItem(hwnd, IDC_SELF_POWER, IDS_POWER_BUS);
    }
    return;
PowerPageRefreshError:
    //
    // The hub is malfunctioning. Show the property page as disabled.
    //
    HWND hButton;
    if (NULL != (hButton = GetDlgItem(hwnd, IDC_REFRESH)) ) {
        SetWindowLong(hButton, 
                      GWL_STYLE, 
                      (GetWindowLong(hButton, GWL_STYLE) | WS_DISABLED));
    }
    if (NULL != (hButton = GetDlgItem(hwnd, IDC_LIST_DEVICES)) ) {
        SetWindowLong(hButton, 
                      GWL_STYLE, 
                      (GetWindowLong(hButton, GWL_STYLE) | WS_DISABLED));
    }
    if (NULL != (hButton = GetDlgItem(hwnd, IDC_DESCRIPTION)) ) {
        SetWindowLong(hButton, 
                      GWL_STYLE, 
                      (GetWindowLong(hButton, GWL_STYLE) | WS_DISABLED));
    }
    SetTextItem(hwnd, IDC_POWER_AVAIL, TEXT(""));
    SetTextItem(hwnd, IDC_SELF_POWER, IDS_POWER_MALFUNCTIONING);
}

HPROPSHEETPAGE PowerPage::Create()
{
    //
    // Make sure that this is indeed a hub
    //
    if (deviceName.empty()) {
        if (!GetDeviceName()) {
            return NULL;
        }
    }
    return UsbPropertyPage::Create();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\ovrcurnt.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       OVRCURNT.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "usbpopup.h"
#include "itemfind.h"
#include "debug.h"
#include "usbutil.h"

//
// Refresh the contents of the treeview control.
// Find all hubs with unused ports on them.  If there are none, find some which
// have devices requiring less than 100 mA.
// 
BOOL UsbOvercurrentPopup::Refresh()
{
    TV_INSERTSTRUCT item;
    int i=0; //, size;
    PUSB_ACQUIRE_INFO acquireInfoController = 0;
    BOOL result = FALSE;
    TCHAR buf[MAX_PATH], formatString[MAX_PATH];
    HWND hReset;
    String hubName = HubAcquireInfo->Buffer;

    //
    // Make the Reset button visible, since this is the overcurrent dialog
    //
    if (NULL != (hReset =GetDlgItem(hWnd, IDC_RESET_PORT)) ) {
        SetWindowLong(hReset,
                      GWL_STYLE, 
                      (GetWindowLong(hReset, GWL_STYLE) | WS_VISIBLE)
                       & ~WS_DISABLED);
    }
    
    //
    // Set the window's title bar
    //
    LoadString(gHInst, IDS_CURRENT_LIMIT_EXCEEDED, buf, MAX_PATH);
    SetWindowText(hWnd, buf);

    //
    // Clear all UI components, and then recreate the rootItem
    //
    UsbTreeView_DeleteAllItems(hTreeDevices);
    if (rootItem) {
        DeleteChunk(rootItem);
        delete rootItem;
    }
    rootItem = new UsbItem;
    if (!rootItem) {
        USBERROR((_T("Out of memory!\n")));
        goto OvercurrentRefreshError;
    }
    AddChunk(rootItem);

    //
    // Get the controller name and enumerate the tree
    //
    acquireInfoController = GetControllerName(WmiHandle, 
                                              InstanceName);
    if (!acquireInfoController) {
        goto OvercurrentRefreshError;
    }
    if (!rootItem->EnumerateController(0,
                                      acquireInfoController->Buffer,
                                      &ImageList, 
                                      0)) {
        goto OvercurrentRefreshError;
    } 
    acquireInfoController = (PUSB_ACQUIRE_INFO) LocalFree(acquireInfoController);
    
    LoadString(gHInst, IDS_UNKNOWNDEVICE, buf, MAX_PATH);
    LoadString(gHInst, IDS_UNKNOWNDEVICE, formatString, MAX_PATH);
    if (deviceItem.IsUnusedPort() ||
        !_tcscmp(deviceItem.configInfo->deviceDesc.c_str(), buf) ||
        !_tcscmp(deviceItem.configInfo->deviceDesc.c_str(), formatString)) {
        //
        // The hub has eroneously removed the device prior to throwing the 
        // overcurrent notification
        //
        LoadString(gHInst, 
                   IDS_OVERCURRENT_NOTIFICATION_UNKNOWN, 
                   buf, 
                   MAX_PATH);
    } else {
        //
        // The device is still there
        // Set the notification using the name of the offending device
        //
        LoadString(gHInst, 
                   IDS_OVERCURRENT_NOTIFICATION, 
                   formatString, 
                   MAX_PATH);
        UsbSprintf(buf, formatString, deviceItem.configInfo->deviceDesc.c_str());
    }
    if (!SetTextItem(hWnd, IDC_POWER_NOTIFICATION, buf) ||
        !SetTextItem(hWnd, IDC_POWER_EXPLANATION, IDS_ENUMFAIL_COURSE) ||
        !SetTextItem(hWnd, IDC_POWER_RECOMMENDATION, IDS_OVERCURRENT_RECOMMENDATION)) {
        goto OvercurrentRefreshError;
    }
    
    if (rootItem->child) {
        if (deviceItem.configInfo->devInst) {
            //
            // The device hasn't been removed by either the hub or the user yet
            // Find the overcurrent device
            //
            UsbItemActionFindOvercurrentDevice f1(deviceItem.configInfo->devInst);
            rootItem->Walk(f1);
            if (f1.GetDevice()) {
                //
                // Device is still attached
                //
                result=InsertTreeItem (hTreeDevices,
                                       rootItem->child,
                                       TreeView_GetRoot(hTreeDevices),
                                       &item,
                                       TrueAlways,
                                       UsbItemActionFindOvercurrentDevice::IsValid,
                                       UsbItemActionFindOvercurrentDevice::IsExpanded);
            }
        } 
        if (!result) {
            //
            // Device has been removed by either the hub or the user. Find the
            // hub that the device was attached to and highlight the port.
            //
            UsbItemActionFindOvercurrentHubPort f2(hubName, deviceItem.cxnAttributes.ConnectionIndex);
            rootItem->Walk(f2);
            if (f2.GetDevice()) {
                result=InsertTreeItem (hTreeDevices,
                                       rootItem->child,
                                       TreeView_GetRoot(hTreeDevices),
                                       &item,
                                       TrueAlways,
                                       UsbItemActionFindOvercurrentHubPort::IsValid,
                                       UsbItemActionFindOvercurrentHubPort::IsExpanded);
            }
        }
    }
    return result;
OvercurrentRefreshError:
    if (acquireInfoController) {
        LocalFree(acquireInfoController);
    }
    return FALSE;
}

BOOL 
UsbOvercurrentPopup::OnCommand(INT wNotifyCode,
                 INT wID,
                 HWND hCtl)
{
    switch (wID) {
    case IDC_RESET_PORT:
        PUSB_CONNECTION_NOTIFICATION resetNotification;
        ULONG size, res;
        _try {
            size = sizeof(USB_CONNECTION_NOTIFICATION);
            resetNotification = 
                (PUSB_CONNECTION_NOTIFICATION) LocalAlloc(LMEM_ZEROINIT, size);
            if (!resetNotification) {
                //
                // do something here
                //
                return FALSE;
            }
        
            resetNotification->NotificationType = ResetOvercurrent;
            resetNotification->ConnectionNumber =
                ConnectionNotification->ConnectionNumber;
        
            res = WmiExecuteMethod(WmiHandle,
                                   InstanceName.c_str(),
                                   ResetOvercurrent,
                                   size,
                                   resetNotification,
                                   &size,
                                   resetNotification);
        
            if (res != ERROR_SUCCESS) {
                TCHAR szTitle[MAX_PATH], szMessage[MAX_PATH];
                LoadString(gHInst, IDS_RESET_FAILED, szMessage, MAX_PATH);
                LoadString(gHInst, IDS_USB_ERROR, szTitle, MAX_PATH);
                MessageBox(hWnd, szMessage, szTitle, MB_OK | MB_USERICON);
            }
        }
        _finally {
            if (resetNotification) {
                LocalFree(resetNotification);
            }
            EndDialog(hWnd, wID);
        }
        return TRUE;
    case IDOK:
        EndDialog(hWnd, wID);
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbOvercurrentPopup::CustomDialogWrap() 
{ 
    TCHAR unknownDevice[MAX_PATH], unknownHub[MAX_PATH];

    LoadString(gHInst, IDS_UNKNOWNDEVICE, unknownDevice, MAX_PATH);
    LoadString(gHInst, IDS_UNKNOWNHUB, unknownHub, MAX_PATH);
    if (deviceItem.IsUnusedPort() ||
        !_tcscmp(deviceItem.configInfo->deviceDesc.c_str(), unknownDevice) ||
        !_tcscmp(deviceItem.configInfo->deviceDesc.c_str(), unknownHub)) {
        return CustomDialog(IDD_INSUFFICIENT_POWER,
                            NIIF_ERROR,
                            IDS_OVERCURRENT_INITIAL_UNKNOWN, 
                            IDS_CURRENT_LIMIT_EXCEEDED);
    } else {
        return CustomDialog(IDD_INSUFFICIENT_POWER,
                            NIIF_ERROR,
                            IDS_OVERCURRENT_INITIAL, 
                            IDS_CURRENT_LIMIT_EXCEEDED); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\legacy.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       LEGACY.CPP
*  VERSION:     1.0
*  AUTHOR:      randyau
*  DATE:        9/19/2000
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  9/19/2000 randyau Original implementation.
*
*******************************************************************************/
#include "UsbPopup.h"
#include "itemfind.h"
#include "debug.h"
#include "usbutil.h"

BOOL
Usb20ControllersOnly (
    UsbItem *Item)
{
    if (Item->IsController()) {
        if (Item->child &&
            Item->child->UsbVersion() >= 0x200) {
            return TRUE;
        }
        return FALSE;
    }
    return TRUE;
}


BOOL
UsbLegacyPopup::Refresh()
{
    TV_INSERTSTRUCT item;
    int i=0; //, size;
    String hubName;
    int stage;
    TCHAR buf[MAX_PATH];
    TCHAR formatString[MAX_PATH];
    PUSB_ACQUIRE_INFO acquireInfo = 0;
    LPCTSTR deviceName = deviceItem.configInfo->deviceDesc.c_str();
    UsbItem *realItem;

    //
    // Clear all UI components, and then recreate the rootItem
    //
    UsbTreeView_DeleteAllItems(hTreeDevices);

    if (deviceState == DeviceReattached) {
        //
        // Set the notification using the name of the offending device
        //
        LoadString(gHInst,
                   IDS_LEGACY_SOLVED,
                   formatString,
                   MAX_PATH);
        UsbSprintf(buf, formatString, deviceName);
        LoadString(gHInst,
                   IDS_USB2_DEVICE_IN_USB1_HUB,
                   formatString,
                   MAX_PATH);
        MessageBox(hWnd, buf, formatString, MB_OK);
        EndDialog(hWnd, 0);
        return TRUE;
    }
    //
    // Set the notification using the name of the offending device
    //
    LoadString(gHInst,
               IDS_LEGACY_NOTIFICATION,
               formatString,
               MAX_PATH);
    UsbSprintf(buf, formatString, deviceName);
    if (!SetTextItem(hWnd, IDC_LEGACY_NOTIFICATION, buf)) {
        goto LegacyRefreshError;
    }

    for (stage=0; stage < 2; stage++) {
        //
        // Recreate the rootItem for each enumeration attempt
        //
        if (rootItem) {
            DeleteChunk(rootItem);
            delete rootItem;
        }
        realItem = rootItem = new UsbItem;
        if (!realItem) {
            USBERROR((_T("Out of memory!\n")));
            goto LegacyRefreshError;
        }
        AddChunk(rootItem);

        if (stage == 0) {
            acquireInfo = GetControllerName(WmiHandle,
                                            InstanceName.c_str());
            if (!acquireInfo) {
                goto LegacyRefreshError;
            }

            if (!rootItem->EnumerateController(0,
                                              acquireInfo->Buffer,
                                              &ImageList,
                                              0)) {
                goto LegacyRefreshError;
            }
            //
            // Usability: Rename the "Root Hub" to "My Computer" and change the
            // USB "shovel" icon to a computer icon.
            //
            LoadString(gHInst,
                       IDS_MY_COMPUTER,
                       buf,
                       MAX_PATH);
            rootItem->child->configInfo->deviceDesc = buf;
            wsprintf(buf, _T(" (%d ports)"), rootItem->child->NumPorts());
            rootItem->child->configInfo->deviceDesc += buf;
            ImageList.GetClassImageIndex(MyComputerClass,
                                         &rootItem->child->imageIndex);
            acquireInfo = (PUSB_ACQUIRE_INFO) LocalFree(acquireInfo);
        } else {
            if (!rootItem->EnumerateAll(&ImageList)) {
                goto LegacyRefreshError;
            }
            if (rootItem->NumChildren() == 1) {
                realItem = rootItem->child;
                break;
            }
        }

        if (rootItem->child) {

            //
            // Find all usb 2.0 hubs with free ports.
            //
            USBTRACE((_T("Looking for free ports on usb 2.0 hubs\n")));
            UsbItemActionFindUsb2xHubsWithFreePorts find1(rootItem);
            rootItem->Walk(find1);
            UsbItemList& devices1 = find1.GetHubs();
            if (!devices1.empty()) {
                USBTRACE((_T("Found free ports on usb 2.0 hubs\n")));
                return AssembleDialog(rootItem->child,
                                      &item,
                                      deviceName,
                                      IDS_FREE_USB2_PORTS,
                                      IDS_FREE_USB2_PORTS_RECOMMENDATION,
                                      Usb20ControllersOnly,
                                      UsbItemActionFindUsb2xHubsWithFreePorts::IsValid,
                                      UsbItemActionFindUsb2xHubsWithFreePorts::IsExpanded);
            }


            USBTRACE((_T("Didn't find free ports on usb 2.0 hubs\n")));

            //
            // Find all usb 2.0 hubs that have usb 1.0 devices attached.
            // These devices can be switched with the offending device.
            //
            USBTRACE((_T("Looking for usb 1.0 devices on usb 2.0 hubs\n")));
            UsbItemActionFindUsb1xDevicesOnUsb2xHubs find2(rootItem);
            rootItem->Walk(find2);
            UsbItemList& devices2 = find2.GetDevices();
            if (!devices2.empty()) {
                USBTRACE((_T("Found usb 1.0 devices on usb 2.0 hubs\n")));
                return AssembleDialog(rootItem->child,
                                      &item,
                                      deviceName,
                                      IDS_USB1_DEVICE_IN_USB2_HUB,
                                      IDS_USB1_DEVICE_IN_USB2_HUB_RECOMMENDATION,
                                      Usb20ControllersOnly,
                                      UsbItemActionFindUsb1xDevicesOnUsb2xHubs::IsValid,
                                      UsbItemActionFindUsb1xDevicesOnUsb2xHubs::IsExpanded);
            }
            USBTRACE((_T("Didn't find usb 1.0 devices on usb 2.0 hubs\n")));

        }
    }
    {
        //
        // Check to see if there are ANY usb 2.0 hubs on the machine
        //
        USBTRACE((_T("Looking for ANY usb 2.0 ports\n")));
        UsbItemActionFindUsb2xHubs find1(realItem);
        realItem->Walk(find1);
        UsbItemList& devices = find1.GetHubs();
        if(devices.empty()) {
            USBTRACE((_T("There aren't any usb 2.0 ports on this machine\n")));
            return AssembleDialog(realItem->child,
                                  &item,
                                  deviceName,
                                  IDS_NO_USB2_HUBS,
                                  IDS_NO_USB2_HUBS_RECOMMENDATION,
                                  TrueAlways,
                                  UsbItemActionFindUsb2xHubs::IsValid,
                                  UsbItemActionFindUsb2xHubs::IsExpanded);
        } else {
            //
            // Find all unknown devices attached to usb 2.0 hubs.
            // These devices can be switched with the offending device.
            //
            USBTRACE((_T("Looking for unknown devices attached to usb 2.0 hubs\n")));
            UsbItemActionFindUnknownDevicesOnUsb2xHubs find2(realItem);
            realItem->Walk(find2);
            UsbItemList& devices2 = find2.GetDevices();
            if (!devices2.empty()) {
                USBTRACE((_T("Found unknown devices attached to usb 2.0 hubs\n")));
                return AssembleDialog(realItem->child,
                                  &item,
                                  deviceName,
                                  IDS_UNKNOWN_DEVICE_IN_USB2_HUB,
                                  IDS_UNKNOWN_DEVICE_IN_USB2_HUB_RECOMMENDATION,
                                  Usb20ControllersOnly,
                                  UsbItemActionFindUnknownDevicesOnUsb2xHubs::IsValid,
                                  UsbItemActionFindUnknownDevicesOnUsb2xHubs::IsExpanded);
            } else {
                USBTRACE((_T("Didn't find unknown devices on usb 2.0 hubs\n")));
                //
                // Last resort here.  Highlight usb 2.0 hubs and tell the user
                // to put it there if they want the device to work.
                //
                USBTRACE((_T("Last resort. Highlight usb 2.0 hubs\n")));
                return AssembleDialog(realItem->child,
                                      &item,
                                      deviceName,
                                      IDS_USB2_DEVICE_IN_USB2_HUB,
                                      IDS_USB2_DEVICE_IN_USB2_HUB_RECOMMENDATION,
                                      Usb20ControllersOnly,
                                      UsbItemActionFindUsb2xHubs::IsValid,
                                      UsbItemActionFindUsb2xHubs::IsValid);
            }
        }
    }
    USBTRACE((_T("Didn't find usb 2.0 devices on usb 2.0 hubs\n")));
    return TRUE;
LegacyRefreshError:
    USBTRACE((_T("LegacyRefreshError\n")));

    if (acquireInfo) {
        LocalFree(acquireInfo);
    }
    return FALSE;
}

BOOL
UsbLegacyPopup::AssembleDialog(UsbItem*              RootItem,
                               LPTV_INSERTSTRUCT     LvItem,
                               LPCTSTR               DeviceName,
                               UINT                  Explanation,
                               UINT                  Recommendation,
                               PUsbItemActionIsValid IsValid,
                               PUsbItemActionIsValid IsBold,
                               PUsbItemActionIsValid IsExpanded)
{
    HTREEITEM hDevice;
    TCHAR buf[MAX_PATH], formatString[MAX_PATH];

    LoadString(gHInst,
               Recommendation,
               formatString,
               MAX_PATH);
    UsbSprintf(buf, formatString, DeviceName);
    if (!SetTextItem(hWnd, IDC_LEGACY_RECOMMENDATION, buf) ||
        !SetTextItem(hWnd, IDC_LEGACY_EXPLANATION, Explanation)) {
        return FALSE;
    }

    if (!InsertTreeItem(hTreeDevices,
                        RootItem,
                        NULL,
                        LvItem,
                        IsValid,
                        IsBold,
                        IsExpanded)) {
        return FALSE;
    }
    if (NULL != (hDevice = TreeView_FindItem(hTreeDevices,
                                             DeviceName))) {
        return TreeView_SelectItem (hTreeDevices, hDevice);
    }
    return TRUE;
}

USBINT_PTR
UsbLegacyPopup::OnTimer()
{

    if (deviceState == DeviceAttachedError) {
        if (S_FALSE == QueryContinue()) {
            // Update the device state
            deviceState = DeviceDetachedError;

        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\proppage.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       PROPPAGE.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _USBPROPERTYPAGE_H
#define _USBPROPERTYPAGE_H

#define USBWM_NOTIFYREFRESH                (WM_USER + 501)

#ifndef WINNT
#define HELPFILE "windows.hlp"
#else
#define HELPFILE "devmgr.hlp"
#endif //WINNT

#include "UsbItem.h"
#include "debug.h"

extern HINSTANCE gHInst;

#define IDH_NOHELP (DWORD(-1))	

class UsbPropertyPage {
public:
    UsbPropertyPage(HDEVINFO         DeviceInfoSet,
                    PSP_DEVINFO_DATA DeviceInfoData); 
    UsbPropertyPage(UsbItem *);
    UsbPropertyPage(HWND, LPCSTR);
    virtual ~UsbPropertyPage()
        { if (rootItem) { DeleteChunk(rootItem); delete rootItem; } }

    HPROPSHEETPAGE Create();
     
    static void SetHandle(HANDLE HInst) {if (!hInst) hInst = HInst;};

    static void DisplayPPSelectedListItem(HWND main, HWND hList);
    static void DisplayPPSelectedTreeItem(HWND main, HWND hList);

    VOID CreateAsChild(HWND hWndParent, HWND hCreateOn, UsbItem *item);
    VOID CreateIndependent();
    BOOL DestroyChild();
    BOOL SizeWindow(int X, int Y, int W, int H) {
        return hwnd ? MoveWindow(hwnd, X, Y, W, H, TRUE) : FALSE; }

protected:
    const DWORD *HelpIds;    
    static USBINT_PTR APIENTRY StaticDialogProc(IN HWND   hDlg,
                                             IN UINT   uMessage,
                                             IN WPARAM wParam,
                                             IN LPARAM lParam);
    static USBINT_PTR APIENTRY AppletDialogProc(IN HWND   hDlg,
                                             IN UINT   uMessage,
                                             IN WPARAM wParam,
                                             IN LPARAM lParam);

    static UINT CALLBACK StaticDialogCallback(HWND            Hwnd,
                                       UINT            Msg,
                                       LPPROPSHEETPAGE Page);

    virtual USBINT_PTR APIENTRY ActualDialogProc(IN HWND   hDlg,
                                           IN UINT   uMessage,
                                           IN WPARAM wParam,
                                           IN LPARAM lParam)
    { return FALSE; } // DefDlgProc(hDlg, uMessage, wParam, lParam); }

    virtual BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl) {return 1;}
    virtual BOOL OnInitDialog() =0;
    virtual BOOL OnNotify(HWND hDlg, int nID, LPNMHDR pnmh);
    BOOL OnContextMenu(HWND HwndControl, WORD Xpos, WORD Ypos);
    void OnHelp(HWND ParentHwnd, LPHELPINFO HelpInfo);
    static void ShowPropertyPage(HWND parent, UsbItem *usbItem);
    
    BOOL GetDeviceName();
    
    static HANDLE           hInst;
    String                  deviceName;
    HWND                    hwnd;
    HWND                    hWndParent;
    UINT                    dlgResource;
                                   
    PROPSHEETPAGE           psp;
    HDEVINFO                deviceInfoSet;
    PSP_DEVINFO_DATA        deviceInfoData;
    UsbImageList            imageList;
    
    UsbItem                 *rootItem;
    
    //
    // This should be null if using as a proppage. This is used when using this
    // class as a child window in the usbapplet class.
    //
    UsbItem *preItem;
};

class GenericPage : public UsbPropertyPage {
public:
    GenericPage(UsbItem *item) : UsbPropertyPage(item) {Initialize();}
    GenericPage(HWND HWndParent, LPCSTR DevName) : UsbPropertyPage(HWndParent, DevName) {Initialize();}
    GenericPage(HDEVINFO         DeviceInfoSet,        
                PSP_DEVINFO_DATA DeviceInfoData) :
        UsbPropertyPage(DeviceInfoSet, DeviceInfoData) {Initialize();}
    
protected:
    void Refresh();
    BOOL OnInitDialog();
    VOID Initialize();
    UsbItem *rootItem;
};

class RootPage : public UsbPropertyPage {
public:
    RootPage(UsbItem *item) : UsbPropertyPage(item) {Initialize();}
    
protected:
    void Refresh();
    BOOL OnInitDialog();
    VOID Initialize();
    BOOL ErrorCheckingEnabled;
    BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl) ;
};

#endif // _USBPROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\proppage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       PROPPAGE.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "BandPage.h"
#include "PowrPage.h"
#include "debug.h"

HANDLE UsbPropertyPage::hInst = (HANDLE) 0;

UsbPropertyPage::UsbPropertyPage(HDEVINFO         DeviceInfoSet,
                                 PSP_DEVINFO_DATA DeviceInfoData) :
    deviceInfoSet(DeviceInfoSet), deviceInfoData(DeviceInfoData), imageList()
{
    preItem = 0;
    hWndParent = NULL;
    rootItem = NULL;
}

UsbPropertyPage::UsbPropertyPage(HWND HWndParent, LPCSTR DeviceName) :
    deviceInfoSet(0), deviceInfoData(0), imageList()
{
    WCHAR       realName[MAX_PATH];

    if (MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            DeviceName,
                            -1,
                            realName,
                            MAX_PATH)) {
        deviceName = realName;
    }                

    preItem = 0;
    hWndParent = HWndParent;
    rootItem = NULL;
}

UsbPropertyPage::UsbPropertyPage(UsbItem *item) :
    deviceInfoSet(0), deviceInfoData(0), imageList()
{
    preItem = item;
    hWndParent = NULL;
    rootItem = NULL;
}

HPROPSHEETPAGE UsbPropertyPage::Create()
{
    //
    // Add the Port Settings property page
    //
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    psp.hInstance   = (HINSTANCE) hInst;
    psp.pszTemplate = MAKEINTRESOURCE(dlgResource);

    //
    // following points to the dlg window proc
    //
    psp.pfnDlgProc = StaticDialogProc;
    psp.lParam     = (LPARAM) this;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    psp.pfnCallback = StaticDialogCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(&psp);
}

UINT CALLBACK
UsbPropertyPage::StaticDialogCallback(HWND            Hwnd,
                                      UINT            Msg,
                                      LPPROPSHEETPAGE Page)
{
    UsbPropertyPage *that;
    that = (UsbPropertyPage*) Page->lParam;

    switch (Msg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page
    case PSPCB_RELEASE:
        DeleteChunk(that);
        delete that; 
        CheckMemory();

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

BOOL
UsbPropertyPage::OnContextMenu(HWND HwndControl,
                               WORD Xpos,
                               WORD Ypos)
{
    WinHelp(HwndControl,
               TEXT(HELPFILE),
               HELP_CONTEXTMENU,
               (USBULONG_PTR) HelpIds);

    return FALSE;
}

void
UsbPropertyPage::OnHelp(HWND       ParentHwnd,
                        LPHELPINFO HelpInfo)
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                   TEXT(HELPFILE),
                   HELP_WM_HELP, 
                   (USBULONG_PTR) HelpIds);
    }
}

USBINT_PTR APIENTRY UsbPropertyPage::StaticDialogProc(IN HWND   hDlg,
                                                   IN UINT   uMessage,
                                                   IN WPARAM wParam,
                                                   IN LPARAM lParam)
{
    UsbPropertyPage *that;

    that = (UsbPropertyPage *) UsbGetWindowLongPtr(hDlg, USBDWLP_USER);

    if (!that && uMessage != WM_INITDIALOG) 
        return FALSE; //DefDlgProc(hDlg, uMessage, wParam, lParam);

    switch (uMessage) {

    case WM_COMMAND:
        return that->OnCommand(HIWORD(wParam),
                               LOWORD(wParam),
                               (HWND) lParam);     

    case WM_INITDIALOG:
        that = (UsbPropertyPage *) ((LPPROPSHEETPAGE)lParam)->lParam;
        UsbSetWindowLongPtr(hDlg, USBDWLP_USER, (USBLONG_PTR) that);
        that->hwnd = hDlg;

        return that->OnInitDialog();

    case WM_NOTIFY:
        return that->OnNotify(hDlg, (int) wParam, (LPNMHDR) lParam); 

    case WM_CONTEXTMENU:
        return that->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP: 
        that->OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    default:
        break;
    }

    return that->ActualDialogProc(hDlg, uMessage, wParam, lParam);
}


BOOL UsbPropertyPage::OnNotify(HWND hDlg, int nID, LPNMHDR pnmh)
{
    switch (pnmh->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Do what ever action is necessary
        //
        UsbSetWindowLongPtr(hwnd, USBDWLP_MSGRESULT, PSNRET_NOERROR);
            
        return TRUE;

    default:
        break;
    }

    return TRUE;
}

BOOL
UsbPropertyPage::GetDeviceName()
{
    HKEY  hDeviceKey;
    DWORD dwBufferSize, dwError;
    WCHAR szBuffer[MAX_PATH];

    //
    // Open the device key for the source device instance, and retrieve its
    // "SymbolicName" value.
    //
    hDeviceKey = SetupDiOpenDevRegKey(deviceInfoSet,
                                      deviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_ALL_ACCESS);

    if (INVALID_HANDLE_VALUE == hDeviceKey) {
        goto GetDeviceNameError;
    }

    dwBufferSize = sizeof(szBuffer);
    dwError = RegQueryValueEx(hDeviceKey,
                              _T("SymbolicName"),
                              NULL,
                              NULL,
                              (PBYTE)szBuffer,
                              &dwBufferSize);

    if(ERROR_SUCCESS != dwError) {
        goto GetDeviceNameError;
    }
    deviceName = szBuffer;
    RegCloseKey(hDeviceKey);
    return TRUE;
GetDeviceNameError:
    if (hDeviceKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hDeviceKey);
    }
    return FALSE;
}

void
UsbPropertyPage::DisplayPPSelectedListItem(HWND main, HWND hList)
{
    LVITEM item;
    BOOL b;
    int itemIndex = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

    ZeroMemory(&item, sizeof(LVITEM));
    item.mask = LVIF_PARAM;
    item.iItem = itemIndex;
    b = ListView_GetItem(hList, &item);
    
    if (!b) {
        return;
    }
    ShowPropertyPage(main, (UsbItem*) item.lParam);
}

void
UsbPropertyPage::DisplayPPSelectedTreeItem(HWND main, HWND hList)
{
    TVITEM item;
    BOOL b;

    ZeroMemory(&item, sizeof(TVITEM));

    if (NULL == (item.hItem = TreeView_GetSelection(hList))) {
        return;
    }
    item.mask = TVIF_PARAM;

    b = TreeView_GetItem(hList, &item);
    if (!b) {
        return;
    }
    ShowPropertyPage(main, (UsbItem*) item.lParam);
}

#ifdef WINNT
typedef USBINT_PTR (FAR *DeviceProp)(HWND, LPCTSTR, LPCTSTR, BOOL);

void 
UsbPropertyPage::ShowPropertyPage(HWND parent, UsbItem *usbItem) 
{
    HINSTANCE h;
    DeviceProp p;
    TCHAR buf[MAX_PATH];

    if (usbItem != NULL) {
        CM_Get_Device_ID(usbItem->configInfo->devInst,
                         buf,
                         MAX_PATH,
                         NULL);
        h = LoadLibrary(TEXT("devmgr.dll"));
        if (h) {
            p = (DeviceProp) GetProcAddress(h, "DevicePropertiesW");
            if (p) {
                p (parent, NULL, buf, FALSE);
            }
            FreeLibrary(h);
        }
    }
}
#else
void 
UsbPropertyPage::ShowPropertyPage(HWND HWndParent, UsbItem *usbItem) 
{
    CHAR        buf[MAX_PATH];
    ULONG       len = MAX_PATH;
    CONFIGRET   cfgRet;
    HKEY        hDevKey;

    if (usbItem != NULL) {
        if (CR_SUCCESS != (cfgRet = 
                           CM_Open_DevNode_Key(usbItem->configInfo->devInst,
                                                KEY_QUERY_VALUE,
                                                CM_REGISTRY_HARDWARE,
                                                RegDisposition_OpenExisting,
                                                &hDevKey,
                                                0))) {
            return;
        }
        len = MAX_PATH;
        if (ERROR_SUCCESS != RegQueryValueEx(hDevKey,
                                             _T("SymbolicName"),
                                             NULL,   
                                             NULL,   
                                             (LPBYTE) &buf,
                                             &len)) {
            RegCloseKey(hDevKey);
            return;
        }

        if (usbItem->itemType == UsbItem::UsbItemType::HCD) {
            BandwidthPage   *band;
            band = new BandwidthPage(HWndParent, buf);
            AddChunk(band);
            if (!band) {
                return;
            }
            band->CreateIndependent();
            DeleteChunk(band);
            delete band;
        } else if (usbItem->itemType == UsbItem::UsbItemType::RootHub ||
                   usbItem->itemType == UsbItem::UsbItemType::Hub) {
            PowerPage   *power;
            power = new PowerPage(HWndParent, buf);
            AddChunk(power);
            if (!power) {
                return;
            }
            power->CreateIndependent();
            DeleteChunk(power);
            delete power;
        } /*else {
            GenericPage   *generic;
            generic = new GenericPage(HWndParent, buf);
            AddChunk(generic);
            if (!generic) {
                return;
            }
            generic->CreateIndependent();
            DeleteChunk(generic);
            delete generic;
        }   */
    }
}
#endif

VOID
UsbPropertyPage::CreateAsChild(HWND HWndParent,
                         HWND hCreateOn,
                         UsbItem *item)
{
    RECT rc;
    POINT *p = (POINT*) &rc;
    GetWindowRect(hCreateOn, &rc);
    ScreenToClient(HWndParent, p++); 
    ScreenToClient(HWndParent, p);
    if (NULL != (hwnd = CreateDialogParam(gHInst, 
                                          MAKEINTRESOURCE(dlgResource),
                                          HWndParent,
                                          AppletDialogProc,
                                          (LPARAM) this))) {
        SetWindowPos(hwnd, 
                     hCreateOn,
                     rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
                     SWP_SHOWWINDOW);
    }
}

VOID
UsbPropertyPage::CreateIndependent()
{
    int error;

    if (-1 == DialogBoxParam(gHInst,                 
                                MAKEINTRESOURCE(dlgResource),
                                hWndParent,
                                AppletDialogProc,
                                (LPARAM) this)) {
        error = GetLastError();
    }
}

BOOL UsbPropertyPage::DestroyChild()
{
    if (hwnd) {
        return DestroyWindow(hwnd);
    } 
    //
    // If there's nothing to destroy, then in a way we've been successful
    //
    return TRUE;
}

USBINT_PTR APIENTRY UsbPropertyPage::AppletDialogProc(IN HWND   hDlg,
                                                   IN UINT   uMessage,
                                                   IN WPARAM wParam,
                                                   IN LPARAM lParam)
{
    UsbPropertyPage *that;

    switch (uMessage) {

    case WM_INITDIALOG:
        that = (UsbPropertyPage *) lParam;
        UsbSetWindowLongPtr(hDlg, USBDWLP_USER, (USBLONG_PTR) that);
        that->hwnd = hDlg;

        return that->OnInitDialog();
    default:
        break;
    }
    return StaticDialogProc(hDlg, uMessage, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbapp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBAPP.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "usbitem.h"
#include <windowsx.h>
#include "proppage.h"

extern HINSTANCE gHInst;

class UsbApplet
{
public:
    UsbApplet() : hMainWnd(0), hTreeDevices(0), barLocation(0), 
        bButtonDown(FALSE) {propPage=NULL;}
    //: bandpage(0), powrpage(0) {;}
    ~UsbApplet() {;}

    BOOL CustomDialog();

    static BOOL IsValid(UsbItem *Item);
    static BOOL IsBold(UsbItem *Item);
    static BOOL IsExpanded(UsbItem *Item);
    VOID OnClose (HWND hWnd);

protected:
    static USBINT_PTR APIENTRY StaticDialogProc(IN HWND   hDlg,
                                             IN UINT   uMessage,
                                             IN WPARAM wParam,
                                             IN LPARAM lParam);

    static UINT CALLBACK StaticDialogCallback(HWND            Hwnd,
                                       UINT            Msg,
                                       LPPROPSHEETPAGE Page);

    USBINT_PTR APIENTRY ActualDialogProc(IN HWND   hDlg,
                                           IN UINT   uMessage,
                                           IN WPARAM wParam,
                                           IN LPARAM lParam)
    { return FALSE; } // DefDlgProc(hDlg, uMessage, wParam, lParam); }

    BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl);
    BOOL OnInitDialog(HWND HWnd);
    BOOL Refresh();
    BOOL OnContextMenu(HWND HwndControl, WORD Xpos, WORD Ypos);
    void OnHelp(HWND ParentHwnd, LPHELPINFO HelpInfo);
    VOID OnSize (HWND hWnd, UINT state, int  cx, int  cy);
    VOID OnMouseMove (HWND hWnd, int  x, int  y, UINT keyFlags);
    VOID OnLButtonDown (HWND hWnd, BOOL fDoubleClick, int  x, int  y, UINT keyFlags);
    VOID OnLButtonUp (HWND hWnd, int  x, int  y, UINT keyFlags);
    LRESULT OnNotify (HWND hWnd, int DlgItem, LPNMHDR lpNMHdr);
//    BOOL OnDeviceChange (HWND hwnd, UINT uEvent, DWORD dwEventData);
    LRESULT OnDeviceChange(HWND hWnd, UINT wParam, DWORD lParam);
    BOOL RegisterForDeviceNotification(HWND hWnd);

    VOID UpdateEditControl(UsbItem *usbItem);
    VOID ResizeWindows (HWND hWnd, BOOL bSizeBar, int BarLocation);
    HTREEITEM InsertRoot(LPTV_INSERTSTRUCT item, UsbItem *firstController);

//    BandwidthPage *bandPage;
//    PowerPage *powerPage;
    
    UsbPropertyPage *propPage;

    HWND            hMainWnd;
    HWND            hTreeDevices;
    HWND            hEditControl;
    HCURSOR         hSplitCursor;
    BOOL            bButtonDown;
    int             barLocation;
    HDEVNOTIFY      hDevNotify;

    UsbImageList    ImageList;
    UsbItem         *rootItem;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbinfo.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBINFO.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "UsbItem.h"
#include "debug.h"

UsbConfigInfo::UsbConfigInfo() : devInst(0), usbFailure(0), status(0),
    problemNumber(0)
{
}

UsbConfigInfo::UsbConfigInfo(
    const UsbString& Desc, const UsbString& Class, DWORD Failure,
    ULONG Status, ULONG Problem) : devInst(0), deviceDesc(Desc),
    deviceClass(Class), usbFailure(Failure), status(Status),
    problemNumber(Problem)
{
}

UsbDeviceInfo::UsbDeviceInfo() : connectionInfo(0),
    configDesc(0), configDescReq(0), isHub(FALSE)
{
    ZeroMemory(&hubInfo, sizeof(USB_NODE_INFORMATION));
}

/*UsbDeviceInfo::UsbDeviceInfo(const UsbDeviceInfo& UDI) : hubName(UDI.hubName),
    isHub(UDI.isHub), hubInfo(UDI.hubInfo), configDesc(UDI.configDesc),
{
    if (UDI.connectionInfo) {
        char *tmp = new char[CONNECTION_INFO_SIZE];
        AddChunk(tmp);
        connectionInfo  = (PUSB_NODE_CONNECTION_INFORMATION) tmp;
        memcpy(connectionInfo, UDI.connectionInfo, CONNECTION_INFO_SIZE);
    }
    else
        connectionInfo = 0;
} */

UsbDeviceInfo::~UsbDeviceInfo()
{
    if (configDesc) {
        LocalFree(configDescReq);
    }
    if (connectionInfo) {
        LocalFree(connectionInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by usbui.rc
//
#define IDS_POWER_PORTS                 1
#define IDS_POWER_DEVICE                2
#define IDS_POWER_NOTIFICATION          3
#define IDS_POWER_BOLD                  4
#define IDS_POWER_INITIAL               5
#define IDS_POWER_RECOMMENDATION_DEVICE 6
#define IDS_POWER_RECOMMENDATION_PORTS  7
#define IDS_POWER_SELF                  8
#define IDS_POWER_BUS                   9
#define IDS_POWER_HIGHDEVICE            10
#define IDS_POWER_RECHIGHDEVICE         11
#define IDS_POWER_CONSUMPTION           12
#define IDS_POWER_CONSUMED              13
#define IDS_PORTS_AVAILABLE             14
#define IDS_TOTAL_POWER                 15
#define IDS_POWER_REQUIRED              16
#define IDS_POWER_MALFUNCTIONING        17
#define IDS_MY_COMPUTER                 18
#define IDS_POWER_NOTSOLVED             20
#define IDS_POWER_SOLVED                21
#define IDS_OVERCURRENT_NOTIFICATION    30
#define IDS_OVERCURRENT_COURSE          31
#define IDS_OVERCURRENT_RECOMMENDATION  32
#define IDS_OVERCURRENT_NOTIFICATION_UNKNOWN 33
#define IDS_CURRENT_LIMIT_EXCEEDED      34
#define IDS_RESET_FAILED                35
#define IDS_OVERCURRENT_INITIAL         36
#define IDS_OVERCURRENT_INITIAL_UNKNOWN 37
#define IDS_ENUMFAIL_NOTIFICATION       40
#define IDS_ENUMFAIL_COURSE             41
#define IDS_ENUMFAIL_RECOMMENDATION     42
#define IDS_ENUMERATION_FAILURE         43
#define IDS_ENUMFAIL_INITIAL            44
#define IDS_BANDWIDTH_NOTIFICATION      50
#define IDS_BANDWIDTH_EXPLANATION       51
#define IDS_BANDWIDTH_INITIAL           52
#define IDS_BANDWIDTH_RECOMMENDATION    53
#define IDS_BANDWIDTH_PAGEHELP          54
#define IDS_BANDWIDTH_PAGEHELP2         55
#define IDS_BW_EXPLANATION              56
#define IDS_BW_RECOMMENDATION           57
#define IDS_BANDWIDTH_CONSUMED          58
#define IDS_CONTROLLER_BW_EXCEEDED      59
#define IDS_CURRENT_BANDWIDTH           60
#define IDS_BANDWIDTH_CONTROLLER_RSRVD  61
#define IDS_USB                         71
#define IDS_DEVICE_DESCRIPTION          72
#define IDS_CONTROLLER                  73
#define IDS_DEVICE                      74
#define IDS_POWER_EXCEEDED              75
#define IDS_USB_ERROR                   76
#define IDS_UNKNOWN                     77
#define IDS_UNUSEDPORT                  78
#define IDS_UNKNOWNDEVICE               79
#define IDS_UNKNOWNHUB                  80
#define IDS_UNKNOWNCONTROLLER           81
#define IDS_LEGACY_INITIAL              82
#define IDS_USB2_DEVICE_IN_USB1_HUB     83
#define IDS_LEGACY_NOTIFICATION         84
#define IDS_LEGACY_SOLVED               85
#define IDS_USB1_DEVICE_IN_USB2_HUB     87
#define IDS_USB1_DEVICE_IN_USB2_HUB_RECOMMENDATION 88
#define IDS_FREE_USB2_PORTS             89
#define IDS_FREE_USB2_PORTS_RECOMMENDATION 90
#define IDS_UNKNOWN_DEVICE_IN_USB2_HUB  91
#define IDS_UNKNOWN_DEVICE_IN_USB2_HUB_RECOMMENDATION 92
#define IDS_NO_USB2_HUBS                93
#define IDS_NO_USB2_HUBS_RECOMMENDATION 94
#define IDS_USB2_DEVICE_IN_USB2_HUB     95
#define IDS_USB2_DEVICE_IN_USB2_HUB_RECOMMENDATION 96
#define IDS_UNKNOWN20HUB                97
#define IDS_UNUSEDMINIPORT              98
#define IDS_NESTED_HUB_INITIAL          1100
#define IDS_HUB_NESTED_TOO_DEEPLY       1101
#define IDS_NESTED_INITIAL              1102
#define IDS_NESTED_NOTIFICATION         1103
#define IDS_NESTED_SOLVED               1104
#define IDS_NESTED                      1105
#define IDS_DEVICE_IN_POWERED_HUB       1106
#define IDS_DEVICE_IN_POWERED_HUB_RECOMMENDATION 1107
#define IDS_FREE_PORTS                  1108
#define IDS_FREE_PORTS_RECOMMENDATION   1109
#define IDS_BUS_POWERED_HUB_IN_POWERED_HUB 1110
#define IDS_BUS_POWERED_HUB_IN_POWERED_HUB_RECOMMENDATION 1111
#define IDS_FREE_POWERED_PORTS          1112
#define IDS_PORTS                       1113
#define IDD_USB_DEVICE_PROPERTIES       101
#define IDD_INSUFFICIENT_POWER          102
#define IDB_BITMAP1                     103
#define IDD_INSUFFICIENT_BANDWIDTH      104
#define IDD_CPL_USB                     105
#define IDC_SPLIT                       107
#define IDD_GENERIC_DEVICE              108
#define IDD_ROOT_PAGE                   109
#define IDD_MODERN_DEVICE_IN_LEGACY_HUB 110
#define IDI_USB                         111
#define IDI_INFRARED                    112
#define IDI_MODEM                       113
#define IDI_FLOPPY                      114
#define IDI_CDROM                       115
#define IDI_IMAGE                       116
#define IDI_MEDIA                       117
#define IDD_BANDWIDTH                   130
#define IDD_POWER                       131
#define IDD_NESTED_HUB                  132
#define IDC_TREE_HUBS                   301
#define IDC_BANDWIDTH_BAR               1000
#define IDC_LIST_DEVICES                1001
#define IDC_CHECK2                      1001
#define IDC_LIST_OTHER_DEVICES          1002
#define IDC_CHECK3                      1002
#define IDC_BANDWIDTH_RECOMMENDATION    1003
#define IDC_CHECK4                      1003
#define IDC_REFRESH                     1004
#define IDC_CHECK5                      1004
#define IDC_DESCRIPTION                 1005
#define IDC_DEVICE_CLASS                1005
#define IDC_POWER_REQUIRED              1006
#define IDC_POWER_AVAIL                 1007
#define IDC_BANDWIDTH                   1007
#define IDC_POWER_BAR                   1008
#define IDC_LIST_CONTROLLERS            1008
#define IDC_SELF_POWER                  1009
#define IDC_PROTECTION                  1010
#define IDC_DEVICE                      1012
#define IDC_POWER_DEVICE                1012
#define IDC_BANDWIDTH_EXPLANATION       1012
#define IDC_ICON_BANDWIDTH              1013
#define IDC_NOTIFICATION                1014
#define IDC_POWER_NOTIFICATION          1014
#define IDC_BANDWIDTH_NOTIFICATION      1014
#define IDC_RECOMMENDATION              1015
#define IDC_POWER_RECOMMENDATION        1015
#define IDC_EXPLANATION                 1016
#define IDC_ICON_POWER                  1016
#define IDC_BANDWIDTH_LINE2             1017
#define IDC_POWER_EXPLANATION           1018
#define IDC_BANDWIDTH_LINE              1019
#define IDC_TREE_USB                    1020
#define IDC_EDIT1                       1026
#define IDC_BAND_TEXT                   1027
#define IDC_BAND_TEXT2                  1028
#define IDC_GENERIC_POWER               1029
#define IDC_GENERIC_BANDWIDTH           1030
#define IDC_ERROR_DETECT_DISABLE        1031
#define IDC_BUTTON1                     1032
#define IDC_BW_REFRESH                  1032
#define IDC_BANDWIDTH_CLOSE             1032
#define IDC_POWER_CLOSE                 1032
#define IDC_BANDWIDTH_PROPERTIES        1033
#define IDC_DISABLE_ERROR_DETECTION     1034
#define IDC_RESET_PORT                  1035
#define IDC_LEGACY_NOTIFICATION         1036
#define IDC_LEGACY_RECOMMENDATION       1037
#define IDC_LEGACY_EXPLANATION          1038
#define IDC_NESTED_NOTIFICATION         1039
#define IDC_NESTED_EXPLANATION          1040
#define IDC_NESTED_RECOMMENDATION       1041
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbitem.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBITEM.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _USBITEM_H
#define _USBITEM_H

#include <windows.h>
//#include <windowsx.h>
#include <objbase.h>
#include <setupapi.h>

#include <devioctl.h>
#pragma warning(disable : 4200)
#include <usbioctl.h>
#include <usb.h>
#include <wdmguid.h>

#include <tchar.h>

#include "str.h"
#include "vec.h"

extern "C" {
#include <cfgmgr32.h>
}

#include <stdio.h> // Used for sprintf

HANDLE
UsbCreateFileA(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile);
    
#ifndef WINNT

#define USBHID TEXT("HID")
#define MyComputerClass TEXT("System")
#define UsbSprintf sprintf
#define UsbCreateFile UsbCreateFileA
#define USBPROC DLGPROC

// Win64 stuff
#define UsbSetWindowLongPtr SetWindowLong
#define UsbGetWindowLongPtr GetWindowLong
#define USBDWLP_MSGRESULT DWL_MSGRESULT
#define USBDWLP_USER DWL_USER
#define USBULONG_PTR ULONG
#define USBLONG_PTR LONG
#define USBINT_PTR BOOL

#else

#define USBHID TEXT("HIDClass")
#define MyComputerClass TEXT("Computer")
#define UsbSprintf wsprintf
#define UsbCreateFile CreateFile
#define USBPROC WNDPROC

// Win64 stuff
#define UsbSetWindowLongPtr SetWindowLongPtr
#define UsbGetWindowLongPtr GetWindowLongPtr
#define USBDWLP_MSGRESULT DWLP_MSGRESULT
#define USBDWLP_USER DWLP_USER
#define USBULONG_PTR ULONG_PTR
#define USBLONG_PTR LONG_PTR
#define USBINT_PTR INT_PTR

#endif

typedef _Str <WCHAR> String;
typedef _Str <TCHAR> UsbString;

class UsbConfigInfo {
public:
    UsbConfigInfo();
    UsbConfigInfo(const UsbString& Desc, const UsbString& Class, DWORD Failure =0, ULONG Status =0, ULONG Problem =0);

    UsbString   deviceDesc, deviceClass;
    String      driverName;
    DEVINST     devInst;
    DWORD       usbFailure;
    ULONG       status;
    ULONG       problemNumber;
};

//#define CONNECTION_INFO_SIZE (sizeof(USB_NODE_CONNECTION_INFORMATION) + sizeof(USB_PIPE_INFO) * 16)

class UsbDeviceInfo {
public:
    UsbDeviceInfo();
//    UsbDeviceInfo(const UsbDeviceInfo& UDI);
    ~UsbDeviceInfo();

    String                              hubName;        // guid if a hub
    BOOL                                isHub;

    USB_NODE_INFORMATION                hubInfo;        // filled if a hub
    PUSB_NODE_CONNECTION_INFORMATION    connectionInfo; // NULL if root HUB
    PUSB_CONFIGURATION_DESCRIPTOR       configDesc;
    PUSB_DESCRIPTOR_REQUEST             configDescReq;
};

typedef struct
{
    LPTSTR  szClassName;
    INT     imageIndex;
} IconItem;

typedef _Vec<IconItem> IconTable;

class UsbImageList {
private:
    IconTable iconTable;
    SP_CLASSIMAGELIST_DATA ClassImageList;
    BOOL GetClassImageList();
public:
    UsbImageList() : iconTable() { GetClassImageList(); }
    ~UsbImageList() { SetupDiDestroyClassImageList(&ClassImageList); }
    HIMAGELIST ImageList() { return ClassImageList.ImageList; }
    BOOL GetClassImageIndex(LPCTSTR DeviceClass, PINT ImageIndex);
};

class UsbItem;

typedef 
BOOL
(*PUsbItemActionIsValid) (
    UsbItem *Item);

class UsbItem {
public:

    UsbItem() : configInfo(0), deviceInfo(0), bandwidth(0), itemType(None), 
        imageIndex(0) { UnusedPort=FALSE; child=0; parent=0; sibling=0; 
#ifdef HUB_CAPS
         ZeroMemory(&hubCaps, sizeof(USB_HUB_CAPABILITIES));
#endif
         }
//    UsbItem(const UsbItem& Other, UsbItem *Parent);
    ~UsbItem();

    enum UsbItemType {
        Root = 1,
        HCD,
        RootHub,
        Hub,
        Device,
        Empty,
        None
    };

    struct UsbItemAction {
        virtual BOOL operator()(UsbItem* item) {return TRUE;}
    };

    BOOL IsUnusedPort() { return UnusedPort; }
    UsbItem* AddLeaf(UsbItem* Parent, UsbDeviceInfo* DeviceInfo,
                     UsbItemType Type, UsbConfigInfo* ConfigInfo, 
                     UsbImageList* ImageList);

    BOOL EnumerateAll(UsbImageList* ClassImageList);
    BOOL EnumerateController(UsbItem *Parent,
                             const String &RootName, 
                             UsbImageList* ClassImageList, 
                             DEVINST DevInst);
    BOOL EnumerateHub(const String &HubName,
                      UsbImageList* ClassImageList,
                      DEVINST DevInst,
                      UsbItem *Parent,
                      UsbItem::UsbItemType itemType);
//    BOOL EnumerateDevice(DEVINST DevInst);

    BOOL ComputeBandwidth();
    BOOL ComputePower();
    UINT TotalTreeBandwidth();
    ULONG PortPower();
    ULONG NumPorts();
    ULONG NumChildren();
    ULONG UsbVersion();
    ULONG DistanceFromController() { return IsController() ? 0 : 
        (parent ? 1+parent->DistanceFromController() : 0); }
    BOOL IsHub();
    BOOL IsController();
    BOOL Walk(UsbItemAction& Action);
    BOOL ShallowWalk(UsbItemAction& Action);
    BOOL IsDescriptionValidDevice();
    
    BOOL GetDeviceInfo( String &HubName, ULONG index);
    
    static ULONG CalculateBWPercent(ULONG bw);

    static BOOL InsertTreeItem (HWND hWndTree,
                                UsbItem *usbItem,
                                HTREEITEM hParent,
                                LPTV_INSERTSTRUCT item,
                                PUsbItemActionIsValid IsValid,
                                PUsbItemActionIsValid IsBold,
                                PUsbItemActionIsValid IsExpanded);
    static UINT EndpointBandwidth(ULONG MaxPacketSize,
                           UCHAR EndpointType,
                           BOOLEAN LowSpeed);
    
    UsbItem *parent, *sibling, *child;
    
    UsbDeviceInfo* deviceInfo;
    UsbConfigInfo* configInfo;
#ifdef HUB_CAPS
    USB_HUB_CAPABILITIES hubCaps;
#endif
    UsbItemType itemType;
    int imageIndex;
    UINT bandwidth;
    UINT power;
    USB_NODE_CONNECTION_ATTRIBUTES cxnAttributes;

protected:

    BOOL GetHubInfo(HANDLE hHubDevice);
    static int CalculateTotalBandwidth(ULONG           NumPipes,
                                       BOOLEAN         LowSpeed,
                                       USB_PIPE_INFO  *PipeInfo);
    static ULONG CalculateUsbBandwidth(ULONG MaxPacketSize,
                                       UCHAR EndpointType,
                                       UCHAR Interval,
                                       BOOLEAN LowSpeed);

    // enum functions
/*    BOOL Enumerate(HANDLE Controller, 
                      UsbImageList* ClassImageList, 
                      DEVINST RootDevInst);*/
    void EnumerateHubPorts(HANDLE HHubDevice, 
                           ULONG NPorts,
                           UsbImageList* ClassImageList);

    // wrappers around IOCTL and cfgmgr
    static String GetHCDDriverKeyName(HANDLE HController);
    static String GetExternalHubName (HANDLE  Hub, ULONG ConnectionIndex);
    static String GetRootHubName(HANDLE HostController);

    PUSB_DESCRIPTOR_REQUEST GetConfigDescriptor(HANDLE hHubDevice, 
                                                ULONG ConnectionIndex);
    
    static BOOL SearchAndReplace (LPCWSTR   FindThis,
                                  LPCWSTR   FindWithin,
                                  LPCWSTR   ReplaceWith,
                                  String    &NewString);
private:
    void GetClassImageIndex(UsbImageList *ClassImageList);
    PUSB_NODE_CONNECTION_INFORMATION GetConnectionInformation(HANDLE HHubDevice,
                                                              ULONG  index);
    BOOL GetPortAttributes(HANDLE HHubDevice,
                           PUSB_NODE_CONNECTION_ATTRIBUTES connectionAttributes,
                           ULONG  index);
    BOOL UnusedPort;
};

//
// Helper functions
//
BOOL UsbTreeView_DeleteAllItems(HWND hTreeDevices);
HTREEITEM TreeView_FindItem(HWND hWndTree, LPCTSTR   text);
void GetConfigMgrInfo(const String& DriverName, UsbConfigInfo* ConfigInfo);
String GetDriverKeyName(HANDLE  Hub, ULONG ConnectionIndex);
HANDLE GetHandleForDevice(const String &DeviceName);

#endif // _USBITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\str.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       STR.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _STR_H
#define _STR_H

#include <assert.h>

template<class T>
class _Str {
public:

    _Str() : buffer(0), length(0) {}
    _Str(const _Str<T>& S) : buffer(0), length(0) { Copy(S); }
    _Str(const T* buf) : buffer(0), length(Length(buf))
    {
        if (!length) return;
        buffer = new T[length+1];
        assert(buffer);
        memcpy(buffer, buf, length * sizeof(T));
        buffer[length] = (T) 0;
    }

    ~_Str( ) { Delete(); } 

    void Clear() { Delete(); }
    void erase() { Clear(); }
    int empty() { return length == 0; }
    unsigned int size() const { return length; }

    // equality, assignment, and append (equal)
    _Str<T>& operator=(const _Str<T>& rhs)
        { Delete(); Copy(rhs); return *this;}
    _Str<T> operator+(const _Str<T>& rhs)
        { _Str<T> s(*this); s += rhs; return s; }
    void operator+=(const _Str<T>& rhs) {
        if (!rhs.length) return;
        T* buf = new T[length+rhs.length+1];
        assert(buf);
        if (buffer) { memcpy(buf, buffer, length*sizeof(T)); }
        memcpy(buf+length, rhs.buffer, rhs.length*sizeof(T));
        length += rhs.length;
        buf[length] = (T) 0;

        delete[] buffer;
        buffer = buf;
    }
    int operator==(const _Str<T>& rhs) const {
        if (!buffer || !rhs.buffer) return 0;
        return Compare(buffer, rhs.buffer) == 0;
    }
    int operator==(const T* rhs) const {
        if (!buffer || !rhs) return 0;
        return Compare(buffer, rhs) == 0;
    }
    int operator> (const _Str<T>& rhs) const {
        if (!buffer || !rhs.buffer) return 0;
        return Compare(buffer, rhs.buffer) == 1;
    }
    int operator>=(const _Str<T>& rhs) const {
        if (!buffer || !rhs.buffer) return 0;
        return Compare(buffer, rhs.buffer) >= 0;
    }
    int operator< (const _Str<T>& rhs) const {
        if (!buffer || !rhs.buffer) return 0;
        return Compare(buffer, rhs.buffer) == -1;
    }
    int operator<=(const _Str<T>& rhs) const {
        if (!buffer || !rhs.buffer) return 0;
        return Compare(buffer, rhs.buffer) <= 0;
    }

    // casts
    operator const T*() const { return buffer; }
    const T* c_str() const { return buffer; }

    static unsigned int Length(const T* Buf) { 
        if (!Buf) return 0;
        for (const T* t=Buf; *t; t++)
            ;
        return (unsigned int)(t - Buf);
    }

protected:
    static int Compare(const T* lhs, const T*rhs)  {
        int ret = 0;
    
        while(!(ret = (int)(*lhs - *rhs)) && *rhs)
            ++lhs, ++rhs;
    
        if (ret < 0) ret = -1;
        else if (ret > 0) ret = 1;
    
        return ret;
    }

private:
    void Delete() { if (buffer) delete[] buffer; buffer = NULL; length = 0; }
    void Copy(const _Str<T>& S) {
        if (!S.length) return;
        buffer  = new T[S.length+1];
        assert(buffer);
        length = S.length;
        memcpy(buffer, S.buffer, length * sizeof(T));
        buffer[length] = (T) 0;
    }
    
protected:
    T* buffer;
    unsigned int length;
};

#endif _STR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbitem.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBITEM.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "UsbItem.h"
#include "resource.h"

// From root\wdm10\usb\hcd\uhcd\bandwdth.c
#define HCD_BW_PER_FRAME            ((ULONG)12000) // bits/ms
#define HCD_TOTAL_USB_BW            ((ULONG)12000*32)

// From root\wdm10\usb\inc\hcdi.h
#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13

#include "debug.h"

extern HINSTANCE gHInst;

UsbItem::~UsbItem()
{
    if (configInfo) {
        DeleteChunk(configInfo);
        delete configInfo;
    }
    if (deviceInfo) {
        DeleteChunk(deviceInfo);
        delete deviceInfo;
    }
    DeleteChunk(sibling);
    delete sibling;
    DeleteChunk(child);
    delete child;
}

UsbItem *
UsbItem::AddLeaf(UsbItem* Parent,
                 UsbDeviceInfo* DeviceInfo,
                 UsbItemType Type,
                 UsbConfigInfo* ConfigInfo,
                 UsbImageList *ClassImageList)
{
    //
    // Fill in the parent's Child field
    //
    // If it's not null, walk the chain of children of this parent and add
    // this node to the end of the chain.
    //
    if (Parent != 0) {
        //
        // Create a new USBMGR_TVITEM
        //
        UsbItem *lastSibling = 0, *item = 0;
        item = new UsbItem();
        AddChunk(item);
        if (0 == item)
        {
            USBERROR((_T("Out of Memory\n")));
            return FALSE;
        }

        if (Parent->child != 0) {
            //
            // This parent already has a child. Look for the end of the chain of
            // children.
            //
            lastSibling = Parent->child;

            while (0 != lastSibling->sibling) {
                lastSibling = lastSibling->sibling;
            }

            //
            // Found the last sibling for this parent
            //
            lastSibling->sibling = item;
        }
        else {
            //
            // No children for this parent yet
            //
            Parent->child = item;
        }

        item->parent         = Parent;

        item->deviceInfo     = DeviceInfo;
        item->configInfo     = ConfigInfo;
        item->itemType       = Type;

        item->GetClassImageIndex(ClassImageList);
        return item;
    }
    else {  // This item is the root (no parent)
        deviceInfo     = DeviceInfo;
        configInfo     = ConfigInfo;
        itemType       = Type;

        GetClassImageIndex(ClassImageList);
        return this;
    }
}

void
UsbItem::GetClassImageIndex(UsbImageList *ClassImageList)
{
    if (!configInfo ||
        !configInfo->deviceClass.size()) {
        //
        // No device class, so assign the default USB class
        //
        ClassImageList->GetClassImageIndex(TEXT("USB"), &imageIndex);
    } else {
        if (_tcsicmp(configInfo->deviceClass.c_str(), USBHID) == 0) {
            //
            // This device is HID, so find out what its child is for the
            // appropriate icon
            //
            CONFIGRET   cr;
            DEVINST     childDI;
            TCHAR       buf[MAX_PATH];
            ULONG       len;
            cr = CM_Get_Child(&childDI,
                              configInfo->devInst,
                              0);
            USBINFO( (_T("Found HID device: %s, devInst: %x\n"),
                  configInfo->deviceDesc.c_str(),
                  configInfo->devInst));
            if (cr == CR_SUCCESS) {
                len = sizeof(buf);
                cr = CM_Get_DevNode_Registry_Property(childDI,
                                                      CM_DRP_CLASS,
                                                      NULL,
                                                      buf,
                                                      &len,
                                                      0);
                if (cr == CR_SUCCESS) {
                    configInfo->deviceClass = buf;
                    USBINFO( (_T("New class: %s\n"), buf));
                }

                len = sizeof(buf);
                cr = CM_Get_DevNode_Registry_Property(childDI,
                                                      CM_DRP_DEVICEDESC,
                                                      NULL,
                                                      buf,
                                                      &len,
                                                      0);
                if (cr == CR_SUCCESS) {
                    configInfo->deviceDesc = buf;
                    USBINFO( (_T("New name: %s\n"), configInfo->deviceDesc.c_str()));
                }
            }
        }
        ClassImageList->GetClassImageIndex(configInfo->deviceClass.c_str(),
                                           &imageIndex);
    }
}

UINT
UsbItem::EndpointBandwidth(
    ULONG MaxPacketSize,
    UCHAR EndpointType,
    BOOLEAN LowSpeed
    )
/*++

Return Value:

    banwidth consumed in bits/ms, returns 0 for bulk
    and control endpoints

--*/
{
    ULONG bw = 0;

    //
    // control, iso, bulk, interrupt
    //
    ULONG overhead[4] = {
        0,
        USB_ISO_OVERHEAD_BYTES,
        0,
        USB_INTERRUPT_OVERHEAD_BYTES
        };

    // return zero for control or bulk
    if (!overhead[EndpointType]) {
        return 0;
    }

    //
    // Calculate bandwidth for endpoint.  We will use the
    // approximation: (overhead bytes plus MaxPacket bytes)
    // times 8 bits/byte times worst case bitstuffing overhead.
    // This gives bit times, for low speed endpoints we multiply
    // by 8 again to convert to full speed bits.
    //

    //
    // Figure out how many bits are required for the transfer.
    // (multiply by 7/6 because, in the worst case you might
    // have a bit-stuff every six bits requiring 7 bit times to
    // transmit 6 bits of data.)
    //

    // overhead(bytes) * maxpacket(bytes/ms) * 8
    //      (bits/byte) * bitstuff(7/6) = bits/ms

    bw = ((overhead[EndpointType]+MaxPacketSize) * 8 * 7) / 6;

    if (LowSpeed) {
        bw *= 8;
    }

    return bw;
}

inline ULONG
UsbItem::CalculateBWPercent(ULONG bw) { return (bw*100) / HCD_BW_PER_FRAME; }

int
UsbItem::CalculateTotalBandwidth(
    ULONG           NumPipes,
    BOOLEAN         LowSpeed,
    USB_PIPE_INFO  *PipeInfo
    )
{
    ULONG i = 0, bwConsumed, bwTotal = 0;
    PUSB_ENDPOINT_DESCRIPTOR epd = 0;

    for (i = 0; i < NumPipes; i++) {

        epd = &PipeInfo[i].EndpointDescriptor;

        //
        // We only take into account iso BW. Interrupt bw is accounted for
        // in another way.
        //
        if (USB_ENDPOINT_TYPE_ISOCHRONOUS ==
            (epd->bmAttributes & USB_ENDPOINT_TYPE_MASK)) {
            bwConsumed = EndpointBandwidth(epd->wMaxPacketSize,
                                           (UCHAR)(epd->bmAttributes & USB_ENDPOINT_TYPE_MASK),
                                           LowSpeed);
            bwTotal += bwConsumed;
        }
    }

    bwTotal = CalculateBWPercent(bwTotal);

    return bwTotal;
}

BOOL
UsbItem::ComputeBandwidth()
{
    bandwidth = 0;

    if (deviceInfo && deviceInfo->connectionInfo &&
        !deviceInfo->connectionInfo->DeviceIsHub) {
        if (deviceInfo->connectionInfo->NumberOfOpenPipes > 0) {
            if (0 != (bandwidth = CalculateTotalBandwidth(
                deviceInfo->connectionInfo->NumberOfOpenPipes,
                deviceInfo->connectionInfo->LowSpeed,
                deviceInfo->connectionInfo->PipeList))) {
                return TRUE;
            }
        } else { // Device is not consuming any bandwidth
            USBTRACE((_T("%s has no open pipes\n"),
                      configInfo->deviceDesc.c_str()));
        }
    }

    return FALSE;
}

BOOL
UsbItem::ComputePower()
{
    power = 0;

    if (IsHub()) {
        if (PortPower() == 100) {
            //
            // Hub that is bus powered requires one unit of power for itself
            // plus one unit for each of its ports
            //
            power = (1 + NumPorts()) > 4 ? 500 : 100 * (1 + NumPorts());

        } else {
            //
            // Self-powered hubs don't require any power from upstream
            //
            power = 0;
        }
        return TRUE;
    }
    if (deviceInfo && deviceInfo->configDesc) {
        power = deviceInfo->configDesc->MaxPower*2;
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItem::IsController()
{
    if (itemType == HCD) {
        return TRUE;
    }
    return FALSE;
}

BOOL
UsbItem::IsHub()
{
    if (itemType == RootHub || itemType == Hub)
        return TRUE;

    if (deviceInfo) {
        if (deviceInfo->isHub)
            return TRUE;

        if (deviceInfo->connectionInfo && deviceInfo->connectionInfo->DeviceIsHub)
            return TRUE;
    }

    return FALSE;
}

ULONG UsbItem::UsbVersion()
{
    if (deviceInfo) {
        if (deviceInfo->connectionInfo) {
            return deviceInfo->connectionInfo->DeviceDescriptor.bcdUSB;
#ifdef HUB_CAPS
        } else if(hubCaps.HubIs2xCapable) { // Probably the root hub, check hub capabilities
            return 0x200;
#endif
        }
#if 0
        else {
           return 0x200;
        }
#endif
    }
    return 0x100;
}

BOOL UsbItem::IsDescriptionValidDevice()
{
    if (!IsUnusedPort() &&
        configInfo &&
        configInfo->deviceDesc.c_str()) {
        return TRUE;
    }
    return FALSE;
}

ULONG UsbItem::NumChildren()
{
    UsbItem *item;
    ULONG i = 0;
    for (item = child; item != NULL; item = item->sibling) {
        if (item->IsDescriptionValidDevice()) {
            i++;
        }
    }
    return i;
}

ULONG UsbItem::NumPorts()
{
    UsbItem *item;
    ULONG i = 0;
    if (IsHub()) {
        for (item = child; item != NULL; item = item->sibling) {
            i++;
        }
    }
    return i;
}

ULONG UsbItem::PortPower()
{
    if (IsHub()) {
        if (deviceInfo->hubInfo.u.HubInformation.HubIsBusPowered)
            return 100;
        else
            return 500;
    } else {
        return 0;
    }
}

BOOL
UsbItem::Walk(UsbItemAction& Action)
{
    if (sibling) {
        if (!sibling->Walk(Action))
            return FALSE;
    }

    if (child) {
        if (!child->Walk(Action))
            return FALSE;
    }

    return Action(this);
}

BOOL
UsbItem::ShallowWalk(UsbItemAction& Action)
{
    if (sibling) {
        if (!sibling->ShallowWalk(Action))
            return FALSE;
    }

    return Action(this);
}

BOOL
UsbItem::GetDeviceInfo( String &HubName,
                        ULONG index)
{
    HANDLE                              hHubDevice;
    PUSB_NODE_CONNECTION_INFORMATION    connectionInfo = 0;
    String                              driverKeyName;
    TCHAR                               buf[MAX_PATH];

    //
    // Try to open the hub device
    //
    hHubDevice = GetHandleForDevice(HubName);

    if (hHubDevice == INVALID_HANDLE_VALUE) {
        goto GetDeviceInfoError;
    }

    if (!GetPortAttributes(hHubDevice, &cxnAttributes, index)) {
        USBERROR( (_T("Couldn't get node connection attributes\n")));
        goto GetDeviceInfoError;
    }

    if (NULL == (connectionInfo = GetConnectionInformation(hHubDevice, index))) {
        USBERROR( (_T("Couldn't get node connection information\n")));
        goto GetDeviceInfoError;
    }

    //
    // Allocate configuration information structure
    //
    configInfo = new UsbConfigInfo();
    AddChunk(configInfo);

    if (configInfo == 0) {
        goto GetDeviceInfoError;
    }

    //
    // If there is a device connected, get the Device Description
    //
    if (connectionInfo->ConnectionStatus != NoDeviceConnected) {
        driverKeyName = GetDriverKeyName(hHubDevice,index);

        if (!driverKeyName.empty()) {
            GetConfigMgrInfo(driverKeyName, configInfo);
        }

        if (configInfo->deviceDesc.empty()) {
            if (connectionInfo->DeviceIsHub) {
                if (connectionInfo->DeviceDescriptor.bcdUSB >= 0x200) {
                    LoadString(gHInst, IDS_UNKNOWN20HUB, buf, MAX_PATH);
                } else {
                    LoadString(gHInst, IDS_UNKNOWNHUB, buf, MAX_PATH);
                }
            } else {
                LoadString(gHInst, IDS_UNKNOWNDEVICE, buf, MAX_PATH);
            }
            configInfo->deviceDesc = buf;
        }
        if (configInfo->deviceClass.empty()) {
            configInfo->deviceClass = connectionInfo->DeviceIsHub ?
                TEXT("USB") : TEXT("Unknown");
        }

        itemType = connectionInfo->DeviceIsHub ? UsbItem::UsbItemType::Hub :
            UsbItem::UsbItemType::Device;

        //
        // Allocate some space for a USBDEVICEINFO structure to hold the
        // info for this device.
        //
        deviceInfo = new UsbDeviceInfo();
        AddChunk(deviceInfo);

        if (deviceInfo == 0) {
            goto GetDeviceInfoError;
        }

        if (NULL != (deviceInfo->configDescReq =
                     GetConfigDescriptor(hHubDevice, index))) {
            deviceInfo->configDesc =
                (PUSB_CONFIGURATION_DESCRIPTOR)(deviceInfo->configDescReq+1);
        }
        deviceInfo->connectionInfo = connectionInfo;
    }
    else {
        //
        // Empty port. Add "Port n"
        //
        LocalFree(connectionInfo);

        itemType = UsbItem::UsbItemType::Empty;

        LoadString(gHInst, IDS_UNUSEDPORT, buf, MAX_PATH);
        configInfo->deviceDesc = buf;
        UnusedPort = TRUE;
        configInfo->deviceClass = TEXT("USB");

    }
    CloseHandle(hHubDevice);
    return TRUE;

GetDeviceInfoError:
    //
    // Clean up any stuff that got allocated
    //
    if (hHubDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hHubDevice);
        hHubDevice = INVALID_HANDLE_VALUE;
    }
    if (deviceInfo) {
        DeleteChunk(deviceInfo);
        delete deviceInfo;
    }
    if (connectionInfo)
    {
        LocalFree(connectionInfo);
    }
    if (configInfo) {
        DeleteChunk(configInfo);
        delete configInfo;
    }
    return FALSE;
}

//
// Recursively inserts items appropriately into a treeview
//
BOOL
UsbItem::InsertTreeItem (HWND hWndTree,
                UsbItem *usbItem,
                HTREEITEM hParent,
                LPTV_INSERTSTRUCT item,
                PUsbItemActionIsValid IsValid,
                PUsbItemActionIsValid IsBold,
                PUsbItemActionIsValid IsExpanded)
{
    if (!usbItem || !item) {
        return FALSE;
    }

    if (IsValid(usbItem)) {
        HTREEITEM hItem;

        ZeroMemory(item, sizeof(TV_INSERTSTRUCT));

        // Get the image index

        item->hParent = hParent;
        item->hInsertAfter = TVI_LAST;
        item->item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE; // TVIF_CHILDREN

        if (IsBold(usbItem)) {
            item->itemex.state = TVIS_BOLD;
        }
        if (IsExpanded(usbItem)) {
            item->itemex.state |= TVIS_EXPANDED;
        }
        item->itemex.stateMask = (UINT)~(TVIS_STATEIMAGEMASK | TVIS_OVERLAYMASK);
        item->itemex.pszText = (LPTSTR) usbItem->configInfo->deviceDesc.c_str();
        item->itemex.cchTextMax = _tcsclen(usbItem->configInfo->deviceDesc.c_str());
        item->itemex.iImage = usbItem->imageIndex;
        item->itemex.iSelectedImage = usbItem->imageIndex;
        if (usbItem->child) {
            item->itemex.cChildren = 1;
        }
        item->itemex.lParam = (USBLONG_PTR) usbItem;

        if (NULL == (hItem = TreeView_InsertItem(hWndTree,
                                                 item))) {
            int i = GetLastError();
            return FALSE;
        }
        if (usbItem->child) {
            if (!InsertTreeItem(hWndTree,
                                usbItem->child,
                                hItem,
                                item,
                                IsValid,
                                IsBold,
                                IsExpanded)) {
                return FALSE;
            }
        }
    }
    if (usbItem->sibling) {
        if (!InsertTreeItem(hWndTree,
                            usbItem->sibling,
                            hParent,
                            item,
                            IsValid,
                            IsBold,
                            IsExpanded)) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
UsbTreeView_DeleteAllItems(HWND hTreeDevices)
{
    HTREEITEM hTreeRoot;

    //
    // Select the root and delete so as to delete whole tree.
    // There is a paint bug in tree view that if you delete all when the
    // root isn't selected, then it will paint badly.
    //
    if (NULL == (hTreeRoot = (HTREEITEM) SendMessage(hTreeDevices,
                                           TVM_GETNEXTITEM,
                                           (WPARAM)TVGN_ROOT,
                                           (LPARAM)NULL))) {
        // Nothing to delete; successful
        return TRUE;
    }
    if (!SendMessage(hTreeDevices,
                        TVM_SELECTITEM,
                        (WPARAM)TVGN_CARET,
                        (LPARAM)hTreeRoot)) {
        // Can't select the root; YIKES!
        return FALSE;
    }

    //
    // deleteAllOk = TreeView_DeleteAllItems(hTreeDevices);
    //
    return (BOOL) SendMessage(hTreeDevices,
                                TVM_DELETEITEM,
                                0,
                                (LPARAM)TVI_ROOT);
}

HTREEITEM
TreeView_FindItem(HWND      hWndTree,
                  LPCTSTR   text)
{
    HTREEITEM hItemPrev, hItemNext;
    TCHAR buf[MAX_PATH];

    TVITEM tvItem;
    tvItem.mask = TVIF_TEXT | TVIF_HANDLE;
    tvItem.pszText = buf;
    tvItem.cchTextMax = MAX_PATH;

    if (NULL == (hItemNext = TreeView_GetRoot(hWndTree))) {
        return NULL;
    }

    hItemPrev = hItemNext;

    while (hItemPrev) {

        //
        // Drill all the way down, checking the nodes along the way.
        //
        while (hItemNext) {
            //
            // Check this leaf
            //
            tvItem.hItem = hItemNext;
            if (TreeView_GetItem(hWndTree, &tvItem)) {
                if (!_tcscmp(tvItem.pszText, text)) {
                    return hItemNext;
                }
            }

            //
            // Get the next child
            //
            hItemPrev = hItemNext;
            hItemNext = TreeView_GetNextItem(hWndTree,
                                             hItemPrev,
                                             TVGN_CHILD);
        }

        //
        // Find the first sibling on the way back up the tree
        //
        while (!hItemNext && hItemPrev) {
            //
            // Get the sibling
            //
            hItemNext = TreeView_GetNextItem(hWndTree,
                                             hItemPrev,
                                             TVGN_NEXT);
            if (!hItemNext) {
                //
                // Get the parent
                //
                hItemPrev = TreeView_GetNextItem(hWndTree,
                                                 hItemPrev,
                                                 TVGN_PARENT);
            }
        }
    }

    return NULL;
}

HANDLE
UsbCreateFileA(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile)
{
    CHAR usbDeviceName[MAX_PATH];
    if (!WideCharToMultiByte(CP_ACP,
                             WC_NO_BEST_FIT_CHARS,
                             lpFileName,
                             -1,
                             usbDeviceName,
                             MAX_PATH,
                             NULL,
                             NULL)) {
        return INVALID_HANDLE_VALUE;
    }
    return CreateFileA (usbDeviceName,
                        dwDesiredAccess,
                        dwShareMode,
                        lpSecurityAttributes,
                        dwCreationDisposition,
                        dwFlagsAndAttributes,
                        hTemplateFile);
}

//
// Get the index into the ImageList for this device's icon
//
BOOL
UsbImageList::GetClassImageIndex(LPCTSTR DeviceClass,
                                 PINT ImageIndex)
{
#ifndef WINNT
    IconItem *iconItem;
    BOOL found = FALSE;
    int i = 0;
    for (iconItem = iconTable.begin();
         iconItem;
         iconItem = iconTable.next(), i++) {
        if (_tcsicmp(DeviceClass, iconItem->szClassName) == 0) {
            *ImageIndex = iconItem->imageIndex;
            return TRUE;
        }
    }
#endif // ~WINNT

    GUID classGuid;
    DWORD listSize;

    if(SetupDiClassGuidsFromName(DeviceClass,
                                 &classGuid,
                                 1,
                                 &listSize)) {
       return SetupDiGetClassImageIndex(&ClassImageList, &classGuid, ImageIndex);
    }
    return FALSE;
}

BOOL
UsbImageList::GetClassImageList()
{
    ZeroMemory(&ClassImageList, sizeof(SP_CLASSIMAGELIST_DATA));
    ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (!SetupDiGetClassImageList(&ClassImageList)) {
        USBERROR((TEXT("Failed to get imagelist, error %x"), GetLastError()));
        return FALSE;
    }
#ifndef WINNT

    HICON hIcon;
    IconItem iconItem;
    HIMAGELIST imageList = ClassImageList.ImageList;

    iconTable.clear();

    hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_IMAGE));
    iconItem.imageIndex = ImageList_AddIcon(imageList, hIcon);
    iconItem.szClassName = TEXT("Image");
    iconTable.push_back(iconItem);

    hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_MODEM));
    iconItem.imageIndex = ImageList_AddIcon(imageList, hIcon);
    iconItem.szClassName = TEXT("Modem");
    iconTable.push_back(iconItem);

    hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_INFRARED));
    iconItem.imageIndex = ImageList_AddIcon(imageList, hIcon);
    iconItem.szClassName = TEXT("Infrared");
    iconTable.push_back(iconItem);

    hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_CDROM));
    iconItem.imageIndex = ImageList_AddIcon(imageList, hIcon);
    iconItem.szClassName = TEXT("CDROM");
    iconTable.push_back(iconItem);

    hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_FLOPPY));
    iconItem.imageIndex = ImageList_AddIcon(imageList, hIcon);
    iconItem.szClassName = TEXT("DiskDrive");
    iconTable.push_back(iconItem);

    hIcon = LoadIcon(gHInst, MAKEINTRESOURCE(IDI_MEDIA));
    iconItem.imageIndex = ImageList_AddIcon(imageList, hIcon);
    iconItem.szClassName = TEXT("MEDIA");
    iconTable.push_back(iconItem);

#endif // ~WINNT
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbpopup.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBPOPUP.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _USBPOPUP_H
#define _USBPOPUP_H

#include <objbase.h>
#pragma warning(disable : 4200)
#include <usbioctl.h>

#include <setupapi.h>
#include <tchar.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <dbt.h>

#include "UsbItem.h"

#include <wmium.h>

//#include "ItemFind.h"
#include "debug.h"

#include "resource.h"

#ifndef IID_PPV_ARG
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#endif

extern HINSTANCE gHInst;
enum ProblemDeviceState {
    DeviceAttachedError = 1,
    DeviceDetachedError,
    DeviceReattached,
    DeviceAttachedProblemSolved
};

class UsbPopup : public IQueryContinue {
public:
    UsbPopup() : hTreeDevices(0), ConnectionNotification(0), WmiHandle(0),
        ImageList(), RegisterForDeviceReattach(FALSE)
        {rootItem = NULL; HubAcquireInfo = NULL;
         deviceState = DeviceAttachedError; ConfigInfo = NULL;
         hNotifyArrival = NULL;}
    ~UsbPopup() { if (rootItem) { DeleteChunk(rootItem); delete rootItem; }
                  if (HubAcquireInfo) { LocalFree(HubAcquireInfo); }
                  if (ConfigInfo) { DeleteChunk(ConfigInfo); delete ConfigInfo;
                  if (hNotifyArrival) { UnregisterDeviceNotification(hNotifyArrival); }}}

    void Make(PUSB_CONNECTION_NOTIFICATION UsbConnectionNotification,
              LPTSTR strInstanceName);

    static USBINT_PTR APIENTRY StaticDialogProc(IN HWND   hDlg,
                                          IN UINT   uMessage,
                                          IN WPARAM wParam,
                                          IN LPARAM lParam);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();

protected:

    static UINT CALLBACK StaticDialogCallback(HWND            Hwnd,
                                       UINT            Msg,
                                       LPPROPSHEETPAGE Page);

    virtual INT_PTR APIENTRY ActualDialogProc(IN HWND   hDlg,
                                           IN UINT   uMessage,
                                           IN WPARAM wParam,
                                           IN LPARAM lParam)
    { return FALSE; } // DefDlgProc(hDlg, uMessage, wParam, lParam); }

    virtual BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl);
    virtual BOOL OnInitDialog(HWND hDlg);
    virtual BOOL OnNotify(HWND hDlg, int nID, LPNMHDR pnmh);
    virtual BOOL CustomDialogWrap() { return FALSE; }
    virtual BOOL IsPopupStillValid() { return TRUE; }

    USBINT_PTR OnTimer() { return 0; }

    BOOL CustomDialog(DWORD DialogBoxId,
                      DWORD IconId,
                      DWORD FormatStringId,
                      DWORD TitleStringId);

    virtual BOOL GetToolTip(LPNMTVGETINFOTIP lParam) { return TRUE; }

    virtual BOOL Refresh() { return FALSE; }

    PUSB_ACQUIRE_INFO GetControllerName(WMIHANDLE WmiHandle,
                                        UsbString InstanceName);

    BOOLEAN GetBusNotification(WMIHANDLE WmiHandle,
                               PUSB_BUS_NOTIFICATION UsbBusNotification);

    PUSB_ACQUIRE_INFO GetHubName(WMIHANDLE WmiHandle,
                                 UsbString InstanceName,
                                 PUSB_CONNECTION_NOTIFICATION ConnectionNotification);

    BOOL InsertTreeItem(HWND hWndTree,
                        UsbItem *usbItem,
                        HTREEITEM hParent,
                        LPTV_INSERTSTRUCT item,
                        PUsbItemActionIsValid IsValid,
                        PUsbItemActionIsValid IsBold,
                        PUsbItemActionIsValid IsExpanded) {
        return UsbItem::InsertTreeItem(hWndTree,
                                       usbItem,
                                       hParent,
                                       item,
                                       IsValid,
                                       IsBold,
                                       IsExpanded);
    }
    HRESULT RegisterForReAttach();
    BOOL OnDeviceChange(HWND hDlg,
                         WPARAM wParam,
                         PDEV_BROADCAST_HDR devHdr);

    PUSB_CONNECTION_NOTIFICATION    ConnectionNotification;
    UsbImageList                    ImageList;
    WMIHANDLE                       WmiHandle;

    HWND        hWnd;
    HWND        hTreeDevices;
    HWND        hListDevices;

    UsbItem     *rootItem;
    UsbString   InstanceName;
    LONG        RefCount;
    PUSB_ACQUIRE_INFO HubAcquireInfo;
    IUserNotification *pun;
    UsbItem     deviceItem;
    BOOLEAN     RegisterForDeviceReattach;
    UsbConfigInfo *ConfigInfo;
    HDEVNOTIFY hNotifyArrival;
    enum ProblemDeviceState deviceState;
};

class UsbBandwidthPopup : public UsbPopup {
public:
    UsbBandwidthPopup() : UsbPopup() {;}
protected:
    BOOL Refresh();
    BOOL OnInitDialog(HWND HWnd);
    BOOL CustomDialogWrap() { return CustomDialog(IDD_INSUFFICIENT_BANDWIDTH,
                                                  NIIF_WARNING | NIIF_NOSOUND,
                                                  IDS_BANDWIDTH_INITIAL,
                                                  IDS_CONTROLLER_BW_EXCEEDED); }
    BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl);
    void AddIsoDevicesToListView(UsbItem *controller, int iIndent);

    BOOL IsPopupStillValid();

private:
    static UsbString    LastDeviceName;
    static ULONG        LastBandwidthRequested;
    static ULONG        LastBandwidthConsumed;
};

class UsbPowerPopup : public UsbPopup {
public:
    UsbPowerPopup() : UsbPopup() {;}
protected:
    USBINT_PTR OnTimer();
    BOOL Refresh();
    BOOL CustomDialogWrap() { //RegisterForDeviceReattach = TRUE;
                              return CustomDialog(IDD_INSUFFICIENT_POWER,
                                                  NIIF_ERROR,
                                                  IDS_POWER_INITIAL,
                                                  IDS_POWER_EXCEEDED); }
    BOOL       AssembleDialog(UsbItem*              RootItem,
                              LPTV_INSERTSTRUCT     LvItem,
                              LPCTSTR               DeviceName,
                              UINT                  Explanation,
                              UINT                  Recommendation,
                              PUsbItemActionIsValid IsValid,
                              PUsbItemActionIsValid IsBold,
                              PUsbItemActionIsValid IsExpanded);
};

class UsbLegacyPopup : public UsbPopup {
public:
   UsbLegacyPopup() : UsbPopup() {;}
protected:
   USBINT_PTR OnTimer();
   BOOL Refresh();
   BOOL CustomDialogWrap() {
      return CustomDialog(IDD_MODERN_DEVICE_IN_LEGACY_HUB,
                          NIIF_WARNING,
                          IDS_LEGACY_INITIAL,
                          IDS_USB2_DEVICE_IN_USB1_HUB);
   }
   BOOL AssembleDialog(UsbItem*              RootItem,
                       LPTV_INSERTSTRUCT     LvItem,
                       LPCTSTR               DeviceName,
                       UINT                  Explanation,
                       UINT                  Recommendation,
                       PUsbItemActionIsValid IsValid,
                       PUsbItemActionIsValid IsBold,
                       PUsbItemActionIsValid IsExpanded);
};

class UsbEnumFailPopup : public UsbPopup {
public:
    UsbEnumFailPopup() : UsbPopup() {;}
protected:
    BOOL Refresh();
    BOOL CustomDialogWrap() { return CustomDialog(IDD_INSUFFICIENT_POWER,
                                                  NIIF_WARNING,
                                                  IDS_ENUMFAIL_INITIAL,
                                                  IDS_ENUMERATION_FAILURE); }
};

class UsbOvercurrentPopup : public UsbPopup {
public:
    UsbOvercurrentPopup() : UsbPopup() {;}
protected:
    BOOL OnCommand(INT wNotifyCode, INT wID, HWND hCtl);
    BOOL Refresh();
    BOOL CustomDialogWrap();
};

class UsbNestedHubPopup : public UsbPopup {
public:
    UsbNestedHubPopup() : UsbPopup() {;}
protected:
    BOOL Refresh();
    BOOL CustomDialogWrap() {
       return CustomDialog(IDD_NESTED_HUB,
                           NIIF_ERROR,
                           IDS_NESTED_HUB_INITIAL,
                           IDS_HUB_NESTED_TOO_DEEPLY); }

    BOOL AssembleDialog(UsbItem*              RootItem,
                        LPTV_INSERTSTRUCT     LvItem,
                        LPCTSTR               DeviceName,
                        UINT                  Explanation,
                        UINT                  Recommendation,
                        PUsbItemActionIsValid IsValid,
                        PUsbItemActionIsValid IsBold,
                        PUsbItemActionIsValid IsExpanded);


};

#endif // _USBPOPUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbpopup.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBPOPUP.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "UsbPopup.h"
#include "PropPage.h"
#include "debug.h"
#include "usbutil.h"

UINT CALLBACK
UsbPopup::StaticDialogCallback(HWND            Hwnd,
                            UINT            Msg,
                            LPPROPSHEETPAGE Page)
{
    UsbPopup *that;

    switch (Msg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        that = (UsbPopup*) Page->lParam;
        DeleteChunk(that);
        delete that;

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

USBINT_PTR APIENTRY UsbPopup::StaticDialogProc(IN HWND   hDlg,
                                      IN UINT   uMessage,
                                      IN WPARAM wParam,
                                      IN LPARAM lParam)
{
    UsbPopup *that;

    that = (UsbPopup *) UsbGetWindowLongPtr(hDlg, USBDWLP_USER);

    if (!that && uMessage != WM_INITDIALOG)
        return FALSE; //DefDlgProc(hDlg, uMessage, wParam, lParam);

    switch (uMessage) {

    case WM_COMMAND:
        return that->OnCommand(HIWORD(wParam),
                               LOWORD(wParam),
                               (HWND) lParam);

    case WM_TIMER:
        return that->OnTimer();
    case WM_INITDIALOG:
        that = (UsbPopup *) lParam;
        UsbSetWindowLongPtr(hDlg, USBDWLP_USER, (USBLONG_PTR) that);
        that->hWnd = hDlg;

        return that->OnInitDialog(hDlg);

    case WM_NOTIFY:
        return that->OnNotify(hDlg, (int) wParam, (LPNMHDR) lParam);
    case WM_DEVICECHANGE:
        return that->OnDeviceChange(hDlg, wParam, (PDEV_BROADCAST_HDR)lParam);

    default:
        break;
    }

    return that->ActualDialogProc(hDlg, uMessage, wParam, lParam);
}

BOOL
UsbPopup::OnCommand(INT wNotifyCode,
                 INT wID,
                 HWND hCtl)
{
    switch (wID) {
    case IDOK:
        EndDialog(hWnd, wID);
        return TRUE;
    }
    return FALSE;
}

BOOL UsbPopup::OnNotify(HWND hDlg, int nID, LPNMHDR pnmh)
{

    switch (nID) {
    case IDC_LIST_CONTROLLERS:
        if (pnmh->code == NM_DBLCLK) {
            //
            // Display properties on this specific device on double click
            //
            UsbPropertyPage::DisplayPPSelectedListItem(hDlg, hListDevices);
        }
        return TRUE;
    case IDC_TREE_HUBS:
        if (pnmh->code == NM_DBLCLK) {
            //
            // Display properties on this specific device on double click
            //
            UsbPropertyPage::DisplayPPSelectedTreeItem(hDlg, hTreeDevices);
        }
        return TRUE;
    }

    return 0;
}

BOOL
UsbPopup::CustomDialog(
    DWORD DialogBoxId,
    DWORD IconId,
    DWORD FormatStringId,
    DWORD TitleStringId)
{
    HRESULT hr;

    //
    // Make sure the device hasn't gone away.
    //
    if (UsbItem::UsbItemType::Empty == deviceItem.itemType) {
        return FALSE;
    }

    TCHAR buf[MAX_PATH];
    TCHAR formatString[MAX_PATH];
    LoadString(gHInst,
               FormatStringId,
               formatString,
               MAX_PATH);
    UsbSprintf(buf, formatString, deviceItem.configInfo->deviceDesc.c_str());
    LoadString(gHInst, TitleStringId, formatString, MAX_PATH);

    pun->SetBalloonRetry(-1, -1, 0);
    pun->SetIconInfo(LoadIcon(gHInst, MAKEINTRESOURCE(IDI_USB)), formatString);
    pun->SetBalloonInfo(formatString, buf, IconId);

    //
    // Query me every 2 seconds.
    //
    hr = pun->Show(this, 2000);

    pun->Release();

    if (S_OK == hr) {
        if (-1 == DialogBoxParam(gHInst,
                                  MAKEINTRESOURCE(DialogBoxId),
                                  NULL,
                                  StaticDialogProc,
                                  (LPARAM) this)) {
            return FALSE;
        }
    }
    return TRUE;
}

STDMETHODIMP_(ULONG) UsbPopup::AddRef()
{
    return InterlockedIncrement(&RefCount);
}

STDMETHODIMP_(ULONG) UsbPopup::Release()
{
    if (InterlockedDecrement(&RefCount))
        return RefCount;

//    delete this;
    return 0;
}

HRESULT UsbPopup::QueryInterface(REFIID iid, void **ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IQueryContinue)) {
        *ppv = (void *)(IQueryContinue *)this;
    }
    else {
        *ppv = NULL;    // null the out param
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT
UsbPopup::QueryContinue()
{
    USB_NODE_CONNECTION_INFORMATION connectionInfo;
    ULONG nBytes;
    HANDLE hHubDevice;
    String hubName = HubAcquireInfo->Buffer;

    //
    // Try to open the hub device
    //
    hHubDevice = GetHandleForDevice(hubName);

    if (hHubDevice == INVALID_HANDLE_VALUE) {
        return S_FALSE;
    }

    //
    // Find out if we still have an underpowered device attached .
    //
    nBytes = sizeof(USB_NODE_CONNECTION_INFORMATION);
    ZeroMemory(&connectionInfo, nBytes);
    connectionInfo.ConnectionIndex = ConnectionNotification->ConnectionNumber;

    if ( !DeviceIoControl(hHubDevice,
                          IOCTL_USB_GET_NODE_CONNECTION_INFORMATION,
                          &connectionInfo,
                          nBytes,
                          &connectionInfo,
                          nBytes,
                          &nBytes,
                          NULL)) {
        return S_FALSE;
    }

    CloseHandle(hHubDevice);

    switch (ConnectionNotification->NotificationType) {
    case InsufficentBandwidth:
        return connectionInfo.ConnectionStatus == DeviceNotEnoughBandwidth ? S_OK : S_FALSE;
    case EnumerationFailure:
        return connectionInfo.ConnectionStatus == DeviceFailedEnumeration ? S_OK : S_FALSE;
    case InsufficentPower:
        return connectionInfo.ConnectionStatus == DeviceNotEnoughPower ? S_OK : S_FALSE;
    case OverCurrent:
        return connectionInfo.ConnectionStatus == DeviceCausedOvercurrent ? S_OK : S_FALSE;
    case ModernDeviceInLegacyHub:
        return connectionInfo.ConnectionStatus == DeviceConnected ? S_OK : S_FALSE;
    case HubNestedTooDeeply:
        return connectionInfo.ConnectionStatus == DeviceHubNestedTooDeeply ? S_OK : S_FALSE;
    }
    return S_FALSE;
}

void
UsbPopup::Make(PUSB_CONNECTION_NOTIFICATION vUsbConnectionNotification,
               LPTSTR     strInstanceName)
{
    ULONG result;
    HRESULT hr;
    String hubName;

    InstanceName = strInstanceName;

    ConnectionNotification = vUsbConnectionNotification;

    result = WmiOpenBlock((LPGUID) &GUID_USB_WMI_STD_DATA,
                       0,
                       &WmiHandle);

    if (result != ERROR_SUCCESS) {
        goto UsbPopupMakeError;
    }

    hWnd = GetDesktopWindow();

    InitCommonControls();

    //
    // Get the hub name and from that, get the name of the device to display in
    // the dialog and display it.
    // We'll use the port number which the device is attached to.  This is:
    //    ConnectionNotification->ConnectionNumber;
    HubAcquireInfo = GetHubName(WmiHandle,
                                strInstanceName,
                                ConnectionNotification);
    if (!HubAcquireInfo) {
        goto UsbPopupMakeError;
    }

    hubName = HubAcquireInfo->Buffer;

    //
    // Make sure that the condition still exists.
    //
    if (S_FALSE == QueryContinue()) {
        USBTRACE((_T("Erorr does not exist anymore. Exitting.\n")));
        goto UsbPopupMakeError;
    }

    if (!deviceItem.GetDeviceInfo(hubName,
                                  ConnectionNotification->ConnectionNumber)) {
        goto UsbPopupMakeError;
    }

    if (!IsPopupStillValid()) {
        //
        // We already saw the error for this device. Usbhub is being
        // repetitive.
        //
        goto UsbPopupMakeError;
    }

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr)) {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    }
    if (FAILED(hr)) {
        goto UsbPopupMakeError;
    }
    hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL,
                          IID_PPV_ARG(IUserNotification, &pun));

    if (!FAILED(hr)) {
        CustomDialogWrap();
    }

    CoUninitialize();

UsbPopupMakeError:
    USBTRACE((_T("UsbPopupMakeError\n")));
    if (WmiHandle != INVALID_HANDLE_VALUE) {
        WmiCloseBlock(WmiHandle);
    }
}

BOOL
UsbPopup::OnInitDialog(HWND HWnd)
{
    hWnd = HWnd;
    HANDLE hExclamation;
    HICON hIcon;

    if (RegisterForDeviceReattach) {
        //
        // Try to open the hub device
        //
        String hubName = HubAcquireInfo->Buffer;
        HANDLE hHubDevice = GetHandleForDevice(hubName);

        if (hHubDevice != INVALID_HANDLE_VALUE) {
            //
            // Register for notification for when the device is re-attached. We want
            // to do this before we see the device get detached because we are polling
            // and may miss the re-attach if we register when the device is removed.
            //
            // Allocate configuration information structure and get config mgr info
            //
            ConfigInfo = new UsbConfigInfo();
            AddChunk(ConfigInfo);
            if (ConfigInfo) {
                String driverKeyName = GetDriverKeyName(hHubDevice,
                                                        ConnectionNotification->ConnectionNumber);

                if (!driverKeyName.empty()) {
                    GetConfigMgrInfo(driverKeyName, ConfigInfo); // ISSUE: leak, jsenior, 4/19/00
                } else {
                    USBWARN((_T("Couldn't get driver key name. Error: (%x)."), GetLastError()));
                }

                CHAR guidBuf[MAX_PATH];
                DEV_BROADCAST_DEVICEINTERFACE devInterface;
                DWORD len = MAX_PATH;
                if (CM_Get_DevNode_Registry_PropertyA(ConfigInfo->devInst,
                                                      CM_DRP_CLASSGUID,
                                                      NULL,
                                                      guidBuf,
                                                      &len,
                                                      0) == CR_SUCCESS) {

                    ZeroMemory(&devInterface, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
                    if (StrToGUID(guidBuf, &devInterface.dbcc_classguid)) {
                        devInterface.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
                        devInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;

                        hNotifyArrival =
                        RegisterDeviceNotification( HWnd,
                                                    &devInterface,
                                                    DEVICE_NOTIFY_WINDOW_HANDLE);

                        if (!hNotifyArrival){
                            USBWARN((_T("RegisterDeviceNotification failure (%x)."), GetLastError()));
                        }
                    } else {
                        USBWARN((_T("GUID conversion didn't work.")));
                    }
                    USBWARN((_T("GUID data: %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x"),
                             devInterface.dbcc_classguid.Data1,
                             devInterface.dbcc_classguid.Data2,
                             devInterface.dbcc_classguid.Data3,
                             devInterface.dbcc_classguid.Data4[0],
                             devInterface.dbcc_classguid.Data4[1],
                             devInterface.dbcc_classguid.Data4[2],
                             devInterface.dbcc_classguid.Data4[3],
                             devInterface.dbcc_classguid.Data4[4],
                             devInterface.dbcc_classguid.Data4[5],
                             devInterface.dbcc_classguid.Data4[6],
                             devInterface.dbcc_classguid.Data4[7]));
                } else {
                    //
                    // If this fails, we need to default to the old functionality!
                    // ISSUE: jsenior
                    //
                }
            }
            CloseHandle(hHubDevice);
        }
    }

    //
    // Set the Icon to an exclamation mark
    //
    if (NULL == (hIcon = LoadIcon(NULL, (LPTSTR) IDI_EXCLAMATION)) ||
        NULL == (hExclamation = GetDlgItem(hWnd, IDC_ICON_POWER))) {
        return FALSE;
    }
    SendMessage((HWND) hExclamation, STM_SETICON, (WPARAM) hIcon, NULL);

    //
    // Get a persistent handle to the tree view control
    //
    if (NULL == (hTreeDevices = GetDlgItem(HWnd, IDC_TREE_HUBS))) {
        return FALSE;
    }

    TreeView_SetImageList(hTreeDevices, ImageList.ImageList(), TVSIL_NORMAL);

    return Refresh();
}

PUSB_ACQUIRE_INFO
UsbPopup::GetHubName(WMIHANDLE WmiHandle,
                     UsbString InstanceName,
                     PUSB_CONNECTION_NOTIFICATION ConnectionNotification)
{
    ULONG                res, size;
    PUSB_ACQUIRE_INFO    usbAcquireInfo;

    //
    // zero all the vars, get the controllers name
    //
    size = ConnectionNotification->HubNameLength * sizeof(WCHAR)
            + sizeof(USB_ACQUIRE_INFO);
    usbAcquireInfo = (PUSB_ACQUIRE_INFO) LocalAlloc(LMEM_ZEROINIT, size);
    if (!usbAcquireInfo) {
        USBERROR((_T("Acquire info allocation failed.")));
        return NULL;
    }
    usbAcquireInfo->NotificationType = AcquireHubName;
    usbAcquireInfo->TotalSize = size;

    res = WmiExecuteMethod(WmiHandle,
                           InstanceName.c_str(),
                           AcquireHubName,
                           size,
                           usbAcquireInfo,
                           &size,
                           usbAcquireInfo
                           );

    if (res != ERROR_SUCCESS) {
        usbAcquireInfo = (PUSB_ACQUIRE_INFO) LocalFree(usbAcquireInfo);
    }
    return usbAcquireInfo;
}

BOOLEAN
UsbPopup::GetBusNotification(WMIHANDLE WmiHandle,
                             PUSB_BUS_NOTIFICATION UsbBusNotification)
{
    ULONG res, size;

    memset(UsbBusNotification, 0, sizeof(USB_BUS_NOTIFICATION));
    UsbBusNotification->NotificationType = AcquireBusInfo;
    size = sizeof(USB_BUS_NOTIFICATION);

    res = WmiExecuteMethod(WmiHandle,
                           InstanceName.c_str(),
                           AcquireBusInfo,
                           size,
                           UsbBusNotification,
                           &size,
                           UsbBusNotification
                           );

    if (res != ERROR_SUCCESS) {
        return FALSE;
    }
    return TRUE;
}

PUSB_ACQUIRE_INFO
UsbPopup::GetControllerName(WMIHANDLE WmiHandle,
                            UsbString InstanceName)
{
    ULONG                res, size;
    USB_BUS_NOTIFICATION usbBusNotification;
    PUSB_ACQUIRE_INFO    usbAcquireInfo;

    memset(&usbBusNotification, 0, sizeof(USB_BUS_NOTIFICATION));
    usbBusNotification.NotificationType = AcquireBusInfo;
    size = sizeof(USB_BUS_NOTIFICATION);

    res = WmiExecuteMethod(WmiHandle,
                           InstanceName.c_str(),
                           AcquireBusInfo,
                           size,
                           &usbBusNotification,
                           &size,
                           &usbBusNotification
                           );

    if (res != ERROR_SUCCESS) {
        return NULL;
    }

    //
    // zero all the vars, get the controllers name
    //
    size = usbBusNotification.ControllerNameLength * sizeof(WCHAR)
            + sizeof(USB_ACQUIRE_INFO);
    usbAcquireInfo = (PUSB_ACQUIRE_INFO) LocalAlloc(LMEM_ZEROINIT, size);
    usbAcquireInfo->NotificationType = AcquireControllerName;
    usbAcquireInfo->TotalSize = size;


    res = WmiExecuteMethod(WmiHandle,
                           InstanceName.c_str(),
                           AcquireControllerName,
                           size,
                           usbAcquireInfo,
                           &size,
                           usbAcquireInfo
                           );

    if (res != ERROR_SUCCESS) {
        usbAcquireInfo = (PUSB_ACQUIRE_INFO) LocalFree(usbAcquireInfo);
    }
    return usbAcquireInfo;
}

BOOL
UsbPopup::OnDeviceChange(HWND hDlg,
                         WPARAM wParam,
                         PDEV_BROADCAST_HDR devHdr)
{
    PDEV_BROADCAST_DEVICEINTERFACE devInterface =
        (PDEV_BROADCAST_DEVICEINTERFACE) devHdr;
    USBTRACE((_T("Device change notification, type %x."), wParam));
    switch (wParam) {
    case DBT_DEVICEARRIVAL:
        USBTRACE((_T("Device arrival.")));
        if (devHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) {
            USBTRACE((_T("Device: %s"),devInterface->dbcc_name));
            // New device arrival.
            // Compare the device description of this puppy to that of the one
            // that we have.
            //
            if (devInterface->dbcc_name == ConfigInfo->deviceDesc &&
                deviceState == DeviceDetachedError) {
                USBTRACE((_T("Device name match on arrival!")));
                //
                // The device has been reattached!
                //
                deviceState = DeviceReattached;
                Refresh();
            }
        }
        break;
    case DBT_DEVICEREMOVECOMPLETE:
        USBTRACE((_T("Device removal.")));
        if (devHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) {
            USBTRACE((_T("Device: %s"),devInterface->dbcc_name));
            // New device arrival.
            // Compare the device description of this puppy to that of the one
            // that we have.
            //
            if (devInterface->dbcc_name == ConfigInfo->deviceDesc &&
                deviceState == DeviceAttachedError) {
                USBTRACE((_T("Device name match on remove!")));
                //
                // The device has been reattached!
                //
                deviceState = DeviceDetachedError;
                Refresh();
            }
        }
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\alloc.cpp ===
#include "pch.h"
#pragma hdrstop

#include "alloc.h"
#include "except.h"


void * __cdecl operator new(
    size_t size
    )
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}

void* __cdecl operator new[] (size_t size)
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}


void __cdecl operator delete(
    void *ptr
    )
{
    if (NULL != ptr)
        LocalFree(ptr);
}


void __cdecl operator delete[] (void* ptr)
{
    if (NULL != ptr)
        LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\vec.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       VEC.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _VEC_H
#define _VEC_H

//#include "debug.h"
#include <assert.h>

template<class T>
class _VecElement {
public:
    _VecElement() { data = NULL; next = NULL; prev = NULL; }
    _VecElement(T& newElement, _VecElement* oldElement) {
        data = new T;
        assert(data);
        *data = newElement;
//        CopyMemory(data, &newElement, sizeof(T));
        next = oldElement;
        prev = NULL;
        if (oldElement) { oldElement->prev = this; } }
    ~_VecElement() { 
        if (prev) { prev->next = next; }
        if (next) { next->prev = prev; }
        delete data; 
        data = NULL; }
    T* GetData() { return data; }
    _VecElement* GetNext() { return next; }
    
private:
    T* data;
    _VecElement *next;
    _VecElement *prev;
};

template<class T>
class _Vec {
public:
    _Vec() { first = NULL; current = NULL; }
    ~_Vec() { clear(); }
    void clear() { 
        if (first) {
            _VecElement<T> *temp = first->GetNext(); 
            for ( ; first; first = temp) { 
                temp = first->GetNext();
                delete first; } }
        }
    void push_back(T &element) { 
        first = new _VecElement<T>(element, first);
        assert(first); }
    T* begin() { 
        current = first; 
        return current ? current->GetData() : NULL; }
    T* next() { 
        current = current->GetNext();
        return Current(); }
    T* Current() { return current ? current->GetData() : NULL; }
    void eraseCurrent() { 
        if (current == first && first) { first = first->GetNext(); } 
        delete current; 
        current = first; }
    BOOL empty() { return first ? FALSE : TRUE; }

private:
    _VecElement<T>* first;
    _VecElement<T>* current;
};

#endif // _VEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbutil.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBUTIL.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef _USBUTIL_H_
#define _USBUTIL_H_

#include <windows.h>

BOOL SetTextItem (HWND hWnd,
                  int ControlItem,
                  int StringItem);
BOOL SetTextItem (HWND hWnd,
                  int ControlItem,
                  TCHAR *s);
BOOL StrToGUID( LPSTR str, GUID *pguid );

#endif // _USBUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\alloc.h ===
#ifndef _INC_DSKQUOTA_ALLOC_H
#define _INC_DSKQUOTA_ALLOC_H
//////////////////////////////////////////////////////////////////////////////
/*  File: alloc.h

    Description: Installs a "new handler" that throws CAllocException
        when a memory allocation request fails.  Required since our
        compiler doesn't throw bad_alloc on memory alloc failures.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

//
// Declarations for overloading global new and delete.
//
void * __cdecl operator new(size_t size);
void __cdecl operator delete(void *ptr);
void * __cdecl operator new[](size_t size);
void __cdecl operator delete[](void *ptr);



#endif // _INC_DSKQUOTA_ALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\usb\usbutil.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       USBUTIL.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "usbutil.h"

extern HINSTANCE gHInst;

BOOL 
SetTextItem (HWND hWnd,
             int ControlItem,
             TCHAR *s)
{
    HWND control;

    if (NULL == (control = GetDlgItem(hWnd, ControlItem))) {
        return FALSE;
    }
    return SetWindowText(control, s);
}

BOOL
SetTextItem (HWND hWnd,
             int ControlItem,
             int StringItem)
{
    TCHAR buf[1000];

    if ( !LoadString(gHInst, StringItem, buf, 1000)) {
        return FALSE;
    }
    return SetTextItem(hWnd, ControlItem, buf);
}

/*
 * strToGUID
 *
 * converts a string in the form xxxxxxxx-xxxx-xxxx-xx-xx-xx-xx-xx-xx-xx-xx
 * {36FC9E60-C465-11CF-8056-444553540000}
 * into a guid
 */
BOOL StrToGUID( LPSTR str, GUID * pguid )
{
    int         idx;
    LPSTR       ptr;
    LPSTR       next;
    DWORD       data;
    DWORD       mul;
    BYTE        ch;
    BOOL        done;
    int         count;

    idx = 0;
    done = FALSE;
    if (*str == '{') {
        str++;
    }
    while( !done )
    {
    	/*
    	 * find the end of the current run of digits
    	 */
        ptr = str;
        if (idx < 3 || idx == 4) {
            while( (*str) != '-' && (*str) != 0 ) {
                str++;
            }
            if( *str == 0 || *str == '}') {
                done = TRUE;
            } else {
                next = str+1;
            }
        } else if (idx == 3 || idx > 4) {
            for( count = 0; (*str) != 0 && count < 2; count++ ) {
                str++;
            }
            if( *str == 0 || *str == '}') {
                done = TRUE;
            } else {
                next = str;
            }
        }
    
    	/*
    	 * scan backwards from the end of the string to the beginning,
    	 * converting characters from hex chars to numbers as we go
    	 */
    	str--;
    	mul = 1;
    	data = 0;
    	while(str >= ptr) {
    	    ch = *str;
    	    if( ch >= 'A' && ch <= 'F' ) {
                data += mul * (DWORD) (ch-'A'+10);
    	    } else if( ch >= 'a' && ch <= 'f' ) {
    		    data += mul * (DWORD) (ch-'a'+10);
    	    } else if( ch >= '0' && ch <= '9' ) {
    		    data += mul * (DWORD) (ch-'0');
    	    } else {
    		    return FALSE;
            }
    	    mul *= 16;
    	    str--;
    	}
    
    	/*
    	 * stuff the current number into the guid
    	 */
    	switch( idx )
    	{
    	case 0:
    	    pguid->Data1 = data;
    	    break;
    	case 1:
    	    pguid->Data2 = (WORD) data;
    	    break;
    	case 2:
    	    pguid->Data3 = (WORD) data;
    	    break;
    	default:
    	    pguid->Data4[ idx-3 ] = (BYTE) data;
    	    break;
    	}
    
    	/*
    	 * did we find all 11 numbers?
    	 */
    	idx++;
    	if( idx == 11 )
    	{
    	    if( done ) {
    		    return TRUE;
    	    } else {
                return FALSE;
    	    }
    	}
    	str = next;
    }
    return FALSE;

} /* strToGUID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\autoptr.h ===
#ifndef _INC_DSKQUOTA_AUTOPTR_H
#define _INC_DSKQUOTA_AUTOPTR_H
///////////////////////////////////////////////////////////////////////////////
/*  File: autoptr.h

    Description: Template auto pointer classes to support normal C++ pointers
        as well as shell and COM object pointers.

        This code was created by DavePl for the Entertainment Center project.
        It worked very well so I've "borrowed" it (thanks Dave).  I think his
        original implementation borrowed from the STL implementation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////


// a_ptr
//
// Safe pointer class that knows to delete the referrent object when
// the pointer goes out of scope or is replaced, etc.

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4284)

template<class _TYPE> class a_ptr
{
public:

    typedef _TYPE element_type;

    a_ptr(_TYPE *_P = 0)
            : _Owns(_P != 0), _Ptr(_P)
    {}

    typedef _TYPE _U;

    a_ptr(const a_ptr<_U>& _Y) : _Owns(_Y._Owns), _Ptr((_TYPE *)_Y.disown())
    {}

    virtual void nukeit() = 0
    {
    }

    a_ptr<_TYPE>& operator=(const a_ptr<_U>& _Y)
    {
        if ((void *)this != (void *)&_Y)
        {
            if (_Owns)
                nukeit();
            _Owns = _Y._Owns;
            _Ptr = (_TYPE *)_Y.disown();

//            ASSERT( !_Owns || _Ptr );
        }
        return (*this);
    }

    a_ptr<_TYPE>& replace(const a_ptr<_U>& _Y)
    {
        return *this = _Y;
    }

    virtual ~a_ptr()
    {
    }

    operator _TYPE*()
    {
        return get();
    }

    operator const _TYPE*() const
    {
        return get();
    }

    _TYPE& operator*() const
    {
        return (*get());
    }

    _TYPE *operator->() const
    {
        return (get());
    }

    _TYPE *get() const
    {
        return (_Ptr);
    }

    _TYPE *disown() const
    {
        ((a_ptr<_TYPE> *)this)->_Owns = FALSE;
        return (_Ptr);
    }

    _TYPE ** getaddr()
    {
        *this = (_TYPE *) NULL;
        _Owns = TRUE;
        return (&_Ptr);
    }

protected:

    BOOL _Owns;
    _TYPE *_Ptr;
};

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4284)
#endif

// autoptr
//

template<class _TYPE>
class autoptr : public a_ptr<_TYPE>
{
    virtual void nukeit()
    {
        delete _Ptr;
    }

public:

    ~autoptr()
    {
        if (_Owns)
            this->nukeit();
    }

    autoptr(_TYPE *_P = 0)
        : a_ptr<_TYPE>(_P)
    {
    }

};


template<class _TYPE>
class array_autoptr : public a_ptr<_TYPE>
{
    virtual void nukeit()
    {
        if (_Ptr)
            delete[] _Ptr;
    }

public:

    ~array_autoptr()
    {
        if (_Owns)
            this->nukeit();
    }

    array_autoptr(_TYPE *_P = 0)
        : a_ptr<_TYPE>(_P)
    {
    }

};



// sh_autoptr
//
// Smart pointer that manually runs the referent's destructor and then
// calls the shell's task allocator to free the object's memory footprint

template<class _TYPE>
class sh_autoptr : virtual public a_ptr<_TYPE>
{
    virtual void nukeit()
    {
        if (_Ptr)
        {
            IMalloc *pMalloc;
            _Ptr->~_TYPE();
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free(_Ptr);
                pMalloc->Release();
            }
        }
    }

public:

    ~sh_autoptr()
    {
        if (_Owns)
            this->nukeit();
    }

    sh_autoptr(_TYPE *_P = 0)
        : a_ptr<_TYPE>(_P)
    {
    }

};

// com_autoptr (nothing to do with ole automation... its an automatic ole ptr)
//
// Smart pointer that calls disown() on the referent when the pointer itself
// goes out of scope

template<class _TYPE>
class com_autoptr : public a_ptr<_TYPE>
{
    virtual void nukeit()
    {
        if (_Ptr)
            _Ptr->Release();
    }

public:

    ~com_autoptr()
    {
        if (_Owns)
            this->nukeit();
    }

    com_autoptr(_TYPE *_P = 0)
        : a_ptr<_TYPE>(_P)
    {
    }

};


#endif // _INC_DSKQUOTA_AUTOPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\dblnul.cpp ===
#include "pch.h"
#pragma hdrstop

#include "dblnul.h"

//
// Use of Zero-initialized memory keeps us from having to add nul terminators.
//

bool
DblNulTermList::AddString(
    LPCTSTR psz,            // String to copy.
    int cch                 // Length of psz in chars (excl nul term).
    )
{
    while((m_cchAlloc - m_cchUsed) < (cch + 2))
    {
        if (!Grow())
            return false;
    }
    DBGASSERT((NULL != m_psz));
    if (NULL != m_psz)
    {
        lstrcpy(m_psz + m_cchUsed, psz);
        m_cchUsed += cch + 1;
        m_cStrings++;
        return true;
    }
    return false;
}



bool
DblNulTermList::Grow(
    void
    )
{
    DBGASSERT((NULL != m_psz));
    DBGASSERT((m_cchGrow > 0));
    int cb = (m_cchAlloc + m_cchGrow) * sizeof(TCHAR);
    LPTSTR p = new TCHAR[cb];
    if (NULL != p)
    {
        ZeroMemory(p, cb);
        if (NULL != m_psz)
        {
            CopyMemory(p, m_psz, m_cchUsed * sizeof(TCHAR));
            delete[] m_psz;
        }
        m_psz = p;
        m_cchAlloc += m_cchGrow;
    }
    return NULL != m_psz;
}


#if DBG
void 
DblNulTermList::Dump(
    void
    ) const
{
    DBGERROR((TEXT("Dumping nul term list iter -------------")));
    DblNulTermListIter iter = CreateIterator();
    LPCTSTR psz;
    while(iter.Next(&psz))
        DBGERROR((TEXT("%s"), psz ? psz : TEXT("<null>")));
}

#endif


bool
DblNulTermListIter::Next(
    LPCTSTR *ppszItem
    )
{
    if (*m_pszCurrent)
    {
        *ppszItem = m_pszCurrent;
        m_pszCurrent += lstrlen(m_pszCurrent) + 1;
        return true;
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\bitset.cpp ===
#include "pch.h"
#pragma hdrstop

#include "bitset.h"


BitSet::BitSet(
    int cBits
    ) : m_pBuffer(NULL),
        m_cBits(0),
        m_cSet(0),
        m_cElements(0)
{
    Initialize(cBits);
}


BitSet::BitSet(
    const BitSet& rhs
    ) : m_pBuffer(NULL),
        m_cBits(0),
        m_cSet(0),
        m_cElements(0)
{
    *this = rhs;
}

BitSet& 
BitSet::operator = (
    const BitSet& rhs
    )
{
    if (this != &rhs)
    {
        Initialize(rhs.m_cBits);
        for (int i = 0; i < m_cElements; i++)
        {
            m_pBuffer[i] = rhs.m_pBuffer[i];
        }
    }
    return *this;
}


BitSet::~BitSet(
    void
    )
{
    delete [] m_pBuffer;
}


void
BitSet::Initialize(
    int cBits
    )
{
    delete [] m_pBuffer;
    m_cSet      = 0;
    m_cBits     = cBits;
    m_cElements = ElementInBuffer(m_cBits) + 1;
    m_pBuffer   = new ELEMENT_TYPE[m_cElements];
    ClrAll();
}


bool 
BitSet::GetBitState(
    int iBit
    ) const
{
    ValidateBitNumber(iBit);

    int iElement   = ElementInBuffer(iBit);
    bool bBitState = false;

    ELEMENT_TYPE mask = MaskFromBit(iBit);
    bBitState = (*(m_pBuffer + iElement) & mask) != 0;

    return bBitState;
}


void 
BitSet::SetBitState(
    int iBit,
    bool bSet
    )
{
    ValidateBitNumber(iBit);

    int iElement = ElementInBuffer(iBit);

    ELEMENT_TYPE mask = MaskFromBit(iBit);
    if (bSet)
    {
        *(m_pBuffer + iElement) |= mask;
        m_cSet++;
    }
    else
    {
        *(m_pBuffer + iElement) &= ~mask;
        m_cSet--;
    }
}

void 
BitSet::Complement(
    void
    )
{
    for (int i = 0; i < m_cElements; i++)
    {
        m_pBuffer[i] = ~m_pBuffer[i];
    }
    m_cSet = CountClr();
}

#if DBG
void 
BitSet::Dump(
    void
    ) const
{
#define BitSetOUT(s)  *pszOut++ = TEXT('\r'); \
                      *pszOut++ = TEXT('\n'); \
                      *pszOut++ = TEXT('\0'); \
                      OutputDebugString(s)

    TCHAR szOut[80];
    LPTSTR pszOut = szOut;
    const TCHAR szBits[] = TEXT("01");
    for (int i = 0; i < m_cBits; i++)
    {
        if (i % 8 == 0)
        {
            if (i % 32 == 0)
            {
                BitSetOUT(szOut);
                pszOut = szOut;
            }
            else
                *pszOut++ = TEXT(' ');
        }
        *pszOut++ = szBits[int(GetBitState(i))];
    }
    BitSetOUT(szOut);
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\bitset.h ===
#ifndef _INC_DSKQUOTA_BITSET_H
#define _INC_DSKQUOTA_BITSET_H

#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif

//
// Macros & Constants
//
// ELEMENT_TYPE
//      This macro defines the type of each "element" in the bit buffer.
//      This type must be an integral type that can be used as an operand
//      in bitwise expressions.  If it is changed, the macros
//      ELEMENT_BITNUM_MASK and ELEMENT_SHIFT must also be changed as
//      follows:
//
//      ELEMENT_TYPE     ELEMENT_BITNUM_MASK     ELEMENT_SHIFT
//      ---------------- ----------------------- -------------------
//      BYTE             0x00000007              3
//      WORD             0x0000000F              4
//      DWORD            0x0000001F              5
//
// ELEMENT_BITNUM_MASK
//      This macro defines the mask used to extract the number of the
//      bit in the array element from the number of the bit being accessed.
//
// ELEMENT_SHIFT
//      This macro defines the number of bits to right shift the bit number
//      to obtain the number of the array element.
//
//
#define ELEMENT_TYPE            BYTE
const int ELEMENT_BITNUM_MASK = 0x00000007;  
const int ELEMENT_SHIFT       = 3;

//
// Forward declaration.
//
class BitSet;

//
// This is a "helper" class that aids BitSet::operator[].  So that 
// BitSet::operator[] functions properly for both lvalue and rvalue
// conditions, it returns a "Bit" object.  The bit object retains the
// bit number and a pointer to the "owner" BitSet object.  It also 
// overloads the bool conversion operator and assignment operator.
// Knowing the bit number and the owner BitSet, the class can set or 
// obtain the value of the bit in the BitSet's array.
//
class Bit 
{
    public:
        Bit(int iBit, BitSet *pOwnerSet = NULL)
            : m_iBit(iBit),
              m_pOwnerSet(pOwnerSet) { }

        Bit(Bit& bit)
            : m_iBit(bit.m_iBit),
              m_pOwnerSet(bit.m_pOwnerSet) { }

        //
        // Convert value of bit to a bool.
        //
        operator bool () const;

        //
        // Set bit to a bool value.
        //
        bool operator = (bool bState);

    private:
        DWORD m_iBit;        // Number of bit in BitSet [0 to n-1]
        BitSet *m_pOwnerSet; // Ptr to BitSet object.
};


class BitSet 
{
    public:
        BitSet(int cBits = 1);
        ~BitSet(void);

        BitSet(const BitSet& rhs);
        BitSet& operator = (const BitSet& rhs);

        void Initialize(int cBits);

        int Count(void) const
            { return m_cBits; }

        int CountSet(void) const
            { return m_cSet; }

        int CountClr(void) const
            { return m_cBits - m_cSet; }

        bool IsSet(int iBit) const
            { return GetBitState(iBit); }

        bool IsClr(int iBit) const
            { return !GetBitState(iBit); }

        void Complement(void);

        //
        // SetBitState and GetBitState are the fastest
        // ways to alter or retrieve the state of a bit.
        //
        void SetBitState(int iBit, bool bSet);
        bool GetBitState(int iBit) const;

        //
        // Set and Clr are the next fastest ways to alter
        // or retrieve the state of a bit.
        //
        void Set(int iBit)
            { SetBitState(iBit, TRUE); }
        void Clr(int iBit)
            { SetBitState(iBit, FALSE); }

        //
        // Using the subscript operator is the slowest way
        // to alter/retrieve the state of a bit.
        //
        Bit operator [] (int iBit)
            { return Bit(iBit, this); }

        void ClrAll(void)
            { ZeroMemory(m_pBuffer, sizeof(ELEMENT_TYPE) * m_cElements); m_cSet = 0; }
        void SetAll(void)
            { FillMemory(m_pBuffer, sizeof(ELEMENT_TYPE) * m_cElements, (BYTE)0xFF); m_cSet = m_cBits; }

#if DBG
        void Dump(void) const;
#endif

    private:
        ELEMENT_TYPE *m_pBuffer;    // Array of elements.
        int m_cBits;     // Bits supported in set.
        int m_cSet;      // Number of bits set to '1'.
        int m_cElements; // Number of elements in array.

        //
        // Inline functions for calculating bit/element positions in array.
        //
        DWORD BitInElement(int iBit) const
            { return (iBit & ELEMENT_BITNUM_MASK); }

        DWORD ElementInBuffer(int iBit) const
            { return (iBit >> ELEMENT_SHIFT); }

        ELEMENT_TYPE MaskFromBit(int iBit) const
            { return 1 << BitInElement(iBit); }

        void ValidateBitNumber(int iBit) const
            { 
                if (iBit >= m_cBits)
                    throw CMemoryException(CMemoryException::index);
            }

        friend class Bit;
};

inline
Bit::operator bool () const
{
	return m_pOwnerSet->GetBitState(m_iBit); 
}

inline bool 
Bit::operator = (bool bState)
{
    m_pOwnerSet->SetBitState(m_iBit, bState);
	return bState;
}




#endif // _INC_DSKQUOTA_BITSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\carray.h ===
#ifndef _INC_DSKQUOTA_CARRAY_H
#define _INC_DSKQUOTA_CARRAY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: carray.h

    Description: Template class CArray.  Implements a dynamic array class.

        Much of the functionality is based on the feature set of MFC's 
        CArray class.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/16/97    Initial creation.                                    BrianAu
    12/13/97    Changed SetAtGrow to return true/false.  True means  BrianAu
                had to grow array.
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_DEBUG_H
#   include "debug.h"
#endif
#ifndef _INC_DSKQUOTA_THDSYNC_H
#   include "thdsync.h"
#endif
#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif
 

template <class T>
class CArray
{
    public:
        CArray<T>(VOID);
        explicit CArray<T>(INT cItems);
        CArray<T>(const CArray<T>& rhs);
        CArray<T>& operator = (const CArray<T>& rhs);

        virtual ~CArray<T>(VOID);

        VOID SetAt(const T& item, INT i);
        bool SetAtGrow(const T& item, INT i);
        T GetAt(INT i) const;
        VOID Insert(const T& item, INT i = -1);
        VOID Append(const T& item, INT i = -1);
        INT Find(const T& key);
        VOID Delete(INT i);

        T operator [] (INT i) const;
        T& operator [] (INT i);

        VOID Clear(VOID);

        BOOL IsEmpty(VOID) const
            { return 0 == m_cItems; }

        INT Count(VOID) const
            { return m_cItems; }

        INT UpperBound(VOID) const
            { return m_cItems - 1; }

        INT Size(VOID) const
            { return m_cAlloc; }

        VOID SetGrow(INT cGrow)
            { m_cGrow = cGrow; }

        VOID Copy(const CArray<T>& rhs);

        VOID Append(const CArray<T>& rhs);

        VOID SetSize(INT cEntries, INT iShift = -1);

        VOID Lock(VOID)
            { m_cs.Enter(); }

        VOID ReleaseLock(VOID)
            { m_cs.Leave(); }

    protected:
        static INT DEFGROW; // Default growth value.

    private:
        INT m_cAlloc;           // Number of entry allocations.
        INT m_cItems;           // Number of used entries.
        INT m_cGrow;
        T *m_rgItems;           // Array of entries.
        mutable CCriticalSection m_cs;  // For multi-threaded access.

        template <class U>
        const U& MIN(const U& a, const U& b) const
        {
            return a < b ? a : b;
        }

        template <class U>
        const U& MAX(const U& a, const U& b) const
        {
            return a > b ? a : b;
        }
};

template <class T>
INT CArray<T>::DEFGROW = 8;

template <class T>
CArray<T>::CArray(
    void
    ) : m_cAlloc(0),
        m_cItems(0),
        m_cGrow(DEFGROW),
        m_rgItems(NULL)
{

}

template <class T>
CArray<T>::CArray(
    INT cItems
    ) : m_cAlloc(0),
        m_cItems(0),
        m_cGrow(DEFGROW),
        m_rgItems(NULL)
{
    SetSize(cItems);
    m_cItems = cItems;
}

template <class T>
CArray<T>::CArray(
    const CArray& rhs
    ) : m_cAlloc(0),
        m_cItems(0),
        m_cGrow(DEFGROW),
        m_rgItems(NULL)
{
    *this = rhs;
}

template <class T>
VOID
CArray<T>::Copy(
    const CArray<T>& rhs
    )
{
    AutoLockCs lock1(rhs.m_cs);
    AutoLockCs lock2(m_cs);

    //
    // Place *this in an empty state in case Grow() throws an exception.
    // It should still be a valid CArray object.
    //
    delete[] m_rgItems;
    m_rgItems = NULL;
    m_cAlloc  = 0;
    m_cItems  = 0;

    //
    // Size the object to hold the source array.
    //
    SetSize(rhs.m_cAlloc);

    //
    // Copy the contents.
    //
    DBGASSERT((m_cAlloc >= rhs.m_cItems));
    for (m_cItems = 0; m_cItems < rhs.m_cItems; m_cItems++)
    {
        //
        // This assignment could throw an exception so only update
        // our item count after each successful copy.
        //
        DBGASSERT((m_cItems < m_cAlloc));
        m_rgItems[m_cItems] = rhs.m_rgItems[m_cItems];
    }
}


template <class T>
VOID 
CArray<T>::Append(
    const CArray<T>& rhs
    )
{
    AutoLockCs lock1(rhs.m_cs);
    AutoLockCs lock2(m_cs);

    //
    // Size the object to hold both arrays.
    //
    SetSize(m_cAlloc + rhs.m_cItems);

    //
    // Append the contents.
    //
    DBGASSERT((m_cAlloc >= (m_cItems + rhs.m_cItems)));
    for (int i = 0; i < rhs.m_cItems; i++)
    {
        DBGASSERT((m_cItems < m_cAlloc));
        m_rgItems[m_cItems++] = rhs.m_rgItems[i];
    }
}


template <class T>
CArray<T>& 
CArray<T>::operator = (
    const CArray<T>& rhs
    ) 
{
    if (this != &rhs)
    {
        Copy(rhs);
    }
    return *this;
}


template <class T>
CArray<T>::~CArray(
    VOID
    )
{
    Clear();
}



template <class T>
T CArray<T>::operator [] (
    INT i
    ) const
{
    return GetAt(i);
}


template <class T>
T& CArray<T>::operator [] (
    INT i
    )
{
    AutoLockCs lock(m_cs);

    if (i < 0 || i >= m_cItems)
        throw CMemoryException(CMemoryException::index);

    return *(m_rgItems + i);
}


template <class T>
VOID
CArray<T>::Clear(
    VOID
    )
{
    AutoLockCs lock(m_cs);
    delete[] m_rgItems;
    m_rgItems = NULL;
    m_cAlloc  = 0;
    m_cItems  = 0;
}

template <class T>
VOID
CArray<T>::Insert(
    const T& item, 
    INT i
    )
{
    AutoLockCs lock(m_cs);

    if (-1 == i)
    {
        //
        // Insert at head of array.
        //
        i = 0;
    }
    //
    // Can only insert an item before an existing item.
    //      i cannot be negative.
    //      If array is empty, i can only be 0.
    //      If array is not empty, i must be index of a valid item.
    //
    if ((0 == m_cItems && 0 != i) ||
        (0 != m_cItems && (i < 0 || i >= m_cItems)))
    {
        throw CMemoryException(CMemoryException::index);
    }

    DBGASSERT((m_cItems <= m_cAlloc));
    if (m_cItems >= m_cAlloc)
    {
        //
        // Grow the array if necessary.
        // This will also shift the elements, beginning with element 'i',
        // one element to the right.
        //
        SetSize(m_cAlloc + m_cGrow, i);
    }
    else
    {
        //
        // Growth not necessary.
        // Shift the contents of the array following the insertion point
        // one element to the right.
        //
        for (int j = m_cItems; j > i; j--)
        {
            m_rgItems[j] = m_rgItems[j-1];
        }
    }
    //
    // We've now inserted an item.
    //
    m_cItems++;
    //
    // Set the value at the inserted location.
    // This assignment could throw an exception.
    //
    SetAt(item, i);
}


template <class T>
VOID
CArray<T>::Append(
    const T& item,
    INT i
    )
{
    AutoLockCs lock(m_cs);

    if (-1 == i)
    {
        //
        // Append at end of array.
        //
        i = m_cItems - 1;
    }
    //
    // Can only append an item after an existing item.
    //      When array is empty, i can only be -1.
    //      When array is not empty, i must be index of a valid item.
    //       
    // Note: i will be -1 when m_cItems is 0.
    //
    if ((0 == m_cItems && -1 != i) ||
        (0 != m_cItems && (i < 0 || i >= m_cItems)))
    {
        throw CMemoryException(CMemoryException::index);
    }

    DBGASSERT((m_cItems <= m_cAlloc));
    if (m_cItems >= m_cAlloc)
    {
        //
        // Grow the array if necessary.
        // This will also shift the elements, beginning with element 'i + 1',
        // one element to the right.
        //
        SetSize(m_cAlloc + m_cGrow, i+1);
    }
    else
    {
        //
        // Shift the contents of the array following the insertion
        // point, one entry to the right.
        //
        for (int j = m_cItems; j > (i+1); j--)
        {
            m_rgItems[j] = m_rgItems[j-1];
        }
    }
    //
    // We've now appended an item.
    //
    m_cItems++;
    //
    // Set the value at the appended location.
    // This assignment could throw an exception.
    //
    SetAt(item, i+1);
}


template <class T>
VOID
CArray<T>::Delete(
    INT i
    )
{
    AutoLockCs lock(m_cs);

    //
    // Can only delete a valid item.
    //
    if (i < 0 || i >= m_cItems)
        throw CMemoryException(CMemoryException::index);
    //
    // Shift memory to remove the item.
    //

    for (int j = i; j < (m_cItems - 1); j++)
    {
        m_rgItems[j] = m_rgItems[j+1];
    }
    //
    // Now we have one less item.
    //
    m_cItems--;
    //
    // Shrink the array if it's required size is less than 2X the
    // array's "growth" amount.
    //
    if ((m_cAlloc - m_cItems) > (2 * m_cGrow))
    {
        SetSize(m_cItems);
    }
}

template <class T>
INT
CArray<T>::Find(
    const T& key
    )
{
    AutoLockCs lock(m_cs);

    for (INT i = 0; i < m_cItems; i++)
    {
        if (m_rgItems[i] == key)
        {
            return i;
        }
    }
    return -1;
}


template <class T>
T
CArray<T>::GetAt(
    INT i
    ) const
{
    AutoLockCs lock(m_cs);

    if (i < 0 || i >= m_cItems)
        throw CMemoryException(CMemoryException::index);

    return m_rgItems[i];
}


template <class T>
VOID
CArray<T>::SetAt(
    const T& item,
    INT i
    )
{
    AutoLockCs lock(m_cs);

    if (i < 0 || i >= m_cAlloc)
        throw CMemoryException(CMemoryException::index);

    m_rgItems[i] = item;
}


//
// Returns:  true = array was extended, false = no extension required.
//
template <class T>
bool
CArray<T>::SetAtGrow(
    const T& item,
    INT i
    )
{
    bool bGrow = false;
    AutoLockCs lock(m_cs);

    if (i >= m_cAlloc)
    {
        //
        // Need to grow the array to accomodate the new item.
        //
        SetSize(i + m_cGrow);
        bGrow = true;
    }
    //
    // Set the new item value.
    //
    SetAt(item, i);
    //
    // Extend the count of "valid" items.
    //
    m_cItems = i + 1;

    return bGrow;
}


template <class T>
VOID
CArray<T>::SetSize(
    INT cEntries,
    INT iShift          // Pass -1 for "no shift".
    )
{
    AutoLockCs lock(m_cs);

    //
    // Don't allow an array of less than 1 element.
    //
    cEntries = MAX(1, cEntries);

    T *pNew = new T[cEntries];
    if (NULL == pNew)
        throw CAllocException();

    if (NULL != m_rgItems)
    {
        INT cCopy = MIN(cEntries, m_cItems);
        INT j = 0;
        for (INT i = 0; i < cCopy; i++, j++)
        {
            //
            // Shift items [i..(n-1)] to [(i+1)..n]
            //
            if (iShift == j)
                j++;

            *(pNew + j) = m_rgItems[i];
        }
    }
    delete[] m_rgItems;
    m_rgItems = pNew;
    m_cAlloc  = cEntries;
}


template <class T>
class CQueueAsArray : public CArray<T>
{
    public:
        CQueueAsArray<T>(VOID) { }
        ~CQueueAsArray<T>(VOID) { }

        VOID Add(T& item);
        BOOL Remove(T& item);

    private:
        CQueueAsArray<T>(const CQueueAsArray<T>& rhs);
        CQueueAsArray<T>& operator = (const CQueueAsArray<T>& rhs);

};


template <class T>
VOID
CQueueAsArray<T>::Add(
    T& item
    )
{
    Append(item);
}

template <class T>
BOOL
CQueueAsArray<T>::Remove(
    T& item
    )
{
    BOOL bResult = FALSE;
    if (!IsEmpty())
    {
        INT i = UpperBound();
        item = GetAt(i);
        Delete(i);
        bResult = TRUE;
    }
    return bResult;
}



#endif // _INC_DSKQUOTA_CARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\dblnul.h ===
#ifndef _INC_DSKQUOTA_DBLNUL_H
#define _INC_DSKQUOTA_DBLNUL_H

//
// For iterating over items in a double-nul terminated list of
// text strings.
//
class DblNulTermListIter
{
    public:
        explicit DblNulTermListIter(LPCTSTR pszList)
            : m_pszList(pszList),
              m_pszCurrent(pszList) { }

        ~DblNulTermListIter(void) { }

        bool Next(LPCTSTR *ppszItem);
        void Reset(void)
            { m_pszCurrent = m_pszList; }

    private:
        LPCTSTR m_pszList;
        LPCTSTR m_pszCurrent;
};


class DblNulTermList
{
    public:
        explicit DblNulTermList(int cchGrow = MAX_PATH)
            : m_psz(new TCHAR[1]),
              m_cchAlloc(1),
              m_cchUsed(0),
              m_cStrings(0),
              m_cchGrow(cchGrow) { *m_psz = TEXT('\0'); }

        ~DblNulTermList(void)
            { delete[] m_psz; }

        bool AddString(const CString& s)
            { return AddString(s.Cstr(), s.Length()); }
        bool AddString(LPCTSTR psz)
            { return AddString(psz, psz ? lstrlen(psz) : 0); }

        int Count(void) const
            { return m_cStrings; }

        operator LPCTSTR ()
            { return m_psz; }

        DblNulTermListIter CreateIterator(void) const
            { return DblNulTermListIter(m_psz); }

#if DBG
        void Dump(void) const;
#endif

    private:
        LPTSTR m_psz;       // The text buffer.
        int    m_cchAlloc;  // Total allocation in chars.
        int    m_cchUsed;   // Total used excluding FINAL nul term.
        int    m_cchGrow;   // How much to grow each expansion.
        int    m_cStrings;  // Count of strings in list.

        bool AddString(LPCTSTR psz, int cch);
        bool Grow(void);

        //
        // Prevent copy.
        //
        DblNulTermList(const DblNulTermList& rhs);
        DblNulTermList& operator = (const DblNulTermList& rhs);
};


#endif // INC_DSKQUOTA_DBLNUL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\debugp.h ===
#ifndef _INC_DSKQUOTA_DEBUGP_H
#define _INC_DSKQUOTA_DEBUGP_H

//
// Define some application-specific debug mask values.
//
#define DM_UPROP       DBGCREATEMASK(0x00000001)
#define DM_VPROP       DBGCREATEMASK(0x00000002)
#define DM_VIEW        DBGCREATEMASK(0x00000004)
#define DM_SIDCACHE    DBGCREATEMASK(0x00000008)
#define DM_RESOLVER    DBGCREATEMASK(0x00000010)
#define DM_MAPFILE     DBGCREATEMASK(0x00000020)
#define DM_NTDS        DBGCREATEMASK(0x00000040)
#define DM_CONNPT      DBGCREATEMASK(0x00000080)
#define DM_COM         DBGCREATEMASK(0x00000100)
#define DM_CONTROL     DBGCREATEMASK(0x00000200)
#define DM_DRAGDROP    DBGCREATEMASK(0x00000400)
#define DM_FSOBJ       DBGCREATEMASK(0x00000800)
#define DM_USER        DBGCREATEMASK(0x00001000)
#define DM_UNDO        DBGCREATEMASK(0x00002000)
#define DM_PRSHTEXT    DBGCREATEMASK(0x00004000)
#define DM_SNAPIN      DBGCREATEMASK(0x00008000)
#define DM_POLICY      DBGCREATEMASK(0x00010000)
#define DM_EVENTLOG    DBGCREATEMASK(0x00020000)


#endif // _INC_DSKQUOTA_DEBUGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\debug.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: debug.cpp

    Description: Provides debugging macros to support tracing, debugger print
        statements, error message debugger output and assertions.
        
        I'm sure you're saying "why ANOTHER debugger output implementation".
        There are many around but I haven't found one that is as flexible and
        consistent as I would like.  This library suports the concept of
        both functional "masks" and detail "levels" to control the quantity
        of debugger output.
        
        Masks let you control debugger output based on program function.  For 
        instance, if you tag a DBGPRINT statement with the mask DM_XYZ, it 
        will only be activated if the global variable DebugParams::PrintMask
        has the DM_XYZ bit set.

        Levels let you control debugger output based on a level of desired 
        detail.  Sometimes you just want to see the basic functions happening 
        but other times, you need to see everything that's going on.  This 
        leveling allows you to specify at which level a macro is enabled.

        The library is designed to be activated with the DBG macro.
        If DBG is not defined as 1, there is no trace of this code in your
        product.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    01/19/98    Replaced with version from CSC cache viewer.         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#if DBG

//
// Defaults for the DebugParams members.
// By default, tracing and printing should be silent (no output).
// The default mask values of 0 ensure this.
// Also, printing and tracing are not verbose by default.
// Note that errors and asserts are always active when DBG is defined as 1.
// Errors and asserts are also always verbose.
//

LPCTSTR DebugParams::m_pszModule = TEXT("");
UINT DebugParams::TraceLevel     = 0;
UINT DebugParams::PrintLevel     = 0;
bool DebugParams::TraceVerbose   = false;
bool DebugParams::PrintVerbose   = false;
bool DebugParams::TraceOnExit    = true;
ULONGLONG DebugParams::TraceMask = 0;
ULONGLONG DebugParams::PrintMask = 0;

//
// Static default values for DebugPrint and DebugTrace classes.
//
const ULONGLONG DebugPrint::DEFMASK = (ULONGLONG)-1;
const UINT DebugPrint::DEFLEVEL     = 0;
const ULONGLONG DebugTrace::DEFMASK = (ULONGLONG)-1;
const UINT DebugTrace::DEFLEVEL     = 0;


LPCTSTR 
DebugParams::SetModule(
    LPCTSTR pszModule
    )
{
    LPCTSTR pszModulePrev = m_pszModule;
    m_pszModule = pszModule;
    return pszModulePrev;
}

void
DebugParams::SetDebugMask(
    ULONGLONG llMask
    )
{
    TraceMask = PrintMask = llMask;
}

void
DebugParams::SetDebugLevel(
    UINT uLevel
    )
{
    TraceLevel = PrintLevel = uLevel;
}

void
DebugParams::SetDebugVerbose(
    bool bVerbose
    )
{
    TraceVerbose = PrintVerbose = bVerbose;
}

void
DebugParams::SetTraceOnExit(
    bool bTrace
    )
{
    TraceOnExit = bTrace;
}


void *
DebugParams::GetItemPtr(
    DebugParams::Item item,
    DebugParams::Type type
    )
{
    //
    // Assertions are active for all levels, any program function (mask = -1)
    // and are always verbose.
    //
    static bool      bAssertVerbose = true;
    static UINT      uAssertLevel   = 0;
    static ULONGLONG llAssertMask   = DM_ALL;

    //
    // This array just eliminates the need for a lot of code when setting
    // or reading the various global DebugParam members.
    //
    static void *rgpMember[eTypeMax][eItemMax] = { { &TraceMask,  &TraceLevel,  &TraceVerbose },
                                                   { &PrintMask,  &PrintLevel,  &PrintVerbose },
                                                   { &llAssertMask,   &uAssertLevel,   &bAssertVerbose  }
                                                 };
    
    return rgpMember[type][item];
}


ULONGLONG 
DebugParams::SetMask(
    ULONGLONG llMask,
    DebugParams::Type type
    )
{
    ULONGLONG *pllMask   = (ULONGLONG *)GetItemPtr(DebugParams::eMask, type);
    ULONGLONG llMaskPrev = *pllMask;
    *pllMask = llMask;
    return llMaskPrev;
}


UINT 
DebugParams::SetLevel(
    UINT uLevel,
    DebugParams::Type type
    )
{
    UINT *puLevel = (UINT *)GetItemPtr(DebugParams::eLevel, type);
    UINT uLevelPrev = *puLevel;
    *puLevel = uLevel;
    return uLevelPrev;
}


bool 
DebugParams::SetVerbose(
    bool bVerbose,
    DebugParams::Type type
    )
{
    bool *pbVerbose = (bool *)GetItemPtr(DebugParams::eVerbose, type);
    bool bVerbosePrev = *pbVerbose;
    *pbVerbose = bVerbose;
    return bVerbosePrev;
}


DebugTrace::DebugTrace(
    LPCTSTR pszFile, 
    INT iLineNo
    ) : m_pszFile(pszFile),
        m_iLineNo(iLineNo),
        m_llMask(0),
        m_uLevel(0)
{
    //
    // Do nothing.
    //
}


void
DebugTrace::Enter(
    ULONGLONG llMask,
    UINT uLevel,
    LPCTSTR pszBlockName
    ) const
{
    DebugPrint(DebugParams::eTrace, m_pszFile, m_iLineNo).Print(m_llMask = llMask, m_uLevel = uLevel, TEXT("++ ENTER %s"), m_pszBlockName = pszBlockName);
}

void
DebugTrace::Enter(
    ULONGLONG llMask,
    UINT uLevel,
    LPCTSTR pszBlockName,
    LPCTSTR pszFmt,
    ...
    ) const
{
    va_list args;
    va_start(args, pszFmt);
    TCHAR szMsg[1024];
    wvsprintf(szMsg, pszFmt, args);
    va_end(args);
    DebugPrint(DebugParams::eTrace, m_pszFile, m_iLineNo).Print(m_llMask = llMask, m_uLevel = uLevel, TEXT("++ ENTER %s: %s"), m_pszBlockName = pszBlockName, szMsg);
}

void
DebugTrace::Enter(
    LPCTSTR pszBlockName
    ) const
{
    Enter(DebugTrace::DEFMASK, DebugTrace::DEFLEVEL, pszBlockName);
}

void
DebugTrace::Enter(
    LPCTSTR pszBlockName,
    LPCTSTR pszFmt,
    ...
    ) const
{
    va_list args;
    va_start(args, pszFmt);
    TCHAR szMsg[1024];
    wvsprintf(szMsg, pszFmt, args);
    va_end(args);
    DebugPrint(DebugParams::eTrace, m_pszFile, m_iLineNo).Print(m_llMask = DebugTrace::DEFMASK, m_uLevel = DebugTrace::DEFLEVEL, TEXT("++ ENTER %s: %s"), m_pszBlockName = pszBlockName, szMsg);
}


DebugTrace::~DebugTrace(void)
{
    if (DebugParams::TraceOnExit)
        DebugPrint(DebugParams::eTrace, m_pszFile, m_iLineNo).Print(m_llMask, m_uLevel, TEXT("-- LEAVE %s"), m_pszBlockName);
}


DebugPrint::DebugPrint(
    DebugParams::Type type,
    LPCTSTR pszFile,
    INT iLineNo
    ) : m_pszFile(pszFile),
        m_iLineNo(iLineNo),
        m_type(type)
{
    //
    // Do nothing.
    //
}


void
DebugPrint::Print(
    LPCTSTR pszFmt,
    ...
    ) const
{
    va_list args;
    va_start(args, pszFmt);
    Print(DebugPrint::DEFMASK, DebugPrint::DEFLEVEL, pszFmt, args);
    va_end(args);
}


void 
DebugPrint::Print(
    ULONGLONG llMask,
    UINT uLevel,
    LPCTSTR pszFmt,
    ...
    ) const
{
    va_list args;
    va_start(args, pszFmt);
    Print(llMask, uLevel, pszFmt, args);
    va_end(args);
}


//
// Determine if there are any corresponding bits set in two ULONGLONG
// values.  Can't just do a simple bitwise AND operation because the compiler
// truncates the operands to integer size.
//
bool
DebugPrint::AnyBitSet(
    ULONGLONG llMask,
    ULONGLONG llTest
    )
{
    ULARGE_INTEGER ulMask, ulTest;
    ulMask.QuadPart = llMask;
    ulTest.QuadPart = llTest;

    return (ulMask.LowPart & ulTest.LowPart) || (ulMask.HighPart & ulTest.HighPart);
}



//
// Internal [private] print function.
// All other print functions end up here.
//
void
DebugPrint::Print(
    ULONGLONG llMask,
    UINT uLevel,
    LPCTSTR pszFmt,
    va_list args
    ) const
{
//
// Crude check to make sure we haven't overflowed the text buffer.
// It's 1K so I don't expect it.  But if we do, it needs to be 
// announced somehow so either the buffer can be enlarged or the 
// message text reduced.  I can't use DBGASSERT because that will
// cause recursion.
//
#define CHECKOVERFLOW \
if (pszWrite >= (pszEnd - 3)) {\
    OutputDebugString(TEXT("Buffer overflow in DebugPrint::Print, File:")TEXT(__FILE__)TEXT(" Line:")TEXT("#__LINE__")); \
    DebugBreak(); }

    //
    // Retrieve the global DebugParam members for the "type" being printed.
    // i.e. ePrint, eAssert or eTrace.
    //
    ULONGLONG *pllMask = (ULONGLONG *)DebugParams::GetItemPtr(DebugParams::eMask, m_type);
    UINT *puLevel      = (UINT *)DebugParams::GetItemPtr(DebugParams::eLevel, m_type);
    bool *pbVerbose    = (bool *)DebugParams::GetItemPtr(DebugParams::eVerbose, m_type);

    if ((uLevel <= *puLevel) && AnyBitSet(llMask, *pllMask))
    {
        //
        // The statement is both "mask" and "level" enabled.
        // Generate debugger output.
        //
        TCHAR szText[1024];
        LPTSTR pszWrite = szText;
        LPCTSTR pszEnd  = pszWrite + ARRAYSIZE(szText);

        //
        // Each message has "[<module>:<thread>]" prefix.
        //
        pszWrite += wsprintf(pszWrite, 
                             TEXT("[%s:%d] "), 
                             DebugParams::m_pszModule,
                             GetCurrentThreadId());
        CHECKOVERFLOW;

        //
        // Append the message text (formatted).
        //
        pszWrite += wvsprintf(pszWrite, pszFmt, args);

        CHECKOVERFLOW;

        if (*pbVerbose)
        {
            //
            // Verbose output is desired.  Add the filename/line number pair
            // indented on the next line.
            //
            pszWrite += wsprintf(pszWrite, TEXT("\n\r\t+->File: %s, Line: %d"), m_pszFile, m_iLineNo);
        }

        CHECKOVERFLOW;

        //
        // Append a CRLF.
        //
        lstrcpy(pszWrite, TEXT("\n\r"));
        OutputDebugString(szText);
    }
}


DebugError::DebugError(
    LPCTSTR pszFile,
    INT iLineNo
    ) : DebugPrint(DebugParams::ePrint, pszFile, iLineNo)
{
    //
    // Do nothing.
    //
}

void
DebugError::Error(
    LPCTSTR pszFmt,
    ...
    ) const
{
    va_list args;
    va_start(args, pszFmt);    
    ULONGLONG llMaskSaved   = DebugParams::PrintMask;
    UINT      uLevelSaved   = DebugParams::PrintLevel;
    DebugParams::PrintMask = (ULONGLONG)-1;
    DebugParams::PrintLevel = 99999;
    Print((ULONGLONG)-1, 0, pszFmt, args);
    DebugParams::PrintLevel = uLevelSaved;
    DebugParams::PrintMask = llMaskSaved;
    va_end(args);
}        


DebugAssert::DebugAssert(
    LPCTSTR pszFile,
    INT iLineNo,
    LPCTSTR pszTest
    )
{
    DebugPrint PrintThis(DebugParams::eAssert, pszFile, iLineNo);
    ULONGLONG llMaskSaved   = DebugParams::PrintMask;
    UINT      uLevelSaved   = DebugParams::PrintLevel;
    DebugParams::PrintMask = (ULONGLONG)-1;
    DebugParams::PrintLevel = 99999;
    PrintThis.Print((ULONGLONG)-1, 0, pszTest);
    DebugParams::PrintLevel = uLevelSaved;
    DebugParams::PrintMask = llMaskSaved;
    DebugBreak();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\except.cpp ===
#include "pch.h"
#pragma hdrstop

#include "except.h"


CExceptionString::CExceptionString(
    LPCTSTR pszText
    ) : m_pszText(NULL)
{
    m_pszText = Dup(pszText);
}


CExceptionString::CExceptionString(
    const CExceptionString& rhs
    ) : m_pszText(NULL)
{
    *this = rhs;
}


CExceptionString& 
CExceptionString::operator = (
    const CExceptionString& rhs
    )
{
    if (this != &rhs)
    {
        delete[] m_pszText;
        m_pszText = Dup(rhs.m_pszText);
    }
    return *this;
}

LPTSTR
CExceptionString::Dup(
    LPCTSTR psz
    )
{
    LPTSTR pszNew = new TCHAR[lstrlen(psz) + 1];
    lstrcpy(pszNew, psz);
    return pszNew;
}    


#if DBG
//
// Don't include these strings in free builds.  Since the strings
// aren't localized, they're intended for debug output only.
//
LPCTSTR CMemoryException::m_pszReasons[] = { TEXT("alloc"), 
                                             TEXT("overflow"),
                                             TEXT("index"), 
                                             TEXT("range"),
                                             TEXT("pointer") };

LPCTSTR CFileException::m_pszReasons[] = { TEXT("create"), 
                                           TEXT("read"),
                                           TEXT("write"),
                                           TEXT("diskfull"),
                                           TEXT("access"),
                                           TEXT("device") };

LPCTSTR CSyncException::m_pszReasons[] = { TEXT("create"), 
                                           TEXT("timeout"), 
                                           TEXT("abandoned") };

LPCTSTR CSyncException::m_pszObjects[] = { TEXT("mutex"),  
                                           TEXT("critsect"), 
                                           TEXT("semaphore"), 
                                           TEXT("event"), 
                                           TEXT("thread"), 
                                           TEXT("process") };

LPCTSTR CResourceException::m_pszReasons[] = { TEXT("accelerator"), 
                                               TEXT("anicursor"), 
                                               TEXT("aniicon"),
                                               TEXT("bitmap"),
                                               TEXT("cursor"),
                                               TEXT("dialog"),
                                               TEXT("font"),
                                               TEXT("fontdir"),
                                               TEXT("group_cursor"),
                                               TEXT("group_icon"),
                                               TEXT("icon"),
                                               TEXT("menu"),
                                               TEXT("messagetable"),
                                               TEXT("rcdata"),
                                               TEXT("string"),
                                               TEXT("version") };

LPCTSTR 
CResourceException::ReasonText(
    void
    ) const
{
    static TCHAR szMsg[MAX_PATH];
    wsprintf(szMsg, TEXT("%s (id: %d)"), m_pszReasons[Type()], m_uResId );
    return szMsg;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\guidsp.h ===
#ifndef _INC_DSKQUOTA_GUIDSP_H
#define _INC_DSKQUOTA_GUIDSP_H
///////////////////////////////////////////////////////////////////////////////
/*  File: guidsp.h

    Description: Private class and interface ID declarations/definitions.
        These GUIDs are for private (dskquota project) use only and are not 
        distributed to public clients.  
        GUIDs are DEFINED if initguids.h is included prior to this header.
        Otherwise, they are declared.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    05/23/97    Added GUID_NtDiskQuotaStream                         BrianAu
    08/19/97    Reserved dispatch IID's.                             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
//
// Class IDs.
//

// {7988B573-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(CLSID_DiskQuotaUI, 
0x7988b573, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

//
// Interface IDs
//
// {7988B578-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_ISidNameResolver, 
0x7988b578, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

//
// This GUID is the unique identifier for the disk quota export/import stream.
// It's text equivalent is used as the name of the stream in the doc file.
//
// {8A44DF21-D2C9-11d0-80EA-00A0C90637D0}
DEFINE_GUID(GUID_NtDiskQuotaStream, 
0x8a44df21, 0xd2c9, 0x11d0, 0x80, 0xea, 0x0, 0xa0, 0xc9, 0x6, 0x37, 0xd0);


// {7988B575-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_DIDiskQuotaControl, 
0x7988b575, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
// {7988B57A-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_DIDiskQuotaUser, 
0x7988b57a, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
// {7988B57C-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(LIBID_DiskQuotaTypeLibrary, 
0x7988b57c, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);


//
// Events used though OLE automation.
//
// {7988B581-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_DIDiskQuotaControlEvents, 
0x7988b581, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
// {7988B580-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDDiskQuotaControlEvents,
0x7988b580, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

#ifdef POLICY_MMC_SNAPIN
//
// Used for MMC Snapin Node IDs.
//
// {313a692a-9f28-11d1-91b7-00c04fb6cbb3}
DEFINE_GUID(NODEID_DiskQuotaRoot,
0x313a692a, 0x9f28, 0x11d1, 0x91, 0xb7, 0x00, 0xc0, 0x4f, 0xb6, 0xcb, 0xb3);
// {3c58d64e-9f28-11d1-91b7-00c04fb6cbb3}
DEFINE_GUID(NODEID_DiskQuotaSettings,
0x3c58d64e, 0x9f28, 0x11d1, 0x91, 0xb7, 0x00, 0xc0, 0x4f, 0xb6, 0xcb, 0xb3);
// {E268F17A-A167-11d1-91B7-00C04FB6CBB3}
DEFINE_GUID(IID_IDiskQuotaSnapInData, 
0xe268f17a, 0xa167, 0x11d1, 0x91, 0xb7, 0x0, 0xc0, 0x4f, 0xb6, 0xcb, 0xb3);

// {A9E1E46F-A260-11d1-91B7-00C04FB6CBB3}
DEFINE_GUID(IID_ISnapInPropSheetExt, 
0xa9e1e46f, 0xa260, 0x11d1, 0x91, 0xb7, 0x0, 0xc0, 0x4f, 0xb6, 0xcb, 0xb3);
#endif // POLICY_MMC_SNAPIN

// {F82FEAC6-A340-11d1-91B8-00C04FB6CBB3}
DEFINE_GUID(IID_IDiskQuotaPolicy, 
0xf82feac6, 0xa340, 0x11d1, 0x91, 0xb8, 0x0, 0xc0, 0x4f, 0xb6, 0xcb, 0xb3);



#ifdef __USED_IN_MIDL_FILE__
//
// These guids are merely reserved for use by in dispatch.idl.
//
// {7988B57B-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(GUID_QuotaStateConstant, 
0x7988b57b, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
// {7988B57D-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(GUID_UserFilterFlags, 
0x7988b57d, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
// {7988B57E-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(GUID_NameResolutionConstant, 
0x7988b57e, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
// {7988B57F-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(GUID_InitResult, 
0x7988b57f, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);
#endif

#ifdef __DSKQUOTA_UNUSED_GUIDS__
//
// These GUIDs were allocated consecutively so it is easier to recognize them
// in the registry.
// If you need another ID for the disk quota project, take it from
// this set.  They may be used as either public or private.
//
// {7988B579-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(<<name>>, 
0x7988b579, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

#endif // __DSKQUOTA_UNUSED_GUIDS__
#endif // _INC_DSKQUOTA_GUIDSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\eventlog.h ===
#ifndef _INC_DSKQUOTA_EVENTLOG_H
#define _INC_DSKQUOTA_EVENTLOG_H
///////////////////////////////////////////////////////////////////////////////
/*  File: eventlog.h

    Description: Header for eventlog.cpp.
        See eventlog.cpp for functional description.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/14/98    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif

//
// This class provides basic NT event logging capability.  It provides only
// a subset of the full capability provided by the NT event logging APIs.
// I wanted a simple way to write messages to the event log.  No reading
// of event log entries is supported.
//
class CEventLog
{
    public:
        //
        // Number conversion formats.
        //
        enum eFmt { 
                     eFmtDec,       // Display as decimal.
                     eFmtHex,       // Display as hex
                     eFmtSysErr     // Display as win32 error text string.
                  };

        CEventLog(void)
            : m_hLog(NULL) 
              { DBGTRACE((DM_EVENTLOG, DL_MID, TEXT("CEventLog::CEventLog"))); }

        ~CEventLog(void);

        HRESULT Initialize(LPCTSTR pszEventSource);

        void Close(void);

        HRESULT ReportEvent(WORD wType,
                            WORD wCategory,
                            DWORD dwEventID,
                            PSID lpUserSid = NULL,
                            LPVOID pvRawData = NULL,
                            DWORD cbRawData = 0);

        HRESULT ReportEvent(WORD wType,
                            WORD wCategory,
                            DWORD dwEventID,
                            const CArray<CString>& rgstr,
                            PSID lpUserSid = NULL,
                            LPVOID pvRawData = NULL,
                            DWORD cbRawData = 0);

        //
        // Push replacement data onto a stack to replace the
        // %1, %2 etc. parameters in the message strings.
        //
        void Push(HRESULT hr, eFmt = eFmtDec);
        void Push(LPCTSTR psz);

    private:
        HANDLE          m_hLog;
        CArray<CString> m_rgstrText;

        static TCHAR m_szFmtDec[];
        static TCHAR m_szFmtHex[];

        //
        // Prevent copy.
        //
        CEventLog(const CEventLog& rhs);
        CEventLog& operator = (const CEventLog& rhs);
};



#endif // _INC_DSKQUOTA_EVENTLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\debug.h ===
#ifndef _INC_DSKQUOTA_DEBUG_H
#define _INC_DSKQUOTA_DEBUG_H
///////////////////////////////////////////////////////////////////////////////
/*  File: debug.h

    Description: Provides debugging macros to support tracing, debugger print
        statements, error message debugger output and assertions.
        
        I'm sure you're saying "why ANOTHER debugger output implementation".
        There are many around but I haven't found one that is as flexible and
        consistent as I would like.  This library suports the concept of
        both functional "masks" and detail "levels" to control the quantity
        of debugger output.
        
        Masks let you control debugger output based on program function.  For 
        instance, if you tag a DBGPRINT statement with the mask DM_XYZ, it 
        will only be activated if the global variable DebugParams::PrintMask
        has the DM_XYZ bit set.

        Levels let you control debugger output based on a level of desired 
        detail.  Sometimes you just want to see the basic functions happening 
        but other times, you need to see everything that's going on.  This 
        leveling allows you to specify at which level a macro is enabled.

        The library is designed to be activated with the DEBUG macro.
        If DBG is not defined as 1, there is no trace of this code in your
        product.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    01/19/98    Replaced module with version from CSC cache viewer.  BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#if DBG            // Only include file contents if DBG is defined as 1.
#   ifndef STRICT
#       define STRICT           // STRICT is required
#   endif
#   ifndef _WINDOWS_
#       include <windows.h>
#   endif
#   ifndef _INC_STDARG
#       include <stdarg.h>      // For va_list stuff.
#   endif

//
// If DBG is NOT defined as 1, none of this is included in your source.  
// The library is designed so that without DBG defined as 1, there is no trace of 
// this code in your product.
//
// The following 4 macros are placed in the program to generate debugger output.
//
// DBGTRACE  - Place at entry to function.  Will print message on entry and on exit.
// DBGPRINT  - For printing general program status messages to debugger.
// DBGERROR  - For printing error messages to debugger.
// DBGASSERT - Conventional assert macro.
//
// There are a couple of forms for the DBGTRACE and DBGPRINT macros.  The most
// basic form, assumes a mask of -1 and a level of 0.  This ensures the macro is
// enabled if any bit in the associated DebugParams mask is set and the associated
// DebugParams level is greater than 0.  The second version allows you to explicitly
// set the mask and level for the specific macro.
//
//      DBGTRACE((TEXT("MyFunction")));
//      DBGPRINT((TEXT("Thread ID = %d"), GetCurrentThreadId()));
//               |                                            |
//               +------- All args enclosed in parens (1) ----+
//
// or:
//
//      DBGTRACE((DM_REGISTRY, 2, TEXT("MyFunction")));
//      DBGPRINT((DM_REGISTRY, 2, TEXT("Thread ID = %d"), GetCurrentThreadId()));
//                     |       |
//                     |       +-- Level
//                     +-- Mask
//                     
//
// (1) So that no debug code is included in your retail product when DBG is not 
// defined as 1, the entire set of arguments to the DBGTRACE, DBGPRINT and DBGERROR macros 
// must be enclosed in parentheses.  This produces a single argument to the macro 
// which can be eliminated when DBG is not defined as 1 (See example above).
//
// The DBGERROR and DBGASSERT macros do not take mask and level arguments.  The
// mask is fixed at -1 and the level is fixed at 0 for both.
//
//
#define DBGTRACE(x)            DebugTrace _TraceThis(TEXT(__FILE__), __LINE__);  _TraceThis.Enter x
#define DBGPRINT(x)            DebugPrint(DebugParams::ePrint, TEXT(__FILE__),__LINE__).Print x
#define DBGERROR(x)            DebugError(TEXT(__FILE__),__LINE__).Error x
#define DBGASSERT(test)        ((test) ? (void)0 : DebugAssert(TEXT(__FILE__),__LINE__, TEXT("Assert failed: \"")TEXT(#test)TEXT("\"")))

//
// The following macros set the global control variables that affect the 4 debugger
// output macros.  All they do is set the static values in the DebugParams class.
// By default, DBGTRACE and DBGPRINT are silent.  You must activate them with the
// appropriate DBGxxxxxMASK macro.  DBGTRACE and DBGASSERT are always active whenever
// DBG is defined as 1.
//
// DBGMODULE        - Sets the "module name" included in debugger output.
// DBGPRINTMASK     - Sets the "mask" value applied to DBGPRINT macros.
// DBGPRINTLEVEL    - Sets the "level" value applied to DBGPRINT macros.
// DBGPRINTVERBOSE  - Controls if DBGPRINT output includes filename and line no.
// DBGTRACEMASK     - Sets the "mask" value applied to DBGTRACE macros.
// DBGTRACELEVEL    - Sets the "level" value applied to DBGTRACE macros.
// DBGTRACEVERBOSE  - Controls if DBGTRACE output includes filename and line no.
//                    This is helpful if you're tracing overloaded C++ functions.
// DBGMASK          - Sets the "mask" for both DBGPRINT and DBGTRACE macros.
//                    Same as calling DBGPRINTMASK(x) and DBGTRACEMASK(x)
// DBGLEVEL         - Sets the "level" for both DBGPRINT and DBGTRACE macros.
//                    Same as calling DBGPRINTLEVEL(x) and DBGTRACELEVEL(x)
// DBGVERBOSE       - Sets the "verbose" flag for both DBGPRINT and DBGTRACE macros.
//                    Same as calling DBGPRINTVERBOSE(x) and DBGTRACEVERBOSE(x)
// DBGTRACEONEXIT   - Enables DBGTRACE output on exit from functions.
//
#define DBGMODULE(modname)     DebugParams::SetModule(modname)
#define DBGPRINTMASK(mask)     DebugParams::SetPrintMask((ULONGLONG)mask)
#define DBGPRINTLEVEL(level)   DebugParams::SetPrintLevel(level)
#define DBGPRINTVERBOSE(tf)    DebugParams::SetPrintVerbose(tf)
#define DBGTRACEMASK(mask)     DebugParams::SetTraceMask((ULONGLONG)mask)
#define DBGTRACELEVEL(level)   DebugParams::SetTraceLevel(level)
#define DBGTRACEVERBOSE(tf)    DebugParams::SetTraceVerbose(tf)
#define DBGMASK(mask)          DebugParams::SetDebugMask((ULONGLONG)mask);
#define DBGLEVEL(level)        DebugParams::SetDebugLevel(level);
#define DBGVERBOSE(tf)         DebugParams::SetDebugVerbose(tf);
#define DBGTRACEONEXIT(tf)     DebugParams::SetTraceOnExit(tf);

//
// Pre-defined debug "levels".
// You can use whatever level values you want.  I've found that using more
// than 3 is confusing.  Basically, you want to define macro levels as
// "show me fundamental stuff", "show me more detail" and "show me everything".
// These three macros make it easier to stick to 3 levels.
// "DL_" = "Debug Level"
//
#define DL_HIGH   0  // "Show me fundamental stuff" - high priority
#define DL_MID    1  // "Show me more detail"       - mid priority
#define DL_LOW    2  // "Show me everything"        - low priority


//
// Some pre-defined debug mask values that I thought might be useful.
// These are not application-specific.  You can interpret them as you
// wish.  I've listed my interpretation in the comments.  In general,
// application function-specific mask values are more useful.  For
// example, you might create one called DM_DUMPSYMTAB to dump the
// contents of a symbol table at a specific point during execution.
// Create new mask values using the DBGCREATEMASK(x) macro defined below.
// "DM_" = "Debug Mask"
//
#define DM_NONE        (ULONGLONG)0x0000000000000000  // No debugging.
#define DM_NOW         (ULONGLONG)0x0000000000000001  // Activate temporarily
#define DM_CTOR        (ULONGLONG)0x0000000000000002  // C++ ctors and dtors
#define DM_REG         (ULONGLONG)0x0000000000000004  // Registry functions.
#define DM_FILE        (ULONGLONG)0x0000000000000008  // File accesses.
#define DM_GDI         (ULONGLONG)0x0000000000000010  // GDI functions.
#define DM_MEM         (ULONGLONG)0x0000000000000011  // Memory functions.
#define DM_NET         (ULONGLONG)0x0000000000000012  // Network functions.
#define DM_WEB         (ULONGLONG)0x0000000000000014  // Web browsing functions.
#define DM_DLG         (ULONGLONG)0x0000000000000018  // Dialog messages.
#define DM_WND         (ULONGLONG)0x0000000000000020  // Window messages.    
#define DM_ALL         (ULONGLONG)0xffffffffffffffff  // Activate always.

//
// Lower 16 bits reserved for pre-defined mask values.
// This leaves 48 mask values that the app can define.
// Use this macro to create app-specific values.
//
// i.e. 
//      #define DBGMASK_XYZ  DBGCREATEMASK(0x0001)
//      #define DBGMASK_ABC  DBCCREATEMASK(0x0002)
//
#define DBGCREATEMASK(value)  (ULONGLONG)((ULONGLONG)value << 16)

//
// Macro to print out an IID for debugging QI functions.
//
#define DBGPRINTIID(mask, level, riid) \
{ \
    TCHAR szTemp[50]; \
    StringFromGUID2(riid, szTemp, ARRAYSIZE(szTemp)); \
    DBGPRINT((mask, level, TEXT("IID = %s"), szTemp)); \
}

//
// For storing debug info in registry.
//
struct DebugRegParams
{
    ULONGLONG PrintMask;
    ULONGLONG TraceMask;
    UINT PrintLevel;    
    UINT TraceLevel;    
    bool PrintVerbose;
    bool TraceVerbose;
    bool TraceOnExit;
};
   

//
// Global debug parameters.
//
struct DebugParams
{
    //
    // Enumeration representing each of the debugging functions.
    //
    enum Type { eTrace = 0, ePrint, eAssert,  eTypeMax };
    //
    // Enumeration representing each of the debug parameters.
    //
    enum Item { eMask  = 0, eLevel, eVerbose, eItemMax };

    //
    // "Mask" that controls if a debugging function is enabled depending upon 
    // a desired function in the application domain.  Each bit in the mask 
    // corresponds to a given program function.  If at runtime, the bitwise
    // OR of this value and the "mask" value passed to the debugging function
    // is non-zero, the function is considered "mask enabled".
    // If a function is both "level enabled" and "mask enabled", it 
    // performs it's prescribed duties.
    // These values can be set by using the following macros:
    //
    //  DBGPRINTMASK(x)    - Sets mask for DBGPRINT only.
    //  DBGTRACEMASK(x)    - Sets mask for DBGTRACE only.
    //  DBGMASK(x)         - Sets mask for both.
    //
    // Note that there's no mask value for DebugAssert or DebugError.
    // These classes are always mask-enabled when DBG is defined as 1.
    //
    static ULONGLONG PrintMask;
    static ULONGLONG TraceMask;
    //
    // "Level" at which debug output is "enabled".
    // If at runtime, this value is >= the "level" value passed to the
    // debugging function, the function is considered "level enabled".
    // If a function is both "level enabled" and "mask enabled", it 
    // performs it's prescribed duties.
    // It is recommended that the set of allowable levels be limited
    // to avoid undue complexity.  The library doesn't impose a restriction
    // on allowable values.  However, I've found [0,1,2] to be sufficient.
    // These values can be set by using the following macros:
    //
    //  DBGPRINTLEVEL(x)    - Sets level for DBGPRINT only.
    //  DBGTRACELEVEL(x)    - Sets level for DBGTRACE only.
    //  DBGLEVEL(x)         - Sets level for both.
    //
    // Note that there's no level value for DebugAssert or DebugError.
    // These classes are always level-enabled when DBG is defined as 1.
    // 
    static UINT PrintLevel;    
    static UINT TraceLevel;    
    //
    // Flag to indicate if the debugger output should include the filename
    // and line number where the debug statement resides in the source file.
    // These values can be set by using the following macros:
    //
    //  DBGPRINTVERBOSE(x)  - Sets the verbose flag for DBGPRINT only.
    //  DBGTRACEVERBOSE(x)  - Sets the verbose flag for DBGTRACE only.
    //  DBGVERBOSE(x)       - Sets the verbose flag for both.
    //
    // Note that there's no verbose flag for DebugAssert or DebugError.
    // These classes always output verbose information.
    //
    static bool PrintVerbose;
    static bool TraceVerbose;
    //
    // Flag to indicate if DBGTRACE output is generated when leaving a function.
    // This value can be set by using the following macro:
    //
    //  DBGTRACEONEXIT
    //
    //      1 = Generate output [default]
    //      0 = Don't generate output.
    //
    static bool TraceOnExit;
    //
    // Address of the name string for the "current" module.  This name will be
    // included with each debugger message.  
    // It can be set using the DBGMODULE(name) macro.
    //
    static LPCTSTR m_pszModule;

    //
    // Some helper functions used by the DebugXxxxx classes.
    //
    static LPCTSTR SetModule(LPCTSTR pszModule);

    static void SetDebugMask(ULONGLONG llMask);

    static ULONGLONG SetPrintMask(ULONGLONG llMask)
        { return SetMask(llMask, ePrint); }

    static ULONGLONG SetTraceMask(ULONGLONG llMask)
        { return SetMask(llMask, eTrace); }

    static void SetDebugLevel(UINT uLevel);

    static UINT SetPrintLevel(UINT uLevel)
        { return SetLevel(uLevel, ePrint); }

    static UINT SetTraceLevel(UINT uLevel)
        { return SetLevel(uLevel, eTrace); }

    static void SetDebugVerbose(bool bVerbose);

    static bool SetPrintVerbose(bool bVerbose)
        { return SetVerbose(bVerbose, ePrint); }

    static bool SetTraceVerbose(bool bVerbose)
        { return SetVerbose(bVerbose, eTrace); }

    static void SetTraceOnExit(bool bTrace);

    static void *GetItemPtr(DebugParams::Item item, DebugParams::Type type);

    private:
        static ULONGLONG SetMask(ULONGLONG llMask, enum Type type);
        static UINT SetLevel(UINT uLevel, enum Type type);
        static bool SetVerbose(bool bVerbose, enum Type type);
};

//
// Class that prints a message an "ENTER" message upon construction
// and a "LEAVE" message upon destruction.  It is intended that the client
// place a DBGTRACE macro at the start of each function.  
// Depending on the current debug "level" and "mask" (see DebugParams),
// a message is printed to the debugger.  When the object goes out of scope,
// another message is automatically printed to the debugger.
// This class is only intended to be instantiated through the 
// DBGTRACE(x) macro.
//
class DebugTrace
{
    public:
        DebugTrace(LPCTSTR pszFile, INT iLineNo);
        ~DebugTrace(void);

        void Enter(void) const { m_llMask = (ULONGLONG)0; }
        void Enter(LPCTSTR pszBlockName) const;
        void Enter(ULONGLONG llMask, UINT uLevel, LPCTSTR pszBlockName) const;
        void Enter(LPCTSTR pszBlockName, LPCTSTR pszFmt, ...) const;
        void Enter(ULONGLONG llMask, UINT uLevel, LPCTSTR pszBlockName, LPCTSTR pszFmt, ...) const;

    private:
        INT                    m_iLineNo;        // Macro's source line number.
        LPCTSTR                m_pszFile;        // Macro's source file name.
        mutable ULONGLONG      m_llMask;         // Macro's "mask".
        mutable UINT           m_uLevel;         // Macro's "level".
        mutable LPCTSTR        m_pszBlockName;   // Ptr to string to print.
        static const ULONGLONG DEFMASK;          // Default mask for DebugTrace.
        static const UINT      DEFLEVEL;         // Default level for DebugTrace.
};


//
// Class for printing general messages to the debugger output.
// Place a DBGPRINT macro wherever you want to send interesting output to
// the debugger. Note that DebugError specifically handles error message output.
// Note that the DebugPrint class is used by the DebugAssert, DebugError
// and DebugTrace to perform debugger output.  The m_type member is used
// to identify which class the output is being produced for.
// This class is only intended to be instantiated through the 
// DBGPRINT(x) macro.
//
class DebugPrint
{
    public:
        DebugPrint(DebugParams::Type type, LPCTSTR pszFile, INT iLineNo);

        void Print(void) const { };
        void Print(LPCTSTR pszFmt, ...) const;
        void Print(ULONGLONG llMask, UINT uLevel, LPCTSTR pszFmt, ...) const;
        void Print(ULONGLONG llMask, UINT uLevel, LPCTSTR pszFmt, va_list args) const;

    private:
        INT                    m_iLineNo;    // Macro's source line number.
        LPCTSTR                m_pszFile;    // Macro's source file name.
        DebugParams::Type      m_type;       // Type of printing being done.
        static const ULONGLONG DEFMASK;      // Default mask for DebugPrint.
        static const UINT      DEFLEVEL;     // Default level for DebugPrint.

        static bool AnyBitSet(ULONGLONG llMask, ULONGLONG llTest);
};

//
// Specialization of the DebugPrint class.  It's just a DebugPrint with the
// mask fixed at -1 and the level fixed at 0 so that DBGERROR messages are 
// always output when DBG is defined as 1.  Note private inheritance prevents
// someone from calling DebugError::Print().  They must call 
// DebugError.Error() which calls DebugPrint::Print after setting a 
// default mask and level.
//
class DebugError : private DebugPrint
{
    public:
        DebugError(LPCTSTR pszFile, INT iLineNo);

        void Error(LPCTSTR pszFmt, ...) const;
};


//
// Creating a DebugAssert object automatically fires an assertion after 
// printing out the debug information.
//
class DebugAssert
{
    public:
        DebugAssert(LPCTSTR pszFile, INT iLineNo, LPCTSTR pszTest);
};


#else // DBG

#define DBGTRACE(x)
#define DBGPRINT(x)                          
#define DBGERROR(x)
#define DBGASSERT(test)
#define DBGMODULE(modname)
#define DBGPRINTMASK(mask)
#define DBGPRINTLEVEL(level)
#define DBGPRINTVERBOSE(tf)
#define DBGTRACEMASK(mask)
#define DBGTRACELEVEL(level)
#define DBGTRACEVERBOSE(tf)
#define DBGMASK(mask)
#define DBGLEVEL(level)
#define DBGVERBOSE(tf)
#define DBGTRACEONEXIT(tf)
#define DBGPRINTIID(mask, level, riid)
#endif // DBG

#endif // _INC_DSKQUOTA_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\eventlog.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: eventlog.cpp

    Description: Implements a subset of the NT event log APIs as a C++ class.
        CEventLog is intended only to provide a convenient method for writing
        NT event log messages.  No reading of event log entries is supported.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/14/98    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "eventlog.h"
#include "registry.h"

TCHAR CEventLog::m_szFmtDec[] = TEXT("%1!d!");
TCHAR CEventLog::m_szFmtHex[] = TEXT("0x%1!X!");


CEventLog::~CEventLog(
    void
    )
{
    DBGTRACE((DM_EVENTLOG, DL_MID, TEXT("CEventLog::~CEventLog")));
    Close();
}

//
// Register the specified event source.
// Note that the registry entries must already exist.
// HKLM\System\CurrentControlSet\Services\EventLog\Application\<pszEventSource>
//     Requires values "EventMessageFile" and "TypesSupported".
//
HRESULT
CEventLog::Initialize(
    LPCTSTR pszEventSource
    )
{
    DBGTRACE((DM_EVENTLOG, DL_MID, TEXT("CEventLog::Initialize")));
    if (NULL != m_hLog)
    {
        return S_FALSE;
    }

    HRESULT hr = NOERROR;
    m_hLog = RegisterEventSource(NULL, pszEventSource);
    if (NULL == m_hLog)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGERROR((TEXT("Error 0x%08X registering event source \"%s\""), hr, pszEventSource));
        DBGERROR((TEXT("Run regsvr32 on dskquota.dll")));
    }

    return hr;
}

//
// Deregister the event source.
//
void
CEventLog::Close(
    void
    )
{
    DBGTRACE((DM_EVENTLOG, DL_MID, TEXT("CEventLog::Close")));

    if (NULL != m_hLog)
    {
        DeregisterEventSource(m_hLog);
        m_hLog = NULL;
    }
}


//
// Report an event.  No replaceable parameters explicitly specified.
// If msg string contains replaceable parameters, use Push() to
// build list of replacement strings.
//
HRESULT
CEventLog::ReportEvent(
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    PSID lpUserSid,    // [optional]
    LPVOID pvRawData,  // [optional]
    DWORD cbRawData    // [optional]
    )
{
    DBGTRACE((DM_EVENTLOG, DL_MID, TEXT("CEventLog::ReportEvent")));

    if (NULL == m_hLog)
    {
        DBGERROR((TEXT("Event log not initialized")));
        return E_FAIL;
    }

    BOOL bResult = false;
    HRESULT hr = NOERROR;
    if (0 < m_rgstrText.Count())
    {
        bResult = ReportEvent(wType,
                              wCategory,
                              dwEventID,
                              m_rgstrText,
                              lpUserSid,
                              pvRawData,
                              cbRawData);
        m_rgstrText.Clear();
    }
    else
    {
        bResult = ::ReportEvent(m_hLog,
                                wType,
                                wCategory,
                                dwEventID,
                                lpUserSid,
                                0,
                                cbRawData,
                                NULL,
                                pvRawData);
    }
    if (!bResult)
    {
        //
        // Special-case ERROR_IO_PENDING.  ::ReportEvent will fail with
        // this error code even when it succeeds.  Don't know exactly why
        // but it does.  Treat this as success so we don't get unnecessary
        // debugger output.
        //
        DWORD dwError = GetLastError();
        if (ERROR_IO_PENDING != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            DBGERROR((TEXT("Error 0x%08X reporting event"), hr));
        }
    }
    return hr;
}


//
// Report an event.  Replacement strings are explicitly specified
// through an array of CString objects.
//
HRESULT
CEventLog::ReportEvent(
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    const CArray<CString>& rgstr,
    PSID lpUserSid,
    LPVOID pvRawData,
    DWORD cbRawData
    )
{
    DBGTRACE((DM_EVENTLOG, DL_MID, TEXT("CEventLog::ReportEvent [ with strings ]")));

    if (NULL == m_hLog)
    {
        DBGERROR((TEXT("Event log not initialized")));
        return E_FAIL;
    }

    HRESULT hr = NOERROR;
    int cStrings = rgstr.Count();
    array_autoptr<LPCTSTR> rgpsz;
    if (0 < cStrings)
    {
        rgpsz = new LPCTSTR[cStrings];
        for (int i = 0; i < cStrings; i++)
        {
            rgpsz[i] = rgstr[i].Cstr();
        }
    }
    if (!::ReportEvent(m_hLog,
                       wType,
                       wCategory,
                       dwEventID,
                       lpUserSid,
                       (WORD)cStrings,
                       cbRawData,
                       rgpsz.get(),
                       pvRawData))
    {
        //
        // Special-case ERROR_IO_PENDING.  ::ReportEvent will fail with
        // this error code even when it succeeds.  Don't know exactly why
        // but it does.  Treat this as success so we don't get unnecessary
        // debugger output.
        //
        DWORD dwError = GetLastError();
        if (ERROR_IO_PENDING != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            DBGERROR((TEXT("Error 0x%08X reporting event"), hr));
        }
    }
    return hr;
}


//
// Push an HRESULT value onto the stack of replacment strings.
//
void
CEventLog::Push(
    HRESULT hr,
    eFmt fmt
    )
{
    DBGTRACE((DM_EVENTLOG, DL_LOW, TEXT("CEventLog::Push [ integer ]")));

    LPTSTR pszBuffer = NULL;
    CString s;
    try
    {
        if (eFmtSysErr == fmt)
        {
            int cchLoaded = ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            NULL,
                                            HRESULT_CODE(hr),
                                            0,
                                            (LPTSTR)&pszBuffer,
                                            1,
                                            NULL);

            if (NULL != pszBuffer && 0 != cchLoaded)
            {
                s = pszBuffer;
            }
        }
        else
        {
            s.Format(eFmtDec == fmt ? m_szFmtDec : m_szFmtHex, hr);
        }
        m_rgstrText.Append(s);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Out of memory error in CEventLog::Push")));
    }
    LocalFree(pszBuffer);
}

//
// Push a string onto the stack of replacement strings.
//
void
CEventLog::Push(
    LPCTSTR psz
    )
{
    DBGTRACE((DM_EVENTLOG, DL_LOW, TEXT("CEventLog::Push [ string ]")));
    try
    {
        m_rgstrText.Append(CString(psz));
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Out of memory error in CEventLog::Push")));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\except.h ===
#ifndef _INC_DSKQUOTA_EXCEPT_H
#define _INC_DSKQUOTA_EXCEPT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: except.h

    Description: Basic exception class hierarchy.

         I shamelessly based this on the MFC exception hierarchy.

         CException
              CMemoryException        - i.e. "Out of memory", "invalid index"
              CFileException          - i.e. "device IO error"
              CSyncException          - i.e. "mutext abandoned"
              CResourceException      - i.e. "resource not found in image"
              COleException           - i.e. "some critical OLE error"
              CNotSupportedException  - i.e. "function not supported"


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/16/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif


//
// Very naive string implementation.  Just need something simple to hold
// strings in exception objects when necessary.
// Ensures proper cleanup on dtor.
// Can't use CString here (I wanted to) because that creates a circular
// reference condition between strclass.h and except.h
//
class CExceptionString 
{
    public:
        explicit CExceptionString(LPCTSTR pszText = TEXT(""));
        ~CExceptionString(void)
            { delete[] m_pszText; }

        CExceptionString(const CExceptionString& rhs);
        CExceptionString& operator = (const CExceptionString& rhs);

        const TCHAR * const GetTextPtr(void) const
            { return m_pszText; }

    private:
        LPTSTR m_pszText;

        LPTSTR Dup(LPCTSTR psz);

};

//
// Base class for all exceptions.
//
class CException
{
    public:
        enum reason { none };
        explicit CException(DWORD r) : m_reason(r) { }

        DWORD Reason(void) const { return m_reason; }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CException"); }

        virtual LPCTSTR ReasonText(void) const
            { return TEXT("Unknown"); }
#endif // DBG

    private:
        DWORD m_reason;
};

//
// Exception class representing different "bad" things associated
// with memory use.
//
class CMemoryException : public CException
{
    public:
        enum reason { alloc,        // Memory allocation failure.
                      overflow,     // Memory overflow.
                      index,        // Bad index value.
                      range,        // Value overrange for data type.
                      pointer,      // Bad pointer (i.e. NULL).
                      num_reasons
                    };
        explicit CMemoryException(reason r) : CException((DWORD)r) { }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CMemoryException"); }

        virtual LPCTSTR ReasonText(void) const
            { return m_pszReasons[Reason()]; }
    private:
        static LPCTSTR m_pszReasons[num_reasons];

#endif // DBG
};

class CAllocException : private CMemoryException
{
    public:
        CAllocException(void) : CMemoryException(CMemoryException::alloc) { }
        
#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CAllocException"); }

        virtual LPCTSTR ReasonText(void) const
            { return CMemoryException::ReasonText(); }

#endif // DBG
};

//
// Exception class representing file I/O errors.
//
class CFileException : public CException
{
    public:
        enum reason { create,       // Can't create file.
                      read,         // Can't read file.
                      write,        // Can't write file.
                      diskfull,     // Disk is full.
                      access,       // No access.
                      device,       // Device write error.
                      num_reasons
                    };

        CFileException(reason r, LPCTSTR pszFile, DWORD dwIoError) 
            : CException((DWORD)r),
              m_strFile(pszFile),
              m_dwIoError(dwIoError) { }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CFileException"); }

        virtual LPCTSTR ReasonText(void) const
            { return m_pszReasons[Reason()]; }
#endif // DBG

        const TCHAR * const FileName(void) const { return m_strFile.GetTextPtr(); }
        DWORD IoError(void) const { return m_dwIoError; }

    private:
        DWORD            m_dwIoError;
        CExceptionString m_strFile;
#if DBG
        static LPCTSTR m_pszReasons[num_reasons];
#endif // DBG
};

//
// Thread synchronization object exception.
//
class CSyncException : public CException
{
    public:
        enum object { mutex, critsect, semaphore, event, thread, process, num_objects };
        enum reason { create, timeout, abandoned, num_reasons };
        CSyncException(object obj, reason r)
            : CException(r),
              m_object(obj) { }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CSyncException"); }

        virtual LPCTSTR ReasonText(void) const
            { return m_pszReasons[Reason()]; }

        virtual LPCTSTR ObjectText(void) const
            { return m_pszObjects[Object()]; }
#endif // DBG

        object Object(void) const { return m_object; }

    private:
        object m_object; 

#if DBG
        static LPCTSTR m_pszReasons[num_reasons];
        static LPCTSTR m_pszObjects[num_objects];
#endif // DBG
};


//
// Windows resource exception.
//
class CResourceException : public CException
{
    public:
        enum type { accelerator,
                    anicursor,
                    aniicon,
                    bitmap,
                    cursor,
                    dialog,
                    font,
                    fontdir,
                    group_cursor,
                    group_icon,
                    icon,
                    menu,
                    messagetable,
                    rcdata,
                    string,
                    version,
                    num_reasons };

        CResourceException(type t, HINSTANCE hInstance, UINT uResId) 
            : CException(CException::none),
              m_type(t),
              m_uResId(uResId),
              m_hInstance(hInstance) { }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CResourceException"); }

        virtual LPCTSTR ReasonText(void) const;

#endif // DBG

        HINSTANCE Module(void) const { return m_hInstance; }
        enum type Type(void) const { return m_type; }

    private:
        enum type  m_type;
        UINT       m_uResId;
        HINSTANCE  m_hInstance;

#if DBG
        static LPCTSTR m_pszReasons[num_reasons];
#endif // DBG
};


class COleException : public CException
{
    public:
        explicit COleException(HRESULT hr) 
            : CException(CException::none),
              m_hr(hr) { }

        HRESULT Result(void) const { return m_hr; }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("COleException"); }
        virtual LPCTSTR ReasonText(void) const
            { return TEXT("not applicable"); }
#endif // DBG

    private:
        HRESULT m_hr;
};


//
// Some requested operation is not supported.
//
class CNotSupportedException : public CException
{
    public:
        CNotSupportedException(void) : CException(CException::none) { }

#if DBG
        virtual LPCTSTR NameText(void) const
            { return TEXT("CNotSupportedException"); }
        virtual LPCTSTR ReasonText(void) const
            { return TEXT("not applicable"); }
#endif // DBG
};



#endif // _INC_DSKQUOTA_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\mapfile.h ===
#ifndef _INC_DSKQUOTA_MAPFILE_H
#define _INC_DSKQUOTA_MAPFILE_H

//
// Simple encapsulation of a mapped file for opening font files.
//
class MappedFile
{
    public:
        MappedFile(VOID);
        ~MappedFile(VOID);
        //
        // Open the mapped file.
        //
        HRESULT Open(LPCTSTR pszFile);
        //
        // Close the mapped file.
        //
        VOID Close(VOID);
        //
        // Get the base virtual address of the mapped file.
        //
        LPBYTE Base(VOID) const
            { return m_pbBase; }
        //
        // How many bytes in the mapped file?
        //
        LONGLONG Size(VOID) const;

    private:
        HANDLE   m_hFile;
        HANDLE   m_hFileMapping;
        LPBYTE   m_pbBase;
        LONGLONG m_llSize;

        //
        // Prevent copy.
        //
        MappedFile(const MappedFile& rhs);
        MappedFile& operator = (const MappedFile& rhs);
};

#endif // _INC_DSKQUOTA_MAPFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\mapfile.cpp ===
#include "pch.h"
#pragma hdrstop

#include "mapfile.h"

//-----------------------------------------------------------------------------
// MappedFile
//
// A simple encapsulation of opening a mapped file in memory.
// The file is opened with READ access only.
// Client calls Base() to retrieve the base pointer of the mapped file.
//-----------------------------------------------------------------------------
MappedFile::MappedFile(
    VOID
    ) : m_hFile(INVALID_HANDLE_VALUE),
        m_hFileMapping(INVALID_HANDLE_VALUE),
        m_pbBase(NULL),
        m_llSize(0) 
{ 
    DBGTRACE((DM_MAPFILE, DL_HIGH, TEXT("MappedFile::MappedFile")));
}


MappedFile::~MappedFile(
    VOID
    )
{
    DBGTRACE((DM_MAPFILE, DL_HIGH, TEXT("MappedFile::~MappedFile")));
    Close();
}


LONGLONG
MappedFile::Size(
    VOID
    ) const
{
    DBGTRACE((DM_MAPFILE, DL_MID, TEXT("MappedFile::Size")));
    return m_llSize;
}



//
// Open the file.  Caller retrieves the base pointer through the
// Base() member function.
//
HRESULT
MappedFile::Open(
    LPCTSTR pszFile
    )
{
    DBGTRACE((DM_MAPFILE, DL_HIGH, TEXT("MappedFile::Open")));
    DBGPRINT((DM_MAPFILE, DL_HIGH, TEXT("\topening \"%s\""), pszFile));

    HRESULT hr = NO_ERROR;

    m_hFile = CreateFile(pszFile, 
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL);

    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if ((m_hFileMapping = CreateFileMapping(m_hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                0,
                                                NULL)) == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            m_pbBase = (LPBYTE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_READ,
                                             0,
                                             0,
                                             0);
            if (NULL == m_pbBase)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                ULARGE_INTEGER liSize;
                liSize.LowPart = GetFileSize(m_hFile, &liSize.HighPart);
                m_llSize = liSize.QuadPart;
            }
        }
    }
    return hr;
}

//
// Close the file mapping and the file.
//
VOID
MappedFile::Close(
    VOID
    )
{
    DBGTRACE((DM_MAPFILE, DL_HIGH, TEXT("MappedFile::Close")));
    if (NULL != m_pbBase)
    {
        UnmapViewOfFile(m_pbBase);
        m_pbBase = NULL;
    }
    if (INVALID_HANDLE_VALUE != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = INVALID_HANDLE_VALUE;
    }
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\pch.h ===
#ifndef __PRECOMPILED_HEADER_H
#define __PRECOMPILED_HEADER_H
///////////////////////////////////////////////////////////////////////////////
/*  File: pch.h

    Description: Precompiled header file for dskquota project.
        Includes all headers that are compiled into the pre-compiled header.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "private.h"


#endif // __PRECOMPILED_HEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\pathstr.cpp ===
#include "pch.h"
#pragma hdrstop

#include "pathstr.h"



CPath::CPath(
    LPCTSTR pszRoot, 
    LPCTSTR pszDir, 
    LPCTSTR pszFile, 
    LPCTSTR pszExt
    )
{
    if (pszDir)
        SetPath(pszDir);
    if (pszRoot)
        SetRoot(pszRoot);
    if (pszFile)
        SetFileSpec(pszFile);
    if (pszExt)
        SetExtension(pszExt);
}


CPath::CPath(
    const CPath& rhs
    ) : CString(rhs)
{

}

    
CPath& 
CPath::operator = (
    const CPath& rhs
    )
{
    if (this != &rhs)
    {
        CString::operator = (rhs);
    }
    return *this;
}


CPath& 
CPath::operator = (
    LPCTSTR rhs
    )
{
    CString::operator = (rhs);
    return *this;
}


void
CPath::AddBackslash(
    void
    )
{
    ::PathAddBackslash(GetBuffer(MAX(MAX_PATH, Length() + 2)));
    ReleaseBuffer();
}

void
CPath::RemoveBackslash(
    void
    )
{
    ::PathRemoveBackslash(GetBuffer());
    ReleaseBuffer();
}

bool 
CPath::GetRoot(
    CPath *pOut
    ) const
{
    CPath temp(*this);
    temp.StripToRoot();
    *pOut = temp;
    return 0 < pOut->Length();
}

bool 
CPath::GetPath(
    CPath *pOut
    ) const
{
    CPath temp(*this);
    temp.RemoveFileSpec();
    *pOut = temp;
    return 0 < pOut->Length();
}

bool
CPath::GetDirectory(
    CPath *pOut
    ) const
{
    if (GetPath(pOut))
        pOut->RemoveRoot();

    return 0 < pOut->Length();
}

bool 
CPath::GetExtension(
    CPath *pOut
    ) const
{
    *pOut = ::PathFindExtension(*this);
    return 0 < pOut->Length();
}


bool 
CPath::GetFileSpec(
    CPath *pOut
    ) const
{
    *pOut = ::PathFindFileName(*this);
    return 0 < pOut->Length();
}
    

bool 
CPath::Append(
    LPCTSTR psz
    )
{
    bool bResult = boolify(::PathAppend(GetBuffer(MAX(MAX_PATH, Length() + lstrlen(psz) + 3)), psz));
    ReleaseBuffer();
    return bResult;
}

bool 
CPath::BuildRoot(
    int iDrive
    )
{
    Empty();
    bool bResult = NULL != ::PathBuildRoot(GetBuffer(5), iDrive);
    ReleaseBuffer();
    return bResult;
}


bool 
CPath::Canonicalize(
    void
    )
{
    CString strTemp(*this);
    bool bResult = boolify(::PathCanonicalize(GetBuffer(MAX(MAX_PATH, Size())), strTemp));
    ReleaseBuffer();
    return bResult;
}



bool 
CPath::Compact(
    HDC hdc, 
    int cxPixels
    )
{
    bool bResult = boolify(::PathCompactPath(hdc, GetBuffer(), cxPixels));
    ReleaseBuffer();
    return bResult;
}


bool 
CPath::CommonPrefix(
    LPCTSTR pszPath1, 
    LPCTSTR pszPath2
    )
{
    Empty();
    ::PathCommonPrefix(pszPath1, 
                       pszPath2, 
                       GetBuffer(MAX(MAX_PATH, (MAX(lstrlen(pszPath1), lstrlen(pszPath2)) + 1))));
    ReleaseBuffer();
    return 0 < Length();
}


void
CPath::QuoteSpaces(
    void
    )
{
    ::PathQuoteSpaces(GetBuffer(MAX(MAX_PATH, Length() + 3)));
    ReleaseBuffer();
}

void 
CPath::UnquoteSpaces(
    void
    )
{
    ::PathUnquoteSpaces(GetBuffer());
    ReleaseBuffer();
}

void 
CPath::RemoveBlanks(
    void
    )
{
    ::PathRemoveBlanks(GetBuffer());
    ReleaseBuffer();
}

void
CPath::RemoveExtension(
    void
    )
{
    PathRemoveExtension(GetBuffer());
    ReleaseBuffer();
}

void
CPath::RemoveFileSpec(
    void
    )
{
    ::PathRemoveFileSpec(GetBuffer());
    ReleaseBuffer();
}

void
CPath::RemoveRoot(
    void
    )
{
    LPTSTR psz = ::PathSkipRoot(*this);
    if (psz)
    {
        CPath temp(psz);
        *this = temp; 
    }
}


void
CPath::RemovePath(
    void
    )
{
    CPath temp;
    GetFileSpec(&temp);
    *this = temp;
}


void
CPath::StripToRoot(
    void
    )
{
    ::PathStripToRoot(GetBuffer());
    ReleaseBuffer();
}


void 
CPath::SetRoot(
    LPCTSTR pszRoot
    )
{
    CPath strTemp(*this);
    strTemp.RemoveRoot();
    *this = pszRoot;
    Append(strTemp);
}

void
CPath::SetPath(
    LPCTSTR pszPath
    )
{
    CPath strTemp(*this);
    *this = pszPath;

    strTemp.RemovePath();
    Append(strTemp);
}

void
CPath::SetDirectory(
    LPCTSTR pszDir
    )
{
    CPath path;
    GetPath(&path);
    path.StripToRoot();
    path.AddBackslash();
    path.Append(pszDir);
    SetPath(path);
}


void
CPath::SetFileSpec(
    LPCTSTR pszFileSpec
    )
{
    RemoveFileSpec();
    Append(pszFileSpec);
}

void
CPath::SetExtension(
    LPCTSTR pszExt
    )
{
    ::PathRenameExtension(GetBuffer(MAX(MAX_PATH, Length() + lstrlen(pszExt) + 2)), pszExt);
    ReleaseBuffer();
}


CPathIter::CPathIter(
    const CPath& path
    ) : m_path(path),
        m_pszCurrent((LPTSTR)m_path.Cstr())
{
    //
    // Skip over leading whitespace and backslashes.
    //
    while(*m_pszCurrent &&
          (TEXT('\\') == *m_pszCurrent ||
           TEXT(' ') == *m_pszCurrent  ||
           TEXT('\t') == *m_pszCurrent ||
           TEXT('\n') == *m_pszCurrent))
    {
        m_pszCurrent++;
    }
}


bool
CPathIter::Next(
    CPath *pOut
    )
{
    DBGASSERT((NULL != pOut));

    LPCTSTR pszStart = m_pszCurrent;
    if (NULL == pszStart || TEXT('\0') == *pszStart)
        return false;

    TCHAR chTemp = TEXT('\0');
    m_pszCurrent = ::PathFindNextComponent(pszStart);
    if (NULL != m_pszCurrent && *m_pszCurrent)
        SWAP(*(m_pszCurrent - 1), chTemp);

    *pOut = pszStart;

    if (TEXT('\0') != chTemp)
        SWAP(*(m_pszCurrent - 1), chTemp);

    return true;
}


void
CPathIter::Reset(
    void
    )
{
    m_pszCurrent = (LPTSTR)m_path.Cstr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\ntds.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: ntds.cpp

    Description: Contains definition for class NTDS.
        This class provides a simple wrapper around NT Directory Service
        name translation features.  Currently, the Win32 functions to perform
        DS-sensitive name-to-SID translations are not present.  These functions
        provide the same functionality.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/01/97    Initial creation.                                    BrianAu
    03/20/98    Reworked to use TranslateName rather than a combo    BrianAu
                of DsBind and DsCrackNames.  This ensures we're
                getting the proper info from the DS.  It's slower
                because we have to re-bind to the DS for each call
                but I'd rather do that than bind incorrectly and
                not get the proper name information.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include <lm.h>        // For NetUserGetInfo and NetGetDCName.
#include "ntds.h"


//
// REARCHITECT:  These DS_NAME_FORMAT codes (ntdsapi.h> are not yet in the 
//          corresponding EXTENDED_NAME_FORMAT enumeration in sspi.h.
//          Since TranslateName passes these codes on directly to DsCrackNames
//          I've defined these here so I can get the latest behavior until
//          Richard Ward updates TranslateNames and sspi.h.
//          Once he's updated that header, you can delete these three consts
//          and remove the "SSPI_" prefix from where they're used in the 
//          code.  [brianau - 3/19/98]
//
#define SSPI_NameUserPrincipal    ((EXTENDED_NAME_FORMAT)8)
#define SSPI_NameCanonicalEx      ((EXTENDED_NAME_FORMAT)9)
#define SSPI_NameServicePrincipal ((EXTENDED_NAME_FORMAT)10)


//
// Given an account name, find the account's SID and optionally the
// account's container and display names.
// The logon name may be either a DS "user principal" name or an
// NT4-style SAM-compatible name.
//
// DS UPN =         "brianau@microsoft.com"
// SAM compatible = "REDMOND\brianau"
//
HRESULT
NTDS::LookupAccountByName(
    LPCTSTR pszSystem,          // IN - optional.  Can be NULL.
    LPCTSTR pszLogonName,       // IN - "REDMOND\brianau" or "brianau@microsoft.com"
    CString *pstrContainerName, // OUT - optional.
    CString *pstrDisplayName,   // OUT - optional.  Can be NULL.
    PSID    pSid,               // OUT
    LPDWORD pdwSid,             // IN/OUT
    PSID_NAME_USE peUse         // OUT
    )
{
    DBGTRACE((DM_NTDS, DL_HIGH, TEXT("NTDS::LookupAccountByName")));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != pSid));
    DBGASSERT((NULL != pdwSid));
    DBGASSERT((NULL != peUse));
    DBGPRINT((DM_NTDS, DL_HIGH, TEXT("Lookup \"%s\""), pszLogonName));

    HRESULT hr = NOERROR;

    //
    // Assume the presence of a '@' character means it's a UPN.
    //
    if (NULL != StrChr(pszLogonName, TEXT('@')))
    {
        hr = LookupDsAccountName(pszSystem,
                                 pszLogonName,
                                 pstrContainerName,
                                 pstrDisplayName,
                                 pSid,
                                 pdwSid,
                                 peUse);
    }
    else
    {
        hr = LookupSamAccountName(pszSystem,
                                  pszLogonName,
                                  pstrContainerName,
                                  pstrDisplayName,
                                  pSid,
                                  pdwSid,
                                  peUse);
    }
    return hr;
}


//
// Given an account SID, optionally find the account's logon name,
// container name and display name.  If a DS UPN is available for the
// user, the container name will be the canonical path to the user
// object and the display name will come from the DS.  If a
// DS UPN is not available, or the account is an NT4 account,
// the container returned is the NT4 domain name and the display name
// is retrieved using NetUserGetInfo.
//
HRESULT
NTDS::LookupAccountBySid(
    LPCTSTR pszSystem,           // optional.  Can be NULL.
    PSID    pSid,
    CString *pstrContainerName,  // optional.  Can be NULL.
    CString *pstrLogonName,      // optional.  Can be NULL.
    CString *pstrDisplayName,    // optional.  Can be NULL.
    PSID_NAME_USE peUse
    )
{
    DBGTRACE((DM_NTDS, DL_HIGH, TEXT("NTDS::LookupAccountBySid")));
    DBGASSERT((NULL != pSid));

    HRESULT hr = NOERROR;
    CString strSamUser;
    CString strSamDomain;
    CString strSamLogonName;

    //
    // Get the SAM-compatible domain\user name for the SID.
    //
    DBGPRINT((DM_NTDS, DL_LOW, TEXT("Calling ::LookupAccountSid")));
    hr = LookupAccountSidInternal(pszSystem,
                                  pSid,
                                  &strSamUser,
                                  &strSamDomain,
                                  peUse);

    if (FAILED(hr))
        return hr;

    //
    // No need to go further if caller doesn't want any name information in which
    // case all they're getting in return is an indication if the SID is for a known
    // account or not.
    //
    if (NULL != pstrLogonName || NULL != pstrContainerName || NULL != pstrDisplayName)
    {
        CString strFQDN;
        bool bUseSamCompatibleInfo = false;
        CreateSamLogonName(strSamDomain, strSamUser, &strSamLogonName);

        //
        // Start by getting the FQDN.  Cracking is most efficient when the
        // FQDN is the starting point.
        //
        if (FAILED(TranslateNameInternal(strSamLogonName,
                                         NameSamCompatible,
                                         NameFullyQualifiedDN,
                                         &strFQDN)))
        {
            //
            // No FQDN available for this account.  Must be an NT4
            // account.  Return SAM-compatible info to the caller.
            //
            bUseSamCompatibleInfo = true;
        }
        if (NULL != pstrLogonName)
        {
            if (bUseSamCompatibleInfo)
            {
                *pstrLogonName = strSamLogonName;
            }
            else
            {
                //
                // Get the DS user principal name
                //
                pstrLogonName->Empty();
                if (FAILED(TranslateNameInternal(strFQDN,
                                                 NameFullyQualifiedDN,
                                                 SSPI_NameUserPrincipal,
                                                 pstrLogonName)))
                {
                    //
                    // No UPN for this account.
                    // Default to returning SAM-compatible info.
                    //
                    bUseSamCompatibleInfo = true;
                    *pstrLogonName = strSamLogonName;
                }
            }
        }

        if (NULL != pstrContainerName)
        {
            if (bUseSamCompatibleInfo)
            {
                *pstrContainerName = strSamDomain;
            }
            else
            {
                pstrContainerName->Empty();
                if (SUCCEEDED(TranslateNameInternal(strFQDN,
                                                    NameFullyQualifiedDN,
                                                    NameCanonical,
                                                    pstrContainerName)))
                {
                    //
                    // Trim off the trailing account name from the canonical path
                    // so we're left with only the container name.
                    //
                    int iLastBS = pstrContainerName->Last(TEXT('/'));
                    if (-1 != iLastBS)
                    {
                        *pstrContainerName = pstrContainerName->SubString(0, iLastBS);
                    }
                }
            }
        }

        if (NULL != pstrDisplayName)
        {
            if (bUseSamCompatibleInfo || FAILED(GetDsAccountDisplayName(strFQDN, pstrDisplayName)))
            {
                GetSamAccountDisplayName(strSamLogonName, pstrDisplayName);
            }
        }
    }
    return hr;
}



//
// Input is a SAM-compatible account name.
// Retrieve the name information using the NT4-style methods.
// 
HRESULT
NTDS::LookupSamAccountName(
    LPCTSTR pszSystem,
    LPCTSTR pszLogonName,       // IN - "REDMOND\brianau"
    CString *pstrContainerName, // OUT - optional.
    CString *pstrDisplayName,   // OUT - optional.  Can be NULL.
    PSID    pSid,               // OUT
    LPDWORD pdwSid,             // IN/OUT
    PSID_NAME_USE peUse         // OUT
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::LookupSamAccountName")));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != pdwSid));
    DBGASSERT((NULL != pSid));
    DBGASSERT((NULL != peUse));
    //
    // Get the SID using the SAM-compatible account name.
    //
    HRESULT hr = NOERROR;
    CString strDomain;
    hr = LookupAccountNameInternal(pszSystem,
                                   pszLogonName,
                                   pSid,
                                   pdwSid,
                                   &strDomain,
                                   peUse);
    if (SUCCEEDED(hr))
    {
        if (NULL != pstrContainerName)
            *pstrContainerName = strDomain;

        if (NULL != pstrDisplayName)
            GetSamAccountDisplayName(pszLogonName, pstrDisplayName);
    }
    return hr;
}



//
// Returns:
//    S_OK      = All information retrieved.
//    S_FALSE   = Container name returned is for SAM-compatible account.  
//                DS container information was not available.
HRESULT
NTDS::LookupDsAccountName(
    LPCTSTR pszSystem,
    LPCTSTR pszLogonName,       // IN - "brianau@microsoft.com"
    CString *pstrContainerName, // OUT - optional.
    CString *pstrDisplayName,   // OUT - optional.  Can be NULL.
    PSID    pSid,               // OUT
    LPDWORD pdwSid,             // IN/OUT
    PSID_NAME_USE peUse         // OUT
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::LookupDsAccountName")));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != pSid));
    DBGASSERT((NULL != pdwSid));
    DBGASSERT((NULL != peUse));
    //
    // Get the SID using the SAM-compatible account name.
    //
    HRESULT hr = S_OK;

    //
    // Translate the DS user principal name to FQDN format.
    // Starting with FQDN is the most efficient for name cracking so
    // we get it once and use it multiple times.
    //
    CString strFQDN;
    hr = TranslateNameInternal(pszLogonName,
                               SSPI_NameUserPrincipal,
                               NameFullyQualifiedDN,
                               &strFQDN);
    if (FAILED(hr))
        return hr;


    CString strSamLogonName;
    hr = TranslateNameInternal(strFQDN,
                               NameFullyQualifiedDN,
                               NameSamCompatible,
                               &strSamLogonName);
    if (FAILED(hr))
        return hr;


    CString strDomain;
    hr = LookupAccountNameInternal(pszSystem,
                                   strSamLogonName,
                                   pSid,
                                   pdwSid,
                                   &strDomain,
                                   peUse);
    if (FAILED(hr))
        return hr;

    bool bUseSamCompatibleInfo = false;
    if (NULL != pstrContainerName)
    {
        //
        // Get the DS container name for the account.
        //
        hr = TranslateNameInternal(strFQDN,
                                   NameFullyQualifiedDN,
                                   NameCanonical,
                                   pstrContainerName);

        if (SUCCEEDED(hr))
        {
            //
            // Trim off the trailing account name from the canonical path
            // so we're left with only the container name.
            //
            int iLastBS = pstrContainerName->Last(TEXT('/'));
            if (-1 != iLastBS)
            {
                *pstrContainerName = pstrContainerName->SubString(0, iLastBS);
            }
        }
        else
        {
            DBGERROR((TEXT("Using SAM-compatible name info")));
            //
            // Can't get DS container name so use the SAM domain name.
            //
            *pstrContainerName = strDomain;
            bUseSamCompatibleInfo = true;
            hr = S_FALSE;
        }
    }
    if (NULL != pstrDisplayName)
    {
        if (bUseSamCompatibleInfo || FAILED(GetDsAccountDisplayName(strFQDN, pstrDisplayName)))
            GetSamAccountDisplayName(strSamLogonName, pstrDisplayName);
    }
    return hr;
}



HRESULT
NTDS::GetSamAccountDisplayName(
    LPCTSTR pszLogonName,
    CString *pstrDisplayName
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::GetSamAccountDisplayName")));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != pstrDisplayName));
    DBGPRINT((DM_NTDS, DL_MID, TEXT("Translating \"%s\""), pszLogonName));

    HRESULT hr             = E_FAIL;
    LPTSTR pszComputerName = NULL;
    NET_API_STATUS status  = NERR_Success;
    CString strLogonName(pszLogonName);
    CString strDomain;
    CString strUser;
    //
    // Separate the domain\account string into two separate strings.
    //
    int iBackslash = strLogonName.Last(TEXT('\\'));
    if (-1 != iBackslash)
    {
        strDomain = strLogonName.SubString(0, iBackslash);
        if (iBackslash < (strLogonName.Length() - 1))
            strUser = strLogonName.SubString(iBackslash + 1);
    }

    pstrDisplayName->Empty();
    DBGPRINT((DM_NTDS, DL_LOW, TEXT("Calling ::NetGetDCName for domain \"%s\""), strDomain.Cstr()));
    status = ::NetGetDCName(NULL, strDomain, (LPBYTE *)&pszComputerName);
    if (NERR_Success == status || NERR_DCNotFound == status)
    {
        struct _USER_INFO_2 *pui = NULL;

        DBGPRINT((DM_NTDS, DL_LOW, TEXT("Calling ::NetGetUserInfo for \"%s\" on \"%s\""), strUser.Cstr(), pszComputerName));
        status = ::NetUserGetInfo(pszComputerName, strUser, 2, (LPBYTE *)&pui);
        if (NERR_Success == status)
        {
            *pstrDisplayName = pui->usri2_full_name;
            DBGPRINT((DM_NTDS, DL_LOW, TEXT("Translated to \"%s\""), pstrDisplayName->Cstr()));
            NetApiBufferFree(pui);
            hr = NOERROR;
        }
        else
        {
            DBGERROR((TEXT("NetUserGetInfo failed with error 0x%08X for \"%s\" on \"%s\""), 
                      status, strUser.Cstr(), pszComputerName ? pszComputerName : TEXT("local machine")));
            hr = HRESULT_FROM_WIN32(status);
        }
        if (NULL != pszComputerName)
            NetApiBufferFree(pszComputerName);
    }
    else
    {
        DBGERROR((TEXT("NetGetDCName failed with error 0x%08X for domain \"%s\""), 
                  status, strDomain.Cstr()));
        hr = HRESULT_FROM_WIN32(status);
    }
    return hr;
}

                 
HRESULT
NTDS::GetDsAccountDisplayName(
    LPCTSTR pszFQDN,
    CString *pstrDisplayName
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::GetDsAccountDisplayName")));
    DBGASSERT((NULL != pszFQDN));
    DBGASSERT((NULL != pstrDisplayName));

    //
    // Get the DS container name for the account.
    //
    pstrDisplayName->Empty();
    return TranslateNameInternal(pszFQDN,
                                 NameFullyQualifiedDN,
                                 NameDisplay,
                                 pstrDisplayName);
}



void
NTDS::CreateSamLogonName(
    LPCTSTR pszSamDomain,
    LPCTSTR pszSamUser,
    CString *pstrSamLogonName
    )
{
    DBGTRACE((DM_NTDS, DL_LOW, TEXT("NTDS::CreateSamLogonName")));
    DBGASSERT((NULL != pszSamDomain));
    DBGASSERT((NULL != pszSamUser));
    DBGASSERT((NULL != pstrSamLogonName));
    DBGPRINT((DM_NTDS, DL_LOW, TEXT("\tDomain.: \"%s\""), pszSamDomain));
    DBGPRINT((DM_NTDS, DL_LOW, TEXT("\tUser...: \"%s\""), pszSamUser));

    pstrSamLogonName->Format(TEXT("%1\\%2"), pszSamDomain, pszSamUser);

    DBGPRINT((DM_NTDS, DL_LOW, TEXT("\tAccount: \"%s\""), pstrSamLogonName->Cstr()));
}



HRESULT 
NTDS::TranslateFQDNsToLogonNames(
    const CArray<CString>& rgstrFQDNs, 
    CArray<CString> *prgstrLogonNames
    )
{
    HRESULT hr = NOERROR;
    prgstrLogonNames->Clear();
    int cItems = rgstrFQDNs.Count();
    CString strLogonName;
    for (int i = 0; i < cItems; i++)
    {
        if (FAILED(TranslateFQDNToLogonName(rgstrFQDNs[i], &strLogonName)))
            strLogonName.Empty();

        prgstrLogonNames->Append(strLogonName);
    }
    return hr;
}



HRESULT 
NTDS::TranslateFQDNToLogonName(
    LPCTSTR pszFQDN,
    CString *pstrLogonName
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::TranslateFQDNToLogonName")));
    DBGASSERT((NULL != pszFQDN));
    DBGASSERT((NULL != pstrLogonName));

    HRESULT hr = NOERROR;
    hr = TranslateNameInternal(pszFQDN,
                               NameFullyQualifiedDN,
                               SSPI_NameUserPrincipal,
                               pstrLogonName);
    if (FAILED(hr))
    {
        hr = TranslateNameInternal(pszFQDN,
                                   NameFullyQualifiedDN,
                                   NameSamCompatible,
                                   pstrLogonName);
    }
    return hr;
}


LPCTSTR 
NTDS::FindFQDNInADsPath(
    LPCTSTR pszADsPath
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::FindFQDNInADsPath")));
    DBGASSERT((NULL != pszADsPath));
    DBGPRINT((DM_NTDS, DL_MID, TEXT("Checking \"%s\""), pszADsPath));
    const TCHAR szCN[] = TEXT("CN=");
    while(*pszADsPath && CSTR_EQUAL != CompareString(LOCALE_USER_DEFAULT,
                                                     0,
                                                     pszADsPath,
                                                     ARRAYSIZE(szCN) - 1,
                                                     szCN,
                                                     ARRAYSIZE(szCN) - 1))
    {
        pszADsPath = CharNext(pszADsPath);
    }
    DBGPRINT((DM_NTDS, DL_MID, TEXT("Found \"%s\""), pszADsPath ? pszADsPath : TEXT("<null>")));
    return (*pszADsPath ? pszADsPath : NULL);
}


LPCTSTR 
NTDS::FindSamAccountInADsPath(
    LPCTSTR pszADsPath
    )
{
    DBGTRACE((DM_NTDS, DL_MID, TEXT("NTDS::FindSamAccountInADsPath")));
    DBGASSERT((NULL != pszADsPath));
    DBGPRINT((DM_NTDS, DL_MID, TEXT("Checking \"%s\""), pszADsPath));
    const TCHAR szPrefix[] = TEXT("WinNT://");
    if (0 == StrCmpN(pszADsPath, szPrefix, ARRAYSIZE(szPrefix)-1))
    {
        pszADsPath += (ARRAYSIZE(szPrefix) - 1);
        DBGPRINT((DM_NTDS, DL_MID, TEXT("Found \"%s\""), pszADsPath));
    }
    else
    {
        pszADsPath = NULL;
    }

    return pszADsPath;
}


//
// Wrapper around sspi's TranslateName that automatically handles
// the buffer sizing using a CString object.
//
HRESULT
NTDS::TranslateNameInternal(
    LPCTSTR pszAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    CString *pstrTranslatedName
    )
{
#if DBG
    //
    // These match up with the EXTENDED_NAME_FORMAT enumeration.
    // They're for debugger output only.
    //
    static const LPCTSTR rgpszFmt[] = { 
                                TEXT("NameUnknown"),
                                TEXT("FullyQualifiedDN"),
                                TEXT("NameSamCompatible"),
                                TEXT("NameDisplay"),
                                TEXT("NameDomainSimple"),
                                TEXT("NameEnterpriseSimple"),
                                TEXT("NameUniqueId"),
                                TEXT("NameCanonical"),
                                TEXT("NameUserPrincipal"),
                                TEXT("NameCanonicalEx"),
                                TEXT("NameServicePrincipal") };
#endif // DBG

    DBGPRINT((DM_NTDS, DL_LOW, TEXT("Calling TranslateName for \"%s\""), pszAccountName));
    DBGPRINT((DM_NTDS, DL_LOW, TEXT("Translating %s -> %s"), 
              rgpszFmt[AccountNameFormat], rgpszFmt[DesiredNameFormat]));

    HRESULT hr = NOERROR;
    //
    // WARNING:  TranslateName doesn't properly set the required buffer size
    //          in cchTrans if the buffer size is too small.  I've notified
    //          Richard B. Ward about it.  Says he'll have the fix in
    //          on 3/24/98.  Should test with an initial value of 1
    //          just to make sure he fixed it.  [brianau - 03/20/98]
    //
    //
    // cchTrans is static so that if a particular installation's
    // account names are really long, we'll not be resizing the
    // buffer for each account.
    //
    static ULONG cchTrans = MAX_PATH;

    while(!::TranslateName(pszAccountName,
                           AccountNameFormat,
                           DesiredNameFormat,
                           pstrTranslatedName->GetBuffer(cchTrans),
                           &cchTrans))
    {
        DWORD dwErr = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            DBGERROR((TEXT("::TranslateName failed with error %d"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }
        DBGPRINT((DM_NTDS, DL_LOW, TEXT("Resizing buffer to %d chars"), cchTrans));
    }
    pstrTranslatedName->ReleaseBuffer();
    return hr;
}


//
// Wrapper around Win32's LookupAccountName that automatically handles
// the domain buffer sizing using a CString object.
//
HRESULT
NTDS::LookupAccountNameInternal(
    LPCTSTR pszSystemName,
    LPCTSTR pszAccountName,
    PSID pSid,
    LPDWORD pcbSid,
    CString *pstrReferencedDomainName,
    PSID_NAME_USE peUse
    )
{
    DBGPRINT((DM_NTDS, DL_MID, TEXT("Calling ::LookupAccountName for \"%s\" on \"%s\""),
              pszAccountName, pszSystemName ? pszSystemName : TEXT("<local system>")));

    HRESULT hr = NOERROR;
    //
    // cchDomain is static so that if a particular installation's
    // account names are really long, we'll not be resizing the
    // buffer for each account.
    //
    static ULONG cchDomain = MAX_PATH;

    while(!::LookupAccountName(pszSystemName,
                               pszAccountName,
                               pSid,
                               pcbSid,
                               pstrReferencedDomainName->GetBuffer(cchDomain),
                               &cchDomain,
                               peUse))
    {
        DWORD dwErr = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            DBGERROR((TEXT("::LookupAccountName failed with error %d"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }
        DBGPRINT((DM_NTDS, DL_LOW, TEXT("Resizing domain buffer to %d chars"), cchDomain));
    }
    pstrReferencedDomainName->ReleaseBuffer();
    return hr;
}
 
//
// Wrapper around Win32's LookupAccountSid that automatically handles
// the domain buffer sizing using a CString object.
//
HRESULT
NTDS::LookupAccountSidInternal(
    LPCTSTR pszSystemName,
    PSID pSid,
    CString *pstrName,
    CString *pstrReferencedDomainName,
    PSID_NAME_USE peUse
    )
{
    HRESULT hr = NOERROR;
    //
    // These are static so that if a particular installation's
    // account names are really long, we'll not be resizing the
    // buffer for each account.
    //
    static ULONG cchName   = MAX_PATH;
    static ULONG cchDomain = MAX_PATH;

    while(!::LookupAccountSid(pszSystemName,
                              pSid,
                              pstrName->GetBuffer(cchName),
                              &cchName,
                              pstrReferencedDomainName->GetBuffer(cchDomain),
                              &cchDomain,
                              peUse))
    {
        DWORD dwErr = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwErr)
        {
            DBGERROR((TEXT("::LookupAccountSid failed with error %d"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }
        DBGPRINT((DM_NTDS, DL_LOW, TEXT("Resizing domain or name buffer")));
    }
    pstrName->ReleaseBuffer();
    pstrReferencedDomainName->ReleaseBuffer();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\pathstr.h ===
#ifndef _INC_DSKQUOTA_PATHSTR_H
#define _INC_DSKQUOTA_PATHSTR_H


#ifndef _INC_DSKQUOTA_UTILS_H
#   include "utils.h"
#endif
#ifndef _INC_SHLWAPI
#   include <shlwapi.h>
#endif
#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif


class CPath : public CString
{
    public:
        CPath(void) { }
        explicit CPath(LPCTSTR pszRoot, LPCTSTR pszDir = NULL, LPCTSTR pszFile = NULL, LPCTSTR pszExt = NULL);
        CPath(const CPath& rhs);
        CPath& operator = (const CPath& rhs);
        CPath& operator = (LPCTSTR rhs);

        ~CPath(void) { }

        //
        // Component replacement.
        //
        void SetRoot(LPCTSTR pszRoot);
        void SetPath(LPCTSTR pszPath);
        void SetDirectory(LPCTSTR pszDir);
        void SetFileSpec(LPCTSTR pszFileSpec);
        void SetExtension(LPCTSTR pszExt);
        //
        // Component query
        //
        bool GetRoot(CPath *pOut) const;
        bool GetPath(CPath *pOut) const;
        bool GetDirectory(CPath *pOut) const;
        bool GetFileSpec(CPath *pOut) const;
        bool GetExtension(CPath *pOut) const;
        //
        // Component removal
        //
        void RemoveRoot(void);
        void RemovePath(void);
        void RemoveFileSpec(void);
        void RemoveExtension(void);
        void StripToRoot(void);

        bool Append(LPCTSTR psz);

        //
        // DOS drive letter support.
        //
        bool BuildRoot(int iDrive);
        int GetDriveNumber(void) const;

        //
        // Type identification.
        //
        bool IsDirectory(void) const;
        bool IsFileSpec(void) const;
        bool IsPrefix(LPCTSTR pszPrefix) const;
        bool IsRelative(void) const;
        bool IsRoot(void) const;
        bool IsSameRoot(LPCTSTR pszPath) const;
        bool IsUNC(void) const;
        bool IsUNCServer(void) const;
        bool IsUNCServerShare(void) const;
        bool IsURL(void) const;

        //
        // Miscellaneous formatting.
        //
        bool MakePretty(void);
        void QuoteSpaces(void);
        void UnquoteSpaces(void);
        void RemoveBlanks(void);
        void AddBackslash(void);
        void RemoveBackslash(void);
        bool Canonicalize(void);
        bool Compact(HDC hdc, int cxPixels);
        bool CommonPrefix(LPCTSTR pszPath1, LPCTSTR pszPath2);
        bool Exists(void) const;

    private:
        template <class T>
        T MAX(const T& a, const T& b)
            { return a > b ? a : b; }

};


class CPathIter
{
    public:
        CPathIter(const CPath& path);
        ~CPathIter(void) { }

        bool Next(CPath *pOut);
        void Reset(void);

    private:
        CPath  m_path;
        LPTSTR m_pszCurrent;
};


inline bool 
CPath::Exists(
    void
    ) const
{
    return boolify(::PathFileExists((LPCTSTR)*this));
}


inline bool 
CPath::IsDirectory(
    void
    ) const
{
    return boolify(::PathIsDirectory((LPCTSTR)*this));
}

inline bool 
CPath::IsFileSpec(
    void
    ) const
{
    return boolify(::PathIsFileSpec((LPCTSTR)*this));
}

inline bool 
CPath::IsPrefix(
    LPCTSTR pszPrefix
    ) const
{
    return boolify(::PathIsPrefix(pszPrefix, (LPCTSTR)*this));
}


inline bool 
CPath::IsRelative(
    void
    ) const
{
    return boolify(::PathIsRelative((LPCTSTR)*this));
}

inline bool 
CPath::IsRoot(
    void
    ) const
{
    return boolify(::PathIsRoot((LPCTSTR)*this));
}


inline bool 
CPath::IsSameRoot(
    LPCTSTR pszPath
    ) const
{
    return boolify(::PathIsSameRoot(pszPath, (LPCTSTR)*this));
}


inline bool 
CPath::IsUNC(
    void
    ) const
{
    return boolify(::PathIsUNC((LPCTSTR)*this));
}

inline bool 
CPath::IsUNCServer(
    void
    ) const
{
    return boolify(::PathIsUNCServer((LPCTSTR)*this));
}


inline bool 
CPath::IsUNCServerShare(
    void
    ) const
{
    return boolify(::PathIsUNCServerShare((LPCTSTR)*this));
}

inline bool 
CPath::IsURL(
    void
    ) const
{
    return boolify(::PathIsURL((LPCTSTR)*this));
}

inline bool 
CPath::MakePretty(
    void
    )
{
    return boolify(::PathMakePretty((LPTSTR)*this));
}

inline int
CPath::GetDriveNumber(
    void
    ) const
{
    return ::PathGetDriveNumber(*this);
}


#endif // _INC_DSKQUOTA_PATHSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\policy.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: policy.cpp

    Description: Handles disk quota policy issues for both a GPE client 
        extension and a server MMC policy snapin (see snapin.cpp).

        ProgressGroupPolicy is called by winlogon to process disk quota policy
        on the client machine.   ProcessGroupPolicy instantiates a CDiskQuotaPolicy
        object to handle the loading and application of disk quota policy.

        The CDiskQuotaPolicy object is also instantiated by the MMC
        disk quota policy snapin to save quota policy information to the
        registry.

        A good deal of this module, especially in CDiskQuotaPolicy::Apply( ),
        is devoted to reporting errors to the NT event log.  This is necessary
        because much of this code runs without UI from within winlogon.  That's
        also why there's a lot of debugger spew.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/14/98    Initial creation.                                    BrianAu
    11/24/98    Added event logging settings to policy.              BrianAu
    11/30/98    Replaced ProcessGPO function with                    BrianAu
                ProcessGroupPolicy to support GPO interface changes.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include <userenv.h>
#include <gpedit.h>
#include <dskquota.h>
#include "policy.h"
#include "registry.h"
#include "guidsp.h"
#include "msg.h"
#include "resource.h"

//
// Global NT event log object.
//
CEventLog g_Log;
//
// Name of the disk quota dll.
//
const TCHAR g_szDskquotaDll[] = TEXT("dskquota.dll");


//
// Exported function called by winlogon to update policy on the client machine.
//
// This function is registered as a GPO extension (see selfreg.inf).
//
DWORD
ProcessGroupPolicy(
    DWORD dwFlags,
    HANDLE hUserToken,
    HKEY hkeyRoot,
    PGROUP_POLICY_OBJECT pDeletedGPOList,
    PGROUP_POLICY_OBJECT pChangedGPOList,
    ASYNCCOMPLETIONHANDLE pHandle,
    BOOL *pbAbort,
    PFNSTATUSMESSAGECALLBACK pStatusCallback
    )
{
    HRESULT hr = ERROR_SUCCESS;

    DBGTRACE((DM_POLICY, DL_HIGH, TEXT("ProcessGroupPolicy")));
    DBGPRINT((DM_POLICY, DL_LOW, TEXT("\tdwFlags......: 0x%08X"), dwFlags));
    DBGPRINT((DM_POLICY, DL_LOW, TEXT("\thUserToken...: 0x%08X"), hUserToken));
    DBGPRINT((DM_POLICY, DL_LOW, TEXT("\thKeyRoot.....: 0x%08X"), hkeyRoot));

    //
    // FEATURE:  Need to add support for pDeletedGPOList
    //          If pDeletedGPOList is non-null, you should
    //          reset the disk quotas back to their defaults first
    //          and then apply the new settings below if appropriate
    //

    if (pChangedGPOList)
    {
        hr = g_Log.Initialize(TEXT("DiskQuota"));

        if (FAILED(hr))
        {
            DBGERROR((TEXT("Error 0x%08X initializing NT event log."), hr));
            //
            // Continue without event log.
            //
        }


        //
        // Only process policy info when...
        //
        //  1. Not deleting policy.
        //

        try
        {
            DBGPRINT((DM_POLICY, DL_HIGH, TEXT("Set quota policy - START.")));

            autoptr<CDiskQuotaPolicy> ptrPolicy(new CDiskQuotaPolicy(NULL,
                                                                     hkeyRoot,
                                                                     0 != (GPO_INFO_FLAG_VERBOSE & dwFlags),
                                                                     pbAbort));
            DISKQUOTAPOLICYINFO dqpi;
            ZeroMemory(&dqpi, sizeof(dqpi));

            //
            // Load policy info from the registry and apply to local volumes.
            //

            hr = ptrPolicy->Load(&dqpi);

            if (SUCCEEDED(hr))
            {
                hr = ptrPolicy->Apply(&dqpi);
            }

            DBGPRINT((DM_POLICY, DL_HIGH, TEXT("Set quota policy - FINISHED.")));
        }
        catch(CAllocException& e)
        {
            DBGERROR((TEXT("Insufficient memory in ProcessGroupPolicy")));
            g_Log.ReportEvent(EVENTLOG_ERROR_TYPE,
                              0,
                              MSG_E_POLICY_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}






//-----------------------------------------------------------------------------
// CDiskQuotaPolicy
//-----------------------------------------------------------------------------

//
// Location of disk quota policy information in the registry.  The "PolicyData"
// value name is somewhat arbitrary.  The policy key name string however must
// coordinate with other system policy locations in the registry.  It should 
// not change unless you have a good reason to do so and you understand the 
// consequences.
//
const TCHAR CDiskQuotaPolicy::m_szRegKeyPolicy[] = REGSTR_KEY_POLICYDATA;
#ifdef POLICY_MMC_SNAPIN
const TCHAR CDiskQuotaPolicy::m_szRegValPolicy[] = REGSTR_VAL_POLICYDATA;
#endif

CDiskQuotaPolicy::CDiskQuotaPolicy(
    LPGPEINFORMATION pGPEInfo,
    HKEY hkeyRoot,
    bool bVerboseEventLog,
    BOOL *pbAbort
    ) : m_cRef(0),
        m_pGPEInfo(pGPEInfo),
        m_hkeyRoot(hkeyRoot),
        m_pbAbort(pbAbort),
        m_bRootKeyOpened(false),
        m_bVerboseEventLog(bVerboseEventLog)
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::CDiskQuotaPolicy")));
}


CDiskQuotaPolicy::~CDiskQuotaPolicy(
    void
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::~CDiskQuotaPolicy")));

    if (NULL != m_hkeyRoot && m_bRootKeyOpened)
        RegCloseKey(m_hkeyRoot);

    if (NULL != m_pGPEInfo)
        m_pGPEInfo->Release();
}


HRESULT
CDiskQuotaPolicy::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::~QueryInterface")));
    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IDiskQuotaPolicy == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}



ULONG
CDiskQuotaPolicy::AddRef(
    void
    )
{
    DBGTRACE((DM_POLICY, DL_LOW, TEXT("CDiskQuotaPolicy::AddRef")));
    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


ULONG
CDiskQuotaPolicy::Release(
    void
    )
{
    DBGTRACE((DM_POLICY, DL_LOW, TEXT("CDiskQuotaPolicy::Release")));
    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


//
// Caller can init with either:
//
//   1. Ptr to IGPEInformation interface.  The snap in should initialize this 
//      way since it has a pointer to an IGPEInformation 
//      interface (LPGPEINFORMATION).
//
//   2. HKEY retrieved from IGPEInformation interface or from Group Policy
//      notification.  ProcessGroupPolicy should initialize this way since it is given 
//      the root key from winlogon.
//
// Can also init with both but pGPEInfo will be ignored if hkeyRoot is provided.
//
HRESULT
CDiskQuotaPolicy::Initialize(
    LPGPEINFORMATION pGPEInfo,
    HKEY hkeyRoot
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::Initialize")));

    if (NULL != m_pGPEInfo || NULL != m_hkeyRoot)
        return S_FALSE;     // Already intialized

    m_hkeyRoot = hkeyRoot;
    m_pGPEInfo = pGPEInfo;

    if (NULL != m_pGPEInfo)
        m_pGPEInfo->AddRef();

    return S_OK;
}

//
// Fill in a DISKQUOTAPOLICYINFO structure with default data.
//
void
CDiskQuotaPolicy::InitPolicyInfo(
    LPDISKQUOTAPOLICYINFO pInfo
    )
{
    pInfo->llDefaultQuotaThreshold = (LONGLONG)-1; // No limit.
    pInfo->llDefaultQuotaLimit     = (LONGLONG)-1; // No limit.
    pInfo->dwQuotaState            = 0;
    pInfo->dwQuotaLogFlags         = 0;
    pInfo->bRemovableMedia         = 0;
}


//
// Initialize and load policy information into a DISKQUOTAPOLICYINFO structure.
// If reg values don't exist, default values are used.
//
void
CDiskQuotaPolicy::LoadPolicyInfo(
    const RegKey& key,
    LPDISKQUOTAPOLICYINFO pInfo
    )
{
    DWORD dwValue = DWORD(-1);
    const struct
    {
        LPCTSTR pszValue; // Name of the "value" reg value.
        LPCTSTR pszUnits; // Name of the "units" reg value.
        LONGLONG *pValue; // Address of destination for computed limit or threshold.

    } rgValUnits[] = {
        { REGSTR_VAL_POLICY_LIMIT,     REGSTR_VAL_POLICY_LIMITUNITS,     &(pInfo->llDefaultQuotaLimit)     },
        { REGSTR_VAL_POLICY_THRESHOLD, REGSTR_VAL_POLICY_THRESHOLDUNITS, &(pInfo->llDefaultQuotaThreshold) }
                     };

    //
    // Initialize with defaults.
    //
    InitPolicyInfo(pInfo);

    //
    // Load the limit and threshold values along with their respective "units"
    // factor.  The factor is a number [1..6] that represents the required
    // multiplier to convert the "value" to a byte value.
    //
    //      1 = KB, 2 = MB, 3 = GB, 4 = TB, 5 = PB, 6 = EB
    //
    // Bytes = value << (factor * 10).
    //
    // Given: value  = 250
    //        factor = 2 (MB)
    //
    // Bytes = 250 << 20
    //       = 262,144,000 
    //       = 250 MB
    //
    for (int i = 0; i < ARRAYSIZE(rgValUnits); i++)
    {
        dwValue = DWORD(-1);
        DWORD dwUnits = DWORD(-1);

        key.GetValue(rgValUnits[i].pszValue, &dwValue);
        key.GetValue(rgValUnits[i].pszUnits, &dwUnits);
        *(rgValUnits[i].pValue) = LONGLONG(-1);
        // must cast dwValue to "int" since DWORDs are never negative
        // Don't need to test dwUnits for negative since negative DWORDs
        // turn into huge positive values, so it will fail the "6 >= dwUnits"
        // test.
        if (0 <= (int)dwValue && 6 >= dwUnits)
        {
            *(rgValUnits[i].pValue) = LONGLONG(dwValue) << (10 * dwUnits);
        }
    }

    //
    // This logic for setting the dwQuotaState member is the same as that
    // used in VolumePropPage::QuotaStateFromControls (volprop.cpp).
    //
    DWORD dwEnable  = 0;
    DWORD dwEnforce = 0;
    key.GetValue(REGSTR_VAL_POLICY_ENABLE,  &dwEnable);
    key.GetValue(REGSTR_VAL_POLICY_ENFORCE, &dwEnforce);
    if (dwEnable)
    {
        if (dwEnforce)
        {
            pInfo->dwQuotaState = DISKQUOTA_STATE_ENFORCE;
        }
        else
        {
            pInfo->dwQuotaState = DISKQUOTA_STATE_TRACK;
        }
    }
    else
    {
        pInfo->dwQuotaState = DISKQUOTA_STATE_DISABLED;
    }

    //
    // Get event logging settings.
    //
    DWORD dwLog = 0;
    key.GetValue(REGSTR_VAL_POLICY_LOGLIMIT, &dwLog);
    DISKQUOTA_SET_LOG_USER_LIMIT(pInfo->dwQuotaLogFlags, dwLog);
    dwLog = 0;
    key.GetValue(REGSTR_VAL_POLICY_LOGTHRESHOLD, &dwLog);
    DISKQUOTA_SET_LOG_USER_THRESHOLD(pInfo->dwQuotaLogFlags, dwLog);

    //
    // Determine if policy is to be applied to removable as well as fixed 
    // media.
    //
    if (SUCCEEDED(key.GetValue(REGSTR_VAL_POLICY_REMOVABLEMEDIA, &dwValue)))
    {
        pInfo->bRemovableMedia = boolify(dwValue);
    }
}


//
// Load machine policy information from the registry.  See comment
// in CDiskQuotaPolicy::Save( ) for registry location information.
//
HRESULT
CDiskQuotaPolicy::Load(
    LPDISKQUOTAPOLICYINFO pInfo
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::Load")));
    DBGASSERT((NULL != pInfo));

    if (NULL == m_pGPEInfo && NULL == m_hkeyRoot)
    {
        DBGERROR((TEXT("Policy object not initialized")));
        return E_FAIL;      // Not initialized.
    }

    HRESULT hr = E_FAIL;

    if (NULL == m_hkeyRoot &&
        SUCCEEDED(hr = m_pGPEInfo->GetRegistryKey(GPO_SECTION_MACHINE, &m_hkeyRoot)))
    {
        m_bRootKeyOpened = true;
    }
    if (NULL != m_hkeyRoot)
    {
        DBGPRINT((DM_POLICY, DL_LOW, TEXT("Opening reg key 0x%08X \"%s\""), m_hkeyRoot, m_szRegKeyPolicy));
        RegKey key(m_hkeyRoot, m_szRegKeyPolicy);
        hr = key.Open(KEY_READ);
        if (SUCCEEDED(hr))
        {
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("Reading disk quota policy information.")));
            LoadPolicyInfo(key, pInfo);

            if (m_bVerboseEventLog)
            {
                //
                // Report successful information retrieval.
                //
                g_Log.ReportEvent(EVENTLOG_INFORMATION_TYPE, 0, MSG_I_POLICY_INFOLOADED);
            }
        }
        else if (ERROR_FILE_NOT_FOUND != HRESULT_CODE(hr)) // Key doesn't always exist.
        {
            DBGERROR((TEXT("Error 0x%08X opening policy reg key"), hr));
            g_Log.Push(hr, CEventLog::eFmtHex);
            g_Log.Push(m_szRegKeyPolicy),
            g_Log.Push(hr, CEventLog::eFmtSysErr);
            g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_GPEREGKEYOPEN);
        }
    }
    else
    {
        DBGERROR((TEXT("m_hkeyRoot is NULL")));
        g_Log.Push(hr, CEventLog::eFmtHex);
        g_Log.Push(hr, CEventLog::eFmtSysErr);
        g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_GPEREGKEYROOT);
    }

    return hr;
}

#ifdef POLICY_MMC_SNAPIN
//
// NOTE:  This code has been disabled because we're moving from using an MMC
//          snapin to an ADM-file format that fits better into the current
//          MMC software policy scheme.  This Save() function was required for
//          the snapin implementation but is not required when we use an ADM file.
//          The function was originally written to store a whole DISKQUOTAPOLICYINFO 
//          structure in the registry and the original version of Load() was 
//          written to read a whole DISKQUOTAPOLICYINFO structure as REG_BINARY.
//          Since the ADM file works with specific reg values rather than a single
//          REG_BINARY, Load() was modified to work with values stored using
//          the ADM format.  Save() has not been modified.
//          
//          If we reactivate this function to use in a snapin, we need to 
//          update it to write out data in a format acceptable to Load().
//          [brianau - 6/25/98]
//
// This function saves the policy info to the following registry value on the
// local machine.
//
//    HKCU\Software\Microsoft\GPE\{98E1D3C1-9DC1-11D1-8544-0000F8046117}Machine\Software\Policies\Microsoft\Windows NT\DiskQuota\PolicyData"
// 
// The call to PolicyChanged( ) flushes the data to the server file:
//
//    \\<server>\SysVol\Policies\{98E1D3C1-9DC1-11D1-8544-0000F8046117}\machine\registry.pol
//
// where <server> is the name of the server.
//
//
HRESULT
CDiskQuotaPolicy::Save(
    LPCDISKQUOTAPOLICYINFO pInfo
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::Save")));
    DBGASSERT((NULL != pInfo));

    if (NULL == m_pGPEInfo && NULL == m_hkeyRoot)
    {
        DBGERROR((TEXT("Policy object not initialized")));
        return E_FAIL;      // Not initialized.
    }

    HRESULT hr = E_FAIL;

    if (NULL == m_hkeyRoot &&
        SUCCEEDED(hr = m_pGPEInfo->GetRegistryKey(GPO_SECTION_MACHINE, &m_hkeyRoot)))
    {
        m_bRootKeyOpened = true;
    }
    if (NULL != m_hkeyRoot)
    {
        DBGPRINT((DM_POLICY, DL_LOW, TEXT("Creating reg key 0x%08X \"%s\""), m_hkeyRoot, m_szRegKeyPolicy));
        RegKey key(m_hkeyRoot, m_szRegKeyPolicy);
        hr = key.Open(KEY_WRITE, true);
        if (SUCCEEDED(hr))
        {
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("Setting reg value \"%s\""), m_szRegValPolicy));
            hr = key.SetValue(m_szRegValPolicy, (LPBYTE)pInfo, sizeof(*pInfo));
            if (SUCCEEDED(hr))
            {
                DBGPRINT((DM_POLICY, DL_LOW, TEXT("Calling PolicyChanged().")));
                if (FAILED(hr = m_pGPEInfo->PolicyChanged(TRUE)))
                    DBGERROR((TEXT("Error 0x%08X returned by PolicyChanged()"), hr));
            }
            else
                DBGERROR((TEXT("Error 0x%08X setting policy reg value"), hr));
        }
        else
            DBGERROR((TEXT("Error 0x%08X opening policy reg key"), hr));
    }
    else
        DBGERROR((TEXT("m_hkeyRoot is NULL")));

    return hr;
}
#endif // POLICY_MMC_SNAPIN

//
// Apply policy information to all local NTFS volumes.  Removable media
// are optional per a value in the policy information structure.
//
HRESULT
CDiskQuotaPolicy::Apply(
    LPCDISKQUOTAPOLICYINFO pInfo
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::Apply")));
    DBGASSERT((NULL != pInfo));

    HRESULT hr    = NOERROR;
    BOOL bAborted = m_pbAbort ? *m_pbAbort : FALSE;

    try
    {
        if (!bAborted)
        {
            CString strVolCompleted;

            //
            // Get list of drives on which to set policy.
            //
            CArray<CString> rgstrDrives;
            hr = GetDriveNames(&rgstrDrives, pInfo->bRemovableMedia);
            int cDrives = rgstrDrives.Count();
            if (SUCCEEDED(hr) && 0 < cDrives)
            {
                //
                // Get the disk quota class factory.  This way we don't
                // call CoCreateInstance for each drive.  Only call it once then
                // call the class factory's CreateInstance for each drive.  
                // Should be more efficient.
                // 
                com_autoptr<IClassFactory> pcf;
                hr = CoCreateInstance(CLSID_DiskQuotaControl, 
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IClassFactory,
                                      reinterpret_cast<void **>(pcf.getaddr()));
                if (SUCCEEDED(hr))
                {
                    bAborted = m_pbAbort ? *m_pbAbort : FALSE;

                    for (int i = 0; i < cDrives && !bAborted; i++)
                    {
                        DBGPRINT((DM_POLICY, DL_MID, TEXT("Setting policy for \"%s\""), rgstrDrives[i].Cstr()));
                        //
                        // Get a quota control object and initialize it for drive[i].
                        // Init with read/write access.
                        //
                        com_autoptr<IDiskQuotaControl> pdqc;
                        hr = pcf->CreateInstance(NULL, 
                                                 IID_IDiskQuotaControl, 
                                                 reinterpret_cast<void **>(pdqc.getaddr()));
                        if (SUCCEEDED(hr))
                        {
                            hr = pdqc->Initialize(rgstrDrives[i], TRUE);
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Set the quota information on the volume.
                                //
                                if (FAILED(hr = pdqc->SetQuotaLogFlags(pInfo->dwQuotaLogFlags)))
                                {
                                    DBGERROR((TEXT("Error 0x%08X setting log flags"), hr));
                                    goto setpolerr;
                                }
                                if (FAILED(hr = pdqc->SetDefaultQuotaThreshold(pInfo->llDefaultQuotaThreshold)))
                                {
                                    DBGERROR((TEXT("Error 0x%08X setting default threshold"), hr));
                                    goto setpolerr;
                                }
                                if (FAILED(hr = pdqc->SetDefaultQuotaLimit(pInfo->llDefaultQuotaLimit)))
                                {
                                    DBGERROR((TEXT("Error 0x%08X setting default limit"), hr));
                                    goto setpolerr;
                                }
                                //
                                // Set state last in case we're enabling quotas.  That way
                                // any rebuild activity will come after the other settings have
                                // been set.
                                //
                                if (FAILED(hr = pdqc->SetQuotaState(DISKQUOTA_STATE_MASK & pInfo->dwQuotaState)))
                                {
                                    DBGERROR((TEXT("Error 0x%08X setting quota state"), hr));
                                    goto setpolerr;
                                }
                                goto setpolsuccess;
                            }
                            else
                                DBGERROR((TEXT("Error 0x%08X initializing vol \"%s\""), 
                                          hr, rgstrDrives[i].Cstr()));

setpolerr:
                            //
                            // Record error for this particular volume.
                            //
                            g_Log.Push(hr, CEventLog::eFmtHex);
                            g_Log.Push(rgstrDrives[i].Cstr());
                            g_Log.Push(hr, CEventLog::eFmtSysErr);
                            g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_SETQUOTA);
setpolsuccess:
                            if (m_bVerboseEventLog && SUCCEEDED(hr))
                            {
                                //
                                // Append name to list of drives that have been successful.
                                //
                                strVolCompleted += rgstrDrives[i];
                                strVolCompleted += CString(TEXT("  "));
                            }
                            pdqc = NULL;  // This releases pdqc.
                        }
                        else
                        {
                            DBGERROR((TEXT("CreateInstance failed with error 0x%08X"), hr));
                            g_Log.Push(hr, CEventLog::eFmtHex);
                            g_Log.Push(hr, CEventLog::eFmtSysErr);
                            g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_CREATEQUOTACONTROL);
                        }
                    }
                    pcf = NULL;  // This releases pcf.
                }
                else
                {
                    DBGERROR((TEXT("CoCreateInstance failed with error 0x%08X"), hr));
                    g_Log.Push(hr, CEventLog::eFmtHex);
                    g_Log.Push(hr, CEventLog::eFmtSysErr);
                    g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_CREATECLASSFACTORY);
                }
            }
            else
            {
                DBGERROR((TEXT("Error 0x%08X getting drive name list"), hr));
                g_Log.Push(hr, CEventLog::eFmtHex);
                g_Log.Push(hr, CEventLog::eFmtSysErr);
                g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_GETDRIVELIST);
            }

            if (m_bVerboseEventLog && 0 < strVolCompleted.Length())
            {
                //
                // Log successful completions by listing volumes
                // and applied policy values.
                //
                CString s;
                LONGLONG llValue;
                g_Log.Push(strVolCompleted);
                g_Log.Push(!DISKQUOTA_IS_DISABLED(pInfo->dwQuotaState));
                g_Log.Push(DISKQUOTA_IS_ENFORCED(pInfo->dwQuotaState));

                llValue = pInfo->llDefaultQuotaThreshold;
                if (LONGLONG(-1) != llValue)
                {
                    XBytes::FormatByteCountForDisplay(llValue, s.GetBuffer(40), 40);
                    s.ReleaseBuffer();
                }
                else
                {
                    s.Format(g_hInstDll, IDS_NO_LIMIT);
                }
                g_Log.Push(s);
                llValue = pInfo->llDefaultQuotaLimit;
                if (LONGLONG(-1) != llValue)
                {
                    XBytes::FormatByteCountForDisplay(llValue, s.GetBuffer(40), 40);
                    s.ReleaseBuffer();
                }
                else
                {
                    s.Format(g_hInstDll, IDS_NO_LIMIT);
                }
                g_Log.Push(s);
                g_Log.ReportEvent(EVENTLOG_INFORMATION_TYPE, 0, MSG_I_POLICY_FINISHED);
            }
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory.")));
        hr = E_OUTOFMEMORY;
        g_Log.ReportEvent(EVENTLOG_ERROR_TYPE, 0, MSG_E_POLICY_OUTOFMEMORY);
    }

    if (bAborted)
    {
        g_Log.ReportEvent(EVENTLOG_INFORMATION_TYPE, 0, MSG_I_POLICY_ABORTED);
    }

    return hr;
}

//
// Build a list of drives to which policy can be applied.
//
HRESULT
CDiskQuotaPolicy::GetDriveNames(   // [ static ]
    CArray<CString> *prgstrDrives,    // Output array of name strings.
    bool bRemovableMedia              // Include removable media?
    )
{
    DBGTRACE((DM_POLICY, DL_MID, TEXT("CDiskQuotaPolicy::GetDriveNames")));
    DBGASSERT((NULL != prgstrDrives));
    HRESULT hr = NOERROR;

    //
    // Get buffer size required to hold drive name strings.
    //
    int cch = GetLogicalDriveStrings(0, NULL);
    //
    // Allocate buffer and get the strings.
    //
    array_autoptr<TCHAR> ptrDrives(new TCHAR[cch + 1]);
    if (0 < GetLogicalDriveStrings(cch, ptrDrives.get()))
    {
        //
        // Iterate over all of the drive name strings.  Append to the 
        // string array each that can accept policy.
        //
        DblNulTermListIter iter(ptrDrives.get());
        LPCTSTR pszDrive;
        while(iter.Next(&pszDrive))
        {
            if (S_OK == OkToApplyPolicy(pszDrive, bRemovableMedia))
            {
                prgstrDrives->Append(CString(pszDrive));
            }
        }
    }
    else
    {
        DWORD dwErr = GetLastError();
        DBGERROR((TEXT("GetLogicalDriveStrings failed with error %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}


//
// Returns:  S_OK    = OK to set policy on drive.
//           S_FALSE = Not OK to set policy
//           Other   = Error occured.  Not OK to set policy.
//
HRESULT
CDiskQuotaPolicy::OkToApplyPolicy(  // [ static ]
    LPCTSTR pszDrive,       // Drive (volume) name string.
    bool bRemovableMedia    // Include removable media?
    )
{
    DBGTRACE((DM_POLICY, DL_LOW, TEXT("CDiskQuotaPolicy::OkToApplyPolicy")));
    HRESULT hr = S_FALSE;
    //
    // Primary filter is drive type.
    //
    UINT uDriveType = GetDriveType(pszDrive);
    switch(uDriveType)
    {
        case DRIVE_UNKNOWN:
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" is UNKNOWN"), pszDrive));
            return S_FALSE;

        case DRIVE_NO_ROOT_DIR:
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" has no root dir"), pszDrive));
            return S_FALSE;

        case DRIVE_REMOTE:
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" is REMOTE"), pszDrive));
            return S_FALSE;

        case DRIVE_CDROM:
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" is CDROM"), pszDrive));
            return S_FALSE;

        case DRIVE_RAMDISK:
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" is RAMDISK"), pszDrive));
            return S_FALSE;

        case DRIVE_REMOVABLE:
            //
            // Removable is allowable if policy says it is.  It should be
            // disallowed by default since using disk quota on removable media
            // doesn't make a lot of sense in most situations.
            //
            if (!bRemovableMedia)
            {
                DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" is REMOVABLE"), pszDrive));
                return S_FALSE;
            }
            //
            // Fall through...
            //
        case DRIVE_FIXED:
            //
            // Fixed drives are always acceptable.
            //
            break;

        default:
            DBGERROR((TEXT("Unknown drive type %d for \"%s\""), uDriveType, pszDrive));
            return S_FALSE;
    }

    //
    // Next filter is support for NTFS quotas.  We do the drive-type check first
    // because it doesn't require hitting the disks.  GetVolumeInformation does
    // hit the disk so we only want to do it if necessary.
    //
    DWORD dwFlags = 0;
    if (GetVolumeInformation(pszDrive, NULL, 0, NULL, NULL, &dwFlags, NULL, 0))
    {
        if (FILE_VOLUME_QUOTAS & dwFlags)
        {
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("Ok to set policy on \"%s\""), pszDrive));
            hr = S_OK;
        }
        else
        {
            DBGPRINT((DM_POLICY, DL_LOW, TEXT("\"%s\" doesn't support NTFS quotas"), pszDrive));
        }
    }
    else
    {
        DWORD dwErr = GetLastError();
        DBGERROR((TEXT("GetVolumeInformation failed with error %d for \"%s\""), 
                 dwErr, pszDrive));
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\ntds.h ===
#ifndef _INC_DSKQUOTA_NTDS_H
#define _INC_DSKQUOTA_NTDS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: ntds.h

    Description: Contains declaration for class NTDS.
        This class provides a simple wrapper around NT Directory Service
        name translation features.  It has no data and no virtual functions.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef __SSPI_H__
#   define SECURITY_WIN32
#   include <security.h>        // For TranslateName
#endif


class NTDS
{
    public:
        NTDS(VOID) { }
        ~NTDS(VOID) { }

        HRESULT LookupAccountByName(
                        LPCTSTR pszSystem,
                        LPCTSTR pszLogonName,
                        CString *pstrContainerName,
                        CString *pstrDisplayName,
                        PSID    pSid,
                        LPDWORD pdwSid,
                        PSID_NAME_USE peUse);

        HRESULT LookupAccountBySid(
                        LPCTSTR pszSystem,
                        PSID    pSid,
                        CString *pstrContainerName,
                        CString *pstrLogonName,
                        CString *pstrDisplayName,
                        PSID_NAME_USE peUse);


        HRESULT TranslateFQDNsToLogonNames(
                        const CArray<CString>& rgstrFQDNs,
                        CArray<CString> *prgstrLogonNames);

        HRESULT TranslateFQDNToLogonName(
                        LPCTSTR pszFQDN,
                        CString *pstrLogonName);

        static void CreateSamLogonName(LPCTSTR pszSamDomain, LPCTSTR pszSamUser, CString *pstrSamLogonName);
        static LPCTSTR FindFQDNInADsPath(LPCTSTR pszADsPath);
        static LPCTSTR FindSamAccountInADsPath(LPCTSTR pszADsPath);


    private:
        HRESULT LookupSamAccountName(
                        LPCTSTR pszSystem,
                        LPCTSTR pszLogonName,
                        CString *pstrContainerName,
                        CString *pstrDisplayName,
                        PSID    pSid,
                        LPDWORD pdwSid,
                        PSID_NAME_USE peUse);

        HRESULT LookupDsAccountName(
                        LPCTSTR pszSystem,
                        LPCTSTR pszLogonName,
                        CString *pstrContainerName,
                        CString *pstrDisplayName,
                        PSID    pSid,
                        LPDWORD pdwSid,
                        PSID_NAME_USE peUse);


        HRESULT GetSamAccountDisplayName(
                        LPCTSTR pszLogonName,
                        CString *pstrDisplayName);


        HRESULT GetDsAccountDisplayName(
                        LPCTSTR pszLogonName,
                        CString *pstrDisplayName);

        HRESULT TranslateNameInternal(
                        LPCTSTR pszAccountName,
                        EXTENDED_NAME_FORMAT AccountNameFormat,
                        EXTENDED_NAME_FORMAT DesiredNameFormat,
                        CString *pstrTranslatedName);

        HRESULT LookupAccountNameInternal(
                        LPCTSTR pszSystemName,
                        LPCTSTR pszAccountName,
                        PSID Sid,
                        LPDWORD pcbSid,
                        CString *pstrReferencedDomainName,
                        PSID_NAME_USE peUse);

        HRESULT LookupAccountSidInternal(
                        LPCTSTR pszSystemName,
                        PSID Sid,
                        CString *pstrName,
                        CString *pstrReferencedDomainName,
                        PSID_NAME_USE peUse);
};

#endif // _INC_DSKQUOTA_NTDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\private.h ===
#ifndef __DSKQUOTA_PRIVATE_H
#define __DSKQUOTA_PRIVATE_H
///////////////////////////////////////////////////////////////////////////////
/*  File: private.h

    Description: Private stuff used in the quota management library.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#define USEQUICKSORT  // Tell comctl32 to use QuickSort for sorting DPA's.

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NT_INCLUDED
#   include <nt.h>
#endif

#ifndef _NTRTL_
#   include <ntrtl.h>
#endif

#ifndef _NTURTL_
#   include <nturtl.h>
#endif

#ifndef _NTSEAPI_
#   include <ntseapi.h>
#endif

#ifdef __cplusplus
}  // end of extern "C"
#endif


#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef _INC_WINDOWSX
#   include <windowsx.h>
#endif

#ifndef _OLE2_H_
#   include <ole2.h>
#endif

#ifndef _OLECTL_H_
#   include <olectl.h>     // Standard OLE interfaces.
#endif

#ifndef _INC_SHELLAPI
#   include <shellapi.h>
#endif

#ifndef _SHLGUID_H_
#   include <shlguid.h>
#endif

#ifndef _INC_SHLWAPI
#   include <shlwapi.h>
#endif

#ifndef _SHLOBJ_H_
#   include <shlobj.h>
#endif

//
// Disable warnings.
//
#pragma warning( disable : 4100 )  // Unreferenced formal parameter
#pragma warning( disable : 4710 )  // Inline was not expanded


//
// Disable "inline" for DEBUG builds so we can set breakpoints
// on inlined methods.
//
#if DBG
#   define INLINE inline
#else
#   define INLINE
#endif

//
// Define PROFILE to activate IceCAP profiler.
//
#ifdef PROFILE
#   include "icapexp.h"
#   define ICAP_START       StartCAP()
#   define ICAP_START_ALL   StartCAPAll()
#   define ICAP_STOP        StopCAP()
#   define ICAP_STOP_ALL    StopCAPAll()
#   define ICAP_SUSPEND     SuspendCAP()
#   define ICAP_SUSPEND_ALL SuspendCAPAll()
#   define ICAP_RESUME      ResumeCAP()
#   define ICAP_RESUME_ALL  SuspendCAPAll()
#else
#   define ICAP_START       0
#   define ICAP_START_ALL   0
#   define ICAP_STOP        0
#   define ICAP_STOP_ALL    0
#   define ICAP_SUSPEND     0
#   define ICAP_SUSPEND_ALL 0
#   define ICAP_RESUME      0
#   define ICAP_RESUME_ALL  0
#endif

typedef unsigned __int64  UINT64;
typedef __int64           INT64;

#ifndef _INC_DSKQUOTA_DEBUG_H
#   include "debug.h"
#endif
#ifndef _INC_DSKQUOTA_DEBUGP_H
#   include "debugp.h"
#endif
#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif
#ifndef _INC_DSKQUOTA_THDSYNC_H
#   include "thdsync.h"
#endif
#ifndef _INC_DSKQUOTA_AUTOPTR_H
#   include "autoptr.h"
#endif
#ifndef _INC_DSKQUOTA_CARRAY_H
#   include "carray.h"
#endif
#ifndef _INC_DSKQUOTA_ALLOC_H
#   include "alloc.h"
#endif
#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif
#ifndef _INC_DSKQUOTA_PATHSTR_H
#   include "pathstr.h"
#endif
#ifndef _INC_DSKQUOTA_UTILS_H
#   include "utils.h"
#endif
#ifndef _INC_DSKQUOTA_DBLNUL_H
#   include "dblnul.h"
#endif
#ifndef _INC_DSKQUOTA_XBYTES_H
#   include "xbytes.h"
#endif
#ifndef _INC_DSKQUOTA_REGSTR_H
#   include "regstr.h"
#endif


extern HINSTANCE g_hInstDll;        // Global module instance handle.
extern LONG      g_cRefThisDll;     // Global module reference count.


//
// Unlimited quota threshold and limit are indicated by a value of -1.
// A limit of -2 marks a record for deletion.
// This is the way NTFS wants it.
//
const LONGLONG NOLIMIT  = (LONGLONG)-1;
const LONGLONG MARK4DEL = (LONGLONG)-2;

//
// Convenience macro for calculating number of elements in an array.
//
#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif
#define ARRAYSIZE(a)  (sizeof(a)/sizeof((a)[0]))

//
// Per-volume quota information.
//
typedef struct DiskQuotaFSObjectInformation {
    LONGLONG DefaultQuotaThreshold;
    LONGLONG DefaultQuotaLimit;
    ULONG    FileSystemControlFlags;
} DISKQUOTA_FSOBJECT_INFORMATION, *PDISKQUOTA_FSOBJECT_INFORMATION;


//
// SIDLIST is a synonym for FILE_GET_QUOTA_INFORMATION.
//
#define SIDLIST  FILE_GET_QUOTA_INFORMATION
#define PSIDLIST PFILE_GET_QUOTA_INFORMATION

//
// Private stuff for twiddling bits in quota state DWORD.
// Public clients don't need these.
// Note that the LOG_VOLUME_XXXX flags are not included.
// This feature is not exposed through the quota APIs.
//
#define DISKQUOTA_LOGFLAG_MASK              0x00000030
#define DISKQUOTA_LOGFLAG_SHIFT                      4
#define DISKQUOTA_FLAGS_MASK                0x00000337
#define DISKQUOTA_FILEFLAG_MASK             0x00000300


//
// Maximum length of a SID.
//
const UINT MAX_SID_LEN = (FIELD_OFFSET(SID, SubAuthority) + 
                          sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES);
//
// SID is a variable length structure.
// This defines how large the FILE_QUOTA_INFORMATION structure can be if the SID
// is maxed out.
//
const UINT FILE_QUOTA_INFORMATION_MAX_LEN = sizeof(FILE_QUOTA_INFORMATION) -
                                            sizeof(SID) +
                                            MAX_SID_LEN;

//
// FEATURE: These may actually be shorter than MAX_PATH.
//         Need to find out what actual max is.
//
const UINT MAX_USERNAME      = MAX_PATH;  // i.e. BrianAu
const UINT MAX_DOMAIN        = MAX_PATH;  // i.e. REDMOND
const UINT MAX_FULL_USERNAME = MAX_PATH;  // i.e. Brian Aust

const UINT MAX_VOL_LABEL = 33;  // Includes term NUL.

const UINT MAX_GUIDSTR_LEN = 40;


#endif // __DSKQUOTA_PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\policy.h ===
#ifndef _INC_DSKQUOTA_POLICY_H
#define _INC_DSKQUOTA_POLICY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: policy.h

    Description: Header for policy.cpp.
        See policy.cpp for functional description.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/14/98    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _GPEDIT_H_
#   include <gpedit.h>
#endif
#ifndef _INC_DSKQUOTA_EVENTLOG_H
#   include "eventlog.h"
#endif
#ifndef _INC_DSKQUOTA_REGISTRY_H
#   include "registry.h"
#endif

//
// Structure used for storing and transferring disk quota policy.
//
struct DISKQUOTAPOLICYINFO
{
    LONGLONG llDefaultQuotaThreshold;  // Default user quota threshold (bytes).
    LONGLONG llDefaultQuotaLimit;      // Default user quota limit (bytes).
    DWORD    dwQuotaState;             // NTFS quota state flags.
    DWORD    dwQuotaLogFlags;          // NTFS quota logging flags.
    bool     bRemovableMedia;          // Apply policy to removable media?
};

typedef DISKQUOTAPOLICYINFO *LPDISKQUOTAPOLICYINFO;
typedef const DISKQUOTAPOLICYINFO *LPCDISKQUOTAPOLICYINFO;


#undef INTERFACE
#define INTERFACE IDiskQuotaPolicy
DECLARE_INTERFACE_(IDiskQuotaPolicy, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // IDiskQuotaPolicy methods
    //
    STDMETHOD(Initialize)(THIS_ LPGPEINFORMATION pGPEInfo, HKEY hkeyRoot) PURE;
#ifdef POLICY_MMC_SNAPIN
    STDMETHOD(Save)(THIS_ LPCDISKQUOTAPOLICYINFO pInfo) PURE;
#endif
    STDMETHOD(Load)(THIS_ LPDISKQUOTAPOLICYINFO pInfo) PURE;
    STDMETHOD(Apply)(THIS_ LPCDISKQUOTAPOLICYINFO pInfo) PURE;
};
typedef IDiskQuotaPolicy *LPDISKQUOTAPOLICY;


//
// Class for saving/loading/applying disk quota policy information.
// Used by both the MMC policy snapin (server) and the GPE extension (client).
//
class CDiskQuotaPolicy : public IDiskQuotaPolicy
{
    public:
        explicit CDiskQuotaPolicy(LPGPEINFORMATION pGPEInfo = NULL, HKEY hkeyRoot = NULL, bool bVerboseEventLog = false, BOOL *pbAbort = NULL);
        ~CDiskQuotaPolicy(void);

        //
        // IUnknown interface.
        //
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //
        // IDiskQuotaPolicy interface.
        //
        STDMETHODIMP Initialize(LPGPEINFORMATION pGPEInfo, HKEY hkeyRoot);
#ifdef POLICY_MMC_SNAPIN
        STDMETHODIMP Save(const DISKQUOTAPOLICYINFO *pPolicyInfo);
#endif
        STDMETHODIMP Load(DISKQUOTAPOLICYINFO *pPolicyInfo);
        STDMETHODIMP Apply(const DISKQUOTAPOLICYINFO *pPolicyInfo);

    private:
        LONG             m_cRef;
        LPGPEINFORMATION m_pGPEInfo;
        HKEY             m_hkeyRoot;
        BOOL            *m_pbAbort;            // Monitor to detect abort.
        bool             m_bRootKeyOpened;     // Need to close root key?
        bool             m_bVerboseEventLog;   // Verbose log output?

        static const TCHAR m_szRegKeyPolicy[];
#ifdef POLICY_MMC_SNAPIN
        static const TCHAR m_szRegValPolicy[];
#endif
        static HRESULT GetDriveNames(CArray<CString> *prgstrDrives, bool bRemovableMedia);
        static HRESULT OkToApplyPolicy(LPCTSTR pszDrive, bool RemovableMedia);
        static void InitPolicyInfo(LPDISKQUOTAPOLICYINFO pInfo);
        static void LoadPolicyInfo(const RegKey& key, LPDISKQUOTAPOLICYINFO pInfo);
};


#endif // _INC_DSKQUOTA_POLICY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\shellinc.h ===
#ifndef _INC_DSKQUOTA_SHELLINC_H
#define _INC_DSKQUOTA_SHELLINC_H


#ifndef _INC_SHELLAPI
#   include <shellapi.h>
#endif


#endif // _INC_DSKQUOTA_SHELLINC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\registry.cpp ===
#include "pch.h"
#pragma hdrstop

#include "registry.h"

RegKey::RegKey(
    void
    ) : m_hkeyRoot(NULL),
        m_hkey(NULL),
        m_hChangeEvent(NULL),
        m_bWatchSubtree(false),
        m_dwChangeFilter(0)
{
    DBGTRACE((DM_REG, DL_MID, TEXT("RegKey::RegKey [default]")));
}


RegKey::RegKey(
    HKEY hkeyRoot,
    LPCTSTR pszSubKey
    ) : m_hkeyRoot(hkeyRoot),
        m_hkey(NULL),
        m_strSubKey(pszSubKey),
        m_hChangeEvent(NULL),
        m_bWatchSubtree(false),
        m_dwChangeFilter(0)
{
    DBGTRACE((DM_REG, DL_MID, TEXT("RegKey::RegKey")));
    //
    // Nothing to do.
    //
}


RegKey::~RegKey(
    void
    )
{
    DBGTRACE((DM_REG, DL_MID, TEXT("RegKey::~RegKey")));
    Close();
    if (NULL != m_hChangeEvent)
        CloseHandle(m_hChangeEvent);
}


HRESULT
RegKey::Open(
    REGSAM samDesired,  // Access mask (i.e. KEY_READ, KEY_WRITE etc.)
    bool bCreate        // Create key if it doesn't exist?
    ) const
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKey::Open")));
    DBGPRINT((DM_REG, DL_HIGH, TEXT("\thkeyRoot = 0x%08X, SubKey = \"%s\""),
                      m_hkeyRoot, m_strSubKey.Cstr()));

    DWORD dwResult = ERROR_SUCCESS;
    Close();
    if (bCreate)
    {
        DWORD dwDisposition;
        dwResult = RegCreateKeyEx(m_hkeyRoot,
                                 (LPCTSTR)m_strSubKey,
                                 0,
                                 NULL,
                                 0,
                                 samDesired,
                                 NULL,
                                 &m_hkey,
                                 &dwDisposition);
    }
    else
    {
        dwResult = RegOpenKeyEx(m_hkeyRoot,
                                (LPCTSTR)m_strSubKey,
                                0,
                                samDesired,
                                &m_hkey);
    }
    return HRESULT_FROM_WIN32(dwResult);
}


void 
RegKey::Attach(
    HKEY hkey
    )
{
    Close();
    m_strSubKey.Empty();
    m_hkeyRoot = NULL;
    m_hkey     = hkey;
}

void 
RegKey::Detach(
    void
    )
{
    m_hkey = NULL;
}


void
RegKey::Close(
    void
    ) const
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKey::Close")));
    DBGPRINT((DM_REG, DL_HIGH, TEXT("\thkeyRoot = 0x%08X, SubKey = \"%s\""),
                      m_hkeyRoot, m_strSubKey.Cstr()));

    if (NULL != m_hkey)
    {
        //
        // Do this little swap so that the m_hkey member is NULL
        // when the actual key is being closed.  This lets the async
        // change proc determine if it was signaled because of a true
        // change or because the key was being closed.
        //
        HKEY hkeyTemp = m_hkey;
        m_hkey = NULL;
        RegCloseKey(hkeyTemp);
    }
}


//
// This is the basic form of GetValue.  All other forms of 
// GetValue() call into this one.
//
HRESULT
RegKey::GetValue(
    LPCTSTR pszValueName,
    DWORD dwTypeExpected,
    LPBYTE pbData,
    int cbData
    ) const
{
    DWORD dwType;
    DWORD dwResult = RegQueryValueEx(m_hkey,
                                     pszValueName,
                                     0,
                                     &dwType,
                                     pbData,
                                     (LPDWORD)&cbData);

    if (ERROR_SUCCESS == dwResult && dwType != dwTypeExpected)
        dwResult = ERROR_INVALID_DATATYPE;

    return HRESULT_FROM_WIN32(dwResult);
}

//
// Get a DWORD value (REG_DWORD).
//
HRESULT
RegKey::GetValue(
    LPCTSTR pszValueName,
    DWORD *pdwDataOut
    ) const
{
    return GetValue(pszValueName, REG_DWORD, (LPBYTE)pdwDataOut, sizeof(DWORD));
}

//
// Get a byte buffer value (REG_BINARY).
//
HRESULT
RegKey::GetValue(
    LPCTSTR pszValueName,
    LPBYTE pbDataOut,
    int cbDataOut
    ) const
{
    return GetValue(pszValueName, REG_BINARY, pbDataOut, cbDataOut);
}

//
// Get a text string value (REG_SZ) and write it to a CString object.
//
HRESULT
RegKey::GetValue(
    LPCTSTR pszValueName,
    CString *pstrDataOut
    ) const
{
    HRESULT hr = E_FAIL;
    int cch = GetValueBufferSize(pszValueName) / sizeof(TCHAR);
    if (NULL != pstrDataOut && 0 < cch)
    {
        hr = GetValue(pszValueName, 
                      REG_SZ, 
                      (LPBYTE)pstrDataOut->GetBuffer(cch), 
                      pstrDataOut->SizeBytes());

        pstrDataOut->ReleaseBuffer();
    }
    return hr;
}


//
// Get a multi-text string value (REG_MULTI_SZ) and write it to a CArray<CString> object.
//
HRESULT
RegKey::GetValue(
    LPCTSTR pszValueName,
    CArray<CString> *prgstrOut
    ) const
{
    HRESULT hr = E_FAIL;
    int cb = GetValueBufferSize(pszValueName);
    if (NULL != prgstrOut && 0 < cb)
    {
        array_autoptr<TCHAR> ptrTemp(new TCHAR[cb / sizeof(TCHAR)]);
        LPCTSTR psz = ptrTemp.get();
        hr = GetValue(pszValueName, REG_MULTI_SZ, (LPBYTE)psz, cb);
        if (SUCCEEDED(hr))
        {
            while(psz && TEXT('\0') != *psz)
            {
                prgstrOut->Append(CString(psz));
                psz += lstrlen(psz) + 1;
            }
        }
    }
    return hr;
}


//
// Return the required buffer size for a given registry value.
//
int
RegKey::GetValueBufferSize(
    LPCTSTR pszValueName
    ) const
{
    DWORD dwType;
    int cbData = 0;
    DWORD dwDummy;
    DWORD dwResult = RegQueryValueEx(m_hkey,
                                     pszValueName,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwDummy,
                                     (LPDWORD)&cbData);
    if (ERROR_MORE_DATA != dwResult)
        cbData = 0;

    return cbData;
}


//
// This is the basic form of SetValue.  All other forms of 
// SetValue() call into this one.
//
HRESULT
RegKey::SetValue(
    LPCTSTR pszValueName,
    DWORD dwValueType,
    const LPBYTE pbData, 
    int cbData
    )
{
    DWORD dwResult = RegSetValueEx(m_hkey,
                                   pszValueName,
                                   0,
                                   dwValueType,
                                   pbData,
                                   cbData);

    return HRESULT_FROM_WIN32(dwResult);
}
      
//
// Set a DWORD value (REG_DWORD).
//
HRESULT
RegKey::SetValue(
    LPCTSTR pszValueName,
    DWORD dwData
    )
{
    return SetValue(pszValueName, REG_DWORD, (const LPBYTE)&dwData, sizeof(dwData));
}


//
// Set a byte buffer value (REG_BINARY).
//
HRESULT
RegKey::SetValue(
    LPCTSTR pszValueName,
    const LPBYTE pbData,
    int cbData
    )
{
    return SetValue(pszValueName, REG_BINARY, pbData, cbData);
}


//
// Set a text string value (REG_SZ).
//
HRESULT
RegKey::SetValue(
    LPCTSTR pszValueName,
    LPCTSTR pszData
    )
{
    return SetValue(pszValueName, REG_SZ, (const LPBYTE)pszData, (lstrlen(pszData) + 1) * sizeof(TCHAR));
}

//
// Set a text string value (REG_MULTI_SZ).
//
HRESULT
RegKey::SetValue(
    LPCTSTR pszValueName,
    const CArray<CString>& rgstrSrc
    )
{
    array_autoptr<TCHAR> ptrValues(CreateDoubleNulTermList(rgstrSrc));
    int cch = 1;
    int n = rgstrSrc.Count();

    for (int i = 0; i < n; i++)
        cch += rgstrSrc[i].Length() + 1;

    return SetValue(pszValueName, REG_MULTI_SZ, (const LPBYTE)ptrValues.get(), cch * sizeof(TCHAR));
}


LPTSTR
RegKey::CreateDoubleNulTermList(
    const CArray<CString>& rgstrSrc
    ) const
{
    int cEntries = rgstrSrc.Count();
    int cch = 1; // Account for 2nd nul term.
    int i;
    for (i = 0; i < cEntries; i++)
        cch += rgstrSrc[i].Length() + 1;

    LPTSTR pszBuf = new TCHAR[cch];
    LPTSTR pszWrite = pszBuf;

    for (i = 0; i < cEntries; i++)
    {
        CString& s = rgstrSrc[i];
        lstrcpy(pszWrite, s);
        pszWrite += s.Length() + 1;
    }
    *pszWrite = TEXT('\0'); // Double nul term.
    return pszBuf;
}


void 
RegKey::OnChange(
    HKEY hkey
    )
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKey::OnChange")));
    //
    // Default does nothing.
    //
}


DWORD
RegKey::NotifyWaitThreadProc(
    LPVOID pvParam
    )
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKey::NotifyWaitThreadProc")));
    RegKey *pThis = (RegKey *)pvParam;

    while(NULL != pThis->m_hkey)
    {
        DBGPRINT((DM_REG, DL_HIGH, TEXT("RegNotifyChangeKey(0x%08X, %d, 0x%08X, 0x%08X, %d)"),
                 pThis->m_hkey, pThis->m_bWatchSubtree, pThis->m_dwChangeFilter, pThis->m_hChangeEvent, true));
        LONG lResult = RegNotifyChangeKeyValue(pThis->m_hkey,
                                               pThis->m_bWatchSubtree,
                                               pThis->m_dwChangeFilter,
                                               pThis->m_hChangeEvent,
                                               true);
        if (ERROR_SUCCESS != lResult)
        {
            DBGERROR((TEXT("RegNotifyChangeKeyValue failed with error %d"), lResult));
            return 0;
        }
        else
        {
            DBGPRINT((DM_REG, DL_MID, TEXT("Waiting for reg change notification...")));
            switch(WaitForSingleObject(pThis->m_hChangeEvent, INFINITE))
            {
                case WAIT_OBJECT_0:
                    if (NULL != pThis->m_hkey)
                    {
                        DBGPRINT((DM_REG, DL_MID, TEXT("Rcv'd reg change notification")));
                        pThis->OnChange(pThis->m_hkey);
                    }
                    break;

                case WAIT_FAILED:
                    DBGERROR((TEXT("Registry chg wait failed with error %d"), GetLastError()));
                    break;

                default:
                    break;
            }
        }
    }
    return 0;
}



HRESULT 
RegKey::WatchForChange(
    DWORD dwChangeFilter, 
    bool bWatchSubtree
    )
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKey::WatchForChange")));
    HRESULT hr = E_FAIL;
    
    if (NULL != m_hChangeEvent || NULL == m_hkey)
        return E_FAIL;

    m_hChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hChangeEvent)
    {
        DBGERROR((TEXT("CreateEvent failed error %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    m_dwChangeFilter = dwChangeFilter;
    m_bWatchSubtree  = bWatchSubtree;

    DWORD dwThreadId = 0;
    HANDLE hThread = CreateThread(NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE)NotifyWaitThreadProc,
                                  this,
                                  0,
                                  &dwThreadId);
    if (INVALID_HANDLE_VALUE != hThread)
    {
        DBGPRINT((DM_REG, DL_MID, TEXT("Reg key chg watch thread ID = %d"), dwThreadId));
        CloseHandle(hThread);
        hr = NOERROR;
    }
    return hr;
}


HRESULT 
RegKey::WaitForChange(
    DWORD dwChangeFilter, 
    bool bWatchSubtree
    )
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKey::WaitForChange")));
    HRESULT hr = NOERROR;
    LONG lResult = RegNotifyChangeKeyValue(m_hkey,
                                           bWatchSubtree,
                                           dwChangeFilter,
                                           NULL,
                                           false);

    if (ERROR_SUCCESS != lResult)
    {
        DBGERROR((TEXT("RegNotifyChangeKeyValue failed with error %d"), lResult));
        hr = HRESULT_FROM_WIN32(lResult);
    }
    return hr;
}
                 

#if DBG
//-----------------------------------------------------------------------------
//                        DEBUG ONLY
//-----------------------------------------------------------------------------
RegKeyChg::RegKeyChg(
    HKEY hkeyRoot, 
    LPCTSTR pszSubKey
    ) : RegKey(hkeyRoot, pszSubKey)
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKeyChg::RegKeyChg")));
    HRESULT hr = Open(KEY_READ | KEY_NOTIFY);
    if (SUCCEEDED(hr))
    {
        hr = WatchForChange(REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME, true); 
        if (FAILED(hr))
        {
            DBGERROR((TEXT("WatchForChange failed with error 0x%08X"), hr));
        }
    }
    else if (ERROR_FILE_NOT_FOUND != HRESULT_CODE(hr))
    {
        DBGERROR((TEXT("Error 0x%08X opening key 0x%08X \"%s\""), hr, hkeyRoot, pszSubKey));
    }
}


RegKeyChg::~RegKeyChg(
    void
    )
{ 
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKeyChg::~RegKeyChg"))); 
}


void
RegKeyChg::OnChange(
    HKEY hkey
    )
{
    DBGTRACE((DM_REG, DL_HIGH, TEXT("RegKeyChg::OnChange")));
    RegKey key;
    key.Attach(hkey);
    DebugRegParams dp;
    HRESULT hr = key.GetValue(REGSTR_VAL_DEBUGPARAMS, (LPBYTE)&dp, sizeof(dp));
    if (SUCCEEDED(hr))
    {
        DBGPRINT((DM_REG, DL_HIGH, TEXT("Setting new debug parameters")));
        DBGPRINTMASK(dp.PrintMask);
        DBGPRINTLEVEL(dp.PrintLevel);
        DBGPRINTVERBOSE(dp.PrintVerbose);
        DBGTRACEMASK(dp.TraceMask);
        DBGTRACELEVEL(dp.TraceLevel);
        DBGTRACEVERBOSE(dp.TraceVerbose);
        DBGTRACEONEXIT(dp.TraceOnExit);
    }
    else
        DBGERROR((TEXT("GetValue failed with error 0x%08X"), hr));

    key.Detach();
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\regstr.h ===
#ifndef _INC_DSKQUOTA_REGSTR_H
#define _INC_DSKQUOTA_REGSTR_H

//
// Registry strings associated with disk quota policy.
//
#define REGSTR_KEY_POLICYDATA   TEXT("Software\\Policies\\Microsoft\\Windows NT\\DiskQuota")
#ifdef POLICY_MMC_SNAPIN
    #define REGSTR_VAL_POLICYDATA   TEXT("PolicyData")
#endif
#define REGSTR_VAL_POLICY_ENABLE            TEXT("Enable")
#define REGSTR_VAL_POLICY_ENFORCE           TEXT("Enforce")
#define REGSTR_VAL_POLICY_LIMIT             TEXT("Limit")
#define REGSTR_VAL_POLICY_THRESHOLD         TEXT("Threshold")
#define REGSTR_VAL_POLICY_LIMITUNITS        TEXT("LimitUnits")
#define REGSTR_VAL_POLICY_THRESHOLDUNITS    TEXT("ThresholdUnits")
#define REGSTR_VAL_POLICY_REMOVABLEMEDIA    TEXT("ApplyToRemovableMedia")
#define REGSTR_VAL_POLICY_LOGLIMIT          TEXT("LogEventOverLimit")
#define REGSTR_VAL_POLICY_LOGTHRESHOLD      TEXT("LogEventOverThreshold")

//
// This is the subkey we store data under in the registry (HKCU).
// If you want to change the location in HKCU, this is all you have to change.
//
#define REGSTR_KEY_DISKQUOTA    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\DiskQuota")
#define REGSTR_VAL_PREFERENCES  TEXT("Preferences")
#define REGSTR_VAL_FINDMRU      TEXT("FindMRU")
#define REGSTR_VAL_DEBUGPARAMS  TEXT("DebugParams")

//
// Shell extension registry keys.
//
#define REGSTR_KEY_APPROVEDSHELLEXT TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define REGSTR_KEY_DRIVEPROPSHEETS  TEXT("Drive\\shellex\\PropertySheetHandlers")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\resource.h ===
#ifndef __COMMON_RESOURCE_DEFS_H
#define __COMMON_RESOURCE_DEFS_H

#define IDS_ORDERBYTES                  80008
#define IDS_ORDERKB                     80009
#define IDS_ORDERMB                     80010
#define IDS_ORDERGB                     80011
#define IDS_ORDERTB                     80012
#define IDS_ORDERPB                     80013
#define IDS_ORDEREB                     80014
#define IDS_NO_LIMIT                    80015
#define IDC_STATIC                      -1

#endif //__COMMON_RESOURCE_DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\strclass.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: strclass.cpp

    Description: Typical class to handle strings.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "strclass.h"


#ifdef StrCpy
#   undef StrCpy
#endif
#ifdef StrCpyN
#   undef StrCpyN
#endif
#ifdef StrLen
#   undef StrLen
#endif

#ifdef UNICODE
#   define StrCpy   StrCpyW
#   define StrCpyN  StrCpyNW
#   define StrLen   StrLenW
#else
#   define StrCpy   StrCpyA
#   define StrCpyN  StrCpyNA
#   define StrLen   StrLenA
#endif // UNICODE

const INT MAX_RESOURCE_STR_LEN = 4097;


//
// Disable "'operator ->' is not a UDT or reference to a UDT" warning.
// This is caused when we create an autoptr to a non-UDT.  It's meaningless
// since there's no reason to call operator-> on a non-UDT autoptr.
//
#pragma warning (disable : 4284)

CString::CString(
    VOID
    ) : m_pValue(new StringValue())
{

}

CString::CString(
    INT cch
    ) : m_pValue(new StringValue(cch))
{

}

CString::CString(
    LPCSTR pszA
    ) : m_pValue(new StringValue(pszA))
{

}

CString::CString(
    LPCWSTR pszW
    ) : m_pValue(new StringValue(pszW))
{

}

CString::CString(
    const CString& rhs
    ) : m_pValue(rhs.m_pValue)
{
    InterlockedIncrement(&(m_pValue->m_cRef));
}


CString::CString(
    HINSTANCE hInst,
    INT idMsg,
    ...
    ) : m_pValue(NULL)
{
    LPTSTR pszMsg = NULL;
    va_list args;

    va_start(args, idMsg);

    Format(hInst, idMsg, &args);

    va_end(args);
}

CString::~CString(
    VOID
    )
{
    if (NULL != m_pValue)
    {
        if (0 == InterlockedDecrement(&(m_pValue->m_cRef)))
            delete m_pValue;
    }
}

//
// Length of string, excluding nul terminator.
//
INT
CString::Length(
    VOID
    ) const
{
    return m_pValue->Length();
}


VOID
CString::Empty(
    VOID
    )
{
    if (0 == InterlockedDecrement(&(m_pValue->m_cRef)))
    {
        delete m_pValue;
        m_pValue = NULL;
    }

    m_pValue = new StringValue();
}

BOOL
CString::IsEmpty(
    VOID
    ) const
{
    return (NULL != m_pValue && 0 == m_pValue->Length());
}



CString&
CString::operator = (
    const CString& rhs
    )
{
    if (m_pValue != rhs.m_pValue) // Chk for assignment to *this.
    {
        if (0 == InterlockedDecrement(&(m_pValue->m_cRef)))
            delete m_pValue;

        m_pValue = rhs.m_pValue;
        InterlockedIncrement(&(m_pValue->m_cRef));
    }
    return *this;
}

CString&
CString::operator = (
    LPCWSTR rhsW
    )
{
    if (0 == InterlockedDecrement(&(m_pValue->m_cRef)))
    {
        delete m_pValue;
        m_pValue = NULL;
    }

    m_pValue = new StringValue(rhsW);
    return *this;
}


CString&
CString::operator = (
    LPCSTR rhsA
    )
{
    if (0 == InterlockedDecrement(&(m_pValue->m_cRef)))
    {
        delete m_pValue;
        m_pValue = NULL;
    }

    m_pValue = new StringValue(rhsA);
    return *this;
}


CString
CString::operator + (
    const CString& rhs
    ) const
{
    CString strNew;
    LPTSTR pszTemp = NULL;
    try
    {
        pszTemp = StringValue::Concat(m_pValue, rhs.m_pValue);
        strNew = pszTemp;
    }
    catch(...)
    {
        delete[] pszTemp;
        throw;
    }
    delete[] pszTemp;

    return strNew;
}



CString&
CString::operator += (
    const CString& rhs
    )
{
    LPTSTR pszTemp = NULL;
    try
    {
        pszTemp = StringValue::Concat(m_pValue, rhs.m_pValue);
        *this = pszTemp;
    }
    catch(...)
    {
        delete[] pszTemp;
        throw;
    }
    delete[] pszTemp;
    return *this;
}


BOOL
CString::operator == (
    const CString& rhs
    ) const
{
    return (0 == lstrcmp(m_pValue->m_psz, rhs.m_pValue->m_psz));
}


INT
CString::Compare(
    LPCWSTR rhsW
    ) const
{
    StringValue Value(rhsW);
    return lstrcmp(m_pValue->m_psz, Value.m_psz);
}


INT
CString::Compare(
    LPCSTR rhsA
    ) const
{
    StringValue Value(rhsA);
    return lstrcmp(m_pValue->m_psz, Value.m_psz);
}

INT
CString::CompareNoCase(
    LPCWSTR rhsW
    ) const
{
    StringValue Value(rhsW);
    return lstrcmpi(m_pValue->m_psz, Value.m_psz);
}


INT
CString::CompareNoCase(
    LPCSTR rhsA
    ) const
{
    StringValue Value(rhsA);
    return lstrcmpi(m_pValue->m_psz, Value.m_psz);
}

BOOL
CString::operator < (
    const CString& rhs
    ) const
{
    return (0 > lstrcmp(m_pValue->m_psz, rhs.m_pValue->m_psz));
}


TCHAR
CString::operator[](
    INT index
    ) const
{
    if (!ValidIndex(index))
        throw CMemoryException(CMemoryException::index);

    return m_pValue->m_psz[index];
}


TCHAR&
CString::operator[](
    INT index
    )
{
    if (!ValidIndex(index))
        throw CMemoryException(CMemoryException::index);

    CopyOnWrite();
    return m_pValue->m_psz[index];
}

INT
CString::First(
    TCHAR ch
    ) const
{
    LPCTSTR psz = m_pValue->m_psz;
    LPCTSTR pszLast = psz;
    INT i = 0;
    while(psz && *psz)
    {
        if (ch == *psz)
            return i;

        psz = CharNext(psz);
        i += (INT)(psz - pszLast);
        pszLast = psz;
    }
    return -1;
}


INT
CString::Last(
    TCHAR ch
    ) const
{
    INT iLast = -1;
    INT i = 0;
    LPCTSTR psz = m_pValue->m_psz;
    LPCTSTR pszPrev = psz;
    while(psz && *psz)
    {
        if (ch == *psz)
            iLast = i;

        psz = CharNext(psz);
        i += (INT)(psz - pszPrev);
        pszPrev = psz;
    }
    return iLast;
}



CString
CString::SubString(
    INT iFirst,
    INT cch
    )
{

    if (!ValidIndex(iFirst))
        throw CMemoryException(CMemoryException::index);

    INT cchToEnd = Length() - iFirst;

    if (-1 == cch || cch > cchToEnd)
        return CString(m_pValue->m_psz + iFirst);

    LPTSTR pszTemp = new TCHAR[cch + 1];
    if (NULL == pszTemp)
        throw CAllocException();

    CString::StrCpyN(pszTemp, m_pValue->m_psz + iFirst, cch + 1);
    CString strTemp(pszTemp);
    delete[] pszTemp;

    return strTemp;
}


VOID
CString::ToUpper(
    INT iFirst,
    INT cch
    )
{
    if (!ValidIndex(iFirst))
        throw CMemoryException(CMemoryException::index);

    CopyOnWrite();
    INT cchToEnd = Length() - iFirst;

    if (-1 == cch || cch > cchToEnd)
        cch = cchToEnd;

    CharUpperBuff(m_pValue->m_psz + iFirst, cch);
}


VOID
CString::ToLower(
    INT iFirst,
    INT cch
    )
{
    if (!ValidIndex(iFirst))
        throw CMemoryException(CMemoryException::index);

    CopyOnWrite();
    INT cchToEnd = Length() - iFirst;

    if (-1 == cch || cch > cchToEnd)
        cch = cchToEnd;

    CharLowerBuff(m_pValue->m_psz + iFirst, cch);
}


VOID
CString::Size(
    INT cch
    )
{
    StringValue *m_psv = new StringValue(cch + 1);
    CString::StrCpyN(m_psv->m_psz, m_pValue->m_psz, cch);

    if (m_pValue->m_cRef > 1)
    {
        InterlockedDecrement(&(m_pValue->m_cRef));
    }
    else
    {
        delete m_pValue;
    }
    m_pValue = m_psv;
}


VOID
CString::CopyOnWrite(
    VOID
    )
{
    //
    // Only need to copy if ref cnt > 1.
    //
    if (m_pValue->m_cRef > 1)
    {
        LPTSTR pszTemp = m_pValue->m_psz;
        InterlockedDecrement(&(m_pValue->m_cRef));
        m_pValue = NULL;
        m_pValue = new StringValue(pszTemp);
    }
}



BOOL
CString::Format(
    LPCTSTR pszFmt,
    ...
    )
{
    BOOL bResult;
    va_list args;
    va_start(args, pszFmt);
    bResult = Format(pszFmt, &args);
    va_end(args);

    return bResult;
}


BOOL
CString::Format(
    LPCTSTR pszFmt,
    va_list *pargs
    )
{
    BOOL bResult = FALSE;
    TCHAR szBuffer[MAX_RESOURCE_STR_LEN];
    INT cchLoaded;

    cchLoaded = ::FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                                pszFmt,
                                0,
                                0,
                                szBuffer,
                                ARRAYSIZE(szBuffer),
                                pargs);

    if (0 < cchLoaded)
    {
        if (NULL != m_pValue && 0 == InterlockedDecrement(&(m_pValue->m_cRef)))
            delete m_pValue;

        m_pValue = NULL;
        m_pValue = new StringValue(szBuffer);

        bResult = TRUE;
    }
    else
    {
        DWORD dwLastError = GetLastError();
        if (ERROR_SUCCESS != dwLastError)
        {
            DBGERROR((TEXT("CString::Format failed with error 0x%08X"), dwLastError));
            throw CResourceException(CResourceException::string, NULL, 0);
        }
    }

    return bResult;
}


BOOL
CString::Format(
    HINSTANCE hInst,
    UINT idFmt,
    ...
    )
{
    BOOL bResult;
    va_list args;
    va_start(args, idFmt);
    bResult = Format(hInst, idFmt, &args);
    va_end(args);
    return bResult;
}


BOOL
CString::Format(
    HINSTANCE hInst,
    UINT idFmt,
    va_list *pargs
    )
{
    BOOL bResult = FALSE;

    TCHAR szFmtStr[MAX_RESOURCE_STR_LEN]; // Buffer for format string (if needed).
    INT cchLoaded;

    //
    // Try to load the format string as a string resource.
    //
    cchLoaded = ::LoadString(hInst, idFmt, szFmtStr, ARRAYSIZE(szFmtStr));

    if (0 < cchLoaded)
    {
        //
        // The format string was in a string resource.
        // Now format it with the arg list.
        //
        bResult = Format(szFmtStr, pargs);
    }
    else
    {
        TCHAR szBuffer[MAX_RESOURCE_STR_LEN];

        //
        // The format string may be in a message resource.
        // Note that if it is, the resulting formatted string will
        // be automatically attached to m_psz by ::FormatMessage.
        //
        cchLoaded = ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                                    FORMAT_MESSAGE_FROM_HMODULE,
                                    hInst,
                                    (DWORD)idFmt,
                                    LANGIDFROMLCID(GetThreadLocale()),
                                    (LPTSTR)szBuffer,
                                    ARRAYSIZE(szBuffer),
                                    pargs);

        if (0 < cchLoaded)
        {
            if (NULL != m_pValue && 0 == InterlockedDecrement(&(m_pValue->m_cRef)))
                delete m_pValue;

            m_pValue = NULL;
            m_pValue = new StringValue(szBuffer);

            bResult = TRUE;
        }
        else
        {
            DWORD dwLastError = GetLastError();
            if (ERROR_SUCCESS != dwLastError)
            {
                DBGERROR((TEXT("CString::Format failed with error 0x%08X"), dwLastError));
                throw CResourceException(CResourceException::string, hInst, idFmt);
            }
        }
    }
    return bResult;
}


LPTSTR
CString::GetBuffer(
    INT cchMax
    )
{
    if (-1 == cchMax)
        cchMax = m_pValue->m_cchAlloc;

    CopyOnWrite();
    if (cchMax > m_pValue->m_cchAlloc)
    {
        //
        // Extend the buffer, copying original contents to dest.
        //
        StringValue *pv = new StringValue(cchMax);

        StrCpyN(pv->m_psz, m_pValue->m_psz, cchMax);

        if (0 == InterlockedDecrement(&(m_pValue->m_cRef)))
            delete m_pValue;

        m_pValue = pv;

        LPTSTR pszEnd = m_pValue->m_psz + m_pValue->m_cchAlloc - 1;
        if (pszEnd >= m_pValue->m_psz && TEXT('\0') != *(pszEnd))
        {
            //
            // Ensure it's nul terminated.
            //
            *(pszEnd) = TEXT('\0');
        }
    }

    return m_pValue->m_psz;
}


VOID
CString::ReleaseBuffer(
    void
    )
{
    //
    // Update the string length member after client has had free access
    // to internal buffer.
    //
    m_pValue->m_cch = StrLen(m_pValue->m_psz);
}

void
CString::Rtrim(
    void
    )
{
    LPTSTR s = GetBuffer();
    int len = Length();

    while(0 < --len && IsWhiteSpace(s[len]))
        s[len] = TEXT('\0');

    ReleaseBuffer();
}


void
CString::Ltrim(
    void
    )
{
    LPTSTR s0;
    LPTSTR s = s0 = GetBuffer();

    while(*s && IsWhiteSpace(*s))
        s++;
    while(*s)
        *s0++ = *s++;
    *s0 = TEXT('\0');

    ReleaseBuffer();
}


VOID
CString::ExpandEnvironmentStrings(
    VOID
    )
{
    DWORD cchBuffer = 0;  // Size of expansion buffer.
    DWORD cchPath   = 0;  // Count of actual chars in expanded buffer.

    CString strExpanded;  // Expansion buffer.

    //
    // If necessary, keep increasing expansion buffer size until entire
    // expanded string fits.
    //
    do
    {
        cchBuffer += MAX_PATH;

        cchPath = ::ExpandEnvironmentStrings(*this,
                                             strExpanded.GetBuffer(cchBuffer),
                                             cchBuffer);
    }
    while(0 != cchPath && cchPath > cchBuffer);
    ReleaseBuffer();

    *this = strExpanded;
}


bool
CString::GetDisplayRect(
    HDC hdc,
    LPRECT prc
    ) const
{
    return (0 != DrawText(hdc, Cstr(), Length(), prc, DT_CALCRECT));
}


VOID
CString::DebugOut(
    BOOL bNewline
    ) const
{
    OutputDebugString(m_pValue->m_psz);
    if (bNewline)
        OutputDebugString(TEXT("\n\r"));
}


CString::StringValue::StringValue(
    VOID
    ) : m_psz(new TCHAR[1]),
        m_cchAlloc(1),
        m_cch(0),
        m_cRef(1)
{
    *m_psz = TEXT('\0');
}


CString::StringValue::StringValue(
    LPCSTR pszA
    ) : m_psz(NULL),
        m_cchAlloc(0),
        m_cch(0),
        m_cRef(1)
{
#ifdef UNICODE
    m_psz = AnsiToWide(pszA, &m_cchAlloc);
    m_cch = StrLenW(m_psz);
#else
    m_cch = CString::StrLenA(pszA);
    m_psz = Dup(pszA, m_cch + 1);
    m_cchAlloc = m_cch + 1;
#endif
}

CString::StringValue::StringValue(
    LPCWSTR pszW
    ) : m_psz(NULL),
        m_cchAlloc(0),
        m_cch(0),
        m_cRef(1)
{
#ifdef UNICODE
    m_cch = CString::StrLenW(pszW);
    m_psz = Dup(pszW, m_cch + 1);
    m_cchAlloc = m_cch + 1;
#else
    m_psz  = WideToAnsi(pszW, &m_cchAlloc);
    m_cch  = StrLenA(m_psz);
#endif
}

CString::StringValue::StringValue(
    INT cch
    ) : m_psz(NULL),
        m_cchAlloc(0),
        m_cch(0),
        m_cRef(0)
{
    m_psz      = Dup(TEXT(""), cch);
    m_cRef     = 1;
    m_cchAlloc = cch;
}


CString::StringValue::~StringValue(
    VOID
    )
{
    delete[] m_psz;
}

LPWSTR
CString::StringValue::AnsiToWide(
    LPCSTR pszA,
    INT *pcch
    )
{
    INT cchW    = 0;
    LPWSTR pszW = NULL;

    cchW = MultiByteToWideChar(CP_ACP,
                               0,
                               pszA,
                               -1,
                               NULL,
                               0);

    pszW = new WCHAR[cchW];
    if (NULL == pszW)
        throw CAllocException();

    MultiByteToWideChar(CP_ACP,
                        0,
                        pszA,
                        -1,
                        pszW,
                        cchW);

    if (NULL != pcch)
        *pcch = cchW;

    return pszW;
}

LPSTR
CString::StringValue::WideToAnsi(
    LPCWSTR pszW,
    INT *pcch
    )
{
    INT cchA   = 0;
    LPSTR pszA = NULL;

    cchA = WideCharToMultiByte(CP_ACP,
                               0,
                               pszW,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);

    pszA = new CHAR[cchA];
    if (NULL == pszA)
        throw CAllocException();

    WideCharToMultiByte(CP_ACP,
                        0,
                        pszW,
                        -1,
                        pszA,
                        cchA,
                        NULL,
                        NULL);

    if (NULL != pcch)
        *pcch = cchA;

    return pszA;
}


INT
CString::StringValue::Length(
    VOID
    ) const
{
    if (0 == m_cch && NULL != m_psz)
    {
        m_cch = StrLen(m_psz);
    }
    return m_cch;
}


LPWSTR
CString::StringValue::Dup(
    LPCWSTR pszW,
    INT cch
    )
{
    if (0 == cch)
        cch = CString::StrLenW(pszW) + 1;

    LPWSTR pszNew = new WCHAR[cch];
    if (NULL == pszNew)
        throw CAllocException();

    CString::StrCpyW(pszNew, pszW);
    return pszNew;
}


LPSTR
CString::StringValue::Dup(
    LPCSTR pszA,
    INT cch
    )
{
    if (0 == cch)
        cch = CString::StrLenA(pszA) + 1;

    LPSTR pszNew = new CHAR[cch];
    if (NULL == pszNew)
        throw CAllocException();

    CString::StrCpyA(pszNew, pszA);
    return pszNew;
}


LPTSTR
CString::StringValue::Concat(
    CString::StringValue *psv1,
    CString::StringValue *psv2
    )
{
    LPTSTR pszTemp = NULL;
    INT len1 = psv1->Length();
    INT len2 = psv2->Length();

    pszTemp = new TCHAR[len1 + len2 + 1];
    if (NULL == pszTemp)
        throw CAllocException();

    CString::StrCpy(pszTemp, psv1->m_psz);
    CString::StrCpy(pszTemp + len1, psv2->m_psz);

    return pszTemp;
}


#pragma warning (default : 4284)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\registry.h ===
#ifndef _INC_DSKQUOTA_REGISTRY_H
#define _INC_DSKQUOTA_REGISTRY_H

#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

#ifndef _INC_DSKQUOTA_CARRAY_H
#   include "carray.h"
#endif
//
// Represents a single registry key.  Provides basic functions for 
// opening and closing the key as well as setting and querying for
// values in that key.  Closure of the key handle is ensured through
// the destructor.
//
class RegKey
{
    public:
        RegKey(void);
        RegKey(HKEY hkeyRoot, LPCTSTR pszSubKey);
        virtual ~RegKey(void);

        operator HKEY(void) const
            { return m_hkey; }

        HKEY GetHandle(void) const
            { return m_hkey; }

        HRESULT Open(REGSAM samDesired, bool bCreate = false) const;
        void Attach(HKEY hkey);
        void Detach(void);
        void Close(void) const;

        int GetValueBufferSize(
            LPCTSTR pszValueName) const;

        bool IsOpen(void) const
            { return NULL != m_hkey; }

        HRESULT WatchForChange(DWORD dwChangeFilter, bool bWatchSubtree = false);
        HRESULT WaitForChange(DWORD dwChangeFilter, bool bWatchSubtree = false);

        //
        // Retrieve REG_DWORD
        //
        HRESULT GetValue(
            LPCTSTR pszValueName,
            DWORD *pdwDataOut) const;
        //
        // Retrieve REG_BINARY
        //
        HRESULT GetValue(
            LPCTSTR pszValueName,
            LPBYTE pbDataOut,
            int cbDataOut) const;
        //
        // Retrieve REG_SZ
        //
        HRESULT GetValue(
            LPCTSTR pszValueName,
            CString *pstrDataOut) const;
        //
        // Retrieve REG_MULTI_SZ
        //
        HRESULT GetValue(
            LPCTSTR pszValueName,
            CArray<CString> *prgstrOut) const;
        //
        // Set REG_DWORD
        //
        HRESULT SetValue(
            LPCTSTR pszValueName,
            DWORD dwData);
        //
        // Set REG_BINARY
        //
        HRESULT SetValue(
            LPCTSTR pszValueName,
            const LPBYTE pbData,
            int cbData);
        //
        // Set REG_SZ
        //
        HRESULT SetValue(
            LPCTSTR pszValueName,
            LPCTSTR pszData);
        //
        // Set REG_MULTI_SZ
        //
        HRESULT SetValue(
            LPCTSTR pszValueName,
            const CArray<CString>& rgstrData);

    protected:
        virtual void OnChange(HKEY hkey);

    private:
        HKEY         m_hkeyRoot;
        mutable HKEY m_hkey;
        HANDLE       m_hChangeEvent;
        DWORD        m_dwChangeFilter;
        CString      m_strSubKey;
        bool         m_bWatchSubtree;

        HRESULT SetValue(
            LPCTSTR pszValueName,
            DWORD dwValueType,
            const LPBYTE pbData, 
            int cbData);

        HRESULT GetValue(
            LPCTSTR pszValueName,
            DWORD dwTypeExpected,
            LPBYTE pbData,
            int cbData) const;

        LPTSTR CreateDoubleNulTermList(
            const CArray<CString>& rgstrSrc) const;

        static DWORD NotifyWaitThreadProc(LPVOID pvParam);

        //
        // Prevent copy.
        //
        RegKey(const RegKey& rhs);
        RegKey& operator = (const RegKey& rhs);
};


#if DBG
class RegKeyChg : public RegKey
{
    public:
        RegKeyChg(HKEY hkeyRoot, LPCTSTR pszSubKey);
        ~RegKeyChg(void);

    protected:
        virtual void OnChange(HKEY hkey);
};

#endif // #if DBG

#endif // _INC_DSKQUOTA_REGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\alloc.cpp ===
#include "pch.h"
#pragma hdrstop

#include "alloc.h"
#include "except.h"


void * __cdecl operator new(
    size_t size
    )
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}

void* __cdecl operator new[] (size_t size)
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}


void __cdecl operator delete(
    void *ptr
    )
{
    if (NULL != ptr)
        LocalFree(ptr);
}


void __cdecl operator delete[] (void* ptr)
{
    if (NULL != ptr)
        LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\thdsync.h ===
#ifndef _INC_CSCVIEW_THDSYNC_H
#define _INC_CSCVIEW_THDSYNC_H
///////////////////////////////////////////////////////////////////////////////
/*  File: thdsync.h

    Description: Contains classes for managing thread synchronization in 
        Win32 programs.  Most of the work is to provide automatic unlocking
        of synchronization primities on object destruction.  The work on 
        monitors and condition variables is strongly patterned after 
        work in "Multithreaded Programming with Windows NT" by Pham and Garg.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif
#ifndef _INC_DSKQUOTA_DEBUG_H
#   include "debug.h"
#endif

class CCriticalSection
{
    public:
        CCriticalSection(void)
            { InitializeCriticalSection(&m_cs); }
        ~CCriticalSection(void)
            { DeleteCriticalSection(&m_cs); }

        void Enter(void)
            { EnterCriticalSection(&m_cs); }

        void Leave(void)
            { LeaveCriticalSection(&m_cs); }

        operator CRITICAL_SECTION& ()
            { return m_cs; }

    private:
        CRITICAL_SECTION m_cs;
        //
        // Prevent copy.
        //
        CCriticalSection(const CCriticalSection& rhs);
        CCriticalSection& operator = (const CCriticalSection& rhs);
};


class CWin32SyncObj
{
    public:
        explicit CWin32SyncObj(HANDLE handle)
            : m_handle(handle) { }
        virtual ~CWin32SyncObj(void)
            { if (NULL != m_handle) CloseHandle(m_handle); }

        HANDLE Handle(void)
            { return m_handle; }

    protected:
        HANDLE m_handle;
};


class CSemaphore : public CWin32SyncObj
{
    public:
        explicit CSemaphore(DWORD dwInitialCount = 0, DWORD dwMaxCount = 1);
        ~CSemaphore(void) { };

        DWORD Wait(DWORD dwTimeout = INFINITE)
            { return WaitForSingleObject(m_handle, dwTimeout); }
        void Release(DWORD dwReleaseCount = 1)
            { ReleaseSemaphore(m_handle, dwReleaseCount, NULL); }

    private:
        //
        // Prevent copy.
        //
        CSemaphore(const CSemaphore& rhs);
        CSemaphore& operator = (const CSemaphore& rhs);
};


class CSemaphoreList
{
    public:
        CSemaphoreList(void)
            : m_pFirst(NULL),
              m_pLast(NULL) { }

        ~CSemaphoreList(void);

        void Append(CSemaphore *pSem);
        void Prepend(CSemaphore *pSem);
        CSemaphore *Head(void);
        bool bEmpty(void)
            { return (NULL == m_pFirst); }
        void Dump(void);

    private:
        class Item
        {
            public:
                Item(CSemaphore *pSem, Item *pNext = NULL)
                    : m_pSem(pSem), m_pNext(pNext) { }

                CSemaphore *m_pSem;
                Item       *m_pNext;
        };

        Item *m_pFirst;
        Item *m_pLast;
};        


class CMutex : public CWin32SyncObj
{
    public:
        explicit CMutex(BOOL InitialOwner = FALSE);
        ~CMutex(void) { };

        DWORD Wait(DWORD dwTimeout = INFINITE)
            { return WaitForSingleObject(m_handle, dwTimeout); }
        void Release(void)
            { ReleaseMutex(m_handle); }

    private:
        //
        // Prevent copy.
        //
        CMutex(const CMutex& rhs);
        CMutex& operator = (const CMutex& rhs);
};


class CEvent : public CWin32SyncObj
{
    public:
        explicit CEvent(BOOL bManualReset, BOOL bInitialState);
        ~CEvent(void) { };

        BOOL Set(void)
            { return SetEvent(m_handle); }
        BOOL Reset(void)
            { return ResetEvent(m_handle); }

    private:
        //
        // Prevent copy.
        //
        CEvent(const CEvent& rhs);
        CEvent& operator = (const CEvent& rhs);
};


class CMonitor
{
    public:
        CMonitor(void) { }
        ~CMonitor(void) { }

        virtual void Lock(void)
            { m_Mutex.Wait(); }
        virtual void Release(void)
            { m_Mutex.Release(); }

    protected:
        CMutex m_Mutex;
};


class CConditionSU;  // fwd decl for use in CMonitorSU.

//
// "Signal-Urgent" monitor.
// Signalling threads are guaranteed to run immediately after the signaled
// thread exits the monitor.
//
class CMonitorSU : public CMonitor
{
    public:
        CMonitorSU(void)
            : m_cUrgentSemCount(0) { }
        ~CMonitorSU(void) { }

        virtual void Release(void);

    protected:
        int            m_cUrgentSemCount;
        CSemaphoreList m_UrgentSemList;

    friend class CConditionSU;
};


//
// "Signal-Return" condition variable.
// Thread that is signaled is guaranteed to own the mutex lock following
// receipt of the signal.
//
class CConditionSR
{
    public:
        explicit CConditionSR(CMonitor& monitor)
            : m_Monitor(monitor),
              m_cSemCount(0) { }

        virtual ~CConditionSR(void) { }

        virtual void Wait(void);
        virtual void Signal(void);

    protected:
        CMonitor&  m_Monitor;
        CSemaphore m_Sem;
        int        m_cSemCount;
};

//
// "Signal-Urgent" condition variable.
// A signaling thread is guaranteed to run first when the
// signaled thread exits the monitor.  
//
class CConditionSU
{
    public:
        explicit CConditionSU(CMonitorSU& monitor)
            : m_Monitor(monitor),
              m_cSemCount(0) { }
        virtual ~CConditionSU(void) { }

        virtual void Wait(void);
        virtual void Signal(void);

    protected:
        CMonitorSU&    m_Monitor;
        CSemaphoreList m_SemList;
        int            m_cSemCount;
};

       

//
// An "auto lock" object based on a Win32 critical section.
// The constructor automatically calls EnterCriticalSection for the 
// specified critical section.  The destructor automatically calls
// LeaveCriticalSection.  Note that the critical section object may
// be specified as a Win32 CRITICAL_SECTION or a CCriticalSection object.
// If using a CRITICAL_SECTION object, initialization and deletion of 
// the CRITICALS_SECTION is the responsibility of the caller.
//
class AutoLockCs
{
    public:
        explicit AutoLockCs(CRITICAL_SECTION& cs)
            : m_cLock(0),
              m_pCS(&cs) { Lock(); }

        void Lock(void)
            { DBGASSERT((0 <= m_cLock)); EnterCriticalSection(m_pCS); m_cLock++; }

        void Release(void)
            { m_cLock--; LeaveCriticalSection(m_pCS); }

        ~AutoLockCs(void) { if (0 < m_cLock) Release(); }

    private:
        CRITICAL_SECTION *m_pCS;
        int               m_cLock;
};


//
// An "auto lock" object based on a Win32 Mutex object.
// The constructor automatically calls WaitForSingleObject for the 
// specified mutex.  The destructor automatically calls
// ReleaseMutex. 
//
class AutoLockMutex
{
    public:
        //
        // Attaches to an already-owned mutex to ensure release.
        //
        explicit AutoLockMutex(HANDLE hMutex)
            : m_hMutex(hMutex) { }

        explicit AutoLockMutex(CMutex& mutex)
            : m_hMutex(mutex.Handle()) { }

        AutoLockMutex(HANDLE hMutex, DWORD dwTimeout)
            : m_hMutex(hMutex) { Wait(dwTimeout); }

        AutoLockMutex(CMutex& mutex, DWORD dwTimeout)
            : m_hMutex(mutex.Handle()) { Wait(dwTimeout); }

        ~AutoLockMutex(void) { ReleaseMutex(m_hMutex); }

    private:
        HANDLE m_hMutex;

        void Wait(DWORD dwTimeout = INFINITE);
};


//
// Automatically locks a monitor on creation and releases the 
// lock on destruction.  Helps exception-safety of monitor functions.
//
class AutoLockMonitor
{
    public:
        explicit AutoLockMonitor(CMonitor& monitor)
            : m_Monitor(monitor)
            { m_Monitor.Lock(); }

        ~AutoLockMonitor(void)
            { m_Monitor.Release(); }

    private:
        CMonitor& m_Monitor;
};


#endif // _INC_CSCVIEW_THDSYNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\thdsync.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: thdsync.cpp

    Description: Contains classes for managing thread synchronization in 
        Win32 programs.  Most of the work is to provide automatic unlocking
        of synchronization primities on object destruction.  The work on 
        monitors and condition variables is strongly patterned after 
        work in "Multithreaded Programming with Windows NT" by Pham and Garg.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "thdsync.h"


CSemaphore::CSemaphore(
    DWORD dwInitialCount,
	DWORD dwMaxCount
    ) : CWin32SyncObj(CreateSemaphore(NULL, dwInitialCount, dwMaxCount, NULL))
{
    if (NULL == Handle())
        throw CSyncException(CSyncException::semaphore, CSyncException::create);
}



CSemaphoreList::~CSemaphoreList(
    void
    )
{
    for (Item *pItem = m_pFirst; NULL != pItem; pItem = m_pFirst)
    {
        m_pFirst = m_pFirst->m_pNext;
        delete pItem->m_pSem;
        delete pItem;
    }
}


void
CSemaphoreList::Dump(
    void
    )
{
    DBGPRINT((TEXT("List: 0x%08X  ------------------------------"), this));
    DBGPRINT((TEXT("m_pFirst = 0x%08X"), m_pFirst));
    DBGPRINT((TEXT("m_pLast  = 0x%08X"), m_pLast));
    for (Item *pItem = m_pFirst; NULL != pItem; pItem = pItem->m_pNext)
    {
        DBGPRINT((TEXT("\tpItem = 0x%08X"), pItem));
        DBGPRINT((TEXT("\t\tm_pNext = 0x%08X"), pItem->m_pNext));
        DBGPRINT((TEXT("\t\tm_pSem  = 0x%08X"), pItem->m_pSem));
    }
}

//
// Insert a semaphore at the head of the list.
//
void
CSemaphoreList::Prepend(
    CSemaphore *pSem
    )
{
    m_pFirst = new Item(pSem, m_pFirst);
    if (NULL == m_pLast)
    {
        m_pLast = m_pFirst;
    }
}


//
// Append a semaphore to the tail of the list.
//
void 
CSemaphoreList::Append(
    CSemaphore *pSem
    )
{
    if (NULL == m_pFirst)
    {
        //
        // Empty list.  Append is same as prepend.
        //
        Prepend(pSem);
    }
    else
    {
        //
        // Create and append the new item.
        //
        m_pLast->m_pNext = new Item(pSem);
        m_pLast = m_pLast->m_pNext;
    }
}

//
// Remove item from the head of the list and return the
// semaphore pointer held in the item.  Delete the item.
//
CSemaphore *
CSemaphoreList::Head(
    void
    )
{
    CSemaphore *pSem = NULL;
    Item *pHead = m_pFirst;             // Get first item.
    if (NULL != pHead)
    {
        pSem = pHead->m_pSem;           // Get first item's semaphore ptr.
        m_pFirst = m_pFirst->m_pNext;   // Unlink item from list.

        delete pHead;                   // Delete item.

        if (NULL == m_pFirst)
            m_pLast = NULL;             //  Adjust "last" ptr if necessary.
    }
    return pSem;                        // Return semaphore ptr.
}


CMutex::CMutex(
    BOOL bInitialOwner
    ) : CWin32SyncObj(CreateMutex(NULL, bInitialOwner, NULL))
{
    if (NULL == Handle())
        throw CSyncException(CSyncException::mutex, CSyncException::create);
}

CEvent::CEvent(
    BOOL bManualReset,
    BOOL bInitialState
    ) : CWin32SyncObj(CreateEvent(NULL, bManualReset, bInitialState, NULL))
{
    if (NULL == Handle())
        throw CSyncException(CSyncException::event, CSyncException::create);
}


//
// Release a "signal-unrgent" monitor.
//
void 
CMonitorSU::Release(
    void
    )
{
    if (0 != m_cUrgentSemCount)
    {
        //
        // There's more than one thread waiting on the "urgent" list.
        // Wake it up and let it run INSIDE of the monitor.
        //
        CSemaphore *pSem = m_UrgentSemList.Head();
        if (NULL != pSem)
        {
            pSem->Release();
        }
    }
    else
    {
        //
        // Exit the monitor.
        //
        m_Mutex.Release();
    }
}

//
// Wait on a "signal-return" condition variable.
//
void 
CConditionSR::Wait(
    void
    )
{
    m_cSemCount++;       // One more thread waiting.
    m_Monitor.Release(); // Release monitor's lock to prevent deadlock.
    m_Sem.Wait();        // Block until condition is signaled.
    m_cSemCount--;       // Have the lock, no longer waiting.
}

//
// Signal a "signal-return" condition variable.
//
void 
CConditionSR::Signal(
    void
    )
{
    //
    // If any threads blocked on the condition variable, release one 
    // of them.
    //
    if (0 < m_cSemCount)
        m_Sem.Release();        // Release thd's blocked on semaphore.
    else
        m_Monitor.Release();    // Release monitor's lock.
}

//
// Wait on a "signal-urgent" condition variable.
//
void 
CConditionSU::Wait(
    void
    )
{
    CSemaphore *pSem = new CSemaphore;
    if (NULL != pSem)
    {
        //
        // Add the semaphore to the list of waiting threads.
        //
        m_SemList.Append(pSem);
        m_cSemCount++;
        if (0 != m_Monitor.m_cUrgentSemCount)
        {
            //
            // At least 1 thread on the "urgent" list.  Get the one highest
            // priority and let it run while we wait.
            //
            CSemaphore *pUrgentItem = m_Monitor.m_UrgentSemList.Head();
            if (NULL != pUrgentItem)
            {
                pUrgentItem->Release();
            }
        }
        else
        {
            //
            // Exit the monitor.
            //
            m_Monitor.Release();
        }
        //
        // Wait for this condition variable to be signaled.
        //
        pSem->Wait();
        m_cSemCount--;
        delete pSem;
    }
}

//
// Signal a "signal-urgent" condition variable.
//
void 
CConditionSU::Signal(
    void
    )
{
    if (0 < m_cSemCount)
    {
        //
        // At least 1 thread waiting on this condition variable.
        //
        CSemaphore *pSemNew = new CSemaphore;
        if (NULL != pSemNew)
        {
            //
            // Add a new semaphore to the "urgent" list.
            //
            m_Monitor.m_UrgentSemList.Prepend(pSemNew);
            m_Monitor.m_cUrgentSemCount++;
            //
            // Retrieve the next semaphore from the condition list and
            // release it allowing it's thread to run.
            //
            CSemaphore *pSemFromList = m_SemList.Head();
            if (NULL != pSemFromList)
            {
                pSemFromList->Release();
            }
            //
            // Wait for this condition variable to be signaled.
            //
            pSemNew->Wait();
            m_Monitor.m_cUrgentSemCount--;
            delete pSemNew;
        }
    }
}

//
// Wait on a Win32 mutex object.
// Throw an exception if the mutex has been abandoned or the wait has timed out.
//
void
AutoLockMutex::Wait(
    DWORD dwTimeout
    )
{
    DWORD dwStatus = WaitForSingleObject(m_hMutex, dwTimeout);
    switch(dwStatus)
    {
        case WAIT_ABANDONED:
            throw CSyncException(CSyncException::mutex, CSyncException::abandoned);
            break;
        case WAIT_TIMEOUT:
            throw CSyncException(CSyncException::mutex, CSyncException::timeout);
            break;
        default:
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\utils.h ===
#ifndef _INC_DSKQUOTA_UTILS_H
#define _INC_DSKQUOTA_UTILS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: utils.h

    Description: Header for general utilities module.  It is expected that
        windows.h is included before this header.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_DSKQUOTA_PRIVATE_H
#   include "private.h"
#endif

//
// Convert a value to a "bool".
// Lower-case "boolify" is intentional to enforce relationship
// to type "bool".
//
template <class T>
inline bool boolify(const T& x)
{
    return !!x;
}


template <class T>
const T&
MAX(const T& a, const T& b)
{
    return a > b ? a : b;
}

template <class T>
const T&
MIN(const T& a, const T& b)
{
    return a < b ? a : b;
}


template <class T>
void
SWAP(T& a, T& b)
{
    T temp(a);
    a = b;
    b = temp;
}


//
// Trivial class for ensuring window redraw is restored in the case
// of an exception.
//
class CAutoSetRedraw
{
    public:
        CAutoSetRedraw(HWND hwnd)
            : m_hwnd(hwnd) { }

        CAutoSetRedraw(HWND hwnd, bool bSet)
            : m_hwnd(hwnd) { Set(bSet); }

        ~CAutoSetRedraw(void)
            { Set(true); }

        void Set(bool bSet)
            { SendMessage(m_hwnd, WM_SETREDRAW, (WPARAM)bSet, 0); }

    private:
        HWND m_hwnd;
};


//
// Trivial class for ensuring window is enabled in the case
// of an exception.
//
class CAutoWndEnable
{
    public:
        CAutoWndEnable(HWND hwnd)
            : m_hwnd(hwnd) { }

        CAutoWndEnable(HWND hwnd, bool bEnable)
            : m_hwnd(hwnd) { Enable(bEnable); }

        ~CAutoWndEnable(void)
            { Enable(true); }

        void Enable(bool bEnable)
            { EnableWindow(m_hwnd, bEnable); }

    private:
        HWND m_hwnd;
};


//
// Ensure NT handles are exception safe.
//
class CNtHandle
{
    public:
        CNtHandle(HANDLE handle)
            : m_handle(handle) { }

        CNtHandle(void)
            : m_handle(NULL) { }

        ~CNtHandle(void)
            { Close(); }

        void Close(void)
            { if (m_handle) NtClose(m_handle); m_handle = NULL; }

        operator HANDLE() const
            { return m_handle; }

        HANDLE *HandlePtr(void)
            { DBGASSERT((NULL == m_handle)); return &m_handle; }

    private:
        HANDLE m_handle;

        //
        // Prevent copy.
        // This class is only intended for automatic handle cleanup.
        //
        CNtHandle(const CNtHandle& rhs);
        CNtHandle& operator = (const CNtHandle& rhs);
};


//
// Ensure Win32 handles are exception safe.
//
class CWin32Handle
{
    public:
        CWin32Handle(HANDLE handle)
            : m_handle(handle) { }

        CWin32Handle(void)
            : m_handle(NULL) { }

        ~CWin32Handle(void)
            { Close(); }

        void Close(void)
            { if (m_handle) CloseHandle(m_handle); m_handle = NULL; }

        operator HANDLE() const
            { return m_handle; }

        HANDLE *HandlePtr(void)
            { DBGASSERT((NULL == m_handle)); return &m_handle; }

    private:
        HANDLE m_handle;

        //
        // Prevent copy.
        // This class is only intended for automatic handle cleanup.
        //
        CWin32Handle(const CWin32Handle& rhs);
        CWin32Handle& operator = (const CWin32Handle& rhs);
};


//
// Trivial inline class to automate the cleanup of a STGMEDIUM
// structure.
//
class CStgMedium : public STGMEDIUM
{
    public:
        CStgMedium(void)
            { tymed = TYMED_NULL; hGlobal = NULL; pUnkForRelease = NULL; }

        ~CStgMedium(void)
            { ReleaseStgMedium(this); }

        operator LPSTGMEDIUM(void)
            { return (LPSTGMEDIUM)this; }

        operator const STGMEDIUM& (void)
            { return (STGMEDIUM &)*this; }
};


//
// On mounted volumes, the parsing name and display name are different.
// The parsing name contains a GUID which means nothing to the user.
// This class encapsulates both strings into a single class that can
// be passed as a single object to functions requiring a volume
// identifier.
//
// Here is an example of what the strings will contain:
//
//          Mounted volume              Non-mounted volume
//
// Display  Label (C:\FOO)              C:\
// Parsing  \\?\Volume\{GUID}           C:\
// FSPath   C:\FOO                      C:\
//
// I've coded this using only CString object references to leverage
// the reference counting of the CString class and minimize string copying.
//
class CVolumeID
{
    public:
        CVolumeID(void)
            : m_bMountedVol(false) { }

        CVolumeID(
            const CString& strForParsing, 
            const CString& strForDisplay,
            const CString& strFSPath
            ) : m_bMountedVol(false)
            { SetNames(strForParsing, strForDisplay, strFSPath); }

        ~CVolumeID(void) { };

        bool IsMountedVolume(void) const
            { return m_bMountedVol; }

        void SetNames(
            const CString& strForParsing, 
            const CString& strForDisplay,
            const CString& strFSPath)
            { m_strForParsing = strForParsing;
              m_strFSPath     = strFSPath;
              m_strForDisplay = strForDisplay;
              m_bMountedVol = !!(strForParsing != strForDisplay); }

        const CString& ForParsing(void) const
            { return m_strForParsing; }

        void ForParsing(CString *pstr) const
            { *pstr = m_strForParsing; }

        const CString& ForDisplay(void) const
            { return m_strForDisplay; }

        void ForDisplay(CString *pstr) const
            { *pstr = m_strForDisplay; }

        const CString& FSPath(void) const
            { return m_strFSPath; }

        void FSPath(CString *pstr) const
            { *pstr = m_strFSPath; }

    private:
        CString m_strForParsing;
        CString m_strForDisplay;
        CString m_strFSPath;
        bool    m_bMountedVol;
};



//
// Don't want to include dskquota.h for these.
// Including it here places the CLSIDs and IIDs in the precompiled header
// which screws up the declaration/definition of the GUIDs.
//
struct IDiskQuotaUser; // fwd decl.
#define SIDLIST  FILE_GET_QUOTA_INFORMATION
#define PSIDLIST PFILE_GET_QUOTA_INFORMATION

BOOL SidToString(
    PSID pSid,
    LPTSTR pszSid,
    LPDWORD pcchSid);

BOOL SidToString(
    PSID pSid,
    LPTSTR *ppszSid);

HRESULT
CreateSidList(
    PSID *rgpSids,
    DWORD cpSids,
    PSIDLIST *ppSidList,
    LPDWORD pcbSidList);

VOID MessageBoxNYI(VOID);

inline INT DiskQuotaMsgBox(HWND hWndParent,
                           LPCTSTR pszText,
                           LPCTSTR pszTitle,
                           UINT uType);

INT DiskQuotaMsgBox(HWND hWndParent,
                    UINT idMsgText,
                    UINT idMsgTitle,
                    UINT uType);

INT DiskQuotaMsgBox(HWND hWndParent,
                    UINT idMsgText,
                    LPCTSTR pszTitle,
                    UINT uType);

INT DiskQuotaMsgBox(HWND hWndParent,
                    LPCTSTR pszText,
                    UINT idMsgTitle,
                    UINT uType);

LPTSTR StringDup(LPCTSTR pszSource);
PSID SidDup(PSID pSid);
BOOL UserIsAdministrator(IDiskQuotaUser *pUser);
VOID CenterPopupWindow(HWND hwnd, HWND hwndParent = NULL);
HRESULT CallRegInstall(HINSTANCE hInstance, LPSTR szSection);
void GetDlgItemText(HWND hwnd, UINT idCtl, CString *pstrText);



#endif // _INC_DSKQUOTA_UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\xbytes.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: xbytes.cpp

    Description: This module implements a class that coordinates the operation
        between the edit control and combo box used for entering byte values.
        The name "XBytes" is used because the control can represent
        KBytes, MBytes, GBytes etc.

        The cooperation between edit control and combo control is required
        so that the user can enter a byte value in the edit control then
        indicate it's order (KB, MB, GB...) using a selection from the combo box.

        A simple external interface is provided to initially set the
        object's byte value then retrieve the byte value when needed.  The
        object's client is also required to call two member functions when
        the parent dialog receives an EN_UPDATE notification and a CBN_SELCHANGE
        message.  The XBytes object handles all of the value scaling
        internally.

        NOTE: I experimented with adding a spin control to the edit control.
            I found that without some fancy intervention, the spin control
            didn't support fractional values (i.e. 2.5MB).  Decided to keep
            fractional values and ditch the spinner.  I think fractional
            values will be more useful to disk admins.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    07/23/97    Added default ctor and CommonInit() function.        BrianAu
                Also added g_ForLoadingStaticStrings instance.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include "resource.h"
#include "xbytes.h"

const TCHAR CH_NUL      = TEXT('\0');
const TCHAR CH_ZERO     = TEXT('0');
const INT MAX_EDIT_TEXT = 16;                     // Max chars in edit text.
const INT MAX_CMB_TEXT  = 10;                     // For "KB", "MB", "GB" etc.
const INT64 MAX_VALUE   = ((1i64 << 60) * 6i64);  // Max is 6EB.
const INT64 MIN_VALUE   = 1024i64;                // Min value is 1KB.

TCHAR XBytes::m_szNoLimit[];            // "No Limit" edit control text.

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::XBytes

    Description: Constructor

    Arguments:
        hDlg - Handle to parent dialog.

        idCtlEdit - Control ID for edit control.

        idCtlCombo - Control ID for combo box control.

        CurrentBytes - Initial byte value.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/15/96    Added m_MaxBytes member.                             BrianAu
    05/29/98    Removed m_MaxBytes member. Don't want to limit       BrianAu
                user's ability to enter a value larger than
                max disk space.
*/
///////////////////////////////////////////////////////////////////////////////
XBytes::XBytes(
    HWND hDlg,
    DWORD idCtlEdit,
    DWORD idCtlCombo,
    INT64 CurrentBytes
    ) : m_hDlg(hDlg),
        m_idCtlEdit(idCtlEdit),
        m_idCtlCombo(idCtlCombo),
        m_ValueBytes(0)
{
    CommonInit();

    LoadComboItems(MAXLONGLONG);        // Load options into combo.
    CurrentBytes = MIN(CurrentBytes, MAX_VALUE);
    if (NOLIMIT != CurrentBytes)
        CurrentBytes = MAX(CurrentBytes, MIN_VALUE);

    SetBytes(CurrentBytes);             // Set "current bytes".
    //
    // Note: SetBytes() calls SetBestDisplay().
    //
}

//
// This constructor is sort of a hack.  Since the m_szNoLimit string
// is static, and since it is initialized in
// the constructor, at least one instance of XBytes must be created.
// There are cases where the static function FormatByteCountForDisplay
// may be useful when there is no need for an XBytes object.  The
// DiskQuota watchdog is just such an example.  If an XBytes object
// is not created, the two strings are not created and the function
// doesn't work correctly.  To fix this, I've defined a single global
// XBytes object constructed using this default constructor.  It's sole
// purpose is to load these static strings. [7/23/97 - brianau]
//
XBytes::XBytes(
    VOID
    ) : m_hDlg(NULL),
        m_idCtlEdit((DWORD)-1),
        m_idCtlCombo((DWORD)-1),
        m_ValueBytes(0)
{
    CommonInit();
}

//
// Initialization common to both constructors.
//
VOID
XBytes::CommonInit(
    VOID
    )
{
    if (NULL != m_hDlg)
        SendMessage(m_hDlg, m_idCtlEdit, EM_LIMITTEXT, MAX_EDIT_TEXT);

    LoadStaticStrings();
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::SetBytes

    Description: Stores a new byte value and updates the display to the
        proper units (order).

    Arguments:
        ValueBytes - Value in bytes.
            If the value is NOLIMIT, the controls are disabled.
            Otherwise the controls are enabled.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::SetBytes(INT64 ValueBytes)
{
    if (NOLIMIT != ValueBytes)
        ValueBytes = MAX(MIN_VALUE, ValueBytes);

    ValueBytes = MIN(MAX_VALUE, ValueBytes);
    Store(ValueBytes, e_Byte);
    SetBestDisplay();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Enable

    Description: Enables/Disables the edit and combo controls.

    Arguments:
        bEnable - TRUE = Enable, FALSE = Disable.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/28/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::Enable(
    BOOL bEnable
    )
{
    EnableWindow(GetDlgItem(m_hDlg, m_idCtlCombo), bEnable);
    EnableWindow(GetDlgItem(m_hDlg, m_idCtlEdit), bEnable);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::IsEnabled

    Description: Returns the "enabled" state of the edit control.  As long
        as the client doesn't enable/disable the edit/combo controls
        individually, this represents the state of the control pair.
        By using only the SetBytes() method to control enabling/disabling,
        this is ensured.

    Arguments:
        bEnable - TRUE = Enable, FALSE = Disable.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/28/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::IsEnabled(
    VOID
    )
{
    return IsWindowEnabled(GetDlgItem(m_hDlg, m_idCtlEdit));
}


bool
XBytes::UndoLastEdit(
    void
    )
{
    if (SendToEditCtl(EM_CANUNDO, 0, 0))
    {
        SendToEditCtl(EM_UNDO, 0, 0);
        SendToEditCtl(EM_EMPTYUNDOBUFFER, 0, 0);
        SendToEditCtl(EM_SETSEL, SendToEditCtl(EM_LINELENGTH, 0, 0), -1);
        return true;
    }
    return false;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::OnEditNotifyUpdate

    Description: Must be called whenever the parent window receives a
        EN_UPDATE notification for the edit control.  The function
        reads the current string in the edit control and tries to store it
        as a byte value.  If the store operation fails, the number is invalid
        and an alarm is sounded.

    Arguments:
        lParam - lParam argument to EN_UPDATE notification.  It is unused.

    Returns:
        Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/15/96    Added check for too-large input.                     BrianAu
    10/22/96    Re-organized and added ValueInRange() function.      BrianAu
                This was to support value check/adjustment when
                user changes the combo-box setting (bug).
    02/26/97    Added EM_CANUNDO and EM_EMPTYUNDOBUFFER.             BrianAu
    05/29/98    Removed ValueInRange() function and replaced with    BrianAu
                check for negative number.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::OnEditNotifyUpdate(
    LPARAM lParam
    )
{
    TCHAR szEditText[MAX_PATH];
    bool bBeep = false;

    DBGASSERT((MAX_EDIT_TEXT < MAX_PATH));

    GetDlgItemText(m_hDlg, m_idCtlEdit, szEditText, ARRAYSIZE(szEditText));
    if (lstrlen(szEditText) > MAX_EDIT_TEXT)
    {
        szEditText[MAX_EDIT_TEXT] = TEXT('\0');
        SetDlgItemText(m_hDlg, m_idCtlEdit, szEditText);
    }

    if (0 != lstrcmpi(XBytes::m_szNoLimit, szEditText))
    {
        //
        // If text in edit control is not "No Limit", convert the text to
        // a number, verify that it is in range and store it.
        //
        if (Store(szEditText, (INT)GetOrderFromCombo()))
        {
            //
            // If number is negative, force it to the minimum.
            //
            if (0 > Fetch(NULL, e_Byte))
            {
                SetBytes(MIN_VALUE);
                bBeep = true;
            }

            SendToEditCtl(EM_EMPTYUNDOBUFFER, 0, 0);
        }
        else
        {
            bBeep = true;
            if (!UndoLastEdit())
            {
                //
                // Number must be too large for the selected order.
                // Found that this can happen when first opening the disk quota UI
                // after someone's set the value out of the range acceptable by
                // the UI.  Remember, because we allow decimal values in the UI,
                // the UI cannot accept values quite as large as the dskquota APIs.
                // Beep the user and force the value to the largest acceptable
                // value.
                //
                SetBytes(MAX_VALUE);
            }
        }
        if (bBeep)
        {
            //
            // Sound beep for either an invalid value or an out-of-range value.
            //
            MessageBeep(MB_OK);
        }
    }

    return FALSE;
}


BOOL
XBytes::OnEditKillFocus(
    LPARAM lParam
    )
{
    TCHAR szEditText[MAX_EDIT_TEXT];
    bool bBeep = false;

    GetDlgItemText(m_hDlg, m_idCtlEdit, szEditText, ARRAYSIZE(szEditText));

    if (0 != lstrcmpi(XBytes::m_szNoLimit, szEditText))
    {
        INT64 value = Fetch(NULL, e_Byte);
        if (MIN_VALUE > value)
        {
            SetBytes(MIN_VALUE);
            bBeep = true;
        }
        else if (MAX_VALUE < value)
        {
            SetBytes(MAX_VALUE);
            bBeep = true;
        }
        if (bBeep)
        {
            MessageBeep(MB_OK);
        }
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::OnComboNotifySelChange

    Description: Must be called whenever the parent window receives a
        CBM_SELCHANGE message for the combo box control.  The function
        scales the stored byte value to the new units.

    Arguments:
        lParam - lParam argument to CBM_SELCHANGE message.  It is unused.

    Returns:
        Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/22/96    Modified to just call OnEditNotifyUpdate().          BrianAu
                Combo-box selection should have same value
                check/adjust behavior as edit control changes.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::OnComboNotifySelChange(
    LPARAM lParam
    )
{
    TCHAR szEditText[MAX_EDIT_TEXT];
    bool bBeep = false;

    GetDlgItemText(m_hDlg, m_idCtlEdit, szEditText, ARRAYSIZE(szEditText));

    if (0 != lstrcmpi(XBytes::m_szNoLimit, szEditText))
    {
        //
        // If text in edit control is not "No Limit", convert the text to
        // a number, verify that it is in range and store it.
        //
        if (Store(szEditText, (INT)GetOrderFromCombo()))
        {
            //
            // If number is less than the minimum, force it to the minimum.
            //
            if (MIN_VALUE > Fetch(NULL, e_Byte))
            {
                SetBytes(MIN_VALUE);
                bBeep = true;
            }
        }
        else
        {
            //
            // Number must be too large for the selected order.
            // Beep the user and force the value to the largest acceptable
            // value.
            //
            SetBytes(MAX_VALUE);
            bBeep = true;
        }
        if (bBeep)
        {
            MessageBeep(MB_OK);
        }
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::LoadComboItems

    Description: Initializes the combo box with its selections.
        [ "KB", "MB", "GB"... "PB" ].  The function only adds options that are
        reasonable for the size of the drive.  For example, if the drive
        is less than 1 GB in size, only KB and MB are displayed.

    Arguments:
        MaxBytes - Maximum bytes available on the drive (drive size).

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::LoadComboItems(
    INT64 MaxBytes
    )
{
    TCHAR szText[MAX_CMB_TEXT];
    INT idMsg = 0;
    INT order = e_Kilo;

    //
    // Find the string resource ID for the largest units possible.
    //
    // WARNING: This code assumes that the resource IDs for
    //          IDS_ORDERKB through IDS_ORDEREB are consecutive
    //          increasing integers.  Hence the following assertions.
    //
    DBGASSERT((IDS_ORDERMB == IDS_ORDERKB + 1));
    DBGASSERT((IDS_ORDERGB == IDS_ORDERKB + 2));
    DBGASSERT((IDS_ORDERTB == IDS_ORDERKB + 3));
    DBGASSERT((IDS_ORDERPB == IDS_ORDERKB + 4));
    DBGASSERT((IDS_ORDEREB == IDS_ORDERKB + 5));

    for (idMsg = IDS_ORDERKB; idMsg < IDS_ORDEREB; idMsg++)
    {
        if ((INT64)(1i64 << (10 * order++)) > MaxBytes)
        {
            idMsg--;
            break;
        }
    }

    //
    // idMsg is at largest units string we'll use.
    // Add strings to combo box.
    //
    while(idMsg >= IDS_ORDERKB)
    {
        if (LoadString(g_hInstDll, idMsg, szText, ARRAYSIZE(szText)))
            SendToCombo(CB_INSERTSTRING, 0, (LPARAM)szText);
        idMsg--;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::SetBestDisplay

    Description: Displays the byte value in the highest order that will
        produce a whole part of 3 digits or less.  That way you see
        "25.5" MB instead of "25500 KB".

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::SetBestDisplay(
    VOID
    )
{
    INT iOrder = e_Byte;
    TCHAR szValue[MAX_EDIT_TEXT];

    //
    // Display NOLIMIT as 0.  Edit and combo controls will be disabled
    // by property page code.  NOLIMIT is (-1).  Defined by NTFS.
    //
    if (NOLIMIT != m_ValueBytes)
    {
        //
        // Format the byte count for display.  Leave off the KB, MB... extension.
        // That part will be displayed in the combo box.
        //
        FormatByteCountForDisplay(m_ValueBytes, szValue, ARRAYSIZE(szValue), &iOrder);

        //
        // If value is 0, display MB units.  That's our default.
        //
        if (0 == m_ValueBytes)
            iOrder = e_Mega;

        //
        // Set the value string in the edit control and the order in the combo box.
        //
        SetOrderInCombo(iOrder);
        SetDlgItemText(m_hDlg,
                       m_idCtlEdit,
                       szValue);

        Enable(TRUE);
    }
    else
    {
        //
        // Set edit control to display "No Limit".
        //
        SetOrderInCombo(0);  // This will cause the combo to display nothing.
        SetDlgItemText(m_hDlg,
                       m_idCtlEdit,
                       m_szNoLimit);

        Enable(FALSE);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Store

    Description: Store a value in a given order as a byte count.

    Arguments:
        Value - Byte value in order xbOrder.

        xbOrder - Order of number in Value.
            One of set { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        TRUE    - Success.  Always returns TRUE.
                  Event though we're not returning anything useful, I want
                  the return type for both Store() methods to be the same.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::Store(
    INT64 Value,
    INT xbOrder
    )
{
    DBGASSERT((VALID_ORDER(xbOrder)));

    m_ValueBytes = INT64(Value) << (10 * (xbOrder - e_Byte));
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Store

    Description: Store a numeric string in a given order as a byte count.

    Arguments:
        pszSource - Numeric string.

        xbOrder - Order of number in pszSource.
            One of set { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        TRUE    - Success.
        FALSE   - Invalid number in string.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::Store(
    LPCTSTR pszSource,
    INT xbOrder
    )
{
    TCHAR szValue[MAX_EDIT_TEXT];    // Temp buffer.
    TCHAR szDecimalSep[MAX_DECIMAL_SEP];
    LPTSTR pszValue = szValue;       // Pointer into temp buffer.
    LPTSTR pszDec   = szValue;       // Pointer to decimal part of temp buffer.
    BOOL bResult    = FALSE;
    UINT uMult      = 1;             // Digit multiplier.
    INT64 WholePart = 0;
    INT64 FracPart  = 0;
    DWORD xbOrderX10 = xbOrder * 10; // Saves multiple computations.

    DBGASSERT((NULL != pszSource));
    DBGASSERT((VALID_ORDER(xbOrder)));

    GetLocaleInfo(LOCALE_USER_DEFAULT,
                  LOCALE_SDECIMAL,
                  szDecimalSep,
                  ARRAYSIZE(szDecimalSep));

    //
    // Local copy to party on.
    //
    lstrcpyn(szValue, pszSource, ARRAYSIZE(szValue));

    //
    // Find the start of the decimal separator.
    //
    while(NULL != *pszDec && szDecimalSep[0] != *pszDec)
        pszDec++;

    if (CH_NUL != *pszDec)
    {
        *pszDec = CH_NUL;      // Terminate the whole part.

        //
        // Skip over the decimal separator character(s).
        // Remember, separator is localized.
        //
        LPTSTR pszDecimalSep = &szDecimalSep[1];
        pszDec++;
        while(*pszDecimalSep && *pszDec && *pszDec == *pszDecimalSep)
        {
            pszDecimalSep++;
            pszDec++;
        }
    }
    else
        pszDec = NULL;          // No decimal pt found.

    //
    // Convert whole part to an integer.
    //
    if (!StrToInt(pszValue, &WholePart))
        goto not_a_number;

    //
    // Check to make sure the number entered will fit into a 64-bit int when
    // scaled up.
    // With the text entry field and order combo, users can specify numbers
    // that will overflow an __int64.  Can't let this happen.  Treat overflows
    // as invalid entry.  The (-1) accounts for the largest fractional part
    // that the user could enter.
    //
    if (WholePart > ((MAXLONGLONG >> xbOrderX10) - 1))
        goto not_a_number;

    //
    // Scale whole part according to order.
    //
    WholePart *= (1i64 << xbOrderX10);

    //
    // Convert fractional part to an integer.
    //
    if (NULL != pszDec)
    {
        //
        // Trim any trailing zero's first.
        //
        LPTSTR pszZero = pszDec + lstrlen(pszDec) - 1;
        while(pszZero >= pszDec && CH_ZERO == *pszZero)
            *pszZero-- = CH_NUL;

        //
        // Convert decimal portion of string to an integer.
        //
        if (!StrToInt(pszDec, &FracPart))
            goto not_a_number;

        //
        // Scale fractional part according to order.
        //
        FracPart *= (1i64 << xbOrderX10);

        DWORD dwDivisor = 1;
        while(pszZero-- >= pszDec)
            dwDivisor *= 10;

        //
        // Round up to the nearest muliple of the divisor to prevent
        // undesireable truncation during integer division we do below.
        //
        DWORD dwRemainder = (DWORD)(FracPart % dwDivisor);
        if (0 != dwRemainder)
            FracPart += dwDivisor - dwRemainder;

        FracPart /= dwDivisor;
    }

    m_ValueBytes = WholePart + FracPart;
    bResult = TRUE;

not_a_number:

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Fetch

    Description: Retrieve the byte count from the object using a specified
        order (magnitude).  i.e. For 60.5 MB, the order is e_Mega, the decimal
        part is 5 and the returned value is 60.

    Arguments:
        pDecimal [optional] - Address of DWORD to receive the fractional part
            of the byte count.  May be NULL.

        xbOrder - Order desired for the returned value.  Must be from the
            enumeration set { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        Returns the whole part of the byte count.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT64
XBytes::Fetch(
    INT64 *pDecimal,
    INT xbOrder
    )
{
    return BytesToParts(m_ValueBytes, pDecimal, xbOrder);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Fetch

    Description: Retrieve the byte count from the object and tell the caller
        what the best order is for display.  The logic used for "best order"
        is to use the first order that results in a 3-digit number.

    Arguments:
        pDecimal - Address of DWORD to receive the fractional part of the
            byte count.

        pxbOrder - Address of integer to receive the order of the number
            being returned.  The returned order is in the enumeration
            { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        Returns the whole part of the byte count.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
XBytes::Fetch(
    LPDWORD pDecimal,
    INT *pxbOrder
    )
{
    return BytesToParts(m_ValueBytes, pDecimal, pxbOrder);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::StrToInt

    Description: Converts a string to an integer.

    Arguments:
        pszValue - Address of string to convert.

        pIntValue - Address of INT64 variable to receive resulting number.

    Returns:
        TRUE    - Successful conversion.
        FALSE   - String was not a valid integer.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::StrToInt(
    LPCTSTR pszValue,
    INT64 *pIntValue
    )
{
    INT iMult   = 1;
    INT64 Value = 0;
    LPCTSTR pszDigit = pszValue + lstrlen(pszValue) - 1; // Start at right-most

    DBGASSERT((NULL != pszValue));
    DBGASSERT((NULL != pIntValue));

    *pIntValue = 0;
    while(pszDigit >= pszValue)
    {
        //
        // Moving left... check each digit.
        //
        if (IsCharNumeric(*pszDigit))
        {
            //
            // Valid digit.  Add it's value to sum.
            //
            Value += iMult * (*pszDigit - CH_ZERO);
            pszDigit--;
            iMult *= 10;
        }
        else
            return FALSE; // Invalid character.
    }
    *pIntValue = Value;
    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::BytesToParts

    Description: Converts a byte value to it's whole and fractional parts
        for a given magnitude (order).  This is a static member function
        that can be used outside of the context of an XBytes object.

    Arguments:
        ValueBytes - Value to convert expressed in bytes.

        pDecimal [optional] - Address of variable to receive the fractional
            part.  May be NULL.

        xbOrder - Order that the parts are to represent.
            { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns: Returns the whole part of the value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT64
XBytes::BytesToParts(
    INT64 ValueBytes,
    INT64 *pDecimal,
    INT xbOrder
    )
{
    INT64 Value = ValueBytes;
    UINT64 DecMask = 0;             // Start with a blank mask.
    DWORD dwOrderDeltaX10 = 10 * (xbOrder - e_Byte);

    DBGASSERT((VALID_ORDER(xbOrder)));

    //
    // Convert the value from order e_Byte to the order requested.
    // Also build a mask that can extract the decimal portion
    // from the original byte value.   The following 2 statements implement
    // this logic.
    //
    // for (INT i = e_Byte; i < xbOrder; i++)
    // {
    //     ValueBytes >>= 10;  // Divide byte value by 1024.
    //     DecMask <<= 10;     // Shift current mask bits 10 left.
    //     DecMask |= 0x3FF;   // OR in another 10 bits.
    // }
    //
    Value >>= dwOrderDeltaX10;
    DecMask = (1i64 << dwOrderDeltaX10) - 1;

    if (NULL != pDecimal)
    {
        //
        // Caller wants fractional part.
        // Extract fractional part from byte value and scale it to the
        // specified order.
        // Pseudocode:
        //      x   = value & mask
        //      pct = x / (2**order)    // ** = "raise to the power of".
        //      dec = 100 * pct
        //
        *pDecimal = (INT64)(100 * (ValueBytes & DecMask)) >> (10 * xbOrder);
    }

    return Value;
}


double
XBytes::ConvertFromBytes(
    INT64 ValueBytes,
    INT xbOrder
    )
{
    return (double)ValueBytes / (double)(10 * xbOrder);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::BytesToParts

    Description: Converts a byte value to it's whole and fractional parts.
        Determines the maximum magnitude (order) that will display the
        whole part in 3 digits or less.
        This is a static member function that can be used outside of the
        context of an XBytes object.

    Arguments:
        ValueBytes - Value to convert expressed in bytes.

        pDecimal [optional] - Address of variable to receive the fractional
            part.  May be NULL.

        pxbOrder - Address of variable to receive the determined order.
            { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns: Returns the whole part of the value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
XBytes::BytesToParts(
    INT64 ValueBytes,
    LPDWORD pDecimal,
    INT *pxbOrder
    )
{
    INT64 Value   = 0;
    INT64 Decimal = 0;
    INT xbOrder   = e_Byte;

    DBGASSERT((NULL != pDecimal));
    DBGASSERT((NULL != pxbOrder));

    //
    // Determine the best order for display.
    //
    while(xbOrder <= MAX_ORDER)
    {
        Value = BytesToParts(ValueBytes, &Decimal, xbOrder);
        if (Value < (INT64)1000)
            break;
        xbOrder++;
    }

    //
    // Return the results.
    //
    *pxbOrder = xbOrder;
    *pDecimal = (DWORD)Decimal;  // Fetch() guarantees this cast is OK.

    return (DWORD)Value;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatByteCountForDisplay

    Description: Given a byte count, this static method formats a character
        string with the 999.99XB number where "XB" is the maximum units
        that can display the whole part in 3 digits or less.

    Arguments:
        Bytes - Number of bytes to format.

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatByteCountForDisplay(
    INT64 Bytes,
    LPTSTR pszDest,
    UINT cchDest
    )
{
    DWORD dwWholePart = 0;
    DWORD dwFracPart  = 0;
    INT Order         = XBytes::e_Byte;

    //
    // To avoid using a local temp buffer, the caller's buffer must be
    // large enough for final string.  "999.99 MB" plus NUL and some pad to
    // allow for possible multi-char decimal separators (localized).
    //
    DBGASSERT((NULL != pszDest));

    FormatByteCountForDisplay(Bytes, pszDest, cchDest, &Order);

    DWORD dwLen = lstrlen(pszDest);
    //
    // Insert a space between the number and the suffix (i.e. "99 MB").
    // dwLen is incremented to allow for the added space.
    //
    *(pszDest + dwLen++) = TEXT(' ');
    //
    // Append the suffix.
    //
    LoadString(g_hInstDll, IDS_ORDERKB + Order - 1, pszDest + dwLen, cchDest - dwLen);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatByteCountForDisplay

    Description: Given a byte count, this static method formats a character
        string with the 999.99 number and returns the enumerted value
        representing the order in *pOrder.  This function complements
        the one above for those callers not needing the "KB", "MB"...
        suffix.  In particular, our combo box.

    Arguments:
        Bytes - Number of bytes to format.

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

        pOrder - Address of variable to receive the enumerated order value.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatByteCountForDisplay(
    INT64 Bytes,
    LPTSTR pszDest,
    UINT cchDest,
    INT *pOrder
    )
{
    DBGASSERT((NULL != pszDest));
    DBGASSERT((NULL != pOrder));

    DWORD dwWholePart = 0;
    DWORD dwFracPart  = 0;

    dwWholePart = BytesToParts(Bytes, &dwFracPart, pOrder);

    FormatForDisplay(pszDest, cchDest, dwWholePart, dwFracPart);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatByteCountForDisplay

    Description: Given a byte count, and a specified order, this static method
        formats a character string with the 999.99 number in the specified
        order.

    Arguments:
        Bytes - Number of bytes to format.

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

        Order - Order of the value in the resultant string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatByteCountForDisplay(
    INT64 Bytes,
    LPTSTR pszDest,
    UINT cchDest,
    INT Order
    )
{
    LONGLONG llWholePart;
    LONGLONG llFracPart;

    DBGASSERT((NULL != pszDest));

    //
    // WARNING: This code assumes that the whole and fractional parts will
    //          each be less than 2^32.  I think a valid assumption for scaled
    //          quota information.
    //
    llWholePart = BytesToParts(Bytes, &llFracPart, Order);
    FormatForDisplay(pszDest, cchDest, (DWORD)llWholePart, (DWORD)llFracPart);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatForDisplay

    Description: Given a whole part and a fractional part, format a decimal
        number suitable for display in 999.99 format.  If the fractional
        part is 0, no decimal part is included.

    Arguments:
        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

        dwWholePart - Whole part of the number.

        dwFracPart - Fractional part of the number.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatForDisplay(
    LPTSTR pszDest,
    UINT cchDest,
    DWORD dwWholePart,
    DWORD dwFracPart
    )
{
    DBGASSERT((NULL != pszDest));

    TCHAR szTemp[80];

    if (0 != dwFracPart)
    {
        TCHAR szFmt[] = TEXT("%d%s%02d");
        TCHAR szDecimalSep[MAX_DECIMAL_SEP];

        if ((dwFracPart >= 10) && (0 == (dwFracPart % 10)))
        {
            //
            // Whack off the trailing zero for display.
            //
            dwFracPart /= 10;
            szFmt[6] = TEXT('1');
        }

        GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_SDECIMAL,
                      szDecimalSep,
                      ARRAYSIZE(szDecimalSep));

        wsprintf(szTemp, szFmt, dwWholePart, szDecimalSep, dwFracPart);
    }
    else
        wsprintf(szTemp, TEXT("%d"), dwWholePart);

    lstrcpyn(pszDest, szTemp, cchDest);
}

//
// Load the static strings if they haven't been loaded.
//
VOID
XBytes::LoadStaticStrings(
    void
    )
{
    //
    // Initialize the "No Limit" text string for display in the
    // edit control.  This is the same string used in the details list
    // view columns.
    //
    if (TEXT('\0') == m_szNoLimit[0])
    {
        INT cchLoaded = LoadString(g_hInstDll,
                                   IDS_NO_LIMIT,
                                   m_szNoLimit,
                                   ARRAYSIZE(m_szNoLimit));

        DBGASSERT((0 < cchLoaded));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\xbytes.h ===
#ifndef _INC_DSKQUOTA_XBYTES_H
#define _INC_DSKQUOTA_XBYTES_H
///////////////////////////////////////////////////////////////////////////////
/*  File: xbytes.h

    Description: This module implements a class that coordinates the operation
        between the edit control and combo box used for entering byte values.
        The name "XBytes" is used because the control can represent
        KBytes, MBytes, GBytes etc.

        The cooperation between edit control and combo control is required
        so that the user can enter a byte value in the edit control then
        indicate it's order (KB, MB, GB...) using a selection from the combo box.

        A simple external interface is provided to initially set the
        object's byte value then retrieve the byte value when needed.  The
        object's client is also required to call two member functions when
        the parent dialog receives an EN_UPDATE notification and a CBN_SELCHANGE
        message.  The XBytes object handles all of the value scaling
        internally.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/15/96    Added m_MaxBytes member.                             BrianAu
    10/22/96    Added ValueInRange() member.                         BrianAu
    05/29/98    Removed ValueInRange() and m_MaxBytes members.       BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

const INT MAX_DECIMAL_SEP = 10;
const INT MAX_NOLIMIT_LEN = 80; // This should be plenty for localization.

#define MAX_ORDER         e_Exa
#define VALID_ORDER(ord)  ((ord) >= e_Byte && (ord) <= MAX_ORDER)


class XBytes
{
    private:
        INT64 m_ValueBytes;     // Byte value.
        HWND  m_hDlg;           // Parent dlg.
        DWORD m_idCtlEdit;      // Edit control.
        DWORD m_idCtlCombo;     // Combo control.
        static TCHAR m_szNoLimit[MAX_NOLIMIT_LEN];

        VOID CommonInit(VOID);

        INLINE BOOL IsCharNumeric(TCHAR ch)
            { return IsCharAlphaNumeric(ch) && !IsCharAlpha(ch); }
        BOOL StrToInt(LPCTSTR pszValue, INT64 *pIntValue);

        INLINE INT_PTR SendToEditCtl(UINT message, WPARAM wParam, LPARAM lParam)
            { return SendMessage(GetDlgItem(m_hDlg, m_idCtlEdit), message, wParam, lParam); }
        INLINE INT_PTR SendToCombo(UINT message, WPARAM wParam, LPARAM lParam)
            { return SendMessage(GetDlgItem(m_hDlg, m_idCtlCombo), message, wParam, lParam); }

        INLINE INT_PTR GetOrderFromCombo(VOID)
            { return SendToCombo(CB_GETCURSEL, 0, 0) + 1; }
        INLINE INT_PTR SetOrderInCombo(INT iOrder)
            { return SendToCombo(CB_SETCURSEL, iOrder-1, 0); }

        VOID LoadComboItems(INT64 MaxBytes);
        VOID SetBestDisplay(VOID);

        BOOL Store(INT64 Value, INT xbOrder);
        BOOL Store(LPCTSTR pszValue, INT xbOrder);

        INT64 Fetch(INT64 *pDecimal, INT xbOrder);    // Fetch in requested order.
        DWORD Fetch(DWORD *pDecimal, INT *pxbOrder);  // Fetch in "best" order.

        bool UndoLastEdit(void);

        static VOID LoadStaticStrings(void);
        static VOID FormatForDisplay(LPTSTR pszDest,
                                     UINT cchDest,
                                     DWORD dwWholePart,
                                     DWORD dwFracPart);
        VOID Enable(BOOL bEnable);

    public:

        //
        // With the exception of e_Byte, these must match the order
        // of the IDS_ORDERKB, IDS_ORDERMB... string resource IDs.
        // There is no IDS_ORDERBYTE string resource.
        //
        enum {e_Byte, e_Kilo, e_Mega, e_Giga, e_Tera, e_Peta, e_Exa};

        XBytes(VOID);

        XBytes(HWND hDlg, DWORD idCtlEdit, DWORD idCtlCombo, INT64 CurrentBytes);

        static double ConvertFromBytes(INT64 ValueBytes, INT xbOrder);
        static INT64 BytesToParts(INT64 ValueBytes, INT64 *pDecimal, INT xbOrder);
        static DWORD BytesToParts(INT64 ValueBytes, LPDWORD pDecimal, INT *pxbOrder);
        static VOID FormatByteCountForDisplay(INT64 Bytes, LPTSTR pszDest, UINT cchDest);
        static VOID FormatByteCountForDisplay(INT64 Bytes, LPTSTR pszDest, UINT cchDest, INT *pOrder);
        static VOID FormatByteCountForDisplay(INT64 Bytes, LPTSTR pszDest, UINT cchDest, INT Order);

        INT64 GetBytes(VOID)
            { return Fetch(NULL, e_Byte); }

        VOID SetBytes(INT64 Value);

        //
        // EN_xxxx handlers.  Client must call this on EN_UPDATE.
        //
        BOOL OnEditNotifyUpdate(LPARAM lParam);
        BOOL OnEditKillFocus(LPARAM lParam);

        //
        // CBN_xxxx handlers. Client must call this on CBN_SELCHANGE.
        //
        BOOL OnComboNotifySelChange(LPARAM lParam);

        BOOL IsEnabled(VOID);
};


#endif // _INC_DSKQUOTA_XBYTES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\strclass.h ===
#ifndef _INC_DSKQUOTA_STRCLASS_H
#define _INC_DSKQUOTA_STRCLASS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: strclass.h

    Description: Typical class to handle strings.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef _INC_STDIO
#   include <stdio.h>
#endif

#ifndef _INC_STDARG
#   include <stdarg.h>    // For va_list stuff.
#endif

#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif

#undef StrCpyA

//
// class String implements a reference-counted string class with all 
// the typical string class operations.
//
class CString
{
    public:
        CString(VOID);
        explicit CString(INT cch);
        explicit CString(LPCSTR pszA);
        explicit CString(LPCWSTR pszW);
        CString(const CString& rhs);
        CString(HINSTANCE hInst, INT idMsg, ...);
        virtual ~CString(VOID);

        //
        // Basic operations.
        // - Assignment.
        // - Concatenation.
        // - Comparison.
        // - Array subscript.
        //
        CString& operator =  (const CString& rhs);
        CString& operator =  (LPCSTR rhsA);
        CString& operator =  (LPCWSTR rhsW);
        CString  operator +  (const CString& rhs) const;
        CString  operator +  (LPCSTR rhsA) const;
        CString  operator +  (LPCWSTR rhsW) const;
        friend CString operator + (LPCSTR pszA, const CString& s);
        friend CString operator + (LPCWSTR pszW, const CString& s);
        CString& operator += (const CString& rhs);
        BOOL     operator == (const CString& rhs) const;
        BOOL     operator != (const CString& rhs) const;
        BOOL     operator <  (const CString& rhs) const;
        BOOL     operator <= (const CString& rhs) const;
        BOOL     operator >  (const CString& rhs) const;
        BOOL     operator >= (const CString& rhs) const;
        TCHAR    operator[]  (INT index) const;
        TCHAR&   operator[]  (INT index);

        //
        // Type conversion.  Give read access to nul terminated c-string.
        //
        operator LPCTSTR(VOID) const
            { return m_pValue->m_psz; }

        operator LPCTSTR(VOID)
            { return m_pValue->m_psz; }

        operator LPTSTR(VOID)
            { CopyOnWrite(); return m_pValue->m_psz; }

        //
        // Same thing as (LPCTSTR) conversion but in function form.
        //
        LPCTSTR Cstr(void) const
            { return m_pValue->m_psz; }

        //
        // Return a pointer to a specifically-sized buffer.
        //
        LPTSTR GetBuffer(INT cchMax = -1);
        void ReleaseBuffer(void);

        //
        // Trim trailing or leading whitespace.
        //
        void Rtrim(void);
        void Ltrim(void);
        void Trim(void)
            { Ltrim(); Rtrim(); }

        //
        // Character location.
        //
        INT First(TCHAR ch) const;
        INT Last(TCHAR ch) const;

        //
        // Extract a substring.
        //
        CString SubString(INT iFirst, INT cch = -1);

        //
        // Convert characters to upper/lower case.
        //
        VOID ToUpper(INT iFirst = 0, INT cch = -1);
        VOID ToLower(INT iFirst = 0, INT cch = -1);

        //
        // Load string from resource or message table.
        // Supports FormatMessage-style variable arg formatting.
        //
        BOOL Format(HINSTANCE hInst, UINT idFmt, ...);
        BOOL Format(LPCTSTR pszFmt, ...);
        BOOL Format(HINSTANCE hInst, UINT idFmt, va_list *pargs);
        BOOL Format(LPCTSTR pszFmt, va_list *pargs);

        //
        // Minimum size display rect.
        //
        bool GetDisplayRect(HDC hdc, LPRECT prc) const;

        //
        // Expand any embedded environment strings.
        //
        VOID ExpandEnvironmentStrings(VOID);

        //
        // Compare with a normal 'C' string.
        //
        INT Compare(LPCWSTR rhsW) const;
        INT Compare(LPCSTR rhsA) const;
        INT CompareNoCase(LPCWSTR rhsW) const;
        INT CompareNoCase(LPCSTR rhsA) const;
    
        //
        // Clear a string's contents.  Leaves in new-object state.
        //
        VOID Empty(VOID);
        //
        // Does the object have no content?
        //
        BOOL IsEmpty(VOID) const;
        //
        // Length of string, excluding nul terminator.
        //
        INT Length(VOID) const;
        INT LengthBytes(VOID) const
            { return Length() * sizeof(TCHAR); }

        VOID Size(INT cch);
        INT Size(VOID) const
            { return m_pValue->m_cchAlloc; }
        INT SizeBytes(VOID) const
            { return m_pValue->m_cchAlloc * sizeof(TCHAR); }

        VOID DebugOut(BOOL bNewline = TRUE) const;

        //
        // Replacements for standard string functions.
        // The Ansi versions are DBCS-aware.
        //
        static LPSTR StrCpyA(LPSTR pszDest, LPCSTR pszSrc);
        static LPWSTR StrCpyW(LPWSTR pszDest, LPCWSTR pszSrc);
        static INT StrLenA(LPCSTR psz);
        static INT StrLenW(LPCWSTR psz);
        static LPSTR StrCpyNA(LPSTR pszDest, LPCSTR pszSrc, INT cch);
        static LPWSTR StrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT cch);

    private:
        //
        // class StringValue contains actual string data and a reference count.
        // Class CString has a pointer to one of these.  If a CString
        // object is initialized with or assigned another CString, their StringValue
        // pointers reference the same StringValue object.  The StringValue
        // object maintains a reference count to keep track of how many
        // CString objects reference it.  The CString object implements 
        // copy-on-write so that when it is modified, a private copy of the
        // StringValue is created so other CString objects are left unmodified.
        //
        struct StringValue
        {
            LPTSTR m_psz;      // Ptr to nul-term character string.
            INT    m_cchAlloc; // Number of characters allocated in buffer.
            LONG   m_cRef;     // Number of CString objects referencing this value.
            mutable INT m_cch; // Number of characters in buffer (excl nul term).
        
            StringValue(VOID);
            StringValue(INT cch);
            StringValue(LPCSTR pszA);
            StringValue(LPCWSTR pszW);
            ~StringValue(VOID);

            INT Length(VOID) const;

            static LPSTR WideToAnsi(LPCWSTR pszW, INT *pcch = NULL);
            static LPWSTR AnsiToWide(LPCSTR pszA, INT *pcch = NULL);
            static LPWSTR Dup(LPCWSTR pszW, INT len = 0);
            static LPSTR Dup(LPCSTR pszA, INT len = 0);
            static LPTSTR Concat(StringValue *psv1, StringValue *psv2);

        };

        StringValue *m_pValue; // Pointer to string representation.

        BOOL ValidIndex(INT index) const;
        VOID CopyOnWrite(VOID);
        inline bool IsWhiteSpace(TCHAR ch) const;
};


inline bool
CString::IsWhiteSpace(
    TCHAR ch
    ) const
{
    return (TEXT(' ')  == ch ||
            TEXT('\t') == ch ||
            TEXT('\n') == ch);
}


inline BOOL
CString::ValidIndex(
    INT index
    ) const
{
    return (0 <= index && index < Length());
}


inline BOOL
CString::operator != (
    const CString& rhs
    ) const
{ 
    return !(this->operator == (rhs)); 
}


inline BOOL
CString::operator <= (
    const CString& rhs
    ) const
{
    return (*this < rhs || *this == rhs);
}

inline BOOL
CString::operator > (
    const CString& rhs
    ) const
{
    return !(*this <= rhs);
}

inline BOOL
CString::operator >= (
    const CString& rhs
    ) const
{
    return !(*this < rhs);
}

inline LPWSTR
CString::StrCpyW(
    LPWSTR pszDest, 
    LPCWSTR pszSrc
    )
{
    return lstrcpyW(pszDest, pszSrc);
}


inline LPSTR
CString::StrCpyA(
    LPSTR pszDest, 
    LPCSTR pszSrc
    )
{
    return lstrcpyA(pszDest, pszSrc);
}

inline INT 
CString::StrLenW(
    LPCWSTR psz
    )
{
    return lstrlenW(psz);
}


inline INT 
CString::StrLenA(
    LPCSTR psz
    )
{
    return lstrlenA(psz);
}


inline LPWSTR
CString::StrCpyNW(
    LPWSTR pszDest, 
    LPCWSTR pszSrc, 
    INT cch
    )
{
    return lstrcpynW(pszDest, pszSrc, cch);
}

inline LPSTR
CString::StrCpyNA(
    LPSTR pszDest, 
    LPCSTR pszSrc, 
    INT cch
    )
{
    return lstrcpynA(pszDest, pszSrc, cch);
}

CString
operator + (const LPCWSTR pszW, const CString& s);
                                                
CString
operator + (const LPCSTR pszA, const CString& s);

#endif // _INC_DSKQUOTA_STRCLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\common\utils.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: utils.cpp

    Description: Contains any general utility functions applicable to the
        dskquota project.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "resource.h"
#include "dskquota.h"
#include <advpub.h>         // For REGINSTALL


//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidToString

    Description: Format a SID as a character string suitable for character
        output.  This code was taken from MSDN KB article Q131320.

    Arguments:
        pSid - Address of SID to format.

        pszSid - Address of output buffer for formatted SID.

    Returns:
        TRUE    - Success.
        FALSE   - Destination buffer too small, invalid SID or pSid == NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/07/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL SidToString(
    PSID pSid,
    LPTSTR pszSid,
    LPDWORD pcchBuffer
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD cchSid;

    //
    // test if Sid passed in is valid
    //
    if(NULL == pSid || !IsValidSid(pSid))
        return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSid = (15 + 12 + (12 * dwSubAuthorities) + 1);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if (*pcchBuffer < cchSid)
    {
        *pcchBuffer = cchSid;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSid = wsprintf(pszSid, TEXT("S-%lu-"), dwSidRev );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        cchSid += wsprintf(pszSid + lstrlen(pszSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        cchSid += wsprintf(pszSid + lstrlen(pszSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        cchSid += wsprintf(pszSid + cchSid, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidToString

    Description: Format a SID as a character string suitable for character
        output.  Allocates the destination buffer so that the caller must free
        it when done with it.

    Arguments:
        pSid - Address of SID to format.

        ppszSid - Address of LPTSTR variable to receive address of formatted
            SID string.  If the function returns TRUE, the caller must free
            this memory when done with it.

    Returns:
        TRUE    - Success.
        FALSE   - Destination buffer too small, invalid SID or pSid == NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/07/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL SidToString(
    PSID pSid,
    LPTSTR *ppszSid
    )
{
    DWORD cchSid = 0;

    //
    // Call once to get required buffer size.
    //
    SidToString(pSid, *ppszSid, &cchSid);

    *ppszSid = new TCHAR[cchSid];
    return SidToString(pSid, *ppszSid, &cchSid);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: CreateSidList

    Description: Creates a structure required for the SID list argument to
        NtQueryQuotaInformationFile.  The caller passes the address of an
        array of SID pointers.  The function allocates an sufficient array
        and creates the following formatted structure:

        +--------+--------+--------+--------+--------+--------+-+
        | SID[0] | SID[1] | SID[2] |        |        |SID[n-1]|0|
        +--------+--------+--------+--------+--------+--------+-+
                 |        |
                 |        |
                /          \
              /              -------------------------------
            /                                                \
          /                                                    \
        +------------+------------+-----------------------------+
        | Next entry | SID length |          SID                |
        |   offset   |  (DWORD)   |   (variable length)         |
        |   (DWORD)  |            |                             |
        +------------+------------+-----------------------------+


    Arguments:
        rgpSids - Array of SID pointers.

        cpSids - Number of pointers in rgpSids.  If 0, the array must
            contain a terminating NULL pointer.

        ppSidList - Address of a PSIDLIST pointer variable to receive
            the address of the final structure.  The caller is reponsible
            for deleting the returned buffer using "delete".

        pcbSidList - Address of DWORD varible to receive the byte count
            for the returned SidList structure.  If the function returns
            hresult ERROR_INVALID_SID, the index in the source array of the invalid
            SID will be returned at this location.

    Returns:
        NO_ERROR            - Success.
        ERROR_INVALID_SID (hr)  - An invalid SID was found in rgpSids.  The
            index of the invalid SID is returned in *pcbSidList.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/13/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CreateSidList(
    PSID *rgpSids,
    DWORD cpSids,
    PSIDLIST *ppSidList,
    LPDWORD pcbSidList
    )
{
    HRESULT hResult = NO_ERROR;
    DBGASSERT((NULL != rgpSids));
    DBGASSERT((NULL != ppSidList));
    DBGASSERT((NULL != pcbSidList));

    DWORD cbBuffer = 0;
    PBYTE pbBuffer = NULL;

    //
    // Initialize return values.
    //
    *ppSidList  = NULL;
    *pcbSidList = 0;

    //
    // If caller passed 0 for cpSids, list is NULL-terminated.
    // Set cpSids to a large value so it is not a factor in controlling the
    // byte-counter loop.
    //
    if (0 == cpSids)
        cpSids = (DWORD)~0;

    //
    // Count how many bytes we'll need to create the SID list.
    // Note that a NULL SID pointer at any array location
    // will truncate all following SIDs from the final list.  Just like strncpy
    // with character strings.
    //
    for (UINT i = 0; NULL != rgpSids[i] && i < cpSids; i++)
    {
        if (IsValidSid(rgpSids[i]))
        {
            cbBuffer += (sizeof(DWORD) + sizeof(DWORD) + GetLengthSid(rgpSids[i]));
        }
        else
        {
            //
            // Tell caller they passed a ptr to an invalid SID and also tell them
            // which one it was.
            //
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
            *pcbSidList = i;
            break;
        }
    }
    //
    // Reset cpSids to the actual number of SIDs processed.
    //
    cpSids = i;

    if (SUCCEEDED(hResult))
    {
        //
        // Got a good byte count and all SIDs are valid.
        //
        DBGASSERT((0 < cpSids));

        pbBuffer = new BYTE [cbBuffer];  // Can throw OutOfMemory.

        PFILE_GET_QUOTA_INFORMATION pfgqi = NULL;
        DWORD cbRecord = 0;
        DWORD cbSid    = 0;

        //
        // Return buffer address and length to caller.
        //
        *ppSidList  = (PSIDLIST)pbBuffer;
        *pcbSidList = cbBuffer;

        for (UINT i = 0; i < cpSids; i++)
        {
            pfgqi = (PFILE_GET_QUOTA_INFORMATION)pbBuffer;

            DBGASSERT((0 == ((DWORD_PTR)pfgqi & 3)));  // record is DWORD aligned?

            //
            // Calculate offsets and sizes for this entry.
            //
            cbSid    = GetLengthSid(rgpSids[i]);
            cbRecord = sizeof(pfgqi->NextEntryOffset) +
                       sizeof(pfgqi->SidLength) +
                       cbSid;
            //
            // Write the entry information.
            // On last entry, NextEntryOffset is 0.
            //
            if (i < (cpSids - 1))
                pfgqi->NextEntryOffset = cbBuffer + cbRecord;
            else
                pfgqi->NextEntryOffset = 0;

            pfgqi->SidLength       = cbSid;
            CopyMemory(&(pfgqi->Sid), rgpSids[i], cbSid);

            pbBuffer += cbRecord;   // Advance write buffer pointer.
        }
    }

    return hResult;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: MessageBoxNYI

    Description: Simple message box for unimplemented features.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID MessageBoxNYI(VOID)
{
    MessageBox(NULL,
               TEXT("This feature has not been implemented."),
               TEXT("Under Construction"),
               MB_ICONWARNING | MB_OK);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaMsgBox

    Description: Several overloaded functions for displaying messages.
        The variations allow the caller to provide either string resource
        IDs or text strings as arguments.

    Arguments:

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT DiskQuotaMsgBox(
    HWND hWndParent,
    UINT idMsgText,
    UINT idMsgTitle,
    UINT uType
    )
{
    INT iReturn     = 0;

    CString strTitle(g_hInstDll, idMsgTitle);
    CString strText(g_hInstDll, idMsgText);

    iReturn = MessageBox(hWndParent, strText, strTitle, MB_SETFOREGROUND | uType);

    return iReturn;
}


INT DiskQuotaMsgBox(
    HWND hWndParent,
    LPCTSTR pszText,
    LPCTSTR pszTitle,
    UINT uType
    )
{
    return MessageBox(hWndParent, pszText, pszTitle, MB_SETFOREGROUND | uType);
}


INT DiskQuotaMsgBox(
    HWND hWndParent,
    UINT idMsgText,
    LPCTSTR pszTitle,
    UINT uType
    )
{
    INT iReturn    = 0;

    CString strText(g_hInstDll, idMsgText);

    iReturn = MessageBox(hWndParent, strText, pszTitle, MB_SETFOREGROUND | uType);

    return iReturn;
}



INT DiskQuotaMsgBox(
    HWND hWndParent,
    LPCTSTR pszText,
    UINT idMsgTitle,
    UINT uType
    )
{
    LPTSTR pszTitle = NULL;
    INT iReturn     = 0;

    CString strTitle(g_hInstDll, idMsgTitle);

    iReturn = MessageBox(hWndParent, pszText, strTitle, MB_SETFOREGROUND | uType);

    return iReturn;
}

//
// Center a popup window in it's parent.
// If hwndParent is NULL, the window's parent is used.
// If hwndParent is not NULL, hwnd is centered in it.
// If hwndParent is NULL and hwnd doesn't have a parent, it is centered
// on the desktop.
//
VOID
CenterPopupWindow(
    HWND hwnd,
    HWND hwndParent
    )
{
    RECT rcScreen;

    if (NULL != hwnd)
    {
        rcScreen.left   = rcScreen.top = 0;
        rcScreen.right  = GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = GetSystemMetrics(SM_CYSCREEN);

        if (NULL == hwndParent)
        {
            hwndParent = GetParent(hwnd);
            if (NULL == hwndParent)
                hwndParent = GetDesktopWindow();
        }

        RECT rcWnd;
        RECT rcParent;

        GetWindowRect(hwnd, &rcWnd);
        GetWindowRect(hwndParent, &rcParent);

        INT cxWnd    = rcWnd.right  - rcWnd.left;
        INT cyWnd    = rcWnd.bottom - rcWnd.top;
        INT cxParent = rcParent.right  - rcParent.left;
        INT cyParent = rcParent.bottom - rcParent.top;
        POINT ptParentCtr;

        ptParentCtr.x = rcParent.left + (cxParent / 2);
        ptParentCtr.y = rcParent.top  + (cyParent / 2);

        if ((ptParentCtr.x + (cxWnd / 2)) > rcScreen.right)
        {
            //
            // Window would run off the right edge of the screen.
            //
            rcWnd.left = rcScreen.right - cxWnd;
        }
        else if ((ptParentCtr.x - (cxWnd / 2)) < rcScreen.left)
        {
            //
            // Window would run off the left edge of the screen.
            //
            rcWnd.left = rcScreen.left;
        }
        else
        {
            rcWnd.left = ptParentCtr.x - (cxWnd / 2);
        }

        if ((ptParentCtr.y + (cyWnd / 2)) > rcScreen.bottom)
        {
            //
            // Window would run off the bottom edge of the screen.
            //
            rcWnd.top = rcScreen.bottom - cyWnd;
        }
        else if ((ptParentCtr.y - (cyWnd / 2)) < rcScreen.top)
        {
            //
            // Window would run off the top edge of the screen.
            //
            rcWnd.top = rcScreen.top;
        }
        else
        {
            rcWnd.top = ptParentCtr.y - (cyWnd / 2);
        }

        MoveWindow(hwnd, rcWnd.left, rcWnd.top, cxWnd, cyWnd, TRUE);
    }
}


//
// Duplicate a string.
//
LPTSTR StringDup(
    LPCTSTR pszSource
    )
{
    LPTSTR pszNew = new TCHAR[lstrlen(pszSource) + 1];
    lstrcpy(pszNew, pszSource);

    return pszNew;
}


//
// Duplicate a SID.
//
PSID SidDup(
    PSID pSid
    )
{
    DBGASSERT((IsValidSid(pSid)));
    DWORD cbSid = GetLengthSid(pSid);

    PSID pCopy = new BYTE [cbSid];

    CopySid(cbSid, pCopy, pSid);
    return pCopy;
}


//
// Similar to Win32's GetDlgItemText except that this one
// doesn't require you to anticipate the required size of the buffer.
//
void
GetDialogItemText(
    HWND hwnd,
    UINT idCtl,
    CString *pstrText
    )
{
    DBGASSERT((NULL != pstrText));
    HWND hwndCtl = GetDlgItem(hwnd, idCtl);
    if (NULL != hwndCtl)
    {
        int cch = (int)SendMessage(hwndCtl, WM_GETTEXTLENGTH, 0, 0) + 1;
        SendMessage(hwndCtl, WM_GETTEXT, (WPARAM)cch, (LPARAM)pstrText->GetBuffer(cch));
        pstrText->ReleaseBuffer();
    }
}


BOOL
UserIsAdministrator(
    PDISKQUOTA_USER pUser
    )
{
    DBGASSERT((NULL != pUser));

    BYTE Sid[MAX_SID_LEN];
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pAdminSid               = NULL;
    BOOL bResult                 = FALSE;

    if (AllocateAndInitializeSid(&sia,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &pAdminSid))
    {
        if (SUCCEEDED(pUser->GetSid(Sid, sizeof(Sid))))
        {
            bResult = EqualSid(Sid, pAdminSid);
        }
        FreeSid(pAdminSid);
    }

    return bResult;
}


//
// Call ADVPACK for the given section of our resource based INF.
//
// hInstance  - Resource instance containing REGINST section.
// pszSection - Name of section to invoke.
//
HRESULT
CallRegInstall(
    HINSTANCE hInstance,
    LPSTR pszSection
    )
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

#ifdef UNICODE
        if ( pfnri )
        {
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(hInstance, pszSection, &stReg);
        }
#else
        if (pfnri)
        {
            hr = pfnri(hInstance, pszSection, NULL);
        }

#endif
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\connect.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: connect.cpp

    Description: Contains class definitions for classes associated with
        OLE connection points.  These are:

            ConnectionPoint         ( IConnectionPoint )
            ConnectionPointEnum     ( IEnumConnectionPoints )
            ConnectionEnum          ( IEnumConnections )


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include "connect.h"
#include "guidsp.h"

//
// Constants for connection point-related objects.
//
const UINT CONNECTION_FIRST_COOKIE = 100; // 1st cookie value given out.

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::ConnectionPoint

    Description: Constructor,

    Arguments:
        pUnkContainer - Pointer to containing DiskQuotaController object.

        riid - Reference to IID that this connection point object supports.

    Returns: Nothing.

    Exceptions: CAllocException, CSyncException

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ConnectionPoint::ConnectionPoint(
    LPUNKNOWN pUnkContainer,
    REFIID riid
    ) : m_cRef(0),
        m_cConnections(0),
        m_dwCookieNext(CONNECTION_FIRST_COOKIE),
        m_pUnkContainer(pUnkContainer),
        m_riid(riid),
        m_hMutex(NULL)
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPoint::ConnectionPoint")));
    DBGASSERT((NULL != pUnkContainer));

    if (NULL == (m_hMutex = CreateMutex(NULL, FALSE, NULL)))
        throw CSyncException(CSyncException::mutex, CSyncException::create);

    m_Dispatch.Initialize(static_cast<IDispatch *>(this),
                          LIBID_DiskQuotaTypeLibrary,
                          IID_DIDiskQuotaControlEvents,
                          L"DSKQUOTA.DLL");
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::~ConnectionPoint

    Description: Destructor.  

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ConnectionPoint::~ConnectionPoint(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPoint::~ConnectionPoint")));

    Lock();
    UINT cConnections = m_ConnectionList.Count();
    for (UINT i = 0; i < cConnections; i++)
    {
        if (NULL != m_ConnectionList[i].pUnk)
        {
            m_ConnectionList[i].pUnk->Release();
        }
    }
    ReleaseLock();
        
    if (NULL != m_hMutex)
        CloseHandle(m_hMutex);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IConnectionPoint interface.  Only IID_IUnknown and 
        IID_IConnectionPoint are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR        - Success.
        E_NOINTERFACE  - Requested interface not supported.
        E_INVALIDARG   - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionPoint::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPoint::QueryInterface")));
    DBGPRINTIID(DM_CONNPT, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IConnectionPoint == riid)
    {
        *ppvOut = static_cast<IConnectionPoint *>(this);
    }
    else if (IID_IDispatch == riid)
    {
        *ppvOut = static_cast<IDispatch *>(this);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
ConnectionPoint::AddRef(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPoint::AddRef")));
    DBGPRINT((DM_CONNPT, DL_LOW, TEXT("\t0x%08X  %d -> %d\n"),
             this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);

    //
    // NOTE:  We maintain a pointer to the quota controller (m_pUnkContainer) but
    //        we DO NOT AddRef it.  The controller calls AddRef for connection
    //        point objects so this would create a circular reference.
    //

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
ConnectionPoint::Release(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPoint::Release")));
    DBGPRINT((DM_COM, DL_HIGH, TEXT("\t0x%08X  %d -> %d\n"),
             this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::GetConnectionInterface

    Description: Retrieves a connection point's interface ID.

    Arguments:
        pIID - Address of IID variable to receive the IID.

    Returns:
        NOERROR      - Success.
        E_INVALIDARG - pIID is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ConnectionPoint::GetConnectionInterface(
    LPIID pIID
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::GetConnectionInterface")));
    HRESULT hr = E_INVALIDARG;

    if (NULL != pIID)
    {
        *pIID = m_riid;
        hr = NOERROR;
    }

    return hr;
}

   
///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::GetConnectionPointContainer

    Description: Retrieves an interface pointer for the point's parent
        container.

    Arguments:
        ppCPC - Address of variable to receive container's interface pointer
            value.

    Returns:
        NOERROR     - Success.
        E_INVALIDARG - ppCPC argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ConnectionPoint::GetConnectionPointContainer(
    PCONNECTIONPOINTCONTAINER *ppCPC
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::GetConnectionPointContainer")));
    return m_pUnkContainer->QueryInterface(IID_IConnectionPointContainer, 
                                       (LPVOID *)ppCPC);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::Advise

    Description: Notifies the connection point of an outgoing interface.

    Arguments:
        pUnkSink - Pointer to outgoing interface provided by Sink.

        pdwCookie - Address of variable to receive the "cookie" returned
            for this connection.  The client uses this "cookie" value to
            refer to the connection.

    Returns:
        NOERROR                 - Success.
        E_INVALIDARG            - pUnkSink or pdwCookie were NULL.
        CONNECT_E_CANNOTCONNECT - Sink doesn't support our event interface.
        E_UNEXPECTED            - Exception caught while calling client code.
        E_OUTOFMEMORY           - Insufficient memory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/21/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ConnectionPoint::Advise(
    LPUNKNOWN pUnkSink,
    LPDWORD pdwCookie
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::Advise")));
    DBGPRINT((DM_CONNPT, DL_MID, TEXT("\tAdvising connpt 0x%08X of sink 0x%08X"), 
             this, pUnkSink));

    HRESULT hr = NOERROR;
    if (NULL == pUnkSink || NULL == pdwCookie)
        return E_INVALIDARG;

    LPUNKNOWN pSink = NULL;
    AutoLockMutex lock(m_hMutex);

    //
    // Does the sink support our conn pt interface?
    //
    try
    {
        //
        // QueryInterface() is client code.  Must handle exceptions.
        //
        hr = pUnkSink->QueryInterface(m_riid, (LPVOID *)&pSink);

        if (SUCCEEDED(hr))
        {
            CONNECTDATA cd;

            //
            // See if there is an unused entry in the list.
            // If not, we'll have to extend the list.
            //
            UINT index = m_cConnections;
            for (UINT i = 0; i < m_cConnections; i++)
            {
                if (NULL == m_ConnectionList[i].pUnk)
                {
                    index = i;
                    break;
                }
            }

            //
            // Fill in the connection info and add to connection list.
            //
            cd.pUnk    = pSink;
            *pdwCookie = cd.dwCookie = m_dwCookieNext++;

            if (index < m_cConnections)
                m_ConnectionList[index] = cd;
            else
                m_ConnectionList.Append(cd); // This can throw OutOfMemory.

            if (SUCCEEDED(hr))
            {
                m_cConnections++;  // Another connection.
                DBGPRINT((DM_CONNPT, DL_HIGH, 
                         TEXT("CONNPT - Connection complete.  Cookie = %d.  %d total connections."),
                         *pdwCookie, m_cConnections));
            }
            else
            {
                DBGERROR((TEXT("ConnPt connection failed with error 0x%08X."), hr));
            }
        }
        else
            hr = CONNECT_E_CANNOTCONNECT;  // Interface not supported.
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    
    if (FAILED(hr) && NULL != pSink)
    {
        //
        // Something failed after QueryInterface.  Release sink pointer.
        //
        pSink->Release();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::Unadvise

    Description: Disconntinues an outgoing communication channel with the 
        connection point object.

    Arguments:
        dwCookie - The "channel" identifier returned from Advise().

    Returns:
        NOERROR                 - Success.
        CONNECT_E_NOCONNECTION  - No connection found for this cookie.
        E_UNEXPECTED            - Exception caught while calling client code.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ConnectionPoint::Unadvise(
    DWORD dwCookie
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::Unadvise")));
    DBGPRINT((DM_CONNPT, DL_MID, TEXT("\tUnadvising connpt 0x%08X of cookie %d"), 
             this, dwCookie));

    HRESULT hr = CONNECT_E_NOCONNECTION;
    
    if (0 != dwCookie)
    {
        AutoLockMutex lock(m_hMutex);
        for (UINT i = 0; i < m_cConnections; i++)
        {
            if (m_ConnectionList[i].dwCookie == dwCookie)
            {
                //
                // Matching cookie found.  Release interface, mark connection
                // list entry as unused.
                //
                hr = NOERROR;
                m_ConnectionList[i].pUnk->Release();
                m_ConnectionList[i].pUnk     = NULL;
                m_ConnectionList[i].dwCookie = 0;
                m_cConnections--;
                DBGPRINT((DM_CONNPT, DL_HIGH, TEXT("CONNPT - Connection terminated for cookie %d.  %d total connections"),
                         dwCookie, m_cConnections));        
                break;
            }   
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPoint::EnumConnections

    Description: Retrieves in interface pointer to a connection enumerator
        which enumerates all connections associated with this connection 
        point.

    Arguments:
        ppEnum - Address of interface pointer variable to received address of
            the enumerator's IEnumConnection interface.

    Returns:
        NOERROR        - Success.
        E_INVALIDARG   - ppEnum was NULL.
        E_OUTOFMEMORY  - Insufficient memory to create enumerator.
        E_UNEXPECTED   - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/21/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ConnectionPoint::EnumConnections(
    PENUMCONNECTIONS *ppEnum
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::EnumConnections")));

    HRESULT hr = NOERROR;

    if (NULL == ppEnum)
        return E_INVALIDARG;

    ConnectionEnum *pEnum = NULL;
    AutoLockMutex lock(m_hMutex);

    try
    {
        array_autoptr<CONNECTDATA> ptrCD;
        PCONNECTDATA pcd = NULL;                
        //
        // Build temp array of connection data to initialize enumerator.
        // Note: If m_cConnections == 0, we still return an enumerator
        //       but it's uninitialized.  Calls to Next and Skip will always
        //       return S_FALSE so the enumerator is just viewed as "empty".
        //
        if (0 != m_cConnections)
        {
            ptrCD = new CONNECTDATA[m_cConnections];
            pcd = ptrCD.get();

            //
            // Transfer connection info to temp array for initializting
            // the enumerator object.
            // Remember, the connection list can have unused entries so
            // cConnListEntries can be greater than m_cConnections.
            //
            UINT cConnListEntries = m_ConnectionList.Count();
            for (UINT i = 0, j = 0; i < cConnListEntries; i++)
            {
                DBGASSERT((j < m_cConnections));
                *(pcd + j) = m_ConnectionList[i];  
                if (NULL != pcd[j].pUnk)
                    j++;
            }
        }

        //
        // Create the enumerator object.
        // The enumerator keeps a copy of the connection's
        // IUnknown pointer.  Note that we still create an 
        // enumerator even if m_cConnections is 0.  It's just an 
        // empty enumerator.  If m_cConnections is 0, pcd can be NULL.
        //
        DBGASSERT((m_cConnections ? NULL != pcd : TRUE));
        pEnum = new ConnectionEnum(static_cast<IConnectionPoint *>(this), m_cConnections, pcd);

        hr = pEnum->QueryInterface(IID_IEnumConnections, 
                                       (LPVOID *)ppEnum);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        delete pEnum;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


//
// IDispatch::GetIDsOfNames
//
STDMETHODIMP
ConnectionPoint::GetIDsOfNames(
    REFIID riid,  
    OLECHAR **rgszNames,  
    UINT cNames,  
    LCID lcid,  
    DISPID *rgDispId
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::GetIDsOfNames")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetIDsOfNames(riid,
                                    rgszNames,
                                    cNames,
                                    lcid,
                                    rgDispId);
}


//
// IDispatch::GetTypeInfo
//
STDMETHODIMP
ConnectionPoint::GetTypeInfo(
    UINT iTInfo,  
    LCID lcid,  
    ITypeInfo **ppTypeInfo
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::GetTypeInfo")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfo(iTInfo, lcid, ppTypeInfo);
}


//
// IDispatch::GetTypeInfoCount
//
STDMETHODIMP
ConnectionPoint::GetTypeInfoCount(
    UINT *pctinfo
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::GetTypeInfoCount")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfoCount(pctinfo);
}


//
// IDispatch::Invoke
//
STDMETHODIMP
ConnectionPoint::Invoke(
    DISPID dispIdMember,  
    REFIID riid,  
    LCID lcid,  
    WORD wFlags,  
    DISPPARAMS *pDispParams,  
    VARIANT *pVarResult,  
    EXCEPINFO *pExcepInfo,  
    UINT *puArgErr
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionPoint::Invoke")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.Invoke(dispIdMember,
                             riid,
                             lcid,
                             wFlags,
                             pDispParams,
                             pVarResult,
                             pExcepInfo,
                             puArgErr);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::ConnectionEnum

    Description: Constructor,

    Arguments:
        pUnkContainer - Pointer to the IUnknown interface of the containing
            object.

        cConnections - Number of connections in array pointed to by rgConnections.

        rgConnections - Array of connection information used to
            initialize the enumerator.

    Returns: Nothing.

    Exceptions: CAllocException.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
    09/06/06    Added copy constructor.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ConnectionEnum::ConnectionEnum(
    LPUNKNOWN pUnkContainer,
    UINT cConnections, 
    PCONNECTDATA rgConnections
    ) : m_cRef(0),
        m_iCurrent(0),
        m_cConnections(0),
        m_rgConnections(NULL),
        m_pUnkContainer(pUnkContainer)
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionEnum::ConnectionEnum")));
    DBGASSERT((NULL != pUnkContainer));

    if (0 != cConnections)
    {
        m_rgConnections = new CONNECTDATA[cConnections];

        DBGASSERT((NULL != rgConnections));

        for (UINT i = 0; i < cConnections; i++)
        {
            //
            // IUnknown::AddRef() is client code. It can generate an exception.
            // Caller must catch and handle it.
            //
            rgConnections[i].pUnk->AddRef();
            m_rgConnections[i].pUnk     = rgConnections[i].pUnk;
            m_rgConnections[i].dwCookie = rgConnections[i].dwCookie;
            m_cConnections++;
        }
    }
}


ConnectionEnum::ConnectionEnum(const ConnectionEnum& refEnum)
    : m_cRef(0),
      m_iCurrent(0),
      m_cConnections(0),
      m_rgConnections(NULL),
      m_pUnkContainer(m_pUnkContainer)
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionEnum::ConnectionEnum [copy]")));

    if (0 != m_cConnections)
    {
        m_rgConnections = new CONNECTDATA[m_cConnections];

        DBGASSERT((NULL != refEnum.m_rgConnections));
        for (UINT i = 0; i < m_cConnections; i++)
        {
            //
            // IUnknown::AddRef() is client code. It can generate an exception.
            // Caller must catch and handle it.
            //
            refEnum.m_rgConnections[i].pUnk->AddRef();
            m_rgConnections[i].pUnk     = refEnum.m_rgConnections[i].pUnk;
            m_rgConnections[i].dwCookie = refEnum.m_rgConnections[i].dwCookie;
            m_cConnections++;
        }
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::~ConnectionEnum

    Description: Destructor.  Releases all connection sink interface pointers
        held in enumerator's array.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ConnectionEnum::~ConnectionEnum(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionEnum::~ConnectionEnum")));

    if (NULL != m_rgConnections)
    {
        for (UINT i = 0; i < m_cConnections; i++)
        {
            if (NULL != m_rgConnections[i].pUnk)
            {
                m_rgConnections[i].pUnk->Release();
                m_rgConnections[i].pUnk = NULL;
            }
        }
        delete[] m_rgConnections;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IEnumConnections interface.  Only IID_IUnknown and 
        IID_IEnumConnections are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR       - Success.
        E_NOINTERFACE - Requested interface not supported.
        E_INVALIDARG  - ppvOut arg is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionEnum::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionEnum::QueryInterface")));
    DBGPRINTIID(DM_CONNPT, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IEnumConnections == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
ConnectionEnum::AddRef(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionEnum::AddRef")));
    DBGPRINT((DM_CONNPT, DL_LOW, TEXT("\t0x%08X  %d -> %d\n"),
             this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;


    InterlockedIncrement(&m_cRef);

    //
    // Increment ref count of connection point so that it stays around
    // while the connection enumerator is alive.
    //
    m_pUnkContainer->AddRef();

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
ConnectionEnum::Release(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionEnum::Release")));
    DBGPRINT((DM_CONNPT, DL_LOW, TEXT("\t0x%08X  %d -> %d\n"),
             this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;

    //
    // Decrement ref count of connection point.  We AddRef'd it
    // above.
    //
    m_pUnkContainer->Release();

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::Next

    Description: Retrieve the next cConnections connections supported by
        the enumerator.

    Arguments:
        cConnections - Number of elements in pConnections array.

        pConnections - Array to receive CONNECTDATA data records.

        pcCreated [optional] - Address of DWORD to accept the count of records 
            returned in pConnections. Note that any array locations equal to 
            or beyond the value returned in pcCreated are invalid and set to 
            NULL.

    Returns:
        S_OK          - Success.  Enumerated number of requested connections.
        S_FALSE       - End of enumeration encountered.  Returning less than
                          cConnections records.
        E_INVALIDARG  - pConnections arg is NULL.
        E_UNEXPECTED  - Exception caught.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
ConnectionEnum::Next(
    DWORD cConnections,         // Number of elements in array.
    PCONNECTDATA pConnections,  // Dest array for connection info.
    DWORD *pcCreated            // Return number created.
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionEnum::Next")));

    if (NULL == pConnections)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    DWORD cCreated = 0;

    //
    // Transfer data to caller's array.
    // Stop when at the end of the enumeration or we've
    // returned all that the caller asked for.
    //
    while(m_iCurrent < m_cConnections && cConnections > 0)
    {
        DBGASSERT((NULL != m_rgConnections));
        *pConnections = m_rgConnections[m_iCurrent++];
        if (NULL != pConnections->pUnk)
        {
            pConnections->pUnk->AddRef();
            pConnections++;
            cCreated++;
            cConnections--;
        }
    }

    //
    // If requested, return the count of items enumerated.
    //
    if (NULL != pcCreated)
        *pcCreated = cCreated;

    if (cConnections > 0)
    {
        //
        // Less than requested number of connections were retrieved.
        // 
        hr = S_FALSE;
        while(cConnections > 0)
        {
            //
            // Set any un-filled array elements to NULL.
            //
            pConnections->pUnk     = NULL;
            pConnections->dwCookie = 0;
            pConnections++;
            cConnections--;
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::Skip

    Description: Skips a specified number of connections in the enumeration.

    Arguments:
        cConnections - Number of connections to skip.

    Returns:
        S_OK            - Success.  Skipped number of requested items.
        S_FALSE         - End of enumeration encountered.  Skipped less than
                          cConnections items.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionEnum::Skip(
    DWORD cConnections
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionEnum::Skip")));

    while(m_iCurrent < m_cConnections && cConnections > 0)
    {
        m_iCurrent++;
        cConnections--;
    }

    return cConnections == 0 ? S_OK : S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::Reset

    Description: Resets the enumerator object so that the next call to Next()
        starts enumerating at the beginning of the enumeration.

    Arguments: None.

    Returns:
        S_OK    - Success.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionEnum::Reset(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionEnum::Reset")));

    m_iCurrent = 0;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionEnum::Clone

    Description: Creates a duplicate of the enumerator object and returns
        a pointer to the new object's IEnumConnections interface.

    Arguments:
        ppEnum - Address of interface pointer variable to accept the pointer
            to the new object's IEnumConnections interface.

    Returns:
        NOERROR        - Success.
        E_OUTOFMEMORY   - Insufficient memory to create new enumerator.
        E_INVALIDARG    - ppEnum arg was NULL.
        E_UNEXPECTED    - Exception caught while calling client code.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionEnum::Clone(
    PENUMCONNECTIONS *ppEnum
    )
{
    DBGTRACE((DM_CONNPT, DL_HIGH, TEXT("ConnectionEnum::Clone")));

    if (NULL == ppEnum)
        return E_INVALIDARG;

    HRESULT hr            = NOERROR;
    ConnectionEnum *pEnum = NULL;

    *ppEnum = NULL;

    try
    {        
        pEnum = new ConnectionEnum((const ConnectionEnum&)*this);

        hr = pEnum->QueryInterface(IID_IEnumConnections, (LPVOID *)ppEnum);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr) && NULL != pEnum)
    {
        delete pEnum;
        *ppEnum = NULL;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::ConnectionPointEnum

    Description: Constructor,

    Arguments:
        pUnkContainer - Pointer to IUnknown of containing object.

        cConnPts - Number of connection points in array pointed to by rgConnPts.

        rgConnPts - Array of connection point object pointers used to
            initialize the enumerator.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
    09/06/96    Added copy constructor.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ConnectionPointEnum::ConnectionPointEnum(
    LPUNKNOWN pUnkContainer,
    UINT cConnPts, 
    PCONNECTIONPOINT *rgConnPts
    ) : m_cRef(0),
        m_iCurrent(0),
        m_cConnPts(0),
        m_rgConnPts(NULL),
        m_pUnkContainer(pUnkContainer)
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPointEnum::ConnectionPointEnum")));
    DBGASSERT((NULL != pUnkContainer));

    if (0 != cConnPts)
    {
        m_rgConnPts = new PCONNECTIONPOINT[cConnPts];

        m_cConnPts = cConnPts;
        for (UINT i = 0; i < m_cConnPts; i++)
        {
            m_rgConnPts[i] = rgConnPts[i];
            m_rgConnPts[i]->AddRef();
        }
    }
}

ConnectionPointEnum::ConnectionPointEnum(
    const ConnectionPointEnum& refEnum
    ) : m_cRef(0),
        m_iCurrent(0),
        m_cConnPts(0),
        m_rgConnPts(NULL),
        m_pUnkContainer(refEnum.m_pUnkContainer)
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPointEnum::ConnectionPointEnum [copy]")));

    if (0 != refEnum.m_cConnPts)
    {
        m_rgConnPts = new PCONNECTIONPOINT[refEnum.m_cConnPts];

        m_cConnPts = refEnum.m_cConnPts;
        for (UINT i = 0; i < m_cConnPts; i++)
        {
            m_rgConnPts[i] = refEnum.m_rgConnPts[i];
            m_rgConnPts[i]->AddRef();
        }
    }
}

    

///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::~ConnectionPointEnum

    Description: Destructor.  Releases all connection point object pointers
        held in enumerator's array.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ConnectionPointEnum::~ConnectionPointEnum(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPointEnum::~ConnectionPointEnum")));

    if (NULL != m_rgConnPts)
    {
        for (UINT i = 0; i < m_cConnPts; i++)
        {
            if (NULL != m_rgConnPts[i])
            {
                m_rgConnPts[i]->Release();
                m_rgConnPts[i] = NULL;
            }
        }
        delete[] m_rgConnPts;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IEnumConnectionPoints interface.  Only IID_IUnknown and 
        IID_IEnumConnectionPoints are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR        - Success.
        E_NOINTERFACE  - Requested interface not supported.
        E_INVALIDARG   - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionPointEnum::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONNPT, DL_MID, TEXT("ConnectionPointEnum::QueryInterface")));
    DBGPRINTIID(DM_CONNPT, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IEnumConnectionPoints == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
ConnectionPointEnum::AddRef(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPointEnum::AddRef")));
    DBGPRINT((DM_CONNPT, DL_LOW, TEXT("\t0x%08X  %d -> %d\n"),
             this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;


    //
    // Increment ref count of QuotaController so that it stays around
    // while the enumerator is alive.
    //
    m_pUnkContainer->AddRef();

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
ConnectionPointEnum::Release(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPointEnum::Release")));
    DBGPRINT((DM_COM, DL_HIGH, TEXT("\t0x%08X  %d -> %d\n"),
             this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;

    //
    // Decrement ref count of QuotaController.  We AddRef'd it above.
    //
    m_pUnkContainer->Release();

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::Next

    Description: Retrieve the next cConnPts connections supported by
        the enumerator.

    Arguments:
        cConnPts - Number of elements in pConnPts array.

        pConnPts - Array to receive PCONNECTIONPOINT pointers.
         
        pcCreated [optional] - Address of DWORD to accept the count of records 
            returned in pConnPts. Note that any array locations equal to or 
            beyond the value returned in pcCreated are invalid and set to NULL.

    Returns:
        S_OK            - Success.  Enumerated number of requested connection pts.
        S_FALSE         - End of enumeration encountered.  Returning less than
                          cConnPts records.
        E_INVALIDARG    - pConnPts arg is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
ConnectionPointEnum::Next(
    DWORD cConnPts,                 // Number of elements in array.
    PCONNECTIONPOINT *rgpConnPts,   // Dest array for connection point ptrs.
    DWORD *pcCreated                // Return number created.
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPointEnum::Next")));

    if (NULL == rgpConnPts)
        return E_INVALIDARG;

    HRESULT hr     = S_OK;
    DWORD cCreated = 0;

    //
    // Transfer data to caller's array.
    // Stop when at the end of the enumeration or we've
    // returned all that the caller asked for.
    //
    while(m_iCurrent < m_cConnPts && cConnPts > 0)
    {
        *rgpConnPts = m_rgConnPts[m_iCurrent++];
        if (NULL != *rgpConnPts)
        {
            (*rgpConnPts)->AddRef();
            rgpConnPts++;
            cCreated++;
            cConnPts--;
        }
        else
            DBGASSERT((FALSE));  // Shouldn't hit this.
    }

    //
    // If requested, return the count of items enumerated.
    //
    if (NULL != pcCreated)
        *pcCreated = cCreated;

    if (cConnPts > 0)
    {
        //
        // Less than requested number of connections were retrieved.
        // 
        hr = S_FALSE;
        while(cConnPts > 0)
        {
            //
            // Set any un-filled array elements to NULL.
            //
            *rgpConnPts = NULL;
            rgpConnPts++;
            cConnPts--;
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::Skip

    Description: Skips a specified number of connection pts in the enumeration.

    Arguments:
        cConnPts - Number of connection points to skip.

    Returns:
        S_OK            - Success.  Skipped number of requested items.
        S_FALSE         - End of enumeration encountered.  Skipped less than
                          cConnPts items.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionPointEnum::Skip(
    DWORD cConnPts
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPointEnum::Skip")));

    while(m_iCurrent < m_cConnPts && cConnPts > 0)
    {
        m_iCurrent++;
        cConnPts--;
    }

    return cConnPts == 0 ? S_OK : S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::Reset

    Description: Resets the enumerator object so that the next call to Next()
        starts enumerating at the start of the enumeration.

    Arguments: None.

    Returns:
        S_OK    - Success.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
ConnectionPointEnum::Reset(
    VOID
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPointEnum::Reset")));

    m_iCurrent = 0;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ConnectionPointEnum::Clone

    Description: Creates a duplicate of the enumerator object and returns
        a pointer to the new object's IEnumConnectionPoints interface.

    Arguments:
        ppEnum - Address of interface pointer variable to accept the pointer
            to the new object's IEnumConnectionPoints interface.

    Returns:
        NOERROR         - Success.
        E_OUTOFMEMORY   - Insufficient memory to create new enumerator.
        E_INVALIDARG    - ppEnum arg was NULL.
        E_UNEXPECTED    - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
 ConnectionPointEnum::Clone(
    PENUMCONNECTIONPOINTS *ppEnum
    )
{
    DBGTRACE((DM_CONNPT, DL_LOW, TEXT("ConnectionPointEnum::Clone")));

    if (NULL == ppEnum)
        return E_INVALIDARG;

    HRESULT hr                 = NOERROR;
    ConnectionPointEnum *pEnum = NULL;

    try
    {
        *ppEnum = NULL;
        pEnum = new ConnectionPointEnum((const ConnectionPointEnum&)*this);

        hr = pEnum->QueryInterface(IID_IEnumConnectionPoints, (LPVOID *)ppEnum);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr) && NULL != pEnum)
    {
        delete pEnum;
        *ppEnum = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\control.h ===
#ifndef _INC_DSKQUOTA_CONTROL_H
#define _INC_DSKQUOTA_CONTROL_H
///////////////////////////////////////////////////////////////////////////////
/*  File: control.h

    Description: Contains declaration for class DiskQuotaControl.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"   // File System object types.
#endif
#ifndef _INC_DSKQUOTA_SIDNAME_H
#   include "sidname.h"    // Sid Name Resolver.
#endif
#ifndef _INC_DSKQUOTA_NTDS_H
#   include "ntds.h"       // For DS versions of LookupAccountSid/Name
#endif
#ifndef _INC_DSKQUOTA_DISPATCH_H
#   include "dispatch.h"   // MIDL-generated header.
#endif
#ifndef _INC_DSKQUOTA_OADISP_H
#   include "oadisp.h"     // OleAutoDispatch class.
#endif


class DiskQuotaControl : public IDiskQuotaControl 
{
    private:
        LONG               m_cRef;                     // Object ref count.
        BOOL               m_bInitialized;             // Controller initialized?
        LONGLONG           m_llDefaultQuotaThreshold;  // "New User" default threshold.
        LONGLONG           m_llDefaultQuotaLimit;      // "New User" default limit.
        FSObject          *m_pFSObject;                // Volume or directory.
        DWORD              m_dwFlags;                  // State of quota system.
        PSID_NAME_RESOLVER m_pSidNameResolver;         // For getting SID account names.
        CMutex             m_mutex;                    // Ensures safe shutdown.

        //
        // Support for IConnectionPointContainer.
        // 1. Static array of supported interface IDs.
        // 2. Array of connection pt interface pointers.
        //    Dynamically grows as clients connect for events.
        //
        static const IID * const m_rgpIConnPtsSupported[];
        PCONNECTIONPOINT  *m_rgConnPts;                // Array of conn pt object ptrs.
        UINT               m_cConnPts;                 // Count of conn pts supported.

        //
        // Create connection point objects for the supported connection
        // point types.
        //
        HRESULT
        InitConnectionPoints(
            VOID);

        //
        // Read quota information from disk to member variables.
        //
        HRESULT
        QueryQuotaInformation(
            VOID);

        //
        // Write quota information from member variables to disk.
        //
        HRESULT
        SetQuotaInformation(
            DWORD dwChangeFlags);

        HRESULT
        GetDefaultQuotaItem(
            PLONGLONG pllItem,
            PLONGLONG pllValueOut);

        //
        // Prevent copy construction.
        //
        DiskQuotaControl(const DiskQuotaControl& control);
        void operator = (const DiskQuotaControl& control);

    public:
        NTDS m_NTDS; 

        //
        // If you add a new connection point type, add a corresponding enumeration
        // member that identifies the location of the conn pt IID in 
        // m_rgpIConnPtsSupported[].
        //
        enum { ConnPt_iQuotaEvents     = 0,
               ConnPt_iQuotaEventsDisp = 1, };

        DiskQuotaControl(VOID);
        ~DiskQuotaControl(VOID);

        HRESULT NotifyUserNameChanged(PDISKQUOTA_USER pUser);

        FSObject *GetFSObjectPtr(VOID)
            { return m_pFSObject; }

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IConnectionPointContainer methods.
        //
        STDMETHODIMP
        FindConnectionPoint(
            REFIID,
            PCONNECTIONPOINT *pCP);

        STDMETHODIMP
        EnumConnectionPoints(
            PENUMCONNECTIONPOINTS *pEnumCP);

        //
        // IDiskQuotaControl methods.
        //
        STDMETHODIMP
        Initialize(
            LPCWSTR pszFSObjectName,
            BOOL bReadWrite);

        STDMETHODIMP
        GetQuotaState(
            LPDWORD pdwState);   

        STDMETHODIMP
        SetQuotaState(
            DWORD dwState);     

        STDMETHODIMP
        SetQuotaLogFlags(
            DWORD dwFlags);    

        STDMETHODIMP
        GetQuotaLogFlags(
            LPDWORD pdwFlags);    

        STDMETHODIMP 
        SetDefaultQuotaThreshold(
            LONGLONG llThreshold);

        STDMETHODIMP 
        SetDefaultQuotaLimit(
            LONGLONG llLimit);

        STDMETHODIMP 
        GetDefaultQuotaThreshold(
            PLONGLONG pllThreshold);

        STDMETHODIMP
        GetDefaultQuotaThresholdText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP 
        GetDefaultQuotaLimit(
            PLONGLONG pllLimit);

        STDMETHODIMP
        GetDefaultQuotaLimitText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP 
        AddUserSid(
            PSID pSid, 
            DWORD fNameResolution,
            PDISKQUOTA_USER *ppUser);

        STDMETHODIMP 
        AddUserName(
            LPCWSTR pszLogonName,
            DWORD fNameResolution,
            PDISKQUOTA_USER *ppUser);

        STDMETHODIMP 
        DeleteUser(
            PDISKQUOTA_USER pUser);

        STDMETHODIMP 
        FindUserSid(
            PSID pSid, 
            DWORD fNameResolution,
            PDISKQUOTA_USER *ppUser);

        STDMETHODIMP 
        FindUserName(
            LPCWSTR pszLogonName, 
            PDISKQUOTA_USER *ppUser);

        STDMETHODIMP 
        CreateEnumUsers(
            PSID *rgpSids, 
            DWORD cpSids,
            DWORD fNameResolution,
            PENUM_DISKQUOTA_USERS *ppEnum);

        STDMETHODIMP
        CreateUserBatch(
            PDISKQUOTA_USER_BATCH *ppUserBatch);

        STDMETHODIMP
        InvalidateSidNameCache(
            VOID);

        STDMETHODIMP
        GiveUserNameResolutionPriority(
            PDISKQUOTA_USER pUser);

        STDMETHODIMP
        ShutdownNameResolution(
            VOID);
};



class DiskQuotaControlDisp : public DIDiskQuotaControl 
{
    public:
        DiskQuotaControlDisp(PDISKQUOTA_CONTROL pQC);

        ~DiskQuotaControlDisp(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);


        //
        // IDispatch methods.
        //
        STDMETHODIMP
        GetIDsOfNames(
            REFIID riid,  
            OLECHAR ** rgszNames,  
            UINT cNames,  
            LCID lcid,  
            DISPID *rgDispId);

        STDMETHODIMP
        GetTypeInfo(
            UINT iTInfo,  
            LCID lcid,  
            ITypeInfo **ppTInfo);

        STDMETHODIMP
        GetTypeInfoCount(
            UINT *pctinfo);

        STDMETHODIMP
        Invoke(
            DISPID dispIdMember,  
            REFIID riid,  
            LCID lcid,  
            WORD wFlags,  
            DISPPARAMS *pDispParams,  
            VARIANT *pVarResult,  
            EXCEPINFO *pExcepInfo,  
            UINT *puArgErr);

        //
        // Automation Properties.
        //
        STDMETHODIMP put_QuotaState(QuotaStateConstants State);
        STDMETHODIMP get_QuotaState(QuotaStateConstants *pState);

        STDMETHODIMP get_QuotaFileIncomplete(VARIANT_BOOL *pbIncomplete);

        STDMETHODIMP get_QuotaFileRebuilding(VARIANT_BOOL *pbRebuilding);

        STDMETHODIMP put_LogQuotaThreshold(VARIANT_BOOL bLogThreshold);
        STDMETHODIMP get_LogQuotaThreshold(VARIANT_BOOL *pbLogThreshold);

        STDMETHODIMP put_LogQuotaLimit(VARIANT_BOOL bLogLimit);
        STDMETHODIMP get_LogQuotaLimit(VARIANT_BOOL *pbLogLimit);

        STDMETHODIMP put_DefaultQuotaThreshold(double Threshold);
        STDMETHODIMP get_DefaultQuotaThreshold(double *pThreshold);
        STDMETHODIMP get_DefaultQuotaThresholdText(BSTR *pThresholdText);

        STDMETHODIMP put_DefaultQuotaLimit(double Limit);
        STDMETHODIMP get_DefaultQuotaLimit(double *pLimit);
        STDMETHODIMP get_DefaultQuotaLimitText(BSTR *pLimitText);

        STDMETHODIMP put_UserNameResolution(UserNameResolutionConstants ResolutionType);
        STDMETHODIMP get_UserNameResolution(UserNameResolutionConstants *pResolutionType);

        //
        // Automation Methods.
        //
        STDMETHODIMP Initialize(
            BSTR path, 
            VARIANT_BOOL bReadOnly);

        STDMETHODIMP AddUser(
            BSTR LogonName,
            DIDiskQuotaUser **ppUser);

        STDMETHODIMP DeleteUser(
            DIDiskQuotaUser *pUser);

        STDMETHODIMP FindUser(
            BSTR LogonName,
            DIDiskQuotaUser **ppUser);

        STDMETHODIMP TranslateLogonNameToSID(
            BSTR LogonName,
            BSTR *psid);

        STDMETHODIMP
            _NewEnum(
                IDispatch **ppEnum);

        STDMETHODIMP InvalidateSidNameCache(void);

        STDMETHODIMP GiveUserNameResolutionPriority(
            DIDiskQuotaUser *pUser);

        STDMETHODIMP ShutdownNameResolution(void);

    private:
        LONG                  m_cRef;                     
        PDISKQUOTA_CONTROL    m_pQC;                      // For delegation
        OleAutoDispatch       m_Dispatch;
        DWORD                 m_fOleAutoNameResolution;
        PENUM_DISKQUOTA_USERS m_pUserEnum;

        //
        // Prevent copy.
        //
        DiskQuotaControlDisp(const DiskQuotaControlDisp& rhs);
        DiskQuotaControlDisp& operator = (const DiskQuotaControlDisp& rhs);
};


#endif  // __DISK_QUOTA_CONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\control.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: control.cpp

    Description: Contains member function definitions for class DiskQuotaControl.
        This class is the main point of focus for managing disk quota information
        through the DSKQUOTA library.  The user creates an instance of a 
        DiskQuotaControl object through CoCreateInstance and manages quota
        information through it's IDiskQuotaControl interface.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "connect.h"
#include "control.h"
#include "guidsp.h"    // Private GUIDs.
#include "registry.h"
#include "sidcache.h"
#include "userbat.h"
#include "userenum.h"
#include "resource.h"  // For IDS_NO_LIMIT.
#include <oleauto.h>   // OLE automation
#include <comutil.h>
#include <sddl.h>

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


//
// Size of user enumerator's buffer.  Thought about this being a reg entry.
// Didn't make a lot of sense.
//
const UINT ENUMUSER_BUF_LEN = 2048;

//
// To add support for a new connection point type, just add a new IID to this
// array.  Also add a corresponding enumeration constant in the DiskQuotaControl
// class declaration that identifies the location of the conn pt IID in 
// m_rgpIConnPtsSupported[].
//
const IID * const DiskQuotaControl::m_rgpIConnPtsSupported[] = { &IID_IDiskQuotaEvents,
                                                                 &IID_DIDiskQuotaControlEvents };


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::DiskQuotaControl

    Description: Constructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/97    Added m_bInitialized member.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaControl::DiskQuotaControl(
    VOID
    ) : m_cRef(0),
        m_bInitialized(FALSE),
        m_pFSObject(NULL),
        m_dwFlags(0),
        m_pSidNameResolver(NULL),
        m_rgConnPts(NULL),
        m_cConnPts(0),
        m_llDefaultQuotaThreshold(0),
        m_llDefaultQuotaLimit(0)
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControl::DiskQuotaControl")));
    InterlockedIncrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::~DiskQuotaControl

    Description: Destructor. Releases FSObject pointer.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaControl::~DiskQuotaControl(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControl::~DiskQuotaControl")));

    //
    // See the comment in NotifyUserNameChanged for a discussion on the
    // use of this mutex.  In short, it prevents a deadlock between
    // the resolver's thread and a client receiving a name-change
    // notification.  The wait here is INFINITE while the corresponding
    // wait in NotifyUserNameChanged is limited.
    //
    AutoLockMutex lock(m_mutex, INFINITE);

    if (NULL != m_pFSObject)
    {
        m_pFSObject->Release();
        m_pFSObject = NULL;
    }

    ShutdownNameResolution();

    if (NULL != m_rgConnPts)
    {
        for (UINT i = 0; i < m_cConnPts; i++)
        {
            if (NULL != m_rgConnPts[i])
            {
                m_rgConnPts[i]->Release();
                m_rgConnPts[i] = NULL;
            }
        }
        delete[] m_rgConnPts;
    }

    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown,
        IDiskQuotaControl or IConnectionPointContainer interface.  The object 
        referenced by the returned interface pointer is uninitialized.  The 
        recipient of the pointer must call Initialize() before the object is 
        usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR       - Success.
        E_NOINTERFACE - Requested interface not supported.
        E_INVALIDARG  - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControl::QueryInterface")));
    DBGPRINTIID(DM_CONTROL, DL_MID, riid);

    if (NULL == ppvOut)
        return E_INVALIDARG;

    HRESULT hr = E_NOINTERFACE;

    try
    {
        *ppvOut = NULL;

        if (IID_IUnknown == riid || 
            IID_IDiskQuotaControl == riid)
        {
            *ppvOut = this;
        }
        else if (IID_IConnectionPointContainer == riid)
        {
            hr = InitConnectionPoints();
            if (SUCCEEDED(hr))
            {
                *ppvOut = static_cast<IConnectionPointContainer *>(this);
            }
        }
        else if (IID_IDispatch == riid ||
                 IID_DIDiskQuotaControl == riid)
        {
            DiskQuotaControlDisp *pQCDisp = new DiskQuotaControlDisp(static_cast<PDISKQUOTA_CONTROL>(this));
            *ppvOut = static_cast<DIDiskQuotaControl *>(pQCDisp);
        }
        if (NULL != *ppvOut)
        {
            ((LPUNKNOWN)*ppvOut)->AddRef();
            hr = NOERROR;
        }
    }
    catch(CAllocException& e)
    {   
        DBGERROR((TEXT("Insufficient memory exception")));
        *ppvOut = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaControl::AddRef(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControl::AddRef")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
                     this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaControl::Release(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControl::Release")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
                     this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::Initialize

    Description: Initializes a quota controller object by opening the NTFS 
        "device" associated with the quota information. The caller passes the
        name of an NTFS volume device to open.  A C++ object is created which
        encapsulates the required NTFS functionality.  This object is known
        as a "file system object" or FSObject.

        Currently, NTFS only supports quotas on volumes.  However, there is
        talk of providing quotas for directories in the future.  This library
        has been designed with this expansion in mind.
        By using an object hierarchy to represent the FSObject,
        we are able to shield the quota control object from differences
        in NTIO API functions dealing with volumes, directories and both
        local and remote flavors of both.  


    Arguments:
        pszPath - Name of NTFS path to open.

        bReadWrite - TRUE  = Read/write.
                     FALSE = Read only.
    Returns:
        NOERROR         - Success.
        E_INVALIDARG    - pszPath arg was NULL.
        E_OUTOFMEMORY   - Insufficient memory.
        E_UNEXPECTED    - Unexpected exception.
        E_FAIL          - Error getting volume information.
        ERROR_ACCESS_DENIED (hr)  - Insufficient access to open FS object.
        ERROR_FILE_NOT_FOUND (hr) - Specified volume doesn't exist.
        ERROR_PATH_NOT_FOUND (hr) - Specified volume doesn't exist.
        ERROR_BAD_PATHNAME (hr)   - Invalid path name provided.
        ERROR_INVALID_NAME (hr)   - Invalid path name provided.
        ERROR_NOT_SUPPORTED (hr)  - Quotas not supported by volume.
        ERROR_ALREADY_INITIALIZED (hr) - Controller is already initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    06/06/96    Added ansi-unicode thunk.                            BrianAu
    06/11/96    Added return of access granted value.                BrianAu
    09/05/96    Added exception handling.                            BrianAu
    09/23/96    Take a "lazy" position on creating the               BrianAu
                SidNameResolver object.  Should only create it when
                it will be needed (user enumeration).  Moved
                creation from here to CreateEnumUsers. 
    07/03/97    Added dwAccess argument.                             BrianAu
    08/15/97    Added "already initialized" check.                   BrianAu
                Removed InitializeA().  
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::Initialize(
    LPCWSTR pszPath,
    BOOL bReadWrite
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::Initialize")));
    DBGPRINT((DM_CONTROL, DL_MID, TEXT("\tpath = \"%s\", bReadWrite = %d"),
              pszPath ? pszPath : TEXT("<null>"), bReadWrite));
    HRESULT hr = NOERROR;

    if (m_bInitialized)
    {
        //
        // Controller has already been initialized.
        // Re-initialization is not allowed.
        //
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }
    else
    {
        if (NULL == pszPath)
            return E_INVALIDARG;

        try
        {
            DWORD dwAccess = GENERIC_READ | (bReadWrite ? GENERIC_WRITE : 0);
            hr = FSObject::Create(pszPath, 
                                  dwAccess,
                                  &m_pFSObject);

            m_bInitialized = SUCCEEDED(hr);
        }
        catch(CAllocException& e)
        {
            DBGERROR((TEXT("Insufficient memory exception")));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::CreateEnumUsers

    Description: Create a new enumerator object for enumerating over the users
        in a volume's quota information file.  The returned interface supports
        the normal OLE 2 enumeration members Next(), Reset(), Skip() and Clone().

    Arguments:
        rgpSids [optional] - Pointer to a list of SID pointers.  If 
            provided, only those users with SIDs included in the list are 
            returned.  This argument may be NULL in which case ALL users are
            included.  Any element containing a NULL pointer will terminate
            the list.

        cpSids [optional] - If pSidList is not NULL, this arg contains
            the count of entries in rgpSids.  If rgpSids is not NULL and this 
            argument contains 0, rgpSids is assumed to contain a terminating
            NULL pointer entry.

        fNameResolution - Can be one of the following:
        
            DISKQUOTA_USERNAME_RESOLVE_NONE
            DISKQUOTA_USERNAME_RESOLVE_SYNC
            DISKQUOTA_USERNAME_RESOLVE_ASYNC

        ppEnum - Address of interface variable to accept the IEnumDiskQuotaUser
            interface pointer.


    Returns:
        NOERROR        - Success.
        E_INVALIDARG   - ppEnum arg is NULL.
        E_OUTOFMEMORY  - Insufficient memory to create enumerator object.
        ERROR_ACCESS_DENIED (hr) - Need READ access to create enumerator.
        ERROR_NOT_READY (hr)     - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
    09/05/96    Added exception handling.                            BrianAu
    09/23/96    Added lazy creation of SidNameResolver object.       BrianAu
                Moved it from InitializeW().
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaControl::CreateEnumUsers(
    PSID *rgpSids,
    DWORD cpSids,
    DWORD fNameResolution,
    IEnumDiskQuotaUsers **ppEnum
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::CreateEnumUsers")));

    HRESULT hr = E_FAIL;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == ppEnum)
        return E_INVALIDARG;

    if (!m_pFSObject->GrantedAccess(GENERIC_READ))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        DiskQuotaUserEnum *pEnumUsers = NULL;
        try
        {
            if (NULL == m_pSidNameResolver)
            {
                //
                // If there's no SID/Name resolver object, create one.
                // We do this "as needed" because user enumeration is
                // the only controller function that requires a resolver.
                // If the client doesn't need a resolver, why create one?
                //
                SidNameResolver *pResolver = NULL;

                //
                // Create user SID/Name resolver object.
                //
                pResolver = new SidNameResolver(*this);

                hr = pResolver->QueryInterface(IID_ISidNameResolver,
                                               (LPVOID *)&m_pSidNameResolver);
                if (SUCCEEDED(hr))
                {
                    hr = m_pSidNameResolver->Initialize();
                    if (FAILED(hr))
                    {
                        //
                        // If resolver initialization fails, we can assume
                        // that the resolver's thread hasn't been created so
                        // it's OK to just call Release() instead of 
                        // Shutdown() followed by Release().  This is strongly 
                        // dependent on the initialization logic in the resolver's
                        // Initialize method.  There's a comment there also.
                        //
                        m_pSidNameResolver->Release();
                        m_pSidNameResolver = NULL;
                        pResolver          = NULL;
                    }
                }
            }
            if (NULL != m_pSidNameResolver)
            {
                //
                // Create and initialize the enumerator object.
                //
                pEnumUsers = new DiskQuotaUserEnum(static_cast<IDiskQuotaControl *>(this),
                                                   m_pSidNameResolver,
                                                   m_pFSObject);
                //
                // This can throw OutOfMemory.
                //
                hr = pEnumUsers->Initialize(fNameResolution,
                                            ENUMUSER_BUF_LEN,
                                            rgpSids, 
                                            cpSids);

                if (SUCCEEDED(hr))
                {
                    hr = pEnumUsers->QueryInterface(IID_IEnumDiskQuotaUsers, 
                                                    (LPVOID *)ppEnum);
                }
                else
                {
                    //
                    // Something failed after enumerator object was created.
                    // 
                    delete pEnumUsers;
                }
            }
        }
        catch(CAllocException& e)
        {
            DBGERROR((TEXT("Insufficient memory exception")));
            delete pEnumUsers;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::CreateUserBatch

    Description: Create a new user batch control object.  Batch control is
        provided to take advantage of the inherent batching properties of the
        NTIOAPI.  If many user records are being altered at one time, it is
        much more efficient to mark each of the users for "deferred update",
        submit each user object to the batch and then flush the batch to disk.

    Arguments:
        ppUserBatch - Address of interface variable to accept the IDiskQuotaUserBatch
            interface pointer.

    Returns:
        NOERROR        - Success.
        E_INVALIDARG   - ppOut arg is NULL.
        E_OUTOFMEMORY  - Insufficient memory to create batch object.
        ERROR_ACCESS_DENIED (hr) - Need WRITE access to create batch.
        ERROR_NOT_READY (hr)     - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::CreateUserBatch(
    PDISKQUOTA_USER_BATCH *ppUserBatch
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::CreateUserBatch")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == ppUserBatch)
        return E_INVALIDARG;

    if (!m_pFSObject->GrantedAccess(GENERIC_WRITE))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        try
        {
            DiskQuotaUserBatch *pUserBatch = new DiskQuotaUserBatch(m_pFSObject);

            hr = pUserBatch->QueryInterface(IID_IDiskQuotaUserBatch, 
                                           (LPVOID *)ppUserBatch);
        }
        catch(CAllocException& e)        // From new or m_UserList ctor.
        {
            DBGERROR((TEXT("Insufficient memory exception")));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::AddUserSid

    Description: Adds a new user to the volume's quota information file.
        If successful, returns an interface to the new user object.  When
        the caller is finished with the interface, they must call Release()
        through that interface pointer.  Uses the default limit and threshold.

    Arguments:
        pSid - Pointer to single SID structure.

        fNameResolution - Method of SID-to-name resolution. Can be one of the 
            following:
                    DISKQUOTA_USERNAME_RESOLVE_NONE
                    DISKQUOTA_USERNAME_RESOLVE_SYNC
                    DISKQUOTA_USERNAME_RESOLVE_ASYNC

        ppUser - Address of interface pointer variable to accept 
            pointer to the new user object's IDiskQuotaUser interface.

    Returns:
        SUCCESS       - Success.
        S_FALSE       - User already exists.  Not added.
        E_OUTOFMEMORY - Insufficient memory.
        E_UNEXPECTED  - Unexpected exception.
        E_INVALIDARG  - pSid or ppUser were NULL.
        ERROR_NOT_READY (hr) - Object not initialized.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/30/96    Added implementation.  Was E_NOTIMPL.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::AddUserSid(
    PSID pSid, 
    DWORD fNameResolution,
    PDISKQUOTA_USER *ppUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::AddUserSid")));

    HRESULT hr = E_FAIL;
    PDISKQUOTA_USER pIUser = NULL;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pSid || NULL == ppUser)
        return E_INVALIDARG;

    LONGLONG llLimit     = 0;
    LONGLONG llThreshold = 0;
    LONGLONG llUsed      = 0;

    *ppUser = NULL;

    //
    // Check to see if the user already exists in the quota file.
    //
    try
    {
        hr = FindUserSid(pSid,
                         DISKQUOTA_USERNAME_RESOLVE_NONE,
                         &pIUser);

        if (SUCCEEDED(hr))
        {
            //
            // The NTIOAPI says the user exists.  
            // We'll need the quota info to determine if we
            // still allow addition of the "new" user.  This is needed because
            // of the weird way the NTIOAPI enumerates users.  If you ask it to
            // enumerate specified user(s), the returned information will include
            // info for users that do not have (but could have) a record in the
            // quota file.  Since the quota system allows automatic addition of
            // users, it considers any users with write access to have a record
            // in the quota file.  Such users are returned with a quota threshold
            // and limit of 0.  Therefore, we treat records marked for deletion
            // or those with 0 used, 0 limit and 0 threshold as "non existing".
            // I use the term "ghost" for these users.
            //
            pIUser->GetQuotaLimit(&llLimit);
            pIUser->GetQuotaThreshold(&llThreshold);
            pIUser->GetQuotaUsed(&llUsed);

            ULARGE_INTEGER a,b,c;
            a.QuadPart = llLimit;
            b.QuadPart = llThreshold;
            c.QuadPart = llUsed;
            DBGPRINT((DM_CONTROL, DL_LOW, TEXT("Found user: Limit = 0x%08X 0x%08X, Threshold = 0x%08X 0x%08X, Used = 0x%08X 0x%08X"),
                      a.HighPart, a.LowPart, b.HighPart, b.LowPart, c.HighPart, c.LowPart));


            BOOL bIsGhost = ((MARK4DEL == llLimit) ||
                            ( 0 == llLimit && 
                              0 == llThreshold && 
                              0 == llUsed));

            if (!bIsGhost)
            {
                //
                // User already exists.  
                //
                hr = S_FALSE;
            }
            else
            {
                DWORD cbSid = GetLengthSid(pSid);

                //
                // User not in quota file OR in quota file but marked for deletion.  
                // Just set it's limit and threshold to the volume defaults.
                //
                pIUser->SetQuotaThreshold(m_llDefaultQuotaThreshold, TRUE);
                hr = pIUser->SetQuotaLimit(m_llDefaultQuotaLimit, TRUE);

                if (SUCCEEDED(hr) && NULL != m_pSidNameResolver)
                {
                    //
                    // We have a good user object and have set the quota parameters.
                    // Get the user's domain, name and full name from the network DC
                    // using the resolution type specified by the caller.
                    //
                    switch(fNameResolution)
                    {
                        case DISKQUOTA_USERNAME_RESOLVE_ASYNC:
                            m_pSidNameResolver->FindUserNameAsync(pIUser);
                            break;
                        case DISKQUOTA_USERNAME_RESOLVE_SYNC:
                            m_pSidNameResolver->FindUserName(pIUser);
                            break;
                        case DISKQUOTA_USERNAME_RESOLVE_NONE:
                        default:
                            break;
                    }
                }
            }
            *ppUser = pIUser;
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        *ppUser = NULL;
        if (NULL != pIUser)
        {
            pIUser->Release();
        }
    }

    return hr;
}


STDMETHODIMP 
DiskQuotaControl::AddUserName(
    LPCWSTR pszLogonName,
    DWORD fNameResolution,
    PDISKQUOTA_USER *ppUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::AddUserName")));

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pszLogonName || NULL == ppUser)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    try
    {
        BYTE Sid[MAX_SID_LEN];
        DWORD cbSid = sizeof(Sid);
        SID_NAME_USE eSidUse;

        if (SUCCEEDED(m_NTDS.LookupAccountByName(NULL,         // system
                                                 pszLogonName, // key
                                                 NULL,         // no container ret
                                                 NULL,         // no display name ret
                                                 &Sid[0],
                                                 &cbSid,
                                                 &eSidUse)))
        {
            hr = AddUserSid(&Sid[0], fNameResolution, ppUser);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::ShutdownNameResolution

    Description: Release the SID/Name resolver.  This terminates the
        resolver thread for clients who don't want to wait for the controller
        object to be destroyed.  Note that subsequent calls to CreateEnumUsers,
        AddUserSid, AddUserName, FindUserSid or FindUserName can restart
        the resolver.

    Arguments: None.

    Returns: Always returns NOERROR

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/29/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::ShutdownNameResolution(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::ShutdownNameResolution")));
    if (NULL != m_pSidNameResolver)
    {
        //
        // Shutdown and release the resolver.
        // Since it's running on it's own thread, we must wait for the thread
        // to exit.
        // Note that if the thread is off resolving a name from the DC, this could
        // take a bit.
        //
        m_pSidNameResolver->Shutdown(TRUE); // TRUE == Wait for thread exit.

        m_pSidNameResolver->Release();  
        m_pSidNameResolver = NULL;
    }
    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::GiveUserNameResolutionPriority

    Description: A very long name for a very simple function.
        This function merely finds the user object in the name resolver's
        input queue and moves it to the head of the queue.

    Arguments:
        pUser - Address of interface pointer for the user object's 
                IDiskQuotaUser interface.

    Returns:
        NOERROR       - Success.
        S_FALSE       - User object not in resolver queue.
        E_OUTOFMEMORY - Insufficient memory.
        E_INVALIDARG  - pUser is NULL.
        E_UNEXPECTED  - Unexpected error.  Caught an exception or the 
                        Sid-Name resolver hasn't been created.
        ERROR_NOT_READY (hr) - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::GiveUserNameResolutionPriority(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GiveUserNameResolutionPriority")));
    HRESULT hr = E_UNEXPECTED;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pUser)
        return E_INVALIDARG;

    //
    // SidNameResolver::PromoteUserToQueueHeader catches exceptions and
    // converts them to HRESULTs.  No need for try-catch block here.
    //
    if (NULL != m_pSidNameResolver)
    {
        hr = m_pSidNameResolver->PromoteUserToQueueHead(pUser);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::FindUserSid

    Description: Finds a single user record in a volume's quota information
        file.  Returns an interface to the corresponding user object.  When
        the caller is finished with the interface, they must call Release()
        through that interface pointer.


                   >>>>>>>>> IMPORTANT NOTE <<<<<<<<<

        This method will return a user object even if there is no quota
        record for the user in the quota file.  While that may sound
        strange, it is consistent with the idea of automatic user addition
        and default quota settings.  If there is currently no user record
        for the requested user, and the user would be added to the quota
        file if they were to request disk space, the returned user object
        will have a quota threshold of 0 and a quota limit of 0.

    Arguments:
        pSid - Pointer to single SID structure identifying the user.

        fNameResolution -  Can be one of the following:

            DISKQUOTA_USERNAME_RESOLVE_NONE
            DISKQUOTA_USERNAME_RESOLVE_SYNC
            DISKQUOTA_USERNAME_RESOLVE_ASYNC

        ppUser - Address of interface pointer variable to accept pointer to 
            the user object's IDiskQuotaUser interface.

    Returns:
        NOERROR       - Success.
        E_INVALIDARG  - Either pSid or ppUser were NULL.
        E_OUTOFMEMORY - Insufficient memory.
        E_UNEXPECTED  - Unexpected exception.
        ERROR_INVALID_SID (hr)   - Invalid SID.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        ERROR_NO_SUCH_USER (hr)  - User not found in volume's quota information.
        ERROR_NOT_READY (hr)     - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/14/96    Changed name from FindUser to FindUserSid to         BrianAu
                accomodate the addition of the FindUserName
                methods.  No change in functionality.
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::FindUserSid(
    PSID pSid, 
    DWORD fNameResolution,
    PDISKQUOTA_USER *ppUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::FindUserSid")));
    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pSid || NULL == ppUser)
        return E_INVALIDARG;


    if (!m_pFSObject->GrantedAccess(GENERIC_READ))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        if (!IsValidSid(pSid))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        }
        else
        {
            PENUM_DISKQUOTA_USERS pEnumUsers = NULL;
            try
            {
                DWORD cbSid = GetLengthSid(pSid);

                *ppUser = NULL;

                //
                // Create a user enumerator for the user's SID.
                // Can throw OutOfMemory.
                //
                hr = CreateEnumUsers(&pSid, 1, fNameResolution, &pEnumUsers);
                if (SUCCEEDED(hr))
                {
                    DWORD dwUsersFound    = 0;
                    PDISKQUOTA_USER pUser = NULL;
                    //
                    // Enumerate 1 record to get the user's info.
                    // Only one record required since the enumerator object
                    // was created from a single SID. Can throw OutOfMemory.
                    //
                    hr = pEnumUsers->Next(1, &pUser, &dwUsersFound);
                    if (S_OK == hr)
                    {
                        //
                        // Return user object interface to caller.
                        //
                        *ppUser = pUser;
                    }
                    else if (S_FALSE == hr)
                    {
                        //
                        // Note:  We should never hit this.
                        //        The quota system always returns a user record
                        //        for a user SID.  If the record doesn't currently
                        //        exist, one with default limit and threshold is
                        //        returned.  This is consistent with the idea
                        //        of automatic user record addition implemented
                        //        by the NTFS quota system.  Just in case we do,
                        //        I want to return something intelligent.
                        //
                        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
                    }
                }
            }
            catch(CAllocException& e)
            {
                DBGERROR((TEXT("Insufficient memory exception")));
                hr = E_OUTOFMEMORY;
            }
            if (NULL != pEnumUsers)
            {
                //
                // Release the enumerator.
                //
                pEnumUsers->Release();
            }
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::FindUserName

    Description: Finds a single user record in a volume's quota information
        file.  Returns an interface to the corresponding user object.  When
        the caller is finished with the interface, they must call Release()
        through that interface pointer.  
        If the name is not already cached in the SidNameCache, the function
        queries the network domain controller.  This operation may take some
        time (on the order of 0 - 10 seconds).

    Arguments:
        pszLogonName - Address of user's logon name string.
            i.e. "REDMOND\brianau" or "brianau@microsoft.com"

        ppUser - Address of interface pointer variable to accept pointer to 
            the user object's IDiskQuotaUser interface.

    Returns:
        NOERROR       - Success.
        E_INVALIDARG  - Name string is blank or NUL ptr was passed.
        E_OUTOFMEMORY - Insufficient memory.
        E_UNEXPECTED  - Unexpected exception.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        ERROR_NO_SUCH_USER (hr)  - User not found in quota file.
        ERROR_NOT_READY (hr)     - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/14/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
                Added exception handling.
    08/15/97    Removed ANSI version.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::FindUserName(
    LPCWSTR pszLogonName,
    PDISKQUOTA_USER *ppUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::FindUserName")));

    HRESULT hr                = E_FAIL; // Assume failure.
    BOOL bAskDomainController = TRUE;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pszLogonName || NULL == ppUser)
        return E_INVALIDARG;

    if (TEXT('\0') == *pszLogonName)
        return E_INVALIDARG;

    //
    // Check for client's access to quota file before we do any 
    // time-expensive operations.
    //
    if (!m_pFSObject->GrantedAccess(GENERIC_READ))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED); 
    }
    else
    {
        PSID pSid = NULL;      // For cache query.
        SID Sid[MAX_SID_LEN];  // For DC query.
        //
        // These nested try-catch blocks look really gross and may 
        // be unnecessary.  I should probably just punt if one of the
        // inner blocks really does throw an exception and return
        // E_UNEXPECTED instead of trying to continue. [brianau]
        //
        try
        {
            SidNameCache *pSidCache;
            hr = SidNameCache_Get(&pSidCache);
            if (SUCCEEDED(hr))
            {
                //
                // See if the SID/Name pair is in the cache.
                //
                try
                {
                    hr = pSidCache->Lookup(pszLogonName, &pSid);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // We have a SID.  No need to ask DC.
                        //
                        bAskDomainController = FALSE;
                    }
                }
                catch(CAllocException& e)
                {
                    //
                    // Just catch the exception.
                    // This will cause us to go to the DC for the SID.
                    //
                    DBGERROR((TEXT("C++ exception during SID cache lookup in FindUserName")));
                    pSid = &Sid[0];
                }
            }

            if (bAskDomainController)
            {
                DBGASSERT((FAILED(hr)));

                //
                // Still don't have a SID.  Ask the DC.
                // This can take some time (Ho Hum.........)
                //
                CString strDisplayName;
                CString strContainerName;
                SID_NAME_USE eUse;
                DWORD cbSid = sizeof(Sid);

                if (SUCCEEDED(m_NTDS.LookupAccountByName(NULL,
                                                         pszLogonName,
                                                         &strContainerName,
                                                         &strDisplayName,
                                                         &Sid[0],
                                                         &cbSid,
                                                         &eUse)))
                {
                    pSid = &Sid[0];
                    //
                    // Add it to the cache for later use.
                    //
                    if (NULL != pSidCache)
                    {
                        pSidCache->Add(&Sid[0], 
                                       strContainerName,
                                       pszLogonName,
                                       strDisplayName);
                    }

                    hr = NOERROR;
                }
            }

            if (SUCCEEDED(hr))
            {
                //
                // We have a SID.
                // Now create the actual user object using FindUserSid().
                //
                hr = FindUserSid(pSid, DISKQUOTA_USERNAME_RESOLVE_SYNC, ppUser);
            }
        }
        catch(CAllocException& e)
        {
            DBGERROR((TEXT("Insufficient memory exception")));
            hr = E_OUTOFMEMORY;
        }
        if (&Sid[0] != pSid)
        {
            //
            // We received a heap-allocated SID from SidNameCache::Lookup.
            // Need to free the buffer.
            //
            delete[] pSid;
        }
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::DeleteUser

    Description: Deletes a user from a volume's quota information and quota
        tracking.  The IDiskQuotaUser pointer may be obtained either through
        enumeration or DiskQuotaControl::FindUser().

        NOTE:  At this time, we're not sure how (or if) deletion will be done.
               This function remains un-implemented until we figure it out.

    Arguments:
        pUser - Pointer to quota user object's IDiskQuotaUser interface.

    Returns:
        NOERROR              - Success.
        E_OUTOFMEMORY        - Insufficient memory.
        E_UNEXPECTED         - Unexpected exception.
        E_FAIL               - NTIO error writing user data.
        E_INVALIDARG         - pUser argument was NULL.
        ERROR_FILE_EXISTS (hr)   - Couldn't delete.  User still has bytes charge.
        ERROR_ACCESS_DENIED (hr) - Insufficient access.
        ERROR_NOT_READY (hr)     - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/28/96    Added implementation.  Was E_NOTIMPL.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::DeleteUser(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::DeleteUser")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pUser)
        return E_INVALIDARG;

    try
    {
        LONGLONG llValue;
        //
        // Invalidate user object to force a refresh of data from the
        // quota file.  Want to make sure this is current information before
        // we tell the caller that the user can't be deleted.
        //
        pUser->Invalidate();
        hr = pUser->GetQuotaUsed(&llValue);

        if (SUCCEEDED(hr))
        {
            if (0 == llValue)
            {
                //
                // User has 0 bytes in use.  OK to delete.
                // Write -2 to user's limit and threshold.
                //
                pUser->SetQuotaThreshold(MARK4DEL, TRUE);
                hr = pUser->SetQuotaLimit(MARK4DEL, TRUE);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
            }
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::QueryQuotaInformation

    Description: Read quota information from disk to member variables.

    Arguments: None.

    Returns:
        NOERROR            - Success.
        E_FAIL             - Any other error.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaControl::QueryQuotaInformation(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControl::QueryQuotaInformation")));

    HRESULT hr = NOERROR;
    DISKQUOTA_FSOBJECT_INFORMATION Info;

    hr = m_pFSObject->QueryObjectQuotaInformation(&Info);
    if (SUCCEEDED(hr))
    {
        m_llDefaultQuotaThreshold = Info.DefaultQuotaThreshold;
        m_llDefaultQuotaLimit     = Info.DefaultQuotaLimit;
        
        m_dwFlags = (Info.FileSystemControlFlags & DISKQUOTA_FLAGS_MASK);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::SetQuotaInformation

    Description: Writes quota information from member variables to disk.

    Arguments: 
        dwChangeMask - A bit mask with one or more of the following bits set:
        
                FSObject::ChangeState
                FSObject::ChangeLogFlags
                FSObject::ChangeThreshold
                FSObject::ChangeLimit

    Returns:
        NOERROR            - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaControl::SetQuotaInformation(
    DWORD dwChangeMask
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControl::SetQuotaInformation")));

    HRESULT hr = NOERROR;
    DISKQUOTA_FSOBJECT_INFORMATION Info;

    Info.DefaultQuotaThreshold  = m_llDefaultQuotaThreshold;
    Info.DefaultQuotaLimit      = m_llDefaultQuotaLimit;
    Info.FileSystemControlFlags = m_dwFlags;

    hr = m_pFSObject->SetObjectQuotaInformation(&Info, dwChangeMask);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::SetDefaultQuotaThreshold

    Description: Sets the default quota threshold value applied to new user 
        quota records.  Value is in bytes.

    Arguments:
        llThreshold - Threshold value.

    Returns:
        NOERROR    - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        ERROR_INVALID_PARAMETER  - llThreshold was less than -2.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
    11/11/98    Added check for value < -2.                          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::SetDefaultQuotaThreshold(
    LONGLONG llThreshold
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::SetDefaultQuotaThreshold")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (MARK4DEL > llThreshold)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    m_llDefaultQuotaThreshold  = llThreshold;
    hr = SetQuotaInformation(FSObject::ChangeThreshold);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::SetDefaultQuotaLimit

    Description: Sets the default quota limit value applied to new user 
        quota records.  Value is in bytes.

    Arguments:
        llThreshold - Limit value.

    Returns:
        NOERROR    - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        ERORR_NOT_READY (hr)     - Object not initialized.
        ERROR_INVALID_PARAMETER  - llLimit was less than -2.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
    11/11/98    Added check for value < -2.                          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::SetDefaultQuotaLimit(
    LONGLONG llLimit
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::SetDefaultQuotaLimit")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (MARK4DEL > llLimit)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    m_llDefaultQuotaLimit  = llLimit;
    hr = SetQuotaInformation(FSObject::ChangeLimit);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::GetDefaultQuotaItem

    Description: Retrieves one of the default quota items (limit, threshold)
        applied to new user quota records.  Value is in bytes.

    Arguments:
        pllItem - Address of item (limit, threshold, used) value item to 
            retrieve (member variable).

        pllValueOut - Address of LONGLONG variable to receive value.

    Returns:
        NOERROR             - Success.
        E_INVALIDARG        - pdwLowPart or pdwHighPart is NULL.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaControl::GetDefaultQuotaItem(
    PLONGLONG pllItem,
    PLONGLONG pllValueOut
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControl::GetDefaultQuotaItem")));

    HRESULT hr = NOERROR;

    if (NULL == pllItem || NULL == pllValueOut)
        return E_INVALIDARG;

    try
    {
        hr = QueryQuotaInformation();
        if (SUCCEEDED(hr))
        {
            *pllValueOut = *pllItem;
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::GetDefaultQuotaThreshold

    Description: Retrieves the default quota threshold applied to new user
        quota records.  Value is in bytes.

    Arguments:
        pllThreshold - Address of LONGLONG to receive threshold value.

    Returns:
        NOERROR             - Success.
        E_INVALIDARG        - pdwLowPart or pdwHighPart is NULL.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::GetDefaultQuotaThreshold(
    PLONGLONG pllThreshold
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GetDefaultQuotaThreshold")));

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    return GetDefaultQuotaItem(&m_llDefaultQuotaThreshold, pllThreshold);
}


STDMETHODIMP
DiskQuotaControl::GetDefaultQuotaThresholdText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GetDefaultQuotaThresholdText")));

    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetDefaultQuotaThreshold(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::GetDefaultQuotaLimit

    Description: Retrieves the default quota limit applied to new user
        quota records.  Value is in bytes.

    Arguments:
        pllThreshold - Address of LONGLONG to receive limit value.

    Returns:
        NOERROR             - Success.
        E_INVALIDARG        - pdwLowPart or pdwHighPart is NULL.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        E_FAIL              - Any other error. // BUBUG: conflict?

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControl::GetDefaultQuotaLimit(
    PLONGLONG pllLimit
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GetDefaultQuotaLimit")));

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    return GetDefaultQuotaItem(&m_llDefaultQuotaLimit, pllLimit);
}


STDMETHODIMP
DiskQuotaControl::GetDefaultQuotaLimitText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GetDefaultQuotaLimitText")));

    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetDefaultQuotaLimit(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::GetQuotaState

    Description: Retrieve the state of the quota system.
        
    Arguments:
        pdwState - Address of DWORD to accept the quota state value.
            Returned value is formatted as follows:
            
            Bit(s)   Definition
            -------  ---------------------------------------------------
            00-01    0 = Disabled  (DISKQUOTA_STATE_DISABLED)
                     1 = Tracking  (DISKQUOTA_STATE_TRACK)
                     2 = Enforcing (DISKQUOTA_STATE_ENFORCE)
                     3 = Invalid value.
            02-07    Reserved
            08       1 = Quota file incomplete.
            09       1 = Rebuilding quota file.
            10-31    Reserved.

            Use the macros defined in dskquota.h to query the 
            values and bits in this state DWORD.

    Returns:
        NOERROR             - Success.
        E_INVALIDARG        - pdwState arg is NULL.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/02/96    Initial creation.                                    BrianAu
    08/19/96    Added DISKQUOTA_FILEFLAG_MASK.                       BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::GetQuotaState(
    LPDWORD pdwState
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GetQuotaState")));
    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pdwState)
        return E_INVALIDARG;

    try
    {
        hr = QueryQuotaInformation();
        if (SUCCEEDED(hr))
        {
            DWORD dwMask = DISKQUOTA_STATE_MASK | DISKQUOTA_FILEFLAG_MASK;
            *pdwState = (m_dwFlags & dwMask);
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::SetQuotaState

    Description: Sets the quota state flags in the volume's quota info file.
        The quota state may be one of the following:
            - Disabled.
            - Tracking quotas (no enforcement).
            - Enforcing quota limits.

    Arguments:
        dwState - New state of quota system.  The bits in this DWORD are
            defined as follows:
            
            Bit(s)   Definition
            -------  ---------------------------------------------------
            00-01    0 = Disabled  (DISKQUOTA_STATE_DISABLED)
                     1 = Tracking  (DISKQUOTA_STATE_TRACK)
                     2 = Enforcing (DISKQUOTA_STATE_ENFORCE)
                     3 = Invalid value.
            02-07    Reserved
            08       1 = Quota file incomplete (read only)
            09       1 = Rebuilding quota file (read only)
            10-31    Reserved.

            Use the macros defined in dskquota.h to set the 
            values and bits in this state DWORD.

    Returns:
        NOERROR             - Success.
        E_INVALIDARG        - Invalid state value.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/02/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::SetQuotaState(
    DWORD dwState
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::SetQuotaState")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    try
    {
        if (dwState <= DISKQUOTA_STATE_MASK)
        {

            m_dwFlags &= ~DISKQUOTA_STATE_MASK; // Clear current state bits.
            m_dwFlags |= dwState;               // Set new state bits.

            hr = SetQuotaInformation(FSObject::ChangeState);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::GetQuotaLogFlags

    Description: Retrieve the state of the quota logging system.
        
    Arguments:
        pdwFlags - Address of DWORD to accept the quota logging flags.
            The bits in the flags DWORD are defined as follows:

            Bit(s)   Definition
            -------  ---------------------------------------------------
            00       1 = Logging user threshold violations.
            01       1 = Logging user limit violations.
            02       1 = Logging volume threshold violations.
            03       1 = Logging volume limit violations.
            04-31    Reserved.

            Use the macros defined in dskquota.h to query the 
            values and bits in this flags DWORD.

    Returns:
        NOERROR             - Success.
        E_INVALIDARG        - pdwFlags arg is NULL.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/02/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::GetQuotaLogFlags(
    LPDWORD pdwFlags
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::GetQuotaLogFlags")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    if (NULL == pdwFlags)
        return E_INVALIDARG;

    try
    {
        hr = QueryQuotaInformation();
        if (SUCCEEDED(hr))
        {
            *pdwFlags = ((m_dwFlags & DISKQUOTA_LOGFLAG_MASK) >> DISKQUOTA_LOGFLAG_SHIFT);
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::SetQuotaLogFlags

    Description: Sets the quota logging state flags in the volume's quota 
        info file.

    Arguments:
        dwFlags - New state of quota logging. 
            The bits in the flags DWORD are defined as follows:

            Bit(s)   Definition
            -------  ---------------------------------------------------
            00       1 = Logging user threshold violations.
            01       1 = Logging user limit violations.
            02       1 = Logging volume threshold violations.
            03       1 = Logging volume limit violations.
            04-31    Reserved.

            Use the macros defined in dskquota.h to set the 
            values and bits in this flags DWORD.

    Returns:
        NOERROR             - Success.
        E_UNEXPECTED        - Unexpected exception.
        E_OUTOFMEMORY       - Insufficient memory.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        ERROR_NOT_READY (hr)     - Object not initialized.
        E_FAIL                   - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/02/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::SetQuotaLogFlags(
    DWORD dwFlags
    )     
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::SetQuotaLogFlags")));

    HRESULT hr = NOERROR;

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);

    try
    {
        m_dwFlags &= ~DISKQUOTA_LOGFLAG_MASK;
        m_dwFlags |= (dwFlags << DISKQUOTA_LOGFLAG_SHIFT);
        hr = SetQuotaInformation(FSObject::ChangeLogFlags);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::InitConnectionPoints

    Description: Private function for initializing the connection point
        objects supported by IConnectionPointContainer.  Called from
        DiskQuotaControl::Initialize().  To add a new connection point
        type, merely add a new record to the m_rgConnPtDesc[] array in the
        DiskQuotaControl class declaration.  All of the other related code
        in DiskQuotaControl will adjust to it automatically.

    Arguments: None.

    Returns:
        NOERROR        - Success.
        E_UNEXPECTED   - A connection point pointer was non-NULL.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaControl::InitConnectionPoints(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControl::InitConnectionPoints")));

    if (NULL != m_rgConnPts)
    {
        //
        // Already initialized.  
        //
        return NOERROR;
    }

    HRESULT hr = NOERROR;
    ConnectionPoint *pConnPt = NULL;

    m_cConnPts = ARRAYSIZE(m_rgpIConnPtsSupported);

    try
    {
        m_rgConnPts = new PCONNECTIONPOINT[m_cConnPts];

        //
        // For each of the connection point IIDs in m_rgpIConnPtsSupported[]...
        //
        for (UINT i = 0; i < m_cConnPts && SUCCEEDED(hr); i++)
        {
            m_rgConnPts[i] = NULL;

            //
            // Create connection point object and query for IConnectionPoint interface.
            //
            pConnPt = new ConnectionPoint(static_cast<IConnectionPointContainer *>(this), 
                                          *m_rgpIConnPtsSupported[i]);

            hr = pConnPt->QueryInterface(IID_IConnectionPoint, (LPVOID *)&m_rgConnPts[i]);

            if (FAILED(hr))
            {
                // 
                // Either Initialize or QI failed.
                //
                delete pConnPt;
                pConnPt = NULL;
            }
        }
    }
    catch(CAllocException& e)
    {
        delete pConnPt;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::FindConnectionPoint

    Description: Queries the quota control object for a specific connection
        point type.  If that type is supported, a pointer to the connection
        point's IConnectionPoint interface is returned.

    Arguments:
        riid - Interface ID of desired connection point interface.
            Supported interfaces:
                IID_IDiskQuotaUserEvents
                    - OnNameChanged()


    Returns:
        NOERROR         - Success.
        E_INVALIDARG    - ppConnPtOut arg is NULL.
        E_NOINTERFACE   - Requested interface is not supported.
        E_UNEXPECTED    - Connection point object pointer is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::FindConnectionPoint(
    REFIID riid,
    IConnectionPoint **ppConnPtOut
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::FindConnectionPoint")));
    DBGPRINTIID(DM_CONTROL, DL_HIGH, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppConnPtOut)
        return E_INVALIDARG;

    *ppConnPtOut = NULL;
    for (UINT i = 0; i < m_cConnPts && NULL == *ppConnPtOut; i++)
    {
        if (*m_rgpIConnPtsSupported[i] == riid)
        {
            if (NULL != m_rgConnPts[i])
            {
                //
                // We have an IID match.  
                // Now get the conn pt interface pointer.
                //
                hr = m_rgConnPts[i]->QueryInterface(IID_IConnectionPoint, (LPVOID *)ppConnPtOut);
            }
            else
            {
                hr = E_UNEXPECTED;
                break;
            }
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::EnumConnectionPoints

    Description: Creates a connection point enumerator object.
        Using this object, the client can enumerate through all of the
        connection point interfaces supported by the quota controller.

    Arguments:
        ppEnum - Address of interface pointer variable to receive the 
            IEnumConnectionPoints interface.

    Returns:
        NOERROR         - Success.
        E_OUTOFMEMORY   - Insufficient memory to create object(s).
        E_INVALIDARG    - ppEnum arg was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::EnumConnectionPoints")));

    HRESULT hr = NOERROR;

    if (NULL == ppEnum)
        return E_INVALIDARG;

    PCONNECTIONPOINT rgCP[ARRAYSIZE(m_rgpIConnPtsSupported)];
    ConnectionPointEnum *pEnum = NULL;

    *ppEnum = NULL;

    for (UINT i = 0; i < m_cConnPts; i++)
    {
        //
        // Make a copy of each connection point pointer
        // to give to the enumerator's Initialize() method.
        //
        m_rgConnPts[i]->AddRef();
        rgCP[i] = m_rgConnPts[i];
    }

    try
    {
        pEnum = new ConnectionPointEnum(static_cast<IConnectionPointContainer *>(this), 
                                        m_cConnPts, rgCP);

        hr = pEnum->QueryInterface(IID_IEnumConnectionPoints, (LPVOID *)ppEnum);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr) && NULL != pEnum)
    {
        delete pEnum;
        *ppEnum = NULL;
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControl::InvalidateSidNameCache

    Description: Invalidates the contents of the SidNameCache so that future
        requests for account names from the cache must be resolved through
        the DC.  As names are resolved, they are again added to the cache.

    Arguments: None.

    Returns:
        NOERROR       - Cache invalidated.
        E_OUTOFMEMORY - Insufficient memory.
        E_UNEXPECTED  - Unexpected exception.
        E_FAIL        - No cache object available or couldn't get lock on
                        cache files.  Either way, cache wasn't invalidated.
        ERROR_NOT_READY (hr)  - Object not initialized.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/24/96    Initial creation.                                    BrianAu
    09/20/96    Updated for new cache design.                        BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaControl::InvalidateSidNameCache(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::InvalidateSidNameCache")));

    if (!m_bInitialized)
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);


    SidNameCache *pCache;
    HRESULT hr = SidNameCache_Get(&pCache);

    if (SUCCEEDED(hr))
    {
        if (!pCache->Clear())
        {
            hr = E_FAIL;
        }
    }
    return hr;
}
    

///////////////////////////////////////////////////////////////////////////////
/*  Function:  DiskQuotaControl::NotifyUserNameChanged

    Description: Notify all user IDiskQuotaControl Event connections that a 
        user's name has changed.

    Arguments:
        pUser - Address of user object's IDiskQuotaUser interface.

    Returns:
        NOERROR       - Success.
        E_OUTOFMEMORY - Insufficient memory to create enumerator.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/22/96    Initial creation.                                    BrianAu
    08/25/97    Added support for IPropertyNotifySink                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaControl::NotifyUserNameChanged(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControl::NotifyUserNameChanged")));

    HRESULT hr = NOERROR;
    PCONNECTIONPOINT pConnPt = NULL;
    bool bAbort = false;

    INT rgiConnPt[] = { ConnPt_iQuotaEvents,
                        ConnPt_iQuotaEventsDisp };

    for (INT i = 0; i < ARRAYSIZE(rgiConnPt) && !bAbort; i++)
    {
        if (NULL != (pConnPt = m_rgConnPts[ rgiConnPt[i] ]))
        {
            PENUMCONNECTIONS pEnum = NULL;

            pConnPt->AddRef();
            hr = pConnPt->EnumConnections(&pEnum);
            if (SUCCEEDED(hr))
            {
                CONNECTDATA cd;

                while(!bAbort && NOERROR == pEnum->Next(1, &cd, NULL))
                {
                    DBGASSERT((NULL != cd.pUnk));

                    LPUNKNOWN pEventSink = NULL;
                    hr = cd.pUnk->QueryInterface(*(m_rgpIConnPtsSupported[ rgiConnPt[i] ]),
                                                 (LPVOID *)&pEventSink);
                    //
                    // Guard with a critical section mutex.  The NT5 quota UI
                    // may deadlock after closing the details view window
                    // without this critical section.  It's possible, other
                    // clients of the quota controller could do the same.  
                    // Here's what happens:
                    //      The controller calls OnUserNameChanged which
                    //      is implemented by the DetailsView object.  This
                    //      function updates the details view for the specified
                    //      quota user.  Update involves sending/posting 
                    //      messages to the listview object.  On destruction
                    //      of the listview window (user closing the window), 
                    //      the quota controller is released.  If the 
                    //      DetailsView held the last ref count to the 
                    //      controller, the controller commands the SID/Name
                    //      resolver to shutdown.  The resolver's Shutdown
                    //      command posts a WM_QUIT to the resolver's input
                    //      queue and blocks until the resolver's thread
                    //      exits normally.  The problem is that the DetailsView
                    //      thread is blocked waiting for the resolver's thread
                    //      to exit but the resolver's thread is blocked 
                    //      because the DetailsView thread can't process it's
                    //      listview update messages.  This results in deadlock.
                    // This critical section prevents this.
                    //
                    if (SUCCEEDED(hr))
                    {
                        if (WAIT_OBJECT_0 != m_mutex.Wait(2000))
                        {
                            //
                            // DiskQuotaControl dtor must own this mutex.  
                            // Since the control is being destroyed, no sense in 
                            // continuing.
                            //
                            DBGERROR((TEXT("Mutex timeout in DiskQuotaControl::NotifyUserNameChanged")));
                            bAbort = true;
                        }
                        else
                        {
                            AutoLockMutex lock(m_mutex); // Exception-safe release.
                            try
                            {
                                //
                                // Calling client code.  Handle any exceptions.
                                //
                                switch(rgiConnPt[i])
                                {
                                    case ConnPt_iQuotaEvents:
                                        hr = ((PDISKQUOTA_EVENTS)pEventSink)->OnUserNameChanged(pUser);
                                        break;

                                    case ConnPt_iQuotaEventsDisp:
                                    {
                                        IDispatch *pEventDisp = NULL;
                                        hr = pEventSink->QueryInterface(IID_IDispatch, (LPVOID *)&pEventDisp);
                                        if (SUCCEEDED(hr))
                                        {
                                            IDispatch *pUserDisp = NULL;
                                            hr = pUser->QueryInterface(IID_IDispatch, (LPVOID *)&pUserDisp);
                                            if (SUCCEEDED(hr))
                                            {
                                                UINT uArgErr;
                                                VARIANTARG va;
                                                DISPPARAMS params;

                                                VariantClear(&va);
                                                V_VT(&va)       = VT_DISPATCH;
                                                V_DISPATCH(&va) = pUserDisp;

                                                params.rgvarg            = &va;
                                                params.rgdispidNamedArgs = NULL;
                                                params.cArgs             = 1;
                                                params.cNamedArgs        = 0;

                                                hr = pEventDisp->Invoke(DISPID_DISKQUOTAEVENTS_USERNAMECHANGED,
                                                                             IID_NULL,
                                                                             GetThreadLocale(),
                                                                             DISPATCH_METHOD,
                                                                             &params,
                                                                             NULL,
                                                                             NULL,
                                                                             &uArgErr);
                                                if (FAILED(hr))
                                                {
                                                    DBGERROR((TEXT("Error 0x%08X firing async notification event with IDispatch::Invoke"), hr));
                                                }
                                                pUserDisp->Release();
                                            }
                                            else
                                            {
                                                DBGERROR((TEXT("Error 0x%08X getting IDispatch interface from user object for async notification."), hr));
                                            }
                                            pEventDisp->Release();
                                        }
                                        else
                                        {
                                            DBGERROR((TEXT("Error 0x%08X getting IDispatch interface from connection point for async notification."), hr));
                                        }
                                        break;
                                    }

                                    default:
                                        //
                                        // Shouldn't hit this.
                                        //
                                        DBGERROR((TEXT("Invalid connection point ID")));
                                        break;
                                }
                            }
                            catch(CAllocException& e)
                            {
                                //
                                // Ignore an allocation exception and try to continue.
                                //
                            }
                        }
                        pEventSink->Release();
                    }
                    cd.pUnk->Release();
                }
                pEnum->Release();
            }
            pConnPt->Release();
        }
    }
    return hr;
}


DiskQuotaControlDisp::DiskQuotaControlDisp(
    PDISKQUOTA_CONTROL pQC
    ) : m_cRef(0),
        m_pQC(pQC),
        m_pUserEnum(NULL)
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControlDisp::DiskQuotaControlDisp")));

    if (NULL != m_pQC)
    {
        m_pQC->AddRef();
    }

    //
    // This is the default resolution style for OLE automation.
    // I've used ASYNC as the default so it won't hang the caller
    // on enumeration if many of the names aren't resolved.
    // If they want sync resolution, they can set the 
    // UserNameResolution property.
    //
    m_fOleAutoNameResolution = DISKQUOTA_USERNAME_RESOLVE_ASYNC;

    m_Dispatch.Initialize(static_cast<IDispatch *>(this),
                          LIBID_DiskQuotaTypeLibrary,
                          IID_DIDiskQuotaControl,
                          L"DSKQUOTA.DLL");
}

DiskQuotaControlDisp::~DiskQuotaControlDisp(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControlDisp::~DiskQuotaControlDisp")));

    if (NULL != m_pUserEnum)
    {
        m_pUserEnum->Release();
    }
    if (NULL != m_pQC)
    {
        m_pQC->Release();
    }
}


STDMETHODIMP_(ULONG) 
DiskQuotaControlDisp::AddRef(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControlDisp::AddRef")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
                     this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


STDMETHODIMP_(ULONG) 
DiskQuotaControlDisp::Release(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControlDisp::Release")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
                     this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



STDMETHODIMP 
DiskQuotaControlDisp::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControlDisp::QueryInterface")));
    DBGPRINTIID(DM_CONTROL, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid)
    {
        *ppvOut = this;
    }
    else if (IID_IDispatch == riid)
    {
        *ppvOut = static_cast<IDispatch *>(this);
    }
    else if (IID_DIDiskQuotaControl == riid)
    {
        *ppvOut = static_cast<DIDiskQuotaControl *>(this);
    }
    else if (IID_IDiskQuotaControl == riid ||
             IID_IConnectionPointContainer == riid)
    {
        //
        // Return the quota controller's vtable interface.
        // This allows code to "typecast" (COM-style) between
        // the dispatch interface and vtable interface.
        //
        return m_pQC->QueryInterface(riid, ppvOut);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}

//
// IDispatch::GetIDsOfNames
//
STDMETHODIMP
DiskQuotaControlDisp::GetIDsOfNames(
    REFIID riid,  
    OLECHAR **rgszNames,  
    UINT cNames,  
    LCID lcid,  
    DISPID *rgDispId
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::GetIDsOfNames")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetIDsOfNames(riid,
                                    rgszNames,
                                    cNames,
                                    lcid,
                                    rgDispId);
}


//
// IDispatch::GetTypeInfo
//
STDMETHODIMP
DiskQuotaControlDisp::GetTypeInfo(
    UINT iTInfo,  
    LCID lcid,  
    ITypeInfo **ppTypeInfo
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::GetTypeInfo")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfo(iTInfo, lcid, ppTypeInfo);
}


//
// IDispatch::GetTypeInfoCount
//
STDMETHODIMP
DiskQuotaControlDisp::GetTypeInfoCount(
    UINT *pctinfo
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::GetTypeInfoCount")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfoCount(pctinfo);
}


//
// IDispatch::Invoke
//
STDMETHODIMP
DiskQuotaControlDisp::Invoke(
    DISPID dispIdMember,  
    REFIID riid,  
    LCID lcid,  
    WORD wFlags,  
    DISPPARAMS *pDispParams,  
    VARIANT *pVarResult,  
    EXCEPINFO *pExcepInfo,  
    UINT *puArgErr
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::Invoke")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.Invoke(dispIdMember,
                             riid,
                             lcid,
                             wFlags,
                             pDispParams,
                             pVarResult,
                             pExcepInfo,
                             puArgErr);
}

//
// Dispatch property "QuotaState" (put)
//
// Sets the state of the quota system on the volume.
// See DiskQuotaControl::SetQuotaState for details.
//
// Valid states:    0 = Disabled.
//                  1 = Tracking
//                  2 = Enforcing
STDMETHODIMP 
DiskQuotaControlDisp::put_QuotaState(
    QuotaStateConstants State
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::put_QuotaState")));
    if (dqStateMaxValue < State)
    {
        //
        // State can only be 0, 1 or 2.
        //
        return E_INVALIDARG;
    }
    //
    // No exception handling required.
    // DiskQuotaControl::SetQuotaState handles exceptions.
    //
    return m_pQC->SetQuotaState(State);
}

//
// Dispatch property "QuotaState" (get)
//
// Retrieves the state of the quota system on the volume.
// See DiskQuotaControl::GetQuotaState for details.
//
// State returned:  0 = Disabled.
//                  1 = Tracking
//                  2 = Enforcing
//
STDMETHODIMP 
DiskQuotaControlDisp::get_QuotaState(
    QuotaStateConstants *pState
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_QuotaState")));
    DWORD dwState;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaState handles exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaState(&dwState);
    if (SUCCEEDED(hr))
    {
        *pState = (QuotaStateConstants)(dwState & DISKQUOTA_STATE_MASK);
    }
    return hr;
}


//
// Dispatch property "QuotaFileIncomplete" (get)
//
// Determines if the state of the quota file is "incomplete".
//
STDMETHODIMP 
DiskQuotaControlDisp::get_QuotaFileIncomplete(
    VARIANT_BOOL *pbIncomplete
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_QuotaFileIncomplete")));
    DWORD dwState;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaState handles exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaState(&dwState);
    if (SUCCEEDED(hr))
    {
        *pbIncomplete = DISKQUOTA_FILE_INCOMPLETE(dwState) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;
}


//
// Dispatch property "QuotaFileRebuilding" (get)
//
// Determines if the state of the quota file is "rebuilding".
//
STDMETHODIMP 
DiskQuotaControlDisp::get_QuotaFileRebuilding(
    VARIANT_BOOL *pbRebuilding
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_QuotaFileRebuilding")));
    DWORD dwState;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaState handles exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaState(&dwState);
    if (SUCCEEDED(hr))
    {
        *pbRebuilding = DISKQUOTA_FILE_REBUILDING(dwState) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;
}


//
// Dispatch property "LogQuotaThreshold" (put)
//
// Sets the "log warning threshold" flag on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::put_LogQuotaThreshold(
    VARIANT_BOOL bLog
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::put_LogQuotaThreshold")));
    DWORD dwFlags;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaLogFlags and SetQuotaLogFlags handle 
    // exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaLogFlags(&dwFlags);
    if (SUCCEEDED(hr))
    {
        hr = m_pQC->SetQuotaLogFlags(DISKQUOTA_SET_LOG_USER_THRESHOLD(dwFlags, VARIANT_TRUE == bLog));
    }
    return hr;
}


//
// Dispatch property "LogQuotaThreshold" (get)
//
// Retrieves the "log warning threshold" flag on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::get_LogQuotaThreshold(
    VARIANT_BOOL *pbLog
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_LogQuotaThreshold")));
    DWORD dwFlags;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaLogFlags handles exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaLogFlags(&dwFlags);
    if (SUCCEEDED(hr))
    {
        *pbLog = DISKQUOTA_IS_LOGGED_USER_THRESHOLD(dwFlags) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return hr;
}


//
// Dispatch property "LogQuotaLimit" (put)
//
// Sets the "log quota limit" flag on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::put_LogQuotaLimit(
    VARIANT_BOOL bLog
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::put_LogQuotaLimit")));
    DWORD dwFlags;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaLogFlags handles exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaLogFlags(&dwFlags);
    if (SUCCEEDED(hr))
    {
        hr = m_pQC->SetQuotaLogFlags(DISKQUOTA_SET_LOG_USER_LIMIT(dwFlags, VARIANT_TRUE == bLog));
    }
    return hr;
}


//
// Dispatch property "LogQuotaLimit" (get)
//
// Retrieves the "log quota limit" flag on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::get_LogQuotaLimit(
    VARIANT_BOOL *pbLog
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_LogQuotaLimit")));
    DWORD dwFlags;
    //
    // No exception handling required.
    // DiskQuotaControl::GetQuotaLogFlags handles exceptions.
    //
    HRESULT hr = m_pQC->GetQuotaLogFlags(&dwFlags);
    if (SUCCEEDED(hr))
    {
        *pbLog = DISKQUOTA_IS_LOGGED_USER_LIMIT(dwFlags) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return hr;
}



//
// Dispatch property "DefaultQuotaThreshold" (put)
//
// Sets the default quota threshold on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::put_DefaultQuotaThreshold(
    double Threshold
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::put_DefaultQuotaThreshold")));
 
    if (MAXLONGLONG < Threshold)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
 
    //
    // No exception handling required.
    // DiskQuotaControl::GetDefaultQuotaThreshold handles exceptions.
    //
    return m_pQC->SetDefaultQuotaThreshold((LONGLONG)Threshold);
}


//
// Dispatch property "DefaultQuotaThreshold" (get)
//
// Retrieves the default quota threshold on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::get_DefaultQuotaThreshold(
    double *pThreshold
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_DefaultQuotaThreshold")));
    LONGLONG llTemp;
    //
    // No exception handling required.
    // DiskQuotaControl::GetDefaultQuotaThreshold handles exceptions.
    //
    HRESULT hr = m_pQC->GetDefaultQuotaThreshold(&llTemp);
    if (SUCCEEDED(hr))
    {
        *pThreshold = (double)llTemp;
    }
    return hr;
}


STDMETHODIMP 
DiskQuotaControlDisp::get_DefaultQuotaThresholdText(
    BSTR *pThresholdText
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_DefaultQuotaThresholdText")));
    TCHAR szValue[40];
    HRESULT hr;
    hr = m_pQC->GetDefaultQuotaThresholdText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pThresholdText = SysAllocString(szValue);
        if (NULL == *pThresholdText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

//
// Dispatch property "DefaultQuotaLimit" (put)
//
// Sets the default quota limit on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::put_DefaultQuotaLimit(
    double Limit
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::put_DefaultQuotaLimit")));

    if (MAXLONGLONG < Limit)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // No exception handling required.
    // DiskQuotaControl::SetDefaultQuotaLimit handles exceptions.
    //
    return m_pQC->SetDefaultQuotaLimit((LONGLONG)Limit);
}


//
// Dispatch property "DefaultQuotaLimit" (get)
//
// Retrieves the default quota limit on the volume.
//
STDMETHODIMP 
DiskQuotaControlDisp::get_DefaultQuotaLimit(
    double *pLimit
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_DefaultQuotaLimit")));
    LONGLONG llTemp;
    //
    // No exception handling required.
    // DiskQuotaControl::GetDefaultQuotaLimit handles exceptions.
    //
    HRESULT hr = m_pQC->GetDefaultQuotaLimit(&llTemp);
    if (SUCCEEDED(hr))
    {
        *pLimit = (double)llTemp;
    }
    return hr;
}


STDMETHODIMP 
DiskQuotaControlDisp::get_DefaultQuotaLimitText(
    BSTR *pLimitText
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_DefaultQuotaLimitText")));
    TCHAR szValue[40];
    HRESULT hr = m_pQC->GetDefaultQuotaLimitText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pLimitText = SysAllocString(szValue);
        if (NULL == *pLimitText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}



STDMETHODIMP 
DiskQuotaControlDisp::put_UserNameResolution(
    UserNameResolutionConstants ResolutionType
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::put_UserNameResolution")));
    if (dqResolveMaxValue < ResolutionType)
    {
        return E_INVALIDARG;
    }
    m_fOleAutoNameResolution = (DWORD)ResolutionType;    
    return NOERROR;
}


STDMETHODIMP 
DiskQuotaControlDisp::get_UserNameResolution(
    UserNameResolutionConstants *pResolutionType
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::get_UserNameResolution")));
    if (NULL == pResolutionType)
        return E_INVALIDARG;

    *pResolutionType = (UserNameResolutionConstants)m_fOleAutoNameResolution;
    return NOERROR;
}


//
// Dispatch method "Initialize"
//
// Initializes the quota control object for a given path and
// access mode.  See DiskQuotaControl::Initialize for details.
//
STDMETHODIMP 
DiskQuotaControlDisp::Initialize(
    BSTR path, 
    VARIANT_BOOL bReadWrite
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::Initialize")));
    //
    // No exception handling required.
    // DiskQuotaControl::Initialize handles exceptions.
    //
    return m_pQC->Initialize(reinterpret_cast<LPCWSTR>(path), VARIANT_TRUE == bReadWrite);
}

//
// Dispatch method "AddUser"
//
// Adds new user quota record.
// See DiskQuotaControl::AddUserName for details.
//
STDMETHODIMP
DiskQuotaControlDisp::AddUser(
    BSTR LogonName,
    DIDiskQuotaUser **ppUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::AddUser")));
    //
    // No exception handling required.
    // DiskQuotaControl::AddUserName handles exceptions.
    //
    PDISKQUOTA_USER pUser = NULL;
    HRESULT hr = m_pQC->AddUserName(reinterpret_cast<LPCWSTR>(LogonName),
                                    m_fOleAutoNameResolution,
                                    &pUser);

    if (SUCCEEDED(hr))
    {
        //
        // Retrieve the user object's IDispatch interface.
        //
        hr = pUser->QueryInterface(IID_IDispatch, (LPVOID *)ppUser);
        pUser->Release();
    }
    return hr;
}



//
// Dispatch method "DeleteUser"
//
// Marks a user quota record for deletion.
// See DiskQuotaControl::DeleteUser for details.
//
STDMETHODIMP 
DiskQuotaControlDisp::DeleteUser(
    DIDiskQuotaUser *pUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::DeleteUser")));
    HRESULT hr = E_INVALIDARG;
    if (NULL != pUser)
    {
        //
        // No exception handling required.
        // DiskQuotaControl::DeleteUser handles exceptions.
        //
        PDISKQUOTA_USER pUserToDelete = NULL;
        hr = pUser->QueryInterface(IID_IDiskQuotaUser, (LPVOID *)&pUserToDelete);
        if (SUCCEEDED(hr))
        {
            hr = m_pQC->DeleteUser(pUserToDelete);
            pUserToDelete->Release();
        }
    }
    return hr;
}


//
// Dispatch method "FindUser"
//
// Locates a user quota entry based on the user's name strings.
// Creates a corresponding user object and returns it to the caller.
// See DiskQuotaControl::FindUserName for details.
//
STDMETHODIMP 
DiskQuotaControlDisp::FindUser(
    BSTR LogonName,
    DIDiskQuotaUser **ppUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::FindUser")));

    //
    // No exception handling required.
    // DiskQuotaControl::FindUserName handles exceptions.
    //
    HRESULT hr = NOERROR;
    LPCWSTR pszName = reinterpret_cast<LPCWSTR>(LogonName);
    PSID psid = NULL;
    PDISKQUOTA_USER pUser = NULL;
    if (ConvertStringSidToSid(pszName, &psid))
    {
        hr = m_pQC->FindUserSid(psid,
                                m_fOleAutoNameResolution,
                                &pUser);
        LocalFree(psid);
        psid = NULL;
    }
    else
    {
        hr = m_pQC->FindUserName(pszName, &pUser);
    }
    
    if (SUCCEEDED(hr))
    {
        DBGASSERT((NULL != pUser));
        //
        // Query for the user's IDispatch interface and release the pointer
        // we received from FindUserName.
        //
        hr = pUser->QueryInterface(IID_IDispatch, (LPVOID *)ppUser);
        pUser->Release();
    }
    return hr;
}

//
// Dispatch method "InvalidateSidNameCache"
//
// Invalidates the SID/Name cache.
// See DiskQuotaControl::InvalidateSidNameCache for details.
//
STDMETHODIMP 
DiskQuotaControlDisp::InvalidateSidNameCache(
    void
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::InvalidateSidNameCache")));
    //
    // No exception handling required.
    // DiskQuotaControl::InvalidateSidNameCache handles exceptions.
    //
    return m_pQC->InvalidateSidNameCache();
}

        
//
// Dispatch method "GiveUserNameResolutionPriority"
//
// Promotes a user object to the front of the SID/Name resolver's input queue.
// See DiskQuotaControl::GiveUserNameResolutionPriority.
//
STDMETHODIMP 
DiskQuotaControlDisp::GiveUserNameResolutionPriority(
    DIDiskQuotaUser *pUser
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::GiveUserNameResolutionPriority")));

    HRESULT hr = E_INVALIDARG;
    if (NULL != pUser)
    {
        //
        // No exception handling required.
        // DiskQuotaControl::GiveUserNameResolutionPriority handles exceptions.
        //
        PDISKQUOTA_USER pUserToPromote = NULL;
        hr = pUser->QueryInterface(IID_IDiskQuotaUser, (LPVOID *)&pUserToPromote);
        if (SUCCEEDED(hr))
        {
            hr = m_pQC->GiveUserNameResolutionPriority(pUserToPromote);
            pUserToPromote->Release();
        }
    }
    return hr;
}


//
// This function is called by an automation controller when a new enumerator is
// required.  In particular, Visual Basic calls it when it encounters a
// "for each" loop.  The name "_NewEnum" is hard-wired and can't change.
//
STDMETHODIMP
DiskQuotaControlDisp::_NewEnum(
    IDispatch **ppEnum
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::_NewEnum")));
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppEnum)
    {
        try
        {
            //
            // Create a Collection object using the current settings for
            // name resolution.
            //
            DiskQuotaUserCollection *pCollection = new DiskQuotaUserCollection(m_pQC,
                                                                               m_fOleAutoNameResolution);
            hr = pCollection->Initialize();
            if (SUCCEEDED(hr))
            {
                //
                // The caller of _NewEnum (probably VB) wants the IEnumVARIANT
                // interface.
                //
                hr = pCollection->QueryInterface(IID_IEnumVARIANT, (LPVOID *)ppEnum);
            }
            else
            {
                delete pCollection;
            }
        }
        catch(CAllocException& e)
        {
            DBGERROR((TEXT("Insufficient memory exception")));
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

//
// Shutdown the SID/Name resolver.  Note that this happens automatically
// when the control object is destroyed.
//
STDMETHODIMP
DiskQuotaControlDisp::ShutdownNameResolution(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlDisp::ShutdownNameResolution")));
    return m_pQC->ShutdownNameResolution();
}


//
// Given a logon name in SAM-compatible or UPN format, translate
// the name to the corresponding account's SID.  The returned SID is 
// formatted as a string.
//
STDMETHODIMP 
DiskQuotaControlDisp::TranslateLogonNameToSID(
    BSTR LogonName,
    BSTR *psid
    )
{
    NTDS ntds;
    BYTE sid[MAX_SID_LEN];
    SID_NAME_USE eSidUse;
    DWORD cbSid = ARRAYSIZE(sid);
    
    HRESULT hr = ntds.LookupAccountByName(NULL,
                                          reinterpret_cast<LPCWSTR>(LogonName),
                                          NULL,
                                          NULL,
                                          sid,
                                          &cbSid,
                                          &eSidUse);

    if (SUCCEEDED(hr))
    {
        LPTSTR pszSid = NULL;
        if (ConvertSidToStringSid((PSID)sid, &pszSid))
        {
            *psid = SysAllocString(pszSid);
            if (NULL == *psid)
            {
                hr = E_OUTOFMEMORY;
            }
            LocalFree(pszSid);
            pszSid = NULL;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\connect.h ===
#ifndef __CONNECTION_POINT_STUFF_H
#define __CONNECTION_POINT_STUFF_H
///////////////////////////////////////////////////////////////////////////////
/*  File: connect.h

    Description: Provides declarations required for the quota controller to
        support OLE connection points.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"       // MAX_USERNAME
#endif
#ifndef _INC_DSKQUOTA_OADISP_H
#   include "oadisp.h"     // OleAutoDispatch class.
#endif
#ifndef _INC_DSKQUOTA_DISPATCH_H
#   include "dispatch.h"
#endif

class ConnectionPoint : public IConnectionPoint, public IDispatch
{
    private:
        LONG          m_cRef;           // Class object ref count.
        DWORD         m_cConnections;   // Number of connections.
        DWORD         m_dwCookieNext;   // Next cookie value to hand out.
        LPUNKNOWN     m_pUnkContainer;  // IUnknown of ConnectionPointEnumerator
        REFIID        m_riid;           // Reference to IID supported by conn pt.
        HANDLE        m_hMutex;         
        OleAutoDispatch m_Dispatch;
        CArray<CONNECTDATA> m_ConnectionList;

        void Lock(void)
            { WaitForSingleObject(m_hMutex, INFINITE); }
        void ReleaseLock(void)
            { ReleaseMutex(m_hMutex); }

        //
        // Prevent copying.
        //
        ConnectionPoint(const ConnectionPoint&);
        void operator = (const ConnectionPoint&);


    public:
        ConnectionPoint(LPUNKNOWN pUnkContainer, REFIID riid);
        ~ConnectionPoint(void);


        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IConnectionPoint methods.
        //
        STDMETHODIMP
        GetConnectionInterface(
            LPIID pIID);
   
        STDMETHODIMP
        GetConnectionPointContainer(
            PCONNECTIONPOINTCONTAINER *ppCPC);

        STDMETHODIMP
        Advise(
            LPUNKNOWN pUnkSink,
            LPDWORD pdwCookie);

        STDMETHODIMP
        Unadvise(
            DWORD dwCookie);

        STDMETHODIMP
        EnumConnections(
            PENUMCONNECTIONS *ppEnum);

        //
        // IDispatch methods.
        //
        STDMETHODIMP
        GetIDsOfNames(
            REFIID riid,  
            OLECHAR ** rgszNames,  
            UINT cNames,  
            LCID lcid,  
            DISPID *rgDispId);

        STDMETHODIMP
        GetTypeInfo(
            UINT iTInfo,  
            LCID lcid,  
            ITypeInfo **ppTInfo);

        STDMETHODIMP
        GetTypeInfoCount(
            UINT *pctinfo);

        STDMETHODIMP
        Invoke(
            DISPID dispIdMember,  
            REFIID riid,  
            LCID lcid,  
            WORD wFlags,  
            DISPPARAMS *pDispParams,  
            VARIANT *pVarResult,  
            EXCEPINFO *pExcepInfo,  
            UINT *puArgErr);
};


class ConnectionEnum : public IEnumConnections
{
    private:
        LONG         m_cRef;          // Object ref count.
        UINT         m_iCurrent;      // "Current" enum index.
        UINT         m_cConnections;  // Connection count.
        PCONNECTDATA m_rgConnections; // Array of connection info.
        LPUNKNOWN    m_pUnkContainer; // Connection pt container.

        //
        // Prevent assignment.
        //
        void operator = (const ConnectionEnum&);

    public:
        ConnectionEnum(
            LPUNKNOWN pUnkContainer,
            UINT cConnection, 
            PCONNECTDATA rgConnections);

        ConnectionEnum(
            const ConnectionEnum& refEnum);

        ~ConnectionEnum(void);

        HRESULT 
        Initialize(
            UINT cConnection, 
            PCONNECTDATA rgConnections);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumConnections methods.
        //
        STDMETHODIMP 
        Next(
            DWORD, 
            PCONNECTDATA, 
            LPDWORD);

        STDMETHODIMP 
        Skip(
            DWORD);

        STDMETHODIMP 
        Reset(
            VOID);

        STDMETHODIMP 
        Clone(
            PENUMCONNECTIONS *);
};


class ConnectionPointEnum : public IEnumConnectionPoints 
{
    private:
        LONG         m_cRef;           // Object ref count.
        UINT         m_iCurrent;       // "Current" enum index.
        UINT         m_cConnPts;       // Connection point count.
        PCONNECTIONPOINT *m_rgConnPts; // Array of connection info.
        LPUNKNOWN    m_pUnkContainer;  // IUnknown of DiskQuotaController.

        //
        // Prevent assignment.
        //
        void operator = (const ConnectionPointEnum&);

    public:
        ConnectionPointEnum(
            LPUNKNOWN pUnkContainer,
            UINT cConnPts, 
            PCONNECTIONPOINT *rgConnPts);

        ConnectionPointEnum(
            const ConnectionPointEnum& refEnum);

        ~ConnectionPointEnum(void);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumConnections methods.
        //
        STDMETHODIMP 
        Next(
            DWORD, 
            PCONNECTIONPOINT *, 
            LPDWORD);

        STDMETHODIMP 
        Skip(
            DWORD);

        STDMETHODIMP 
        Reset(
            VOID);

        STDMETHODIMP 
        Clone(
            PENUMCONNECTIONPOINTS *);
};


#endif // CONNECTION_POINT_STUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\dskquota.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: dskquota.cpp

    Description: Contains standard functions for an OLE component server DLL.

                    DllMain
                    DllGetClassObject
                    DllCanUnloadNow

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    12/10/96    Moved to free-threading OLE apartment model.         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#define INITGUIDS  // Define GUIDs.
#include "dskquota.h"
#include "guidsp.h"    // Private GUIDs.
#include <gpedit.h>    // For GUIDs.

#include "factory.h"   // Class factory declarations.
#include "sidcache.h"  // SID/Name cache.
#include "registry.h"
//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


HINSTANCE     g_hInstDll     = NULL;    // DLL instance handle.
LONG          g_cRefThisDll  = 0;       // DLL reference count.
LONG          g_cLockThisDll = 0;       // DLL lock count.


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllGetClassObject

    Description: Creates instance of DiskQuotaControlClassFactory.

    Arguments:
        rclsid - Reference to class ID that identifies the type of object that the
            class factory will be asked to create.

        riid - Reference to interface ID on the class factory object.

        ppvOut - Destination location for class factory object pointer after 
            instantiation.

    Returns:
        NOERROR                   - Success.
        E_OUTOFMEMORY             - Can't create class factory object.
        E_NOINTERFACE             - Interface not supported.
        E_INVALIDARG              - ppvOut arg is NULL.
        CLASS_E_CLASSNOTAVAILABLE - Class factory not available.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllGetClassObject(
    REFCLSID rclsid, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllGetClassObject")));
    DBGPRINTIID(DM_COM, DL_HIGH, (REFIID)rclsid);
    DBGPRINTIID(DM_COM, DL_HIGH, riid);

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (IsEqualIID(rclsid, CLSID_DiskQuotaControl))
        {
            DiskQuotaControlClassFactory *pClassFactory = NULL;

            pClassFactory = new DiskQuotaControlClassFactory;
            hr = pClassFactory->QueryInterface(riid, ppvOut);
            if (FAILED(hr))
            {
                delete pClassFactory;
            }
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllCanUnloadNow

    Description: Called by OLE to determine if DLL can be unloaded.

    Arguments: None.

    Returns:
        S_FALSE     - Can't unload.  Ref count or lock count are > 0.
        S_OK        - OK to unload. Ref count and lock count are 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllCanUnloadNow(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllCanUnloadNow")));
    DBGPRINT((DM_COM, DL_HIGH, TEXT("\tRefCnt = %d  LockCnt = %d"),
              g_cRefThisDll, g_cLockThisDll));

#ifdef DEBUG_PROCESS_DETACH
    //
    // This code will force the DLL to be unloaded so that we can 
    // test OnProcessDetach().  Otherwise, OLE will wait 10 minutes
    // after DllCanUnloadNow returns S_OK to call FreeLibrary.
    // Note however that the process will AV when OLE finally gets
    // around to freeing the library.  Therefore, we don't leave
    // this code active in free or check builds; only private debug
    // builds.  Must explicitly define DEBUG_PROCESS_DETACH.
    //
    if (0 == g_cRefThisDll && 0 == g_cLockThisDll)
    {
        HINSTANCE hMod;
        static INT iExeThisPath = 0;
        
        if (0 == iExeThisPath++)
        {
            hMod = LoadLibrary(TEXT("dskquota.dll"));
            if (NULL != hMod)
            {
                DBGASSERT((g_hInstDll == hMod));
                FreeLibrary(hMod);
                FreeLibrary(hMod);
            }
        }
    }
#endif // DEBUG_PROCESS_DETACH

    return (0 == g_cRefThisDll && 0 == g_cLockThisDll) ? S_OK : S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllRegisterServer

    Description: Create the necessary registry entries for dskquota.dll
        to operate properly.  This is called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to create one of the registry entries.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllRegisterServer(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllRegisterServer")));
    HRESULT hr = CallRegInstall(g_hInstDll, "RegDll");

    if (FAILED(hr))
    {
        hr = SELFREG_E_CLASS;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllUnregisterServer

    Description: Remove the necessary registry entries for dskquota.dll.
        This is called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to remove the CLSID entry.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllUnregisterServer(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllUnregisterServer")));
    HRESULT hr = CallRegInstall(g_hInstDll, "UnregDll");

    if (FAILED(hr))
    {
        hr = SELFREG_E_CLASS;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessAttach

    Description: Handles all tasks associated with a process attaching to 
        the DLL.

        Try to keep processing time to a minimum.

    Arguments:
        hInstDll - The DLL instance handle passed to DllMain.

    Returns:
        NOERROR    - Success.
        E_FAIL     - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessAttach(
    HINSTANCE hInstDll
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("OnProcessAttach")));
    HRESULT hr = NOERROR;

    //
    // Start IceCAP profiling.
    //
    ICAP_START_ALL;

#if DBG
    DBGMODULE(TEXT("DSKQUOTA"));  // Name of module displayed with messages.
    RegKey key(HKEY_LOCAL_MACHINE, REGSTR_KEY_DISKQUOTA);
    if (SUCCEEDED(key.Open(KEY_READ)))
    {
        DebugRegParams dp;
        if (SUCCEEDED(key.GetValue(REGSTR_VAL_DEBUGPARAMS, (LPBYTE)&dp, sizeof(dp))))
        {
            DBGPRINTMASK(dp.PrintMask);
            DBGPRINTLEVEL(dp.PrintLevel);
            DBGPRINTVERBOSE(dp.PrintVerbose);
            DBGTRACEMASK(dp.TraceMask);
            DBGTRACELEVEL(dp.TraceLevel);
            DBGTRACEVERBOSE(dp.TraceVerbose);
            DBGTRACEONEXIT(dp.TraceOnExit);
        }
    }
#endif // DBG

    g_hInstDll = hInstDll;
    DisableThreadLibraryCalls(hInstDll);

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessDetach

    Description: Handles all tasks associated with a process detaching from 
        the DLL.

    Arguments: None.

    Returns:
        NOERROR    - Success.
 
    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessDetach(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("OnProcessAttach")));

    HRESULT hr = NOERROR;

#ifdef DEBUG_PROCESS_DETACH
    LoadLibrary(TEXT("dskquota.dll"));
#endif

    SidNameCache_Destroy();

    //
    // Stop IceCAP profiling.
    //
    ICAP_STOP_ALL;

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllMain

    Description: Main entry point for OLE component server.

    Arguments:
        hInstDll - Instance handle of DLL

        fdwReason - Reason DllMain is being called.  Can be at Process attach/
            detach or Thread attach/detach.

        lpdwReserved - Reserved.

    Returns:
        TRUE    - Successful initialization.
        FALSE   - Failed initialization.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/09/96    Moved code associated with process attach and        BrianAu
                detach out to separate functions.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI 
DllMain(
    HINSTANCE hInstDll, 
    DWORD fdwReason, 
    LPVOID lpvReserved
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllMain")));
    BOOL bResult = FALSE;

    switch(fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DLL_PROCESS_ATTACH")));
            bResult = SUCCEEDED(OnProcessAttach(hInstDll));
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bResult = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DLL_PROCESS_DETACH")));
            bResult = SUCCEEDED(OnProcessDetach());
            break;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\factory.h ===
#ifndef _INC_DSKQUOTA_FACTORY_H
#define _INC_DSKQUOTA_FACTORY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: factory.h

    Description: Contains declaration for the class factory object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
    08/20/97    Added IDispatch support.                             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

class DiskQuotaControlClassFactory : public IClassFactory
{
    private:
        LONG m_cRef;

        HRESULT Create_IDiskQuotaControl(REFIID riid, LPVOID *ppvOut);

        //
        // Prevent copying.
        //
        DiskQuotaControlClassFactory(const DiskQuotaControlClassFactory&);
        void operator = (const DiskQuotaControlClassFactory&);

    public:
        DiskQuotaControlClassFactory(void)
            : m_cRef(0) 
            { DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControlClassFactory::DiskQuotaControlClassFactory"))); }

        //
        // IUnknown methods
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IClassFactory methods
        //
        STDMETHODIMP 
        CreateInstance(
            LPUNKNOWN pUnkOuter, 
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP 
        LockServer(
            BOOL fLock);
};



#endif // _INC_DSKQUOTA_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\fsobject.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: fsobject.cpp

    Description: Contains member function definitions for class FSObject and
        it's derived subclasses.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "dskquota.h"
#include "fsobject.h"
#include "pathstr.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


///////////////////////////////////////////////////////////////////////////////
/*  Function: FSObject::~FSObject

    Description: Destructor.  Frees object's name buffer.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
FSObject::~FSObject(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSObject::~FSObject")));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: FSObject::AddRef

    Description: Increments object reference count.
        Note this is not a member of IUnknown; but it works the same.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ULONG
FSObject::AddRef(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("FSObject::AddRef")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
             this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: FSObject::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.  Note this is not a member of IUnknown; but it
        works the same.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ULONG
FSObject::Release(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("FSObject::Release")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
             this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: FSObject::ObjectSupportsQuotas

    Description: Determine a file system object's type (and locality) from
        it's name string.

    Arguments:
        pszFSObjName - Volume root name. (i.e. "C:\", "\\scratch\scratch").

    Returns:
        S_OK                     - Success.  Supports quotas.
        ERROR_NOT_SUPPORTED (hr) - File system doesn't support quotas.
        Other win32 error        - Couldn't get volume information.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
    08/16/96    Added pSupportsQuotas.                               BrianAu
    12/05/96    Disabled check for $DeadMeat volume label.           BrianAu
                Leave the code in place for a while.  I'll remove
                it later when we're sure it's not needed.
    07/03/97    Changed name from ObjectTypeFromName.                BrianAu
                Changed logic to indicate reason for not supporting
                quotas.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
FSObject::ObjectSupportsQuotas(
    LPCTSTR pszFSObjName
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSObject::ObjectSupportsQuotas")));
    DBGPRINT((DM_CONTROL, DL_MID, TEXT("\tobject = \"%s\""), pszFSObjName ? pszFSObjName : TEXT("<null>")));

    HRESULT hr = E_FAIL;
    DWORD dwFileSysFlags = 0;
    TCHAR szFileSysName[MAX_PATH];

    DBGASSERT((NULL != pszFSObjName));

    if (GetVolumeInformation(
                pszFSObjName,
                NULL, 0,
                NULL, 0,
                &dwFileSysFlags,
                szFileSysName,
                ARRAYSIZE(szFileSysName)))
    {
        //
        // Does the file system support quotas?
        //
        if (0 != (dwFileSysFlags & FILE_VOLUME_QUOTAS))
        {
            //
            // Yes, it does.
            //
            hr = S_OK;
            DBGPRINT((DM_CONTROL, DL_LOW, TEXT("Vol \"%s\" supports quotas"), pszFSObjName));
        }
        else
        {
            //
            // Doesn't support quotas.
            //
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            DBGPRINT((DM_CONTROL, DL_HIGH, TEXT("File system \"%s\" on \"%s\" doesn't support quotas."),
                     szFileSysName, pszFSObjName));
        }
    }
    else
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        DBGERROR((TEXT("Error %d calling GetVolumeInformation for \"%s\""), dwErr, pszFSObjName));
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: FSObject::Create

    Description: 2 overloaded functions.
        Static functions for creating a File System object of the
        proper type.  Clients call Create with an object name string or
        a reference to an existing FSObject instance.

    Arguments:
        pszFSObjName - Address of volume root string.

        ppNewObject - Address of FSObject pointer to accept the address of the
            new file system object.

        ObjToClone - Reference to file system object to be cloned.

    Returns:
        NOERROR                   - Success.
        E_OUTOFMEMORY             - Insufficient memory.
        ERROR_ACCESS_DENIED (hr)  - Insufficient access to open device.
        ERROR_FILE_NOT_FOUND (hr) - Disk device not found.
        ERROR_INVALID_NAME (hr)   - Object name is invalid.
        ERROR_NOT_SUPPORTED (hr)  - Volume doesn't support quotas.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
FSObject::Create(
    LPCTSTR pszFSObjName,
    DWORD dwAccess,
    FSObject **ppNewObject
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSObject::Create")));
    DBGPRINT((DM_CONTROL, DL_MID, TEXT("\tVol = \"%s\""), pszFSObjName ? pszFSObjName : TEXT("<null>")));
    HRESULT hr = NOERROR;

    DBGASSERT((NULL != pszFSObjName));
    DBGASSERT((NULL != ppNewObject));

    *ppNewObject = NULL;

    FSObject *pNewObject = NULL;

    try
    {
        hr = FSObject::ObjectSupportsQuotas(pszFSObjName);
        if (SUCCEEDED(hr))
        {
            hr = FSObject_CreateLocalVolume(pszFSObjName, &pNewObject);
            if (SUCCEEDED(hr))
            {
                //
                // Do any subclass-specific initialization.
                // i.e.:  Volume opens the volume device.
                //
                hr = pNewObject->Initialize(dwAccess);

                if (SUCCEEDED(hr))
                {
                    //
                    // Return ptr to caller.
                    //
                    DBGPRINT((DM_CONTROL, DL_MID, TEXT("FSObject created")));
                    pNewObject->AddRef();
                    *ppNewObject = pNewObject;
                }
                else
                {
                    DBGPRINT((DM_CONTROL, DL_MID, TEXT("FSObject create FAILED with error 0x%08X"), hr));
                    delete pNewObject;
                    pNewObject = NULL;
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        delete pNewObject;  // Will also free name if necessary.
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//
// Version to clone an existing FSObject.
//
HRESULT
FSObject::Create(
    const FSObject& ObjectToClone,
    FSObject **ppNewObject
    )
{
    return FSObject::Create(ObjectToClone.m_strFSObjName,
                            ObjectToClone.m_dwAccessRights,
                            ppNewObject);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: FSObject::GetName

    Description: Retrieves the file system object's name string.

    Arguments:
        pszBuffer - Address of buffer to accept name string.

        cchBuffer - Size of destination buffer in characters.

    Returns:
        NOERROR                   - Success.
        ERROR_INSUFFICIENT_BUFFER - Destination buffer is too small for name.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT FSObject::GetName(LPTSTR pszBuffer, ULONG cchBuffer) const
{
    HRESULT hr = NOERROR;

    DBGASSERT((NULL != pszBuffer));
    if ((ULONG)m_strFSObjName.Length() < cchBuffer)
        lstrcpyn(pszBuffer, m_strFSObjName, cchBuffer);
    else
    {
        *pszBuffer = TEXT('\0');
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}


//
// This function was created to fix bug 365936.
// Class FSObject has a CPath member who's constructor
// can throw CAllocException.  Because of this, we
// need to isolate this construction operation from 
// other FSObject code so that we don't try to delete 
// an FSObject object that has already been destroyed
// by the constructor's call stack unwinding process.
// 
HRESULT 
FSObject_CreateLocalVolume(
    LPCTSTR pszVolumeName,
    FSObject **ppObject
    )
{
    HRESULT hr = S_OK;
    
    *ppObject = NULL;
   
    try
    {
        FSObject *pNewObject = new FSLocalVolume(pszVolumeName);
        *ppObject = pNewObject;
    }
    catch(CAllocException& e)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: FSVolume::~FSVolume

    Description: Destructor. Closes volume handle.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
FSVolume::~FSVolume(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::~FSVolume")));
    if (INVALID_HANDLE_VALUE != m_hVolume)
        CloseHandle(m_hVolume);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: FSVolume::Initialize

    Description: Initializes a volume object by opening the NTFS volume.

    Arguments:
        dwAccess - Desired access.  GENERIC_READ, GENERIC_WRITE.

    Returns:
        NOERROR              - Success.
        ERROR_ACCESS_DENIED (hr) - Insufficient access to open device.
        ERROR_FILE_NOT_FOUND (hr) - Disk device not found.
        ERROR_INVALID_NAME (hr) - Invalid path string.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
    08/11/96    Added access right handling.                         BrianAu
    08/16/96    Added device name formatting.                        BrianAu
    07/03/97    Changed so caller passes in desired access.          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT FSVolume::Initialize(
    DWORD dwAccess
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::Initialize")));
    DBGPRINT((DM_CONTROL, DL_MID, TEXT("\tdwAccess = 0x%08X"), dwAccess));

    HRESULT hr = NOERROR;

    //
    // Close the device if it's open.
    //
    if (INVALID_HANDLE_VALUE != m_hVolume)
        CloseHandle(m_hVolume);

    //
    // Create a path to the actual quota file on the volume.
    // This string is appended to the existing "volume name" we already
    // have.
    //
    CPath strQuotaFile(m_strFSObjName);
    strQuotaFile.AddBackslash();
    strQuotaFile += CString("$Extend\\$Quota:$Q:$INDEX_ALLOCATION");

    m_hVolume = CreateFile(strQuotaFile,
                           dwAccess,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS,
                           NULL);

    if (INVALID_HANDLE_VALUE == m_hVolume)
    {
        //
        // Couldn't open device because...
        // 1. I/O error
        // 2. File (device) not found.
        // 3. Access denied.
        //
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        DBGERROR((TEXT("Error %d opening quota file \"%s\""), dwErr, strQuotaFile.Cstr()));
    }
    else
    {
        //
        // Save access granted to caller.  Will be used to validate
        // operation requests later.
        //
        DBGPRINT((DM_CONTROL, DL_MID, TEXT("Quota file \"%s\" open with access 0x%08X"), strQuotaFile.Cstr(), dwAccess));
        m_dwAccessRights = dwAccess;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: FSVolume::QueryObjectQuotaInformation

    Description: Retrieves quota information for the volume.  This includes
        default quota threshold, default quota limit and system control flags.

    Arguments:
        poi - Address of object information buffer.  This type contains
            a subset of the information in FILE_FS_CONTROL_INFORMATION
            (defined in ntioapi.h).

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        Other                    - NTFS subsystem failure result.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
FSVolume::QueryObjectQuotaInformation(
    PDISKQUOTA_FSOBJECT_INFORMATION poi
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::QueryObjectQuotaInformation")));
    HRESULT hr = E_FAIL;

    if (!GrantedAccess(GENERIC_READ))
    {
        DBGPRINT((DM_CONTROL, DL_MID, TEXT("Access denied reading quota info")));
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        NTSTATUS status = STATUS_SUCCESS;
        IO_STATUS_BLOCK iosb;
        FILE_FS_CONTROL_INFORMATION ControlInfo;

        status = NtQueryVolumeInformationFile(
                    m_hVolume,
                    &iosb,
                    &ControlInfo,
                    sizeof(ControlInfo),
                    FileFsControlInformation);

        if (STATUS_SUCCESS == status)
        {
            //
            // Update caller's buffer with quota control data.
            //
            poi->DefaultQuotaThreshold  = ControlInfo.DefaultQuotaThreshold.QuadPart;
            poi->DefaultQuotaLimit      = ControlInfo.DefaultQuotaLimit.QuadPart;
            poi->FileSystemControlFlags = ControlInfo.FileSystemControlFlags;
            hr = NOERROR;
        }
        else
        {
            DBGERROR((TEXT("NtQueryVolumeInformationFile failed with NTSTATUS 0x%08X"), status));
            hr = HResultFromNtStatus(status);
        }
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: FSVolume::SetObjectQuotaInformation

    Description: Writes new quota information to the volume.  This includes
        default quota threshold, default quota limit and system control flags.

    Arguments:
        poi - Address of object information buffer.  This type contains
            a subset of the information in FILE_FS_CONTROL_INFORMATION
            (defined in ntioapi.h).

        dwChangeMask - Mask specifying which elements in *poi to write to disk.
            Can be any combination of:
                FSObject::ChangeState
                FSObject::ChangeLogFlags
                FSObject::ChangeThreshold
                FSObject::ChangeLimit

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        Other                    - NTFS subsystem failure result.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
FSVolume::SetObjectQuotaInformation(
    PDISKQUOTA_FSOBJECT_INFORMATION poi,
    DWORD dwChangeMask
    ) const
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::SetObjectQuotaInformation")));
    HRESULT hr = E_FAIL;

    if (!GrantedAccess(GENERIC_WRITE))
    {
        DBGPRINT((DM_CONTROL, DL_MID, TEXT("Access denied setting quota info")));
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        NTSTATUS status = STATUS_SUCCESS;
        IO_STATUS_BLOCK iosb;
        FILE_FS_CONTROL_INFORMATION ControlInfo;

        //
        // First read current info from disk.
        // Then replace whatever we're changing.
        //
        status = NtQueryVolumeInformationFile(
                    m_hVolume,
                    &iosb,
                    &ControlInfo,
                    sizeof(ControlInfo),
                    FileFsControlInformation);

        if (STATUS_SUCCESS == status)
        {
            //
            // Only alter those values specified in dwChangeMask.
            //
            if (FSObject::ChangeState & dwChangeMask)
            {
                ControlInfo.FileSystemControlFlags &= ~DISKQUOTA_STATE_MASK;
                ControlInfo.FileSystemControlFlags |= (poi->FileSystemControlFlags & DISKQUOTA_STATE_MASK);
            }
            if (FSObject::ChangeLogFlags & dwChangeMask)
            {
                ControlInfo.FileSystemControlFlags &= ~DISKQUOTA_LOGFLAG_MASK;
                ControlInfo.FileSystemControlFlags |= (poi->FileSystemControlFlags & DISKQUOTA_LOGFLAG_MASK);
            }
            if (FSObject::ChangeThreshold & dwChangeMask)
            {
                ControlInfo.DefaultQuotaThreshold.QuadPart = poi->DefaultQuotaThreshold;
            }
            if (FSObject::ChangeLimit & dwChangeMask)
            {
                ControlInfo.DefaultQuotaLimit.QuadPart = poi->DefaultQuotaLimit;
            }

            status = NtSetVolumeInformationFile(
                        m_hVolume,
                        &iosb,
                        &ControlInfo,
                        sizeof(ControlInfo),
                        FileFsControlInformation);

            if (STATUS_SUCCESS == status)
            {
                hr = NOERROR;
            }
            else
            {
                DBGERROR((TEXT("NtSetVolumeInformationFile failed with NTSTATUS = 0x%08X"), status));
                hr = HResultFromNtStatus(status);
            }
        }
        else
        {
            DBGERROR((TEXT("NtQueryVolumeInformationFile failed with NTSTATUS = 0x%08X"), status));
            hr = HResultFromNtStatus(status);
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: FSVolume::QueryUserQuotaInformation

    Description: Retrieves user quota information for the volume.  This includes
        quota threshold and quota limit.  This function works like an enumerator.
        Repeated calls will return multiple user records.

    Arguments:
        pBuffer - Address of buffer to receive quota information.

        cbBuffer - Number of bytes in buffer.

        bReturnSingleEntry - TRUE  = Return only one record from quota file.
                             FALSE = Return as many whole entries as possible
                                     in buffer.

        pSidList [optional] - Address of SID list identifying users to obtain
            information for.  Specify NULL to include all users.

        cbSidList [optional] - Number of bytes in sid list.  Ignored if pSidList
            is NULL.

        pStartSid [optional] - Address of SID identifying which user is to start
            the enumeration.  Specify NULL to start with current user in
            enumeration.

        bRestartScan - TRUE = restart scan from first user in the SID list or
            the entire file if pSidList is NULL.
            FALSE = Continue enumeration from current user record.

    Returns:
        NOERROR                  - Success.
        ERROR_NO_MORE_ITEMS      - Read last entry in quota file.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        Other                    - Quota subsystem error.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
FSVolume::QueryUserQuotaInformation(
    PVOID pBuffer,
    ULONG cbBuffer,
    BOOL bReturnSingleEntry,
    PVOID pSidList,
    ULONG cbSidList,
    PSID  pStartSid,
    BOOL  bRestartScan
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::QueryUserQuotaInformation")));
    HRESULT hr = E_FAIL;

    DBGASSERT((NULL != pBuffer));

    if (!GrantedAccess(GENERIC_READ))
    {
        DBGPRINT((DM_CONTROL, DL_MID, TEXT("Access denied querying user quota info")));
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        NTSTATUS status = STATUS_SUCCESS;
        IO_STATUS_BLOCK iosb;

        status = NtQueryQuotaInformationFile(
                    m_hVolume,
                    &iosb,
                    pBuffer,
                    cbBuffer,
                    (BOOLEAN)bReturnSingleEntry,
                    pSidList,
                    cbSidList,
                    pStartSid,
                    (BOOLEAN)bRestartScan);

        switch(status)
        {
            case STATUS_SUCCESS:
                hr = NOERROR;
                break;

            default:
                DBGERROR((TEXT("NtQueryQuotaInformationFile failed with NTSTATUS 0x%08X"), status));
                //
                // Fall through...
                //
            case STATUS_NO_MORE_ENTRIES:
                hr = HResultFromNtStatus(status);
                break;
        }
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: FSVolume::SetUserQuotaInformation

    Description: Writes new user quota information to the volume.  This includes
        quota threshold, and quota limit.

    Arguments:
        pBuffer - Address of buffer containing quota information.

        cbBuffer - Number of bytes of data in buffer.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
                                   Or tried to set limit on Administrator.
        Other                    - Quota subsystem error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/24/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
FSVolume::SetUserQuotaInformation(
    PVOID pBuffer,
    ULONG cbBuffer
    ) const
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::SetUserQuotaInformation")));

    HRESULT hr = NOERROR;

    DBGASSERT((NULL != pBuffer));

    if (!GrantedAccess(GENERIC_WRITE))
    {
        DBGPRINT((DM_CONTROL, DL_MID, TEXT("Access denied setting user quota info")));
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        NTSTATUS status = STATUS_SUCCESS;
        IO_STATUS_BLOCK iosb;

        status = NtSetQuotaInformationFile(
                    m_hVolume,
                    &iosb,
                    pBuffer,
                    cbBuffer);

        if (STATUS_SUCCESS == status)
        {
            hr = NOERROR;
        }
        else
        {
            DBGERROR((TEXT("NtSetQuotaInformationFile failed with NTSTATUS 0x%08X"), status));
            hr = HResultFromNtStatus(status);
        }
    }
    return hr;
}


//
// Convert an NTSTATUS value to an HRESULT.
// This is a simple attempt at converting the most common NTSTATUS values that
// might be returned from NtQueryxxxxx and NTSetxxxxxx functions.  If I've missed
// some obvious ones, go ahead and add them.
//
HRESULT
FSObject::HResultFromNtStatus(
    NTSTATUS status
    )
{
    HRESULT hr = E_FAIL;  // Default if none matched.

    static const struct
    {
        NTSTATUS status;
        HRESULT hr;
    } rgXref[] = {

       { STATUS_SUCCESS,                NOERROR                                        },
       { STATUS_INVALID_PARAMETER,      E_INVALIDARG                                   },
       { STATUS_NO_MORE_ENTRIES,        HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)        },
       { STATUS_ACCESS_DENIED,          HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)        },
       { STATUS_BUFFER_TOO_SMALL,       HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)  },
       { STATUS_BUFFER_OVERFLOW,        HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW)      },
       { STATUS_INVALID_HANDLE,         HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)       },
       { STATUS_INVALID_DEVICE_REQUEST, HRESULT_FROM_WIN32(ERROR_BAD_DEVICE)           },
       { STATUS_FILE_INVALID,           HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_AVAILABLE) }};

    for (int i = 0; i < ARRAYSIZE(rgXref); i++)
    {
        if (rgXref[i].status == status)
        {
            hr = rgXref[i].hr;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\factory.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: factory.cpp

    Description: Contains the member function definitions for class
        DiskQuotaControlClassFactory.  The class factory object generates
        new instances of DiskQuotaControl objects.  The object implements
        IClassFactory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "dskquota.h"
#include "control.h"
#include "factory.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


extern LONG g_cLockThisDll;  // Supports LockServer().


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControlClassFactory::QueryInterface

    Description: Retrieves a pointer to the IUnknown or IClassFactory 
        interface.  Recoginizes the IID_IUnknown and IID_IClassFactory
        interface IDs.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added IShellPropSheetExt                             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControlClassFactory::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControlClassFactory::QueryInterface")));
    DBGPRINTIID(DM_CONTROL, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid || IID_IClassFactory == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControlClassFactory::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaControlClassFactory::AddRef(
   VOID
   )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControlClassFactory::AddRef")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
                     this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControlClassFactory::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaControlClassFactory::Release(
    VOID
    )
{
    DBGTRACE((DM_CONTROL, DL_LOW, TEXT("DiskQuotaControlClassFactory::Release")));
    DBGPRINT((DM_CONTROL, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
                     this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControlClassFactory::CreateInstance

    Description: Creates a new instance of a DiskQuotaControl object, returning
        a pointer to its IDiskQuotaControl interface.

    Arguments:
        pUnkOuter - Pointer to outer object's IUnknown interface for IUnknown
            delegation in support of aggregation.  Aggregation is not supported
            by IDiskQuotaControl.

        riid - Reference to interface ID being requested.

        ppvOut - Address of interface pointer variable to accept interface
            pointer.

    Returns:
        NOERROR               - Success.
        E_OUTOFMEMORY         - Insufficient memory to create new object.
        E_NOINTERFACE         - Requested interface not supported.
        E_INVALIDARG          - ppvOut arg was NULL.
        CLASS_E_NOAGGREGATION - Aggregation was requested but is not supported.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
    08/20/97    Added IDispatch support.                             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControlClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlClassFactory::CreateInstance")));
    DBGPRINTIID(DM_CONTROL, DL_HIGH, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (NULL != pUnkOuter && IID_IUnknown != riid)
        {
            hr = CLASS_E_NOAGGREGATION;
        }
        else if (IID_IClassFactory == riid)
        {
            *ppvOut = this;
            ((LPUNKNOWN)*ppvOut)->AddRef();
            hr = NOERROR;
        }
        else if (IID_IDiskQuotaControl == riid ||
                 IID_IDispatch == riid ||
                 IID_IUnknown == riid)
        {
            hr = Create_IDiskQuotaControl(riid, ppvOut);
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControlClassFactory::LockServer

    Description: Places/removes a lock on the DLL server.  See OLE 2
        documentation of IClassFactory for details.
        
    Arguments:
        fLock - TRUE = Increment lock count, FALSE = Decrement lock count.

    Returns:
        S_OK    - Success.
        S_FALSE - Lock count is already 0.  Can't be decremented.
        

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaControlClassFactory::LockServer(
    BOOL fLock
    )
{
    DBGTRACE((DM_CONTROL, DL_HIGH, TEXT("DiskQuotaControlClassFactory::LockServer")));
    HRESULT hr = S_OK;

    if (fLock)
    {
        //
        // Increment the lock count.
        //
        InterlockedIncrement(&g_cLockThisDll);
    }
    else
    {
        //
        // Decrement only if lock count is > 0.
        // Otherwise, it's an error.
        //
        LONG lLock = g_cLockThisDll - 1;
        if (0 <= lLock)
        {
            InterlockedDecrement(&g_cLockThisDll);
        }
        else
            hr = S_FALSE;  // Lock count already at 0.
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaControlClassFactory::Create_IDiskQuotaControl

    Description: Creates a DiskQuotaControl object and returns a pointer
        to it's IDiskQuotaControl interface.

    Arguments:
        ppvOut - Address of interface pointer variable to receive the interface
            pointer.

        riid - Reference to interface ID requested.

    Returns:
        NOERROR        - Success.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
                Broke code out of CreateInstance().
    08/20/97    Added riid argument.                                 BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaControlClassFactory::Create_IDiskQuotaControl(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("DiskQuotaControlClassFactory::Create_IDiskQuotaControl")));
    DBGASSERT((NULL != ppvOut));

    HRESULT hr = NOERROR;
    DiskQuotaControl *pController = new DiskQuotaControl;

    hr = pController->QueryInterface(riid, ppvOut);

    if (FAILED(hr))
    {
        delete pController;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\pch.h ===
#ifndef _INC_DSKQUOTA_PCH_H
#define _INC_DSKQUOTA_PCH_H
///////////////////////////////////////////////////////////////////////////////
/*  File: pch.h

    Description: Precompiled header file for dskquota project.
        Includes all headers that are compiled into the pre-compiled header.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "private.h"

#endif // _INC_DSKQUOTA_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\fsobject.h ===
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#define _INC_DSKQUOTA_FSOBJECT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: fsobject.h

    Description: Contains declarations for file system objects used in the
        quota management library.  Abstractions are provided for NTFS
        volumes, directories and local/remote versions of both.  The idea
        is to hide any peculiarities of these variations behind a common
        FSObject interface.

        The holder of a pointer to an FSObject can call the member functions
        IsLocal() and Type() to determine the exact type and locality of 
        the object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////


class FSObject 
{
    private:
        LONG   m_cRef;              // Instance ref counter.

        //
        // Prevent copy construction.
        //
        FSObject(const FSObject& obj);
        void operator = (const FSObject& obj);

    protected:
        CPath m_strFSObjName;
        DWORD  m_dwAccessRights;    // Access rights granted to client.
                                    // 0                           = None.
                                    // GENERIC_READ                = Read
                                    // GENRIC_READ | GENERIC_WRITE = Read/Write.

        static HRESULT HResultFromNtStatus(NTSTATUS status);

    public:
        //
        // Types of FS Objects.
        //
        enum { TypeUnknown, Volume, Directory };

        //
        // Flags used to indicate what data is to be updated in calls to 
        // SetObjectQuotaInformation() and SetUserQuotaInformation().
        //
        enum {
                ChangeState     = 0x01,
                ChangeLogFlags  = 0x02,
                ChangeThreshold = 0x04,
                ChangeLimit     = 0x08
             };

        FSObject(LPCTSTR pszObjName)
            : m_cRef(0),
              m_dwAccessRights(0),
              m_strFSObjName(pszObjName)
              { DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSObject::FSObject"))); }

        virtual ~FSObject(void);

        ULONG AddRef(VOID);
        ULONG Release(VOID);

        //
        // Pure virtual interface for opening volume/directory.
        //
        virtual HRESULT Initialize(DWORD dwAccess) = 0;

        static HRESULT
        Create(
            LPCTSTR pszFSObjName,
            DWORD dwAccess,
            FSObject **ppNewObject);

        static HRESULT
        Create(
            const FSObject& obj,
            FSObject **ppNewObject);

        static HRESULT 
        ObjectSupportsQuotas(
            LPCTSTR pszFSObjName);

        HRESULT GetName(LPTSTR pszBuffer, ULONG cchBuffer) const;

        virtual HRESULT QueryUserQuotaInformation(
                            PVOID pBuffer,
                            ULONG cBufferLength,
                            BOOL bReturnSingleEntry,
                            PVOID pSidList,
                            ULONG cSidListLength,
                            PSID  pStartSid,
                            BOOL  bRestartScan
                            ) = 0;
    
        virtual HRESULT SetUserQuotaInformation(
                            PVOID pBuffer,
                            ULONG cBufferLength
                            ) const = 0;

        virtual HRESULT QueryObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi
                            ) = 0;

        virtual HRESULT SetObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi,
                            DWORD dwChangeMask
                            ) const = 0;

        virtual BOOL IsLocal(VOID) const = 0;
        virtual UINT Type(VOID) const = 0;

        DWORD GetAccessRights(VOID) const
            { return m_dwAccessRights; }

        BOOL GrantedAccess(DWORD dwAccess) const
            { return (m_dwAccessRights & dwAccess) == dwAccess; }
};


class FSVolume : public FSObject
{
    private:
        //
        // Prevent copying.
        //
        FSVolume(const FSVolume&);
        FSVolume& operator = (const FSVolume&);

    protected:
        HANDLE m_hVolume;

    public:
        FSVolume(LPCTSTR pszVolName)
            : FSObject(pszVolName),
              m_hVolume(INVALID_HANDLE_VALUE) 
              { DBGTRACE((DM_CONTROL, DL_MID, TEXT("FSVolume::FSVolume"))); }

        virtual ~FSVolume(void);

        HRESULT Initialize(DWORD dwAccess);

        UINT Type(VOID) const
            { return FSObject::Volume; }


        virtual HRESULT QueryObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi
                            );


        virtual HRESULT SetObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi,
                            DWORD dwChangeMask
                            ) const;

        virtual HRESULT QueryUserQuotaInformation(
                            PVOID pBuffer,
                            ULONG cBufferLength,
                            BOOL bReturnSingleEntry,
                            PVOID pSidList,
                            ULONG cSidListLength,
                            PSID  pStartSid,
                            BOOL  bRestartScan
                            );
    
        virtual HRESULT SetUserQuotaInformation(
                            PVOID pBuffer,
                            ULONG cBufferLength
                            ) const;
};

class FSLocalVolume : public FSVolume
{
    private:
        //
        // Prevent copying.
        //
        FSLocalVolume(const FSLocalVolume&);
        FSLocalVolume& operator = (const FSLocalVolume&);

    public:
        FSLocalVolume(LPCTSTR pszVolName) 
            : FSVolume(pszVolName) { }

        BOOL IsLocal(VOID) const
            { return TRUE; }

};

HRESULT FSObject_CreateLocalVolume(LPCTSTR pszVolumeName, FSObject **ppObject);


//
// These next classes were originally designed when I thought we might
// need a hierarchy of file system object "types".  As it turns out,
// we really only need FSVolume and FSLocalVolume.  I'll leave these 
// in case the problem changes again sometime in the future.  For now, 
// these are excluded from compilation.  [brianau - 2/17/98]
//
#if 0
/*

class FSRemoteVolume : public FSVolume
{
    private:
        //
        // Prevent copying.
        //
        FSRemoteVolume(const FSRemoteVolume&);
        void operator = (const FSRemoteVolume&);

    public:
        FSRemoteVolume(VOID)
            : FSVolume() { }

        BOOL IsLocal(VOID) const
            { return FALSE; }

};


class FSDirectory : public FSObject
{
    private:
        //
        // Prevent copying.
        //
        FSDirectory(const FSDirectory&);
        void operator = (const FSDirectory&);

    protected:
        HANDLE m_hDirectory;

    public:
        FSDirectory(VOID)
            : FSObject(),
              m_hDirectory(NULL) { }

        HRESULT Initialize(DWORD dwAccess)
            { return E_NOTIMPL; }

        UINT Type(VOID) const
            { return FSObject::Directory; }


        virtual HRESULT QueryObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi
                            ) { return E_NOTIMPL; }


        virtual HRESULT SetObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi,
                            DWORD dwChangeMask
                            ) const { return E_NOTIMPL; }

        virtual HRESULT QueryUserQuotaInformation(
                            PVOID pUserInfoBuffer,
                            ULONG uBufferLength,
                            BOOL bReturnSingleEntry,
                            PVOID pSidList,
                            ULONG uSidListLength,
                            PSID pStartSid,
                            BOOL bRestartScan
                            ) { return E_NOTIMPL; }

        virtual HRESULT SetUserQuotaInformation(
                            PVOID pUserInfoBuffer,
                            ULONG uBufferLength
                            ) const { return E_NOTIMPL; }

};


class FSLocalDirectory : public FSDirectory
{
    private:
        //
        // Prevent copying.
        //
        FSLocalDirectory(const FSLocalDirectory&);
        void operator = (const FSLocalDirectory&);

    public:
        FSLocalDirectory(VOID)
            : FSDirectory() { }

        BOOL IsLocal(VOID) const
            { return TRUE; }

};


class FSRemoteDirectory : public FSDirectory
{
    private:
        //
        // Prevent copying.
        //
        FSRemoteDirectory(const FSRemoteDirectory&);
        void operator = (const FSRemoteDirectory&);

    public:
        FSRemoteDirectory(VOID)
            : FSDirectory() { }

        BOOL IsLocal(VOID) const
            { return FALSE; }
};
*/
#endif // #if 0

#endif  // DISKQUOTA_FSOBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\oadisp.h ===
#ifndef _INC_DSKQUOTA_OADISP_H
#define _INC_DSKQUOTA_OADISP_H
///////////////////////////////////////////////////////////////////////////////
/*  File: oadisp.h

    Description: Provides reusable implementation of IDispatch.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _OLEAUTO_H_
#   include <oleauto.h>
#endif

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

class OleAutoDispatch
{
    public:
        OleAutoDispatch(VOID);

        OleAutoDispatch(IDispatch *pObject,
                        REFIID riidTypeLib,
                        REFIID riidDispInterface,
                        LPCTSTR pszTypeLib);

        ~OleAutoDispatch(VOID);

        HRESULT 
        Initialize(
            IDispatch *pObject,
            REFIID riidTypeLib,
            REFIID riidDispInterface,
            LPCTSTR pszTypeLib);

        HRESULT 
        GetIDsOfNames(
            REFIID riid,  
            OLECHAR ** rgszNames,  
            UINT cNames,  
            LCID lcid,  
            DISPID *rgDispId);
        
        HRESULT 
        GetTypeInfo(
            UINT iTInfo,  
            LCID lcid,  
            ITypeInfo **ppTInfo);

        HRESULT 
        GetTypeInfoCount(
            UINT *pctinfo);

        HRESULT 
        Invoke(
            DISPID dispIdMember,  
            REFIID riid,  
            LCID lcid,  
            WORD wFlags,  
            DISPPARAMS *pDispParams,  
            VARIANT *pVarResult,  
            EXCEPINFO *pExcepInfo,  
            UINT *puArgErr);

    private:
        IDispatch *m_pObject;
        GUID       m_idTypeLib;
        GUID       m_idDispInterface;
        ITypeInfo *m_pTypeInfo;
        CString    m_strTypeLib;

        //
        // Prevent copy.
        //
        OleAutoDispatch(const OleAutoDispatch& rhs);
        OleAutoDispatch& operator = (const OleAutoDispatch& rhs);
};

#endif //_INC_DSKQUOTA_OADISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\oadisp.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: oadisp.cpp

    Description: Provides reusable implementation of IDispatch.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "oadisp.h"


OleAutoDispatch::OleAutoDispatch(
    VOID
    ) : m_pObject(NULL),
        m_pTypeInfo(NULL)
{

}

OleAutoDispatch::OleAutoDispatch(
    IDispatch *pObject,
    REFIID riidTypeLib,
    REFIID riidDispInterface,
    LPCTSTR pszTypeLib
    ) : m_pObject(NULL),
        m_pTypeInfo(NULL),
        m_strTypeLib(pszTypeLib)
{
    Initialize(pObject, riidTypeLib, riidDispInterface, pszTypeLib);
}

OleAutoDispatch::~OleAutoDispatch(
    VOID
    )
{
    if (NULL != m_pTypeInfo)
    {
        m_pTypeInfo->Release();
    }
}


HRESULT
OleAutoDispatch::Initialize(
    IDispatch *pObject,
    REFIID riidTypeLib,
    REFIID riidDispInterface,
    LPCTSTR pszTypeLib
    )
{
    HRESULT hr = S_FALSE; // Assume already initialized.

    if (NULL == m_pObject)
    {
        //
        // Note that we DO NOT AddRef the object pointer.
        // We assume that the object will outlive the OleAutoDispatch.
        // If you do, you can get into a circular reference problem where
        // the object pointed to by pObject is the container for *this.
        //
        m_pObject         = pObject;
        m_idTypeLib       = riidTypeLib;
        m_idDispInterface = riidDispInterface;
        m_strTypeLib      = pszTypeLib;
        hr = S_OK;
    }
    return hr;
}


HRESULT
OleAutoDispatch::GetIDsOfNames(
    REFIID riid,  
    OLECHAR **rgszNames,  
    UINT cNames,  
    LCID lcid,  
    DISPID *rgDispId
    )
{
    HRESULT hr;
    ITypeInfo *pTI;

    if (IID_NULL != riid)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    hr = GetTypeInfo(0, lcid, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispId);
        pTI->Release();
    }
    return hr;
}


HRESULT
OleAutoDispatch::GetTypeInfo(
    UINT iTInfo,  
    LCID lcid,  
    ITypeInfo **ppTypeInfo
    )
{
    HRESULT   hr = NOERROR;
    ITypeLib  *pTypeLib;
    ITypeInfo **ppTI;

    if (0 != iTInfo)
        return TYPE_E_ELEMENTNOTFOUND;

    if (NULL == ppTypeInfo)
        return E_INVALIDARG;

    *ppTypeInfo = NULL;

    switch(PRIMARYLANGID(lcid))
    {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            ppTI = &m_pTypeInfo;
            break;

        default:
            return DISP_E_UNKNOWNLCID;
    }

    if (NULL == *ppTI)
    {
        hr = LoadRegTypeLib(m_idTypeLib,
                            1,
                            0,
                            PRIMARYLANGID(lcid),
                            &pTypeLib);
        if (FAILED(hr))
        {
            switch(PRIMARYLANGID(lcid))
            {
                case LANG_NEUTRAL:
                case LANG_ENGLISH:
                    hr = LoadTypeLib(m_strTypeLib, &pTypeLib);
                    break;

                default:
                    break;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pTypeLib->GetTypeInfoOfGuid(m_idDispInterface, ppTI);
            pTypeLib->Release();
        }
    }
    if (SUCCEEDED(hr))
    {
        (*ppTI)->AddRef();
        *ppTypeInfo = *ppTI;
    }

    return hr;
}


HRESULT
OleAutoDispatch::GetTypeInfoCount(
    UINT *pctinfo
    )
{
    //
    // 1 = "We implement GetTypeInfo"
    //
    *pctinfo = 1;
    return NOERROR;
}


HRESULT
OleAutoDispatch::Invoke(
    DISPID dispIdMember,  
    REFIID riid,  
    LCID lcid,  
    WORD wFlags,  
    DISPPARAMS *pDispParams,  
    VARIANT *pVarResult,  
    EXCEPINFO *pExcepInfo,  
    UINT *puArgErr
    )
{
    HRESULT hr;
    ITypeInfo *pTI;

    if (IID_NULL != riid)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    hr = GetTypeInfo(0, lcid, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = pTI->Invoke(m_pObject,
                         dispIdMember,
                         wFlags,
                         pDispParams,
                         pVarResult,
                         pExcepInfo,
                         puArgErr);

        pTI->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\sidcache.h ===
#ifndef _INC_DSKQUOTA_SIDCACHE_H
#define _INC_DSKQUOTA_SIDCACHE_H
///////////////////////////////////////////////////////////////////////////////
/*  File: sidcache.h

    Description: Header for classes associated with the SID/Name cache.


   Here's a ER-style diagram of the SID cache.  The cache consists
   of a data file and index file.  The index is a hash table consisting
   of an array of hash buckets, each containing 0 or more hash bucket entries.
   Each hash bucket entry contains the index of it's corresponding user record
   in the data file.  The index hash code is based on the user SID.

   The index is designed for fast lookup of queue entries.  Hash values are
   calculated by simply summing the value of the bytes in a SID and
   performing modulo division with the number of hash buckets.  Each hash
   bucket contains a doubly-linked list to handle hash value collisions
   and removal of expired entries. Each hash bucket entry contains the index
   of the starting block for the user's record in the data file.


                         +-----------+      +--------+<---> User SID
                     +-->| data file |<--->>| record |<---> User Domain
                     |   +-----------+      +--------+<---> User Name
                     |                            ^   <---> User Full User Name
    +-----------+<---+                            |
    |  cache    |                                 |
    +-----------+<---+                            +--- points to ----+
                     |                                               |
                     |                                               |
                     |   +----------+      +-------------+     +--------------+
                     +-->| ndx file |<--->>| hash bucket |<-->>| bucket entry |
                         +----------+      +-------------+     +--------------+

    <--->  = One-to-one
    <-->>  = One-to-many


   Notes:
     1. Because SID->Name resolution over the network is very slow
        (0-10 seconds), I anticipate that this cache will be used heavily
        and may contain 100's or 1000's of entries depending upon the
        volume's usage.

    Index file structure ------------------------------------------------------

        +------------------------+
        |      Header            | <--- Type INDEX_FILE_HDR
        +------------------------+
        |                        |
        |                        | <--- Array of DWORDs.  Count should be prime.
        |    Hash bucket array   |      Each element represents a hash bucket.
        |                        |      Unused elements contain NULL.
        |                        |      Used elements contain address of first
        |                        |      entry in hash bucket's entry list.
        +------------------------+
        |                        |
        |                        |
        |                        | <--- Array of INDEX_ENTRY.
        |      Index entries     |      Each entry is a node in a linked list.
        |                        |      Initially, all are on the "free list".
        |                        |      As entries are allocated, they are
        |                        |      transfered to the appropriate hash bucket's
        |                        |      list.  Each used entry contains the
        |                        |      starting block number of the corresponding
        |                        |      record in the data file.
        +------------------------+

    Data file structure -------------------------------------------------------

        +------------------------+
        |      Header            | <--- Type DATA_F