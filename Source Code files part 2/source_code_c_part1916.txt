r loop.
     * If X1 is odd, then the last texel is an even texel and the odd texel component will
     * need to be copied as a WORD value after the inner loop completes.
     */
    switch (((dwSrcX0 & 0x01) << 1) | (dwSrcX1 & 0x01))
    {
        /*
         * Even start, even end.
         */
        case 0:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                while (xSrcCurrent < dwSrcX1)
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Even start, odd end.
         */
        case 1:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
            }
            break;

        /*
         * Odd start, even end.
         */
        case 2:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
                xSrcCurrent++;
                u = UV_INC(u, uInc, uMask);
                while (xSrcCurrent < dwSrcX1)
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Odd start, odd end.
         */
        case 3:
            for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                xSrcCurrent = dwSrcX0;
                u = u0;
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
                xSrcCurrent++;
                u = UV_INC(u, uInc, uMask);
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    xSrcCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                pDstSwizzle[UV_OFFSET(u,v)] = pSrcLinear[xSrcCurrent];
            }
            break;
    }
}

void nvSwizzleTexture32Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstSwizzleBase
)
{
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    unsigned long *pSrcLinear;
    unsigned long *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned long *)dwDstSwizzleBase;
    // X1, Y1 are exclusive.
    for (ySrcCurrent = dwSrcY0; ySrcCurrent < dwSrcY1; ySrcCurrent++, v = UV_INC(v, vInc, vMask))
    {
        pSrcLinear = (unsigned long *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
        xSrcCurrent = dwSrcX0;
        u = u0;
        while (xSrcCurrent < dwSrcX1)
        {
            pDstSwizzle[UV_OFFSET(u,v)]   = pSrcLinear[xSrcCurrent];
            pDstSwizzle[UV_OFFSET(u,v)+1] = pSrcLinear[xSrcCurrent+1];
            xSrcCurrent += 2;
            u = UV_INC(u, uInc2, uMask);
        }
    }
}

/*
 * General purpose texture de-swizzling.  This routine is called at most
 * once for any given texture, so there's only really a need for a single
 * general purpose routine.
 */
void nvDeSwizzleTexture
(
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwPitch,
    DWORD   dwDstLinearBase,
    DWORD   dwSrcSwizzleBase,
    DWORD   dwTextureFormat
)
{
    DWORD   u, v;
    DWORD   xDstCurrent, yDstCurrent;
    DWORD   dwAdjustedWidth;
    unsigned long *pDstLinear;
    unsigned long *pSrcSwizzle;

    switch (dwTextureFormat)
    {
        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
        case NV054_FORMAT_COLOR_LE_R5G6B5:
        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
            // for 16-bit textures, divide the width by two since
            // we move four bytes at a time
            dwAdjustedWidth = dwWidth >> 1;
            break;
        default:
            dwAdjustedWidth = dwWidth;
            break;
    }

    pSrcSwizzle = (unsigned long *)dwSrcSwizzleBase;

    // for 1xN and Mx1 textures, no deswizzling is necessary. just copy
    if ((dwAdjustedWidth <= 1) || (dwHeight == 1)) {
        pDstLinear = (unsigned long *)dwDstLinearBase;
        for (u=0; u < ((dwHeight*dwPitch)>>2); u++)
            pDstLinear[u] = pSrcSwizzle[u];
        return;
    }

    for (yDstCurrent = 0;
         yDstCurrent < dwHeight;
         yDstCurrent++)
    {
        V_INTERLEAVE(v, yDstCurrent, dwWidth, dwHeight);
        pDstLinear = (unsigned long *)(dwDstLinearBase + (yDstCurrent * dwPitch));
        for (xDstCurrent = 0;
             xDstCurrent < dwAdjustedWidth;
             xDstCurrent++)
        {
            U_INTERLEAVE(u, xDstCurrent, dwWidth, dwHeight);
            pDstLinear[xDstCurrent] = pSrcSwizzle[UV_OFFSET(u,v)];
        }
    }
    return;
}

BOOL nvLoadTexture
(
    PNVD3DTEXTURE   pTexture
)
{
    DWORD                       texBPP;
    DWORD                       texWidth, texHeight, texPitch;
    DWORD                       logbaseu, logbasev, mipmaplevels;
    DWORD                       dwSrcLinearBase;
    DWORD                       dwDstSwizzleBase;
    DWORD                       dwTextureOffset;
    DWORD                       dwCurrentSize;
    DWORD                       dwTextureFlags;
    DWORD                       dwSrcLimit;
    DWORD                       dwImageColorFormat;
    DWORD                       dwSurfaceColorFormat;
    DWORD                       dwBytesPerPixel;
    PNVD3DTEXTURE               pTextureMipMapLevel;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDDS;

    /*
     * Validate the context and texture pointers.
     */
    if (!pCurrentContext || !pTexture || !pTexture->dwTexturePointer)
        return (FALSE);

    /*
     * Validate the texture surface.
     */
    if (!(lclDDS = pTexture->lpLcl))
        return (FALSE);
    if (!(gblDDS = lclDDS->lpGbl))
        return (FALSE);
    if ((!gblDDS->fpVidMem) && (!pTexture->fpUserTexture))
        return (FALSE);

    /*
     * Get information about the source texture out of the texture structure.
     */
    dwTextureFlags  = pTexture->dwTextureFlags;
    texBPP          = pTexture->dwTextureColorFormat;
    texWidth        = lclDDS->lpGbl->wWidth;
    texHeight       = lclDDS->lpGbl->wHeight;
    texPitch        = lclDDS->lpGbl->lPitch;

    logbaseu        = pTexture->dwMipMapBaseU;
    logbasev        = pTexture->dwMipMapBaseV;
    mipmaplevels    = pTexture->dwMipMapLevels;

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
#endif  // CACHE_FREECOUNT

    /*
     * Get pointers to the source and destination textures.
     */
    dwSrcLinearBase  = (DWORD)((gblDDS->fpVidMem) ? gblDDS->fpVidMem : pTexture->fpUserTexture);
    if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
        dwDstSwizzleBase = pTexture->dwTexturePointer;
    else
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
        {
            dwDstSwizzleBase = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#ifdef WINNT
            dwDstSwizzleBase += (ULONG) pDriverData->ppdev->pjScreen;
#endif
        }
        else
        {
            if (pDriverData->GARTLinearBase > 0)
                dwDstSwizzleBase = pTexture->dwTexturePointer;
            else
                dwDstSwizzleBase = GetPointerTextureHeap(pTexture->dwTextureOffset);
        }
    }
    dwTextureOffset = pTexture->dwTextureOffset;
    pTextureMipMapLevel = pTexture;
    while (mipmaplevels)
    {
        /*
         * Only need to swizzle the texture if it has been modified.
         */
        if (pTextureMipMapLevel->dwTextureFlags & NV3_TEXTURE_MODIFIED)
        {
            /*
             * Display the source texture on the screen. (DEBUG only)
             */
            dbgDisplayLinearTexture(pTextureMipMapLevel->lpLcl, pTextureMipMapLevel->lpLcl, pTextureMipMapLevel->dwTextureColorFormat);

            if (pTextureMipMapLevel->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
            {
                dwSrcLimit = (texPitch * texHeight) - 1;
                switch (texBPP)
                {
                    case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_R5G6B5:
                    case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
                        dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;
                        dwBytesPerPixel      = 2;
                        break;

                    case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;
                        dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;
                        dwBytesPerPixel      = 4;
                        break;
                }
                nvTMVideoTextureBlt (0,texPitch,0,0,texWidth,texHeight,
                                     dwSrcLinearBase,texPitch,0,0,
                                     dwTextureOffset,
                                     (WORD)logbaseu, (WORD)logbasev,
                                     texBPP);
            }
            else
            {
                /*
                 * Call correct swizzle routine based on the texture format (16bpp vs 32bpp)
                 */
                switch (texBPP)
                {
                    case NV054_FORMAT_COLOR_LE_X1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_R5G6B5:
                    case NV054_FORMAT_COLOR_LE_A1R5G5B5:
                    case NV054_FORMAT_COLOR_LE_A4R4G4B4:
                        dwBytesPerPixel = 2;
                        nvSwizzleTexture16Bpp(0, 0,
                                              texWidth, texHeight,
                                              texWidth, texHeight,
                                              texPitch,
                                              dwSrcLinearBase,
                                              0, 0,
                                              dwDstSwizzleBase);
                        break;

                    case NV054_FORMAT_COLOR_LE_X8R8G8B8:
                    case NV054_FORMAT_COLOR_LE_A8R8G8B8:
                        dwBytesPerPixel = 4;
                        nvSwizzleTexture32Bpp(0, 0,
                                              texWidth, texHeight,
                                              texWidth, texHeight,
                                              texPitch,
                                              dwSrcLinearBase,
                                              0, 0,
                                              dwDstSwizzleBase);
                        break;
                }
            }
            dbgDisplayTexture((PNVD3DCONTEXT)pTextureMipMapLevel->hContext, pTextureMipMapLevel);
        }
        mipmaplevels--;

        if ((pDriverData->regD3DEnableBits1 & REG_BIT1_USER_MIPMAPS_ENABLE)
         && (lclDDS->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
        {
            if ((lclDDS->lpAttachList)
                && (lclDDS = lclDDS->lpAttachList->lpAttached))
            {
                    dwCurrentSize     = ((1 << logbaseu) * dwBytesPerPixel) * (1 << logbasev);
                    texWidth          = lclDDS->lpGbl->wWidth;
                    texHeight         = lclDDS->lpGbl->wHeight;
                    texPitch          = lclDDS->lpGbl->lPitch;
                    dwSrcLinearBase   = (DWORD)lclDDS->lpGbl->fpVidMem;
                    dwDstSwizzleBase += dwCurrentSize;
                    logbaseu--;
                    logbasev--;
                    pTextureMipMapLevel = (PNVD3DTEXTURE)lclDDS->dwReserved1;
            }
            else
                mipmaplevels = 0;
        }
        else
        {
            mipmaplevels = 0;
        }
    }

    /*
     * Auto generate mipmaps
     */
    if (pTexture->dwTextureFlags & NV4_TEXTURE_AUTOMIPMAPPED)
    {
        nvTextureAutoMipMap (pTexture);
    }

    /*
     * Save frequently accessed globals.
     */
    NV_D3D_GLOBAL_SAVE();

    /*
     * Set the hardware texture format for this texture.
     */
    pTexture->dwTextureFlags  &= ~NV3_TEXTURE_MODIFIED;

    /*
     * Save the pointer to the texture data that the internal texture
     * was created from. This will be used for validation. If this pointer
     * is ever different from the pointer stored in the texture surface,
     * then the texture must be reloaded.
     */
    pTexture->fpTexture = (FLATPTR)pTexture->lpLcl->lpGbl->fpVidMem;

#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT
    return (TRUE);
}

#endif //!NV_TEX2

/*
 * nvAllocateUserTexture
 *
 * Application texture memory allocation.
 * legacy code names 'internal' what we now call 'swizzle'
 *               and 'user'     what we now call 'linear'
 */
BOOL nvAllocateUserTexture
(
    PNVD3DTEXTURE   pTexture
)
{
#ifdef NV_TEX2

#ifdef DEBUG
    if (!pTexture)
    {
        DPF ("nvAllocateUserTexture: pTexture == NULL");
        dbgD3DError();
        __asm int 3;
        return FALSE;
    }
#endif // DEBUG

    /*
     * allocate if it does not already exist
     *
     * note that for mipmap chains we allocate seperate linear textures (unlike the linked version for swizzle)
     */
    if (!pTexture->dwLinearAddr)
    {
        DWORD dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_SYS)
                                                         : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI | NV4_TEXLOC_SYS);
        if (!nvTextureAllocLinearSurface(pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI)))
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateUserTexture: User Texture Allocation Failed");
            dbgD3DError();
            return (FALSE);
        }
    }

    /*
     * tag as invalid - will be deswizzled before use
     */
    pTexture->dwTextureFlags &= ~NV4_TEXFLAG_LINEAR_VALID;

    /*
     * done
     */
    return TRUE;

#else //!NV_TEX2

    DWORD                       dwBlockSize;
    HGLOBAL                     hMem;
    PNVD3DTEXTURE               pMipMapTexture;
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   lpGbl;
    LPDDRAWI_DDRAWSURFACE_LCL   lpMipMapLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   lpMipMapGbl;

    /*
     * Make sure there is a valid texture pointer.
     */
    if ((!pTexture)
     || (!pTexture->lpLcl)
     || (!pTexture->lpLcl->lpGbl))
        return (FALSE);

    lpLcl = pTexture->lpLcl;
    lpGbl = lpLcl->lpGbl;

    /*
     * Allocate application's system memory texture surface if neccessary.
     */
    if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
    {
        /*
         * Reuse the system memory texture surface already allocated.
         */
        lpGbl->fpVidMem    = pTexture->fpUserTexture;
        lpGbl->dwReserved1 = (DWORD)pTexture->hUserTexture;

        if (pTexture->dwTextureFlags & NV3_TEXTURE_BLIT_UPDATE)
        {
            /*
             * The internal texture memory was modified with a blit but the user texture memory
             * was not updated.  The internal texture needs to be de-swizzled before the application
             * can be given access to it.
             */
            nvDeSwizzleTexture((DWORD)lpGbl->wWidth,
                               (DWORD)lpGbl->wHeight,
                               (DWORD)lpGbl->lPitch,
                               (DWORD)lpGbl->fpVidMem,
                               (DWORD)pTexture->dwTexturePointer,
                               (DWORD)pTexture->dwTextureColorFormat);

            /*
             * Once the texture has been de-swizzled once, it should never need to be
             * de-swizzled again.  Clear the flag, if the need for de-swizzling ever comes
             * up again, it will get re-set.
             */
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_BLIT_UPDATE;
        }
    }
    else
    {
        /*
         * If this is a mipmap chain, we want to allocate memory for all mip
         * levels all at once, so find the base, mipmap texture and run
         * through the chain allocating and de-swizzling each level.
         * If this is not a mipmap chain, only only a single iteration will
         * be neccessary.
         */
        if (lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            if (!pTexture->hMipBaseTexture)
                pMipMapTexture = pTexture;
            else
                pMipMapTexture = (PNVD3DTEXTURE)pTexture->hMipBaseTexture;
        }
        else
        {
            /*
             * Not a user mipmap chain, 1 mipmap level (i.e. only base texture)
             */
            pMipMapTexture = pTexture;
        }

        /*
         * Traverse the mipmap chain and allocate memory for each level.
         */
        while (pMipMapTexture)
        {
            lpMipMapLcl = pMipMapTexture->lpLcl;
            lpMipMapGbl = lpMipMapLcl->lpGbl;

            /*
             * Allocate the user system memory texture surface.
             */
            dwBlockSize = (DWORD)(lpMipMapGbl->lPitch * (LONG)lpMipMapGbl->wHeight);
            hMem = GlobalAlloc(GHND | GMEM_SHARE, dwBlockSize);
            if (!hMem)
            {
                /*
                 * Could not allocate the internal texture memory.  Cleanup and return the error.
                 */
                lpMipMapGbl->dwReserved1      = (DWORD)NULL;
                pMipMapTexture->hUserTexture  = (HANDLE)NULL;
                pMipMapTexture->fpUserTexture = (FLATPTR)NULL;
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvAllocateUserTexture - User texture memory allocation failed");
                return (FALSE);
            }

            /*
             * Store the handle and pointer for the system memory surface in the global surface
             * data structure.
             */
            lpMipMapGbl->fpVidMem           = (FLATPTR)GlobalLock(hMem);
            lpMipMapGbl->dwReserved1        = (DWORD)hMem;
            pMipMapTexture->hUserTexture    = hMem;
            pMipMapTexture->fpUserTexture   = lpMipMapGbl->fpVidMem;
            pMipMapTexture->dwTextureFlags |= NV3_TEXTURE_USER_ALLOCATED;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvAllocateUserTexture - User Texture = %08lx", pMipMapTexture->fpUserTexture);

            if (pMipMapTexture->dwTextureFlags & NV3_TEXTURE_BLIT_UPDATE)
            {
                /*
                 * The internal texture memory was modified with a blit but the user texture memory
                 * was not updated.  The internal texture needs to be de-swizzled before the application
                 * can be given access to it.
                 */
                nvDeSwizzleTexture((DWORD)lpMipMapGbl->wWidth,
                                   (DWORD)lpMipMapGbl->wHeight,
                                   (DWORD)lpMipMapGbl->lPitch,
                                   (DWORD)lpMipMapGbl->fpVidMem,
                                   (DWORD)pMipMapTexture->dwTexturePointer,
                                   (DWORD)pTexture->dwTextureColorFormat);

                /*
                 * Once the texture has been de-swizzled once, it should never need to be
                 * de-swizzled again.  Clear the flag, if the need for de-swizzling ever comes
                 * up again, it will get re-set.
                 */
                pMipMapTexture->dwTextureFlags &= ~NV3_TEXTURE_BLIT_UPDATE;
            }

            /*
             * Move to the next mipmap in the chain.
             */
            if ((lpMipMapLcl->lpAttachList)
             && (lpMipMapLcl->lpAttachList->lpAttached)
             && (lpMipMapLcl->lpAttachList->lpAttached->dwReserved1))
            {
                pMipMapTexture = (PNVD3DTEXTURE)lpMipMapLcl->lpAttachList->lpAttached->dwReserved1;
            }
            else
                pMipMapTexture = (PNVD3DTEXTURE)NULL;
        }
    }

    return (TRUE);

#endif //!NV_TEX2
}

/*
 * nvCreateTextureSurface
 *
 * Direct Draw Texture Surface routines.
 */
BOOL nvCreateTextureSurface
(
    LPDDHAL_CREATESURFACEDATA   lpCreateSurface,
    LPDDRAWI_DDRAWSURFACE_LCL   lclDDS,
    LPDDRAWI_DDRAWSURFACE_GBL   gblDDS
)
{
    BOOL            bCanAutoMipMap;
#ifndef NV_TEX2
    DWORD           logCurrentU, logCurrentV;
    DWORD           j;
    HGLOBAL         hMem;
#endif
    DWORD           dwTextureFlags;
    DWORD           dwTextureFormat;
    DWORD           width, height;
    DWORD           mipmaplevels;
    DWORD           texWidth, texHeight, texPitch, minPitch;
    DWORD           texSizeBytes;
    DWORD           logWidth, logHeight;
    DWORD           dwBytesPerPixel;
    DWORD           dwSrcBitCount;
    LONG            lPitch;
    HDDRVITEM       hTexture;
    PNVD3DTEXTURE   pTexture = 0;

    /*
     * It's possible that the internal texture data structure has already been allocated (in
     * the case where the texture handle was allocated first).  Try and get the pointer to
     * it.
     */
    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "nvCreateTextureSurface - lclDDS = %08lx, gblDDS = %08lx", lclDDS, gblDDS);
    hTexture = lclDDS->dwReserved1;
    pTexture = (PNVD3DTEXTURE)hTexture;

    /*
     * Initialize the texture flags.  Use the current flags in the texture data structure
     * if there is one.  Otherwise, start from scratch.
     */
    dwTextureFlags = (pTexture) ? pTexture->dwTextureFlags : 0;

    /*
     * Only supporting RGB 16 and 32bpp formats.
     */
    if (lclDDS->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        if ((gblDDS->ddpfSurface.dwFlags & DDPF_RGB)
         || ((gblDDS->ddpfSurface.dwFlags & DDPF_FOURCC)
         &&  (gblDDS->ddpfSurface.dwFourCC == FOURCC_RGB0)))
        {
            if ((gblDDS->ddpfSurface.dwRGBBitCount != 16)
             && (gblDDS->ddpfSurface.dwRGBBitCount != 32)
             && ((gblDDS->ddpfSurface.dwRGBBitCount != 8)
              || ((gblDDS->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8) != DDPF_PALETTEINDEXED8)))
            {
                /*
                 * Invalid pixel format. Return the error.
                 */
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (FALSE);
            }
        }
    }

    /*
     * Determine the color format of the texture.
     */
    bCanAutoMipMap = FALSE;
    if (lclDDS->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        if (gblDDS->ddpfSurface.dwRGBBitCount == 16)
        {
            switch (gblDDS->ddpfSurface.dwRGBAlphaBitMask)
            {
                case 0x0000:
                    if (gblDDS->ddpfSurface.dwRBitMask == 0x7C00)
                    {
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X1R5G5B5;
                        bCanAutoMipMap  = TRUE;
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X1R5G5B5");
                    }
                    else
                    {
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_R5G6B5;
                        bCanAutoMipMap  = TRUE;
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_R5G6B5");
                    }
                    break;
                case 0x8000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_A1R5G5B5;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A1R5G5B5");
                    break;
                case 0xF000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_A4R4G4B4;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A4R4G4B4");
                    break;
            }
            dwBytesPerPixel = 2;
            dwSrcBitCount = 16;
        }
        else if (gblDDS->ddpfSurface.dwRGBBitCount == 32)
        {
            switch (gblDDS->ddpfSurface.dwRGBAlphaBitMask)
            {
                case 0x00000000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                    bCanAutoMipMap  = TRUE;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X8R8G8B8");
                    break;
                case 0xFF000000:
                    dwTextureFormat = NV054_FORMAT_COLOR_LE_A8R8G8B8;
                    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A8R8G8B8");
                    break;
            }
            dwBytesPerPixel = 4;
            dwSrcBitCount = 32;
        }
        else if (gblDDS->ddpfSurface.dwRGBBitCount == 8)
        {
            if (pDriverData->regPal8TextureConvert == REG_P8TC_NONE)
            {
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (FALSE);
            }
            if (gblDDS->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)
            {
                switch (pDriverData->regPal8TextureConvert)
                {
                    case REG_P8TC_8TOR5G6B5:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a 565!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_R5G6B5");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_R5G6B5;
                        dwBytesPerPixel = 2;
                        break;
                    case REG_P8TC_8TOX1R5G5B5:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a X555!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X1R5G5B5");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X1R5G5B5;
                        dwBytesPerPixel = 2;
                        break;
                    case REG_P8TC_8TOA1R5G5B5:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a 1555!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A1R5G5B5");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_A1R5G5B5;
                        dwBytesPerPixel = 2;
                        break;

                    case REG_P8TC_8TOX8R8G8B8:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a X888!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X8R8G8B8");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                        dwBytesPerPixel = 4;
                        break;
                    case REG_P8TC_8TOA8R8G8B8:
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit palettized texture as a 8888!");
                        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_A8R8G8B8");
                        dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                        dwBytesPerPixel = 4;
                        break;
                    default:
                        dbgD3DError();
                        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                        lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        return (FALSE);
                }
            }
            else if (gblDDS->ddpfSurface.dwFlags & DDPF_LUMINANCE)
            {
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface: Allocating 8 bit Luminance Texture!");
                DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_Y8");
                dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
                dwBytesPerPixel = 1;
            }
            else
            {
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
                lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                return (FALSE);
            }
            dwSrcBitCount = 8;
#ifdef HW_PAL8
            dwTextureFlags |= NV4_TEXFLAG_PALETTIZED;
#endif
        }
        else
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
            lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return (FALSE);
        }
    }
    else
    {
        /*
         * If the texture doesn't specify a pixel format, that means it's the same format
         * as the device.  One application that actually does this is Indy Racing League.
         */
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - No Pixel format Given!");
        if (pDriverData->bi.biBitCount == 16)
        {
            dwTextureFormat = NV054_FORMAT_COLOR_LE_R5G6B5;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_R5G6B5");
            dwBytesPerPixel = 2;
            dwSrcBitCount   = 16;
            bCanAutoMipMap  = TRUE;
        }
        else if (pDriverData->bi.biBitCount == 32)
        {
            dwTextureFormat = NV054_FORMAT_COLOR_LE_X8R8G8B8;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface:TextureFormat = FORMAT_COLOR_LE_X8R8G8B8");
            dwBytesPerPixel = 4;
            dwSrcBitCount   = 32;
            bCanAutoMipMap  = TRUE;
        }
        else
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture format!");
            lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            return (FALSE);
        }
    }

    /*
     * Make sure there's a valid color format in the texture format register.
     */
    if (!dwTextureFormat)
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Texture format not set!!");

    if (pDriverData->regD3DEnableBits1 & REG_BIT1_RESTRICT_AUTO_MIPMAPS)
    {
        if (lclDDS->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
            bCanAutoMipMap = FALSE;
    }
    else
        bCanAutoMipMap = TRUE;

    /*
     * Validate width, height and pitch. Get commonly used values local.
     */
    minPitch = (pDriverData->regPal8TextureConvert == REG_P8TC_NONE) ? 2 : 1;

    if (((texWidth  = (long)gblDDS->wWidth)  == 0)
     || ((texHeight = (long)gblDDS->wHeight) == 0)
     || ((texPitch  = (long)gblDDS->lPitch)  <  minPitch))
    {
        /*
         * Invalid texture size. Return the error.
         */
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture size!");
        lpCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
        return (FALSE);
    }

    /*
     * Validate that the texture dimensions are both powers of two.
     */
    if ((texWidth & (texWidth - 1))
     || (texHeight & (texHeight - 1)))
    {
        /*
         * The texture is not a power of two. Return the error.
         */
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Texture not power of 2");
        lpCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
        return (FALSE);
    }

    /*
     * Determine which power of two by finding the bit position.
     */
    __asm
    {
        mov ecx,[texWidth]
        mov ebx,[texHeight]
        mov [width],ecx             // width = texWidth
        bsf eax,ecx                 //   486 instruction to count the bit position
        mov [height],ebx            // height = texHeight
        bsf edx,ebx                 //   486 instruction to count the bit position
        mov [logWidth],eax
        mov [logHeight],edx;
    }

    /*
     * Determine the number of MipMap levels based on the maximum image
     * size and the maximum number of MipMap levels. For auto-generated
     * MipMaps, this is based on a registry setting.  For user defined
     * MipMaps, this will be a combination of the number of levels supplied
     * by the application as well as the maximum number of levels set in
     * the registry.
     */
    if (lclDDS->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
    {
        if (pDriverData->regD3DEnableBits1 & REG_BIT1_USER_MIPMAPS_ENABLE)
        {
            LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

            /*
             * Rather than grab the mipmap count from the structure, I'm just
             * going to traverse the chain and manually count the levels.
             * This way I can't get it wrong.
             */
            mipmaplevels = 1;
            lclMip = lclDDS;
            while (lclMip
                && lclMip->lpAttachList)
            {
                mipmaplevels++;
                lclMip = lclMip->lpAttachList->lpAttached;
            }

            /*
             * Check if this is the base level or one of the mip levels.
             */
            if (lclDDS->lpAttachListFrom)
#ifdef NV_TEX2
                dwTextureFlags |= NV4_TEXFLAG_USER_MIP_LEVEL;
#else
                dwTextureFlags |= NV3_TEXTURE_USER_MIP_LEVEL;
#endif
        }
        else
        {
            mipmaplevels = 1;
        }
    }
    else
    {
        /*
         * Set the number of mipmap levels to auto generate.
         */
        mipmaplevels = 1L; // default
        /*
         * if we haven't drawn some frames yet and ...
         */
        if (bCanAutoMipMap
#ifndef NV_TEX2
         && (pCurrentContext && (pCurrentContext->dwSceneCount < 3))
#endif
           )
        {
            /*
             * the texture dimensions are okay
             */
            if ((logWidth + 1 == logHeight    )     // 2:1
             || (logWidth     == logHeight    )     // 1:1
             || (logWidth     == logHeight + 1))    // 1:2
            {
                if ((dwSrcBitCount != 8)
                 && (pDriverData->regMipMapLevels))
                {
                    mipmaplevels = min(logWidth,logHeight) + 1;
                    mipmaplevels = min(mipmaplevels, pDriverData->regMipMapLevels);
                }
            }
        }

        /*
         * update texture flags
         */
#ifdef NV_TEX2
        // test: disable auto mipmaps totally for now.
        //       also update mipmap disables to not redo HW if not really needed
        //dwTextureFlags |= (mipmaplevels > 1) ? NV4_TEXFLAG_AUTOMIPMAP : 0;
#else
        dwTextureFlags |= (mipmaplevels > 1) ? NV4_TEXTURE_AUTOMIPMAPPED : 0;
#endif
    }

    /*
     * Calculate the size of the NV3 format texture including mip maps.
     */
#ifdef NV_TEX2
    texSizeBytes = nvTextureCalcMipMapSize(logWidth,logHeight,mipmaplevels) * dwBytesPerPixel;
#else
    texSizeBytes    = 0;
    logCurrentU     = logWidth;
    logCurrentV     = logHeight;
    for (j = 0; j < mipmaplevels; j++)
    {
        texSizeBytes += (1 << (logCurrentU + logCurrentV)) * dwBytesPerPixel;
        logCurrentU--;
        logCurrentV--;
    }
#endif // !NV_TEX2

    /*
     * All the pertinent texture data has now been validated and calculated.
     * Time for allocating all the memory for the texture surface and texture data structures.
     *
     * Calculate the pitch for the application system memory texture.
     */
    lPitch = texWidth * dwBytesPerPixel;
    gblDDS->lPitch = lPitch;

    /*
     * Allocate an internal texture data structure if there isn't one allocated yet.
     */
    if (!pTexture)
    {
        /*
         * Internal texture data structure not allocated yet.  Allocate it now.
         */
#ifndef OLDSTUFF
        hTexture = (HDDRVITEM)HEAPALLOC((HANDLE)pDriverData->hTextures_gbl,
                                sizeof(NVD3DTEXTURE));
#else
        hTexture = (HDDRVITEM)HeapAlloc((HANDLE)pDriverData->hTextures_gbl,
                                        HEAP_ZERO_MEMORY,
                                        sizeof(NVD3DTEXTURE));
#endif // #ifndef OLDSTUFF
        pTexture = (PNVD3DTEXTURE)hTexture;
        if (!pTexture)
        {
            /*
             * Could not allocate the internal data structure.  Cleanup and return the error.
             */
            gblDDS->fpVidMem        = (FLATPTR)NULL;
            gblDDS->dwReserved1     = (DWORD)NULL;
            lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Could not allocate internal data structure!");
            return (FALSE);
        }
        pDriverData->dwD3DTextureCount++;

        /*
         * Store the handle for the internal texture data structure in the driver reserved field.
         */
        lclDDS->dwReserved1 = hTexture;

        /*
         * Make sure a few key fields are intialized to zero.
         */
/* allocated with HEAP_ZERO_MEMORY - not needed
        pTexture->dwTexturePointer  = 0;
        pTexture->dwTextureOffset   = 0;
        pTexture->fpTexture         = 0;
        pTexture->hUserTexture      = 0;
        pTexture->fpUserTexture     = 0;
*/
        pTexture->dwDriverData      = (DWORD)pDriverData;

        /*
         * Update the texture list.
         */
        pTexture->pTexturePrev = (PNVD3DTEXTURE)NULL;
        pTexture->pTextureNext = (PNVD3DTEXTURE)pDriverData->dwTextureListHead;
        if (pTexture->pTextureNext)
            pTexture->pTextureNext->pTexturePrev = pTexture;
        pDriverData->dwTextureListHead = (DWORD)pTexture;
    }
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - pTexture = %08lx", pTexture);

    /*
     * Initialize texture information
     */
    pTexture->lpDriverObject       = lpCreateSurface->lpDD;
    pTexture->lpLcl                = lclDDS;
    pTexture->dwWidth              = texWidth;
    pTexture->dwHeight             = texHeight;
    pTexture->dwPitch              = (DWORD)lPitch;
    pTexture->dwMipMapBaseU        = logWidth;
    pTexture->dwMipMapBaseV        = logHeight;
    pTexture->dwMipMapSizeBytes    = texSizeBytes;
    pTexture->dwTextureColorFormat = dwTextureFormat;
#ifdef NV_TEX2
    pTexture->dwBPP                = dwBytesPerPixel;
    pTexture->dwMipMapLevels       = (dwTextureFlags & NV4_TEXFLAG_AUTOMIPMAP) ? 1 : mipmaplevels;
    pTexture->dwTextureFlags       = dwTextureFlags;
    pTexture->dwAutoMipMapScene    = NV4_TEXDEFAULT_AUTOMIPMAPTIME;
    if (pCurrentContext) pTexture->dwAutoMipMapScene += pCurrentContext->dwSceneCount;
    pTexture->dwAutoMipMapCount    = mipmaplevels;
    pTexture->dwDirtyX0            = pTexture->dwDirtyY0
                                   = 0;
    pTexture->dwDirtyX1            = pTexture->dwWidth;
    pTexture->dwDirtyY1            = pTexture->dwHeight;
    pTexture->dwLockUpdateCount    = 0;
    pTexture->dwBlitUpdateCount    = 0;
#else
    pTexture->dwUpdateCount        = 0;
    pTexture->dwMipMapLevels       = mipmaplevels;
    pTexture->dwTextureFlags       = dwTextureFlags | (bCanAutoMipMap ? NV4_TEXTURE_CAN_AUTO_MIPMAP : 0);
#endif

    /*
     * update user mip levels - this code assumes that the
     * base texture is already allocated
     */
#ifdef NV_TEX2
    if (dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL)
#else
    if (dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
#endif
    {
        DWORD                       dwMipMapLevel;
        DWORD                       dwMipMapOffset;
        PNVD3DTEXTURE               pMipBaseTexture;
        LPDDRAWI_DDRAWSURFACE_LCL   lclMip;

        /*
         * Find the base texture handle.
         */
        dwMipMapLevel = 1;
        lclMip = lclDDS->lpAttachListFrom->lpAttached;
        while (lclMip->lpAttachListFrom)
        {
            lclMip = lclMip->lpAttachListFrom->lpAttached;
            dwMipMapLevel++;
        }
        pTexture->hMipBaseTexture = lclMip->dwReserved1;

        /*
         * Calculate the starting offset and pointer for this
         * mipmap level.
         */
        pMipBaseTexture = (PNVD3DTEXTURE)pTexture->hMipBaseTexture;
        if (pMipBaseTexture)
        {
#ifdef NV_TEX2
            DWORD dwIndex = TEX_SWIZZLE_INDEX(pMipBaseTexture->dwTextureFlags);

            dwMipMapOffset = nvTextureCalcMipMapSize(pMipBaseTexture->dwMipMapBaseU,
                                                     pMipBaseTexture->dwMipMapBaseV,
                                                     dwMipMapLevel) * dwBytesPerPixel;
#else
            logCurrentU    = pMipBaseTexture->dwMipMapBaseU;
            logCurrentV    = pMipBaseTexture->dwMipMapBaseV;
            dwMipMapOffset = 0;
            for (j = dwMipMapLevel; j > 0; j--)
            {
                dwMipMapOffset += ((1 << logCurrentU) * dwBytesPerPixel) * (1 << logCurrentV);
                logCurrentU--;
                logCurrentV--;
            }
#endif //!NV_TEX2
            pTexture->dwTextureContextDma = pMipBaseTexture->dwTextureContextDma;

#ifdef NV_TEX2

            pTexture->dwTextureFlags  &= ~(NV4_TEXMASK_LINEAR_LOCATION | NV4_TEXFLAG_SWIZZLE_INDEX);
            pTexture->dwTextureFlags  |= dwIndex | (pMipBaseTexture->dwTextureFlags & NV4_TEXMASK_LINEAR_LOCATION);
            TEX_SWIZZLE_FLAGS(pTexture,dwIndex) = (TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & ~NV4_TEXMASK_LOCATION)
                                                | (TEX_SWIZZLE_FLAGS(pMipBaseTexture,dwIndex) & NV4_TEXMASK_LOCATION);
            pTexture->dwSwizzleOffset[dwIndex]  = pMipBaseTexture->dwSwizzleOffset[dwIndex] + dwMipMapOffset;

            pTexture->dwSwizzleAddr[dwIndex]    = GetTextureAddrFromOffset(pTexture->dwSwizzleOffset[dwIndex],TEX_SWIZZLE_FLAGS(pTexture,dwIndex) & NV4_TEXMASK_LOCATION);
#else
            pTexture->dwTextureOffset = pMipBaseTexture->dwTextureOffset + dwMipMapOffset;
            if (pMipBaseTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
            {
#ifndef WINNT
                pTexture->dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                pTexture->dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif
                pTexture->dwTextureFlags |= NV3_TEXTURE_VIDEO_MEMORY;
            }
            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    pTexture->dwTexturePointer = pMipBaseTexture->dwTexturePointer + dwMipMapOffset;
                else
                    pTexture->dwTexturePointer = GetPointerTextureHeap(pMipBaseTexture->dwTextureOffset) + dwMipMapOffset;
            }
#endif // !NV_TEX2
        }
    }
    else
        pTexture->hMipBaseTexture = 0;

    /*
     * Allocate the internal texture surface if it's not already allocated.
     */
#ifdef NV_TEX2
    if ((!TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
      && !(pTexture->dwTextureFlags & NV4_TEXFLAG_USER_MIP_LEVEL))
#else
    if ((!(pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED))
     && (!(pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)))
#endif
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        /*
         * Allocate memory for NV internal texture format buffer.
         */
        if (!nvAllocateInternalTexture(pTexture))
        {
            /*
             * Could not allocate the internal texture memory.  Cleanup and return the error.
             */
            gblDDS->fpVidMem        = (FLATPTR)NULL;
            gblDDS->dwReserved1     = (DWORD)NULL;
#ifndef NV_TEX2
            pTexture->hUserTexture  = (HANDLE)NULL;
            pTexture->fpUserTexture = (FLATPTR)NULL;
#endif
            nvDestroyTextureStructure(pTexture);
            lpCreateSurface->ddRVal = DDERR_OUTOFVIDEOMEMORY;
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Could not allocate internal texture memory!");
            NV_D3D_GLOBAL_SAVE();
            return (FALSE);
        }
#ifdef NV_TEX2
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - Internal Texture = %08lx", TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags));
#else
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - Internal Texture = %08lx", pTexture->dwTexturePointer);
#endif

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }

#ifdef HW_PAL8
    if (pTexture->dwTextureFlags & NV4_TEXFLAG_PALETTIZED)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        if (!pTexture->dwLinearAddr)
        {
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         NV4_TEXLOC_SYS,
                                         NV4_TEXLOC_SYS);
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }
#endif

#ifdef DIRECTSWIZZLE
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        if (!pTexture->dwLinearAddr)
        {
            /*
             * create a linear texture for staging - if this succeeds we will use
             * HW swizzling in the future
             */
            DWORD dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                               : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI));
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }
#endif //DIRECTSWIZZLE

#if 0
#ifdef NV_TEX2
    /*
     * if texture is dynamic, give it a linear copy - this way we do not have to wait for staging space
     */
    if ((lpCreateSurface->lpDDSurfaceDesc->dwSize >= sizeof(DDSURFACEDESC2))
     && (((DDSURFACEDESC2*)&lpCreateSurface->lpDDSurfaceDesc)->ddsCaps.dwCaps2 & DDSCAPS2_HINTDYNAMIC)) {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT

        if (!pTexture->dwLinearAddr)
        {
            /*
             * create a linear texture for staging - if this succeeds we will use
             * HW swizzling in the future
             */
            DWORD dwAllocFlags = (pDriverData->GARTLinearBase) ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP)
                                                               : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI);
            nvTextureAllocLinearSurface (pTexture,
                                         pTexture->dwPitch * pTexture->dwHeight,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI));
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();
    }
#endif  // NV_TEX2
#endif 0

#ifdef NV_TEX2
    /*
     * Set the fpVidMem pointer in the global surface structure to be the internal
     * texture memory pointer unless we already have a linear surface lying around
     */
#ifndef WINNT
    gblDDS->fpVidMem    = pTexture->dwLinearAddr ? pTexture->dwLinearAddr
                                                 : TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags);
#else
    gblDDS->fpVidMem    = pTexture->dwLinearAddr ? pTexture->dwLinearAddr
                                                 : TEX_SWIZZLE_OFFSET(pTexture,pTexture->dwTextureFlags);
#endif
#else
    /*
     * Set the fpVidMem pointer in the global surface structure to be the internal
     * texture memory pointer.  The only time that seperate user texture memory needs
     * to be allocated is in the event that the application is directly touching the
     * texture memory.  If all accesses to the texture are done using DDRAW, then there
     * is no need for a seperate copy of the texture in system memory since the texture
     * swizzling is now done at DDRAW Blit time.  If, however, the application locks the
     * texture surface, then seperate texture memory will need to be alloacted and the
     * the fpVidMem pointer will be switched at that point.
     */
    gblDDS->fpVidMem    = pTexture->dwTexturePointer;
#endif
    gblDDS->dwReserved1 = 0;

#ifndef NV_TEX2
    /*
     * Show that the texture surface has been allocated.
     */
    pTexture->dwTextureFlags |= NV3_TEXTURE_SURFACE_ALLOCATED;
#endif

    /*
     * If this is really an 8 bit palettized texture, then an extra system memory
     * texture surface needs to be allocated and some information in the surface structure
     * needs to be modified.
     */
    if ((dwSrcBitCount == 8) && (dwBytesPerPixel != 1))
    {
#ifdef NV_TEX2
        DWORD dwAllocFlags;
#endif
        NV_D3D_GLOBAL_SETUP();
        /*
         * Allocate the user system memory texture surface.
         */
        lPitch = texWidth;
        gblDDS->lPitch = lPitch;
        texSizeBytes = (DWORD)(lPitch * (LONG)texHeight);
#ifdef NV_TEX2
        dwAllocFlags = pDriverData->GARTLinearBase ? (NV4_TEXLOC_VID | NV4_TEXLOC_AGP | NV4_TEXLOC_SYS)
                                                   : (NV4_TEXLOC_VID | NV4_TEXLOC_PCI | NV4_TEXLOC_SYS);
        if (!nvTextureAllocLinearSurface(pTexture,
                                         texSizeBytes,
                                         dwAllocFlags,
                                         dwAllocFlags & (NV4_TEXLOC_AGP | NV4_TEXLOC_PCI)))
#else  // !NV_TEX2
        hMem = GlobalAlloc(GHND | GMEM_SHARE, texSizeBytes);
        if (!hMem)
#endif // !NV_TEX2
        {
            /*
             * Could not allocate the internal texture memory.  Cleanup and return the error.
             */
#ifndef NV_TEX2
            pTexture->hUserTexture  = (HANDLE)NULL;
            pTexture->fpUserTexture = (FLATPTR)NULL;
#endif
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - User texture memory allocation failed");
        }
        else
        {
            /*
             * Store the handle and pointer for the system memory surface in the global surface
             * data structure.
             */
#ifdef NV_TEX2
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - User Texture = %08lx", pTexture->dwLinearAddr);
#else
            gblDDS->fpVidMem          = (FLATPTR)GlobalLock(hMem);
            gblDDS->dwReserved1       = (DWORD)hMem;
            pTexture->hUserTexture    = hMem;
            pTexture->fpUserTexture   = gblDDS->fpVidMem;
            pTexture->dwTextureFlags |= NV3_TEXTURE_USER_ALLOCATED;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvCreateTextureSurface - User Texture = %08lx", pTexture->fpUserTexture);
#endif //!NV_TEX2
        }
        NV_D3D_GLOBAL_SAVE();
    }

    /*
     * Texture surface allocated successfully.
     */
    return (TRUE);
}

BOOL nvDestroyTextureSurface
(
    LPDDHAL_DESTROYSURFACEDATA  lpDestroySurface,
    LPDDRAWI_DDRAWSURFACE_LCL   lclDDS,
    LPDDRAWI_DDRAWSURFACE_GBL   gblDDS
)
{
    HGLOBAL         hMem;
    HDDRVITEM       hTexture;
    PNVD3DCONTEXT   pContext = 0;
    PNVD3DTEXTURE   pTexture = 0;

    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "nvDestroyTextureSurface - lclDDS = %08lx, gblDDS = %08lx", lclDDS, gblDDS);

    /*
     * Get the handle of the system memory texture surface.
     */
    hMem = (HGLOBAL)gblDDS->dwReserved1;

    /*
     * Get pointer to the texture being destroyed.
     */
    hTexture = lclDDS->dwReserved1;
    pTexture = (PNVD3DTEXTURE)hTexture;
    if (pTexture)
    {
        /*
         * Get pointer to the context.
         */
        pContext = (PNVD3DCONTEXT)pTexture->hContext;
        if (pContext)
        {
            /*
             * Make sure the context does not refer to the texture being destroyed.
             */
            if (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] == hTexture)
                pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

#ifndef NV_TEX2
        /*
         * Mark the texture surface as de-allocated.
         */
        pTexture->dwTextureFlags &= ~NV3_TEXTURE_SURFACE_ALLOCATED;
#endif

        /*
         * Free any memory that is currently allocated.
         */
#ifdef NV_TEX2
        if (pTexture->dwLinearAddr)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free User Texture = %08lx", pTexture->dwLinearAddr);
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
            nvTextureFreeLinearSurface (pTexture);
            NV_D3D_GLOBAL_SAVE();
        }
        if (TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags))
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free Internal Texture = %08lx", TEX_SWIZZLE_ADDR(pTexture,pTexture->dwTextureFlags));
            NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
            nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
            NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_ROP, sizeSet2DSurfacesDestination);
#endif  // CACHE_FREECOUNT
            nvTextureFreeSwizzleSurface (pTexture);
            NV_D3D_GLOBAL_SAVE();
        }
#else // !NV_TEX2
        /* Under WINNT, defer destruction of user allocated texture surface
         * until the texture handle is destroyed. We can't free the user
         * address here since we may not be running in the context of the
         * process which created the texture.
         */
#ifndef WINNT
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free User Texture = %08lx", pTexture->fpUserTexture);
            pTexture->dwTextureFlags &= ~NV3_TEXTURE_USER_ALLOCATED;
            GlobalUnlock(hMem);
            GlobalFree(hMem);
        }
#endif // #ifndef WINNT
        if (pTexture->dwTextureFlags & NV3_TEXTURE_INTERNAL_ALLOCATED)
        {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free Internal Texture = %08lx", pTexture->dwTexturePointer);
            NV_D3D_GLOBAL_SETUP();
            nvDestroyInternalTexture(pContext, pTexture);
            NV_D3D_GLOBAL_SAVE();
       }
#endif // !NV_TEX2

        /*
         * Do a little cleanup.
         */
        gblDDS->fpVidMem           = 0;
        gblDDS->dwReserved1        = 0;
#ifndef NV_TEX2
        pTexture->hUserTexture     = 0;
        pTexture->fpUserTexture    = 0;
        pTexture->dwTexturePointer = 0;
        pTexture->dwTextureOffset  = 0;
#endif
        pTexture->lpLcl            = 0;

        /*
         * Only destroy the internal texture data structure if the texture handle has already
         * been de-allocated.
         */
#ifdef NV_TEX2
        if (!(pTexture->dwTextureFlags & NV4_TEXFLAG_HANDLE_ALLOCATED))
#else
        if (!(pTexture->dwTextureFlags & NV3_TEXTURE_HANDLE_ALLOCATED))
#endif
        {
            /*
             * Setup frequently accessed globals.
             */
            NV_D3D_GLOBAL_SETUP();

            /*
             * Free the memory allocated for the internal texture data structure.
             */
            DPF_LEVEL(NVDBG_LEVEL_INFO, "nvDestroyTextureSurface - Free Texture Structure = %08lx", pTexture);
            nvDestroyTextureStructure(pTexture);
            lclDDS->dwReserved1 = (DWORD)NULL;
            NV_D3D_GLOBAL_SAVE();
        }
    }
    else
    {
        /*
         * Free the system memory texture surface.
         */
        if (hMem)
        {
            GlobalUnlock(hMem);
            GlobalFree(hMem);
        }
        gblDDS->fpVidMem    = 0;
        gblDDS->dwReserved1 = 0;
    }

    /*
     * Return successful return codes.
     */
    lpDestroySurface->ddRVal = DD_OK;
    return (TRUE);
}

#ifndef NV_TEX2

void nvSwizzleBlit16Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstPitch,
    DWORD   dwDstLinearBase,
    DWORD   dwDstSwizzleBase,
    DWORD   dwTextureFormat
)
{
    WORD    wSrcTexel;
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    DWORD   xDstCurrent, yDstCurrent;
    DWORD   dwSrcTexel;
    unsigned short *pSrcLinear;
    unsigned short *pDstLinear;
    unsigned short *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned short *)dwDstSwizzleBase;
    // X1 is exclusive, so if X1 is even, then the real last texel is on an odd boundry.
    switch (((dwSrcX0 & 0x01) << 1) | (dwSrcX1 & 0x01))
    {
        /*
         * Even start, even end.
         */
        case 0:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                while (xSrcCurrent < dwSrcX1)
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Even start, odd end.
         */
        case 1:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
            }
            break;

        /*
         * Odd start, even end.
         */
        case 2:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
                xSrcCurrent++;
                xDstCurrent++;
                u = UV_INC(u, uInc, uMask);
                while (xSrcCurrent < dwSrcX1)
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
            }
            break;

        /*
         * Odd start, odd end.
         */
        case 3:
            // X1, Y1 are exclusive.
            for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
                 ySrcCurrent < dwSrcY1;
                 ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
            {
                pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
                pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
                xSrcCurrent = dwSrcX0;
                xDstCurrent = dwDstX0;
                u = u0;
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
                xSrcCurrent++;
                xDstCurrent++;
                u = UV_INC(u, uInc, uMask);
                // X1 is exclusive, so need to bail out of inner loop before doing last texel.
                while (xSrcCurrent < (dwSrcX1 - 1))
                {
                    dwSrcTexel = *(DWORD *)(&pSrcLinear[xSrcCurrent]);
                    *(DWORD *)(&pDstSwizzle[UV_OFFSET(u,v)]) = dwSrcTexel;
                    *(DWORD *)(&pDstLinear[xDstCurrent])     = dwSrcTexel;
                    xSrcCurrent += 2;
                    xDstCurrent += 2;
                    u = UV_INC(u, uInc2, uMask);
                }
                wSrcTexel = pSrcLinear[xSrcCurrent];
                pDstSwizzle[UV_OFFSET(u,v)] = wSrcTexel;
                pDstLinear[xDstCurrent]     = wSrcTexel;
            }
            break;
    }
}

void nvSwizzleBlit32Bpp
(
    DWORD   dwSrcX0,
    DWORD   dwSrcY0,
    DWORD   dwSrcX1,
    DWORD   dwSrcY1,
    DWORD   dwWidth,
    DWORD   dwHeight,
    DWORD   dwSrcPitch,
    DWORD   dwSrcLinearBase,
    DWORD   dwDstX0,
    DWORD   dwDstY0,
    DWORD   dwDstPitch,
    DWORD   dwDstLinearBase,
    DWORD   dwDstSwizzleBase,
    DWORD   dwTextureFormat
)
{
    DWORD   u0, u, v;
    DWORD   uInc, uInc2, vInc, uMask, vMask;
    DWORD   xSrcCurrent, ySrcCurrent;
    DWORD   xDstCurrent, yDstCurrent;
    DWORD   dwSrcTexel;
    unsigned long *pSrcLinear;
    unsigned long *pDstLinear;
    unsigned long *pDstSwizzle;

    U_INTERLEAVE(u0, dwDstX0, dwWidth, dwHeight);
    V_INTERLEAVE(v,  dwDstY0, dwWidth, dwHeight);
    U_INC2_MASK(uInc, uInc2, uMask, dwHeight);
    V_INC_MASK(vInc, vMask, dwWidth);
    pDstSwizzle = (unsigned long *)dwDstSwizzleBase;
    for (ySrcCurrent = dwSrcY0, yDstCurrent = dwDstY0;
         ySrcCurrent < dwSrcY1;
         ySrcCurrent++, yDstCurrent++, v = UV_INC(v, vInc, vMask))
    {
        pSrcLinear = (unsigned long *)(dwSrcLinearBase + (ySrcCurrent * dwSrcPitch));
        pDstLinear = (unsigned long *)(dwDstLinearBase + (yDstCurrent * dwDstPitch));
        xSrcCurrent = dwSrcX0;
        xDstCurrent = dwDstX0;
        u = u0;
        while (xSrcCurrent < dwSrcX1)
        {
            dwSrcTexel = pSrcLinear[xSrcCurrent];
            pDstSwizzle[UV_OFFSET(u,v)]   = dwSrcTexel;
            pDstLinear[xDstCurrent]       = dwSrcTexel;
            dwSrcTexel = pSrcLinear[xSrcCurrent+1];
            pDstSwizzle[UV_OFFSET(u,v)+1] = dwSrcTexel;
            pDstLinear[xDstCurrent+1]     = dwSrcTexel;
            xSrcCurrent += 2;
            xDstCurrent += 2;
            u = UV_INC(u, uInc2, uMask);
        }
    }
}

void nvTextureBlit8Bpp
(
    LPDDHAL_BLTDATA pbd
)
{
    unsigned long               dwSrcLinearBase, dwDstLinearBase;
    unsigned char              *pSrcLinear;
    unsigned char              *pDstLinear;
    long                        xWidth, yHeight;
    PNVD3DTEXTURE               pBaseTexture = 0;
    PNVD3DTEXTURE               pTexture = 0;
    BOOL                        bLuminanceTexture = FALSE;
    DWORD                       dwSrcX0, dwSrcY0;
    DWORD                       dwSrcX1, dwSrcY1;
    DWORD                       dwSrcPitch;
    DWORD                       dwSrcWidth;
    DWORD                       dwSrcHeight;
    DWORD                       dwSrcLimit;
    DWORD                       dwDstX0, dwDstY0;
    DWORD                       dwDstX1, dwDstY1;
    DWORD                       dwDstPitch;
    DWORD                       dwDstWidth;
    DWORD                       dwDstHeight;
    DWORD                       dwDstLimit;
    DWORD                       dwTexturePointer = 0;
    DWORD                       dwTextureFormat  = 0;
    DWORD                       dwSrcBitCount;
    DWORD                       dwDstBitCount;
    DWORD                       xSrc, ySrc, xDst, yDst;
    DWORD                       dwColor;
    DWORD                       u, v;
    LPPALETTEENTRY              pPalette;
    BYTE                        bIndex;
    LPDDRAWI_DDRAWSURFACE_LCL   lclSrcDDS;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDstDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblSrcDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDstDDS;

    /*
     * Get source surface information.
     */
    lclSrcDDS       = pbd->lpDDSrcSurface;
    gblSrcDDS       = lclSrcDDS->lpGbl;
    dwSrcPitch      = gblSrcDDS->lPitch;
    dwSrcLinearBase = (unsigned long)gblSrcDDS->fpVidMem;
    dwSrcLimit      = (dwSrcPitch * (DWORD)gblSrcDDS->wHeight) - 1;
    if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwRGBBitCount;
    else if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_LUMINANCE)
    {
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwLuminanceBitCount;
        bLuminanceTexture = TRUE;
    }
    else
        dwSrcBitCount = pDriverData->bi.biBitCount;

    /*
     * Get destination surface information.
     */
    lclDstDDS       = pbd->lpDDDestSurface;
    gblDstDDS       = lclDstDDS->lpGbl;
    dwDstPitch      = gblDstDDS->lPitch;
    dwDstLinearBase = (unsigned long)gblDstDDS->fpVidMem;
    dwDstLimit      = (dwDstPitch * (DWORD)gblDstDDS->wHeight) - 1;
    if (gblDstDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwDstBitCount = gblDstDDS->ddpfSurface.dwRGBBitCount;
    else if (gblDstDDS->ddpfSurface.dwFlags & DDPF_LUMINANCE)
    {
        dwSrcBitCount = gblDstDDS->ddpfSurface.dwLuminanceBitCount;
        bLuminanceTexture = TRUE;
    }
    else
        dwDstBitCount = pDriverData->bi.biBitCount;

    if ((dwSrcBitCount != dwDstBitCount)
     || (dwSrcBitCount != 8))
    {
        /*
         * Not supporting bit depth conversion blits.
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlit8Bpp - Source and destination have different bit depths!!");
        dbgD3DError();
        return;
    }

    /*
     * Get the pointer to the internal texture structure.
     */
    pTexture = (PNVD3DTEXTURE)lclDstDDS->dwReserved1;

    /*
     * Get the pointer to the internal texture surface.
     */
    if (pTexture)
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
            dwTexturePointer = pTexture->dwTexturePointer;
        else
        {
            if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
#ifndef WINNT
                dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif // #ifdef WINNT
            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    dwTexturePointer = pTexture->dwTexturePointer;
                else
                    dwTexturePointer = GetPointerTextureHeap(pTexture->dwTextureOffset);
            }
        }
    }

    /*
     * Get the blit postion.
     */
    dwSrcX0 = pbd->rSrc.left;
    dwSrcX1 = pbd->rSrc.right;
    dwSrcY0 = pbd->rSrc.top;
    dwSrcY1 = pbd->rSrc.bottom;
    dwDstX0 = pbd->rDest.left;
    dwDstY0 = pbd->rDest.top;
    dwDstX1 = pbd->rDest.right;
    dwDstY1 = pbd->rDest.bottom;

    /*
     * Calculate the width and height of the blit.
     */
    dwSrcWidth  = dwSrcX1 - dwSrcX0;
    dwSrcHeight = dwSrcY1 - dwSrcY0;
    dwDstWidth  = dwDstX1 - dwDstX0;
    dwDstHeight = dwDstY1 - dwDstY1;
    xWidth      = (dwDstWidth  <= dwSrcWidth)  ? dwDstWidth  : dwSrcWidth;
    yHeight     = (dwDstHeight <= dwSrcHeight) ? dwDstHeight : dwSrcHeight;

    if (bLuminanceTexture)
    {
        pPalette = 0;
    }
    else
    {
#ifndef WINNT // BUGBUG - Under WINNT, where's the palette?
        if ((!lclDstDDS->lpDDPalette)
         || (!lclDstDDS->lpDDPalette->lpLcl)
         || (!lclDstDDS->lpDDPalette->lpLcl->lpGbl)
         || (!lclDstDDS->lpDDPalette->lpLcl->lpGbl->lpColorTable))
        {
            if (pTexture)
                pTexture->dwTextureFlags |= NV3_TEXTURE_MODIFIED;
            pPalette = 0;
        }
        else
            pPalette = lclDstDDS->lpDDPalette->lpLcl->lpGbl->lpColorTable;
#endif // #ifndef WINNT
    }

    /*
     * Display the source texture on the screen. (DEBUG only)
     */
    dbgDisplayLinearTexture(lclSrcDDS, lclDstDDS, pTexture->dwTextureColorFormat);

    if (bLuminanceTexture)
    {
        unsigned char   *pDstSwizzle;
        unsigned char   bColor;

        /*
         * Straight 8bit swizzle.
         */
        pDstSwizzle = (unsigned char *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bColor = pSrcLinear[xSrc];
                U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                pDstSwizzle[UV_OFFSET(u,v)] = bColor;
            }
        }
    }
    else if (pDriverData->regPal8TextureConvert == REG_P8TC_8TOR5G6B5)
    {
        unsigned short             *pDstSwizzle;
        WORD                        wColor;
        pDstSwizzle = (unsigned short *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            pDstLinear = (char *)(dwDstLinearBase + (yDst * dwDstPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bIndex = pSrcLinear[xSrc];
                pDstLinear[xDst] = bIndex;
                if (pPalette)
                {
                    wColor = ((WORD)(pPalette[bIndex].peRed & 0xF8) << 8)
                           | ((WORD)(pPalette[bIndex].peGreen & 0xFC) << 3)
                           | ((WORD)(pPalette[bIndex].peBlue & 0xF8) >> 3);
                    U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                    pDstSwizzle[UV_OFFSET(u,v)] = wColor;
                }
            }
        }
    }
    else if ((pDriverData->regPal8TextureConvert == REG_P8TC_8TOX1R5G5B5)
          || (pDriverData->regPal8TextureConvert == REG_P8TC_8TOA1R5G5B5))
    {
        unsigned short             *pDstSwizzle;
        WORD                        wColor;
        pDstSwizzle = (unsigned short *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            pDstLinear = (char *)(dwDstLinearBase + (yDst * dwDstPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bIndex = pSrcLinear[xSrc];
                pDstLinear[xDst] = bIndex;
                if (pPalette)
                {
                    wColor = ((WORD)(pPalette[bIndex].peRed & 0xF8) << 7)
                           | ((WORD)(pPalette[bIndex].peGreen & 0xF8) << 2)
                           | ((WORD)(pPalette[bIndex].peBlue & 0xF8) >> 3)
                           | 0x8000;
                    U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                    pDstSwizzle[UV_OFFSET(u,v)] = wColor;
                }
            }
        }
    }
    else if ((pDriverData->regPal8TextureConvert == REG_P8TC_8TOX8R8G8B8)
          || (pDriverData->regPal8TextureConvert == REG_P8TC_8TOX8R8G8B8))
    {
        unsigned long              *pDstSwizzle;
        pDstSwizzle = (unsigned long *)dwTexturePointer;
        for (ySrc = dwSrcY0, yDst = dwDstY0; ySrc < dwSrcY1; ySrc++, yDst++)
        {
            pSrcLinear = (char *)(dwSrcLinearBase + (ySrc * dwSrcPitch));
            pDstLinear = (char *)(dwDstLinearBase + (yDst * dwDstPitch));
            V_INTERLEAVE(v,  yDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
            for (xSrc = dwSrcX0, xDst = dwDstX0; xSrc < dwSrcX1; xSrc++, xDst++)
            {
                bIndex = pSrcLinear[xSrc];
                pDstLinear[xDst] = bIndex;
                if (pPalette)
                {
                    dwColor = ((DWORD)(pPalette[bIndex].peRed) << 16)
                            | ((DWORD)(pPalette[bIndex].peGreen) << 8)
                            | (DWORD)(pPalette[bIndex].peBlue)
                            | 0xFF000000;
                    U_INTERLEAVE(u,  xDst, gblDstDDS->wWidth, gblDstDDS->wHeight);
                    pDstSwizzle[UV_OFFSET(u,v)] = dwColor;
                }
            }
        }
    }
    dbgDisplayTexture((PNVD3DCONTEXT)pTexture->hContext, pTexture);
}

void nvTextureBlit16Bpp
(
    LPDDHAL_BLTDATA pbd
)
{
    unsigned long               dwSrcLinearBase, dwDstLinearBase;
    unsigned short             *pSrcLinear;
    unsigned short             *pDstLinear;
    long                        xCount, yCount;
    long                        xWidth, yHeight;
    PNVD3DTEXTURE               pBaseTexture = 0;
    PNVD3DTEXTURE               pTexture = 0;
    DWORD                       ySrcCurrent;
    DWORD                       yDstCurrent;
    DWORD                       dwSrcX0, dwSrcY0;
    DWORD                       dwSrcX1, dwSrcY1;
    DWORD                       dwSrcPitch;
    DWORD                       dwSrcWidth;
    DWORD                       dwSrcHeight;
    DWORD                       dwSrcLimit;
    DWORD                       dwDstX0, dwDstY0;
    DWORD                       dwDstX1, dwDstY1;
    DWORD                       dwDstPitch;
    DWORD                       dwDstWidth;
    DWORD                       dwDstHeight;
    DWORD                       dwDstLimit;
    DWORD                       dwTexturePointer = 0;
    DWORD                       dwTextureFormat  = 0;
    DWORD                       dwSrcBitCount;
    DWORD                       dwDstBitCount;
    LPDDRAWI_DDRAWSURFACE_LCL   lclSrcDDS;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDstDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblSrcDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDstDDS;

    /*
     * Get source surface information.
     */
    lclSrcDDS       = pbd->lpDDSrcSurface;
    gblSrcDDS       = lclSrcDDS->lpGbl;
    dwSrcPitch      = gblSrcDDS->lPitch;
    dwSrcLinearBase = (unsigned long)gblSrcDDS->fpVidMem;
    dwSrcLimit      = (dwSrcPitch * (DWORD)gblSrcDDS->wHeight) - 1;
    if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwRGBBitCount;
    else
        dwSrcBitCount = pDriverData->bi.biBitCount;

    /*
     * Get destination surface information.
     */
    lclDstDDS       = pbd->lpDDDestSurface;
    gblDstDDS       = lclDstDDS->lpGbl;
    dwDstPitch      = gblDstDDS->lPitch;
    dwDstLinearBase = (unsigned long)gblDstDDS->fpVidMem;
    dwDstLimit      = (dwDstPitch * (DWORD)gblDstDDS->wHeight) - 1;
    if (gblDstDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwDstBitCount = gblDstDDS->ddpfSurface.dwRGBBitCount;
    else
        dwDstBitCount = pDriverData->bi.biBitCount;

    if (dwSrcBitCount != dwSrcBitCount)
    {
        /*
         * Not supporting bit depth conversion blits.
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlit16Bpp - Source and destination have different bit depths!!");
        dbgD3DError();
        return;
    }
    else if (dwSrcBitCount == 32)
    {
        nvTextureBlit32Bpp(pbd);
        return;
    }
    else if (dwSrcBitCount == 8)
    {
        nvTextureBlit8Bpp(pbd);
        return;
    }

    /*
     * Check for a non-square texture.
     */
    if (gblDstDDS->wWidth != gblDstDDS->wHeight)
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureBlit16bpp - Non-Square Texture!!");

    /*
     * Get the pointer to the internal texture structure.
     */
    pTexture = (PNVD3DTEXTURE)lclDstDDS->dwReserved1;

    /*
     * Get the pointer to the internal texture surface.
     */
    if (pTexture)
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
            dwTexturePointer = pTexture->dwTexturePointer;
        else
        {
            if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
#ifndef WINNT
                dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif // #ifdef WINNT

            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    dwTexturePointer = pTexture->dwTexturePointer;
                else
                    dwTexturePointer = GetPointerTextureHeap(pTexture->dwTextureOffset);
            }
        }
    }

    /*
     * Get the blit postion.
     */
    dwSrcX0 = pbd->rSrc.left;
    dwSrcX1 = pbd->rSrc.right;
    dwSrcY0 = pbd->rSrc.top;
    dwSrcY1 = pbd->rSrc.bottom;
    dwDstX0 = pbd->rDest.left;
    dwDstY0 = pbd->rDest.top;
    dwDstX1 = pbd->rDest.right;
    dwDstY1 = pbd->rDest.bottom;

    /*
     * Calculate the width and height of the blit.
     */
    dwSrcWidth  = dwSrcX1 - dwSrcX0;
    dwSrcHeight = dwSrcY1 - dwSrcY0;
    dwDstWidth  = dwDstX1 - dwDstX0;
    dwDstHeight = dwDstY1 - dwDstY1;
    xWidth      = (dwDstWidth  <= dwSrcWidth)  ? dwDstWidth  : dwSrcWidth;
    yHeight     = (dwDstHeight <= dwSrcHeight) ? dwDstHeight : dwSrcHeight;

    /*
     * Display the source texture on the screen. (DEBUG only)
     */
    dbgDisplayLinearTexture(lclSrcDDS, lclDstDDS, pTexture->dwTextureColorFormat);

    /*
     * If there's a valid pointer to an internal texture surface, then a dual
     * internal/user texture blit can be performed.
     */
    if (dwTexturePointer)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
#endif  // CACHE_FREECOUNT

        dwTextureFormat = pTexture->dwTextureColorFormat;

        /*
         * Decide what kind of texture blit to do.
         */
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
        {
            /*
             * The application has locked the surface so there are two
             * copies of the texture to update.
             * If the swizzled texture is in video memory:
             * First do a fast linear copy from the source surface to the
             * linear user surface, then use the hardware to swizzle the
             * texture.
             * If the swizzled texture is in non-local video memory:
             * Do the swizzle and the linear blit at the same time.
             *
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                /*
                 * Now use hardware to do the swizzle from user texture memory.
                 */
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     dwDstLinearBase,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                nvSwizzleBlit16Bpp((DWORD)dwSrcX0,
                                   (DWORD)dwSrcY0,
                                   (DWORD)dwSrcX1,
                                   (DWORD)dwSrcY1,
                                   (DWORD)gblDstDDS->wWidth,
                                   (DWORD)gblDstDDS->wHeight,
                                   (DWORD)dwSrcPitch,
                                   (DWORD)dwSrcLinearBase,
                                   (DWORD)dwDstX0,
                                   (DWORD)dwDstY0,
                                   (DWORD)dwDstPitch,
                                   (DWORD)dwDstLinearBase,
                                   (DWORD)dwTexturePointer,
                                   (DWORD)dwTextureFormat);
            }
        }
        else
        {
            /*
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     0,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                /*
                 * This is a good application.  It's not locking and touching the texture directly
                 * so there is only one copy of the texture to deal with.  Only need to swizzle the
                 * texture to the internal texture memory.
                 */
                nvSwizzleTexture16Bpp((DWORD)dwSrcX0,
                                      (DWORD)dwSrcY0,
                                      (DWORD)dwSrcX1,
                                      (DWORD)dwSrcY1,
                                      (DWORD)gblDstDDS->wWidth,
                                      (DWORD)gblDstDDS->wHeight,
                                      (DWORD)dwSrcPitch,
                                      (DWORD)dwSrcLinearBase,
                                      (DWORD)dwDstX0,
                                      (DWORD)dwDstY0,
                                      (DWORD)dwTexturePointer);
            }

            /*
             * Only the internal texture surface has been modified.  If a lock on this texture
             * comes through then it will be neccessary to de-swizzle the internal texture
             * to the user texture memory, so set the flag that shows this has happened.
             */
            pTexture->dwTextureFlags  |= NV3_TEXTURE_BLIT_UPDATE;
        }
        pTexture->fpTexture        = (FLATPTR)dwDstLinearBase;
        pTexture->dwTextureFlags  &= ~(NV3_TEXTURE_MODIFIED | NV3_TEXTURE_MUST_RELOAD);

        /*
         * Auto generate mipmaps
         */
        if (pTexture->dwTextureFlags & NV4_TEXTURE_AUTOMIPMAPPED)
        {
            nvTextureAutoMipMap (pTexture);
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();

#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

        /*
         * Display the texture surface to the current display buffer (debug only).
         */
        dbgDisplayTexture((PNVD3DCONTEXT)pTexture->hContext, pTexture);
    }
    else
    {
        /*
         * Set up the starting postion of the blit.
         */
        yDstCurrent = dwDstY0;
        ySrcCurrent = dwSrcY0;

        /*
         * Don't have an internal texture suface, so just do the blit to
         * the user texture surface.
         */
        for (yCount = 0; yCount < yHeight; yCount++)
        {
            pSrcLinear = (unsigned short *)(dwSrcLinearBase + (ySrcCurrent++ * dwSrcPitch));
            pDstLinear = (unsigned short *)(dwDstLinearBase + (yDstCurrent++ * dwDstPitch));
            for (xCount = 0; xCount < xWidth; xCount++)
                pDstLinear[dwDstX0 + xCount] = pSrcLinear[dwSrcX0 + xCount];
        }
    }

    return;
}
void nvTextureBlit32Bpp
(
    LPDDHAL_BLTDATA pbd
)
{
    unsigned long               dwSrcLinearBase, dwDstLinearBase;
    unsigned long              *pSrcLinear;
    unsigned long              *pDstLinear;
    long                        xCount, yCount;
    long                        xWidth, yHeight;
    PNVD3DTEXTURE               pBaseTexture = 0;
    PNVD3DTEXTURE               pTexture = 0;
    DWORD                       ySrcCurrent;
    DWORD                       yDstCurrent;
    DWORD                       dwSrcX0, dwSrcY0;
    DWORD                       dwSrcX1, dwSrcY1;
    DWORD                       dwSrcPitch;
    DWORD                       dwSrcWidth;
    DWORD                       dwSrcHeight;
    DWORD                       dwSrcLimit;
    DWORD                       dwDstX0, dwDstY0;
    DWORD                       dwDstX1, dwDstY1;
    DWORD                       dwDstPitch;
    DWORD                       dwDstWidth;
    DWORD                       dwDstHeight;
    DWORD                       dwDstLimit;
    DWORD                       dwTexturePointer = 0;
    DWORD                       dwTextureFormat = 0;
    DWORD                       dwSrcBitCount;
    DWORD                       dwDstBitCount;
    LPDDRAWI_DDRAWSURFACE_LCL   lclSrcDDS;
    LPDDRAWI_DDRAWSURFACE_LCL   lclDstDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblSrcDDS;
    LPDDRAWI_DDRAWSURFACE_GBL   gblDstDDS;

    /*
     * Get source surface information.
     */
    lclSrcDDS       = pbd->lpDDSrcSurface;
    gblSrcDDS       = lclSrcDDS->lpGbl;
    dwSrcPitch      = gblSrcDDS->lPitch;
    dwSrcLinearBase = (unsigned long)gblSrcDDS->fpVidMem;
    dwSrcLimit      = (dwSrcPitch * (DWORD)gblSrcDDS->wHeight) - 1;
    if (gblSrcDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwSrcBitCount = gblSrcDDS->ddpfSurface.dwRGBBitCount;
    else
        dwSrcBitCount = pDriverData->bi.biBitCount;

    /*
     * Get destination surface information.
     */
    lclDstDDS       = pbd->lpDDDestSurface;
    gblDstDDS       = lclDstDDS->lpGbl;
    dwDstPitch      = gblDstDDS->lPitch;
    dwDstLinearBase = (unsigned long)gblDstDDS->fpVidMem;
    dwDstLimit      = (dwDstPitch * (DWORD)gblDstDDS->wHeight) - 1;
    if (gblDstDDS->ddpfSurface.dwFlags & DDPF_RGB)
        dwDstBitCount = gblDstDDS->ddpfSurface.dwRGBBitCount;
    else
        dwDstBitCount = pDriverData->bi.biBitCount;

    if (dwSrcBitCount != dwSrcBitCount)
    {
        /*
         * Not supporting bit depth conversion blits.
         */
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureBlit32Bpp - Source and destination have different bit depths!!");
        dbgD3DError();
        return;
    }
    else if (dwSrcBitCount == 16)
    {
        nvTextureBlit16Bpp(pbd);
        return;
    }
    else if (dwSrcBitCount == 8)
    {
        nvTextureBlit8Bpp(pbd);
        return;
    }

    /*
     * Check for a non-square texture.
     */
    if (gblDstDDS->wWidth != gblDstDDS->wHeight)
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureBlit32bpp - Non-Square Texture!!");

    /*
     * Get the pointer to the internal texture structure.
     */
    pTexture = (PNVD3DTEXTURE)lclDstDDS->dwReserved1;

    /*
     * Get the pointer to the internal texture surface.
     */
    if (pTexture)
    if (pTexture)
    {
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_MIP_LEVEL)
            dwTexturePointer = pTexture->dwTexturePointer;
        else
        {
            if (pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
#ifndef WINNT
                dwTexturePointer = pDriverData->BaseAddress + pTexture->dwTextureOffset;
#else
                dwTexturePointer = pDriverData->ppdev->pjScreen + pTexture->dwTextureOffset;
#endif // #ifdef WINNT
            else
            {
                if (pDriverData->GARTLinearBase > 0)
                    dwTexturePointer = pTexture->dwTexturePointer;
                else
                    dwTexturePointer = GetPointerTextureHeap(pTexture->dwTextureOffset);
            }
        }
    }

    /*
     * Get the blit postion.
     * NOTE: X1 and Y1 are exclusive!!
     */
    dwSrcX0 = pbd->rSrc.left;
    dwSrcX1 = pbd->rSrc.right;
    dwSrcY0 = pbd->rSrc.top;
    dwSrcY1 = pbd->rSrc.bottom;
    dwDstX0 = pbd->rDest.left;
    dwDstY0 = pbd->rDest.top;
    dwDstX1 = pbd->rDest.right;
    dwDstY1 = pbd->rDest.bottom;

    /*
     * Calculate the width and height of the blit.
     */
    dwSrcWidth  = dwSrcX1 - dwSrcX0;
    dwSrcHeight = dwSrcY1 - dwSrcY0;
    dwDstWidth  = dwDstX1 - dwDstX0;
    dwDstHeight = dwDstY1 - dwDstY1;
    xWidth      = (dwDstWidth  <= dwSrcWidth)  ? dwDstWidth  : dwSrcWidth;
    yHeight     = (dwDstHeight <= dwSrcHeight) ? dwDstHeight : dwSrcHeight;

    /*
     * Display the source texture on the screen. (DEBUG only)
     */
    dbgDisplayLinearTexture(lclSrcDDS, lclDstDDS, pTexture->dwTextureColorFormat);

    /*
     * If there's a valid pointer to an internal texture surface, then a dual
     * internal/user texture blit can be performed.
     */
    if (dwTexturePointer)
    {
        /*
         * Setup frequently accessed globals.
         */
        NV_D3D_GLOBAL_SETUP();
#ifdef  CACHE_FREECOUNT
        nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetObject);
#endif  // CACHE_FREECOUNT

        dwTextureFormat = pTexture->dwTextureColorFormat;

        /*
         * Decide what kind of texture blit to do.
         */
        if (pTexture->dwTextureFlags & NV3_TEXTURE_USER_ALLOCATED)
        {
            /*
             * The application has locked the surface so there are two
             * copies of the texture to update.
             * If the swizzled texture is in video memory:
             * First do a fast linear copy from the source surface to the
             * linear user surface, then use the hardware to swizzle the
             * texture.
             * If the swizzled texture is in non-local video memory:
             * Do the swizzle and the linear blit at the same time.
             *
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                /*
                 * Now use hardware to do the swizzle from user texture memory.
                 */
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     dwDstLinearBase,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                nvSwizzleBlit32Bpp((DWORD)dwSrcX0,
                                   (DWORD)dwSrcY0,
                                   (DWORD)dwSrcX1,
                                   (DWORD)dwSrcY1,
                                   (DWORD)gblDstDDS->wWidth,
                                   (DWORD)gblDstDDS->wHeight,
                                   (DWORD)dwSrcPitch,
                                   (DWORD)dwSrcLinearBase,
                                   (DWORD)dwDstX0,
                                   (DWORD)dwDstY0,
                                   (DWORD)dwDstPitch,
                                   (DWORD)dwDstLinearBase,
                                   (DWORD)dwTexturePointer,
                                   (DWORD)dwTextureFormat);
            }
        }
        else
        {
            /*
             * Hardware Restrictions require the destination texture offset to be 32 byte aligned
             * and the source width to be 2 or more.  If this isn't the case must use software to
             * do the swizzling.
             * The only time the offset should be misaligned at this point is for mipmap levels of
             * 2x2 and 1x1.
             */
            if ((pTexture->dwTextureFlags & NV3_TEXTURE_VIDEO_MEMORY)
             && (pDriverData->NvDevFlatDma)
             && ((pTexture->dwTextureOffset & 0x0000001F) == 0)
             && (dwSrcWidth > 1))
            {
                nvTMVideoTextureBlt (dwSrcLinearBase,dwSrcPitch,dwSrcX0,dwSrcY0,dwSrcX1,dwSrcY1,
                                     0,dwDstPitch,dwDstX0,dwDstY0,
                                     pTexture->dwTextureOffset,
                                     (WORD)pTexture->dwMipMapBaseU, (WORD)pTexture->dwMipMapBaseV,
                                     dwTextureFormat);
            }
            else
            {
                /*
                 * This is a good application.  It's not locking and touching the texture directly
                 * so there is only one copy of the texture to deal with.  Only need to swizzle the
                 * texture to the internal texture memory.
                 */
                nvSwizzleTexture32Bpp((DWORD)dwSrcX0,
                                      (DWORD)dwSrcY0,
                                      (DWORD)dwSrcX1,
                                      (DWORD)dwSrcY1,
                                      (DWORD)gblDstDDS->wWidth,
                                      (DWORD)gblDstDDS->wHeight,
                                      (DWORD)dwSrcPitch,
                                      (DWORD)dwSrcLinearBase,
                                      (DWORD)dwDstX0,
                                      (DWORD)dwDstY0,
                                      (DWORD)dwTexturePointer);
            }

            /*
             * Only the internal texture surface has been modified.  If a lock on this texture
             * comes through then it will be neccessary to de-swizzle the internal texture
             * to the user texture memory, so set the flag that shows this has happened.
             */
            pTexture->dwTextureFlags  |= NV3_TEXTURE_BLIT_UPDATE;
        }
        pTexture->fpTexture        = (FLATPTR)dwDstLinearBase;
        pTexture->dwTextureFlags  &= ~(NV3_TEXTURE_MODIFIED | NV3_TEXTURE_MUST_RELOAD);

        /*
         * Auto generate mipmaps
         */
        if (pTexture->dwTextureFlags & NV4_TEXTURE_AUTOMIPMAPPED)
        {
            nvTextureAutoMipMap (pTexture);
        }

        /*
         * Save frequently accessed globals.
         */
        NV_D3D_GLOBAL_SAVE();

#ifdef  CACHE_FREECOUNT
        pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
        NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

        /*
         * Display the texture surface to the current display buffer (debug only).
         */
        dbgDisplayTexture((PNVD3DCONTEXT)pTexture->hContext, pTexture);
    }
    else
    {

        /*
         * Set up the starting postion of the blit.
         */
        yDstCurrent = dwDstY0;
        ySrcCurrent = dwSrcY0;

        /*
         * Don't have an internal texture suface, so just do the blit to
         * the user texture surface.
         */
        for (yCount = 0; yCount < yHeight; yCount++)
        {
            pSrcLinear = (unsigned long *)(dwSrcLinearBase + (ySrcCurrent++ * dwSrcPitch));
            pDstLinear = (unsigned long *)(dwDstLinearBase + (yDstCurrent++ * dwDstPitch));
            for (xCount = 0; xCount < xWidth; xCount++)
                pDstLinear[dwDstX0 + xCount] = pSrcLinear[dwSrcX0 + xCount];
        }
    }

    return;
}
#endif // !NV_TEX2

/*
 *
 */
DWORD UnplugSystemMemoryTextureContext
(
    void
)
{
    NvNotification             *npDmaPusherSyncNotifier;

    npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;

    /*
     * Unplug from DX6 triangle
     */
#ifndef CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetStartMethod + sizeSetData));
#endif  // !CACHE_FREECOUNT
    while (nvFreeCount < (sizeSetObject + sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx6TriangleContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_A, 1);
    nvglSetData(nvFifo, nvFreeCount, NV01_NULL_OBJECT);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < ((sizeSetStartMethod + sizeSetData) * 3))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         ((sizeSetStartMethod + sizeSetData) * 3));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NOTIFY, 1);
    nvglSetData(nvFifo, nvFreeCount, NV055_NOTIFY_WRITE_ONLY);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Unplug from DX5 triangle
     */
    while (nvFreeCount < (sizeSetObject + sizeSetStartMethod + sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetStartMethod + sizeSetData));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_A, 1);
    nvglSetData(nvFifo, nvFreeCount, NV01_NULL_OBJECT);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglDx5TriangleNotify(nvFifo, nvFreeCount, NV_DD_SPARE);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Force both triangle states to be resent.
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    return (0);
}

/*
 * Some commonly used code for setting up the system memory/agp memory texture contexts and
 * DMA pusher contexts.
 */
DWORD AdjustTextureLimit
(
    DWORD   dwContext,
    DWORD   dwHeapBase,
    DWORD   dwNewLimit,
    DWORD   dwOldLimit
)
{
#ifdef  MULTI_MON
    DWORD   dwStatus;

    if (pDriverData->dwTextureContextValid)
    {
        /*
         * Should probably unplug the object before destroying.
         */
        while (nvFreeCount < (sizeSetObject + sizeSetDx6TriangleContexts))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                             (sizeSetObject + sizeSetDx6TriangleContexts));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        nvglSetDx6TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, NV01_NULL_OBJECT, NV01_NULL_OBJECT);

        while (nvFreeCount < (sizeSetObject + sizeSetDx5TriangleContexts))
            nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                             (sizeSetObject + sizeSetDx5TriangleContexts));
        nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        nvglSetDx5TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, NV01_NULL_OBJECT, NV01_NULL_OBJECT);
        nvStartDmaBuffer (FALSE);

        /*
         * First destroy the current context.
         */
        if (NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY) != NVOS00_STATUS_SUCCESS)
                    return(TRUE);
        pDriverData->dwTextureContextValid = FALSE;
    }

    dwStatus = 7; // NVOS03_STATUS_
    if (dwHeapBase && dwNewLimit)
    {
        dwStatus = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                       D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                       NV01_CONTEXT_DMA,
                                       (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                        ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                       (PVOID)dwHeapBase,
                                       dwNewLimit);
    }

    if (dwStatus != 0) // NVOS03_STATUS_SUCCESS
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AdjustTextureLimit: Could not resize system memory texture context");
        dbgD3DError();
        if (dwHeapBase && dwOldLimit)
        {
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                (PVOID)dwHeapBase,
                                dwOldLimit) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
        }
        else
        {
#ifndef WINNT
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                (PVOID)pDriverData->BaseAddress,
                                0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
#else
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                                (PVOID)pDriverData->ppdev->pjScreen,
                                0xFF) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
#endif // #ifdef WINNT
        }
    }
    pDriverData->dwTextureContextValid = TRUE;

    /*
     * Force both triangle states to be resent.
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    return (dwStatus);
#else   // !MULTI_MON
    NvNotification             *npDmaPusherSyncNotifier;

    npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;

#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;

    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
    while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, dwContext);
    nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                               dwHeapBase, pDriverData->flatSelector, dwNewLimit, 0);
    nvStartDmaBuffer (FALSE);
    pDriverData->dDrawSpareSubchannelObject = dwContext;
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    if (npDmaPusherSyncNotifier->status)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "AdjustTextureLimit - Could not adjust the texture limit!!");
        dbgD3DError();
        npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
        if (dwOldLimit)
        {
            nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                                       dwHeapBase, pDriverData->flatSelector, dwOldLimit, 0);
        }
        else
        {
            nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                                       0, 0, 0, 0);
        }
        nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
        while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
        /*
         * non-0 = bad.  error locking memory.
         */
        return (1);
    }

    /*
     * 0 = good, no error.
     */
    return (0);
#endif  // !MULTI_MON
}
DWORD UpdateTriangleContexts
(
    void
)
{
    NvNotification             *npDmaPusherSyncNotifier;

    npDmaPusherSyncNotifier = (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;

    /*
     * Plug into DX6 triangle.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx6TriangleContexts))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx6TriangleContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
    nvglSetDx6TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < ((sizeSetStartMethod + sizeSetData) * 3))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         ((sizeSetStartMethod + sizeSetData) * 3));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NOTIFY, 1);
    nvglSetData(nvFifo, nvFreeCount, NV055_NOTIFY_WRITE_ONLY);
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV055_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Plug into DX5 triangle.
     */
    while (nvFreeCount < (sizeSetObject + sizeSetDx5TriangleContexts))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetObject + sizeSetDx5TriangleContexts));
    nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    nvglSetDx5TriangleContexts(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvStartDmaBuffer (FALSE);

    /*
     * Send a couple NOPS and notify on completion.
     * This should hopefully ensure that the contexts are unplugged before they are changed.
     */
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER
    while (nvFreeCount < (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE,
                         (sizeSetStartMethod + sizeSetData + sizeDx5TriangleNotify));
    nvglSetStartMethod(nvFifo, nvFreeCount, NV_DD_SPARE, NV054_NO_OPERATION, 1);
    nvglSetData(nvFifo, nvFreeCount, 0);
    nvglDx5TriangleNotify(nvFifo, nvFreeCount, NV_DD_SPARE);
    npDmaPusherSyncNotifier->status = NV_IN_PROGRESS;
    nvStartDmaBuffer (FALSE);
#ifndef NV_NULL_HW_DRIVER
    while (npDmaPusherSyncNotifier->status == NV_IN_PROGRESS);
#endif //!NV_NULL_HW_DRIVER

    /*
     * Force both triangle states to be resent.
     */
    pDriverData->dDrawSpareSubchannelObject = 0;
    return (0);
}

#ifdef  MULTI_MON
/*
 * Destroy all texture DMA contexts and free all allocated system memory for shutdown.
 */
void D3DDestroyTextureContexts
(
    void
)
{
    /*
     * Free the texture heap DMA context.
     */
    if (pDriverData->dwTextureContextValid)
    {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
        pDriverData->dwTextureContextValid = FALSE;
    }

    /*
     * Free the system memory texture heap.
     */
    if (pDriverData->hTextureHeap)
    {
        if (pDriverData->GARTLinearBase == 0)
        {
            /*
             * Only need to free the heap if it was allocated.  (it won't be
             * allocated on an AGP system)
             */
#ifndef OLDSTUFF
            HEAPFREE((HANDLE)pDriverData->hTextureHeap, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HEAPDESTROY((HANDLE)pDriverData->hTextureHeap);
#else
            HeapFree((HANDLE)pDriverData->hTextureHeap, 0, (PTEXHEAPHEADER)pDriverData->pRealHeapBase);
            HeapDestroy((HANDLE)pDriverData->hTextureHeap);
#endif // #ifdef OLDSTUFF

        }
        else
            DestroyAGPListArray();
    }

    /*
     * Clean up a little bit.
     */
    pDriverData->hTextureHeap                           = (DWORD)NULL;
    (PTEXHEAPHEADER)pDriverData->pRealHeapBase         = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapBase      = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocHead = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapAllocTail = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeHead  = (PTEXHEAPHEADER)NULL;
    (PTEXHEAPHEADER)pDriverData->pTextureHeapFreeTail  = (PTEXHEAPHEADER)NULL;
    pDriverData->dwTextureHeapSize                     = 0;
    pDriverData->dwTextureHeapSizeMax                  = 0;
    pDriverData->dwTextureHeapLimit                    = 0;
    pDriverData->dwTextureHeapLimitMax                 = 0;
    pDriverData->dwAllocSize                           = 0;
    pDriverData->dwFreeSize                            = 0;

    /*
     * Next free the texture manager heap context DMA.
     */
    if (pDriverData->dwTMStageHandle)
    {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);

        /*
         * And free the texture manager memory.
         */
        nvTMDestroy();
    }
}
#endif  // MULTI_MON

#endif  // NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4vx.c ===
/*
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 *
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4VX.C                                                           *
*   NV4 Triangle Inner Loops. (Originally Machine Generated)                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/23/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include <math.h>
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3d.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"

#ifdef NV_FASTLOOPS

DWORD dwDrawPrimitiveTable[] =
{
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x040*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x080*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x0c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x100*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x140*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x180*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x1c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x200*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x240*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x280*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x2c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x300*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x340*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x380*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x3c0*/
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x400*/
   (DWORD)nvAACapturePrimitive,
   (DWORD)nvDX5TriangleSetup,
   (DWORD)nvAACapturePrimitive,
   (DWORD)nvDX6TriangleSetup,
};

#else //~NV_FASTLOOPS

/*
 * Function Tables
 */
LPNVDRAWPRIM fnDX5Table[] =
{
    nvDX5Triangle                           ,
    nvDX5TriangleExpFog                     ,
    nvDX5TriangleExp2Fog                    ,
    nvDX5TriangleLinearFog                  ,
    nvDX5TriangleWBuf                       ,
    nvDX5TriangleExpFogWBuf                 ,
    nvDX5TriangleExp2FogWBuf                ,
    nvDX5TriangleLinearFogWBuf              ,
    nvDX5TriangleAACapture                  ,
    nvDX5TriangleAACaptureWBuf              ,
    nvDX5TriangleSetup
};

LPNVINDEXEDPRIM fnDX5IndexedTable[] =
{
    nvDX5TriangleIndexed                    ,
    nvDX5TriangleExpFogIndexed              ,
    nvDX5TriangleExp2FogIndexed             ,
    nvDX5TriangleLinearFogIndexed           ,
    nvDX5TriangleIndexedWBuf                ,
    nvDX5TriangleExpFogIndexedWBuf          ,
    nvDX5TriangleExp2FogIndexedWBuf         ,
    nvDX5TriangleLinearFogIndexedWBuf       ,
    nvDX5TriangleIndexedAACapture           ,
    nvDX5TriangleIndexedAACaptureWBuf       ,
    nvDX5IndexedTriangleSetup
};

LPNVFVFDRAWPRIM fnDX5FlexTable[] =
{
    nvDX5FlexTriangle                       ,
    nvDX5FlexTriangleExpFog                 ,
    nvDX5FlexTriangleExp2Fog                ,
    nvDX5FlexTriangleLinearFog              ,
    nvDX5FlexTriangleWBuf                   ,
    nvDX5FlexTriangleExpFogWBuf             ,
    nvDX5FlexTriangleExp2FogWBuf            ,
    nvDX5FlexTriangleLinearFogWBuf          ,
    nvDX5FlexTriangleAACapture              ,
    nvDX5FlexTriangleAACaptureWBuf          ,
    nvDX5FlexTriangleSetup
};

LPNVFVFINDEXEDPRIM fnDX5FlexIndexedTable[] =
{
    nvDX5FlexTriangleIndexed                ,
    nvDX5FlexTriangleExpFogIndexed          ,
    nvDX5FlexTriangleExp2FogIndexed         ,
    nvDX5FlexTriangleLinearFogIndexed       ,
    nvDX5FlexTriangleIndexedWBuf            ,
    nvDX5FlexTriangleExpFogIndexedWBuf      ,
    nvDX5FlexTriangleExp2FogIndexedWBuf     ,
    nvDX5FlexTriangleLinearFogIndexedWBuf   ,
    nvDX5FlexTriangleIndexedAACapture       ,
    nvDX5FlexTriangleIndexedAACaptureWBuf   ,
    nvDX5FlexIndexedTriangleSetup
};

LPNVFVFDRAWPRIM fnDX6FlexTable[] =
{
    nvDX6FlexTriangle                       ,
    nvDX6FlexTriangleExpFog                 ,
    nvDX6FlexTriangleExp2Fog                ,
    nvDX6FlexTriangleLinearFog              ,
    nvDX6FlexTriangleWBuf                   ,
    nvDX6FlexTriangleExpFogWBuf             ,
    nvDX6FlexTriangleExp2FogWBuf            ,
    nvDX6FlexTriangleLinearFogWBuf          ,
    nvDX6FlexTriangleAACapture              ,
    nvDX6FlexTriangleAACaptureWBuf          ,
    nvDX6FlexTriangleSetup
};

LPNVFVFINDEXEDPRIM fnDX6FlexIndexedTable[] =
{
    nvDX6FlexTriangleIndexed                ,
    nvDX6FlexTriangleExpFogIndexed          ,
    nvDX6FlexTriangleExp2FogIndexed         ,
    nvDX6FlexTriangleLinearFogIndexed       ,
    nvDX6FlexTriangleIndexedWBuf            ,
    nvDX6FlexTriangleExpFogIndexedWBuf      ,
    nvDX6FlexTriangleExp2FogIndexedWBuf     ,
    nvDX6FlexTriangleLinearFogIndexedWBuf   ,
    nvDX6FlexTriangleIndexedAACapture       ,
    nvDX6FlexTriangleIndexedAACaptureWBuf   ,
    nvDX6FlexIndexedTriangleSetup
};


/*
 * Function declarations
 */

// nvDX5Triangle
#define  PROC_        "nvDX5Triangle                           "
#define  PROC         nvDX5Triangle
#define  VERTEX       nvglDX5TriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#include "nv4loop.c"
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFog
#define  PROC_        "nvDX5TriangleExpFog                     "
#define  PROC         nvDX5TriangleExpFog
#define  VERTEX       nvglDX5TriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#include "nv4loop.c"
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2Fog
#define  PROC_        "nvDX5TriangleExp2Fog                    "
#define  PROC         nvDX5TriangleExp2Fog
#define  VERTEX       nvglDX5TriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#include "nv4loop.c"
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFog
#define  PROC_        "nvDX5TriangleLinearFog                  "
#define  PROC         nvDX5TriangleLinearFog
#define  VERTEX       nvglDX5TriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#include "nv4loop.c"
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleWBuf
#define  PROC_        "nvDX5TriangleWBuf                       "
#define  PROC         nvDX5TriangleWBuf
#define  VERTEX       nvglDX5TriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFogWBuf
#define  PROC_        "nvDX5TriangleExpFogWBuf                 "
#define  PROC         nvDX5TriangleExpFogWBuf
#define  VERTEX       nvglDX5TriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2FogWBuf
#define  PROC_        "nvDX5TriangleExp2FogWBuf                "
#define  PROC         nvDX5TriangleExp2FogWBuf
#define  VERTEX       nvglDX5TriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFogWBuf
#define  PROC_        "nvDX5TriangleLinearFogWBuf              "
#define  PROC         nvDX5TriangleLinearFogWBuf
#define  VERTEX       nvglDX5TriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#include "nv4loop.c"
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexed
#define  PROC_        "nvDX5TriangleIndexed                    "
#define  PROC         nvDX5TriangleIndexed
#define  VERTEX       nvglDX5TriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFogIndexed
#define  PROC_        "nvDX5TriangleExpFogIndexed              "
#define  PROC         nvDX5TriangleExpFogIndexed
#define  VERTEX       nvglDX5TriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2FogIndexed
#define  PROC_        "nvDX5TriangleExp2FogIndexed             "
#define  PROC         nvDX5TriangleExp2FogIndexed
#define  VERTEX       nvglDX5TriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFogIndexed
#define  PROC_        "nvDX5TriangleLinearFogIndexed           "
#define  PROC         nvDX5TriangleLinearFogIndexed
#define  VERTEX       nvglDX5TriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexedWBuf
#define  PROC_        "nvDX5TriangleIndexedWBuf                "
#define  PROC         nvDX5TriangleIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExpFogIndexedWBuf
#define  PROC_        "nvDX5TriangleExpFogIndexedWBuf          "
#define  PROC         nvDX5TriangleExpFogIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleExp2FogIndexedWBuf
#define  PROC_        "nvDX5TriangleExp2FogIndexedWBuf         "
#define  PROC         nvDX5TriangleExp2FogIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleLinearFogIndexedWBuf
#define  PROC_        "nvDX5TriangleLinearFogIndexedWBuf       "
#define  PROC         nvDX5TriangleLinearFogIndexedWBuf
#define  VERTEX       nvglDX5TriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  INDEXED
#include "nv4loop.c"
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleAACapture
#define  PROC_        "nvDX5TriangleAACapture                  "
#define  PROC         nvDX5TriangleAACapture
#define  VERTEX       nvglDX5TriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleAACaptureWBuf
#define  PROC_        "nvDX5TriangleAACaptureWBuf              "
#define  PROC         nvDX5TriangleAACaptureWBuf
#define  VERTEX       nvglDX5TriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexedAACapture
#define  PROC_        "nvDX5TriangleIndexedAACapture           "
#define  PROC         nvDX5TriangleIndexedAACapture
#define  VERTEX       nvglDX5TriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5TriangleIndexedAACaptureWBuf
#define  PROC_        "nvDX5TriangleIndexedAACaptureWBuf       "
#define  PROC         nvDX5TriangleIndexedAACaptureWBuf
#define  VERTEX       nvglDX5TriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangle
#define  PROC_        "nvDX5FlexTriangle                       "
#define  PROC         nvDX5FlexTriangle
#define  VERTEX       nvglDX5FlexTriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFog
#define  PROC_        "nvDX5FlexTriangleExpFog                 "
#define  PROC         nvDX5FlexTriangleExpFog
#define  VERTEX       nvglDX5FlexTriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2Fog
#define  PROC_        "nvDX5FlexTriangleExp2Fog                "
#define  PROC         nvDX5FlexTriangleExp2Fog
#define  VERTEX       nvglDX5FlexTriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFog
#define  PROC_        "nvDX5FlexTriangleLinearFog              "
#define  PROC         nvDX5FlexTriangleLinearFog
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleWBuf
#define  PROC_        "nvDX5FlexTriangleWBuf                   "
#define  PROC         nvDX5FlexTriangleWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFogWBuf
#define  PROC_        "nvDX5FlexTriangleExpFogWBuf             "
#define  PROC         nvDX5FlexTriangleExpFogWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2FogWBuf
#define  PROC_        "nvDX5FlexTriangleExp2FogWBuf            "
#define  PROC         nvDX5FlexTriangleExp2FogWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFogWBuf
#define  PROC_        "nvDX5FlexTriangleLinearFogWBuf          "
#define  PROC         nvDX5FlexTriangleLinearFogWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexed
#define  PROC_        "nvDX5FlexTriangleIndexed                "
#define  PROC         nvDX5FlexTriangleIndexed
#define  VERTEX       nvglDX5FlexTriangleVertex
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFogIndexed
#define  PROC_        "nvDX5FlexTriangleExpFogIndexed          "
#define  PROC         nvDX5FlexTriangleExpFogIndexed
#define  VERTEX       nvglDX5FlexTriangleVertexExpFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2FogIndexed
#define  PROC_        "nvDX5FlexTriangleExp2FogIndexed         "
#define  PROC         nvDX5FlexTriangleExp2FogIndexed
#define  VERTEX       nvglDX5FlexTriangleVertexExp2Fog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFogIndexed
#define  PROC_        "nvDX5FlexTriangleLinearFogIndexed       "
#define  PROC         nvDX5FlexTriangleLinearFogIndexed
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFog
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleIndexedWBuf            "
#define  PROC         nvDX5FlexTriangleIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExpFogIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleExpFogIndexedWBuf      "
#define  PROC         nvDX5FlexTriangleExpFogIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExpFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleExp2FogIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleExp2FogIndexedWBuf     "
#define  PROC         nvDX5FlexTriangleExp2FogIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexExp2FogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleLinearFogIndexedWBuf
#define  PROC_        "nvDX5FlexTriangleLinearFogIndexedWBuf   "
#define  PROC         nvDX5FlexTriangleLinearFogIndexedWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexLinearFogWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleAACapture
#define  PROC_        "nvDX5FlexTriangleAACapture              "
#define  PROC         nvDX5FlexTriangleAACapture
#define  VERTEX       nvglDX5FlexTriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleAACaptureWBuf
#define  PROC_        "nvDX5FlexTriangleAACaptureWBuf          "
#define  PROC         nvDX5FlexTriangleAACaptureWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexedAACapture
#define  PROC_        "nvDX5FlexTriangleIndexedAACapture       "
#define  PROC         nvDX5FlexTriangleIndexedAACapture
#define  VERTEX       nvglDX5FlexTriangleVertexAACapture
#define  VXSIZE       sizeDX5TriangleVertex
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX5FlexTriangleIndexedAACaptureWBuf
#define  PROC_        "nvDX5FlexTriangleIndexedAACaptureWBuf   "
#define  PROC         nvDX5FlexTriangleIndexedAACaptureWBuf
#define  VERTEX       nvglDX5FlexTriangleVertexAACaptureWBuf
#define  VXSIZE       sizeDX5TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangle
#define  PROC_        "nvDX6FlexTriangle                       "
#define  PROC         nvDX6FlexTriangle
#define  VERTEX       nvglDX6FlexTriangleVertex
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFog
#define  PROC_        "nvDX6FlexTriangleExpFog                 "
#define  PROC         nvDX6FlexTriangleExpFog
#define  VERTEX       nvglDX6FlexTriangleVertexExpFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2Fog
#define  PROC_        "nvDX6FlexTriangleExp2Fog                "
#define  PROC         nvDX6FlexTriangleExp2Fog
#define  VERTEX       nvglDX6FlexTriangleVertexExp2Fog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFog
#define  PROC_        "nvDX6FlexTriangleLinearFog              "
#define  PROC         nvDX6FlexTriangleLinearFog
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleWBuf
#define  PROC_        "nvDX6FlexTriangleWBuf                   "
#define  PROC         nvDX6FlexTriangleWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFogWBuf
#define  PROC_        "nvDX6FlexTriangleExpFogWBuf             "
#define  PROC         nvDX6FlexTriangleExpFogWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExpFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2FogWBuf
#define  PROC_        "nvDX6FlexTriangleExp2FogWBuf            "
#define  PROC         nvDX6FlexTriangleExp2FogWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExp2FogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFogWBuf
#define  PROC_        "nvDX6FlexTriangleLinearFogWBuf          "
#define  PROC         nvDX6FlexTriangleLinearFogWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexed
#define  PROC_        "nvDX6FlexTriangleIndexed                "
#define  PROC         nvDX6FlexTriangleIndexed
#define  VERTEX       nvglDX6FlexTriangleVertex
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFogIndexed
#define  PROC_        "nvDX6FlexTriangleExpFogIndexed          "
#define  PROC         nvDX6FlexTriangleExpFogIndexed
#define  VERTEX       nvglDX6FlexTriangleVertexExpFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2FogIndexed
#define  PROC_        "nvDX6FlexTriangleExp2FogIndexed         "
#define  PROC         nvDX6FlexTriangleExp2FogIndexed
#define  VERTEX       nvglDX6FlexTriangleVertexExp2Fog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFogIndexed
#define  PROC_        "nvDX6FlexTriangleLinearFogIndexed       "
#define  PROC         nvDX6FlexTriangleLinearFogIndexed
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFog
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleIndexedWBuf            "
#define  PROC         nvDX6FlexTriangleIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExpFogIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleExpFogIndexedWBuf      "
#define  PROC         nvDX6FlexTriangleExpFogIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExpFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          1
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleExp2FogIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleExp2FogIndexedWBuf     "
#define  PROC         nvDX6FlexTriangleExp2FogIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexExp2FogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          2
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleLinearFogIndexedWBuf
#define  PROC_        "nvDX6FlexTriangleLinearFogIndexedWBuf   "
#define  PROC         nvDX6FlexTriangleLinearFogIndexedWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexLinearFogWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FOG          3
#define  WBUFFER
#define  INDEXED
#define  FVF
#include "nv4loop.c"
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   FOG
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleAACapture
#define  PROC_        "nvDX6FlexTriangleAACapture              "
#define  PROC         nvDX6FlexTriangleAACapture
#define  VERTEX       nvglDX6FlexTriangleVertexAACapture
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleAACaptureWBuf
#define  PROC_        "nvDX6FlexTriangleAACaptureWBuf          "
#define  PROC         nvDX6FlexTriangleAACaptureWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexAACaptureWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexedAACapture
#define  PROC_        "nvDX6FlexTriangleIndexedAACapture       "
#define  PROC         nvDX6FlexTriangleIndexedAACapture
#define  VERTEX       nvglDX6FlexTriangleVertexAACapture
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

// nvDX6FlexTriangleIndexedAACaptureWBuf
#define  PROC_        "nvDX6FlexTriangleIndexedAACaptureWBuf   "
#define  PROC         nvDX6FlexTriangleIndexedAACaptureWBuf
#define  VERTEX       nvglDX6FlexTriangleVertexAACaptureWBuf
#define  DX6
#define  VXSIZE       sizeDX6TriangleVertex
#define  WBUFFER
#define  INDEXED
#define  FVF
#define  ANTIALIAS
#include "nv4loop.c"
#undef   ANTIALIAS
#undef   FVF
#undef   INDEXED
#undef   WBUFFER
#undef   VXSIZE
#undef   DX6
#undef   VERTEX
#undef   PROC
#undef   PROC_

#endif //!NV_FASTLOOPS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4tman.c ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4TMAN.C                                                         *
*   Texture Blit Manager routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 06/03/98 - created.                     *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nvd3dmac.h"
#include "nv4dreg.h"
#include "nv3ddbg.h"
#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#endif  // MULTI_MON

/*
 * externals
 */
void nvReset2DSurfaceFormat (void);

/*
 * Local Switches
 */
#define TM_OFFSETALIGN          32
#define TM_PITCHALIGN           4

/*
 * Locals
 */
BOOL bTMHadToWaitForStagingSpace;

/*
 * Local Routines
 */
DWORD __inline nvTMGetFreeSpace
(
    void
)
{
    long size;

    if (pDriverData->dwTMHead >= pDriverData->dwTMTail)
        size = (long)(pDriverData->dwTMStageMax - pDriverData->dwTMHead);
    else
        size = (long)(pDriverData->dwTMTail - pDriverData->dwTMHead - 1);

    return (size < 0) ? 0 : size;
}

/*
 * Public Routines
 */
DWORD nvPlacePsuedoNotifier
(
    DWORD offset,
    DWORD value
)
{
    DWORD topLft = 0x00000000 + (offset / 4);

    /*
     * Set proper surface info
     */
    while (nvFreeCount < (sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat + sizeSet2DSurfacesPitch));
    nvglSet2DSurfacesDestination (nvFifo,nvFreeCount,NV_DD_SURFACES, pDriverData->dwTMPseudoNotifierOffset);
    nvglSet2DSurfacesColorFormat (nvFifo,nvFreeCount,NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y32);
    nvglSet2DSurfacesPitch       (nvFifo,nvFreeCount,NV_DD_SURFACES, 0x20,0x20);

    /*
     * Do solid rect fill (with argument as color)
     */
    while (nvFreeCount < (sizeSetObject + 2 * sizeSetStartMethod + 3 * sizeSetData))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + 2 * sizeSetStartMethod + 3 * sizeSetData));
    nvglSetObject      (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE_2);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_COLOR,1);
    nvglSetData        (nvFifo,nvFreeCount,             value);
    nvglSetStartMethod (nvFifo,nvFreeCount,NV_DD_SPARE, NV05E_RECTANGLE(0),2);
    nvglSetData        (nvFifo,nvFreeCount,             topLft);
    nvglSetData        (nvFifo,nvFreeCount,             0x00010001);

    pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE_2;

    /*
     * reset when we are done
     */
    nvReset2DSurfaceFormat();
    return 0;
}

/*
 * Create TexMan Heap
 */
DWORD nvTMCreate
(
    void
)
{
#ifdef TM_STAGER_IN_AGP
    DWORD dwAddr = 0;

    __asm int 3;

    if (pDriverData->GARTLinearBase)
    {
        /*
         * allocate agp memory
         */
        dwAddr = (DWORD)AllocAGPHeap(lpDriverObject, TM_STAGESPACE+0x2000);
        if (dwAddr)
        {
            /*
             * Setup variables
             */
            pDriverData->dwTMStageHandle = dwAddr; // keep addr here too
            pDriverData->dwTMStageMem    = dwAddr;
            pDriverData->dwTMStageAddr   = (pDriverData->dwTMStageMem + 0xfff) & 0xfffff000;
            pDriverData->dwTMStageMax    = pDriverData->dwTMStageAddr + TM_STAGESPACE;
            pDriverData->dwTMHead        = pDriverData->dwTMStageAddr;
            pDriverData->dwTMTail        = pDriverData->dwTMStageAddr;

            /*
             * Debug
             */
#ifdef DEBUG
            memset ((void*)pDriverData->dwTMStageAddr,0x55,TM_STAGESPACE);
#endif

            /*
             * Success
             */
            return 0;
        }
    }

    if (!dwAddr)
    {
        __asm int 3;
        // ***************************** fall back to PCI then - todo
        pDriverData->dwTMStageHandle = 0;
    }
#else
    /*
     * init
     */
    pDriverData->dwTMStageHandle = 0;

    /*
     * Allocate staging space
     */
#ifndef OLDSTUFF
    if (pDriverData->dwTMStageHandle = (DWORD)HEAPCREATE(TM_STAGESPACE+0x3000))
#else
    if (pDriverData->dwTMStageHandle = (DWORD)HeapCreate(HEAP_SHARED, TM_STAGESPACE+0x3000, 0))
#endif
    {
        /*
         * Allocate TexMan stage
         */
#ifndef OLDSTUFF
        if (pDriverData->dwTMStageMem = (DWORD)HEAPALLOC(pDriverData->dwTMStageHandle, TM_STAGESPACE+0x2000))
#else
        if (pDriverData->dwTMStageMem = (DWORD)HeapAlloc((HANDLE)pDriverData->dwTMStageHandle, HEAP_ZERO_MEMORY, TM_STAGESPACE+0x2000))
#endif
        {
            /*
             * Setup vairables
             */
            pDriverData->dwTMStageAddr = (pDriverData->dwTMStageMem + 0xfff) & 0xfffff000;
            pDriverData->dwTMStageMax  = pDriverData->dwTMStageAddr + TM_STAGESPACE;
            pDriverData->dwTMHead      = pDriverData->dwTMStageAddr;
            pDriverData->dwTMTail      = pDriverData->dwTMStageAddr;

            /*
             * Lock down the heap
             */
#ifdef  MULTI_MON
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY,
                                NV01_CONTEXT_DMA,
                                (ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY |
                                 ALLOC_CTX_DMA_FLAGS_LOCKED_CACHED),
                                (PVOID)pDriverData->dwTMStageAddr,
                                TM_STAGESPACE + 0xfff) != ALLOC_CTX_DMA_STATUS_SUCCESS)
                                    return(TRUE);
#else   // !MULTI_MON
            while (nvFreeCount < (sizeSetObject + sizeSetDmaFromMemoryNotify))
                nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetDmaFromMemoryNotify));
            nvglSetObject(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
            nvglSetDmaFromMemoryNotify(nvFifo, nvFreeCount, NV_DD_SPARE,
                                       pDriverData->dwTMStageAddr, pDriverData->flatSelector, TM_STAGESPACE + 0xfff, 0);
            pDriverData->dDrawSpareSubchannelObject = D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY;
#endif  // !MULTI_MON

            /*
             * Debug
             */
#ifdef DEBUG
            memset ((void*)pDriverData->dwTMStageAddr,0x55,TM_STAGESPACE);
#endif

            /*
             * Success
             */
            return 0;
        }
        else
        {
#ifndef OLDSTUFF
            HEAPDESTROY (pDriverData->dwTMStageHandle);
#else
            HeapDestroy ((HANDLE)pDriverData->dwTMStageHandle);
#endif
        }
    }
#endif //TM_STAGER_IN_AGP

    pDriverData->dwTMStageHandle = 0; // <- this will indicate that we failed creating the texture manager
    return 1;
}

/*
 * Destroy TexMan Heap
 */
void nvTMDestroy
(
    void
)
{

#ifdef TM_STAGER_IN_AGP
    if (pDriverData->dwTMStageHandle)
    {
        FreeAGPHeap(lpDriverObject, pDriverData->dwTMStageHandle);
    }
#else
    if (pDriverData->dwTMStageHandle)
    {
        if (pDriverData->dwTMStageMem)
        {
#ifndef OLDSTUFF
            HEAPFREE (pDriverData->dwTMStageHandle,(void*)pDriverData->dwTMStageMem);
#else
            HeapFree ((HANDLE)pDriverData->dwTMStageHandle,0,(void*)pDriverData->dwTMStageMem);
#endif
            pDriverData->dwTMStageMem = 0;
        }
#ifndef OLDSTUFF
        HEAPDESTROY (pDriverData->dwTMStageHandle);
#else
        HeapDestroy ((HANDLE)pDriverData->dwTMStageHandle);
#endif
    }
#endif //TM_STAGER_IN_AGP

    pDriverData->dwTMStageHandle = 0;
}

/*
 * nvTMAllocTextureStagingSpace
 */
DWORD nvTMAllocTextureStagingSpace
(
    DWORD  dwSize,
    DWORD *pdwAddr,
    DWORD *pdwOffset
)
{
    DWORD dwSizeNeeded;
    DWORD dwFreeSpace;
    DWORD dwFirst;

#ifdef NV_NULL_HW_DRIVER
    *pdwAddr   = pDriverData->dwTMStageAddr;
    *pdwOffset = 0;
    return dwTMHead;
#endif //NV_NULL_HW_DRIVER

    /*
     * Get free space in staging heap
     */
    dwSizeNeeded = dwSize + TM_OFFSETALIGN;

    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Check 1");
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMHead   = %08x",pDriverData->dwTMHead);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMTail   = %08x",pDriverData->dwTMTail);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   free space = %08x",nvTMGetFreeSpace());
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:");

    /*
     * Check if we can commit the space
     */
    dwFreeSpace  = nvTMGetFreeSpace();
    if (dwFreeSpace >= dwSizeNeeded)
    {
        DWORD addr;

    cont:
        addr     = (pDriverData->dwTMHead + (TM_OFFSETALIGN - 1)) & ~(TM_OFFSETALIGN-1);
        pDriverData->dwTMHead = addr + dwSize;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Commit Buffer");
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   New Head = %08x",pDriverData->dwTMHead);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   Buf Addr = %08x",addr);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   Buf Ofs  = %08x",addr - pDriverData->dwTMStageAddr);

        *pdwAddr   = addr;
#ifdef TM_STAGER_IN_AGP
        *pdwOffset = addr - pDriverData->GARTLinearBase;
#else
        *pdwOffset = addr - pDriverData->dwTMStageAddr;
#endif

        return pDriverData->dwTMHead; // this is what tail should be when texture blit retires
    }

    /*
     * Not enough space
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Out of staging space");
    DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:");

#ifdef NV_PROFILE
    NVP_START(NVP_T_TSTAGE);
#endif

    dwFirst = 1;
    for (;;)
    {
        /*
         * Read Tail from psuedo notifier
         */
#ifdef DEBUG
        {
            DWORD old = pDriverData->dwTMTail;
#endif
#ifndef WINNT
        pDriverData->dwTMTail = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEX_RETIRE + pDriverData->BaseAddress);
#else
        pDriverData->dwTMTail = *(DWORD*)(pDriverData->dwTMPseudoNotifierOffset + NV_PN_TEX_RETIRE + pDriverData->ppdev->pjScreen);
#endif // #ifdef WINNT

#ifdef DEBUG
            if (old < pDriverData->dwTMTail) memset ((void*)old,0x55,pDriverData->dwTMTail-old);
            if (old > pDriverData->dwTMTail) memset ((void*)old,0x55,pDriverData->dwTMStageMax-old);
        }
#endif

        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Check 2");
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMHead   = %08x",pDriverData->dwTMHead);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   dwTMTail   = %08x",pDriverData->dwTMTail);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:   free space = %08x",nvTMGetFreeSpace());
        DPF_LEVEL(NVDBG_LEVEL_INFO, "TM:");

        /*
         * Attempt to wrap around
         */
        if ((pDriverData->dwTMHead >= pDriverData->dwTMTail) && (pDriverData->dwTMTail > pDriverData->dwTMStageAddr)) {
            DPF_LEVEL(NVDBG_LEVEL_INFO, "TM: Wrap around");
            /*
             * Set head to start of buffer
             */
            pDriverData->dwTMHead = pDriverData->dwTMStageAddr;
            /*
             * Update tail
             */
            nvTMUpdateRetirementDate (pDriverData->dwTMHead);
            /*
             * Kick off data
             */
            nvStartDmaBuffer (FALSE);
        }

        /*
         * Check if we have enough space now
         */
        dwFreeSpace  = nvTMGetFreeSpace();
        if (dwFreeSpace >= dwSizeNeeded) goto retire;

        /*
         * Not enough space yet
         *   go to never-never land for a while
         *   save some PCI bus activity
         */
        if (dwFirst)
        {
            /*
             * Start Buffer just in case we have pending data (avoids hanging too)
             */
            nvStartDmaBuffer (FALSE);
            dwFirst = 0;
        }

        bTMHadToWaitForStagingSpace = TRUE;
        NV_DELAY;
    }

retire:
#ifdef NV_PROFILE
    NVP_STOP(NVP_T_TSTAGE);
    nvpLogTime(NVP_T_TSTAGE,nvpTime[NVP_T_TSTAGE]);
#endif
    goto cont;
}

void nvTMUpdateRetirementDate
(
    DWORD dwRetirementAddress
)
{
    DPF_LEVEL(NVDBG_LEVEL_FUNCTION_CALL, "TM: Placing notifier at %08x",dwRetirementAddress);
    nvPlacePsuedoNotifier (NV_PN_TEX_RETIRE,dwRetirementAddress);
}

/*
 * Copy Texels
 */
void __inline nvTMCopyTexels
(
    DWORD dwSrcLine,
    DWORD dwSrcPitch,
    DWORD dwDst1Line,       // 1st destination
    DWORD dwDst1Pitch,
    DWORD dwDst2Line,       // 2nd destination (may be NULL)
    DWORD dwDst2Pitch,      // must be 0 when above is NULL
    DWORD dwSpanX,          // in bytes
    DWORD dwSpanY           // in lines
)
{
#ifdef NV_TEX2
    DWORD i,y;

    i = 4096 / dwSpanX; // move 4k at a time

    for (y = dwSpanY; y;)
    {
        DWORD h = min(y,i);
        DWORD z;

        if (h)
        {
            DWORD src = dwSrcLine;

            for (z=h; z; z--)
            {
                nvMemTouch (src,dwSpanX);
                src += dwSrcPitch;
            }
            for (z=h; z; z--)
            {
                nvMemCopy (dwDst1Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);
                if (dwDst2Line) nvMemCopy (dwDst2Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);

                dwDst1Line += dwDst1Pitch;
                dwDst2Line += dwDst2Pitch;
                dwSrcLine  += dwSrcPitch;
            }

            y -= h;
        }
        else // width too large for multi spans, do a line at a time
        {
            nvMemCopy (dwDst1Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);
            if (dwDst2Line) nvMemCopy (dwDst2Line,dwSrcLine,dwSpanX,NV_MEMCOPY_WANTDESTALIGNED);

            dwDst1Line += dwDst1Pitch;
            dwDst2Line += dwDst2Pitch;
            dwSrcLine  += dwSrcPitch;
            y--;
        }

    }

#else // !NV_TEX2

    long y;

    if (dwDst2Line) {
        if ((dwSpanX == dwDst1Pitch) && (dwSpanX == dwDst2Pitch) && (dwSpanX == dwSrcPitch))
        {
            DWORD size = dwSpanX * dwSpanY;
            while (size)
            {
                if (size >= 4096)
                {
                    memcpy ((void*)dwDst1Line,(void*)dwSrcLine,4096);
                    memcpy ((void*)dwDst2Line,(void*)dwSrcLine,4096);
                    size -= 4096;
                }
                else
                {
                    memcpy ((void*)dwDst1Line,(void*)dwSrcLine,size);
                    size = 0;
                }
            }
            return;
        }

        for (y=(long)dwSpanY; y>0; y--)
        {
            memcpy ((void*)dwDst1Line,(void*)dwSrcLine,dwSpanX);
            memcpy ((void*)dwDst2Line,(void*)dwSrcLine,dwSpanX);
            dwDst1Line += dwDst1Pitch;
            dwDst2Line += dwDst2Pitch;
            dwSrcLine  += dwSrcPitch;
        }
    }
    else
    {
        if ((dwSpanX == dwDst1Pitch) && (dwSpanX == dwSrcPitch))
        {
            DWORD size = dwSpanX * dwSpanY;
            memcpy ((void*)dwDst1Line,(void*)dwSrcLine,size);
            return;
        }

        for (y=(long)dwSpanY; y>0; y--)
        {
            memcpy ((void*)dwDst1Line,(void*)dwSrcLine,dwSpanX);
            dwDst1Line += dwDst1Pitch;
            dwSrcLine  += dwSrcPitch;
        }
    }
#endif // !NV_TEX2
}

/*
 * Setup swizzled Blt
 */
void __inline nvTMSwizzleBlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwImageColorFormat,

    DWORD dwDstSwizzleOffset,
    DWORD dwMipMapBaseU,
    DWORD dwMipMapBaseV,
    DWORD dwSurfaceColorFormat,

    DWORD dwDstX0,
    DWORD dwDstY0,

    DWORD dwBlitWidth,
    DWORD dwBlitHeight
)
{
    /*
     * target surface
     */
    while (nvFreeCount < (sizeSetObject + sizeSetSwizzledSurface))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetSwizzledSurface));
    nvglSetObject          (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (nvFifo,nvFreeCount,NV_DD_SPARE,
                                        (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwSurfaceColorFormat)
                                        |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwMipMapBaseU)
                                        |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwMipMapBaseV)),
                                         dwDstSwizzleOffset);

    /*
     * format
     */
    while (nvFreeCount < (sizeSetObject + sizeSetScaledImageFormat))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeSetObject + sizeSetScaledImageFormat));
    nvglSetObject               (nvFifo,nvFreeCount,NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageFormat    (nvFifo,nvFreeCount,NV_DD_SPARE, dwImageColorFormat);

    /*
     * source memory context
     */
    while (nvFreeCount < sizeSetScaledImageContextImage)
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeSetScaledImageContextImage);
#ifdef TM_STAGER_IN_AGP
    nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY);
#else
    nvglSetScaledImageContextImage(nvFifo, nvFreeCount, NV_DD_SPARE, D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY);
#endif

    /*
     * clip
     */
    while (nvFreeCount < (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageClip + sizeScaledImageOut + sizeScaledImageDeltaDuDxDvDy));
    nvglScaledImageClip          (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageOut           (nvFifo,nvFreeCount,NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageDeltaDuDxDvDy (nvFifo,nvFreeCount,NV_DD_SPARE, (1<<20), (1<<20));

    /*
     * src & go
     */
    while (nvFreeCount < (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint))
        nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, (sizeScaledImageInSize + sizeScaledImageInFormat + sizeScaledImageInOffset + sizeScaledImageInPoint));
    nvglScaledImageInSize   (nvFifo, nvFreeCount, NV_DD_SPARE, dwBlitWidth, dwBlitHeight);
    nvglScaledImageInFormat (nvFifo, nvFreeCount, NV_DD_SPARE,
                             (DRF_NUM(077,_IMAGE_IN_FORMAT,_PITCH,        dwSrcPitch)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_ORIGIN,       _CORNER)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_INTERPOLATOR, _ZOH)));
    nvglScaledImageInOffset (nvFifo, nvFreeCount, NV_DD_SPARE, dwSrcOffset);
    nvglScaledImageInPoint  (nvFifo, nvFreeCount, NV_DD_SPARE, 0, 0);

    pDriverData->dDrawSpareSubchannelObject = D3D_SCALED_IMAGE_FROM_MEMORY;
}

/*
 * Stage a Texture Swizzle Blt
 */
void nvTMVideoTextureBlt
(
    DWORD dwSrcLinearBase,
    DWORD dwSrcPitch,
    DWORD dwSrcX0,
    DWORD dwSrcY0,
    DWORD dwSrcX1,
    DWORD dwSrcY1,
    DWORD dwDstLinearBase,
    DWORD dwDstPitch,
    DWORD dwDstX0,
    DWORD dwDstY0,
    DWORD dwDstSwizzleOffset,
    DWORD dwMipMapBaseU,
    DWORD dwMipMapBaseV,
    DWORD dwTextureColorFormat
)
{
    DWORD dwImageColorFormat;
    DWORD dwSurfaceColorFormat;
    DWORD dwBytesPerPixel;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStagePitch;
    DWORD dwStageSize;
    DWORD dwSrcLinearAddr;
    DWORD dwDstLinearAddr;
    DWORD dwSpan;

    /*
     * Determine surface attributes
     */
    switch (dwTextureColorFormat)
    {
        case NV054_FORMAT_COLOR_LE_X1R5G5B5:
        case NV054_FORMAT_COLOR_LE_R5G6B5:
        case NV054_FORMAT_COLOR_LE_A1R5G5B5:
        case NV054_FORMAT_COLOR_LE_A4R4G4B4:
            dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_R5G6B5;
            dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;
            dwBytesPerPixel      = 2;
            break;

        case NV054_FORMAT_COLOR_LE_X8R8G8B8:
        case NV054_FORMAT_COLOR_LE_A8R8G8B8:
            dwImageColorFormat   = NV077_SET_COLOR_FORMAT_LE_A8R8G8B8;
            dwSurfaceColorFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;
            dwBytesPerPixel      = 4;
            break;
    }

    /*
     * Calc staging area
     */
    dwHeight        = dwSrcY1 - dwSrcY0;
    dwWidth         = dwSrcX1 - dwSrcX0;
    dwSpan          = dwWidth * dwBytesPerPixel;
    dwStagePitch    = (dwSpan + (TM_PITCHALIGN-1)) & ~(TM_PITCHALIGN-1);
    dwStageSize     = dwStagePitch * dwHeight;
    dwSrcLinearAddr = dwSrcLinearBase + (dwSrcPitch * dwSrcY0) + (dwSrcX0 * dwBytesPerPixel);
    dwDstLinearAddr = dwDstLinearBase + (dwDstPitch * dwDstY0) + (dwDstX0 * dwBytesPerPixel);

    if (dwWidth >= 2048) {

        // the HW can't swizzle textures this wide. do it via CPU

        nvFlushDmaBuffers();

        if (dwSrcLinearBase) {

            // we've got a linear source and two destinations: one linear. one swizzled

            if (dwBytesPerPixel == 2) {
                nvSwizzleBlit16Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwSrcLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }
            else {
                nvSwizzleBlit32Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwSrcLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }

        }

        else {

            // we've got one linear source (passed in via dwDstLinearBase for reasons
            // that totally escape me) and one swizzled destination

            if (dwBytesPerPixel == 2) {
                nvSwizzleBlit16Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwDstLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,  // copy it back on top of itself
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }
            else {
                nvSwizzleBlit32Bpp (dwSrcX0, dwSrcY0,
                                    dwSrcX1, dwSrcY1,
                                    dwWidth, dwHeight,
                                    dwSrcPitch,
                                    dwDstLinearBase,
                                    dwDstX0, dwDstY0,
                                    dwDstPitch,
                                    dwDstLinearBase,  // copy it back on top of itself
                                    pDriverData->ppdev->pjScreen + dwDstSwizzleOffset,
                                    dwTextureColorFormat);
            }

        }

        return;
    }

    /*
     * Small requests can be handled elegantly in one step
     */
    if (dwStageSize < (TM_STAGESPACE / 2))
    {
        DWORD dwStageHandle;
        DWORD dwStageAddr;
        DWORD dwStageOffset;

        /*
         * Allocate staging space - this function may kick off pusher
         */
        dwStageHandle = nvTMAllocTextureStagingSpace(dwStageSize,&dwStageAddr,&dwStageOffset);

        /*
         * Copy texels
         */
        if (dwSrcLinearBase)
        {
            if (dwDstLinearBase)
                nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                dwStageAddr,dwStagePitch,       // dest 1
                                dwDstLinearAddr,dwDstPitch,     // dest 2
                                dwSpan,dwHeight);
            else
                nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                dwStageAddr,dwStagePitch,       // dest
                                0,0,                            // nop
                                dwSpan,dwHeight);
        }
        else
            nvTMCopyTexels (dwDstLinearAddr,dwDstPitch,     // source
                            dwStageAddr,dwStagePitch,       // dest
                            0,0,                            // nop
                            dwSpan,dwHeight);

        /*
         * Setup the swizzle Blt
         */
        nvTMSwizzleBlt (dwStageOffset,dwStagePitch,dwImageColorFormat,
                        dwDstSwizzleOffset,dwMipMapBaseU,dwMipMapBaseV,dwSurfaceColorFormat,
                        dwDstX0,dwDstY0,dwWidth,dwHeight);

        /*
         * Report Retirement
         */
        nvTMUpdateRetirementDate (dwStageHandle);

        /*
         * Start Buffer just in case HW is idle
         */
        nvStartDmaBuffer (TRUE);
    }
    else
    /*
     * Large textures are sent in sections
     */
    {
        DWORD dwSection;
        DWORD dwSectionDelta;
        DWORD dwSectionSrcPitch;
        DWORD dwSectionDstPitch;
        DWORD dwSectionHeight;

        /*
         * init
         */
        dwSectionDelta    = (TM_STAGESPACE / 3) / dwStagePitch; // # of lines to fill 1/3 of the buffer
        dwSectionSrcPitch = (dwSrcLinearBase) ? (dwSrcPitch * dwSectionDelta) : 0;
        dwSectionDstPitch = (dwDstLinearBase) ? (dwDstPitch * dwSectionDelta) : 0;

        /*
         * step through sections
         */

        /*
        { // fill swizzle buffer
            DWORD size = (1<<dwMipMapBaseU)*(1<<dwMipMapBaseV)*dwBytesPerPixel;
            memset ((void*)(dwDstSwizzleOffset+pDriverData->BaseAddress),0xaa,size);
        }
        /**/

        for (dwSection = 0; dwSection < dwHeight; dwSection += dwSectionDelta)
        {
            DWORD dwStageHandle;
            DWORD dwStageAddr;
            DWORD dwStageOffset;

            /*
             * Prepare section
             */
            dwSectionHeight = dwHeight - dwSection;
            if (dwSectionHeight > dwSectionDelta) dwSectionHeight = dwSectionDelta;
            dwStageSize     = dwStagePitch * dwSectionHeight;

            /*
             * Allocate staging space - this function may kick off pusher
             */
            dwStageHandle = nvTMAllocTextureStagingSpace(dwStageSize,&dwStageAddr,&dwStageOffset);

            /*
             * Copy texels
             */
            if (dwSrcLinearBase)
            {
                if (dwDstLinearBase)
                    nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                    dwStageAddr,dwStagePitch,       // dest 1
                                    dwDstLinearAddr,dwDstPitch,     // dest 2
                                    dwSpan,dwSectionHeight);
                else
                    nvTMCopyTexels (dwSrcLinearAddr,dwSrcPitch,     // source
                                    dwStageAddr,dwStagePitch,       // dest
                                    0,0,                            // nop
                                    dwSpan,dwSectionHeight);
            }
            else
                nvTMCopyTexels (dwDstLinearAddr,dwDstPitch,     // source
                                dwStageAddr,dwStagePitch,       // dest
                                0,0,                            // nop
                                dwSpan,dwSectionHeight);

            /*
             * Setup the swizzle Blt
             */
            nvTMSwizzleBlt (dwStageOffset,dwStagePitch,dwImageColorFormat,
                            dwDstSwizzleOffset,dwMipMapBaseU,dwMipMapBaseV,dwSurfaceColorFormat,
                            dwDstX0,dwDstY0,dwWidth,dwSectionHeight);

            /*
             * Report Retirement
             */
            nvTMUpdateRetirementDate (dwStageHandle);

            /*
             * Start Buffer
             */
            nvStartDmaBuffer (TRUE);

        /*
        NV_D3D_GLOBAL_SAVE();
        nvFlushDmaBuffers();
        NV_D3D_GLOBAL_SETUP();
        Sleep (10);
        /**/

            /*
             * prep for next
             */
            dwSrcLinearAddr += dwSectionSrcPitch;
            dwDstLinearAddr += dwSectionDstPitch;
            dwDstY0         += dwSectionDelta;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\src\nv4tri.c ===
#ifdef  NV4
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4TRI.C                                                          *
*   NV4 Old Execute Buffer Style RenderPrimitive DDI routines.              *
*   NOTE: Uses indexed primitive rendering routines in NV4INDEX.C           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include <windows.h>
#include "nvd3ddrv.h"
#include "ddrvmem.h"
#include "nv32.h"
#include "nvddobj.h"
#include "d3dinc.h"
#include "nv3ddbg.h"
#include "nv4vxmac.h"


PFNRENDERPRIMITIVEOP    pfnRenderPrimitiveOperation[] =
{
    nvRenderNoOp,           // Op codes are 1 based, so 0 is a no op.
    nvRenderPoint,
    nvRenderLine,
    nvRenderTriangle,
    nvRenderNoOp,           // 4  - not supported.
    nvRenderNoOp,           // 5  - not supported.
    nvRenderNoOp,           // 6  - not supported.
    nvRenderNoOp,           // 7  - not supported.
    nvRenderNoOp,           // 8  - not supported.
    nvRenderNoOp,           // 9  - not supported.
    nvRenderNoOp,           // 10 - not supported.
    nvRenderNoOp,           // 11 - not supported.
    nvRenderNoOp,           // 12 - not supported.
    nvRenderNoOp,           // 13 - not supported.
    nvRenderNoOp            // 14 - not supported.
};

DWORD nvRenderNoOp
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderNoOp - Unhandled instruction opcode");
    return (DD_OK);
}

DWORD nvRenderTriangle
(
    DWORD           dwPrimCount,
    LPBYTE          lpPrim,
    LPD3DTLVERTEX   lpVertices
)
{
    /*
     * Call the appropriate wrapper function.
     */
    switch (pCurrentContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
    {
        case D3DFILL_SOLID:
#ifdef NV_FASTLOOPS
            nvTriangleDispatch(dwPrimCount,(LPWORD)lpPrim,LEGACY_STRIDES,(LPBYTE)lpVertices);
#else
            fnDX5IndexedTable[pCurrentContext->dwFunctionLookup](dwPrimCount, (LPWORD)lpPrim, LEGACY_STRIDES, lpVertices);
#endif
            break;
        case D3DFILL_WIREFRAME:
            nvIndexedWireframeTriangle(dwPrimCount, (LPWORD)lpPrim, LEGACY_STRIDES, lpVertices);
            break;
        case D3DFILL_POINT:
            nvIndexedPointTriangle(dwPrimCount, (LPWORD)lpPrim, LEGACY_STRIDES, lpVertices);
            break;
    }
    return (DD_OK);
}

#ifndef WINNT
/*
 * Old style execute buffer entry point.
 */
DWORD __stdcall nvRenderPrimitive
(
    LPD3DHAL_RENDERPRIMITIVEDATA    prd
)
{
    LPD3DINSTRUCTION    lpIns;
    LPBYTE              lpData;
    DWORD               dwPrimCount;
    LPBYTE              lpPrim;
    LPD3DTLVERTEX       lpVertices;

#ifdef NV_NULL_DRIVER
    prd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    /*
     * NOTES:
     *
     * This callback is invoked when a primitive is to be rendered.
     * All the data is known to be clipped.
     *
     * Get the pointer to the context this texture is associated with.
     */
    DPF_LEVEL(NVDBG_LEVEL_DDI_ENTRY, "nvRenderPrimitive - hContext = %08lx", prd->dwhContext);
    if (!(pCurrentContext = (PNVD3DCONTEXT)prd->dwhContext))
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderPrimitive - Bad Context");
        prd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    NvSetDriverDataPtrFromContext(pCurrentContext);
    if (!pDriverData->NvDevFlatDma)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderPrimitive - Bad Context");
        prd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Check z-visibility test.
     */
    if (pCurrentContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        /*
         * If you don't implement Z visibility testing, just do this.
         */
        prd->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        prd->ddrval    = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->fFullScreenDosOccurred)
    {
        if (pDriverData->fFullScreenDosOccurred & 0x01)
            nvD3DReenable();
        else
        {
            prd->ddrval = DD_OK;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    if (pCurrentContext->dwContextReset)
        nvResetContext((PNVD3DTEXTURE)NULL);

    /*
     * Setup frequently accessed globals.
     */
    NV_D3D_GLOBAL_SETUP();
    NV_AA_SEMANTICS_CHECK(pCurrentContext);
    if ((pCurrentContext->dwStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pCurrentContext);

    /*
     * prep fvf data
     */
    {
        DWORD dwDummy1,dwDummy2;
        CHECK_FVF_DATA_AND_LOAD_TL (fvfData,D3DFVF_TLVERTEX,dwDummy1,dwDummy2);
    }

    /*
     * Always read the current free count on entry.
     */
#ifdef  CACHE_FREECOUNT
    nvFreeCount = pDriverData->dwDmaPusherFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#else   // CACHE_FREECOUNT
    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, sizeDx5TriangleTLVertex);
#endif  // CACHE_FREECOUNT

    /*
     * If the context has changed since the last render call, switch it now.
     */
    nvSetD3DSurfaceState(pCurrentContext);

    /*
     * Prepare to parse the instructions.
     */
    prd->ddrval = DD_OK;
    lpData      = (LPBYTE)(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem);
    lpIns       = &prd->diInstruction;
    dwPrimCount = lpIns->wCount;
    lpPrim      = (LPBYTE)(lpData + prd->dwOffset);
    lpVertices  = (LPD3DTLVERTEX)((LPBYTE)((LPDDRAWI_DDRAWSURFACE_INT)prd->lpTLBuf)->lpLcl->lpGbl->fpVidMem + prd->dwTLOffset);
    pfnRenderPrimitiveOperation[lpIns->bOpcode](dwPrimCount, lpPrim, lpVertices);

    /*
     * Update the put offset.
     */
    nvStartDmaBuffer (TRUE);

    /*
     * The DEBUG driver has a flag that can be set to force a flush after every triangle
     * rendering call.  This is helpful for debugging when dbgFrontRender is enabled.
     */
    dbgFlushDmaBuffers(pCurrentContext);

    /*
     * Tell DDRAW that thee global clip state has changed.
     * Probably don't need this, but I'd rather be safe.
     */
    pDriverData->ddClipUpdate = TRUE;
#ifdef  CACHE_FREECOUNT
    pDriverData->dwDmaPusherFreeCount = nvFreeCount;
#ifdef  DEBUG
    NvCheckCachedFreeCount(nvFreeCount, pDriverData->NvDmaPusherPutAddress);
#endif  /* DEBUG */
#endif  // CACHE_FREECOUNT

    /*
     * Show that 3D rendering has occurred.
     */
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    /*
     * Return successfully.
     */
    NV_D3D_GLOBAL_SAVE();
    return (DDHAL_DRIVER_HANDLED);
}
#endif // #ifndef WINNT
#endif  NV4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNACCESS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnaccess.asm
;
; Purpose:      This file implements the BeginAccess and EndAccess
;               Functions.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_BeginAccess
;
; Purpose:      This function is the BeginAccess display driver callback
;               function used by other modules that need to syncronize
;               frame buffer access and access to the hardware.
;
; Arguments:    BeginAccess display driver stack frame
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC GENERIC_BeginAccess, PASCAL, FRAME, FAR16
PARMD   lpDevice
PARMW   wLeft
PARMW   wTop
PARMW   wRight
PARMW   wBottom
PARMW   wFlags
OPENPROC
        PUSHR   ds,esi
        mov	ds,cs:[wFlatDataSel]
        mov	esi,cs:[CSpGNLogicalDevice]
	bts	ds:[esi].DIBENGINE.deFlags,BUSY_BIT
	jc	BA_End

        test    wFlags,FB_ACCESS
        jz      @F
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
	jne	@F
        mov	esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess
@@:
	test	wFlags,CURSOREXCLUDE
	jz	@F

	mov	eax,lpDevice
	cmp	eax,cs:[CSlp16LogDevice]
	jne	@F

	push	lpDevice
	push	wLeft
	push	wTop
	push	wRight
	push	wBottom
	pushw	CURSOREXCLUDE
	call	DIB_BeginAccess
@@:
	; Turn off BUSY bit
        mov	esi,cs:[CSpGNLogicalDevice]
	and	ds:[esi].DIBENGINE.deFlags,NOT BUSY
BA_End:
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_EndAccess
;
; Purpose:      This function is the EndAccess display driver callback
;               function. It is called by other modules after they have
;               finished accessing the frame buffer or other hardware.
;
; Arguments:    EndAccess display driver stack frame
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC GENERIC_EndAccess, PASCAL, FRAME, FAR16
PARMD   lpDevice
PARMW   wFlags
OPENPROC
	test	wFlags,CURSOREXCLUDE
	jz	EA_End

        PUSHR   ds,esi
        mov	ds,cs:[wFlatDataSel]
        mov	esi,cs:[CSpGNLogicalDevice]
	bts	ds:[esi].DIBENGINE.deFlags,BUSY_BIT
	jc	EA_Popr

        test    wFlags,FB_ACCESS
        jz      @F
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
	jne	@F
        mov	esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess
@@:
	mov	eax,lpDevice
	cmp	eax,cs:[CSlp16LogDevice]
	jne	@F

	push	lpDevice
	pushw	CURSOREXCLUDE
	call	DIB_EndAccess

@@:
	; Turn off BUSY bit
        mov	esi,cs:[CSpGNLogicalDevice]
	and	ds:[esi].DIBENGINE.deFlags,NOT BUSY

EA_Popr:
        POPR    ds,esi
EA_End:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnblt.asm
;
; Purpose:      This file holds the Biblt display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

IFDEF DEBUG
PUBLIC  bVramToVram, bMonoToVram, bColorToVram, bToSystem
bVramToVram     DB      0
bMonoToVram     DB      0
bColorToVram    DB      0
bToSystem       DB      0
ENDIF

;==============================================================================
;
; Function:     GENERIC_BitBlt
;
; Purpose:      This function is the BitBlt display driver entry point.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_BitBlt, PASCAL, FRAME, FAR16
BITBLT_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi

        ; Filter out old style destinations
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev
        movzx   edi,byte ptr [dwRop3 + 2]
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]

        cmp     gs:[esi].DIBENGINE.deType,0
        je      GN_BitBltSystemMemoryDst

        ; New style dst with DIBENG Header. Filter based upon deFlags.
        movzx   eax,gs:[esi].DIBENGINE.deFlags
        movzx   edx,ds:[ebx].DIBENGINE.deFlags
        movzx   ecx,cs:Rop3Table[edi]
        test    ah,VRAM / 256
        jz      GN_BitBltSystemMemoryDst
        test    dh,PALETTE_XLAT / 256
        jnz     GN_BitBltPunt

        ; is it by BOARD or by CRTC? Depends how DOS works.
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_BitBltPunt

        ; Dispatch to routine based upon the rop
        cmp     cl,PAD
        je      GN_BitBltPatDstRop
        movsx   edx,byte ptr [dwRop3 + 2]
        cmp     cl,OND
        je      @f
        cmp     cl,PSD
        je      GN_BitBltPatUnknownSrcUnknownDstVram
        jmp     GN_BitBltSrcUnknownDstVram
@@:
        mov     ebx,ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   ecx,byte ptr [dwRop3 + 2]
        jmp     HW_BitBltSolidPatDstRop                                         

GENERIC_BitBlt  ENDP


;==============================================================================
;
; Function:     BitBlt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of BitBlt. You can either return a success code, a failure
;               code, punt to the DIBENG, etc.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_BitBltPunt
GN_BitBltPunt   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL  Punt_BitBlt
        jmp     DIB_BitBlt
GN_BitBltPunt   ENDP

PUBLIC  GN_BitBltFail
GN_BitBltFail   PROC    NEAR
        sub     eax,eax
        jmp     GN_BitBltExit
GN_BitBltFail   ENDP

PUBLIC  GN_BitBltSuccess
GN_BitBltSuccess        PROC    NEAR
        mov     eax,1
GN_BitBltSuccess        ENDP

PUBLIC  GN_BitBltExit
GN_BitBltExit   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 20H
GN_BitBltExit   ENDP


;==============================================================================
;
; Function:     GN_BitBltPatDstRop
;
; Purpose:      This function does a bitblt when the rop involves a
;               pattern only or a pattern and a dst. This function
;               expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               ds              Context selector
;               gs:esi          ptr to lpDstDev
;               edi             rop
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltPatDstRop
GN_BitBltPatDstRop      PROC    NEAR

        mov     es,word ptr lpBrush+2
        movzx   edi,word ptr lpBrush+0
        mov     cl,byte ptr es:[edi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[edi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[edi].DIB_Brush8.dp8BrushBits
        mov     ebx,ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        cmp     cl,BS_HOLLOW
        je      GN_BitBltSuccess
        jnc     @F
        test    al,COLORSOLID
        jz      HW_BitBltColorPatDstRop
        movzx   ecx,byte ptr [dwRop3 + 2]
        jmp     HW_BitBltSolidPatDstRop
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      GN_BitBltFail
        test    al,PATTERNMONO
        jz      HW_BitBltColorPatDstRop
IsMono:
        sub     edx,edx
        lfs     dx,lpDrawMode
        mov     eax,fs:[edx].DRAWMODE.TextColor
        mov     ecx,fs:[edx].DRAWMODE.bkColor
        lea     edi,[edi].DIB_Brush8.dp8BrushMono
        jmp     HW_BitBltMonoPatDstRop
IsHatch:
        mov     eax,es:[edi].DIB_Brush8.dp8BgColor
        mov     ecx,es:[edi].DIB_Brush8.dp8FgColor
        lea     edi,[edi].DIB_Brush8.dp8BrushMask
        jmp     HW_BitBltMonoPatDstRop

GN_BitBltPatDstRop      ENDP


;==============================================================================
;
; Function:     GN_BitBltPatUnknownSrcUnknownDstVram
;
; Purpose:      This function does a bitblt when the rop involves a src
;               and a pattern and the dst is in Vram. This function
;               expects to be jumped to, not called.
;
;               This routine will call the hardware to set up the
;               pattern and then continue on as if it were just a
;               src,dst blt.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               gs:esi          lpDstDev
;               ds              Context selector
;               ebx             GNLOGDEVCX ptr
;               edi             rop
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltPatUnknownSrcUnknownDstVram
GN_BitBltPatUnknownSrcUnknownDstVram    PROC    NEAR

        mov     es,word ptr lpBrush+2
        movzx   esi,word ptr lpBrush+0
        push    lpDrawMode
        call    GN_PrepareBrush
        or      eax,eax
        jl      GN_BitBltFail
        je      GN_BitBltSuccess

        ; Reload the lpDstDev
        sub     esi,esi
        lgs     si,lpDstDev
        .errnz  $ - OFFSET GN_BitBltSrcUnknownDstVram

GN_BitBltPatUnknownSrcUnknownDstVram    ENDP



;==============================================================================
;
; Function:     GN_BitBltSrcUnknownDstVram
;
; Purpose:      This function does a bitblt when the rop involves a src
;               and the dst is in Vram. It may also involve a pattern
;               and the dst, but it doesn't have to. This function
;               expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               gs:esi          lpDstDev
;               ds              Context selector
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltSrcUnknownDstVram
GN_BitBltSrcUnknownDstVram      PROC    NEAR

        ; Load a ptr to the source device
        mov     es,word ptr lpSrcDev+2
        movzx   edi,word ptr lpSrcDev+0

        ; First priority is to clip the source
        call    GN_BitBltClipSrc
        or      eax,eax
        je      GN_BitBltSuccess

        ; Dispatch the blt to the correct place
        sub     eax,eax
        mov     dwScansPerSeg,7FFFH
        movzx   ecx,es:[edi].DIBENGINE.deFlags
        cmp     ax,es:[edi].DIBENGINE.deType
        je      OldStyleSrc
        test    ch,VRAM / 256
        jnz     GN_BitBltSrcVramDstVram
        cmp     es:[edi].DIBENGINE.deBitsPixel,1
        jne     GN_BitBltSrcColorDstVram_1
        mov     eax,dword ptr es:[edi].DIBENGINE.deBits
        mov     bx,word ptr es:[edi].DIBENGINE.deBits+4
        mov     ecx,es:[edi].DIBENGINE.deDeltaScan
        mov     edx,7FFFH
        jmp     GN_BitBltSrcMonoDstVram_1

OldStyleSrc:
        cmp     es:[edi].BITMAP.bmBitsPixel,1
        jne     GN_BitBltPunt
        mov     edx,07FFFH
        cmp     ax,es:[edi].BITMAP.bmSegmentIndex
        je      @F
        movzx   ecx,es:[edi].BITMAP.bmScanSegment
        mov     dwScansPerSeg,ecx
        movzx   eax,wSrcY
        sub     edx,edx
        div     cx
        sub     ecx,edx
        mov     edx,ecx
@@:
        movzx   ecx,es:[edi].BITMAP.bmWidthBytes
        movzx   eax,word ptr es:[edi].BITMAP.bmBits
        movzx   ebx,word ptr es:[edi].BITMAP.bmBits+2
        movzx   edi,es:[edi].BITMAP.bmFillBytes
        jmp     GN_BitBltSrcMonoDstVram_1

GN_BitBltSrcUnknownDstVram      ENDP


;==============================================================================
;
; Function:     GN_BitBltClipSrc
;
; Purpose:      This function clips the src adjusting the stack parameters
;               for BitBlt appropriately to represent the clipped coords
;               and clipped extents.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               es:edi  lpSrcDev
;
; Returns:      eax     1 - there is something to draw
;                       0 - there is nothing to draw
;
; Preserve:     ds,esi,es,edi,fs
;==============================================================================
PUBLIC  GN_BitBltClipSrc
GN_BitBltClipSrc        PROC    NEAR

        movsx   eax,wSrcX
        movsx   ecx,wSrcY
        movzx   ebx,es:[edi].DIBENGINE.deWidth
        movzx   edx,es:[edi].DIBENGINE.deHeight
        or      eax,eax
        js      ClipLeft
cld1:   or      ecx,ecx
        js      ClipTop
clt:    add     ax,wExtX
        add     cx,wExtY
        sub     ax,bx
        jg      ClipRight
clr:    sub     cx,dx
        jg      ClipBottom
clb:    mov     eax,1
        ret

ClipLeft:
        add     wExtX,ax
        jle     ClipDone
        sub     wDstX,ax
        sub     eax,eax
        mov     wSrcX,ax
        jmp     cld1

ClipTop:
        add     wExtY,cx
        jle     ClipDone
        sub     wDstY,cx
        sub     ecx,ecx
        mov     wSrcY,cx
        jmp     clt

ClipRight:
        sub     wExtX,ax
        jg      clr
        jmp     ClipDone

ClipBottom:
        sub     wExtY,cx
        jg      clb

ClipDone:
        sub     eax,eax
        ret

GN_BitBltClipSrc        ENDP


;==============================================================================
;
; Function:     GN_BitBltSrcVramDstVram
;
; Purpose:      This function does a bitblt when the rop involves a source,
;               the source is in VRAM, and the dst is in VRAM. The rop may
;               also involve the dst and a pattern, but it may not. This
;               routine calls the hardware specific routine
;               HW_BitBltSrcVramDstVram to do the actual blt.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               es:edi          lpSrcDev
;               gs:esi          lpDstDev
;               ds              Context selector
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_BitBltSrcVramDstVram
GN_BitBltSrcVramDstVram PROC    NEAR

IFDEF DEBUG
        cmp     cs:[bVramToVram],0
        jne     GN_BitBltPunt
ENDIF
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    lpSrcDev
        push    lpBrush
        push    lpDrawMode
        push    dword ptr wDstY
        push    dword ptr wSrcY
        push    dword ptr wExtY
        push    dwRop3
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltPunt
        jmp     GN_BitBltFail

GN_BitBltSrcVramDstVram ENDP


;==============================================================================
;
; Function:     GN_BitBltSrcMonoDstVram_1
;
; Purpose:      This function does a bitblt when a source is involved,
;               the source is a mono bitmap, and the dst is in VRAM. The
;               rop may also involve the dst and a pattern, but it may
;               not. This routine calls the generic routine
;               GN_BitBltSrcMonoDstVram_1 to do the actual blt.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               es              selector of lpSrcDev
;               gs:esi          selector of lpDstDev
;               ds              Context selector
;               dwScansPerSeg   scans per segment of the mono bitmap
;               edx             starting from and including the wSrcY
;                               coord, this is the number of scanlines
;                               in the mono bitmap before there is a
;                               segment crossing (when you need to
;                               adjust the src pointer to account for
;                               the fillbytes.)
;               edi             padding bytes at the end of each segment
;               bx              src selector points to src bits
;               eax             src offset points to src bits
;               ecx             pitch of src bitmap in bytes
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
;==============================================================================
PUBLIC  GN_BitBltSrcMonoDstVram_1
GN_BitBltSrcMonoDstVram_1 PROC  NEAR

IFDEF DEBUG
        cmp     cs:[bMonoToVram],0
        jne     GN_BitBltPunt
ENDIF
        mov     dwSrcBitsOffset,eax

        ; Let the hardware specific code handle the transfer.
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        movzx   eax,wDstX
        push    eax
        movzx   eax,wDstY
        push    eax
        push    ebx                             ; src sel
        push    dwSrcBitsOffset                 ; offset to src bits
        push    ecx                             ; src pitch in bytes
        xor     ebx,ebx                         ; clear high word of EBX
        les     bx,lpDrawMode
        movzx   eax,wSrcX
        push    eax
        movzx   eax,wSrcY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        push    es:[ebx].DRAWMODE.TextColor
        push    es:[ebx].DRAWMODE.bkColor
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        push    edx
        push    dwScansPerSeg
        push    edi                             ; fill bytes
        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltFail
        jmp     GN_BitBltPunt

GN_BitBltSrcMonoDstVram_1 ENDP


;==============================================================================
;
; Function:     GN_BitBltSrcColorDstVram_1
;
; Purpose:      This function does a bitblt when a source is involved,
;               the source is a color DIBENG bitmap, and the dst is in
;               VRAM. The rop may also involve the dst and a pattern,
;               but it may not. This routine calls the hardware specific
;               routine HW_BitBltSrcMonoDstVram to do the actual blt.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               gs:esi          lpDstDev
;               es:edi          lpSrcDev
;               ds              Context selector
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
;==============================================================================
PUBLIC  GN_BitBltSrcColorDstVram_1
GN_BitBltSrcColorDstVram_1      PROC    NEAR

IFDEF DEBUG
        cmp     cs:[bColorToVram],0
        jne     GN_BitBltPunt
ENDIF
        ; Let the vendor handle the whole thing
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        movzx   ecx,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        push    ecx
        push    gs:[esi].DIBENGINE.deDeltaScan
        movzx   eax,wDstX
        push    eax
        movzx   eax,wDstY
        push    eax
        movzx   eax, word ptr es:[edi].DIBENGINE.deBits+4
        mov     ecx,dword ptr es:[edi].DIBENGINE.deBits+0
        push    eax
        push    ecx
        movzx   eax,es:[edi].DIBENGINE.deBitsPixel
        mov     ecx,es:[edi].DIBENGINE.deDeltaScan
        push    eax
        push    ecx
        movzx   eax,wSrcX
        push    eax
        movzx   eax,wSrcY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        sub     eax,eax
        push    eax                     ; size color table entry in bytes
        push    eax                     ; num color table entries
        push    eax                     ; lpColorTable
        push    eax
        call    HW_BitBltSrcColorDstVram
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltFail
        jmp     GN_BitBltPunt

GN_BitBltSrcColorDstVram_1      ENDP


;==============================================================================
;
; Function:     GN_BitBltSystemMemoryDst
;
; Purpose:      This routine gets jumped to when either the lpDstDev
;               points to an old BITMAP header or when lpDstDev points
;               to a new style DIBENGINE header but the deFlags field
;               does not have the VRAM bit set. Both these scenarios
;               describe a bitmap that is in system memory. We may
;               wish to handle a blt where the dst is in system memory
;               if there is also a source located in video memory since
;               we can use hardware DMA to transfer back from VRAM.
;               This function expects to be jumped to, not called.
;
; Arguments:    BitBlt Display Driver Stack Frame
;		ds:ebx		ptr GNLOGDEVCX which is also PDEVICE
;               gs:esi          lpDstDev
;               edi             rop
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the BitBlt ending routines.
;
;==============================================================================
PUBLIC  GN_BitBltSystemMemoryDst
GN_BitBltSystemMemoryDst        PROC    NEAR

IFDEF DEBUG
        cmp     cs:[bToSystem],0
        jne     GN_BitBltPunt
ENDIF

        ; Make sure hardware is not busy
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_BitBltPunt

        ; Prepare some things that we need for testing
        movzx   ecx,cs:Rop3Table[edi]

        ; If the dst is a BITMAP hdr, then punt cases where dst is color.
        cmp     gs:[esi].DIBENGINE.deType,0
        movzx   eax,gs:[esi].BITMAP.bmBitsPixel
        jne     IsDib
        cmp     eax,1
        ja      GN_BitBltPunt
        jmp     @F
IsDib:
        ; Punt dsts that we cannot handle
        test    gs:[esi].DIBENGINE.deFlags,PALETTE_XLAT
        jnz     GN_BitBltPunt
@@:
        ; Punt rops not involving a src
        cmp     cl,SAD
        jc      GN_BitBltPunt

        ; Punt if source is in system memory too.
        xor     edi,edi                 ; clear high word of EDI
        les     di,lpSrcDev
        cmp     es:[edi].DIBENGINE.deType,0
        je      GN_BitBltPunt
        test    es:[edi].DIBENGINE.deFlags,VRAM
        jz      GN_BitBltPunt

        ; We must clip to the src rectangle
        call    GN_BitBltClipSrc
        or      eax,eax
        je      GN_BitBltSuccess

        ; Call the generic code to overlap DMAing and converting.
        push    cs:[CSpGNLogicalDevice]
        push    lpDstDev
        pushd   0

        ; Get the dst parameters -- depends upon bitmap header format
        cmp     gs:[esi].DIBENGINE.deType,0
        jne     NewT
        movzx   eax,word ptr gs:[esi].BITMAP.bmBits+2
        movzx   ecx,word ptr gs:[esi].BITMAP.bmBits+0
        movzx   edx,word ptr gs:[esi].BITMAP.bmWidthBytes
        push    eax
        push    ecx
        pushd   1
        push    edx
        jmp     @F

NewT:   movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        movzx   ecx,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        push    ecx
        push    gs:[esi].DIBENGINE.deDeltaScan
@@:
        movzx   eax,wDstX
        push    eax
        movzx   eax,wDstY
        push    eax
        push    lpSrcDev
        movzx   eax,word ptr es:[edi].DIBENGINE.deBits+4
        movzx   ecx,es:[edi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr es:[edi].DIBENGINE.deBits
        push    ecx
        push    es:[edi].DIBENGINE.deDeltaScan
        movzx   eax,wSrcX
        push    eax
        movzx   eax,wSrcY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        sub     eax,eax
        push    eax
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jg      GN_BitBltSuccess
        jl      GN_BitBltFail
        jmp     GN_BitBltPunt

GN_BitBltSystemMemoryDst        ENDP


;==============================================================================
;
; Function:     GN_PrepareBrush
;
; Purpose:      This function figures out the type of brush and
;               call the hardware specific routine to load the
;               brush into the hardware.
;
; Arguments:
;               ds              Context selector
;               ebx             GNLOGDEVCX ptr
;               es:esi          lpBrush
;
; Returns:
;               eax             -1      Failure
;               eax             0       Brush was hollow
;                               1       Success
;
; Preserve:     ds
;==============================================================================
DECPROC GN_PrepareBrush, PASCAL, FRAME, NEAR
PARMD   lpDrawMode
OPENPROC
        mov     cl,byte ptr es:[esi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[esi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[esi].DIB_Brush8.dp8BrushBits
        mov     ebx,ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        cmp     cl,BS_HOLLOW
        je      IsHollow
        PUSH    OFFSET ReSetPat
        jnc     @F
        test    al,COLORSOLID
        jz      HW_LoadColorPattern
        jmp     HW_LoadSolidPattern
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      IsFail
        test    al,PATTERNMONO
        jz      HW_LoadColorPattern
IsMono:
        sub     edx,edx
        lfs     dx,lpDrawMode
        mov     ecx,fs:[edx].DRAWMODE.TextColor
        mov     edx,fs:[edx].DRAWMODE.bkColor
        lea     esi,[esi].DIB_Brush8.dp8BrushMono
        mov     eax,-1
        jmp     HW_LoadMonoPattern
IsHatch:
        mov     ecx,es:[esi].DIB_Brush8.dp8BgColor
        mov     edx,es:[esi].DIB_Brush8.dp8FgColor
        lea     esi,[esi].DIB_Brush8.dp8BrushMask
        mov     eax,-1
        jmp     HW_LoadMonoPattern

IsHollow:
        sub     eax,eax
        jmp     DoneIt

IsFail:
        mov     eax,-1
        jmp     DoneIt

ReSetPat:
        mov     eax,1
DoneIt:
CLOSEPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUBLIC  Rop3Table
Rop3Table       LABEL   BYTE
DB      OND,    PSD,    PSD,    PSD,    PSD,    PAD,    PSD,    PSD
DB      PSD,    PSD,    PAD,    PSD,    PSD,    PSD,    PSD,    PAD

DB      PSD,    SAD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    SAD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PAD,    PSD,    PSD,    PSD,    PSD,    OND,    PSD,    PSD
DB      PSD,    PSD,    PAD,    PSD,    PSD,    PSD,    PSD,    PAD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    SAD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    SAD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      SAD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    SAD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD

DB      PAD,    PSD,    PSD,    PSD,    PSD,    PAD,    PSD,    PSD
DB      PSD,    PSD,    OND,    PSD,    PSD,    PSD,    PSD,    PAD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    SAD,    PSD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    SAD,    PSD,    PSD

DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    PSD
DB      PSD,    PSD,    PSD,    PSD,    PSD,    PSD,    SAD,    PSD

DB      PAD,    PSD,    PSD,    PSD,    PSD,    PAD,    PSD,    PSD
DB      PSD,    PSD,    PAD,    PSD,    PSD,    PSD,    PSD,    OND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\x86\x86.h ===
#ifndef _x86_h
#define _x86_h
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: x86.h                                                             *
*   x86 architexture specific macros - used mainly to generate assembly     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/10/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

/*****************************************************************************
 * constants
 *****************************************************************************/

/*
 * registers
 */
#define rEAX            0
#define rECX            1
#define rEDX            2
#define rEBX            3
#define rESP            4
#define rEBP            5
#define rESI            6
#define rEDI            7

#define rAX             0
#define rCX             1
#define rDX             2
#define rBX             3
#define rSP             4
#define rBP             5
#define rSI             6
#define rDI             7

#define rAL             0
#define rCL             1
#define rDL             2
#define rBL             3
#define rAH             4
#define rCH             5
#define rDH             6
#define rBH             7

#define rMM0            0
#define rMM1            1
#define rMM2            2
#define rMM3            3
#define rMM4            4
#define rMM5            5
#define rMM6            6
#define rMM7            7

#define rXMM0           0
#define rXMM1           1
#define rXMM2           2
#define rXMM3           3
#define rXMM4           4
#define rXMM5           5
#define rXMM6           6
#define rXMM7           7

#define rST0            0
#define rST1            1
#define rST2            2
#define rST3            3
#define rST4            4
#define rST5            5
#define rST6            6
#define rST7            7

/*
 * op codes
 *  alphabetically sorted
 */
#define xADD_r_rm(r,rm)         x86s(2) x86b(0x03) x86b(mREG(r) | (rm))
#define xADD_r_i32(r,a)         x86s(6) x86b(0x03) x86b(mREG(r) | mOFS32) x86d(a)
#define xADD_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(0) | (rm)) x86b(i)
#define xADD_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(0) | (rm)) x86d(i)
#define xADD_rm_r(rm,r)         x86s(2) x86b(0x01) x86b(mREG(r) | (rm))
#define xADD_i32_r(a,r)         x86s(6) x86b(0x01) x86b(mREG(r) | mOFS32) x86d(a)

#define xAND_r_rm(r,rm)         x86s(2) x86b(0x23) x86b(mREG(r) | (rm))
#define xAND_r_i32(r,a)         x86s(6) x86b(0x23) x86b(mREG(r) | mOFS32) x86d(a)
#define xAND_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(4) | (rm)) x86b(i)
#define xAND_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(4) | (rm)) x86d(i)

#define xCALL_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(2) | (rm))

#define xCMP_r_rm(r,rm)         x86s(2) x86b(0x3b) x86b(mREG(r) | (rm))
#define xCMP_r_i32(r,a)         x86s(6) x86b(0x3b) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMP_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(7) | (rm)) x86d(i)

#define xDEC_r(r)               x86s(1) x86b(0x48 | (r))
#define xDEC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(1) | (rm))
#define xDEC_i32(a)             x86s(6) x86b(0xff) x86b(mREG(1) | mOFS32) x86d(a)

#define xFADD_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(0) | mOFS32) x86d(a)
#define xFADDP_st(r)            x86s(2) x86b(0xde) x86b(0xc0 + (r))

#define xFISTP_rm32(rm)         x86s(2) x86b(0xdb) x86b(mREG(3) | (rm))
#define xFISTP_i32(a)           x86s(6) x86b(0xdb) x86b(mREG(3) | mOFS32) x86d(a)

#define xFLD_rm32(rm)           x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_i32(a)             x86s(6) x86b(0xd9) x86b(mREG(0) | mOFS32) x86d(a)
#define xFLD_st(r)              x86s(2) x86b(0xd9) x86b(0xc0 + (r))
#define xFLD1                   x86s(2) x86b(0xd9) x86b(0xe8)

#define xFMUL_st(r)             x86s(2) x86b(0xd8) x86b(0xc8 + (r))
#define xFMUL_rm32(rm)          x86s(2) x86b(0xd8) x86b(mREG(1) | (rm))
#define xFMUL_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(1) | mOFS32) x86d(a)
#define xFMULP_st(r)            x86s(2) x86b(0xde) x86b(0xc8 + (r))

#define xFSUBP_st(r)            x86s(2) x86b(0xde) x86b(0xe8 + (r))
#define xFSUBRP_st(r)           x86s(2) x86b(0xde) x86b(0xe0 + (r))

#define xFSTP_rm(rm)            x86s(2) x86b(0xd9) x86b(mREG(3) | (rm))
#define xFSTP_i32(a)            x86s(6) x86b(0xd9) x86b(mREG(3) | mOFS32) x86d(a)

#define xFXCH_st(r)             x86s(2) x86b(0xd9) x86b(0xc8 + (r))

#define xINC_r(r)               x86s(1) x86b(0x40 | (r))
#define xINC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(0) | (rm))

#define xIMUL_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | (rm))
#define xIMUL_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | mOFS32) x86d(a)

#define xINT3                   x86s(1) x86b(0xcc)

#define xJA(disp)               { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x77) x86b(_x) }
#define xJA32(disp)             { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x87) x86d(_x) }
#define xJL(disp)               { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7c) x86b(_x) }
#define xJL32(disp)             { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8c) x86d(_x) }
#define xJNZ(disp)              { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x75) x86b(_x) }
#define xJNZ32(disp)            { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x85) x86d(_x) }
#define xJZ(disp)               { DWORD _x = (disp)-(ilcCount+2); x86s(2) x86b(0x74) x86b(_x) }
#define xJZ32(disp)             { DWORD _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x84) x86d(_x) }

#define xJMP(disp)              { DWORD _x = (disp)-(ilcCount+5); x86s(5) x86b(0xe9) x86d(_x) }

#define xLEA_r_rm(r,rm)         x86s(2) x86b(0x8d) x86b(mREG(r) | (rm))

#define xMOV_r_rm(r,rm)         x86s(2) x86b(0x8b) x86b(mREG(r) | (rm))                     // mov eax,[ebx]
#define xMOV_r_i32(r,a)         x86s(6) x86b(0x8b) x86b(mREG(r) | mOFS32) x86d(a)           // mov eax,[1234h]
#define xMOV_rm_imm(rm,i)       x86s(6) x86b(0xc7) x86b(mREG(0) | (rm)) x86d(i)               // mov ebp,12345678
#define xMOV_rm_r(rm,r)         x86s(2) x86b(0x89) x86b(mREG(r) | (rm))                     // mov [ebx],eax
#define xMOV_i32_r(a,r)         x86s(6) x86b(0x89) x86b(mREG(r) | mOFS32) x86d(a)           // mov [1234h],eax
#define xMOV_r_rm8(r,rm)        x86s(2) x86b(0x8a) x86b(mREG(r) | (rm))                     // mov al,[ebx]
#define xMOV_rm8_r(rm,r)        x86s(2) x86b(0x88) x86b(mREG(r) | (rm))                     // mov [ebx],al

#define xNOP                    x86s(1) x86b(0x90)

#define xNOT_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(2) | (rm))

#define xOR_r_rm(r,rm)          x86s(2) x86b(0x0b) x86b(mREG(r) | (rm))
#define xOR_r_i32(r,a)          x86s(6) x86b(0x0b) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_r(r,rm)          x86s(2) x86b(0x09) x86b(mREG(r) | (rm))
#define xOR_i32_r(a,r)          x86s(6) x86b(0x09) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_imm(rm,i)        x86s(6) x86b(0x81) x86b(mREG(1) | (rm)) x86d(i)

#define xPOP_r(r)               x86s(1) x86b(0x58 | (r))
#define xPOP_rm(rm)             x86s(2) x86b(0xff) x86b(0x30 | (rm))
#define xPOPAD                  x86s(1) x86b(0x61)

#define xPUSH_r(r)              x86s(1) x86b(0x50 | (r))
#define xPUSH_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(6) | (rm))
#define xPUSH_i32(a)            x86s(6) x86b(0xff) x86b(mREG(6) | mOFS32) x86d(a)
#define xPUSH_imm(i)            x86s(5) x86b(0x68) x86d(i)
#define xPUSHAD                 x86s(1) x86b(0x60)

#define xRET                    x86s(1) x86b(0xc3)

#define xSBB_r_rm(r,rm)         x86s(2) x86b(0x1b) x86b(mREG(r) | (rm))
#define xSBB_r_i32(r,a)         x86s(6) x86b(0x1b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSBB_rm_r(rm,r)         x86s(2) x86b(0x19) x86b(mREG(r) | (rm))

#define xSETG_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9f) x86b(rm)
#define xSETGE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9d) x86b(rm)
#define xSETNZ_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x95) x86b(rm)
#define xSETZ_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x94) x86b(rm)

#define xSHL_rm_imm(rm,i)       x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)

#define xSHR_rm_imm(rm,i)       x86s(3) x86b(0xc1) x86b(mREG(5) | (rm)) x86b(i)

#define xSUB_r_rm(r,rm)         x86s(2) x86b(0x2b) x86b(mREG(r) | (rm))
#define xSUB_r_i32(r,a)         x86s(2) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_r(rm,r)         x86s(2) x86b(0x29) x86b(mREG(r) | (rm))
#define xSUB_i32_r(a,r)         x86s(2) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(5) | (rm)) x86b(i)
#define xSUB_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(5) | (rm)) x86d(i)

#define xTEST_rm_r(rm,r)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_i32_r(a,r)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_r_i32(r,a)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_rm_imm(rm,i)      x86s(6) x86b(0xf7) x86b(mREG(0) | (rm)) x86d(i)

#define xXOR_r_rm(r,rm)         x86s(2) x86b(0x33) x86b(mREG(r) | (rm))
#define xXOR_r_i32(r,a)         x86s(6) x86b(0x33) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_r(rm,r)         x86s(2) x86b(0x31) x86b(mREG(r) | (rm))
#define xXOR_i32_r(a,r)         x86s(6) x86b(0x31) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(6) | (rm)) x86d(i)

/*
 * mmx opcodes
 */
#define xMOVQ_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | (rm))
#define xMOVQ_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | (rm))

#define xEMMS                   x86s(2) x86b(0x0f) x86b(0x77)

/*
 * katmai opcodes
 */
#define xMOVAPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x28) x86b(mREG(r) | (rm))
#define xMOVAPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x29) x86b(mREG(r) | (rm))

#define xMOVUPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVUPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))

#define xMOVHPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r) | (rm))
#define xMOVHPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x16) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x17) x86b(mREG(r) | (rm))

#define xMOVLPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r) | (rm))
#define xMOVLPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x12) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x13) x86b(mREG(r) | (rm))
/*****************************************************************************
 * macros
 *****************************************************************************/

/*
 * emission
 */
#define x86s(x)                 if ((ilcCount+(x)) > ilcMax) ILCGrowTo(ilcCount+(x));
#define x86b(x)                 ilcData[ilcCount]=(BYTE)(x);              ilcCount++;
#define x86d(x)                 *(DWORD*)(ilcData+ilcCount) = (DWORD)(x); ilcCount+=4;

/*
 * mod r/m
 */
#define mOFS32                  rmIND(rEBP)
#define mREG(x)                 ((x) << 3)

#define rmIND(x)                (0x00 | (x))
#define rmIND8(x)               (0x40 | (x))
#define rmIND32(x)              (0x80 | (x))
#define rmREG(x)                (0xc0 | (x))
#define rmSIB                   rmIND(rESP)
#define rmSIB8                  rmIND8(rESP)
#define rmSIB32                 rmIND32(rESP)

#define x1                      0
#define x2                      1
#define x4                      2
#define x8                      3
#define xSIB(r1,r2,s)           x86s(1) x86b((r1) | ((r2)<<3) | ((s)<<6))

#define x16r                    x86s(1) x86b(0x66)
#define x16m                    x86s(1) x86b(0x67)

#define xDS                     x86s(1) x86b(0x3e)

#define xOFS8(e)                x86s(1) x86b(e)
#define xOFS32(e)               x86s(4) x86d(e)

/*****************************************************************************
 * externals
 *****************************************************************************/
void ILCGrowTo (DWORD dwNeed);

#endif //x86.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBMPBTS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnbmpbts.asm
;
; Purpose:      This file holds the BitmapBits display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

DDB_SET                 EQU     1
DDB_GET                 EQU     2
DDB_COPY                EQU     4
DDB_SETWITHFILLER       EQU     8

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_BitmapBits
;
; Purpose:      This function is the BitmapBits display driver entry point.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
; Returns:      The return values from the functions vary.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_BitmapBits, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMD   dwFlags
PARMD   dwCount
PARMD   lpBits

LOCALD  dwBytesToCopyPerWholeScan
LOCALD  dwBytesToCopyPerPartialScan
LOCALD  dwPixelsToCopyPerWholeScan
LOCALD  dwWholeScansToCopy
LOCALD  dwTotalBytesToCopy
LOCALD  dwDstWrapWidth
LOCALD  dwSrcWrapWidth
LOCALD  dwSrcBpp
LOCALD  dwInVram
LOCALD  dwXferHeight
OPENPROC
        PUSHR   ds,esi,edi

        ; Check and block copies to the screen if it is busy
        mov     fs,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     fs:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_BitmapBitsPuntNoWait

        mov     eax,dwFlags
        mov     dwInVram,0
        cmp     eax,1
        je      BitmapBits_Set
        cmp     eax,4
        jc      BitmapBits_Get
        je      BitmapBits_Copy
        jmp     BitmapBits_SetWithFiller

GENERIC_BitmapBits      ENDP

;==============================================================================
;
; Function:     BitmapBits ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of BitmapBits. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_BitmapBitsPunt
GN_BitmapBitsPunt       PROC    NEAR
        sub     esi,esi
        lds     si,lpDstDev
        movzx   eax,ds:[esi].DIBENGINE.deFlags
        test    eax,VRAM
        jz      GN_BitmapBitsPuntNoWait

        ; Syncronize with the engine
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess

PLABEL  GN_BitmapBitsPuntNoWait
        POPR    ds,esi,edi
        STOPPROC
PLABEL  Punt_BitmapBits
        jmp     DIB_BitmapBits
GN_BitmapBitsPunt       ENDP

PUBLIC  GN_BitmapBitsSuccess
GN_BitmapBitsSuccess    PROC    NEAR
        mov     eax,dwTotalBytesToCopy
        shld    edx,eax,10H
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 10H
GN_BitmapBitsSuccess    ENDP


;==============================================================================
;
; Function:     BitmapBits_Set
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_SET. In this flavor
;               of the routine, the idea is to copy dwCount bytes from
;               the raw flat linear data buffer pointed to by lpBits
;               to the dst bitmap whose header is pointed to by lpDstDev.
;
;               If lpDstDev points to a VRAM bitmap, then use the hardware
;               to do the transfer.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_Set
BitmapBits_Set  PROC    NEAR

        ; Load up a ptr to the dst bitmap header
        sub     esi,esi
        sub     edi,edi
        lds     si,lpDstDev

        ; Compute the smaller of bytes requested and size of bitmap.
        movzx   eax,ds:[esi].DIBENGINE.deHeight
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        imul    eax,ebx
        cmp     eax,dwCount
        jc      @F
        mov     eax,dwCount
@@:     mov     dwTotalBytesToCopy,eax

        ; Punt dst that we can't handle (this almost never happens)
        movzx   eax,ds:[esi].DIBENGINE.deFlags
        test    eax,SELECTEDDIB
        jnz     GN_BitmapBitsPunt
        test    eax,VRAM
        jz      NotVrm
        mov     dwInVram,1

        ; We may be able to use the hardware, but only if the
        ; number of bytes we are asked to copy is an integral
        ; number of scanlines. If there is a partial scanline,
        ; then we could do it, but since we only process
        ; rectangles with the hardware, we would have to do it
        ; in two operations. The 2 rect case almost never
        ; happens, so we use software for the case.
        mov     eax,dwTotalBytesToCopy
        movzx   ecx,ds:[esi].DIBENGINE.deWidthBytes
        sub     edx,edx
        idiv    ecx
        mov     dwXferHeight,eax
        or      edx,edx
        jne     NotVrm

        ; USE THE HARDWARE HERE
        ; Let the vendor handle the whole thing
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr ds:[esi].DIBENGINE.deBits+4
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr ds:[esi].DIBENGINE.deBits
        push    ecx
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        movzx   eax,word ptr lpBits+2
        movzx   ecx,word ptr lpBits+0
        push    eax
        push    ecx
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        movzx   ecx,ds:[esi].DIBENGINE.deWidthBytes
        push    eax
        push    ecx
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,word ptr ds:[esi].DIBENGINE.deWidth
        push    eax
        push    dwXferHeight
        mov     ecx,0CC0000H
        push    ecx
        push    ebx                                             ;lpBrush
        push    ebx                                             ;lpDrawMode
        push    ebx                                             ;size color table entry in bytes
        push    ebx                                             ;num color table entries
        push    ebx                                             ;lpColorTable
        push    ebx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcColorDstVram
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        je      NotVrm
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

NotVrm:
        ; Load up the ptrs
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        les     edi,ds:[esi].DIBENGINE.deBits
        lds     si,lpBits
        mov     dwBytesToCopyPerWholeScan,ebx
        sub     ecx,ebx
        je      BitmapBits_CopyAll

        ; The pitch and width of the bitmap are not the same so ...
        sub     eax,eax
        mov     dwDstWrapWidth,ecx
        mov     dwSrcWrapWidth,eax
        jmp     BitmapBits_CopyByScan

BitmapBits_Set  ENDP


;==============================================================================
;
; Function:     BitmapBits_SetWithFiller
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_SETWITHFILLER. In
;               this flavor of the routine, you copy dwCount bytes from
;               the src bitmap whose header is pointed to by lpBits to
;               the dst bitmap whose header is pointed to by lpDstDev.
;
;               This is like a BitmapBits_Set except that the raw data
;               buffer pointed to by lpBits is not flat. There are fill
;               bytes to prevent a break in the src data for a scanline.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_SetWithFiller
BitmapBits_SetWithFiller        PROC    NEAR

        ; Load up a ptr to the src bitmap header
        sub     esi,esi
        sub     edi,edi
        lds     si,lpDstDev

        movzx   eax,ds:[esi].DIBENGINE.deFlags
        test    al,SELECTEDDIB
        jnz     GN_BitmapBitsPunt

        ; If the width in bytes of the dst is a power of 2 less than
        ; 64K, then we can treat the src as flat since there will be
        ; zero fillbytes.
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        mov     eax,10000H
        sub     edx,edx
        div     ebx
        or      edx,edx
        je      BitmapBits_Set

        ; Also, we can treat the src as flat if we don't need to transfer
        ; more than 64K.
        cmp     ax,ds:[esi].DIBENGINE.deHeight
        ja      BitmapBits_Set

        ; Else, we are going to have to do it -- I vote we punt!
        ; This case almost never happens.
        jmp     GN_BitmapBitsPunt

BitmapBits_SetWithFiller        ENDP


;==============================================================================
;
; Function:     BitmapBits_Get
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_GET. In this flavor
;               of the routine, the idea is to copy dwCount bytes from
;               the src bitmap whose header is pointed to by lpDstDev to
;               the raw flat linear data buffer pointed to by lpBits.
;
;               If lpDstDev points to a VRAM bitmap, then use the hardware
;               DMA to do the transfer.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_Get
BitmapBits_Get  PROC    NEAR

        ; Load up a ptr to the src bitmap header
        sub     esi,esi
        sub     edi,edi
        lds     si,lpDstDev

        ; Copy the smaller of bytes requested and size of bitmap.
        movzx   eax,ds:[esi].DIBENGINE.deHeight
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        imul    eax,ebx
        cmp     eax,dwCount
        jc      @F
        mov     eax,dwCount
@@:     mov     dwTotalBytesToCopy,eax

        ; Punt dsts (actually sources in this case) that we can't handle
        mov     ax,ds:[esi].DIBENGINE.deFlags
        test    ax,SELECTEDDIB
        jnz     GN_BitmapBitsPunt
        test    eax,VRAM
        jz      NotVrm
        mov     dwInVram,1

        ; We may be able to use the hardware, but only if the
        ; number of bytes we are asked to copy is an integral
        ; number of scanlines. If there is a partial scanline,
        ; then we could do it, but since we only process
        ; rectangles with the hardware, we would have to do it
        ; in two operations. The 2 rect case almost never
        ; happens, so we use software for the case.
        mov     eax,dwTotalBytesToCopy
        movzx   ecx,ds:[esi].DIBENGINE.deWidthBytes
        sub     edx,edx
        idiv    ecx
        mov     dwXferHeight,eax
        or      edx,edx
        jne     NotVrm

        ; USE THE HARDWARE HERE
        ; Call the generic code to overlap DMAing and converting.
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        push    lpDstDev
        push    ebx
        movzx   eax,word ptr lpBits+2
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        movzx   eax,word ptr lpBits
        push    eax
        push    ecx
        movzx   eax,ds:[esi].DIBENGINE.deWidthBytes
        push    eax
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        push    ebx                                             ;lpSrcDev
        movzx   eax,word ptr ds:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr ds:[esi].DIBENGINE.deBits
        push    ecx
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,ds:[esi].DIBENGINE.deWidth
        push    eax
        push    dwXferHeight
        mov     eax,0CC0000H
        push    eax
        push    ebx
        push    ebx
        movzx   ebx,cs:bTableBppToIndex[ecx]
        mov     edx,ebx
        cmp     ebx,MAX_BPP_INDICES
        jge     NotVrm
        imul    ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
        push    ecx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        je      NotVrm
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

NotVrm:
        ; Load up the ptrs
        movzx   ebx,ds:[esi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        les     di,lpBits
        lds     esi,ds:[esi].DIBENGINE.deBits
        mov     dwBytesToCopyPerWholeScan,ebx
        sub     ecx,ebx
        je      BitmapBits_CopyAll

        ; The pitch and width of the bitmap are not the same so ...
        sub     eax,eax
        mov     dwSrcWrapWidth,ecx
        mov     dwDstWrapWidth,eax
        jmp     BitmapBits_CopyByScan

BitmapBits_Get  ENDP


;==============================================================================
;
; Function:     BitmapBits_Copy
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY. In this flavor
;               of the routine, the idea is to copy dwCount bytes from
;               the src bitmap whose header is pointed to by lpBits to
;               the dst bitmap whose header is pointed to by lpDstDev.
;
;               If one of lpBits or lpDstDev points to a header which
;               is in VRAM, then hardware acceleration can be used.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  BitmapBits_Copy
BitmapBits_Copy PROC    NEAR

        ; Load up the ptrs to both bitmap headers
        sub     esi,esi
        sub     edi,edi
        lds     si,lpBits
        les     di,lpDstDev
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        mov     dwSrcBpp,eax

        ; With two bitmaps, things are different. We will not copy
        ; more bytes per scan than the narrower of two bitmaps.
        movzx   eax,ds:[esi].DIBENGINE.deWidthBytes
        movzx   ecx,es:[edi].DIBENGINE.deWidthBytes
        movzx   edx,ds:[esi].DIBENGINE.deWidth
        cmp     eax,ecx
        jc      @F
        movzx   edx,es:[edi].DIBENGINE.deWidth
        mov     eax,ecx
@@:     mov     dwBytesToCopyPerWholeScan,eax
        mov     dwPixelsToCopyPerWholeScan,edx

        ; We will not copy more scans than the shorter of the two.
        movzx   ebx,ds:[esi].DIBENGINE.deHeight
        movzx   edx,es:[edi].DIBENGINE.deHeight
        cmp     ebx,edx
        jc      @F
        mov     ebx,edx
@@:     mov     dwWholeScansToCopy,ebx

        ; For this call, we ignore the dwCount parameter and just copy
        ; the src to the dst clipping to the smaller of the two bitmaps.
        imul    eax,ebx
        mov     dwTotalBytesToCopy,eax

        ; Figure out how many scans this number of bytes correpsonds to:
        sub     edx,edx
        div     dwBytesToCopyPerWholeScan
        mov     dwBytesToCopyPerPartialScan,edx
        cmp     eax,dwWholeScansToCopy
        jc      @F
        mov     dwBytesToCopyPerPartialScan,0
        mov     eax,dwWholeScansToCopy
@@:     mov     dwWholeScansToCopy,eax

        ; Punt those we don't handle (very rare that we punt)
        movzx   eax,ds:[esi].DIBENGINE.deFlags
        movzx   ebx,es:[edi].DIBENGINE.deFlags
        test    eax,SELECTEDDIB
        jnz     GN_BitmapBitsPunt
        test    ebx,SELECTEDDIB
        jnz     GN_BitmapBitsPunt

        ; Now break out into the four cases --
        ; sys->sys, sys->vram, vram->sys, vram->vram
        ; We can use the hardware for the last three cases
        test    eax,VRAM
        jz      @F
        test    ebx,VRAM
        jnz     BitmapBits_CopyVramToVram
        jmp     BitmapBits_CopyVramToSystem
@@:     test    ebx,VRAM
        jnz     BitmapBits_CopySystemToVram
        jmp     BitmapBits_CopySystemToSystem

BitmapBits_Copy ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyVramToVram
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               and dst bitmaps are both known to be in vram.
;
;               Since, in this call, we are asked to do a certain number
;               of bytes and not a specified rectangle, it may be that
;               there are some whole number of scans to be copied and then
;               a portion of a scan. We must treat these as two separate
;               blts.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopyVramToVram
BitmapBits_CopyVramToVram       PROC    NEAR

        cmp     dwWholeScansToCopy,0
        je      @F
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    lpBits
        sub     eax,eax
        push    eax                             ; lpBrush
        push    eax                             ; lpDrawMode
        push    eax                             ; wDstX:wDstY
        push    eax                             ; wSrcX:wSrcY
        mov     eax,dwPixelsToCopyPerWholeScan
        shl     eax,10H
        or      eax,dwWholeScansToCopy
        push    eax                             ; wExtX:wExtY
        mov     ecx,0CC0000H
        push    ecx
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jle     FailHW
@@:
        ; Do the extra portion of a scan
        cmp     dwBytesToCopyPerPartialScan,0
        je      GN_BitmapBitsSuccess
        mov     esi,cs:[CSpGNLogicalDevice]
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    lpBits
        sub     eax,eax
        push    eax                             ; lpBrush
        push    eax                             ; lpDrawMode
        mov     eax,dwWholeScansToCopy
        push    eax                             ; wDstX:wDstY
        push    eax                             ; wSrcX:wSrcY

        ; To how many pixels do the extra bytes correspond?
        mov     eax,dwBytesToCopyPerPartialScan
        cmp     dwSrcBpp,8
        je      @F
        shr     eax,1
        cmp     dwSrcBpp,32
        jc      @F
        shr     eax,1
@@:     shl     eax,10H
        mov     ax,1
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      GN_BitmapBitsSuccess

FailHW:
        jmp     BitmapBits_CopySystemToSystem

BitmapBits_CopyVramToVram       ENDP


;==============================================================================
;
; Function:     BitmapBits_CopySystemToVram
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               bitmap is in system memory and the and dst bitmap is in
;               VRAM.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               ds:esi  DIBENGINE ptr for src
;               es:edi  DIBENGINE ptr for dst
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopySystemToVram
BitmapBits_CopySystemToVram     PROC    NEAR

        ; Let the vendor handle the whole thing
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr es:[edi].DIBENGINE.deBits+4
        movzx   ecx,es:[edi].DIBENGINEHDR.bRealBpp
        push    eax
        push    dword ptr es:[edi].DIBENGINE.deBits
        push    ecx
        push    es:[edi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        movzx   eax,word ptr es:[edi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[edi].DIBENGINE.deBits
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        push    eax
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,word ptr ds:[esi].DIBENGINE.deWidth
        push    eax
        movzx   eax,word ptr ds:[esi].DIBENGINE.deHeight
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        push    ebx                                             ;lpBrush
        push    ebx                                             ;lpDrawMode
        push    ebx                                             ;size color table entry in bytes
        push    ebx                                             ;num color table entries
        push    ebx                                             ;lpColorTable
        push    ebx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcColorDstVram
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        mov     dwInVram,1
        je      BitmapBits_CopySystemToSystem
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

BitmapBits_CopySystemToVram     ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyVramToSystem
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               bitmap is in video memory and the and dst bitmap is in
;               system memory.
;
;               Since, in this call, we are asked to do a certain number
;               of bytes and not a specified rectangle, it may be that
;               there are some whole number of scans to be copied and then
;               a portion of a scan. We must treat these as two separate
;               blts.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopyVramToSystem
BitmapBits_CopyVramToSystem     PROC    NEAR

        ; Call the generic code to overlap DMAing and converting.
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        push    lpDstDev
        push    ebx
        movzx   eax,es:[edi].DIBENGINEHDR.deBitsSelector
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[edi].DIBENGINEHDR.deBitsOffset
        push    ecx
        push    es:[edi].DIBENGINEHDR.deDeltaScan
        push    ebx                                             ;wDstX
        push    ebx                                             ;wDstY
        push    ebx                                             ;lpSrcDev
        movzx   eax,ds:[esi].DIBENGINEHDR.deBitsSelector
        movzx   ecx,ds:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    ds:[esi].DIBENGINEHDR.deBitsOffset
        push    ecx
        push    ds:[esi].DIBENGINE.deDeltaScan
        push    ebx                                             ;wSrcX
        push    ebx                                             ;wSrcY
        movzx   eax,ds:[esi].DIBENGINE.deWidth
        push    eax
        movzx   eax,ds:[esi].DIBENGINE.deHeight
        push    eax
        mov     eax,0CC0000H
        push    eax
        push    ebx
        push    ebx
        movzx   ebx,cs:bTableBppToIndex[ecx]
        mov     edx,ebx
        imul    ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
        push    ecx
        mov     ds,cs:[wFlatDataSel]
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jg      GN_BitmapBitsSuccess
        mov     dwInVram,1
        je      BitmapBits_CopySystemToSystem
        mov     dwTotalBytesToCopy,0
        jmp     GN_BitmapBitsSuccess                            ;Failure

BitmapBits_CopyVramToSystem     ENDP


;==============================================================================
;
; Function:     BitmapBits_CopySystemToSystem
;
; Purpose:      This function is jumped to when the BitmapBits routine
;               is called with dwFlags equal to DDB_COPY AND the src
;               and dst bitmaps are both in system memory.
;
;               Since, in this call, we are asked to do a certain number
;               of bytes and not a specified rectangle, it may be that
;               there are some whole number of scans to be copied and then
;               a portion of a scan. We must treat these as two separate
;               blts.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwBytesToCopyPerWholeScan
;               dwPixelsToCopyPerWholeScan
;               dwWholeScansToCopy              can be 0
;               dwBytesToCopyPerPartialScan     can be 0
;
;==============================================================================
PUBLIC  BitmapBits_CopySystemToSystem
BitmapBits_CopySystemToSystem   PROC    NEAR

        ; Reload these ptrs and do it in software
        sub     esi,esi
        sub     edi,edi
        lds     si,lpBits
        les     di,lpDstDev

        ; We can treat the bitmaps as one big linear array of bytes if
        ; the width in bytes and pitches of the bitmaps match.
        movzx   eax,ds:[esi].DIBENGINE.deWidthBytes
        movzx   ebx,es:[edi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        mov     edx,es:[edi].DIBENGINE.deDeltaScan
        add     eax,3
        add     ebx,3
        and     eax,NOT 3
        and     ebx,NOT 3
        cmp     eax,ebx
        jne     AsRect
        cmp     eax,ecx
        jne     AsRect
        cmp     ebx,edx
        jne     AsRect

        ; Linear it is, copy up all the bytes desired
        imul    ecx,dwWholeScansToCopy
        add     ecx,dwBytesToCopyPerPartialScan
        mov     dwTotalBytesToCopy,ecx
        lds     esi,ds:[esi].DIBENGINE.deBits
        les     edi,es:[edi].DIBENGINE.deBits
        jmp     BitmapBits_CopyAll

AsRect:
        ; Compute wrap widths, load ptrs and go copy it
        sub     ecx,dwBytesToCopyPerWholeScan
        sub     edx,dwBytesToCopyPerWholeScan
        mov     dwSrcWrapWidth,ecx
        mov     dwDstWrapWidth,edx
        lds     esi,ds:[esi].DIBENGINE.deBits
        les     edi,es:[edi].DIBENGINE.deBits
        jmp     BitmapBits_CopyByScan

BitmapBits_CopySystemToSystem   ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyByScan
;
; Purpose:      This function is jumped to when we are ready to copy
;               data from one place to another. Unfortunately,it is
;               not just one long linear block, but rather rectangle
;               to rectangle. Wait for idle, if needed, and then copy.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               ds:esi                  ptr to src bits
;               es:edi                  ptr to dst bits
;               dwTotalBytesToCopy
;               dwBytesToCopyPerWholeScan
;               dwSrcWrapWidth
;               dwDstWrapWidth
;
;==============================================================================
PUBLIC  BitmapBits_CopyByScan
BitmapBits_CopyByScan   PROC    NEAR

        cmp     dwInVram,0
        jz      @F

        ; Syncronize with the engine
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess
@@:
        ; Compute the dword and partial dword counts
        mov     eax,dwBytesToCopyPerWholeScan
        mov     edx,dwTotalBytesToCopy
        jmp     @F
LoopY:
        mov     ecx,eax
        shr     ecx,2
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,eax
        and     ecx,3
        rep     movs byte ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
@@:     sub     edx,eax
        jge     LoopY

        ; Check for a partial scan
        add     edx,eax
        jle     GN_BitmapBitsSuccess
        mov     ecx,edx
        shr     ecx,2
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,edx
        and     ecx,3
        rep     movs byte ptr es:[edi], ds:[esi]

        cmp     dwInVram,0
        jz      GN_BitmapBitsSuccess
        push    cs:[CSlp16LogDevice]
        pushw   FB_ACCESS
        call    GENERIC_EndAccess
        jmp     GN_BitmapBitsSuccess

BitmapBits_CopyByScan   ENDP


;==============================================================================
;
; Function:     BitmapBits_CopyAll
;
; Purpose:      This function is jumped to when we are ready to copy
;               data from one place to another. It is just one long
;               linear block. We may need to wait for idle, though.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;               dwTotalBytesToCopy
;
;==============================================================================
PUBLIC  BitmapBits_CopyAll
BitmapBits_CopyAll      PROC    NEAR

        cmp     dwInVram,0
        jz      @F

        ; Syncronize with the engine
        push    lpDstDev
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess
@@:
        mov     ecx,dwTotalBytesToCopy
        shr     ecx,2
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,dwTotalBytesToCopy
        and     ecx,3
        rep     movs byte ptr es:[edi], ds:[esi]

        cmp     dwInVram,0
        jz      GN_BitmapBitsSuccess
        push    lpDstDev
        pushw   FB_ACCESS
        call    GENERIC_EndAccess
        jmp     GN_BitmapBitsSuccess

BitmapBits_CopyAll      ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBOARD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnboard.asm
;
; Purpose:      This file holds init routines for the GNBOARDCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  szDisplayDeviceName
szDisplayDeviceName     DB      "DISPLAY",0

;==============================================================================
;
; Function:     GN_FindBoardContext
;
; Purpose:      This routine searches to see if a GNBOARDCX exists
;               for the board specified.
;
;		If this routine finds a GNBOARDCX already active on
;		this board, then it establishes the wFlatDataSelector
;		in the code segments. If it does not find one, then
;		the flat data selectors are left untouched.
;
; Arguments:
;               dwBoardDevnode
;
; Returns:      eax             GNBOARDCX ptr
;                               0 if there are no instances yet
;
;		If there are instances, then ds has the context selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindBoardContext, PASCAL, FRAME, FAR16
PARMD   dwBoardDevnode
OPENPROC
	; We need a flat data selector temporarily
        mov     eax,1
        sub     ebx,ebx
        mov     ecx,-1
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
	mov	ds,ax

	; Now get the global mapping ptr
        call    HW_GetLogdevToBoardPtr

        ; Search the mapping array looking for this board context
        mov     ebx,eax
        mov     ecx,dwBoardDevnode
        sub     eax,eax
Back1:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      FreeFlat
        cmp     ecx,ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle
        jne     @F
        mov     eax,ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset
        jmp     FreeFlat
@@:
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back1

FreeFlat:
	mov	dx,ds
	sub	cx,cx
	or	eax,eax
	je	@F
        mov	ecx,ds:[eax].GNBOARDCX.dwFlatDataSelector
        mov     es,wNVTEXT32_Alias_In_NVTEXT16
        mov     es:[wFlatDataSel],cx
        mov     es,wNVTEXT16_Alias_In_NVTEXT16
        mov     es:[wFlatDataSel_In_NVTEXT16],cx
@@:
        mov	ds,cx
	push	eax
	mov	eax,edx
        call    GN_UnmapAndFreeSelector
        pop	eax
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_CreateBoardContext
;
; Purpose:      This routine initializes a GNBOARDCX structure.
;
;		This routine stablishes the wFlatDataSelector
;		in the code segments.
;
; Arguments:
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateBoardContext, PASCAL, FRAME, FAR16
PARMD   dwThisLogDeviceHandle
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi
        sub     esi,esi

        ; Allocate memory for the GNBOARDCX
        pushd   SIZE GNBOARDCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

	; We need a flat data selector that everyone can use
        mov     eax,1
        sub     ebx,ebx
        mov     ecx,-1
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt

        ; Put the flat selector in both code segments
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[wFlatDataSel],ax
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[wFlatDataSel_In_NVTEXT16],ax
        mov	ds,ax
        mov	ds:[esi].GNBOARDCX.dwFlatDataSelector,eax

        ; we are initting. Cleared at end of first modeset.
        mov     ds:[esi].GNBOARDCX.dwInitting,1

        ; Init this to 0
        mov     ds:[esi].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,0

        ; DirectX is not active right now
        mov     ds:[esi].GNBOARDCX.dwDirectXActive,0

        ; Crete a HW board context
        push    dwThisLogDeviceHandle
        call    HW_CreateBoardContext
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].GNBOARDCX.pHWBoardCX,eax

        ; Ask RM about free offscreen space on this board
        push    eax
        call    HW_GetLargestOffscreenBlock
        mov     ds:[esi].GNBOARDCX.dwMemorySizeForValidateMode,eax

	; Create a heap
        mov     eax,MAX_OFFSCREEN_BITMAPS
        call    GN_HeapCreate
        mov     ds:[esi].GNBOARDCX.dwOffscreenHeap,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        or	eax,eax
        je	DoneIt
        and     ds:[esi].GNBOARDCX.dwOffscreenFlags,NOT OFFS_HEAP_UNAVAILABLE

        push    esi
        call    GN_GetNumCRTCs
        mov     ds:[esi].GNBOARDCX.dwNumCrtcsOnBoard,eax

        ; We want the board path into the registry.
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        push    eax
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo
        mov     ecx,sDispInfo.diDevNodeHandle
        mov     ds:[esi].GNBOARDCX.dwDeviceNodeHandle,ecx

        ; Build a 16:16 ptr to the display path. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNBOARDCX.szLocalDisplayBasePath
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNBOARDCX.lpLocalDisplayBasePath,eax

        ; Fill in the actual path to our board registry stuff
        push    ds:[esi].GNBOARDCX.dwDeviceNodeHandle
        mov     ax,ds
        push    eax
        lea     ecx,[esi].GNBOARDCX.szLocalDisplayBasePath
        push    ecx
        sub     eax,eax
        mov     ax,SEG szDisplayDeviceName
        push    eax
        mov     ax,OFFSET szDisplayDeviceName
        movzx   eax,ax
        push    eax
        call    GN_GetDeviceLocalBasePath

        ; Init offset to bitmap info
        lea     eax,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,eax

        ; Clear/Reset the offscreen bitmap manager.
        push    esi
        call    GN_ClearOffscreenBitmapCache

        call    HW_GetLogdevToBoardPtr

        ; Search the mapping array looking for an empty slot
        ; and save off the GNBOARDCX there.
        mov     ebx,eax
        mov     ecx,ds:[esi].GNBOARDCX.dwDeviceNodeHandle
Back1:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      FoundIt
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back1
FoundIt:
        mov     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,ecx
        mov     ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset,esi

        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the GNBOARDCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; GN_DestroyBoardContext can clean up partial inits
        push    esi
        call    GN_DestroyBoardContext
        sub     eax,eax

ExitIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyBoardContext
;
; Purpose:      This routine destroys a GNBOARDCX structure.
;               You do not need to free its memory. Just free any
;               resources inside the structure.
;
; Arguments:
;               ds                      Selector for the board Context data
;               pGNBoardCXOffset        Offset to the board context data
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyBoardContext, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNBoardCXOffset
        or      esi,esi
        je      DoneIt

        ; If the DeviceNodeHandle is 0, then we didn't get far enough
        ; in the init to add an entry to the LOGDEVTOBOARD structure.
        cmp     ds:[esi].GNBOARDCX.dwDeviceNodeHandle,0
        je      NextThing

        ; Search the mapping array looking for this GNBOARDCX.
        call    HW_GetLogdevToBoardPtr
        mov     ebx,eax
        mov     ecx,ds:[esi].GNBOARDCX.dwDeviceNodeHandle
Back1:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      NextThing
        cmp     ecx,ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle
        je      FoundIt
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back1

FoundIt:
        ; Find the end of the array
        mov     edx,ebx
Back2:
        cmp     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,0
        je      FoundEnd
        add     ebx,SIZE LOGDEVTOBOARD
        jmp     Back2

FoundEnd:
        ; Copy the last entry in the array down into the entry we
        ; are removing. Then zero out the final entry
        sub     ebx,SIZE LOGDEVTOBOARD
        mov     eax,ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset
        mov     ds:[edx].LOGDEVTOBOARD.dwGNBoardCXOffset,eax
        mov     eax,ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle
        mov     ds:[edx].LOGDEVTOBOARD.dwBoardDevnodeHandle,eax
        sub     eax,eax
        mov     ds:[ebx].LOGDEVTOBOARD.dwGNBoardCXOffset,eax
        mov     ds:[ebx].LOGDEVTOBOARD.dwBoardDevnodeHandle,eax

NextThing:
        ; Free up the 16:16 base path ptr if need be
        cmp     ds:[esi].GNBOARDCX.lpLocalDisplayBasePath,0
        je      @f
        mov     eax,ds:[esi].GNBOARDCX.lpLocalDisplayBasePath
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNBOARDCX.lpLocalDisplayBasePath,0
@@:
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        or	eax,eax
        je	@F
        call    GN_HeapDestroy
        mov     ds:[esi].GNBOARDCX.dwOffscreenHeap,0
@@:
        cmp     ds:[esi].GNBOARDCX.pHWBoardCX,0
        je      @F
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        call    HW_DestroyBoardContext
        mov     ds:[esi].GNBOARDCX.pHWBoardCX,0
@@:

	; The following may have been allocated in the
	; SHARED MEMORY escapes. We need to free the
	; memory blocks if so.
	sub	ecx,ecx
LoopSM:
	mov	eax,ds:[esi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData
	or	eax,eax
	je	@F
	mov	ds:[esi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,0
	PUSHR	ecx
	shr	eax,10H
	call	GN_MemoryFree
	POPR	ecx
@@:	inc	ecx
	cmp	ecx,MAX_SHARED_MEM_BLOCKS
	jc	LoopSM

	; Free the flat data selector
	mov	eax,ds:[esi].GNBOARDCX.dwFlatDataSelector
	or	eax,eax
	je	@F

	; To prevent the system chash we have to change DS
	; because it points to the selector we are going free.
	sub	ebx,ebx
	mov	ds,bx
	call	GN_UnmapAndFreeSelector

@@:
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_AttachLogicalDeviceToBoard
;
; Purpose:      This routine attaches a logical device to a given
;               board by placing the logical device into the array
;               of GNLOGDEVCXs in the GNBOARDCX structure.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax                     0 failure
;                                       non-0 success
;                                       In this case, ecx is the
;                                       0 based instance number
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AttachLogicalDeviceToBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNLogdevCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        sub     edx,edx
        sub     eax,eax
@@:
        cmp     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        je      Found
        inc     eax
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      @B

        ; UhOh ... What is wrong here? This shouldn't happen.
        sub     eax,eax
        jmp     DoneIt
Found:
        mov     ecx,pGNLogdevCXOffset
        mov     ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4],ecx
        inc     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
        mov     ecx,eax
        mov     eax,1
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ReattachLogicalDeviceToBoard
;
; Purpose:      This routine searches for the logical device / board
;               combination and then updates the GNBOARDCXs knowledge
;               of what GNLOGDEVCXs are attached to it.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNLogdevCXOffsetOld    GNLOGDEVCX ptr
;               pGNLogdevCXOffsetNew    GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ReattachLogicalDeviceToBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNLogdevCXOffsetOld
PARMD   pGNLogdevCXOffsetNew
OPENPROC
        mov     ebx,pGNBoardCXOffset
        mov     edx,pGNLogdevCXOffsetOld
        sub     eax,eax
@@:
        cmp     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        je      Found
        inc     eax
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      @B

        ; UhOh ... What is wrong here? This shouldn't happen.
        ; Cross your fingers and return slot 1 ....
        mov     eax,1
Found:
        mov     ecx,pGNLogdevCXOffsetNew
        mov     ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4],ecx
CLOSEPROC


;==============================================================================
;
; Function:     GN_DetachLogicalDeviceFromBoard
;
; Purpose:      This routine detaches a logical device from a
;               given board.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax     Number of logical devices left attached to
;                       the board after this one detaches
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DetachLogicalDeviceFromBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNLogdevCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        mov     edx,pGNLogdevCXOffset
        sub     eax,eax
@@:
        cmp     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        je      Found
        inc     eax
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      @B
        jmp     DoneIt

Found:
        mov     ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4],0

        ; One less logical device on this board
        dec     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
DoneIt:
        mov     eax,ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetPciDeviceID
;
; Purpose:      This routine gets the PCI Device ID of the board.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     Frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetPciDeviceID, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        call    HW_GetPciDeviceID
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetFrameBufferSelector
;
; Purpose:      This routine gets the frame buffer selector.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     Frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetFrameBufferSelector, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        call    HW_GetFrameBufferSelector
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetNumCRTCs
;
; Purpose:      This routine gets the number of physical CRTCs
;               on the board.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     Frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetNumCRTCs, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        call    HW_GetNumCRTCs
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetBoardRegistryPath
;
; Purpose:      This routine gets the registry path to the board
;               info.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     ptr to a REGDATA structure describing registry path
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetBoardRegistryPath, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset
        mov     eax,ds:[ebx].GNBOARDCX.lpLocalDisplayBasePath
CLOSEPROC


CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNBOARD2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnboard2.asm
;
; Purpose:      This file holds run-time routines for GNBOARDCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_BoardMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_BoardMessage, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi
        mov     esi,pGNBoardCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        jmp     ChainIt

PreMS:
        ; Free up the memory used for offscreen allocations.
        ; This will appropriately flush all bitmaps to system
        ; memory as required.
        push    pGNBoardCXOffset
        pushd   0
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

PostMS:
        ; Alloc the memory used for offscreen allocations
        ; if DirectX is not running.
        cmp     ds:[esi].GNBOARDCX.dwDirectXActive,0
        jne     @F
        push    pGNBoardCXOffset
        pushd   1
        call    GN_ControlOffscreenAllocations
@@:
        ; We are no longer initting after the first modeset
        mov     ds:[esi].GNBOARDCX.dwInitting,0
        jmp     ChainIt

DXEnum:
        jmp     ChainIt

DXOn:
        ; DirectX is coming up.
        mov     ds:[esi].GNBOARDCX.dwDirectXActive,1

        ; Flush all offscreen bitmaps
        ; Free up the memory used for offscreen allocations.
        push    pGNBoardCXOffset
        pushd   0
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

DXOff:
        ; DirectX is going away.
        mov     ds:[esi].GNBOARDCX.dwDirectXActive,0

        ; Alloc the memory used for offscreen allocations
        push    pGNBoardCXOffset
        pushd   1
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

DosOff:
PowerOn:
        ; Clear H/W busy for ALL logical devices.
        mov     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX
        mov     ecx,ds:[ebx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        lea     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX

@@:
        mov     eax,ds:[ebx]
        or      eax,eax
        je      NextLogdevOff

        ; Enable HW access to device
        mov     ds:[eax].GNLOGDEVCX.dwHardwareBusy,0

NextLogdevOff:
        add     ebx,4
        loop    @B
        jmp     ChainIt

DosOn:
PowerOff:
        ; Flush all offscreen bitmaps
        push    pGNBoardCXOffset
        call    GN_ClearOffscreenBitmapCache

        ; Set H/W busy for ALL logical devices.
        mov     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX
        mov     ecx,ds:[ebx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        lea     ebx,ds:[esi].GNBOARDCX.pGNLogdevCX

@@:
        mov     eax,ds:[ebx]
        or      eax,eax
        je      NextLogdevOn

        ; Disable HW access to device
        mov     ds:[eax].GNLOGDEVCX.dwHardwareBusy,1

NextLogdevOn:
        add     ebx,4
        loop    @B
        jmp     ChainIt

DrvDis:
        ; Free up the memory used for offscreen allocations.
        ; ONLY if this is the primary driver. Any secondary
        ; disabling should not free the memory.
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        je      FlushOffscreen
        test    dwThisLogicalDeviceHandle_In_NVTEXT16,03H
        jnz     ChainIt

FlushOffscreen:
        push    pGNBoardCXOffset
        pushd   0
        call    GN_ControlOffscreenAllocations
        jmp     ChainIt

ChainIt:
        ; Call the hardware to inform it of the message
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    HW_BoardMessage
        jmp     DoneIt

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_IsDevDataUniqueOnBoard
;
; Purpose:      This routine runs through all the CRTCCXs on the board
;               and sees if anyone else is using the same device and number
;               as the CRTCCX passed in. For example, you can call
;               this routine if you want to know, "is someone else
;               using CRT4?" or "is someone else using DFP6?" or
;               "TV2", etc.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNCrtcCXOffset         GNCRTCCX
;
; Returns:
;               eax                     TRUE no one else is using
;                                       the device and number in
;                                       the CRTCCX passed in
;                                       FALSE, someone is using it
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_IsDevDataUniqueOnBoard, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNCrtcCXOffset
LOCALD  dwDesiredDevData
OPENPROC
        PUSHR   esi,edi
        push    pGNCrtcCXOffset
        call    GN_GetDevData
        mov     dwDesiredDevData,eax

        mov     eax,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Is this the CRTCCX that we are comparing against?
        cmp     esi,pGNCrtcCXOffset
        je      NextCrtc

        ; No, so see if this enumerated CRTCCX's DevData is
        ; the same as the DevData in the passed in CRTCCX
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData
        cmp     ax,word ptr dwDesiredDevData
        POPR    eax,ebx,ecx,edx
        je      NotUnique

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

Unique:
        mov     eax,1
        jmp     DoneIt

NotUnique:
        sub     eax,eax
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_FindFirstCloneDevice
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board looking to see if any of them have a clone device.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;               ebx                     GNLOGDEVCX ptr if one is found
;                                       that has a clone device.
;                                       Else 0
;               eax                     Which phys device number it is
;                                       if ebx is not 0.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindFirstCloneDevice, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
LOCALD  dwDesiredDevData
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev

        ; Start with the first clone
        mov     edx,1

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Ah! We found a clone device. Let's return it
        mov     ebx,ecx
        mov     eax,edx
        jmp     DoneIt

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; Didn't find one
        sub     ebx,ebx
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SendDevicesRemapMsgToAllLogDevs
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board and sends a MSG_DEVICESREMAPPED to each one.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SendDevicesRemapMsgToAllLogDevs, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     edi,edi

LoopLogdev:
        mov     eax,ds:[esi].GNBOARDCX.pGNLogdevCX[edi * 4]
        or      eax,eax
        je      NextLogdev

        push    eax
        pushd   MSG_DEVICESREMAPPED
        push    eax
        push    ds:[eax].GNLOGDEVCX.Dibeng.delpPDevice
        call    GN_LogdevMessage

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     edi
        cmp     edi,ds:[esi].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_FindLogdevWaitingToClone
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board looking to see if any of them would like to
;               have a clone device. (Generally this is the result
;               of a clone device having been "Stolen" away from them
;               if someone switches to multi-mon on the fly.)
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;               eax                     GNLOGDEVCX ptr if one is found
;                                       that wants a clone device.
;                                       Else 0
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindLogdevWaitingToClone, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
OPENPROC
        mov     ebx,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ecx,ecx

LoopLogdev:
        mov     eax,ds:[ebx].GNBOARDCX.pGNLogdevCX[ecx * 4]
        or      eax,eax
        je      NextLogdev

        cmp     ds:[eax].GNLOGDEVCX.dwNumClonesAwaited,0
        jne     DoneIt

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ecx
        cmp     ecx,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; Didn't find one
        sub     eax,eax
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_FindUnusedDevice
;
; Purpose:      This routine finds a device (and number -- like CRT6 or
;               DFP2), that is connected to the system and is not in use
;               by any other CRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwUnusedIndex           0, 1, 2, 3, etc
;                                       This tells which unused device
;                                       to find. The zeroth, first
;                                       second, etc. They are always
;                                       ordered as CRTS, DFPS, TVS
; Returns:
;               eax                     DEVDATA describing device
;                                       0x0FFFFFFFF if couldn't find one
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_FindUnusedDevice, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwUnusedIndex
LOCALD  dwAllAttachedDevices
LOCALD  dwCurrentIndex
OPENPROC
        PUSHR   esi,edi

        ; First get a list of all the devices that exist and
        ; are attached.
        mov     eax,pGNBoardCXOffset
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_GetAllAttachedDevices

        ; If there is no display device present, and this is the primary
        ; driver, then we need to drive the CRT even though it is not present.
        ; However, we only want to do this if this is not a mobile system
        ; since a mobile system is guaranteed to have an LCD, and its absence
        ; along with the absence of any other display device is extremely
        ; bad news.
        cmp     eax,0
        jne     DeviceMapCont
        
        ; Only force a device which is not present to be treated as present
        ; if we are the primary driver!
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     DeviceMapCont

        ; This routine returns whether or not this is mobile behavior.
        mov     eax,pGNBoardCXOffset
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        push    ds:[ecx].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        cmp     ax,0
        jne     ReturnNoDevice
        mov     eax,1                   ; return CRT is attached
        jmp     DeviceMapCont
        
ReturnNoDevice:
        mov     eax,0
        
DeviceMapCont:
        mov     dwAllAttachedDevices,eax

        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset
        mov     dwNumDevices,0

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Get the dev data for this CRTCCX
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData

        ; watch out for the "no device" case
        cmp     eax,-1
        je      NoDevice

        ; Form a mask out of it
        mov     ecx,eax
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl

        ; Remove this bit from the list of attached devices
IFDEF DEBUG
        ; unless someone has hot-unplugged a device, the bit
        ; we are touching should currently be ON since it is
        ; the device that some CRTCCX is actively using
        test    eax,dwAllAttachedDevices
        jnz     @F
        int     3
@@:
ENDIF
        not     eax
        and     dwAllAttachedDevices,eax

NoDevice:
        POPR    eax,ebx,ecx,edx

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; If dwAllAttachedDevices if not 0, then there is an
        ; available device. If it is 0, then there isn't a device.
        mov     ecx,dwAllAttachedDevices
        or      ecx,ecx
        je      FailIt

        ; First look at CRTS
        mov     ebx,-1

        mov     eax,DEVTYPE_CRT + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next1
        inc     ebx
        cmp     ebx,dwUnusedIndex
        je      DoneIt
Next1:  shr     cl,1
        cmp     ah,8
        jc      @B

        ; Nope. Try DFPS
        shr     ecx,8
        mov     eax,DEVTYPE_DFP + 0FF00H
@@:     inc     ah
        test    ch,1
        jz      Next2
        inc     ebx
        cmp     ebx,dwUnusedIndex
        je      DoneIt
Next2:  shr     ch,1
        cmp     ah,8
        jc      @B

        ; Lasthope is TVS
        mov     eax,DEVTYPE_TV + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next3
        inc     ebx
        cmp     ebx,dwUnusedIndex
        je      DoneIt
Next3:  shr     cl,1
        cmp     ah,8
        jc      @B

FailIt:
        mov     eax,-1
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetAllDeviceData
;
; Purpose:      This routine loads up three arrays. One will hold all the
;               devices/numbers needed by all CRTCCXs, the other will
;               hold the ptrs to the GNCRTCCXs and the last will hold
;               the ptrs to the corresponding HWCRTCCXs which want to
;               display on the corresponding device and device number
;               in the first array.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               lpDevData               DEVDATA array ptr
;               lpHWCrtcCX              ULONG array ptr (for HW Crtc CXs)
;               Maximum array length
;
; Returns:
;               eax                     number of devices found
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetAllDeviceData, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   lpDevData
PARMD   lpGNCrtcCX
PARMD   lpHWCrtcCX
PARMD   dwMaxLen
LOCALD  lpDevData_Inc
LOCALD  lpGNCrtcCX_Inc
LOCALD  lpHWCrtcCX_Inc
LOCALD  dwNumDevices
OPENPROC
        PUSHR   esi,edi
        mov     eax,lpDevData
        mov     lpDevData_Inc,eax
        mov     eax,lpHWCrtcCX
        mov     lpHWCrtcCX_Inc,eax
        mov     eax,lpGNCrtcCX
        mov     lpGNCrtcCX_Inc,eax
        mov     eax,pGNBoardCXOffset
        mov     dwNumDevices,0

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; Get the dev data for this CRTCCX
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData
        les     di,lpDevData_Inc
        mov     es:[di],eax
        add     lpDevData_Inc,4

        ; Put the corresponding HW Crtc CX ptr in the other array
        les     di,lpGNCrtcCX_Inc
        mov     es:[di],esi
        add     lpGNCrtcCX_Inc,4
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCX
        les     di,lpHWCrtcCX_Inc
        mov     es:[di],eax
        add     lpHWCrtcCX_Inc,4
        POPR    eax,ebx,ecx,edx

        inc     dwNumDevices

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; return the number of devices
        mov     eax,dwNumDevices
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDevDataMask
;
; Purpose:      This routine runs through all the CRTCCX in all
;               GNLOGDEVCXs on this board with the exception of
;               the CRTCCX passed in and forms a mask out of the
;               DEVDATAs.  The mask is as follows. The low byte
;               as a 1 in each bit where there is a CRTC in use
;               (i.e. bit 0 is set if some CRTCCX was using CRTC0, etc.)
;               Now, the next byte is the same thing for TVs and
;               the high byte is the same thing for DFPs.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:
;               eax                     device mask described in purpose
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetDevDataMask, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset
        sub     edi,edi

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev
        sub     edx,edx

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc
        cmp     esi,pGNCrtcCXOffset
        je      NextCrtc

        ; Get the dev data for this CRTCCX and OR it into the mask
        PUSHR   eax,ebx,ecx,edx
        push    esi
        call    GN_GetDevData
        shl     al,3
        add     al,ah
        mov     cl,al
        mov     ebx,1
        shl     ebx,cl
        or      edi,ebx
        POPR    eax,ebx,ecx,edx

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

        ; return the mask
        mov     eax,edi
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCNTRL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gncntrl.asm
;
; Purpose:      This file holds the Control display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include valmode.inc
include escape.inc
include tvout.inc
include modeext.inc

CONTROL_FRAME_AND_LOCALS        MACRO
PARMD   lpDstDev
PARMW   wFunction
PARMD   lpIn
PARMD   lpOut
LOCALD  dwCRTCCount
LOCALD  dwCopyStandard
LOCALD  pGNCrtcCXOffset
LOCALD  pHWCrtcCXOffset
LOCALD  pGNLogdevCXUsingTheHead
LOCALD  pGNCrtcCXUsingTheHead
LOCALD  pHWCrtcCXUsingTheHead
LOCALD  dwLogCrtcIndex
ENDM

QUERYESCSUPPORT         TEXTEQU <8>
MOUSETRAILS             TEXTEQU <39>
DCICOMMAND              TEXTEQU <3075>
EDDESCAPE                               TEXTEQU <0EEEE0000H>
EDDESC_SCROLL                   TEXTEQU <0EDD00012H>

EDDESC_SCROLL_DATA      struc
dwSize          dd      ?               ;// = sizeof(struct tagSCROLL_DATA)
dwCommand       dd      ?               ;// = EDDESC_SCROLL
cyLines         dd      ?               ;// # of lines vertical panning
EDDESC_SCROLL_DATA      ends

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_Control
;
; Purpose:      This function is the Control display driver entry point.
;               It will handle all the Windows defined escapes. Any non-
;               Windows escapes will be passed off to the hardware
;               specific routine.
;
; Arguments:    Control Display Driver Stack Frame
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Control, PASCAL, FRAME, FAR16
CONTROL_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi
        pushf
        cld

        ; We want a ptr to the GNLOGDEVCX passed in (which is
        ; not necessarily the one corresponding to this driver!
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     eax,lpDstDev
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        mov     esi,eax

        movzx   eax,wFunction
        push    OFFSET RetAddr
        cmp     eax,QUERYESCSUPPORT
        je      GN_ControlQuery
        cmp     eax,DCICOMMAND
        je      GN_ControlDDraw
        cmp     eax,MOUSETRAILS
        je      GN_MouseTrails
        add     sp,@WordSize

        push    OFFSET Done
        cmp     eax,GN_ESC_GET_PDEVICE
        je      GN_ControlReturnPDevice
        cmp     eax,GN_ESC_ALLOC_SELECTOR_AND_MAP
        je      GN_ControlAllocSelectorAndMap
        cmp     eax,GN_ESC_UNMAP_AND_FREE_SELECTOR
        je      GN_ControlUnmapAndFreeSelector
        cmp     eax,NV_ESC_ALLOC_SHARED_MEMORY
        je      GN_ControlAllocSharedMemory
        cmp     eax,NV_ESC_FREE_SHARED_MEMORY
        je      GN_ControlFreeSharedMemory
        cmp     eax,NV_ESC_GET_SHARED_MEMORY
        je      GN_ControlGetSharedMemory
        cmp     eax,GN_ESC_SET_CURSOR
        je      GN_ControlSetCursor
        cmp     eax,NV_ESC_DVD_MACROVISION_CMD
        je      GN_DvdMacrovisionCommand
        cmp     eax,OPENGL_GETINFO
        je      GN_OpenGLGetInfo
        cmp     eax,VIDEO_PARAMETERS
        je      GN_VideoParameters
        cmp     eax,NV_ESC_GET_LOCAL_REGISTRY_PATH
        je      GN_GetLocalRegistryPath
        cmp     eax,NV_ESC_GET_REGISTRY_MODE_LIST
        je      GN_GetRegistryModeList
        cmp     eax,NV_ESC_PRIMARY_INFO
        je      GN_GetPrimaryInfo
        cmp     eax,NV_ESC_GET_REGISTRY_DESKTOP_MODE_LIST
        je      GN_GetRegistryDesktopModeList
        cmp     eax,ESC_NV_QUERY_HEAD_REFRESH_RATE
        je      GN_QueryHeadRefreshRate
        cmp     eax,NV_ESC_ENABLE_DISABLE_SOFTWARE_CURSOR
        je      GN_SoftwareCursor
        cmp	eax,NV_ESC_SET_CPL_DWORD
        je      GN_SetCplDword
        cmp	eax,NV_ESC_GET_CPL_DWORD
        je      GN_GetCplDword
        add     sp,@WordSize

        ; See if it is a dualhead specific escape
        push    esi                     ; GNLOGDEVCX
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    ControlPanelInterface
        or      ecx,ecx
        jne     Done

        ; See if it is a hardware specific escape
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    HW_ControlAction
        or      ecx,ecx
        jne     Done

BackPunt:
        ; Punt it to DIBENG
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    DIB_Control
        jmp     Done

RetAddr:
        or      ecx,ecx
        je      BackPunt
Done:
        popf
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlQuery
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is QUERYESCSUPPORT. This routine should
;               see first if it is a generic escape it knows about and,
;               if so, it should return the appropriate return code. If
;               it is not a generic escape, this routine will call the
;               hardware specific query routine to see if it is a HW
;               specific escape.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds:esi
;==============================================================================
DECPROC GN_ControlQuery, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx
        les     bx,lpIn
        mov     ecx,1
        movzx   edx,word ptr es:[ebx]

        cmp     edx,DCICOMMAND
        jne     @F
        mov     eax,(DD_HAL_VERSION - 1)        ; WHQL certification "bit"
        jmp     Done
@@:
        cmp     edx,OPENGL_GETINFO
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        cmp     edx,OPENGL_CMD
        jne     @F
        sub     eax,eax
        jmp     Done
@@:
        cmp     edx,VIDEO_PARAMETERS
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        cmp     edx,NV_ESC_DVD_MACROVISION_CMD
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    HW_ControlQuery
        or      ecx,ecx
        jne     Done

        ; Punt it to DIBENG
        push    lpDstDev
        push    wFunction
        push    lpIn
        push    lpOut
        call    DIB_Control
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDraw
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND. This routine will
;               handle the flavors of DCICOMMAND escapes it knows about
;               and punt the rest to the DIBENG.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     0   DCICOMMAND sub-function was not recognized
;                       1   DCICOMMAND sub-function was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDraw, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx

        ; Punt if lpIn is NULL or if the version is wrong
        cmp     ebx,lpIn
        je      Punt
        les     bx,lpIn
        cmp     es:[ebx].MYDCICMD.dwVersion,DD_VERSION
        jne     Punt

        push    OFFSET Handled
        mov     eax,es:[ebx].MYDCICMD.dwCommand
        cmp     eax,DDNEWCALLBACKFNS
        je      GN_ControlDDrawNewCallbackFns
        cmp     eax,DDGET32BITDRIVERNAME
        je      GN_ControlDDrawGet32BitDriverName
        cmp     eax,DDCREATEDRIVEROBJECT
        je      GN_ControlDDrawCreateDriverObject
        cmp     eax,DDVERSIONINFO
        je      GN_ControlDDrawDDVersionInfo

        ; These are not really standard DCI escapes. The
        ; DDNVCREATEDRIVEROBJECT escape tells us that the DirectX
        ; driver just went from having no apps attached to having one
        ; app attached. The DDNVDESTROYDRIVEROBJECT tells us that
        ; Direct X just went from having 1 app attached to having no
        ; apps attached.
        cmp     eax,DDNVCREATEDRIVEROBJECT
        je      GN_ControlDDrawNVCreateDriverObject
        cmp     eax,DDNVDESTROYDRIVEROBJECT
        je      GN_ControlDDrawNVDestroyDriverObject

        ; For a little applet someone wrote.
        cmp     eax,EDDESCAPE
        je      GN_RollerToolEscape
        add     sp,@WordSize

Punt:
        sub     ecx,ecx
        jmp     Done

Handled:
        mov     ecx,1
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawNewCallbackFns
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDNEWCALLBACKFNS.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawNewCallbackFns, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Save the callbacks to internal direct functions
        sub     ebx,ebx
        les     bx,lpIn
        mov     eax,es:[ebx].MYDCICMD.dwParam1

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    eax
        call    HW_SetNewDirxCallbacks

        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawGet32BitDriverName
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDGET32BITDRIVERNAME.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawGet32BitDriverName, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Copy the Direct Draw Dll Name into the lpOut structure
        ; so the system knows which Dll to load.
        movzx   ebx,word ptr lpOut+0
        movzx   eax,word ptr lpOut+2
        lea     edx,[ebx].MYDD32BITDRIVERDATA.szName
        lea     ecx,[ebx].MYDD32BITDRIVERDATA.szEntryPoint

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    eax
        push    edx
        push    eax
        push    ecx
        call    HW_GetDirectXDllNameAndEntryPoint

        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].MYDD32BITDRIVERDATA.dwContext,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawCreateDriverObject
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDCREATEDRIVEROBJECT.
;
;               NOTE: This function may get called in a DISABLED
;               secondary display driver in which case we will
;               never actually receive a DD
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawCreateDriverObject, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Let everyone know that DirectX is at least enumerating.
        push    esi
        pushd   MSG_DIRECTX_ENUM
        push    esi
        push    eax                             ; ignored
        call    GN_LogdevMessage

        ; We are supposed to return the hInstance of our driver for this
        ; sub-escape. If we don't know it, then return 0.
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetDirectXInstance
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx],eax

        ; Success code
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawNVCreateDriverObject
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDNVCREATEDRIVEROBJECT.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawNVCreateDriverObject, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Let everyone know that DirectX is starting up.
        push    esi
        pushd   MSG_DIRECTXON
        push    esi
        push    eax                             ; ignored
        call    GN_LogdevMessage

        ; Need to remember that directX is active
        mov     ds:[esi].GNLOGDEVCX.bDirectXActive,1

Done:
        ; Return success and handled
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawNVDestroyDriverObject
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDNVDESTROYDRIVEROBJECT.
;
;		NOTE: Due to a messed up DirectX run-time, we
;		can get multiple creates and only one destroy.
;		When we get the destroy we need to shut down
;		DirectX on ALL logical devices, not just the
;		one corresponding to the driver we are called in.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      TRUE
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawNVDestroyDriverObject, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
	; Inform all GNLOGDEVCXs on this board thwt DirectX is going away
	mov	dwCRTCCount,0
LoopT:
	mov	ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
	mov	eax,dwCRTCCount
	mov	edi,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
	or	edi,edi
	je	@F

        push    edi
        pushd   MSG_DIRECTXOFF
        push    edi
        push    eax                             ; ignored
        call    GN_LogdevMessage

        ; Need to remember that directX is not active
        mov     ds:[edi].GNLOGDEVCX.bDirectXActive,0

@@:
	inc	dwCRTCCount
	mov	eax,dwCRTCCount
	mov	ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     eax,ds:[ebx].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopT

Done:
        ; Return success and handled
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlDDrawDDVersionInfo
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is DDVERSIONINFO.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:
;==============================================================================
DECPROC GN_ControlDDrawDDVersionInfo, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; This Microsoft DDK said to do this. Stuff the run-time
        ; version of DirectX which the DirectX driver was built to
        ; handle in dwHALVersion. If the lpOut ptr it NULL, then fail.
        sub     eax,eax
        cmp     eax,lpOut
        je      Done

        sub     ebx,ebx
        les     bx,lpIn
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    es:[ebx].MYDCICMD.dwParam1
        call    HW_GetDirectXRuntimeVersion

        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].MYDDVERSIONDATA.dwHALVersion,eax
        mov     eax,1
Done:
CLOSEPROC

;==============================================================================
;
; Function:     GN_RollerToolEscape
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is DCICOMMAND and the subfunction
;               is EDDESCAPE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:
;==============================================================================
DECPROC GN_RollerToolEscape, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; This Microsoft DDK said to do this. Stuff the run-time
        ; version of DirectX which the DirectX driver was built to
        ; handle in dwHALVersion. If the lpOut ptr it NULL, then fail.
        sub     eax,eax
        cmp     eax,lpIn
        je      Done

        sub     ebx,ebx
        les     bx,lpIn
        cmp     es:[ebx].EDDESC_SCROLL_DATA.dwCommand,EDDESC_SCROLL
        jne     Done
        cmp     es:[ebx].EDDESC_SCROLL_DATA.dwSize,size EDDESC_SCROLL_DATA
        jne     Done
        mov     eax,es:[ebx].EDDESC_SCROLL_DATA.cyLines

        add     ds:[esi].GNLOGDEVCX.dwCurrentLine,eax
        jns     @F
        mov     ds:[esi].GNLOGDEVCX.dwCurrentLine,0

@@:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[ecx].GNBOARDCX.dwMemorySizeForValidateMode
        sub     edx,edx
        idiv    ds:[esi].DIBENGINEHDR.deDeltaScan

        ; eax = whole height of videomemory.
        movzx   ecx,ds:[esi].DIBENGINEHDR.deHeight
        mov     edx,ds:[esi].GNLOGDEVCX.dwCurrentLine
        add     edx,ecx
        cmp     edx,eax
        jbe     @F
        sub     eax,ecx
        mov     ds:[esi].GNLOGDEVCX.dwCurrentLine,eax

@@:
        mov     ecx,ds:[esi].DIBENGINEHDR.deDeltaScan
        mov     eax,ds:[esi].GNLOGDEVCX.dwCurrentLine
        imul    eax,ecx

IF 0
        ; Tell the CRTC0 where the base of the panning should be.
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[0]
        push    eax                                     ;PanBase
        push    ecx                                     ;Pitch
        call    GN_SetPanBaseAndPitch
ENDIF
        mov     eax,1
Done:
CLOSEPROC

;==============================================================================
;
; Function:     GN_MouseTrails
;
; Purpose:      This function is called when an escape is changing the
;               mouse trails state.
;
;               I could not find a definition of the lpIn and lpOut
;               ptrs when wFunction = MOUSETRAILS, but by using the
;               debugger I inferred the following:
;               lpOut is NULL
;               lpIn points to a 16bit value which tells the number
;               of trails to display. It is 0 to turn off mouse trails.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               ecx     = 0 so that we will pass the call to the DIBENG
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_MouseTrails, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Enumerate CRTCs attached
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX

LoopCRTC:
        ; If this CRTC is not a NULL context ...
        mov     edx,ds:[edi]
        or      edx,edx
        je      NextCrtc

        ; Get the cursor cache ptr
        mov     ecx,ds:[edx].GNCRTCCX.pCursorCache
        or      ecx,ecx
        je      NextCrtc

        ; Clear cursor cache
        push    ecx
        push    edx
        call    GN_ClearCursorCache
        pop     ecx

        ; Turn on / off the TRAILS bit accordingly
        sub     ebx,ebx
        les     bx,lpIn

        or      ds:[ecx].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_MOVE
        cmp     word ptr es:[ebx],0
        jne     @F
        and     ds:[ecx].CURSORCACHE.dwCursorFlags,NOT (CURSOR_HAS_TRAILS OR CURSOR_MOVE)

        ; Initialize position for h/w cursor only.
        push    ecx
        mov     eax,dword ptr ds:[ecx].CURSORCACHE.wCursorX
        ror     eax,10H
        push    eax
        call    GENERIC_MoveCursor
        pop     ecx
@@:
        ; Now patch the cursor depended entries
        push    ds:[ecx].CURSORCACHE.dwCursorFlags
        call    GN_TurnExcludeOffOrOn

NextCrtc:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

        ; Return that we want the call passed to the DIBENG also.
        sub     ecx,ecx
CLOSEPROC


;==============================================================================
;
; Function:     GN_SoftwareCursor
;
; Purpose:      This function is called when an escape is changing to/from
;               a hardware cursor from/to a software cursor.
;
;               I could not find a definition of the lpIn and lpOut
;               ptrs when wFunction = MOUSETRAILS, but by using the
;               debugger I inferred the following:
;               lpOut is NULL
;               lpIn points to a 16bit value which tells the number
;               of trails to display. It is 0 to turn off mouse trails.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               ecx     = 0 so that we will pass the call to the DIBENG
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_SoftwareCursor, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Enumerate CRTCs attached
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX

LoopCRTC:
        ; If this CRTC is not a NULL context ...
        mov     edx,ds:[edi]
        or      edx,edx
        je      NextCrtc

        ; Get the cursor cache ptr
        mov     ecx,ds:[edx].GNCRTCCX.pCursorCache
        or      ecx,ecx
        je      NextCrtc

        ; Clear cursor cache
        push    ecx
        push    edx
        call    GN_ClearCursorCache
        pop     ecx

        ; Turn on / off the TRAILS bit accordingly
        sub     ebx,ebx
        les     bx,lpIn

        or      ds:[ecx].CURSORCACHE.dwCursorFlags,CURSOR_IS_SOFTWARE OR CURSOR_MOVE
        cmp     word ptr es:[ebx],0
        jne     @F
        and     ds:[ecx].CURSORCACHE.dwCursorFlags,NOT (CURSOR_IS_SOFTWARE OR CURSOR_MOVE)

        ; Initialize position for h/w cursor only.
        push    ecx
        mov     eax,dword ptr ds:[ecx].CURSORCACHE.wCursorX
        ror     eax,10H
        push    eax
        call    GENERIC_MoveCursor
        pop     ecx
@@:
        ; Now patch the cursor depended entries
        push    ds:[ecx].CURSORCACHE.dwCursorFlags
        call    GN_TurnExcludeOffOrOn

NextCrtc:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

        ; Return that we want the call passed to the DIBENG also.
        sub     ecx,ecx
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlReturnPDevice
;
; Purpose:      This function returns the PDevice as both
;               a 16:16 and a flat 32bit ptr.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               The linear address is provided as the first dword in the
;               lpOut structure and a 16:16 ptr is provided in the 2nd dword.
;               See escape.h for mode details.
;               Aslo return ecx = 1 to show that we handled the call.
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlReturnPDevice, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],esi
        mov     eax,cs:[CSlp16LogDevice_In_NVTEXT16]
        mov     es:[edi + 4],eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetCplDword
;
; Purpose:      This function saves the dword passed in. It can be
;		gotten again by the caller by issuing the
;		NV_ESC_GET_CPL_DWORD. Note that the display driver
;		makes no attempt to interpret this data in any way.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_SetCplDword, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut
        mov     eax,es:[edi]
        mov	ds:[esi].GNLOGDEVCX.dwCplData,eax
        mov	eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetCplDword
;
; Purpose:      This function returns the cpl dword. It was saved
;		when the caller issued the NV_ESC_SET_CPL_DWORD.
;		It was initialized to -1 at boot.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               dword pointed to by lpOut is set to the saved
;		control panel data.
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_GetCplDword, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut
        mov	eax,ds:[esi].GNLOGDEVCX.dwCplData
        mov     es:[edi],eax
        mov	eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlAllocSelectorAndMap
;
; Purpose:      This function allocs a selector and maps it to
;               a linear address given for the given length.
;
;               The lpIn argument should point to 2 DWORDS.
;               The first DWORD is the linear base address the
;               newly allcated seelctor should get.
;               The second DWORD specifies the limit of the selector.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               The return value is a 16bit WORD that is placed where
;               lpOut points to. The 16bit value is the newly allocated
;               slector. It is 0 if the routine failed.
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlAllocSelectorAndMap, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        mov     eax,1
        mov     ebx,es:[edi]
        mov     ecx,es:[edi + 4]
        call    GN_AllocSelectorAndMapIt
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],eax
CLOSEPROC

;==============================================================================
;
; Function:     GN_ControlUnmapAndFreeSelector
;
; Purpose:      This function unmaps and frees a selector.
;
;               The first 16 bit WORD pointed to by lpIn has
;               the selector to free.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlUnmapAndFreeSelector, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        movzx   eax,word ptr es:[edi]
        or      eax,eax
        je      @f
        call    GN_UnmapAndFreeSelector
        mov     eax,1
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlAllocSharedMemory
;
; Purpose:      This function allocates shared memory for the
;               caller and remembers the allocation.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlAllocSharedMemory, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX

        ; Look for a free entry in the sSharedMemBlocks[] array
        sub     ecx,ecx
@@:
        cmp     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,0
        je      FoundOne
        inc     ecx
        cmp     ecx,MAX_SHARED_MEM_BLOCKS
        jc      @B
        sub     eax,eax
        jmp     DoneIt

FoundOne:
        PUSHR   ecx
        sub     ebx,ebx
        les     bx,lpIn
        mov     eax,es:[ebx].ESC_ALLOC_SHARED_MEMORY_IN.dwNumBytes
        call    GN_MemoryAlloc
        POPR    ecx
        or      eax,eax
        je      DoneIt

        ; Save off the memory allocated in the GNBOARDCX
        sub     ebx,ebx
        les     bx,lpIn
        shl     edx,10H
        mov     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,edx
        mov     eax,es:[ebx].ESC_ALLOC_SHARED_MEMORY_IN.dwID
        mov     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwID,eax
        shr     edx,10H
        push    edx
        call    GN_GetSelectorBase

DoneIt:
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].ESC_ALLOC_SHARED_MEMORY_OUT.pMemBlock,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlFreeSharedMemory
;
; Purpose:      This function frees shared memory for the caller.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlFreeSharedMemory, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        sub     ebx,ebx
        les     bx,lpIn
        mov     eax,es:[ebx].ESC_FREE_SHARED_MEMORY_IN.dwID

        ; Look for this ID in the sSharedMemBlocks[] array
        sub     ecx,ecx
@@:
        cmp     eax,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwID
        je      FoundOne
        inc     ecx
        cmp     ecx,MAX_SHARED_MEM_BLOCKS
        jc      @B
        sub     eax,eax
        jmp     DoneIt

FoundOne:
        mov     eax,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData
        mov     ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData,0
        shr     eax,10H
        call    GN_MemoryFree
        mov     eax,1

DoneIt:
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].ESC_FREE_SHARED_MEMORY_OUT.dwSuccess,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlGetSharedMemory
;
; Purpose:      This function gets a shared memory ptr allocated
;               at some point in the past.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlGetSharedMemory, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        sub     ebx,ebx
        les     bx,lpIn
        mov     edx,es:[ebx].ESC_GET_SHARED_MEMORY_IN.dwID

        ; Look for this ID in the sSharedMemBlocks[] array
        sub     ecx,ecx
@@:
        cmp     edx,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwID
        je      FoundIt
        inc     ecx
        cmp     ecx,MAX_SHARED_MEM_BLOCKS
        jc      @B
        sub     eax,eax
        jmp     DoneIt

FoundIt:
        mov     eax,ds:[edi].GNBOARDCX.sSharedMemBlocks[ecx * 4].dwData
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase

DoneIt:
        sub     ebx,ebx
        les     bx,lpOut
        mov     es:[ebx].ESC_GET_SHARED_MEMORY_OUT.pMemBlock,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_ControlSetCursor
;
; Purpose:      This function sets a cursor.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_ControlSetCursor, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; We allow applications to directly set the cursor, allowing
        ; cursors that are different sized from what Windows will allow.
        ; Also, other formats are supported for debug builds.
        push    dword ptr lpIn
        call    GENERIC_SetCursor
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_DvdMacrovisionCommand
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_DVD_MACROVISION_CMD.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             appropriate macrovision returns
;
; Preserve:
;==============================================================================
DECPROC GN_DvdMacrovisionCommand, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; If this is not the first ID that has been set AND it does not
        ; match the current ID, then there is an error.
        mov     eax,ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID
        or      eax,eax
        je      @F
        sub     ebx,ebx
        les     bx,lpIn
        cmp     eax,es:[ebx].MACROVISION_INFO.dwMacrovisionNavigatorID
        je      @F
        les     di,lpOut
        mov     dword ptr es:[ebx].MACROVISION_INFO.dwMacrovisionData,'DABU'
        sub     eax,eax
        jmp     DoneIt
@@:
        ; The ID is OK. If the display device is a real TV or PAL
        ; system, then save it. Otherwise, we don't care.
        push    edi
        call    GN_GetDevData
        movzx   edx,al
        mov     eax,1
        cmp     edx,DEVTYPE_TV
        jne     DoneIt

        cmp     ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID,0
        jne     DoneIt
        sub     ebx,ebx
        les     bx,lpIn
        mov     edx,es:[ebx].MACROVISION_INFO.dwMacrovisionNavigatorID
        mov     ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID,edx
        sub     eax,eax
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_OpenGLGetInfo
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is OPENGL_GETINFO.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:
;               eax                     1
;               If the first dword in the lpIn ptr is GETINFO_DRVNAME
;               then the lpOut ponts to a OPENGL_GETINFO structure.
;               You should fill in the relevant feilds and return eax = 1.
;               If the first dword of lpIn is not GETINFO_DRVNAME
;               or it is, but you can't fill in the releveant fields
;               return eax = 0.
;
; Preserve:
;==============================================================================
DECPROC GN_OpenGLGetInfo, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        sub     eax,eax
        cmp     dword ptr es:[edi],OPENGL_GETINFO_DRVNAME
        jne     DoneIt

        movzx   eax,word ptr lpOut+0
        movzx   ecx,word ptr lpOut+2
        lea     eax,[eax].OPENGL_INFO.awch
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    ecx
        push    eax
        call    HW_GetOpenGLRegistryName

        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].OPENGL_INFO.ulVersion,eax
        mov     es:[edi].OPENGL_INFO.ulDriverVersion,ebx
        mov     eax,1
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     GN_OpenGLCommand
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is OPENGL_CMD.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax                     0
;
; Preserve:
;==============================================================================
DECPROC GN_OpenGLCommand, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     eax,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_VideoParameters
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is VIDEO_PARAMETERS.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax                     0
;
; Preserve:
;==============================================================================
DECPROC GN_VideoParameters, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpIn
        push    OFFSET VpRet
        cmp     es:[edi].VIDEOPARAMETERS.dwCommand,VP_COMMAND_GET
        je      GN_VpCommandGet
        cmp     es:[edi].VIDEOPARAMETERS.dwCommand,VP_COMMAND_SET
        je      GN_VpCommandSet
        add     sp,@WordSize
        sub     eax,eax
VpRet:
CLOSEPROC


;==============================================================================
;
; Function:     GN_VpCommandGet
;
; Purpose:      This function is called when the escape is
;               VIDEO_PARAMETERS and the specific flavor is
;               VP_COMMAND_GET.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX
;               es:edi          VIDEOPARAMETERS ptr
;
; Returns:      eax     value to return to GDI
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_VpCommandGet, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx
FindTV:
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      eax,eax
        jz      NextCrtc
        push    ebx
        push    eax
        call    GN_GetDevData
        pop     ebx
        mov     es,word ptr lpIn+2
        cmp     al,DEVTYPE_TV
        je      IsTv
NextCrtc:
        inc     ebx
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      FindTV
        sub     ebx,ebx
        mov     es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_TV_MODE OR VP_FLAGS_TV_STANDARD
        mov     es:[edi].VIDEOPARAMETERS.dwTVStandard,VP_TV_STANDARD_WIN_VGA
        mov     es:[edi].VIDEOPARAMETERS.dwAvailableTVStandard,VP_TV_STANDARD_WIN_VGA
        mov     dwCopyStandard,0
        jmp     GotT
IsTv:
        shr     eax,10H
        mov     ecx,VP_TV_STANDARD_NTSC_M
        cmp     al,TVTYPE_NTSCM
        je      FoundTV
        cmp     al,TVTYPE_NTSCJ
        je      FoundTV
        mov     ecx,VP_TV_STANDARD_PAL_B
FoundTV:
        mov     es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_TV_MODE OR VP_FLAGS_TV_STANDARD
        mov     es:[edi].VIDEOPARAMETERS.dwTVStandard,ecx
        mov     es:[edi].VIDEOPARAMETERS.dwAvailableTVStandard,ecx
        mov     dwCopyStandard,ecx
GotT:
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCXWhenLocked
@@:     mov     pHWCrtcCXOffset,eax

        mov     es:[edi].VIDEOPARAMETERS.dwAvailableModes,VP_MODE_WIN_GRAPHICS

        ; Set the maximum unscaled width and height
        or      es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_MAX_UNSCALED
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        movzx   ecx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     es:[edi].VIDEOPARAMETERS.dwMaxUnscaledX,eax
        mov     es:[edi].VIDEOPARAMETERS.dwMaxUnscaledY,ecx
        or      es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_POSITION
        mov     es:[edi].VIDEOPARAMETERS.dwPositionX,0
        mov     es:[edi].VIDEOPARAMETERS.dwPositionY,0
        mov     es:[edi].VIDEOPARAMETERS.dwCPType,0
        mov     es:[edi].VIDEOPARAMETERS.dwCPStandard,0

        push    pHWCrtcCXOffset
        call    HW_IsMacroVisionEncoderAttached
        or      eax,eax
        je      No_MV

        ; Yes, we have macrovision
        or      es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_COPYPROTECT
        mov     es:[edi].VIDEOPARAMETERS.dwCPType,VP_CP_TYPE_APS_TRIGGER
        mov     eax,ds:[esi].GNLOGDEVCX.dwMacrovisionMode
        mov     es:[edi].VIDEOPARAMETERS.bCP_APSTriggerBits,eax
        mov     eax,dwCopyStandard
        mov     es:[edi].VIDEOPARAMETERS.dwCPStandard,eax
No_MV:
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_VpCommandSet
;
; Purpose:      This function is called when the escape is
;               VIDEO_PARAMETERS and the specific flavor is
;               VP_COMMAND_SET.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX
;               es:edi          VIDEOPARAMETERS ptr
;
; Returns:      eax     value to return to GDI
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_VpCommandSet, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC

        ; The only "set" command we support is CopyProtect
        test    es:[edi].VIDEOPARAMETERS.dwFlags,VP_FLAGS_COPYPROTECT
        jz      Fail

        sub     ebx,ebx

        ; We'll be using these local variables.
        ; dwCRTCCount = last non-TV device index.
        ; dwCopyStandard = 1 if we are forcing Macrovision for a non-TV device.
        mov     dwCRTCCount,ebx
        mov     dwCopyStandard,ebx

FindTV1:
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      eax,eax
        jz      NextCrtc1
        mov     dwCRTCCount,ebx
        push    ebx
        push    eax
        call    GN_GetDevData
        pop     ebx
        cmp     al,DEVTYPE_TV
        je      FoundTv
NextCrtc1:
        inc     ebx
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      FindTV1

        ; If no TV device was found, use the last non-TV device to
        ; make sure the new Macrovision level gets down to the RM.
        mov     ebx,dwCRTCCount
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      eax,eax
        jz      SkipToFail
        push    ebx
        push    eax
        call    GN_GetDevData
        pop     ebx
                mov     dwCopyStandard,1
        jmp     FoundTv

SkipToFail:
        jmp     Fail

FoundTv:
        mov     es,word ptr lpIn+2
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        mov     pGNCrtcCXOffset,ebx
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[ebx].GNCRTCCX.pHWCrtcCXWhenLocked
@@:     mov     pHWCrtcCXOffset,eax

        ; Ask hardware if we have macrovision capability
        push    pHWCrtcCXOffset
        call    HW_IsMacroVisionEncoderAttached
        mov     ebx,pGNCrtcCXOffset
        or      eax,eax
        je      Fail

        ; The only copy protection mechanism we support is APS trigger
        cmp     es:[edi].VIDEOPARAMETERS.dwCPType,VP_CP_TYPE_APS_TRIGGER
        jne     Fail

        ; Are we being asked to activate copy protection?
        cmp     es:[edi].VIDEOPARAMETERS.dwCPCommand,VP_CP_CMD_ACTIVATE
        jne     Next1

        ; Try to set the Copy protection
        mov     eax,es:[edi].VIDEOPARAMETERS.bCP_APSTriggerBits
        and     eax,3
        mov     ecx,eax
        xchg    ds:[esi].GNLOGDEVCX.dwMacrovisionMode,eax
        or      eax,eax
        jnz     @F
        or      ecx,4
@@:

        push    ecx

        ; If we are forcing Macrovision through a non-TV device to
        ; get the Macrovision level to the RM, use default width/height.
        cmp     dwCopyStandard, 1
        jnz     SkipNormal
        mov     eax,800
        push    eax
        mov     eax,600
        push    eax
        jmp     SkipCommon

        ; Else use normal calculated width and height.
SkipNormal:
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    eax
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        push    eax

SkipCommon:
        push    pHWCrtcCXOffset
        call    HW_SetMacrovisionMode
        or      eax,eax
        je      Fail

        ; Save current key and bump to next key
        mov     eax,ds:[esi].GNLOGDEVCX.dwNextMacrovisionKey
        mov     ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey,eax
        mov     es:[edi].VIDEOPARAMETERS.dwCPKey,eax
        inc     ds:[esi].GNLOGDEVCX.dwNextMacrovisionKey
        mov     eax,1
        jmp     Done
Next1:
        cmp     es:[edi].VIDEOPARAMETERS.dwCPCommand,VP_CP_CMD_DEACTIVATE
        jne     Next2

        ; We can deactivate if the requester has the right key
        mov     eax,DISP_CHANGE_BADPARAM
        mov     edx,ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey
        cmp     edx,es:[edi].VIDEOPARAMETERS.dwCPKey
        jne     Done
        sub     eax,eax
        mov     ecx,eax
        xchg    ds:[esi].GNLOGDEVCX.dwMacrovisionMode,eax
        or      eax,eax
        jz      @F
        mov     ecx,4
@@:
        push    ecx
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    eax
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        push    eax
        push    pHWCrtcCXOffset
        call    HW_SetMacrovisionMode
        jmp     Done
Next2:
        cmp     es:[edi].VIDEOPARAMETERS.dwCPCommand,VP_CP_CMD_CHANGE
        jne     Next3

        ; We can change the CP if the requester has the right key
        mov     eax,DISP_CHANGE_BADPARAM
        mov     edx,ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey
        cmp     edx,es:[edi].VIDEOPARAMETERS.dwCPKey
        jne     Done
        mov     eax,es:[edi].VIDEOPARAMETERS.bCP_APSTriggerBits
        and     eax,3
        mov     ecx,eax
        xchg    ds:[esi].GNLOGDEVCX.dwMacrovisionMode,eax
        or      eax,eax
        jz      WasNotProt
        or      ecx,ecx
        jnz     ChangeProt
ChangeBrightness:
        or      ecx,4
        jmp     ChangeProt
WasNotProt:
        or      ecx,ecx
        jnz     ChangeBrightness
ChangeProt:
        push    ecx
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    eax
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        push    eax
        push    pHWCrtcCXOffset
        call    HW_SetMacrovisionMode
        jmp     Done
Next3:
Fail:
        sub     eax,eax
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetLocalRegistryPath
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_LOCAL_REGISTRY_PATH.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetLocalRegistryPath, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the logical context
        mov     esi,ds:[esi].GNLOGDEVCX.pGNBoardCX

        sub     edi,edi
        les     di,lpOut
        mov     ecx,4
        mov     eax,dword ptr ds:[esi].GNBOARDCX.szLocalDisplayBasePath
        mov     es:[edi],eax
@@:
        mov     al,ds:[esi].GNBOARDCX.szLocalDisplayBasePath[ecx]
        mov     es:es:[edi][ecx],al
        inc     ecx
        or      al,al
        jne     @B

        ; Tack on NVidia to the end of it
        mov     dword ptr es:[edi][ecx - 1],'ivN\'
        mov     dword ptr es:[edi][ecx + 3],'aid'
        mov     eax,1
CLOSEPROC



;==============================================================================
;
; Function:     GN_GetRegistryModeList
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_REGISTRY_MODE_LIST.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetRegistryModeList, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Find an available GNCRTCCX ptr, just so we can use
        ; the DISPDATA structure from it
        mov     edx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        sub     eax,4
        sub     ecx,ecx

@@:     add     eax,4
        cmp     ecx,ds:[eax]
        jne     @F
        dec     edx
        jne     @B
        sub	eax,eax
        jmp	LastPart
@@:
        ; If lpIn is NULL, we want to return the number of modes,
        ; which means that we should pass in a NULL ptr for the modelist.
        mov     edx,MODETYPE_MODEENTRY
        sub     ebx,ebx
        cmp     lpIn,0
        je      @F

        ; Check lpIn
        mov     edx,MODETYPE_MODEENTRYNORR
        mov     ebx,lpOut
        les     di,lpIn
        cmp     dword ptr es:[di],MODETYPE_MODEENTRYANDPITCH
        ja      @F
        mov     edx,es:[di]
@@:
        mov     eax,ds:[eax]
        push    ds:[eax].GNCRTCCX.lpNvmodeDispData
        push    ebx
        push    edx
        CALLFAR16IND lpfnGetModeList,es,ax

LastPart:
        ; If lpIn was NULL, then we want to return the number of modes
        cmp     lpIn,0
        jne     @F
        les     di,lpOut
        movzx   eax,ax
        mov     es:[di],eax
@@:
        mov     eax,1
CLOSEPROC

;==============================================================================
;
; Function:     GN_GetPrimaryInfo
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_PRIMARY_INFO.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetPrimaryInfo, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        les     di,lpIn
        mov     eax,es:[di].NV_PRIMARY_INFO.ulHeadNum
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jae     FailIt

        ; Find the GNLOGDEVCX that is using this head number
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    eax
        call    GN_MapHeadToGNLogdev
        or      eax,eax
        je      FailIt
        mov     esi,ebx

Success:
        les     di,lpOut
        mov     es:[di].NV_PRIMARY_INFO.ulReturnCode,1
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     es:[di].NV_PRIMARY_INFO.ulWidth2,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     es:[di].NV_PRIMARY_INFO.ulHeight,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     es:[di].NV_PRIMARY_INFO.ulDepth,eax
        mov     eax,ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        mov     es:[di].NV_PRIMARY_INFO.ulPitch,eax
        mov     eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        mov     es:[di].NV_PRIMARY_INFO.ulPrimarydwOffset,eax
        mov     eax,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        mov     es:[di].NV_PRIMARY_INFO.ulNumActiveDACs,eax
        sub     eax,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPanningPtr,eax
        mov     es:[di].NV_PRIMARY_INFO.ulFullscreenPtr,eax
        jmp     DoneIt

FailIt:
        ; Clear out everything to zero
        les     di,lpOut
        sub     eax,eax
        mov     es:[di].NV_PRIMARY_INFO.ulReturnCode,eax
        mov     es:[di].NV_PRIMARY_INFO.ulWidth2,eax
        mov     es:[di].NV_PRIMARY_INFO.ulHeight,eax
        mov     es:[di].NV_PRIMARY_INFO.ulDepth,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPitch,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPrimarydwOffset,eax
        mov     es:[di].NV_PRIMARY_INFO.ulPanningPtr,eax
        mov     es:[di].NV_PRIMARY_INFO.ulFullscreenPtr,eax

DoneIt:
        mov     eax,1
CLOSEPROC

;==============================================================================
;
; Function:     GN_GetRegistryDesktopModeList
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_REGISTRY_DESKTOP_MODE_LIST.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_GetRegistryDesktopModeList, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Find an available GNCRTCCX ptr, just so we can use
        ; the DISPDATA structure from it
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     edx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        sub     eax,4
        sub     ecx,ecx

@@:     add     eax,4
        cmp     ecx,ds:[eax]
        jne     @F
        dec     edx
        jne     @B
        sub	eax,eax
        jmp	LastPart
@@:
        ; If lpIn is NULL, we want to return the number of modes,
        ; which means that we should pass in a NULL ptr for the modelist.
        mov     edx,MODETYPE_MODEENTRY
        sub     ebx,ebx
        cmp     lpIn,0
        je      @F

        ; Check lpIn
        mov     edx,MODETYPE_MODEENTRYNORR
        mov     ebx,lpOut
        les     di,lpIn
        cmp     dword ptr es:[di],MODETYPE_MODEENTRYANDPITCH
        ja      @F
        mov     edx,es:[di]
@@:
        mov     eax,ds:[eax]
        push    ds:[eax].GNCRTCCX.lpNvmodeDispData
        push    ebx
        push    edx
        CALLFAR16IND lpfnGetDesktopModeList,es,ax

LastPart:
        ; If lpIn was NULL, then we want to return the number of modes
        cmp     lpIn,0
        jne     @F
        les     di,lpOut
        movzx   eax,ax
        mov     es:[di],eax
@@:
        mov     eax,1
CLOSEPROC

;==============================================================================
;
; Function:     GN_QueryHeadRefreshRate
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is ESC_NV_QUERY_HEAD_REFRESH_RATE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      eax             1
;
; Preserve:
;==============================================================================
DECPROC GN_QueryHeadRefreshRate, PASCAL, ShareFrameFar16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        les     di,lpIn
        mov     eax,es:[di]                     ;Head number
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jae     FailIt

        ; Find the GNLOGDEVCX that is using this head number
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    eax
        call    GN_MapHeadToGNLogdev
        or      eax,eax
        je      FailIt
        mov     esi,eax

        lea     esi,ds:[esi].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[esi].MODEINFO.dwRefreshRate
        les     di,lpOut
        mov     es:[di],eax
        jmp     DoneIt

FailIt:
        les     di,lpOut
        sub     eax,eax
        mov     es:[di],eax

DoneIt:
        mov     eax,1
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCLRINF.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnclrinf.asm
;
; Purpose:      This file holds the ColorInfo display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

COMPARE_VS_DIBENG       MACRO
        LOCAL   skip1, skip2
IFDEF DEBUG
        movzx   ecx,sp
        push    eax
        push    edx
        push    lpDstDev
        push    dwColorIn
        push    lpPhysColor
        call    DIB_ColorInfo
        mov     ebx,eax
        mov     ecx,edx
        pop     edx
        pop     eax
        cmp     ax,bx
        je      skip1
        int     3
skip1:
        cmp     cx,dx
        je      skip2
        int     3
skip2:
ENDIF
ENDM


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  Table5To8
Table5To8       LABEL   BYTE
DB      000H, 010H, 018H, 020H, 028H, 030H, 038H, 040H
DB      048H, 050H, 058H, 060H, 068H, 070H, 078H, 080H
DB      088H, 090H, 098H, 0A0H, 0A8H, 0B0H, 0B8H, 0C0H
DB      0C8H, 0D0H, 0D8H, 0E0H, 0E8H, 0F0H, 0F8H, 0FFH

PUBLIC  Table6To8
Table6To8       LABEL   BYTE
DB      000H, 008H, 00CH, 010H, 014H, 018H, 01CH, 020H
DB      024H, 028H, 02CH, 030H, 034H, 038H, 03CH, 040H
DB      044H, 048H, 04CH, 050H, 054H, 058H, 05CH, 060H
DB      064H, 068H, 06CH, 070H, 074H, 078H, 07CH, 080H
DB      084H, 088H, 08CH, 090H, 094H, 098H, 09CH, 0A0H
DB      0A4H, 0A8H, 0ACH, 0B0H, 0B4H, 0B8H, 0BCH, 0C0H
DB      0C4H, 0C8H, 0CCH, 0D0H, 0D4H, 0D8H, 0DCH, 0E0H
DB      0E4H, 0E8H, 0ECH, 0F0H, 0F4H, 0F8H, 0FCH, 0FFH

;==============================================================================
;
; Function:     GENERIC_ColorInfo
;
; Purpose:      This function is the ColorInfo display driver entry point.
;
;==============================================================================
lpDstDev        TEXTEQU <dword ptr ss:[ecx + 0CH]>
dwColorIn       TEXTEQU <dword ptr ss:[ecx + 08H]>
lpPhysColor     TEXTEQU <dword ptr ss:[ecx + 04H]>

DECPROC GENERIC_ColorInfo, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   dwColorIn
;PARMD   lpPhysColor
OPENPROC
        movzx   ecx,sp
        sub     ebx,ebx
        lfs     bx,lpDstDev

        ; Only handle 16bpp and 32bpp color info calls
        mov     al,fs:[ebx].DIBENGINE.deBitsPixel
        movzx   edx,fs:[ebx].DIBENGINE.deFlags
        cmp     al,32
        je      Bpp32
        cmp     al,16
        jne     Punt

Bpp16:
        ; Only deal with 5-6-5
        test    edx,FIVE6FIVE
        jz      Punt

        ; Break into LogToPhys and PhysToLog cases
        mov     eax,dwColorIn
        cmp     word ptr lpPhysColor+2,0
        je      Phys16ToLog

LogToPhys16:
        test    eax,0FF000000H
        jnz     LogPaletteIndexToPhys

LogRGBToPhys16:
        lfs     bx,lpPhysColor

        ; Special case check for black
        and     eax,0FFFFFFH
        jne     @F
        or      eax,40000000H
        mov     fs:[ebx],eax
        mov     byte ptr fs:[ebx + 3],40H
        sub     edx,edx
        COMPARE_VS_DIBENG
        RETFAR16  0CH
@@:
        ; Special case check for white
        cmp     eax,0FFFFFFH
        jne     @F
        or      eax,40000000H
        mov     fs:[ebx],eax
        mov     byte ptr fs:[ebx + 3],40H
        mov     edx,0FFH
        COMPARE_VS_DIBENG
        RETFAR16  0CH
@@:
        ; Not special -- convert 32 to 16 the hard way
        movzx   edx,al
        shr     eax,8
        xchg    ah,dl
        sub     al,02H
        jnc     @F
        sub     al,al
@@:     sub     ah,4
        jnc     @F
        sub     ah,ah
@@:     sub     dl,4
        jnc     @F
        sub     dl,dl
@@:     shr     ah,3
        shl     edx,18H
        shr     ax,2
        shld    eax,edx,5
        movzx   eax,ax
        mov     fs:[ebx],eax

Phys16ToLog:
        ; Convert 16 to 32 via tables
        mov     ebx,eax
        and     eax,1FH
        shr     ebx,5
        mov     dl,cs:Table5To8[eax]
        mov     ecx,ebx
        and     ebx,3FH
        shr     ecx,6
        and     ecx,1FH
        mov     ah,cs:Table6To8[ebx]
        mov     al,cs:Table5To8[ecx]
        sub     dh,dh
        COMPARE_VS_DIBENG
        RETFAR16  0CH

Bpp32:
        movzx   eax,word ptr dwColorIn
        movzx   edx,word ptr dwColorIn+2
        cmp     word ptr lpPhysColor+2,0
        je      Phys32ToLog

LogToPhys32:
        ; Watch for palette indices
        or	dh,dh
        jne     LogPaletteIndexToPhys

        ; Easy -- just switch red and blue
        lfs     bx,lpPhysColor
        mov     byte ptr fs:[ebx+0],dl
        mov     byte ptr fs:[ebx+1],ah
        mov     byte ptr fs:[ebx+2],al
        mov     byte ptr fs:[ebx+3],00
        sub     dh,dh
        COMPARE_VS_DIBENG
        RETFAR16  0CH

Phys32ToLog:
        ; Easy -- just switch red and blue
        xchg    al,dl
        sub     dh,dh
        COMPARE_VS_DIBENG
        RETFAR16  0CH

LogPaletteIndexToPhys:
        or      eax,0FFFF0000H
        lfs     bx,lpPhysColor
        mov     fs:[ebx],eax
        shld    edx,eax,10H
        COMPARE_VS_DIBENG
        RETFAR16  0CH

Punt:
        jmp     DIB_ColorInfo
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCLRBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnclrblt.asm
;
; Purpose:      This file holds the routines to do Bitblt's involving
;               a color source located in system memory. There may
;               also be a pattern involved but maybe not. The code is
;               generic in terms of not touching hardware, but it does
;               make assumptions about hardware capability and to some
;               extent programming order. These should all be fine for
;               Nvidia products.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  dwTableBppToXlatFunc
dwTableBppToXlatFunc    LABEL   DWORD
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0                               ; GN_Xfer1To8 - use mono transfer
DD      OFFSET  GN_Xfer4To8WordXlat
DD      OFFSET  GN_Xfer8To8NoXlat
DD      OFFSET  GN_Xfer15To8
DD      OFFSET  GN_Xfer16To8
DD      OFFSET  GN_Xfer24To8
DD      OFFSET  GN_Xfer32To8
DD      0;                              ; GN_Xfer1To15 - use mono transfer
DD      OFFSET  GN_Xfer4To15DwordXlat
DD      OFFSET  GN_Xfer8To15DwordXlat
DD      OFFSET  GN_Xfer15To15
DD      OFFSET  GN_Xfer16To15
DD      OFFSET  GN_Xfer24To15
DD      OFFSET  GN_Xfer32To15
DD      0                               ; GN_Xfer1To16 - use mono transfer
DD      OFFSET  GN_Xfer4To16DwordXlat
DD      OFFSET  GN_Xfer8To16DwordXlat
DD      OFFSET  GN_Xfer15To16
DD      OFFSET  GN_Xfer16To16
DD      OFFSET  GN_Xfer24To16
DD      OFFSET  GN_Xfer32To16
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0
DD      0                               ; GN_Xfer1To32 - use mono transfer
DD      OFFSET  GN_Xfer4To32
DD      OFFSET  GN_Xfer8To32
DD      OFFSET  GN_Xfer15To32
DD      OFFSET  GN_Xfer16To32
DD      OFFSET  GN_Xfer24To32
DD      OFFSET  GN_Xfer32To32

PUBLIC  bTableBppToIndex
bTableBppToIndex        LABEL   BYTE
DB      08H,    00H,    08H,    08H,    01H,    08H,    08H,    08H
DB      02H,    08H,    08H,    08H,    08H,    08H,    08H,    03H
DB      04H,    08H,    08H,    08H,    08H,    08H,    08H,    08H
DB      05H,    08H,    08H,    08H,    08H,    08H,    08H,    08H
DB      06H

;==============================================================================
;
; Function:     GN_BitBltSrcColorDstVram
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a color system memory bitmap and the
;               dst is in VRAM. There may be a pattern involved as well
;               but there may not be. The color depth of the src and
;               dst do not have to agree. Hence there is some sort of
;               pixel depth translation going on. The general strategy
;               implemented in this routine is:
;
;               1) Compute all the neccessary data
;
;               2) Call the HW_BeginSrcColorDstVram routine to set up
;                  the chip to expect to receive dwExtX * dwExtY pixels
;                  in the Destination Pixel Depth and place them
;                  in the rectangle whose upper left corner is at
;                  dwDstLeft,dwDstTop. HW_BeginSrcColorDstVram will
;                  also set the rop, base address, set up the pattern, etc.
;
;               3) GN_BitBltSrcColorDstVram calls the routine
;                  HW_BlockSrcColorDstVram to wait for enough space
;                  in the hardware buffer.
;
;               4) GN_BitBltSrcColorDstVram calls an inner loop routine
;                  which reads src pixels, translates them to dst space
;                  and stores them in the hardware. The inner loop routine
;                  can do partial scanlines or an integral number of scans.
;
;               5) Steps 3 and 4 are repeated until the entire bitmap has
;                  been transferred.
;
;               6) HW_EndSrcColorDstVram is called to allow the hardware
;                  specific code to clean up anything it needs to.
;
; Arguments:
;               ds              Context Selector
;               pNotUsed        Don't use this
;               dwDstBitsSel    Selector for the dst bits
;               dwDstBitsOffset Offset to the dst bits
;               dwDstBpp        bits per pixel of the dst bitmap
;               dwDstPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwDstLeft       left edge of the dst rectangle
;               dwDstTop        top  edge of the dst rectangle
;               dwSrcBitsSel    selector to the src bits
;               dwSrcBitsOffset offset to the start of the source bits
;               dwSrcBpp        Bits Per Pixel in the src image
;                               This can be 4, 8, 15, 16, 24, or 32
;               dwSrcPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwSrcLeft       left edge of the src rectangle
;               dwSrcTop        top  edge of the src rectangle
;               dwExtX          extent of the src (and dst) rectangle.
;               dwExtY          extent of the src (and dst) rectangle.
;               dwRop3          3-operand rop
;               lpBrush         ptr to a DIB_Brush struct
;               lpDrawMode      This is only needed for the case where
;                               the rop involves a brhs and the brush
;                               is a mono pattern. In this case,
;                               DRAWMODE.TextColor specifies the color
;                               to which to translate pattern 0 bits, and
;                               DRAWMODE.bkColor specifies the color to
;                               which to translate pattern 1 bits. Note
;                               that these are not the same colors used
;                               translate 0 and 1 bits from the src
;                               bitmap.
;               dwSizeColorTableEntry  bytes per entry in the color table
;               dwColorTableEntries  number of entries in the color table
;               lpColorTable    ptr to a color table. This ptr will be
;                               NULL if no color table is necessary.
;               pfnCopyXlatArg  If this argument is not NULL then it is
;                               the correct inner loop to use. If it is
;                               NULL, then the correct inner loop needs
;                               to be computed from the pixel depths of
;                               the src and dst, and the color table.
;
;       There will be a color table if:
;
;       1) The src is 4bpp. If the dst is 8bpp, then each entry will be
;          2 bytes. Only the low byte is used and is the remapped dst
;          color. If the dst is any other color depth besides 8bpp, then
;          each entry is 4 bytes -- a 32bpp logical color. These entries
;          will need to be mapped to the correct dst color depth.
;
;       2) the src is 8bpp and the dst is not 8bpp. Each entry is is
;          4 bytes -- a 32bpp logical color. These entries will need
;          to be mapped to the correct dst color depth.
;
;       There may be a color table if the src is 8bpp and the dst is
;       8bpp, but there also may not. If there is a color table then
;       each entry is 2 bytes in length. Only the low byte is used and
;       is the remapped dst color.
;
;       In all other cases, there is no color table. In some cases you
;       don't need one. i.e. if you are going from 15bpp->15bpp no
;       remapping is necessary -- just copy the source to the dst. On
;       the other hand if you are going from 24bpp->15bpp, there is no
;       color table either, but you need to convert each 24bit pixel to
;       a 15bit pixel. You MUST do these conversions in a manner identical
;       to the way the DIBENG does the conversions. If you aren't familiar
;       with the various algorithms the DIBENG uses for converting colors,
;       ask someone who is. They are not necessarily what you think. i.e.
;       15->24 does not just expand each 5bit color to an 8bit color by
;       tacking three 0 bits on the low end. There is a pseudo rounding
;       algorithm that is used.
;
; Returns:      eax     0       The routine will be punted to software
;                       else    the return code to GDI
;
;       Do not trash ds,esi,edi
;
;==============================================================================
DECPROC GN_BitBltSrcColorDstVram, PASCAL, NOFRAME, NEAR
;PARMD   pNotUsed
;PARMD   dwDstBitsSel
;PARMD   dwDstBitsOffset
;PARMD   dwDstBpp
;PARMD   dwDstPitch
;PARMD   dwDstLeft
;PARMD   dwDstTop
;PARMD   dwSrcBitsSel
;PARMD   dwSrcBitsOffset
;PARMD   dwSrcBpp
;PARMD   dwSrcPitch
;PARMD   dwSrcLeft
;PARMD   dwSrcTop
;PARMD   dwExtX
;PARMD   dwExtY
;PARMD   dwRop3
;PARMD   lpBrush
;PARMD   lpDrawMode
;PARMD   dwSizeColorTableEntry
;PARMD   dwColorTableEntries
;PARMD   lpColorTable
;PARMD   pfnCopyXlatArg
OPENPROC
        sub     ebx,ebx
        pop     eax
        push    ebx
        push    ebx
        push    ebx
        push    eax
        jmp	GN_StretchBltSrcColorDstVram
CLOSEPROC

;=============================================================
DECPROC GN_StretchBltSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pNotUsed
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwSizeColorTableEntry
PARMD   dwColorTableEntries
PARMD   lpColorTable
PARMD   pfnCopyXlatArg
PARMD   dwExtDstX
PARMD   dwExtDstY
PARMD   lpClipRect

; These are needed by the generic code
LOCALD  pfnCopyXlat
LOCALD  dwDstBytesPerPixel
LOCALD  dwDstWrapWidth
LOCALD  dwAlignedExtXInPixels
LOCALD  dwAlignedDstExtXInBytes
LOCALD  dwSrcStart
LOCALD  dwSrcWrapWidth
LOCALD  dwMaxTransferSizeInBytes
LOCALD  dwScansPerBlock
LOCALD  dwBytesPerBlock
LOCALD  dwPixelsPerBlock
LOCALD  lpFinalColorTable
LOCALD  pHWBoardCXOffset
LOCALD  dwCXSel
LOCALD  dwScale
LOCALD	pfnHWBlockProc
LOCALS  FinalColorTable,400H
OPENPROC
        PUSHR   ds,esi,edi

        mov     dwCXSel,ds
	mov	eax,dwExtDstX
	or	eax,dwExtDstY
	mov	dwScale,eax

	mov	eax,HW_BlockSrcColorDstVram
	jz	@F
	mov	eax,HW_BlockStretchSrcColorDstVram
@@:
	mov	pfnHWBlockProc,eax
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Determine the inner loop copy/xlat routine

        ; If the caller supplied the correct copy routine, we are done
        mov     eax,pfnCopyXlatArg
        mov     pfnCopyXlat,eax
        or      eax,eax
        jne     DoneCT

        ; Figure out the correct copy/xlat routine from the pixel depth
        ; of the src and the dst.
        mov     ebx,dwDstBpp
        mov     edx,dwSrcBpp
        movzx   ebx,cs:bTableBppToIndex[ebx]
        movzx   edx,cs:bTableBppToIndex[edx]
        cmp     ebx,MAX_BPP_INDICES
        jge     DoneIt
        cmp     edx,MAX_BPP_INDICES
        jge     DoneIt
	imul	ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
        mov     pfnCopyXlat,ecx

        ; The copy/xlat routine selected may not be quite correct. There
        ; are some special cases if a color table is involved.
        mov     eax,lpColorTable
        mov     lpFinalColorTable,eax
        or      eax,eax
        je      DoneCT

        ; If the copy/xlat routine is for 8->8, we need to know the size
        ; of a color table entry in order to get the correct routine.
        cmp     ecx,OFFSET GN_Xfer8To8NoXlat
        jne     @F
        mov     pfnCopyXlat,OFFSET GN_Xfer8To8ByteXlat
        cmp     dwSizeColorTableEntry,1
        je      DoneCT
        mov     pfnCopyXlat,OFFSET GN_Xfer8To8WordXlat
        jmp     DoneCT
@@:
        ; If the xlat is 4->15,16 or 8->15,16 and each color table entry
        ; is 32bits, then we may want to pre-convert the color table
        ; entries so we won't have to do a lookup from 4->32 (or 8->32)
        ; and then convert the 32 bit pixel down to 15 or 16. For a
        ; 4bpp source, we'll just say it is always worth pre-converting
        ; the table since there are at most 16 entries in the color table.
        ; For an 8bpp source, there may be 256 table entries and if we
        ; are only going to be processing a handful of pixels, converting
        ; the whole color table may be a waste. Check appropriately.
        cmp     dwSrcBpp,4
        je      S4
        cmp     dwSrcBpp,8
        jne     DoneCT
        mov     eax,dwExtX
        imul    eax,dwExtY
        cmp     eax,100H
        jc      DoneCT
        mov     ecx,403H
        mov     edx,OFFSET GN_Xfer8To15WordXlat
        cmp     dwDstBpp,15
        je      @F
        cmp     dwDstBpp,16
        jne     DoneCT
        mov     ecx,202H
        mov     edx,OFFSET GN_Xfer8To16WordXlat
        jmp     @F
S4:
        mov     ecx,403H
        mov     edx,OFFSET GN_Xfer4To15WordXlat
        cmp     dwDstBpp,15
        je      @F
        cmp     dwDstBpp,16
        jne     DoneCT
        mov     ecx,202H
        mov     edx,OFFSET GN_Xfer4To16WordXlat
@@:
        mov     pfnCopyXlat,edx
        sub     esi,esi
        lds     si,lpColorTable
        push    ss
        pop     es
        sub     edi,edi
        lea     di,FinalColorTable
        mov     edx,dwColorTableEntries
        mov     word ptr lpFinalColorTable+0,di
        mov     word ptr lpFinalColorTable+2,es
        call    GN_ConvertColorTableFrom32To16
DoneCT:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Compute the byte width of a dword aligned dst scan and also
        ; the number of dst pixels that woud fit in this aligned scan.
        mov     eax,dwExtX
        mov     edx,eax
        mov     ebx,dwDstBpp
        inc     ebx
        shr     ebx,3
        imul    eax,ebx
        mov     ecx,eax
        add     eax,3
        and     eax,NOT 3
        mov     dwAlignedDstExtXInBytes,eax
        sub     eax,ecx
        je      Skip
@@:     inc     edx
        sub     eax,ebx
        jne     @B
Skip:   mov     dwAlignedExtXInPixels,edx

        ; Compute src address and wrap width -- dlightly different for
        ; 4bpp vs. 8bpp and higher.
        mov     eax,dwSrcPitch
        mov     edx,dwSrcTop
        imul    edx,eax
        add     edx,dwSrcBitsOffset
        mov     ecx,dwSrcBpp
        mov     ebx,dwExtX
        cmp     ecx,4
        je      Is4
Is8orM:
        inc     ecx
        shr     ecx,3
        imul    ebx,ecx
        sub     eax,ebx
        imul    ecx,dwSrcLeft
        add     edx,ecx
        jmp     @F
Is4:
        add     eax,eax
        add     edx,edx
        sub     eax,ebx
        add     edx,dwSrcLeft
        jmp     @F
@@:
        mov     dwSrcWrapWidth,eax
        mov     dwSrcStart,edx
DoneW:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Call the hardware specific routine to setup for the transfer
        mov     ds,dwCXSel
        mov     ebx,cs:[CSpGNLogicalDevice]
        mov     ecx,ds:[ebx].GNLOGDEVCX.pGNBoardCX


        mov     eax,ds:[ecx].GNBOARDCX.pHWBoardCX
        mov     pHWBoardCXOffset,eax

        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    dwDstBitsOffset
        push    dwDstPitch
        push    dwDstBpp
        push    dwDstLeft
        push    dwDstTop
	cmp	dwScale,0
	jne	StretchCase

        push    dwExtX
        push    dwExtY
        push    dwAlignedExtXInPixels
        push    lpBrush
        push    lpDrawMode
        push    dwRop3
        call    HW_BeginSrcColorDstVram
	jmp	@F

StretchCase:
        push    dwExtDstX
        push    dwExtDstY
        push    dwExtX
        push    dwExtY
        push    dwAlignedExtXInPixels
        push    lpBrush
        push    lpDrawMode
        push    dwRop3
	push	lpClipRect
        call    HW_BeginStretchSrcColorDstVram

@@:
        or      eax,eax
        je      DoneIt
        mov     dwDstWrapWidth,ebx
        mov     dwMaxTransferSizeInBytes,ecx

        ; At this point, the generic and hardware code are linked
        ; until the HW_EndSrcColorDstVram routine is called.
        ; The generic code has agreed not to touch es -- it is the
        ; hardware's selector for whatever purposes it may need.

        ; Now we can begin the inner loop. Ther are two different cases
        ; that can occur and we will handle them separately.
        ; 1) The number of bytes that are to be transferred for a single
        ;    scanline is larger than the most the hardware can accept
        ;    in one shot. Each scanline must be broken into multiple
        ;    pieces. This is most typically the FIFO based model.
        ; 2) At least one scanline, possibly many, can be sent as a
        ;    single transfer. This is the typical DMA scenario.
        push    OFFSET CRet
        cmp     ecx,dwAlignedDstExtXInBytes
        jge     GN_XferWholeColorScans
        jmp     GN_XferPartialColorScans
CRet:
        ; Let the hardware know we are done
        mov     esi,pHWBoardCXOffset
        call    HW_EndSrcColorDstVram
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     eax,1

DoneIt:
        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GN_XferWholeColorScans
;
; Purpose:      This function is called from GN_BitBltSrcColorDstVram
;               when at least one whole scan will fit in the transfer
;               area of the chip. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcColorDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each
;                       pixel is put in the buffer and the wrapWidth
;                       can be added appropriately. These are the
;                       only changes allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferWholeColorScans
GN_XferWholeColorScans  PROC    NEAR

        ; Figure out how many scanlines can be done in a single shot
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        div     dwAlignedDstExtXInBytes
        mov     dwScansPerBlock,eax
        imul    eax,dwAlignedDstExtXInBytes
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel
        sub     ebx,ebx
        lfs     bx,lpFinalColorTable

LoopY:
        ; Compute the number of scans in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ecx,dwScansPerBlock
        sub     dwExtY,ecx
        jge     @F
        add     ecx,dwExtY
        mov     dwExtY,0
        mov     eax,dwAlignedDstExtXInBytes
        imul    eax,ecx
@@:
        ; Get ready to call inner loop
        push    dwExtX
        push    ecx
        push    dwSrcWrapWidth
        push    dwDstWrapWidth

        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        push    esi
        mov     esi,pHWBoardCXOffset
        call    NEAR PTR pfnHWBlockProc
        pop     esi

        ; Call the inner loop to process a chunk of scans
        call    NEAR PTR pfnCopyXlat

        ; If there are more scans to do, go for it.
        cmp     dwExtY,0
        jg      LoopY
        ret

GN_XferWholeColorScans  ENDP


;==============================================================================
;
; Function:     GN_XferPartialColorScans
;
; Purpose:      This function is called from GN_BitBltSrcColorDstVram
;               when one whole scan will not fit in the transfer
;               area of the chip. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcColorDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each
;                       pixel is put in the buffer and the wrapWidth
;                       can be added appropriately. These are the
;                       only changes allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferPartialColorScans
GN_XferPartialColorScans        PROC    NEAR

        ; We can't send a whole scanline in a single transfer so
        ; compute how many pixels we can send in one shot.
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        mov     ebx,dwDstBpp
        inc     ebx
        shr     ebx,3
        mov     dwDstBytesPerPixel,ebx
        div     ebx
        mov     dwPixelsPerBlock,eax
        imul    eax,ebx
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel
        sub     ebx,ebx
        lfs     bx,lpFinalColorTable

LoopY:
        push    dwExtX
LoopX:
        ; Compute the number of pixels in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ecx,dwPixelsPerBlock
        sub     dwExtX,ecx
        jge     @F
        add     ecx,dwExtX
        mov     dwExtX,0
        mov     eax,dwDstBytesPerPixel
        imul    eax,ecx
        add     eax,3
        and     eax, NOT 3
@@:
        ; Get ready to call inner loop
        push    ecx
        pushd   0                               ; Only partial scanlines
        push    dwSrcWrapWidth
        push    dwDstWrapWidth

        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        push    esi
        mov     esi,pHWBoardCXOffset
        call    NEAR PTR pfnHWBlockProc
        pop     esi

        ; Call the inner loop to process a chunk of scans
        call    NEAR PTR pfnCopyXlat

        ; Are there more pixels left on this scanline?
        cmp     dwExtX,0
        jne     LoopX
        pop     dwExtX

        ; Go to next scanline
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jg      LoopY
        ret

GN_XferPartialColorScans        ENDP


;==============================================================================
;
; Function:     GN_ConvertColorTableFrom32To16
;
; Purpose:      This function is called to convert a color table from
;               one with 32bpp color entries to one with 15bpp or 16bpp
;               color entries. The conversion code must be functionally
;               equivalent to the DIBENG.
;
; Arguments:
;               ds:esi  ptr to src color table with 32bpp entries
;               edx     number of entries in src color table
;               es:edi  ptr to dst color table with 15bpp entries
;               ecx     403H if should convert to 15bpp (5-5-5)
;                       202H if should convert to 16bpp (5-6-5)
;
; Returns:      The table has been converted.
;
; Preserve:     None
;==============================================================================
DECPROC GN_ConvertColorTableFrom32To16, PASCAL, NOFRAME, NEAR
OPENPROC
@@:
        mov     eax,ds:[esi]
        add     esi,4

        shld    ebx,eax,10H
        sub     bl,04
        cmc
        sbb     bh,bh
        and     bl,bh
        shl     bx,05

        mov     bl,ah
        sub     bl,ch
        cmc
        sbb     ah,ah
        and     bl,ah
        shr     bx,cl

        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah

        shl     eax,18H
        shld    ebx,eax,05

        mov     es:[edi],bx
        add     edi,2
        dec     edx
        jne     @B
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP16.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp16.asm
;
; Purpose:      This file has inner loop routines in it to copy 4, 8,
;               15, 16, 24, or 32bpp bitmaps to a 16bpp dst bitmap.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To16WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 2,
;               and a word 16bpp RGB value is pulled out of the table
;               and written as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To16WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        movzx   eax,byte ptr ds:[esi]
        inc     esi
        and     eax,0FH
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     ax,fs:[ebx][eax * 2]
        mov     cx,fs:[ebx][ecx * 2]
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        movzx   eax,byte ptr ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer4To16DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 16bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To16DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     eax,fs:[ebx][eax * 4]
        mov     ecx,fs:[ebx][ecx * 4]
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To16WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 2,
;               and a word value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To16WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        shr     eax,10H
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     cx,fs:[ebx][eax * 2]
        mov     es:[edi],cx
        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To16DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 16bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 16bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To16DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,2
        jl      CheckLastPixels

ChunksOf2:
        movzx   eax,word ptr ds:[esi]
        add     esi,2
        movzx   ecx,al
        movzx   edx,ah
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        shld    eax,ecx,10H
        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        shl     ax,05

        mov     al,ch
        sub     al,2
        cmc
        sbb     ch,ch
        and     al,ch
        shr     ax,2

        sub     cl,04
        cmc
        sbb     ch,ch
        and     cl,ch

        shl     ecx,18H
        shld    eax,ecx,05
        mov     es:[edi+0],ax

        shld    eax,edx,10H
        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        shl     ax,05

        mov     al,dh
        sub     al,2
        cmc
        sbb     dh,dh
        and     al,dh
        shr     ax,2

        sub     dl,04
        cmc
        sbb     dh,dh
        and     dl,dh

        shl     edx,18H
        shld    eax,edx,05
        mov     es:[edi+2],ax

        add     edi,4
        sub     dwTempExtX,2
        cmp     dwTempExtX,2
        jge     ChunksOf2

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,fs:[ebx][eax * 4]
        shld    eax,ecx,10H
        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        shl     ax,05

        mov     al,ch
        sub     al,2
        cmc
        sbb     ch,ch
        and     al,ch
        shr     ax,2

        sub     cl,04
        cmc
        sbb     ch,ch
        and     cl,ch

        shl     ecx,18H
        shld    eax,ecx,05
        mov     es:[edi],ax

        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 15bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer15To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     ax,ds:[esi+0]
        mov     cx,ds:[esi+2]
        add     esi,4
        ror     eax,5
        ror     ecx,5
        shl     ax,1
        shl     cx,1
        rol     eax,5
        rol     ecx,5
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     ax,ds:[esi]
        add     esi,2
        ror     eax,5
        shl     ax,1
        rol     eax,5
        mov     es:[edi],ax
        add     edi,2

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 16bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. In fact, no conversion is needed at all.
;               Just copy the src to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer16To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
        ; Let's compute the optimal inner loop. Basically, there
        ; is either 0 or 1 word to get dword aligned (a left edge),
        ; then 0 or more dwords (middle), and finally there may be
        ; an extra word on the end (right edge).
        mov     edx,dwExtX
        add     edx,edx
        mov     eax,esi
        and     eax,2
        sub     edx,eax
        mov     ecx,edx
        shr     eax,1
        cmp     edx,3
        adc     eax,eax
        and     ecx,2
        cmp     ecx,1
        adc     eax,eax
        xor     eax,3
        shr     edx,2
        jmp     NEAR PTR cs:JmpTable[eax * 4]

JmpTable:
DD      OFFSET L0_M0_R0,OFFSET L0_M0_R1,OFFSET L0_MX_R0,OFFSET L0_MX_R1
DD      OFFSET L1_M0_R0,OFFSET L1_M0_R1,OFFSET L1_MX_R0,OFFSET L1_MX_R1

L1_MX_R1:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R1
        jmp     Done

L1_MX_R0:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R0
        jmp     Done

L1_M0_R1:
        movs    dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_M0_R1
        jmp     Done

L0_MX_R1:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R1
        jmp     Done

L0_MX_R0:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R0
        jmp     Done

L1_M0_R0:
L0_M0_R1:
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_M0_R1

L0_M0_R0:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 24bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer24To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     cl,ds:[esi+5]
        shl     ecx,10H
        mov     cx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     al,ds:[esi+2]
        shl     eax,10H
        mov     ax,ds:[esi+0]
        add     esi,3
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer32To16
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 32bpp bitmap to a 16bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer32To16, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,2
        shr     cx,2
        ror     eax,6
        ror     ecx,6
        shr     ax,3
        shr     cx,3
        rol     eax,11
        rol     ecx,11
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     eax,ds:[esi]
        add     esi,4
        shr     eax,3
        ror     eax,5
        shr     ax,2
        ror     eax,6
        shr     ax,3
        rol     eax,11
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP32.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp32.asm
;
; Purpose:      This file has inner loop routines in it to copy 4, 8,
;               15, 16, 24, or 32bpp bitmaps to a 32bpp dst bitmap.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 32bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               and used as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     eax,fs:[ebx][eax * 4]
        mov     es:[edi],eax
        add     edi,4
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     eax,fs:[ebx][eax * 4]
        mov     ecx,fs:[ebx][ecx * 4]
        mov     es:[edi+0],eax
        mov     es:[edi+4],ecx
        add     edi,8
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        mov     es:[edi],eax
        add     edi,4
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 32bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 4,
;               and a dword value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     edx,dwExtX
        mov     dwTempExtX,edx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        movzx   ecx,al
        movzx   edx,ah
        shr     eax,10H
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        movzx   ecx,al
        movzx   edx,ah
        add     edi,8
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     eax,fs:[ebx][eax * 4]
        mov     es:[edi],eax
        add     edi,4
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 15bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. Each pixel is converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer15To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD	dwTempExtX
OPENPROC
LoopTop:
        mov     edx,dwExtX
        mov     dwTempExtX,edx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        ; First chunk of 2
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5 + 8
        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8

        ; Do a second chunk of two
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
	shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5
        shrd    edx,ebx,5
        shr     eax,5
        shr     ebx,5
        shrd    ecx,eax,1
        shrd    edx,ebx,1
        sar     ecx,2
        sar     edx,2
        shrd    ecx,eax,5 + 8
        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,word ptr ds:[esi]
        add     esi,2
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5
        shr     eax,5
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5
        shr     eax,5
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5 + 8
        mov     es:[edi],ecx
        add     edi,4
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 16bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. Each pixel is converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer16To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     edx,dwExtX
        mov     dwTempExtX,edx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        ; First chunk of 2
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5
                                        shrd    edx,ebx,5
        shr     eax,5
                                        shr     ebx,5
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,1
                                        sar     edx,1
        shrd    ecx,eax,6
                                        shrd    edx,ebx,6
        shr     eax,6
                                        shr     ebx,6
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5 + 8
                                        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8

        ; Do a seond chunk of two
        movzx   eax,word ptr ds:[esi+0]
        movzx   ebx,word ptr ds:[esi+2]
        add     esi,4

        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5
                                        shrd    edx,ebx,5
        shr     eax,5
                                        shr     ebx,5
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,1
                                        sar     edx,1
        shrd    ecx,eax,6
                                        shrd    edx,ebx,6
        shr     eax,6
                                        shr     ebx,6
        shrd    ecx,eax,1
                                        shrd    edx,ebx,1
        sar     ecx,2
                                        sar     edx,2
        shrd    ecx,eax,5 + 8
                                        shrd    edx,ebx,5 + 8

        mov     es:[edi+0],ecx
        mov     es:[edi+4],edx
        add     edi,8
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,word ptr ds:[esi]
        add     esi,2
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5
        shr     eax,5
        shrd    ecx,eax,1
        sar     ecx,1
        shrd    ecx,eax,6
        shr     eax,6
        shrd    ecx,eax,1
        sar     ecx,2
        shrd    ecx,eax,5 + 8
        mov     es:[edi],ecx
        add     edi,4
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 24bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. Each pixel is converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer24To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+3]
        add     esi,6
        mov     es:[edi+0],eax
        mov     es:[edi+4],ecx
        add     edi,8
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+2]
        add     esi,6
        shr     ecx,8
        mov     es:[edi+0],eax
        mov     es:[edi+4],ecx
        add     edi,8
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     al,ds:[esi+2]
        shl     eax,10H
        mov     ax,ds:[esi+0]
        add     esi,3
        mov     es:[edi],eax
        add     edi,4
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer32To32
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 32bpp src bitmap to a 32bpp dst bitmap. There is no
;               color translate table. In fast, there is no conversion
;               period. Just copy the src to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer32To32, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
@@:
        mov     ecx,dwExtX
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     @B
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP8.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp8.asm
;
; Purpose:      This file has functions to copy X-bpp bitmaps to
;               16bpp bitmaps.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To8WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 8bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 2,
;               and a word 16bpp value is pulled out of the table. The
;               low byte of this word should be used as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To8WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     cl,fs:[ebx][eax * 2]
        mov     es:[edi],cl
        inc     edi
        sub     ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
        shr     eax,4
        and     ecx,00FH
        mov     al,fs:[ebx][eax * 2]
        mov     cl,fs:[ebx][ecx * 2]
        mov     es:[edi+0],al
        mov     es:[edi+1],cl
        add     edi,2
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
        sub     ecx,ecx
        dec     edx
        jl      NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
        shr     eax,4
        mov     al,fs:[ebx][eax * 2]
        mov     es:[edi],al
        inc     edi
        inc     ecx

NextScan:
        shl     esi,1
        add     esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To8NoXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 8bpp dst bitmap. There is no
;               color translate table needed. Just copy the src to the
;               dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer8To8NoXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
        ; Are there just a few bytes to do?
        mov     eax,esi
        neg     eax
        and     eax,3
        mov     edx,dwExtX
        sub     edx,eax
        jg      @F
        mov     eax,dwExtX
        sub     ebx,ebx
        jmp     L0_M0_RX
@@:
        ; We can
        sub     ecx,ecx
        mov     ebx,edx
        shr     edx,2
        and     ebx,3
        or      eax,eax
        setne   cl
        cmp     edx,1
        adc     ecx,ecx
        cmp     ebx,1
        adc     ecx,ecx
        xor     ecx,3
        jmp     NEAR PTR cs:CopyJmpTable[ecx * 4]


CopyJmpTable    LABEL   DWORD
DD      OFFSET L0_M0_R0,OFFSET L0_M0_RX,OFFSET L0_MX_R0,OFFSET L0_MX_RX
DD      OFFSET LX_M0_R0,OFFSET LX_M0_RX,OFFSET LX_MX_R0,OFFSET LX_MX_RX

LX_MX_RX:
        mov     ecx,eax
        rep     movs byte ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,ebx
        rep     movs byte ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LX_MX_RX
        jmp     Done

LX_MX_R0:
        mov     ecx,eax
        rep     movs byte ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LX_MX_R0
        jmp     Done

L0_MX_RX:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,ebx
        rep     movs byte ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_RX
        jmp     Done

L0_MX_R0:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R0
        jmp     Done

LX_M0_RX:
LX_M0_R0:
L0_M0_RX:
        add     eax,ebx
@@:     mov     ecx,eax
        rep     movs byte ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     @B
        jmp     Done

L0_M0_R0:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To8ByteXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 8bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 1,
;               and a byte value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To8ByteXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        sub     ecx,ecx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        mov     cl,al
        mov     al,fs:[ebx + ecx]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx]
        rol     eax,10H
        mov     cl,al
        mov     al,fs:[ebx + ecx]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx]
        rol     eax,10H
        mov     es:[edi],eax
        sub     edx,4
        add     edi,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     cl,ds:[esi]
        inc     esi
        mov     al,fs:[ebx + ecx]
        mov     es:[edi],al
        inc     edi
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To8WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 8bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 2,
;               and a word value is pulled out. The low byte of this word
;               is written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To8WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwBytesRest
OPENPROC
LoopTop:
        mov     edx,dwExtX
        sub     ecx,ecx
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        mov     cl,al
        mov     al,fs:[ebx + ecx * 2]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx * 2]
        rol     eax,10H
        mov     cl,al
        mov     al,fs:[ebx + ecx * 2]
        mov     cl,ah
        mov     ah,fs:[ebx + ecx * 2]
        rol     eax,10H
        mov     es:[edi],eax
        sub     edx,4
        add     edi,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     cl,ds:[esi]
        inc     esi
        mov     al,fs:[ebx + ecx * 2]
        mov     es:[edi],al
        inc     edi
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 15bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer15To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
LoopX:
        mov     dx,ds:[esi]
        and     edx,7FFFH
        add     esi,2
        mov     al,fs:[ebx + edx]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 16bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer16To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
        sub     eax,eax
LoopX:
        mov     ax,ds:[esi]
        ror     eax,5
        shr     ax,1
        rol     eax,5
        add     esi,2
        mov     al,fs:[ebx + eax]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 24bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer24To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
LoopX:
        mov     al,ds:[esi]
        shr     al,3
        shrd    edx,eax,5
        mov     al,ds:[esi + 1]
        shr     al,3
        shrd    edx,eax,5
        xor     ah,ah
        mov     al,ds:[esi + 2]
        shr     al,3
        shrd    edx,eax,16H
        add     esi,3
        mov     al,fs:[ebx + edx]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer32To8
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 32bpp src bitmap to a 8bpp dst bitmap.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer32To8, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        mov     ecx,dwExtX
LoopX:
        mov     al,ds:[esi]
        shr     al,3
        shrd    edx,eax,5
        mov     al,ds:[esi + 1]
        shr     al,3
        shrd    edx,eax,5
        xor     ah,ah
        mov     al,ds:[esi + 2]
        shr     al,3
        shrd    edx,eax,16H
        add     esi,4
        mov     al,fs:[ebx + edx]
        mov     es:[edi],al
        inc     edi
        dec     ecx
        jne     LoopX

        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCP15.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncp15.asm
;
; Purpose:      This file has inner loop routines in it to copy 4, 8,
;               15, 16, 24, or 32bpp bitmaps to a 15bpp dst bitmap.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_Xfer4To15WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 2,
;               and a word 15bpp value is pulled out of the table and
;               used as the dst pixel.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To15WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        movzx   eax,byte ptr ds:[esi]
        inc     esi
        and     eax,0FH
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
	shr	eax,4
        and     ecx,00FH
        mov     ax,fs:[ebx][eax * 2]
        mov     cx,fs:[ebx][ecx * 2]
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        movzx   eax,byte ptr ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     ax,fs:[ebx][eax * 2]
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer4To15DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 4bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 4bpp value (a number
;               from 0 through 15 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 15bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src nibble
;                       NOTE: This is a nibble address!!!
;                       You must divide esi by 2 to get the byte address
;                       If esi is even then use the high nibble in the byte
;                       If esi is odd then use the low nibble in the byte
;               es:edi  ptr to first dst pixel -- normal byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of nibbles (not bytes)
;                       to be added into esi after dwExtX src pixels
;                       (which are nibbles) have been processed to bring
;                       esi to point to the first nibble to be processed
;                       on the following scanline.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src nibble to be processed
;                       NOTE: Once again this should be a nibble address
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer4To15DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopY:
        ; Remember the dwExtX
        mov     edx,dwExtX

        ; Get a byte address
        shr     esi,1
        jnc     ByteAligned

        mov     al,ds:[esi]
        inc     esi
        and     eax,0FH
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
	sub	ecx,ecx
        dec     edx
        je      NextScan

ByteAligned:
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     al,ds:[esi]
        inc     esi
        mov     ecx,eax
        and     eax,0F0H
        and     ecx,00FH
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        mov     ecx,fs:[ebx][ecx * 4]
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
	sub	ecx,ecx
        dec     edx
        jl	NextScan
        mov     al,ds:[esi]
        and     eax,0F0H
	shr	eax,4
        mov     eax,fs:[ebx][eax * 4]
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
	inc	ecx

NextScan:
	shl	esi,1
	add	esi,ecx
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopY
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To15WordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 2,
;               and a word value is pulled out and written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To15WordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi]
        add     esi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        shr     eax,10H
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        movzx   ecx,ah
        mov     edx,dword ptr fs:[ebx][ecx * 2 - 2]
        movzx   ecx,al
        mov     dx,fs:[ebx][ecx * 2]
        mov     es:[edi],edx
        add     edi,4
        sub     dwTempExtX,4
        cmp     dwTempExtX,4
        jge     ChunksOf4

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     cx,fs:[ebx][eax * 2]
        mov     es:[edi],cx
        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer8To15DwordXlat
;
; Purpose:      This function can be used as the inner loop for copies
;               of a 8bpp src bitmap to a 15bpp dst bitmap. The color
;               translate table is indexed with a 8bpp value (a number
;               from 0 through 255 inclusive) scaled up by a factor of 4,
;               and a dword 32bpp RGB value is pulled out of the table.
;               Then the 32bpp dword value is down converted to 15bpp
;               on the fly ad the resulting value written to the dst.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               fs:ebx  ptr to color translate table
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     fs,ebx
;==============================================================================
DECPROC GN_Xfer8To15DwordXlat, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
LOCALD  dwTempExtX
OPENPROC
LoopTop:
        mov     eax,dwExtX
        mov     dwTempExtX,eax
        cmp     eax,2
        jl      CheckLastPixels

ChunksOf2:
        movzx   eax,word ptr ds:[esi]
        add     esi,4
        movzx   ecx,al
        movzx   edx,ah
        mov     ecx,dword ptr fs:[ebx][ecx * 4]
        mov     edx,dword ptr fs:[ebx][edx * 4]
        shr     ecx,3
        shr     edx,3
        ror     ecx,5
        ror     edx,5
        shr     cx,3
        shr     dx,3
        ror     ecx,5
        ror     edx,5
        shr     cx,3
        shr     dx,3
        rol     ecx,10
        rol     edx,10
        mov     es:[edi+0],cx
        mov     es:[edi+2],dx
        add     edi,4
        sub     dwTempExtX,2
        cmp     dwTempExtX,2
        jge     ChunksOf2

CheckLastPixels:
        cmp     dwTempExtX,0
        je      NextScan

OnePixelAtATime:
        movzx   eax,byte ptr ds:[esi]
        inc     esi
        mov     ecx,fs:[ebx][eax * 4]
        shr     ecx,3
        ror     ecx,5
        shr     cx,3
        ror     ecx,5
        shr     cx,3
        rol     ecx,10
        mov     es:[edi],cx
        add     edi,2
        dec     dwTempExtX
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer15To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 15bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer15To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
        ; Let's compute the optimal inner loop. Basically, there
        ; is either 0 or 1 word to get dword aligned (a left edge),
        ; then 0 or more dwords (middle), and finally there may be
        ; an extra word on the end (right edge).
        mov     edx,dwExtX
        add     edx,edx
        mov     eax,esi
        and     eax,2
        sub     edx,eax
        mov     ecx,edx
        shr     eax,1
        cmp     edx,3
        adc     eax,eax
        and     ecx,2
        cmp     ecx,1
        adc     eax,eax
        xor     eax,3
        shr     edx,2
        jmp     NEAR PTR cs:JmpTable[eax * 4]

JmpTable:
DD      OFFSET L0_M0_R0,OFFSET L0_M0_R1,OFFSET L0_MX_R0,OFFSET L0_MX_R1
DD      OFFSET L1_M0_R0,OFFSET L1_M0_R1,OFFSET L1_MX_R0,OFFSET L1_MX_R1

L1_MX_R1:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R1
        jmp     Done

L1_MX_R0:
        movs    word ptr es:[edi], ds:[esi]
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_MX_R0
        jmp     Done

L1_M0_R1:
        movs    dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L1_M0_R1
        jmp     Done

L0_MX_R1:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R1
        jmp     Done

L0_MX_R0:
        mov     ecx,edx
        rep     movs dword ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_MX_R0
        jmp     Done

L1_M0_R0:
L0_M0_R1:
        movs    word ptr es:[edi], ds:[esi]
        cmp     dwExtY,0
        je      Done
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     L0_M0_R1

L0_M0_R0:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer16To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 16bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer16To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,2
        jl      CheckLastPixel

ChunksOf2:
        mov     ax,ds:[esi+0]
        mov     cx,ds:[esi+2]
        add     esi,4
        ror     eax,5
        ror     ecx,5
        shr     ax,1
        shr     cx,1
        rol     eax,5
        rol     ecx,5
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,2
        cmp     edx,2
        jge     ChunksOf2

CheckLastPixel:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     ax,ds:[esi]
        add     esi,2
        ror     eax,5
        shr     ax,1
        rol     eax,5
        mov     es:[edi],ax
        add     edi,2

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC


;==============================================================================
;
; Function:     GN_Xfer24To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 24bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer24To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     cl,ds:[esi+5]
        shl     ecx,10H
        mov     cx,ds:[esi+3]
        add     esi,6
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     al,ds:[esi+2]
        shl     eax,10H
        mov     ax,ds:[esi+0]
        add     esi,3
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC

;==============================================================================
;
; Function:     GN_Xfer32To15
;
; Purpose:      This function can be used as the inner loop for copies
;               from a 32bpp bitmap to a 15bpp bitmap. No Color translate
;               table is needed. Each pixel must be converted on the fly.
;
; Arguments:    ds:esi  ptr to first src pixel -- this is a byte address
;               es:edi  ptr to first dst pixel -- this is a byte address
;               dwExtX  In Pixels
;               dwExtY  In Scanlines -- if this number is 0, then
;                       you are only processing a portion of the scanline
;                       so do not add in the WrapWidths when you are done
;                       processing dwExtX pixels. You just return.
;               dwSrcWrapWidth  This is the number of bytes to add to esi
;                       after dwExtX src pixels have been processed to
;                       bring esi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;               dwDstWrapWidth  This is the number of bytes to add to edi
;                       after dwExtX dst pixels have been processed to
;                       bring edi to point to the first pixel to be
;                       processed on the following scanline. This is all
;                       in easy byte addresses.
;
; Returns:      None
;               ds:esi  should point to the next src pixel to be processed
;               es:edi  should point to the next dst pixel to be processed
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_Xfer32To15, PASCAL, FRAME, NEAR
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwSrcWrapWidth
PARMD   dwDstWrapWidth
OPENPROC
LoopTop:
        mov     edx,dwExtX
        cmp     edx,4
        jl      CheckLastPixels

ChunksOf4:
        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4

        mov     eax,ds:[esi+0]
        mov     ecx,ds:[esi+4]
        add     esi,8
        shr     eax,3
        shr     ecx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        ror     eax,5
        ror     ecx,5
        shr     ax,3
        shr     cx,3
        rol     eax,10
        rol     ecx,10
        mov     es:[edi+0],ax
        mov     es:[edi+2],cx
        add     edi,4
        sub     edx,4
        cmp     edx,4
        jge     ChunksOf4

CheckLastPixels:
        or      edx,edx
        je      NextScan

OnePixelAtATime:
        mov     eax,ds:[esi]
        add     esi,4
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,10
        mov     es:[edi],ax
        add     edi,2
        dec     edx
        jne     OnePixelAtATime

NextScan:
        cmp     dwExtY,0
        je      @F
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwExtY
        jne     LoopTop
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCURSOR.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncursor.asm
;
; Purpose:      This file holds the SetCursor, MoveCursor, and CheckCursor
;               display driver entry point.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc


OPENSEG  _DATA, USE16, DATA
; This structure is too big to put on the stack because sometimes
; GDI calls SetCursor with a 4K (!) stack and this is over 4K!
; We use this area to convert 8bpp cursors to 32bpp cursors to
; avoid problems where the palette changes while a cursor is
; still in the cache and then the pattern gets reloaded into the
; hardware without getting retranslated through the new palette.
SIZE_32BPP_CURSOR_PLUS_HEADER   TEXTEQU <SIZE CURSORDESCEX + AND_MASK_SIZE + 20H * 20H * 4>
TempCursor              DB      (SIZE_32BPP_CURSOR_PLUS_HEADER) DUP (0)
wTempCursorInUse        DW      0
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_CreateCursorCache
;
; Purpose:      This function destroys a cursor cache. Memory is
;               freed and ptrs are zeroed.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset
;
; Returns:      eax             0       then Failure
;                               non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateCursorCache, PASCAL, FRAME, FAR32
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Now allocate a cursor cache
        mov     eax, SIZE CURSORCACHE
        add     eax,(SIZE CURSORDESCEX * MAX_CACHEABLE_CURSORS)
        push    eax
        call    HW_AllocFlatMemory
        mov     ds:[esi].GNCRTCCX.pCursorCache,eax

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyCursorCache
;
; Purpose:      This function destroys a cursor cache. Memory is
;               freed and ptrs are zeroed.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyCursorCache, PASCAL, FRAME, FAR32
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Now allocate a cursor cache
        mov     eax,ds:[esi].GNCRTCCX.pCursorCache
        or      eax,eax
        je      @F

        push    esi
        call    GN_ClearCursorCache

        push    ds:[esi].GNCRTCCX.pCursorCache
        call    HW_FreeFlatMemory
        mov     ds:[esi].GNCRTCCX.pCursorCache,0
@@:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ClearCursorCache
;
; Purpose:      This function clears the cursor cache which will
;               cause all cache entries to be marked empty. However
;               it will not flush current patterns from the cache,
;               thus making sure the selected pattern remains valid
;               until the next pattern is set.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearCursorCache, PASCAL, FRAME, FAR32
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Mark all cache spots so that there will never be a match
        mov     ebx,ds:[esi].GNCRTCCX.pCursorCache
        mov     ecx,ds:[esi].GNCRTCCX.dwMaxCacheableCursors
        lea     ebx,[ebx + SIZE CURSORCACHE]
        mov     eax,-1
@@:     mov     ds:[ebx].CURSORDESCEX.wWidthBytes,ax
        mov     ds:[ebx].CURSORDESCEX.ExtraData.dwCursorHash,eax
        add     ebx,SIZE CURSORDESCEX
        dec     ecx
        jne     @B

        ; Set flags so that the cursor will be moved/selected correctly
        mov     ebx,ds:[esi].GNCRTCCX.pCursorCache
        or      ds:[ebx].CURSORCACHE.dwCursorFlags,CURSOR_MOVE OR CURSOR_SELECT OR CURSOR_IS_NULL
        mov     ds:[ebx].CURSORCACHE.dwNextCacheSlot,0

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ClearAllCursorCaches
;
; Purpose:      This routine runs through all the GNLOGDEVCXs on the
;               board and clears the cursor cache for each of them.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearAllCursorCaches, PASCAL, FRAME, FAR32
PARMD   pGNBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNBoardCXOffset

        ; Set up a loop to enumerate logical devices
        sub     ebx,ebx

LoopLogdev:
        mov     ecx,ds:[eax].GNBOARDCX.pGNLogdevCX[ebx * 4]
        or      ecx,ecx
        je      NextLogdev

        ; Start with the first CRTCCX
        mov     edx,0

LoopCrtc:
        mov     esi,ds:[ecx].GNLOGDEVCX.pGNCrtcCX[edx * 4]
        or      esi,esi
        je      NextCrtc

        ; We found a CRTCCX. Clear the cursor cache.
        push    eax                     ; save GNBOARDCX
        push    ebx                     ; save index into GNLOGDEVCXs
        push    ecx                     ; save GNLOGDEVCX
        push    edx                     ; save index into GNCRTCCXs
        push    esi
        call    GN_ClearCursorCache
        pop     edx                     ; restore index into GNCRTCCXs
        pop     ecx                     ; restore GNLOGDEVCX
        pop     ebx                     ; restore index into GNLOGDEVCXs
        pop     eax                     ; restore GNBOARDCX

NextCrtc:
        ; We could potentially have as many physical devices on a
        ; logical device as there are CRTCs on the board.
        inc     edx
        cmp     edx,ds:[ecx].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCrtc

NextLogdev:
        ; We could potentially have as many logical devices
        ; as CRTCs on the board
        inc     ebx
        cmp     ebx,ds:[eax].GNBOARDCX.dwNumCrtcsOnBoard
        jc      LoopLogdev

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_Convert8BppCursorTo32BppCursor
;
; Purpose:      This function converts an 8bpp cursor to a 32bpp
;               cursor.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lp8BppCursorShape       16:16 "src" 8bpp cursor
;               lp32BppCursorShape      16:16 ptr to place to store
;                                       converted cursor
;
; Returns:      eax = 0 - OK; NE 0 - Fail
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_Convert8BppCursorTo32BppCursor, PASCAL, FRAME, NEAR
PARMD   pGNCrtcCXOffset
PARMD   lp8BppCursorShape
PARMD   lp32BppCursorShape
OPENPROC
        PUSHR   esi,edi

        ; Convert the 8bpp cursor to a 32bpp cursor
        sub     esi,esi
        lfs     si,lp8BppCursorShape
        sub     edi,edi
        les     di,lp32BppCursorShape

        ; First copy the header
        movzx   eax,fs:[esi].CURSORDESC.wWidth
        imul    ax,fs:[esi].CURSORDESC.wHeight
        cmp     eax,SIZE_32BPP_CURSOR_PLUS_HEADER
        jg      WrongHeader
        mov     ecx,eax
        shr     ecx,5
        add     ecx,(SIZE CURSORHEADER) SHR 2
        rep     movs dword ptr es:[edi], fs:[esi]

        ; Fix up the bits per pixel field to say 32bpp
        movzx   ecx,word ptr lp32BppCursorShape
        mov     es:[ecx].CURSORDESC.bBitsPerPixel,32

        ; Now we are at the XOR mask for the cursor.
        ; Translate it through the palette, pixel by pixel
        mov     ebx,pGNCrtcCXOffset
        lea     ebx,[ebx].GNCRTCCX.dwPaletteTable
        mov     ecx,eax

Cont_Xlate:
        movzx   eax,byte ptr fs:[esi]
        inc     esi
        mov     eax,ds:[ebx][eax * 4]
        and     eax,00FFFFFFh
        mov     es:[edi],eax
        add     edi,4
        dec     ecx
        jne     Cont_Xlate
        sub     eax,eax

WrongHeader:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_SetCursor
;
; Purpose:      This function is the SetCursor display driver entry point.
;               This routine may be interrupt time -- be sure to preserve
;               the registers appropriately.
;
; Arguments:
;               lpCursorShape   ptr to cursorShape structure
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetCursor, PASCAL, FRAME, FAR16, LOGOFF
PARMD   lpCursorShape
LOCALD  lpTempCursor
LOCALD  dwUsingTempCursorInDataSeg
LOCALD  dwTotalCursorDataSize
LOCALD  dwCursorsLeftToSearch
LOCALD  pThisCursorCache
LOCALD  dwMaxCursorCacheEntries
LOCALD  dwCursorPixelDepth
LOCALD  dwHadToAlloc
LOCALD  dwCRTCCount
LOCALD  ppGNCrtcCXOffset
LOCALD  pGNCrtcCXOffset
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        pushf

        ; Prepare for the routine
        mov     dwHadToAlloc,0
        cld

        ; Load up our context
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     DoneIt

        mov     dwCRTCCount,0
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ppGNCrtcCXOffset,eax

        ; If this CRTC is not a NULL context ...
LoopCRTC:
        mov     eax,ppGNCrtcCXOffset
        mov     esi,ds:[eax]
        or      esi,esi
        je      NextCrtc

        ; Get a few things relating to this cursor cache
        mov     eax,ds:[esi].GNCRTCCX.dwMaxCacheableCursors
        mov     dwMaxCursorCacheEntries,eax
        mov     edi,ds:[esi].GNCRTCCX.pCursorCache
        or      edi,edi
        je      NextCrtc

        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        je      HW_SetCursor

        ; Check for NULL cursor ...
        or      ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        cmp     lpCursorShape,0
        je      @F
        and     ds:[edi].CURSORCACHE.dwCursorFlags,NOT CURSOR_IS_NULL
@@:
        ; We have to move the cursor first time after switching.
        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_MOVE
        je      @F
        and     ds:[edi].CURSORCACHE.dwCursorFlags,NOT CURSOR_MOVE
        mov     eax,dword ptr ds:[edi].CURSORCACHE.wCursorX
        ror     eax,10H
        push    eax
        push    cs:[CSlp16LogDevice]
        call    DIB_MoveCursorExt

@@:
        push    lpCursorShape
        push    cs:[CSlp16LogDevice]
        call    DIB_SetCursorExt
        jmp     NextCrtc

HW_SetCursor:
        mov     pThisCursorCache,edi

        ; Check for NULL cursor ...
        cmp     lpCursorShape,0
        jne     NonNullCursor

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; A NULL lpCursorShape means to turn the cursor off.
NullCursor:
        ; disable the cursor on it
        or      ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        push    esi
        pushd   0
        pushd   0
        call    GN_TurnCursorOffOrOn
        jmp     NextCrtc
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NonNullCursor:
        ; See if we need to convert the 8bpp cursor to a 32bpp
        ; cursor through the palette. This way, palette changes
        ; won't affect the cursor color in the future. Do we have
        ; a temporary area to do the cursor translation? If not
        ; we have to allocate. The Alloc should not happen
        ; unless SetCursor reenters itself.
        mov     eax,lpCursorShape
        mov     lpTempCursor,eax
        sub     ebx,ebx
        sub     eax,eax
        les     bx,lpCursorShape

        ; Check for the valid selector first
        mov     ax,es
        lar     edx,eax
        jnz     DoneIt
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     DoneIt

        ; Check for the valid bpp
        mov     al,es:[ebx].CURSORDESC.bBitsPerPixel
        cmp     al,1
        je      CheckCache
        cmp     al,4
        je      CheckCache
        cmp     al,15
        je      CheckCache
        cmp     al,16
        je      CheckCache
        cmp     al,24
        je      CheckCache
        cmp     al,32
        je      CheckCache
        cmp     al,8
        jne     DoneIt

        mov     ax,SEG TempCursor
        shl     eax,10H
        lea     ax,TempCursor
        mov     lpTempCursor,eax

        mov     ax,_DATA
        mov     fs,ax
        mov     ecx,1
        xchg    cx,fs:[wTempCursorInUse]
        or      ecx,ecx
        je      @F

        mov     eax,SIZE_32BPP_CURSOR_PLUS_HEADER
        call    GN_MemoryAlloc
        or      eax,eax
        je      SetCursorDone
        shl     edx,10H
        mov     lpTempCursor,edx
        mov     dwHadToAlloc,1
@@:
        push    esi
        push    lpCursorShape
        push    lpTempCursor
        call    GN_Convert8BppCursorTo32BppCursor
        or      eax,eax
        jnz     SetCursorDone

        ; Reload this
        sub     ebx,ebx
        les     bx,lpTempCursor
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CheckCache:
        ; es:ebx should point to the CURSORDESCEX

        ; See if this cursor shape is currently in the cache
        ; First we calculate the size of the cursor in EBX
        movzx   ecx,es:[ebx].CURSORDESC.bBitsPerPixel
        mov     dwCursorPixelDepth,ecx

        ; Convert 15 to 16
        cmp     ecx,15
        sete    al
        movzx   eax,al
        add     ecx,eax

        ; Anything over 32bpp gets set to 32bpp
        ; For Debug Only:
        ; 33Bpp = ARGB format
        ; 34Bpp = ARGB premultiplied format
        cmp     ecx,32
        jle     @F
        mov     ecx,32
@@:
        ; Figure out the total size of the CURSORDESC
        ; plus the AND_MASK and the cursor data
        inc     ecx
        movzx   eax,es:[ebx].CURSORDESC.wWidth
        imul    eax,ecx
        movzx   ecx,es:[ebx].CURSORDESC.wHeight
        imul    eax,ecx
        shr     eax,3
        add     eax,(SIZE CURSORHEADER)
        shr     eax,2
        cmp     eax,SIZE_32BPP_CURSOR_PLUS_HEADER
        jg      SetCursorDone
        mov     dwTotalCursorDataSize,eax
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; It's a little quicker to find by hashing first
        mov     eax,dwMaxCursorCacheEntries
        mov     dwCursorsLeftToSearch,eax
        mov     eax,pThisCursorCache
        add     eax,SIZE CURSORCACHE
        mov     esi,lpCursorShape
HashLoop:
        cmp     esi,ds:[eax].CURSORDESCEX.ExtraData.dwCursorHash
        je      HashHit
HashFail:
        add     eax,SIZE CURSORDESCEX
        dec     dwCursorsLeftToSearch
        jne     HashLoop
        jmp     CheckLong
HashHit:
        movzx   edi,word ptr lpTempCursor
        lea     esi,[eax].CURSORDESCEX.wHotX
        mov     ecx,dwTotalCursorDataSize
        repe    cmps dword ptr ds:[esi], es:[edi]
        je      CursorMatch
        mov     esi,lpCursorShape
        jmp     HashFail
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Didn't find a hash match. Check everything the long way.
CheckLong:
        mov     edi,pThisCursorCache
        lea     eax,[edi + SIZE CURSORCACHE].CURSORDESCEX.wHotX
        mov     ecx,dwMaxCursorCacheEntries
        mov     dwCursorsLeftToSearch,ecx

LongLoop:
        movzx   edi,word ptr lpTempCursor
        mov     esi,eax
        mov     ecx,dwTotalCursorDataSize
        repe    cmps dword ptr ds:[esi], es:[edi]
        je      CursorMatch
        add     eax,SIZE CURSORDESCEX
        dec     dwCursorsLeftToSearch
        jne     LongLoop
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NoMatch:
        ; Didn't find a match, so use the next cache slot
        mov     edx,pThisCursorCache
        mov     eax,ds:[edx].CURSORCACHE.dwNextCacheSlot
        mov     ds:[edx].CURSORCACHE.dwSelectedCacheSlot,eax
        imul    edi,eax,SIZE CURSORDESCEX
        lea     edi,[edx + SIZE CURSORCACHE][edi]
        mov     ecx,lpCursorShape
        mov     ds:[edi].CURSORDESCEX.ExtraData.dwCursorHash,ecx
        sub     esi,esi
        lfs     si,lpTempCursor
        mov     cx,ds
        mov     es,cx
        add     edi,SIZE CURSOREXTRA
        mov     ecx,dwTotalCursorDataSize
        rep     movs dword ptr es:[edi], fs:[esi]

        ; Indicate which cursor slot needs updating by the hardware and
        ; also that some lazy activity is required.
        lea     ecx,[eax + NUM_CURSOR_FLAGS]
        mov     ebx,1
        shl     ebx,cl
        or      ebx,CURSOR_MOVE OR CURSOR_SELECT
        or      ebx,ds:[edx].CURSORCACHE.dwCursorFlags
        and     ebx,NOT CURSOR_IS_NULL
        mov     ds:[edx].CURSORCACHE.dwCursorFlags,ebx

        ; Update the next cache slot.  The first three cursors to
        ; go in are usually the really common ones, like the arrow,
        ; the hourglass, and the arrow/hourglass combo. So never
        ; kick the first three out once they go in.
        inc     eax
        cmp     eax,dwMaxCursorCacheEntries
        jc      @F
        mov     eax,3
@@:     mov     ds:[edx].CURSORCACHE.dwNextCacheSlot,eax
        mov     ebx,edx
        jmp     SetCursorWhere

CursorMatch:
        ; edx is the cursor cache number that matched
        mov     ebx,pThisCursorCache
        mov     edx,dwMaxCursorCacheEntries
        sub     edx,dwCursorsLeftToSearch
        mov     ds:[ebx].CURSORCACHE.dwSelectedCacheSlot,edx

        ; Don't put off the lazy activity for cursors that are already
        ; in the cache or the cursor seems unresponsive.
        mov     eax,ds:[ebx].CURSORCACHE.dwCursorFlags
        and     eax,NOT CURSOR_IS_NULL
        or      eax,CURSOR_MOVE OR CURSOR_SELECT
        mov     ds:[ebx].CURSORCACHE.dwCursorFlags,eax

SetCursorWhere:
        mov     eax,ppGNCrtcCXOffset
        push    dword ptr ds:[eax]
        call    GN_CursorAction
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetCursorDone:
        cmp     dwHadToAlloc,0
        je      @F
        movzx   eax,word ptr lpTempCursor+2
        call    GN_MemoryFree
        jmp     Skip5
@@:
        ; We didn't have to alloc, so wemust have been using
        ; the TempCursor
        mov     ax,_DATA
        mov     fs,ax
        mov     fs:[wTempCursorInUse],0
Skip5:

NextCrtc:
        ; Go to the next CRTC
        add     ppGNCrtcCXOffset,4
        inc     dwCRTCCount
        mov     esi,cs:[CSpGNLogicalDevice]
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoneIt:
        ; We are Done!
        popf
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_CursorAction
;
; Purpose:      This function should be called when it is desired to
;               set, move, select, or enable the cursor. The appropriate
;               sequencing is performed to do all the actions in the
;               correct order.
;
; Arguments:
;               ds      Context Selector
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CursorAction, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pGNCrtcCXOffset
LOCALD  pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset
        mov     esi,ds:[edi].GNCRTCCX.pCursorCache
        mov     eax,ds:[edi].GNCRTCCX.pHWCrtcCX
        mov     pHWCrtcCXOffset,eax

        ; Check the semaphore so we don't step on ourselves
        bts     ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_SEMAPHORE_BIT
        jc      BlockedSemaphore

        ; Handle cursor setting first. There may be many cursors to set
        ; because SetCursor may have been called multiple times since
        ; the last lazy call to this routine. However, only bother
        ; placing the cursor we are going to select into the HW.

        ; If the currently selected cursor needs setting, then do so
        mov     ecx,ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        add     ecx,NUM_CURSOR_FLAGS
        mov     eax,1
        shl     eax,cl
        test    ds:[esi].CURSORCACHE.dwCursorFlags,eax
        jz      Set1

        ; Clear out the SETTING bit for the particular cache slot
        not     eax
        and     ds:[esi].CURSORCACHE.dwCursorFlags, eax
        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot

        ; Call the hw specific code to set the cursor pattern into vidmem
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        lea     eax,[edi].CURSORDESCEX.wHotX

        push    pHWCrtcCXOffset
        push    ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        push    eax
        call    HW_CursorSet
        mov     ds:[edi].CURSORDESCEX.ExtraData.dwCursorType,eax

Set1:
        ; Handle cursor selection second
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_SELECT
        jz      Select1

        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        lea     edx,[edi].CURSORDESCEX.wHotX

        push    pHWCrtcCXOffset
        push    eax
        push    ds:[edi].CURSORDESCEX.ExtraData.dwCursorType
        push    edx
        call    HW_CursorSelect
        and     ds:[esi].CURSORCACHE.dwCursorFlags,NOT CURSOR_SELECT

Select1:
        ; Handle cursor moves last
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_MOVE
        jz      Move1

        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        push    pGNCrtcCXOffset
        push    word ptr ds:[esi].CURSORCACHE.wCursorX
        push    word ptr ds:[esi].CURSORCACHE.wCursorY
        call    GN_CheckPanAndMoveCursor

        and     ds:[esi].CURSORCACHE.dwCursorFlags,NOT CURSOR_MOVE

Move1:
        push    pGNCrtcCXOffset
        pushd   1
        pushd   0
        call    GN_TurnCursorOffOrOn

        ; turn off the blocking semaphore
        and     ds:[esi].CURSORCACHE.dwCursorFlags,NOT CURSOR_SEMAPHORE

BlockedSemaphore:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_MoveCursor
;
; Purpose:      This function is the MoveCursor display driver entry point.
;               This routine may be interrupt time -- be sure to preserve
;               the registers appropriately.
;
; Arguments:    wX, wY          coords of new cursor location
;
;==============================================================================
DECPROC GENERIC_MoveCursor, PASCAL, FRAME, FAR16, LOGOFF
PARMW   wX
PARMW   wY
LOCALD  ppGNCrtcCXOffset
LOCALD  dwCRTCCount
LOCALD  PhysicalXRes
LOCALD  PhysicalYRes
LOCALD  NewScanStart
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        pushf

        ; Load up our context
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        mov     dwCRTCCount,0
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ppGNCrtcCXOffset,eax

        ; If this CRTC is not a NULL context ...
LoopCRTC:
        mov     eax,ppGNCrtcCXOffset
        mov     edi,ds:[eax]
        or      edi,edi
        je      NextCrtc

        push    edi
        push    word ptr wX
        push    word ptr wY
        call    GN_CheckPanAndMoveCursor

NextCrtc:
        ; Go to the next CRTC
        add     ppGNCrtcCXOffset,4
        inc     dwCRTCCount
        mov     esi,cs:[CSpGNLogicalDevice]
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

done:
        popf
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckPanAndMoveCursor
;
; Purpose:      This function checks if the PhysicalViewport needs to pan
;               and updates its coordinates in the GNCRTCCX if so. This
;               function then figures out the physical postion of the
;               cursor relative to the virtual desktop.
;
; Arguments:    pGNCrtcCXOffset GNCRTCCX ptr
;               wX, wY          coords of new cursor location
;
;==============================================================================
DECPROC GN_CheckPanAndMoveCursor, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pGNCrtcCXOffset
PARMW   wX
PARMW   wY
LOCALD  dwCRTCCount
LOCALD  PhysicalXRes
LOCALD  PhysicalYRes
LOCALD  NewScanStart
OPENPROC
        PUSHR   esi,edi

        ; Call the DIBENG first
        push    dword ptr wY
        push    cs:[CSlp16LogDevice]
        call    DIB_MoveCursorExt

        mov     edi,pGNCrtcCXOffset
        mov     esi,cs:[CSpGNLogicalDevice]

        ; If the cursor has not been enabled, then we are done
        mov     ebx,ds:[edi].GNCRTCCX.pCursorCache
        or      ebx,ebx
        je      done

        cmp     ds:[edi].GNCRTCCX.dwPanAndScanEnabled,0
        je      skip_pan

        mov     NewScanStart,0
        sub     edx,edx

        ; Check to make sure the cusor coordinates are inside the
        ; virtual desktop window.
        mov     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        cmp     ax,wX
        jge     @F
        mov     dx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        cmp     ax,wY
        jl      skip_pan

@@:
        ; Calculate the physical X and Y of the ViewPort.
        mov     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight
        sub     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft
        mov     PhysicalXRes,eax
        mov     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom
        sub     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop
        mov     PhysicalYRes,eax

        mov     dx,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     eax,PhysicalXRes
        cmp     edx,eax
        jne     check_XLeft
        
        mov     dx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     eax,PhysicalYRes
        cmp     edx,eax
        jne     check_YTop
        jmp     skip_pan

check_XLeft:
        movzx   eax,wX
        cmp     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        jle     @F
        mov     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
@@:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft
        jge     check_XRight
        
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        mov     edx,PhysicalXRes
        add     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,edx
        mov     NewScanStart,1
        jmp     check_YTop

check_XRight:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight
        jle     check_YTop

        inc     eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        mov     edx,PhysicalXRes
        sub     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,edx
        mov     NewScanStart,1

check_YTop:
        movzx   eax,wY
        cmp     ax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        jle     @F
        mov     ax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
@@:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop
        jge     check_YBottom
        
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax
        mov     edx,PhysicalYRes
        add     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,edx
        mov     NewScanStart,1
        jmp     set_scanline_start

check_YBottom:
        cmp     eax,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom
        jle     set_scanline_start

        inc     eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,eax
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax
        mov     edx,PhysicalYRes
        sub     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,edx
        mov     NewScanStart,1

set_scanline_start:
        cmp     NewScanStart,1
        jne     skip_pan

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     skip_pan

        push    edi
        call    GN_SetPanRectangle
        
skip_pan:

        ; Save the coords for later
        mov     ebx,ds:[edi].GNCRTCCX.pCursorCache
        mov     eax,dword ptr wY
        ror     eax,10H
        mov     dword ptr ds:[ebx].CURSORCACHE.wCursorX,eax

        ; Is this a hardware or software cursor
        ; For software cursors, we don't have to enumerate the
        ; CRTCs for Clone Mode since a software cursor is embedded
        ; in the frame buffer. Writing it once will have it show
        ; up on all cloned monitors.
        mov     ebx,ds:[edi].GNCRTCCX.pCursorCache
        test    ds:[ebx].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        jnz     done

        ; Since this is a hardware cursor, we need to subtract the position
        ; of the topleft corner from the cursor position of the virtual
        ; desktop in order to get the cursor position relative to the
        ; physical desktop.
        mov     edx,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop
        shl     edx,10h
        sub     eax,edx
        mov     edx,ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft
        sub     ax,dx
        
        ; We need the actual CURSORDESC for the selected cursor
        ; since we need to know its hot spot
        mov     ecx,ds:[ebx].CURSORCACHE.dwSelectedCacheSlot
        imul    ecx,SIZE CURSORDESCEX
        lea     edx,[ebx + SIZE CURSORCACHE][ecx]

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     done

        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        push    eax
        push    dword ptr ds:[edx].CURSORDESCEX.wHotX
        call    HW_CursorMove

done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_CheckCursor
;
; Purpose:      This function is the CheckCursor display driver entry point.
;               This routine may be interrupt time -- be sure to preserve
;               the registers appropriately.
;
;==============================================================================
DECPROC GENERIC_CheckCursor, PASCAL, FRAME, FAR16, LOGOFF
LOCALD  ppGNCrtcCXOffset
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        pushf

        ; Just in case the driver is deinitted but we still get called
        cmp     cs:[CSpGNLogicalDevice],0
        je      Done

        ;!!!!!! FIGURE OUT WHERE IS THE CRITICAL INTERVAL !!!!!!
        sub     eax,eax
        mov     ax,cs:[wFlatDataSel]
        lar     edx,eax
        jnz     Done
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     Done
        mov     ds,ax
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Always call the DIBENGINE CheckCursor just in case
        push    cs:[CSlp16LogDevice]
        call    DIB_CheckCursorExt

        ; Prevent H/W access when in DOS FS or PowerDown mode
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     Done

        ; This is used as a time base for a few things in the driver
        inc     ds:[esi].GNLOGDEVCX.dwCheckCursorCount
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        inc     ds:[eax].GNBOARDCX.dwCheckCursorTicksSinceSecondDriverLoaded

        ; Deal with Windows bug doing repaint request processing
        call    GN_CheckUserRepaint

        ; Set up to enumerate all CRTC attached to this logical device
        mov     dwCRTCCount,0
        lea     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ppGNCrtcCXOffset,eax

        ; If this CRTC is not a NULL context ...
LoopCRTC:
        mov     eax,ppGNCrtcCXOffset
        mov     edi,ds:[eax]
        or      edi,edi
        je      NextCrtc

        ; If the cursor has not been enabled, then we are done
        mov     esi,ds:[edi].GNCRTCCX.pCursorCache
        or      esi,esi
        je      NextCrtc

        ; If the cursor is NULL, then we're done
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        jnz     NextCrtc

        ; If the cursor is software, then we're done
        test    ds:[esi].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        jnz     NextCrtc

        ; If the cursor has no action to take then we are done
        test    ds:[esi].CURSORCACHE.dwCursorFlags,(((1 SHL MAX_CACHEABLE_CURSORS) - 1) SHL NUM_CURSOR_FLAGS) OR CURSOR_MOVE OR CURSOR_SELECT
        jz      NextCrtc

        push    edi
        call    GN_CursorAction

NextCrtc:
        ; Go to the next CRTC
        add     ppGNCrtcCXOffset,4
        inc     dwCRTCCount
        mov     esi,cs:[CSpGNLogicalDevice]
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      LoopCRTC

Done:
        popf
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_TurnCursorOffOrOn
;
; Purpose:      This function turns off the cursor. If the cursor is
;               software, this routine do nothing.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               dwZeroForOffOneForOn    Just what it says
;               dwMoveCursor            if this parameter s non-0, then the
;                                       cursor position is updated as well
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_TurnCursorOffOrOn, PASCAL, FRAME, FAR32, LOGOFF
PARMD   pGNCrtcCXOffset
PARMD   dwZeroForOffOneForOn
PARMD   dwMoveCursor
OPENPROC
        PUSHR   esi,edi

        mov     esi,pGNCrtcCXOffset
        mov     edi,ds:[esi].GNCRTCCX.pCursorCache
        or      edi,edi
        je      Done

        ; Is mouse trails active?
        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_HAS_TRAILS OR CURSOR_IS_SOFTWARE
        jnz     Done

        cmp     dwZeroForOffOneForOn,0
        je      HwOff

        ; Are we supposed to move the cursor?
        cmp     dwMoveCursor,0
        je      @F
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dword ptr ds:[edi].CURSORCACHE.wCursorX
        pushd   0
        call    HW_CursorMove

@@:
        ; Don't turn the cursor on if it is NULL ...
        test    ds:[edi].CURSORCACHE.dwCursorFlags,CURSOR_IS_NULL
        jnz     Done

        ; Turn the cursor back on
        push    esi
        call    GN_CursorAction

HwOff:
        ; Turn off/on the hardware cursor
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        pushd   dwZeroForOffOneForOn
        call    HW_CursorEnable

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResetSelectedCursor
;
; Purpose:      This function takes the currently selected cursor
;               and recalls SetCursor with the pattern. We need
;               this for times when there is a modeset or whatever
;               and the cursor gets turned off and marked as NULL,
;               but the system does not call SetCursor to turn it
;               back on.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ResetSelectedCursor, PASCAL, FRAME, FAR32, LOGOFF
PARMD   pGNCrtcCXOffset
LOCALD  lpResetCursorShape
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset
        mov     esi,ds:[edi].GNCRTCCX.pCursorCache
        mov     eax,ds:[esi].CURSORCACHE.dwSelectedCacheSlot

        ; Call the hw specific code to set the cursor pattern into vidmem
        imul    ecx,eax,SIZE CURSORDESCEX
        lea     edi,[esi + SIZE CURSORCACHE][ecx]
        lea     ebx,[edi].CURSORDESCEX.wHotX

        mov     eax,1
        mov     ecx,SIZE CURSORDESC + (CURSOR_WIDTH * CURSOR_HEIGHT * 4)
        call    GN_AllocSelectorAndMapIt
        shl     eax,10H
        mov     lpResetCursorShape,eax

        push    lpResetCursorShape
        CALLFAR16 GENERIC_SetCursor

        mov     eax,lpResetCursorShape
        shr     eax,10H
        call    GN_UnmapAndFreeSelector

        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDIBBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibblt.asm
;
; Purpose:      This file holds the DibBlt display driver entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_DibBlt
;
; Purpose:      This function is the DibBlt display driver entry point.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_DibBlt, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   iStart
PARMW   cScans
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpDrawMode
PARMD   lpTranslate

LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwDibBitsOffset
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwDibPitch
LOCALD  dwPhysColor
OPENPROC
        PUSHR   ds,esi,edi

        ; Load up the DstDev and the DIB Header for dispatching
        sub     eax,eax
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0
        mov     ds,word ptr lpDIBInfo+2
        movzx   edi,word ptr lpDIBInfo+0

        ; not handling negative cScans case
        cmp     ax,cScans
        jge     GN_DibBltPunt

        ; The case where lpDIBBits is NULL is a sizing request -- punt it
        cmp     eax,lpDIBBits
        je      GN_DibBltPuntNoWait

IF      (DIB_8BPP_ACCEL NE 0)
        ; If the dst is 8bpp and src is mono, then punt it.
        cmp     gs:[esi].DIBENGINE.deBitsPixel,8
        jne     @F
        cmp     ds:[edi].BitmapInfoHeader.biBitCount,1
        je      GN_DibBltPunt
        ; It we're reading from 8bpp screen, then punt it. 
        cmp     fGet,0
        jne     GN_DibBltPunt
@@:
ELSE
        ; If the dst is 8bpp, then punt it.
        cmp     gs:[esi].DIBENGINE.deBitsPixel,8
        je      GN_DibBltPunt
ENDIF

        ; We only do RGB DIBs (No Compression)
        cmp     ds:[edi].BitmapInfoHeader.biCompression,BI_RGB
        jne     GN_DibBltPunt

        ; If the bitmap is not in VRAM, then punt it.
        cmp     ax,gs:[esi].DIBENGINE.deType
        je      GN_DibBltPuntNoWait

        test    gs:[esi].DIBENGINE.deFlags,VRAM
        jz      GN_DibBltPuntNoWait

        ; Clip the call now since we are going to handle it
        call    GN_DibBltClip
        or      eax,eax
        je      GN_DibBltSuccess

        ; Syncronize with other drawing components
        mov     fs,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     fs:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_DibBltPunt

        ; Is this a DIB->Bitmap or Bitmap->DIB conversion
        cmp     fGet,0
        jne     GN_DibBltGet
        cmp     ds:[edi].BitmapInfoHeader.biBitCount,1
        jne     GN_DibBltSetColor
        jmp     GN_DibBltSetMono

GENERIC_DibBlt  ENDP


;==============================================================================
;
; Functions:    DibBlt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of DibBlt. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_DibBltPunt
GN_DibBltPunt     PROC    NEAR
        ; If the bitmap is in VRAM, then we must wait for idle
        ; because the DIBENG will not.
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0
        cmp     gs:[esi].DIBENGINE.deType,0
        je      GN_DibBltPuntNoWait
        test    gs:[esi].DIBENGINE.deFlags,VRAM OR OFFSCREEN
        jz      GN_DibBltPuntNoWait
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    GENERIC_BeginAccess
        .errnz  $ - OFFSET GN_DibBltPuntNoWait
GN_DibBltPunt   ENDP

PUBLIC  GN_DibBltPuntNoWait
GN_DibBltPuntNoWait PROC    NEAR
        ; The DIBENG DibBltExt takes an extra parameter which indicates
        ; whether we are running in a palettized mode right now.
        test    gs:[esi].DIBENGINEHDR.deFlags,PALETTIZED
        setne   al
        movzx   eax,al
        POPR    ds,esi,edi
        STOPPROC
        pop     ecx
        push    ax
        push    ecx
PLABEL  Punt_DibBlt
        jmp     DIB_DibBltExt
GN_DibBltPuntNoWait ENDP


PUBLIC  GN_DibBltSuccess
GN_DibBltSuccess  PROC    NEAR
        movzx   eax,cScans
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1AH
GN_DibBltSuccess  ENDP


;==============================================================================
;
; Function:     GN_DibBltSetMono
;
; Purpose:      This function is jumped to from the DibBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;               The operation is from a DIB to a Bitmap and the DIB is mono.
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the DibBlt ending routines.
;
;==============================================================================
PUBLIC  GN_DibBltSetMono
GN_DibBltSetMono        PROC    NEAR

        ; We can handle this as a mono transfer
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        sub     ecx,ecx
        push    eax
        push    dwDibBitsOffset
        push    dwDibPitch
        push    ecx
        push    ecx
        push    dwExtX
        push    dwExtY

        lea     esi,dwPhysColor
        ror     esi,10H
        mov     si,ss
        ror     esi,10H
        push    lpDstDev
        mov     eax,dword ptr ds:[edi].BitmapInfo.bmiColors[0]
        bswap   eax
        ror     eax,8
        push    eax
        push    esi
        call    GENERIC_ColorInfo
        push    dwPhysColor

        cmp     ds:[edi].BitmapInfoHeader.biClrUsed,1
        je      @F
        push    lpDstDev
        mov     eax,dword ptr ds:[edi].BitmapInfo.bmiColors[4]
        bswap   eax
        ror     eax,8
        push    eax
        push    esi
        call    GENERIC_ColorInfo
@@:     push    dwPhysColor

        sub     eax,eax
        mov     edx,07FFFH
        pushd   0CC0000H                        ; Rop3
        push    eax                             ; lpBrush
        push    lpDrawMode                      ; lpDrawmode
        push    edx                             ; scans left in start seg
        push    edx                             ; scans per seg
        push    eax                             ; fill bytes

        ; Load Device Context Selector
        mov     ds,cs:[wFlatDataSel]

        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        je      GN_DibBltPunt
        jmp     GN_DibBltSuccess

GN_DibBltSetMono        ENDP


;==============================================================================
;
; Function:     GN_DibBltSetColor
;
; Purpose:      This function is jumped to from the DibBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the color transfer.
;               The operation is from a DIB to a Bitmap and the DIB is color.
;               (this could be a 4, 8, 15, 16, 24, or 32bpp DIB.)
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the DibBlt ending routines.
;
;==============================================================================
PUBLIC  GN_DibBltSetColor
GN_DibBltSetColor       PROC    NEAR

        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   ecx,ds:[edi].BitmapInfoHeader.biBitCount
        cmp     ecx,10H
        jne     @F
        mov     ecx,0FH
        cmp     ds:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_DibBltPunt
        inc     ecx
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_DibBltPunt
@@:
        ; For this conversion, we use color transfer
        mov     es,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    es:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr gs:[esi].DIBENGINE.deBits
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   edx,word ptr lpDIBBits+2
        sub     eax,eax
        push    edx
        push    dwDibBitsOffset
        push    ecx
        push    dwDibPitch
        push    eax                             ; dwSrcLeft
        push    eax                             ; dwSrcTop
        push    dwExtX
        push    dwExtY

        pushd   0CC0000H
        push    eax                             ; lpBrush
        push    lpDrawMode                      ; lpDrawMode
        pushd   4                               ; dwSizeColorTableEntry

        ; If the src is > 8bpp, then there is no color table.
        ; If there is a color table, compute the number of entries.
        sub     ebx,ebx
        cmp     cl,8
        jbe     IsColorTable
        cmp     gs:[esi].DIBENGINEHDR.bRealBpp,8
        jne     @F
        mov     ebx,lpTranslate
        jmp     @F

IsColorTable:
        mov     bx,ds
        shl     ebx,10H
        lea     bx,[di].BitmapInfo.bmiColors
        mov     edx,ds:[edi].BitmapInfoHeader.biClrUsed
        mov     eax,1
        shl     eax,cl
        or      edx,edx
        je      @F
        cmp     eax,edx
        jc      @F
        mov     eax,edx
@@:
        push    eax                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        sub     eax,eax
        push    eax

        ; Load Device Context Selector
        mov     ds,cs:[wFlatDataSel]

        call    HW_BitBltSrcColorDstVram
        or      eax,eax
        je      GN_DibBltPunt
        jmp     GN_DibBltSuccess

GN_DibBltSetColor       ENDP


;==============================================================================
;
; Function:     GN_DibBltGet
;
; Purpose:      This function is jumped to from the DibBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the DMA back transfer
;               interleaved with the copy into the correct system
;               memory bitmap.
;               The operation is from a Bitmap to a DIB.
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done
;               it should jump to one of the DibBlt ending routines.
;
;==============================================================================
PUBLIC  GN_DibBltGet
GN_DibBltGet    PROC    NEAR

        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   eax,ds:[edi].BitmapInfoHeader.biBitCount
        cmp     eax,10H
        jne     @F
        mov     eax,0FH
        cmp     ds:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_DibBltPunt
        inc     eax
        cmp     ds:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_DibBltPunt
@@:
        ; Use the GetVramBitmap to interleave DMA and conversion
        push    cs:[CSpGNLogicalDevice]
        sub     edx,edx
        push    edx
        push    lpDIBInfo
        movzx   ecx,word ptr lpDIBBits+2
        push    ecx
        push    dwDibBitsOffset
        push    eax
        push    dwDibPitch
        push    edx             ; dwDibLeft
        push    edx             ; dwDibTop

        push    lpDstDev        ; It's called dstdev but it is really the src
        movzx   eax,word ptr gs:[esi].DIBENGINE.deBits+4
        push    eax
        push    gs:[esi].DIBENGINEHDR.deBitsOffset
        movzx   eax,gs:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    gs:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        push    dwExtX
        push    dwExtY
        pushd   0CC0000H
        push    edx             ; lpBrush
        push    lpDrawMode      ; lpDrawMode
        push    edx             ; pfnCopyXlat :Let called func figure it out

        ; Load Device Context Selector
        mov     ds,cs:[wFlatDataSel]

        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        je      GN_DibBltPunt
        jmp     GN_DibBltSuccess

GN_DibBltGet    ENDP


;==============================================================================
;
; Function:     GN_DibBltClip
;
; Purpose:      This function clips the DIB and Bitmap for DibBlt.
;
; Arguments:    DibBlt Display Driver Stack Frame
;               ds:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               gs:esi  lpDstDev
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     ds,edi,gs
;==============================================================================
PUBLIC  GN_DibBltClip
GN_DibBltClip   PROC    NEAR

        ; If there is nothing to do, then report all clipped
        movsx   ecx,cScans
        or      ecx,ecx
        je      AllClipped

        ; Ext X = minimum (Bitmap Width, DIB width)
        movsx   eax,gs:[esi].DIBENGINE.deWidth
        mov     edx,ds:[edi].BitmapInfoHeader.biWidth
        cmp     eax,edx
        jl      @F
        mov     eax,edx
@@:     mov     dwExtX,eax

        ; Compute the unsigned DIB pitch. We will make it signed to
        ; indicate DIB orientation later when we adjust the bits ptr.
        movzx   eax,ds:[edi].BitmapInfoHeader.biBitCount
        mov     ecx,ds:[edi].BitmapInfoHeader.biWidth
        imul    eax,ecx
        add     eax,31
        and     eax,NOT 31
        shr     eax,3
        mov     dwDibPitch,eax
        movzx   edx,word ptr lpDIBBits
        mov     dwDibBitsOffset,edx

        ; Based upon the sign of the DIB height, adjust for DIB orientation.
        mov     edx,ds:[edi].BitmapInfoHeader.biHeight
        or      edx,edx
        js      @F
        movzx   ecx,cScans
        dec     ecx
        imul    ecx,eax
        add     dwDibBitsOffset,ecx
        neg     eax
        mov     dwDibPitch,eax
        neg     edx
@@:     neg     edx

        ; The only thing left is Bitmap top and bottom coords
        movsx   ebx,iStart
        movsx   ecx,cScans
        sub     edx,ebx
        sub     edx,ecx
        mov     dwBmpTop,edx
        sub     edx,edx
        mov     dwExtY,ecx
        mov     dwBmpLeft,edx
        mov     eax,1
        ret

AllClipped:
        sub     eax,eax
        ret

GN_DibBltClip   ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCRTC.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncrtc.asm
;
; Purpose:      This file holds init routines for GNCRTCCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc
include minivdd.inc
.listall

IF      (MAX_MODEOUT_SIZE LT (SIZE MODEOUT))
echo MAX_MODEOUT_SIZE less than size of MODEOUT structure
.err
ENDIF
IF      (MAX_DISPDATA_SIZE LT (SIZE DISPDATA))
echo MAX_DISPDATA_SIZE less than size of DISPDATA structure
.err
ENDIF
IF      (MAX_MODEINFO_SIZE LT SIZE MODEINFO)
echo MAX_MODEINFO_SIZE less than size of MODEINFO structure
.err
ENDIF

OPENSEG  _DATA, USE16, DATA
PUBLIC  szPowerUpSubkey
szPowerUpSubkey         DB      "PowerUpFlags",0
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_CreateCrtcContext
;
; Purpose:      This routine allocates memory for and initializes
;               an array of GNCRTCCX structure.
;
; Arguments:
;               ds                      Selector for the Context data
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwIsBootCrtc            TRUE if this is the CRTC we
;                                       are booting windows on. In a
;                                       Clone situation, this is only
;                                       the first of the clone monitors
;                                       that are the boot set.
;
; Returns:      eax     0       failure
;                       else    Success and eax is a GNCRTCCX ptr
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateCrtcContext, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwLogDeviceInstance
PARMD   dwPhysDeviceInstance
PARMD   dwIsBootCrtc
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        ; Allocate memory for the GNCRTCCX
        pushd   SIZE GNCRTCCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; We are initting.
        mov     ds:[esi].GNCRTCCX.dwInitting,1
        mov     eax,dwLogDeviceInstance
        mov     ds:[esi].GNCRTCCX.dwLogicalDeviceInstance,eax
        mov     eax,dwPhysDeviceInstance
        mov     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,eax
        mov     eax,dwIsBootCrtc
        mov     ds:[esi].GNCRTCCX.dwBootCrtc,eax

        ; Save this
        mov     eax,pGNBoardCXOffset
        mov     ds:[esi].GNCRTCCX.pGNBoardCX,eax

        ; Crate the HW logical device next
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_CreateCrtcContext
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].GNCRTCCX.pHWCrtcCX,eax

        ; Build a 16:16 ptr to the monitor path. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.szLocalMonitorBasePath
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpLocalMonitorBasePath,eax

        ; Build a 16:16 ptr to the DISPDATA. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sCrtcModeOut
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpCrtcModeOut,eax

        ; Build a 16:16 ptr to the DISPDATA. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sNvmodeDispData
        add     ebx,eax
        mov     eax,1
        mov     ecx,100H
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpNvmodeDispData,eax
        lea     edi,[esi].GNCRTCCX.sNvmodeDispData

        push    ds:[esi].GNCRTCCX.pGNBoardCX
        call    GN_GetBoardRegistryPath
        mov     ds:[edi].DISPDATA.lpBoardRegistryData,eax
        mov     ds:[esi].GNCRTCCX.lpBoardRegistryData,eax

        ; The base monitor registry path
        mov     eax,ds:[esi].GNCRTCCX.lpLocalMonitorBasePath
        mov     ds:[edi].DISPDATA.lpMonitorRegistryData,eax

        ; Get the PCI device ID
        push    ds:[esi].GNCRTCCX.pGNBoardCX
        call    GN_GetPciDeviceID
        mov     ds:[edi].DISPDATA.dwDeviceID,eax

        ; We don't use this anymore since we validate the physical
        ; and virtual modes independently. I'd like to get rid of it,
        ; but for now we just set the amount of memory to a really
        ; big amount so that this will not be a limitation on the mode.
        mov     eax,10000000H
        mov     ds:[edi].DISPDATA.dwVideoMemoryInBytes,eax

        ; Get the maximum DFP scaling
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_GetMaxDfpScaledXRes
        mov     ds:[edi].DISPDATA.dwMaxDfpScaledXResInPixels,eax

        ; Fill out address of GN_GetDisplayPitch so MODESET DLL can
        ; call back to display driver to get the pitch.
        mov     ax,SEG GN_Far16GetModeSize
        shl     eax,10h
        mov     ecx,OFFSET GN_Far16GetModeSize
        mov     ax,cx
        mov     ds:[edi].DISPDATA.lpfnGetModeSize,eax
        mov     ecx,OFFSET GN_Far16IsModeAcceptedByDriver
        mov     ax,cx
        mov     ds:[edi].DISPDATA.lpfnIsModeAcceptedByDriver,eax
        mov     ds:[edi].DISPDATA.dwContext1,ds
        mov     ds:[edi].DISPDATA.dwContext2,esi

        ; Fill the maximum resolution for TV
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_GetMaxTVOutResolution
        mov     ds:[edi].DISPDATA.dwMaxTVOutResolution,eax
        mov     ds:[edi].DISPDATA.dwTVEncoderType,ebx

        ; Build a 16:16 ptr to the Edid Buffer. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sEdidBuffer
        add     ebx,eax
        mov     eax,1
        mov     ecx,MAX_EDID_BUFFER_SIZE
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpEdidBuffer,eax
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0

        ; Build a 16:16 ptr to the sCrtcModeInfo.MIDevData
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        lea     ebx,[ebx].MODEINFO.MIDevData
        add     ebx,eax
        mov     eax,1
        mov     ecx,MAX_EDID_BUFFER_SIZE
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[edi].DISPDATA.lpDevData,eax

        ; Get the desired display device
        push    esi
        call    GN_GetDisplayDevice

        ; This forces an EDID read also for cases where we read more
        ; frequently than just at boot time.
        mov     ds:[esi].GNCRTCCX.dwTicksSinceLastEdidRead,0

        ; Ask the hardware how many bits per color gun
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_BitsPerColorGun
        mov     ds:[esi].GNCRTCCX.dwBitsPerColorChannel,eax

        ; Ask the Hardware how many cursors it can cache
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        pushd   MAX_CACHEABLE_CURSORS
        call    HW_SizeCursorCache
        mov     ds:[esi].GNCRTCCX.dwMaxCacheableCursors,eax

        ; We force the first modeset after a GNCRTCCX creation
        ; to be a "display device change" modeset which means
        ; that the .inf status will be ignored -- the initial
        ; inf status that Windows gives us is unreliable.
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1

        ; Now we can create it
        push    esi
        call    GN_CreateCursorCache
        or      eax,eax
        je      DoneIt

        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache

        ; Build a 16:16 ptr to the sCrtcModeInfo. We need to be able
        ; to pass these into the modeset dll which is 16bit C code.
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        add     ebx,eax
        mov     eax,1
        mov     ecx,SIZE MODEINFO
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].GNCRTCCX.lpCrtcModeInfo,eax

        ; Initialize the palette table
        ; The first ten entries are system colors
        mov     edi,OFFSET SystemColorTableFirst10
        sub     ebx,ebx
@@:     mov     eax,cs:[edi]
        add     edi,4
        mov     ds:[esi][ebx * 4].GNCRTCCX.dwPaletteTable,eax
        inc     ebx
        cmp     ebx,10
        jc      @B

        ; The middle 236 are just set to a default value
        mov     edi,OFFSET SystemColorTableDefault
        mov     eax,cs:[edi]
@@:     mov     ds:[esi][ebx * 4].GNCRTCCX.dwPaletteTable,eax
        inc     ebx
        cmp     ebx,246
        jc      @B

        ; The last ten entries are system colors also
        mov     edi,OFFSET SystemColorTableLast10
@@:     mov     eax,cs:[edi]
        add     edi,4
        mov     ds:[esi][ebx * 4].GNCRTCCX.dwPaletteTable,eax
        inc     ebx
        cmp     ebx,256
        jc      @B

        ; Create an identity gamma table.
        mov     ebx,0FFH
        mov     eax,0FFFFFFH
@@:     mov     ds:[esi][ebx * 4].GNCRTCCX.dwGammaTable,eax
        sub     eax,10101H
        dec     ebx
        jge     @B

        ; Return Success
        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the GNBOARDCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; GN_DestroyBoardContext can clean up partial inits
        push    esi
        call    GN_DestroyCrtcContext
        sub     eax,eax

ExitIt:

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyCrtcContext
;
; Purpose:      This routine destroys a GNCRTCCX.
;               You do not need to free its memory. Just free any
;               resources inside the structure.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset Offset to the crtc context data to destroy
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyCrtcContext, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        ; Turn off the cursor.
        push    pGNCrtcCXOffset
        pushd   0
        pushd   0
        call    GN_TurnCursorOffOrOn

        cmp     ds:[esi].GNCRTCCX.pCursorCache,0
        je      @F

        ; Now we can destroy the cursor cache.
        push    pGNCrtcCXOffset
        call    GN_DestroyCursorCache
@@:
        ; Free the 16:16 ptr to the lpCrtcModeInfo buffer
        mov     eax,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        or      eax,eax
        je      @F
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpCrtcModeInfo,0
@@:


        ; Free the 16:16 ptr to the edid buffer
        mov     eax,ds:[esi].GNCRTCCX.lpEdidBuffer
        or      eax,eax
        je      @F
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpEdidBuffer,0
@@:

        ; Free the 16:16 ptr to the lpNvmodeDispData buffer
        mov     eax,ds:[esi].GNCRTCCX.lpNvmodeDispData
        or      eax,eax
        je      DoneDispData

        push    eax
        CALLFAR16IND lpfnFreeMasterLists,es,bx

        ; Free the 16:16 ptr lpDevData in the NvModeDispData struct
        lea     ebx,[esi].GNCRTCCX.sNvmodeDispData
        mov     eax,ds:[ebx].DISPDATA.lpDevData
        or      eax,eax
        je      @F
        shr     eax,10H
        mov     ds:[ebx].DISPDATA.lpDevData,0
        call    GN_UnmapAndFreeSelector
@@:
        mov     eax,ds:[esi].GNCRTCCX.lpNvmodeDispData
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpNvmodeDispData,0
DoneDispData:

        ; Free the 16:16 ptr to the lpNvmodeDispData buffer
        mov     eax,ds:[esi].GNCRTCCX.lpCrtcModeOut
        or      eax,eax
        je      DoneModeOut
        mov     eax,ds:[esi].GNCRTCCX.lpCrtcModeOut
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpCrtcModeOut,0
DoneModeOut:

        ; Free the 16:16 ptr to the lpLocalMonitorBasePath buffer
        mov     eax,ds:[esi].GNCRTCCX.lpLocalMonitorBasePath
        or      eax,eax
        je      @F
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNCRTCCX.lpLocalMonitorBasePath,0
@@:
        cmp     ds:[esi].GNCRTCCX.pHWCrtcCX,0
        je      @F
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        call    HW_DestroyCrtcContext
        mov     ds:[esi].GNCRTCCX.pHWCrtcCX,0

@@:
        ; Free the memory for the object.
        push    esi
        call    HW_FreeFlatMemory

        ; Indicate that we destroyed something.
        mov     eax,1
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetLargestEdidMode
;
; Purpose:      This function gets the largest EDI mode for the
;               current device type and tv format if they have
;               an EDID. If not, the mode passed in is unchanged.
;
; Arguments:
;               ds              CX Sel
;               pGNCrtcCXOffset GNCRTCCX ptr
;               lpModeInfo      MODEINFO ptr
;
; Returns:      eax     FALSE then there was no EDID mode
;                       TRUE lpModeInfo was overridden with the largest
;                               EDID mode.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetLargestEdidMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpModeInfo
OPENPROC
        mov     ecx,pGNCrtcCXOffset
        push    ds:[ecx].GNCRTCCX.lpEdidBuffer
        push    ds:[ecx].GNCRTCCX.dwEdidSize
        push    lpModeInfo
        CALLFAR16IND lpfnGetLargestEdidMode,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetRefreshRateForDesktop
;
; Purpose:      This function gets the refresh rate for the desktop.
;               A refresh rate is really a CRTC thing, not a desktop
;               thing, but this is a Windows messiness. They have
;               a refresh rate affiliated with the desktop because
;               they don't understand about virtual desktops.
;
; Arguments:
;               ds              CX Sel
;               pGNCrtcCXOffset GNCRTCCX ptr
;               lpModeInfo      MODEINFO ptr
;
; Returns:      lpModeInfo->dwRefreshRate was filled in with some
;               refresh rate.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetRefreshRateForDesktop, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpModeInfo
OPENPROC
        mov     ebx,pGNCrtcCXOffset
        mov     gs,word ptr lpModeInfo+2
        movzx   eax,word ptr lpModeInfo
        push    ds:[ebx].GNCRTCCX.lpNvmodeDispData
        lea     ecx,[ebx].GNCRTCCX.sCrtcModeInfo
        mov     ecx,ds:[ecx].MODEINFO.MIDevData
        mov     gs:[eax].MODEINFO.MIDevData,ecx
        push    lpModeInfo
        push    ds:[ebx].GNCRTCCX.lpEdidBuffer
        push    ds:[ebx].GNCRTCCX.dwEdidSize
        CALLFAR16IND lpfnGetRefreshRateForDesktop,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     GN_DoOddballStuffAtBoot
;
; Purpose:      This function does some things that need to be done
;               at boot that are pretty random. Here is the list.
;               1) Clear PowerUp flags in the registry so that
;                       the control panel will know if the system
;                       has been rebooted since the the last time
;                       the control panel was invoked.
;
; Arguments:
;               ds      CX Sel
;               esi     GNCRTCCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DoOddballStuffAtBoot, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        mov     ebx,pGNCrtcCXOffset
        lfs     bx,ds:[ebx].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpBoardRegistryData
        mov     ax,_DATA
        push    ax
        mov     ax,OFFSET szPowerUpSubkey
        push    ax
        CALLFAR16IND lpfnDeleteLocalRegEntry,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckAndMaybeReadEdid
;
; Purpose:      This function check to see if the EDID needs to be reread
;               and if so, then does the EDID read.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;
; Returns:      eax     0       then there was a problem reading the EDID.
;                       non-0   then there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CheckAndMaybeReadEdid, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
LOCALD  dwCurrentEdidSize
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Read the registry to determine if the EDID should be reread.
        ; If AX is returned as 1, then the registry key ForceEdidRead
        ; exists and is enabled.
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetEdidRegistryKey,es,ax
        movzx   eax,ax
        or      eax,eax
        je      DoneRead

OKToReadEdid:
        ; Even Now we still won't read the EDID if we have read it
        ; very recently. This prevents long delays on monitors with
        ; no EDID which take a while to timeout.
        cmp     ds:[esi].GNCRTCCX.dwTicksSinceLastEdidRead,MIN_TICKS_BEFORE_REREADING_EDID
        jc      DoneRead

MustReRead:
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        cmp     ds:[ebx].MODEINFO.MIDevData.cType,DEVTYPE_TV
        je      DoneRead
        
        ; OK, NOW we can read the EDID
        mov     ds:[esi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNCRTCCX.pHWCrtcCX

        ; JKTODO -- Need to be able to specify Device And Number
        ; For now, just device
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        push    ds:[ebx].MODEINFO.MIDevData
        lea     eax,[esi].GNCRTCCX.sEdidBuffer
        push    eax
        lea     eax,[esi].GNCRTCCX.dwEdidSize
        push    eax
        call    HW_ReadEdid

DoneRead:
        mov     eax,ds:[esi].GNCRTCCX.dwEdidSize
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_Far16GetModeSize
;
; Purpose:      This function returns the amount of memory taken up
;               by a given mode and the pitch for a gievn mode.
;               This function is called from 16bit C code. It must
;               lie within 64K of the start of a segment. We put it
;               in a 16Bit segment just to make things easier.
;
; Arguments:
;               dwContextData1  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the Context Selector.
;
;               dwContextData2  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the GNCRTCCX ptr.
;
;               dwXRes          X Resolution of mode to get size for
;               dwYRes          Y Resolution of mode to get size for
;               dwBpp           Color depth of mode to get size for
;               lpPitch         place to return pitch
;               lpSize          place to return total bytes needed for mode
;
; Returns:      TRUE
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_Far16GetModeSize, PASCAL, FRAME, FAR16
PARMD   dwContextData1
PARMD   dwContextData2
PARMD   dwXRes
PARMD   dwYRes
PARMD   dwBpp
PARMD   lpPitch
PARMD   lpSize
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,dwContextData1
        mov     ebx,dwContextData2
        mov     ebx,ds:[ebx].GNCRTCCX.pGNBoardCX

        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwXRes
        push    dwYRes
        push    dwBpp
        call    HW_GetModeDimensions

        lfs     si,lpPitch
        mov     fs:[si],eax
        lfs     si,lpSize
        mov     fs:[si],ebx

        mov     ax,1
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_Far16IsModeAcceptedByDriver
;
; Purpose:      This function gets called from the modeset dll
;               to allow the driver to veto or accept a mode.
;               Technically, you may also modify the output
;               timings, but this is discouraged and should
;               only be done in extreme cases.
;
; Arguments:
;               dwContextData1  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the Context Selector.
;
;               dwContextData2  This context data was supplied by the
;                               display driver to the modeset dll.
;                               It ought to be the GNCRTCCX ptr.
;
;               lpDispData      LPDISPDATA ptr
;               lpModeOut       LPMODEOUT ptr
;               lpEdidBuffer    LPCHAR ptr to an edid buffer
;               dwEdidSize      ULONG size in bytes of edid (0 if no edid)
;
; Returns:      TRUE
;
; Preserve:     ds,esi,edi
;==============================================================================
CALL_LINKREG    MACRO   label1,linkreg
        LOCAL   quickret
        mov     linkreg,OFFSET quickret
        jmp     label1
quickret:
ENDM

DECPROC GN_Far16IsModeAcceptedByDriver, PASCAL, FRAME, FAR16
PARMD   dwContextData1
PARMD   dwContextData2
PARMD   lpDispData
PARMD   lpModeOut
PARMD   lpEdidBuffer
PARMD   dwEdidSize
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALS  aHWCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
LOCALD  dwDeviceCount
LOCALD  pTheHWCrtcCX
OPENPROC
        PUSHR   ds,esi,edi

        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        mov     ds,dwContextData1
        mov     esi,dwContextData2

        ; Just in case the HWCRTCCX has been locked by somebody
        ; else, we have to look a couple places for it.
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCXWhenLocked
@@:     mov     pTheHWCrtcCX,eax

        ; The paramter list we have to provide is the following:
        ; pHWCrtcCXOffset
        ; dwTotalWidth0
        ; dwVisibleWidth0
        ; dwTotalHeight0
        ; dwVisibleHeight0
        ; dwPixelDepth0
        ; dwPixelClock0
        ; dwRefreshRate0
        ; dwTotalWidth1
        ; dwVisibleWidth1
        ; dwTotalHeight1
        ; dwVisibleHeight1
        ; dwPixelDepth1
        ; dwPixelClock1
        ; dwRefreshRate1
        ;
        ; The 0 on the end means physical head 0 and the 1 means
        ; physical head 1. If you are only concerned with the mode
        ; on one of the two heads (i.e. the other head is not active)
        ; set dwTotalWidth for that head to 0.

        ; push the HWCRTCCX
        push    pTheHWCrtcCX

        push    ds:[esi].GNCRTCCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; See if the device we are testing is on head 0
        push    pTheHWCrtcCX
        call    HW_GetPhysicalCrtcIndex
        or      eax,eax
        je      UseNewParamsFirst

        ; If it is on head -1, we don't know!! It may not have
        ; been mapped yet. Unh! We will assume that it is the
        ; right one in this case, though.
        cmp     eax,-1
        je      UseNewParamsFirst

        ; We are on a non-0 legal head. Are there two devices?
        cmp     dwDeviceCount,1
        je      NullForFirst

TwoDevicesNewIsNotHead0:
        lfs     bx,lpGNCrtcCX
        mov     ecx,fs:[bx]
        mov     edx,fs:[bx + 4]
        cmp     ecx,esi
        jne     @F
        mov     ecx,edx
@@:
        push    ds
        pop     fs
        lea     ecx,[ecx].GNCRTCCX.sCrtcModeOut
        CALL_LINKREG  PushParams,edx

        sub     ecx,ecx
        lfs     cx,lpModeOut
        CALL_LINKREG  PushParams,edx
        jmp     DoTheCall

NullForFirst:
        ; Nulls for head 0, and head 1 must be the "new" one
        CALL_LINKREG    PushNulls,edx

        sub     ecx,ecx
        lfs     cx,lpModeOut
        CALL_LINKREG    PushParams,edx
        jmp     DoTheCall

UseNewParamsFirst:
        sub     ecx,ecx
        lfs     cx,lpModeOut
        CALL_LINKREG    PushParams,edx

        ; OK, now, are we even concerned with two displays?
        cmp     dwDeviceCount,1
        je      NullForSecond

        ; Find the paramters for the device that isn't "new"
        lfs     bx,lpGNCrtcCX
        mov     ecx,fs:[bx]
        mov     edx,fs:[bx + 4]
        cmp     ecx,esi
        je      GotSecondCrtcCX
        mov     edx,ecx
        jmp     GotSecondCrtcCX

NullForSecond:
        CALL_LINKREG    PushNulls,edx
        jmp     DoTheCall

GotSecondCrtcCX:
        ; edx = GNCRTCCX
        lea     ecx,[edx].GNCRTCCX.sCrtcModeOut
        push    ds
        pop     fs
        CALL_LINKREG    PushParams,edx
        jmp     DoTheCall

DoTheCall:
        call    HW_IsBandwidthOK
        jmp     Done

PushParams:
        movzx   eax,fs:[ecx].MODEOUT.wHTotal
        push    eax
        movzx   eax,fs:[ecx].MODEOUT.wXRes
        push    eax
        movzx   eax,fs:[ecx].MODEOUT.wVTotal
        push    eax
        movzx   eax,fs:[ecx].MODEOUT.wYRes
        push    eax
        mov     eax,fs:[ecx].MODEOUT.dwFormat
        shr     eax,16
        and     eax,3
        inc     eax
        cmp     eax,3
        jne     @F
        mov     eax,2
@@:     shl     eax,3
        push    eax
        push    fs:[ecx].MODEOUT.dwPixelClock
        movzx   eax,fs:[ecx].MODEOUT.wRefreshRate
        push    eax
        jmp     edx

PushNulls:
        sub     eax,eax
        push    eax
        push    eax
        push    eax
        push    eax
        push    eax
        push    eax
        push    eax
        jmp     edx

Done:
        POPR    ds,esi,edi
CLOSEPROC


ALIGN 4
SystemColorTableFirst10 LABEL   BYTE
;       blue,   green,  red,    flags
DB      000H,   000H,   000H,   000H
DB      000H,   000H,   080H,   000H
DB      000H,   080H,   000H,   000H
DB      000H,   080H,   080H,   000H
DB      080H,   000H,   000H,   000H
DB      080H,   000H,   080H,   000H
DB      080H,   080H,   000H,   000H
DB      0C0H,   0C0H,   0C0H,   MAPTOWHITE
DB      0C0H,   0DCH,   0C0H,   NONSTATIC+MAPTOWHITE
DB      0F0H,   0CAH,   0A6H,   NONSTATIC+MAPTOWHITE

SystemColorTableDefault LABEL   BYTE
;       blue,   green,  red,    flags
DB      000H,   000H,   000H,   NONSTATIC

SystemColorTableLast10  LABEL   BYTE
;       blue,   green,  red,    flags
DB      0F0H,   0FBH,   0FFH,   NONSTATIC+MAPTOWHITE
DB      0A4H,   0A0H,   0A0H,   NONSTATIC+MAPTOWHITE
DB      080H,   080H,   080H,   MAPTOWHITE
DB      000H,   000H,   0FFH,   000H
DB      000H,   0FFH,   000H,   MAPTOWHITE
DB      000H,   0FFH,   0FFH,   MAPTOWHITE
DB      0FFH,   000H,   000H,   000H
DB      0FFH,   000H,   0FFH,   000H
DB      0FFH,   0FFH,   000H,   MAPTOWHITE
DB      0FFH,   0FFH,   0FFH,   MAPTOWHITE

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gndibs.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibs.asm
;
; Purpose:      This file implements some of the optimization routines
;               for specific portions of benchmarks or apps.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

IF 0
	; FOR SetDIBItsToDevice, these are the widths that have
	; alot of repeated pixels
        cmp     ecx,2EAH
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1E2H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1C0H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,208H
        je      HW_SetDIBitsSingleScan_Sizeable
        jmp     Not_Sizeable
ENDIF

IF 0
	; FOR StretchDIBits, these are the widths that have
	; alot of repeated pixels
        cmp     ecx,2E8H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1E2H
        je      HW_SetDIBitsSingleScan_Sizeable
        cmp     ecx,1C0H
        je      HW_SetDIBitsSingleScan_Sizeable
        jmp     Not_Sizeable
ENDIF


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC	dwEnableDibRunLengths
dwEnableDibRunLengths	DD	0

;==============================================================================
;
; Function:     GN_DibSingleScan_Bpp32
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsSingleScan
;               when the generic code has determined that the call
;		matches this special case: the DIB is 8bpp, 1 scanline
;		high, wInitScan = 0, and wNumScans = 1 and dst is 32bpp.
;
; Arguments:
; 		es:ebx  ptr to first DIB src pixel    (SRC)
; 		gs:edx  framebuffer_selecotr:y * deltaScan + deBitsOffset
; 		fs:edi  ptr to color table
; 		ecx     ExtX
; 		eax     DstX
;
; Returns:      eax     always return 1
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_DibSingleScan_Bpp32, PASCAL, NOFRAME, NEAR
OPENPROC
	cmp	cs:[dwEnableDibRunLengths],0
	jne	RunLengths

        lea     esi,[edx][eax * 4]
@@:
        movzx   eax,byte ptr es:[ebx]
        inc     ebx
        mov     edx,fs:[edi][eax * 4]
        mov     gs:[esi],edx
        add     esi,4
        dec     ecx
        jne     @B
        mov     eax,1
	ret

RunLengths:
        lea     esi,[edx][eax * 4]

NextRun32:
        ; Load up the first src pixel
        movzx   eax,byte ptr es:[ebx]
        mov     edx,fs:[edi + eax * 4]
        imul    eax,1010101H
        cmp     ecx,4
        jl      Tl2

        ; Do the run cppropriately
@@:     cmp     eax,es:[ebx]
        jne     EndDwordRun32
        mov     gs:[esi + 00H],edx
        mov     gs:[esi + 04H],edx
        mov     gs:[esi + 08H],edx
        mov     gs:[esi + 0CH],edx
        add     esi,10H
        add     ebx,4
        sub     ecx,4
        cmp     ecx,4
        jge     @B
Tl2:
        or      ecx,ecx
        je      EndLine

EndDwordRun32:
@@:
        cmp     al,es:[ebx]
        jne     EndByteRun32
        mov     gs:[esi],edx
        add     esi,4
        inc     ebx
        dec     ecx
        jg      @B

EndByteRun32:
        or      ecx,ecx
        jne     NextRun32

EndLine:
	mov	eax,1
	ret
ENDPROC


;==============================================================================
;
; Function:     GN_DibSingleScan_Bpp16
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsSingleScan
;               when the generic code has determined that the call
;		matches this special case: the DIB is 8bpp, 1 scanline
;		high, wInitScan = 0, and wNumScans = 1 and dst is 16bpp.
;
; Arguments:
; 		es:ebx  ptr to first DIB src pixel    (SRC)
; 		gs:edx  framebuffer_selecotr:y * deltaScan + deBitsOffset
; 		fs:edi  ptr to color table
; 		ecx     ExtX
; 		eax     DstX
; 		edx     y * deltascan + deBitsOffset
;
; Returns:      eax     always return 1
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_DibSingleScan_Bpp16, PASCAL, NOFRAME, NEAR
OPENPROC
	cmp	cs:[dwEnableDibRunLengths],0
	jne	RunLengths

        push    ebp
        lea     esi,[edx][eax * 2]
back:
        movzx   edx,byte ptr es:[ebx]
        inc     ebx
        movzx   eax,byte ptr fs:[edi + edx * 4 + 0]
        movzx   ebp,byte ptr fs:[edi + edx * 4 + 1]
        movzx   edx,byte ptr fs:[edi + edx * 4 + 2]

        sub     eax,4
        jnc     @F
        sub     eax,eax
@@:     sub     ebp,2
        jnc     @F
        sub     ebp,ebp
@@:     sub     edx,4
        jnc     @F
        sub     edx,edx
@@:     shr     ebp,2
        shr     edx,3
        shr     eax,3
        shl     ebp,5
        shl     edx,0BH
        or      eax,ebp
        or      eax,edx
        mov     gs:[esi],ax
        add     esi,2
        dec     ecx
        je      done1
        movzx   edx,byte ptr es:[ebx - 1]
@@:
        cmp     dl,es:[ebx]
        jne     back
        inc     ebx
        mov     gs:[esi],ax
        add     esi,2
        dec     ecx
        jne     @B
done1:
        pop     ebp
        mov     eax,1
        ret


RunLengths:
        lea     esi,[edx][eax * 2]

NextRun16:
        ; Load up the first src pixel
        movzx   edx,byte ptr es:[ebx]

        ; Remap the color into edx
        push    ebx
        movzx   eax,byte ptr fs:[edi + edx * 4 + 0]
        movzx   ebx,byte ptr fs:[edi + edx * 4 + 1]
        movzx   edx,byte ptr fs:[edi + edx * 4 + 2]
        sub     eax,4
        jnc     @F
        sub     eax,eax
@@:     sub     ebx,2
        jnc     @F
        sub     ebx,ebx
@@:     sub     edx,4
        jnc     @F
        sub     edx,edx
@@:     shr     ebx,2
        shr     edx,3
        shr     eax,3
        shl     ebx,5
        shl     edx,0BH
        or      eax,ebx
        or      eax,edx
        pop     ebx

        ; get the color into both words
        shrd    edx,eax,10H
        mov     dx,ax

        ; Now get the src pixel again into all 4 bytes of eax
        movzx   eax,byte ptr es:[ebx]
        imul    eax,1010101H

        ; Go into the dword loop if there are enough pixels left
        cmp     ecx,4
        jl      Tl1

        ; Do the run cppropriately
@@:     cmp     eax,es:[ebx]
        jne     EndDwordRun16
        mov     gs:[esi + 00H],edx
        mov     gs:[esi + 04H],edx
        add     esi,8
        add     ebx,4
        sub     ecx,4
        cmp     ecx,4
        jge     @B
Tl1:
        or      ecx,ecx
        je      EndLine

EndDwordRun16:
@@:
        cmp     al,es:[ebx]
        jne     EndByteRun16
        mov     gs:[esi],dx
        add     esi,2
        inc     ebx
        dec     ecx
        jg      @B

EndByteRun16:
        or      ecx,ecx
        jne     NextRun16

EndLine:
        mov     eax,1
        ret
ENDPROC


;==============================================================================
;
; Function:     GN_DibSingleScan_Bpp8
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsSingleScan
;               when the generic code has determined that the call
;		matches this special case: the DIB is 8bpp, 1 scanline
;		high, wInitScan = 0, and wNumScans = 1 and dst is 8bpp.
;
; Arguments:
; 		es:ebx  ptr to first DIB src pixel    (SRC)
; 		gs:edx  framebuffer_selecotr:y * deltaScan + deBitsOffset
; 		fs:edi  ptr to color table
; 		ecx     ExtX
; 		eax     DstX
; 		edx     y * deltascan + deBitsOffset
;
; Returns:      eax     always return 1
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_DibSingleScan_Bpp8, PASCAL, NOFRAME, NEAR
OPENPROC
	cmp	cs:[dwEnableDibRunLengths],0
	jne	RunLengths

        lea     esi,[edx][eax]

Next_Pixel:
        movzx   edx,byte ptr es:[ebx]
        inc     ebx
        mov     al,fs:[edi][edx * 2]
        mov     gs:[esi],al
        inc     esi
        dec     ecx
        jne     Next_Pixel
        mov     eax,1
        ret

RunLengths:
        lea     esi,[edx][eax]

NextRun8:
        ; Load up the first src pixel
        movzx   edx,byte ptr es:[ebx]
        movzx   eax,byte ptr fs:[edi + edx * 2]
        imul	edx,1010101H
        imul    eax,1010101H
        cmp     ecx,4
        jl      Tl2

        ; Do the run cppropriately
@@:     cmp     edx,es:[ebx]
        jne     EndDwordRun8
        mov     gs:[esi + 00H],eax
        add     esi,4
        add     ebx,4
        sub     ecx,4
        cmp     ecx,4
        jge     @B
Tl2:
        or      ecx,ecx
        je      EndLine

EndDwordRun8:
@@:
        cmp     dl,es:[ebx]
        jne     EndByteRun8
        mov     gs:[esi],al
        add     esi,4
        inc     ebx
        dec     ecx
        jg      @B

EndByteRun8:
        or      ecx,ecx
        jne     NextRun8

EndLine:
	mov	eax,1
	ret
ENDPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDIBDEV.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibdev.asm
;
; Purpose:      This file holds the SetDIBitsToDevice display driver
;               entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_SetDIBitsToDevice
;
; Purpose:      This function is the SetDIBitsToDevice driver entry point.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetDIBitsToDevice, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wInitScan
PARMW   wNumScans
PARMD   lpClipRect
PARMD   lpDrawMode
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
LOCALD  dwBmpBitsPixel
LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwDibLeft
LOCALD  dwDibTop
LOCALD  dwDibBitsOffset
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwDibPitch
LOCALD  dwDibWidth
LOCALD  dwDibHeight
LOCALD  lpPhysColor
LOCALD  dwPhysColor
LOCALD  dwFlagSecondPhysColorPresent
OPENPROC
        PUSHR   ds,esi,edi
        sub     esi,esi
        sub     edi,edi

        ; Load up the DstDev and the DIB Header for dispatching
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        lfs     di,lpDIBInfo

        ; See if screen is busy
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_DibDevPunt

        ; We only do RGB DIBs (No Compression)
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_RGB
        jne     GN_DibDevPunt

IF DIB_PROCESS_SINGLESCAN
        ; Special case the 8bpp dibs that are 1 scanline high,
        ; where wInitScan = 0 and wNumScans = 1.
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,8
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biHeight,1
        jne     @F
        movzx   eax,wInitScan
        movzx   ecx,wNumScans
        or      eax,eax
        jne     @F
        cmp     ecx,1
        je      GN_SetDIBitsSingleScan
@@:
ENDIF

IF      (DIB_8BPP_ACCEL NE 0)
        ; If the dst is 8bpp and src is mono, then punt it.
        cmp     ds:[esi].DIBENGINE.deBitsPixel,8
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        je      GN_DibDev8BppPunt
@@:
ELSE
        ; If the dst is 8bpp, then punt it. Already handled SingleScan case.
        cmp     ds:[esi].DIBENGINE.deBitsPixel,8
        je      GN_DibDev8BppPunt
ENDIF

        ; First, clip the DIB
        call    GN_SetDIBitsToDeviceClip
        or      eax,eax
        je      GN_DibDevExit
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Break the call out into cases.
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        jne     GN_SetColorDibToDevice
        jmp     GN_SetMonoDibToDevice
ENDPROC


;==============================================================================
;
; Function:     SetDIBitsToDevice ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of SetDIBitsToDevice. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_DibDevPunt
GN_DibDevPunt   PROC    NEAR
        push    lpDstDev
        push    wDstX
        push    wDstY
        push    wInitScan
        push    wNumScans
        push    lpClipRect
        push    lpDrawMode
        push    lpDIBBits
        push    lpDIBInfo
        push    lpTranslate
PLABEL  Punt_DibToDevice
        call    DIB_DibToDevice
        .errnz  $ - OFFSET GN_DibDevExit

GN_DibDevPunt   ENDP

PUBLIC  GN_DibDevExit
GN_DibDevExit   PROC    NEAR
        POPR    ds,esi,edi
        mov     sp,bp
        mov     ecx,ss:[ebp + 4]
        pop     ebp
IF DIB_FAST_EXIT
        cmp     ax,-1
        je      @F
        cmp     cs:[bUseSetDIBitsFastExit],0
        je      @F
        cmp     ecx,cs:[lpfnGdiCode03_2119]
        jne     @F
        add     sp,4 + 20H
        jmp     GdiCode03_2119
@@:
ENDIF
        ; Clean and return normally
        RETFAR16 20H
GN_DibDevExit   ENDP


;==============================================================================
;
; Function:     GN_DibDev8BppPunt (SetDIBitsToDevice ending routine)
;
; Purpose:      This function is a work-around for a bug in the
;               DIBEngine DIB compiler.  At 8bpp, if the destination
;               bitmap is not word aligned (i.e. (wDestX & 1) == 1)
;               AND the clip rect is one (1) pixel wide AND the clip
;               rect is misaligned by 3 (i.e. (wClipLeft & 3) == 3),
;               AND the stretch is 1:1, then the DIB compiler will
;               fail to compile the code to do the pixel copy
;               (tested in the 16bpp source case) but will compile
;               the epilogue code incrementing the source and dest
;               pointers furiously.
;               The result of this is somewhat unsatisfying.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
;==============================================================================
DECPROC GN_DibDev8BppPunt, PASCAL, NOFRAME, NEAR
OPENPROC
        test    wDstX,1                 ; Check for unaligned destination
        jz      GN_DibDevPunt
        xor     esi,esi
        cmp     word ptr [lpClipRect + 2],si
        jz      GN_DibDevPunt
        lfs     si,lpClipRect

        movzx   eax,fs:[esi].RECT.left
        inc     eax
        cmp     ax,fs:[esi].RECT.right  ; Check if clip is 1 pixel wide
        jnz     GN_DibDevPunt
        and     eax,3                   ; Check for (clipleft mod 4) == 3
        jnz     GN_DibDevPunt

        ; Clean and return a failure normally
        POPR    ds,esi,edi
        mov     sp,bp
        mov     eax,-1
        pop     ebp
        RETFAR16 20H
ENDPROC


;==============================================================================
;
; Function:     GN_SetMonoDibToDevice
;
; Purpose:      This function is jumped to from the SetDIBitsToDevice
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               ds      Context Selector
;               esi     GNLOGDEVCX ptr
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the SetDIBitsToDevice ending routines.
;
;==============================================================================
DECPROC GN_SetMonoDibToDevice, PASCAL, NOFRAME, NEAR
OPENPROC
        ; We can handle this as a mono transfer
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        push    eax
        push    dwDibBitsOffset
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY

        ; The bg and fg colors come from the color table at end of DIB
        lea     esi,dwPhysColor
        ror     esi,10H
        mov     si,ss
        ror     esi,10H
        mov     lpPhysColor,esi

        mov     esi,dword ptr fs:[edi].BitmapInfo.bmiColors[0]
        cmp     fs:[edi].BitmapInfoHeader.biClrUsed,1
        je      @F
        mov     edi,dword ptr fs:[edi].BitmapInfo.bmiColors[4]
        push    lpDstDev
        bswap   edi
        ror     edi,8
        push    edi
        push    lpPhysColor
        call    GENERIC_ColorInfo
        mov     edi,dwPhysColor
@@:
        push    lpDstDev
        bswap   esi
        ror     esi,8
        push    esi
        push    lpPhysColor
        call    GENERIC_ColorInfo

        ; push two translated colors
        push    dwPhysColor
        push    edi

        mov     ecx,0CC0000H
        mov     edx,07FFFH
        sub     ebx,ebx
        push    ecx                             ; Rop3
        push    ebx                             ; lpBrush
        push    lpDrawMode                      ; lpDrawmode
        push    edx                             ; scans left in start seg
        push    edx                             ; scans per seg
        push    ebx                             ; fill bytes

        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        je      GN_DibDevPunt
        movzx   eax,wNumScans
        jmp     GN_DibDevExit
ENDPROC


;==============================================================================
;
; Function:     GN_SetColorDibToDevice
;
; Purpose:      This function is jumped to from the SetDIBitsToDevice
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the color transfer.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               ds      Context Selector
;               esi     GNLOGDEVCX ptr
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the SetDIBitsToDevice ending routines.
;
;==============================================================================
DECPROC GN_SetColorDibToDevice, PASCAL, NOFRAME, NEAR
OPENPROC
        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   ecx,fs:[edi].BitmapInfoHeader.biBitCount
        cmp     ecx,10H
        jne     @F
        mov     ecx,0FH
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_DibDevPunt
        inc     ecx
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_DibDevPunt
@@:
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp
        push    eax
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   edx,word ptr lpDIBBits+2
        push    edx
        push    dwDibBitsOffset
        push    ecx
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY
        sub     eax,eax
        pushd   0CC0000H
        push    eax                             ; lpBrush
        push    lpDrawMode                      ; lpDrawMode
        pushd   4                               ; dwSizeColorTableEntry

        ; If the src is > 8bpp, then there is no color table.
        ; If there is a color table, compute the number of entries.
        sub     ebx,ebx
        cmp     cl,8
        jbe     IsColorTable
        cmp     ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp,8
        jne     @F
        mov     ebx,lpTranslate
        jmp     @F

IsColorTable:
        mov     ebx,lpDIBInfo
        add     bx,word ptr fs:[edi].BitmapInfoHeader.biSize
        mov     edx,fs:[edi].BitmapInfoHeader.biClrUsed
        mov     eax,1
        shl     eax,cl
        or      edx,edx
        je      @F
        cmp     eax,edx
        jc      @F
        mov     eax,edx
@@:
        push    eax                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        sub     eax,eax
        push    eax

        call    HW_BitBltSrcColorDstVram
        or      eax,eax
        je      GN_DibDevPunt
        movzx   eax,wNumScans
        jmp     GN_DibDevExit
ENDPROC


;==============================================================================
;
; Function:     GN_SetDIBitsToDeviceClip
;
; Purpose:      This function clips the DIB and Bitmap for SetDIBitsToDevice.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_SetDIBitsToDeviceClip, PASCAL, NOFRAME, NEAR
OPENPROC
        ; We need this for the clipping.
        xor     esi,esi                 ; clear high word of ESI
        les     si,lpClipRect

        ; Get the width and height of the DIB and compute the signed pitch.
        mov     ecx,fs:[edi].BitmapInfoHeader.biHeight
        mov     edx,fs:[edi].BitmapInfoHeader.biWidth
        movzx   eax,fs:[edi].BitmapInfoHeader.biBitCount
        imul    eax,edx
        add     eax,1FH
        shr     eax,3
        and     eax,NOT 3
        neg     ecx
        jns     @F
        neg     ecx
        neg     eax
@@:     mov     dwDibWidth,edx
        mov     dwDibHeight,ecx
        mov     dwDibPitch,eax

        ; Bitmap Top = maximum(pClipRect->top, wDstY);
        movsx   eax,wDstY
        movsx   ecx,es:[esi].RECT.top
        mov     ebx,eax
        cmp     eax,ecx
        jge     @F
        mov     eax,ecx
@@:
        ; Bitmap Top = maximum (0, wDstY)
        ; Dib Top = maximum (0, wDstY) - wDstY
        or      eax,eax
        jge     @F
        sub     eax,eax
@@:     mov     dwBmpTop,eax
        sub     eax,ebx
        mov     dwDibTop,eax

        ; wClippedNumScans = mimimum (DibHeight - wInitScan, wNumScans)
        mov     edx,dwDibHeight
        movsx   eax,wInitScan
        movsx   ecx,wNumScans
        sub     edx,eax
        cmp     edx,ecx
        jle     @F
        mov     edx,ecx
@@:     or      edx,edx
        jle     AllClipped

        ; Bitmap Bottom = mimimum (lpClipRect->bottom, wDstY + wClippedNumScans)
        movzx   eax,es:[esi].RECT.bottom
        add     ebx,edx
        cmp     ebx,eax
        jl      @F
        mov     ebx,eax
@@:     sub     ebx,dwBmpTop
        jle     AllClipped
        mov     dwExtY,ebx

        ; Bitmap Left = maximum(pClipRect->left, wDstX);
        movsx   eax,wDstX
        movsx   ecx,es:[esi].RECT.left
        mov     ebx,eax
        cmp     eax,ecx
        jge     @F
        mov     eax,ecx
@@:
        ; Bitmap Left = maximum (0, wDstX)
        ; Dib Left = maximum (0, wDstX) - wDstX
        or      eax,eax
        jge     @F
        sub     eax,eax
@@:     mov     dwBmpLeft,eax
        sub     eax,ebx
        mov     dwDibLeft,eax

        ; Bitmap Right = minimum(lpClipRect->right, wDstX + DibWidth)
        ; SetDib X Ext = Bitmap Right - Bitmap Left
        mov     eax,dwDibWidth
        movsx   ecx,es:[esi].RECT.right
        add     eax,ebx
        cmp     eax,ecx
        jl      @F
        mov     eax,ecx
@@:     sub     eax,dwBmpLeft
        jle     AllClipped
        mov     dwExtX,eax

        ; Make a ptr to the DIB Bits based upon the orientation of the
        ; DIB (right side up or upside down).
        mov     ecx,dwDibPitch
        movzx   ebx,word ptr lpDIBBits
        or      ecx,ecx
        jg      @F
        mov     edx,dwDibHeight
        neg     ecx
        dec     edx
        imul    ecx,edx
        add     ebx,ecx
@@:     mov     dwDibBitsOffset,ebx

        mov     eax,1
        ret

AllClipped:
        sub     eax,eax
        ret
ENDPROC


IF DIB_PROCESS_SINGLESCAN
;==============================================================================
;
; Function:     GN_SetDIBitsSingleScan
;
; Purpose:      This routine is jumped to from GENERIC_SetDIBitsToDevice
;               when the generic code has determined that the call
;               matches this special case: the DIB is 8bpp, 1 scanline
;               high, wInitScan = 0, and wNumScans = 1.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               ds      Context Selector
;               esi     GNLOGDEVCX ptr
;
; Returns:      None
;               This routine jumps to other routines which eventually
;               jump to GN_DibDevExit with the proper return code for
;               the SetDIBitsToDevice call when they are done.
;
; Preserve:     ds,edi,gs
;==============================================================================
DECPROC GN_SetDIBitsSingleScan, PASCAL, NOFRAME, NEAR
OPENPROC
        movzx   eax,ds:[esi].DIBENGINE.deBitsPixel
        mov     dwBmpBitsPixel,eax

        sub     esi,esi
        les     si,lpClipRect
        sub     eax,eax

        ; clip top and bottom
        movsx   edx,wDstY
        movsx   ebx,es:[esi].RECT.top
        cmp     edx,ebx
        jl      GN_DibDevExit
        movsx   ebx,es:[esi].RECT.bottom
        sub     ebx,edx
        cmp     ebx,fs:[edi].BitmapInfoHeader.biHeight
        jg      GN_DibDevExit

        ; clip left
        movsx   eax,wDstX
        movsx   ecx,es:[esi].RECT.left
        sub     ebx,ebx
        cmp     eax,ecx
        jge     @F
        mov     ebx,ecx
        sub     ebx,eax
        mov     eax,ecx
@@:
        ; clip right
        movsx   ecx,es:[esi].RECT.right
        sub     ecx,eax
        cmp     ecx,fs:[edi].BitmapInfoHeader.biWidth
        jg      GN_DibDevExit

        ; At this point:
        ; eax = clipped DstX
        ; ebx = number src pixels clipped on left edge
        ; ecx = clipped ExtX
        ; edx = clipped DstY

        ; Load up the src ptr
        movzx   esi,word ptr lpDIBBits
        mov     es,word ptr lpDIBBits+2
        add     ebx,esi

        ; Point to the color table
        mov     esi,cs:[CSpGNLogicalDevice]
        add     edi,fs:[edi].BitmapInfoHeader.biSize

        ; Get the dst ptr in gs:edx
        imul    edx,ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        add     edx,ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        mov     gs,ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector

        ; Sync with the hardware
        mov     esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess

        ; Dispatch to correct color depth routine
        push    OFFSET GN_DibDevExit
        cmp     dwBmpBitsPixel,10H
        ja      GN_DibSingleScan_Bpp32
        je      GN_DibSingleScan_Bpp16

        ; if not NULL, need to use lpTranslate
        cmp     lpTranslate,0
        je      GN_DibSingleScan_Bpp8
        sub     edi,edi
        lfs     di,lpTranslate
        jmp     GN_DibSingleScan_Bpp8
ENDPROC
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNCRTC2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gncrtc2.asm
;
; Purpose:      This file holds run-time routines for GNCRTCCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc
include minivdd.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  szMonitorDeviceName
szMonitorDeviceName     DB      "MONITOR",0

;============================================================================
;
; Function:     GN_CrtcMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
; Returns:      None
;
; Preserve:     ds,esi,edi
;============================================================================
DECPROC GN_CrtcMessage, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        cmp     eax,MSG_LOGDEVMOVED
        je      MoveLogDev
        cmp     eax,MSG_DEVICESREMAPPED
        je      DevRemap
        jmp     ChainIt

PreMS:
        jmp     ChainIt

PostMS:
        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache

        ; We are no longer initting after the first modeset
        mov     ds:[esi].GNCRTCCX.dwInitting,0
        jmp     ChainIt

DXEnum:
DXOn:
DXOff:
        jmp     ChainIt

DosOff:
        push    dwData1
        push    esi
        call    GN_SetBytesPerPixelAndBytesPerLine

        push    esi
        call    GN_SetPanRectangle

        ; Now, reload the color map
        push    esi
        call    GN_ResetColorMap

PowerOn:
        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache
        jmp     ChainIt

DosOn:
DrvDis:
        ; Clear out the cursor cache.
        push    esi
        call    GN_ClearCursorCache

        ; Set a NULL cursor so the cursor will disappear
        pushd   0
        call    GENERIC_SetCursor

PowerOff:
        jmp     ChainIt

MoveLogDev:
        jmp     ChainIt

DevRemap:
        push    pGNCrtcCXOffset
        push    dwData1
        call    GN_CrtcDeviceHasBeenRemapped
        jmp     ChainIt

ChainIt:
        ; Call the hardware to inform it of the message
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    HW_CrtcMessage

DoneIt2:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestoreCrtcState
;
; Purpose:      This routine gets called to put the GNCRTCCX
;               back into the HWCRTCCX.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestoreCrtcState, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGNLogDevCXOffset
OPENPROC
        PUSHR   esi

        ; Reset the mode
        push    pGNCrtcCXOffset
        push    pGNLogDevCXOffset
        call    GN_SetCrtcMode

        ; Force the cursor cache to be re-created
        push    pGNCrtcCXOffset
        call    GN_ClearCursorCache

        ; Turn the cursor back on if it is not NULL
        push    pGNCrtcCXOffset
        pushd   1
        pushd   1
        call    GN_TurnCursorOffOrOn

        ; restore the
        push    pGNCrtcCXOffset
        call    GN_ResetColorMap

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CrtcDeviceHasBeenRemapped
;
; Purpose:      This routine gets called whenever we get the
;               DEVICESREMAPPED message. The CRTC must update
;               any internal state it needs to because its
;               display device has changed.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CrtcDeviceHasBeenRemapped, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGNLogDevCXOffset
LOCALD  pHWCrtcCXOffset
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Check for video mirror enabled on this CRTC?
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F
        mov     eax,ds:[esi].GNCRTCCX.pHWCrtcCXWhenLocked
@@:
        mov     pHWCrtcCXOffset,eax

        ; We only do this for the primary device in each driver
        cmp     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,0
        jne     @F

        ; This forces the monitors to be re-enumerated and
        ; it forces Windows to reget all the EDIDS which
        ; may be necessary after a device remapping. We pass
        ; up the physical head that the first Windows logical
        ; device is using.
        push    pHWCrtcCXOffset
        call    HW_GetPhysicalCrtcIndex
        mov     ebx,pGNLogDevCXOffset
        push    ds:[ebx].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        or      eax,80000000H
        push    eax
        call    GN_VddReenumerateDevNode

@@:
        push    pHWCrtcCXOffset
        call    HW_GetDacLimits
        lea     edi,[esi].GNCRTCCX.sNvmodeDispData
        mov     ds:[edi].DISPDATA.dwMaxDacSpeedInHertz8bpp,eax
        mov     ds:[edi].DISPDATA.dwMaxDacSpeedInHertz16bpp,ebx
        mov     ds:[edi].DISPDATA.dwMaxDacSpeedInHertz32bpp,ecx

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        push    eax
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo

        ; Get the registry path to our device local stuff.
        ; Anything that is not the primary device does not
        ; get an .inf file.
        ; Also, because the results of Reenumerate are asyncronous
        ; and delayed by about five seconds, when switching display
        ; devices we have to just go without a .inf status the first
        ; time. A modeset that occurs but does not involve a display
        ; device switch will attempt to reget the .inf status.
        ; However, if we are initting, and the device is the primary,
        ; get the INF or we won't have it for modesets until the display
        ; device changes.
        mov     ds:[edi].DISPDATA.dwMonitorInfType,UNKNOWN_DEVICE
        cmp     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,0
        jne     @F
        cmp     ds:[esi].GNCRTCCX.dwInitting,1
        je      GetDevPath
        cmp     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,0
        jne     @F
        
GetDevPath:
        lea     eax,[esi].GNCRTCCX.szLocalMonitorBasePath
        push    sDispInfo.diMonitorDevNodeHandle
        mov     ax,ds
        push    eax
        lea     ecx,[esi].GNCRTCCX.szLocalMonitorBasePath
        push    ecx
        mov     ax,SEG szMonitorDeviceName
        push    eax
        mov     ax,OFFSET szMonitorDeviceName
        movzx   eax,ax
        push    eax
        call    GN_GetDeviceLocalBasePath
        mov     ds:[edi].DISPDATA.dwMonitorInfType,ecx
@@:
        ; In case it was set, clear out the display device change flag
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,0

        ; Assume no Edid
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0

        ; Reread the EDID if the device is not a TV
        push    esi
        call    GN_GetDevData
        cmp     al,DEVTYPE_TV
        je      @F

        ; Read the EDID for this device
        mov     ds:[esi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    pHWCrtcCXOffset
        push    eax
        lea     eax,[esi].GNCRTCCX.sEdidBuffer
        push    eax
        lea     eax,[esi].GNCRTCCX.dwEdidSize
        push    eax
        call    HW_ReadEdid
@@:
        ; Set the new Display Device type into the registry
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    ds:[esi].GNCRTCCX.dwLogicalDeviceInstance
        push    ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[ebx].DISPDATA.lpDevData
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

        ; If this device is a TV, set the TV Format in the ResMan.
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        lfs     bx,fs:[ebx].DISPDATA.lpDevData
        mov     eax,fs:[ebx]
        cmp     al,DEVTYPE_TV
        jne     SkipTVFormat
        push    pHWCrtcCXOffset
        push    eax
        call    HW_SetResManTvFormat
        
SkipTVFormat:

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CrtcRemapArray
;
; Purpose:      This routine gets all the display devices types
;               associated with all the CRTCCXs, asks the hardware
;               for a remapping.
;
;               The caller must have verified that the set of all
;               display device types in all the CRTCCXs are able
;               to be used simultaneously, presumably by having
;               called HW_CanDevicesBeMapped.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwRestoreStates         Restore the CRTC state
;                                       for those devices which
;                                       changed under the remap
;                                       if this is non-0.
;                                       otherwise, don't.
;
; Returns:
;               eax                     A dword specifying which devices
;                                       have changed. If bit 0 is a 1,
;                                       then first device in the lpDevData
;                                       array was remapped. If bit 1, is a
;                                       1, then the 2nd device in lpDevData
;                                       array was remapped, etc...
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CrtcRemapArray, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; Just some setup
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Get all the attached devices
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData

        ; Ask the hardware to resolve the mappings so things
        ; will just work ;-).
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    lpHWCrtcCX
        push    eax
        call    HW_MapDevices
        push    eax

        ; Send a message around telling everyone that the
        ; hardware has remapped device assignments.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_SendDevicesRemapMsgToAllLogDevs

        pop     eax
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestoreAllCrtcStates
;
; Purpose:      This routine gets called to restore all the
;               CRTC states.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwRestoreStates         Restore the CRTC state
;                                       for those devices which
;                                       changed under the remap
;                                       if this is non-0.
;                                       otherwise, don't.
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestoreAllCrtcStates, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
LOCALD  dwDeviceCount
LOCALD  dwDevDataMask
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; Just some setup
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Get all the attached devices
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; We need to go into a loop here. Restore all states
        sub     edi,edi

        ; Get the Device Data Mask for all display devices.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ebx
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwDevDataMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_BeginDisplayChange

Loopit7:
        ; Is this CRTCCX valid?
        sub     ebx,ebx
        les     bx,lpGNCrtcCX
        push    dword ptr es:[ebx][edi * 4]
        push    esi
        call    GN_RestoreCrtcState
        inc     edi
        cmp     edi,dwDeviceCount
        jc      Loopit7

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_EndDisplayChange

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetBytesPerPixelAndBytesPerLine
;
; Purpose:      This routine gets called to let the CRTCCX know
;               the current number of bytes per pixel and bytes
;               per line. It needs this to do panning.
;
; Arguments:
;               ds                      CX Sel
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetBytesPerPixelAndBytesPerLine, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   pGNCrtcCXOffset
OPENPROC
        mov     ebx,pGNLogdevCXOffset
        mov     ecx,pGNCrtcCXOffset
        movzx   eax,ds:[ebx].DIBENGINEHDR.deBitsPixel
        inc     eax
        shr     eax,3
        mov     ds:[ecx].GNCRTCCX.dwBytesPerPixelInCurrentMode,eax
        mov     eax,ds:[ebx].DIBENGINEHDR.deDeltaScan
        mov     ds:[ecx].GNCRTCCX.dwBytesPerLineInCurrentMode,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetPanRectangle
;
; Purpose:      This routine gets called whenever the panning
;               rectangle needs to be reset. The fields in
;               the GNCRTCCX.rcPhysicalViewport have been
;               modified and need to get set back into the
;               hardware.
;
; Arguments:
;               ds                      CX Sel
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetPanRectangle, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        ; Set the Pan Coordinates
        mov     ebx,pGNCrtcCXOffset
        mov     eax,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwTop
        imul    eax,ds:[ebx].GNCRTCCX.dwBytesPerLineInCurrentMode
        mov     ecx,ds:[ebx].GNCRTCCX.rcPhysicalViewport.dwLeft
        imul    ecx,ds:[ebx].GNCRTCCX.dwBytesPerPixelInCurrentMode
        add     eax,ecx

        ; Note that we must have a multiple of 4 for the hardware to
        ; pan to it, but this means the address may not match the
        ; rectangle coordinates exactly. We can fix that if it ever
        ; really becomes an issue. For right now, I'll ignore it.
        add     eax,3
        and     eax,NOT 3

        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    eax
        call    HW_SetPanOffset
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDevData
;
; Purpose:      This routine gets called to get the DevData for the
;               CRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      GNCRTCCX.sCrtcModeInfo.MIDevData
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetDevData, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        mov     eax,pGNCrtcCXOffset
        lea     eax,[eax].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[eax].MODEINFO.MIDevData
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetDevData
;
; Purpose:      This routine gets called to set the DevData for the
;               CRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               NewDevData              DEVDATA
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetDevData, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   NewDevData
OPENPROC
        mov     ecx,pGNCrtcCXOffset
        mov     eax,NewDevData
        lea     ecx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     ds:[ecx].MODEINFO.MIDevData,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_AssignCrtcModeOnlyBackOffSpatial
;
; Purpose:      This routine assigns the CRTC mode to be the mode
;               passed in. If the CRTC cannot do the mode passed
;               in, then back off ONLY the XRes, and YRes, to
;               get the mode that it can do. Try to leave the
;               refresh rate alone.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpNewModeInfo           DEVDATA
;
; Returns:      GNCRTCCX.CrtcDevData
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AssignCrtcModeOnlyBackOffSpatial, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpNewModeInfo
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Use the suggested mode passed in
        sub     edi,edi
        les     di,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    es:[edi].MODEINFO.MIDevData
        sub     esi,esi
        lfs     si,lpNewModeInfo
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        sub     edi,SIZE MODEINFO
        pop     es:[edi].MODEINFO.MIDevData

        mov     esi,pGNCrtcCXOffset

        ; We don't have a way to back off just the XRes,YRes at
        ; this point. This may back off the refresh rate. JKTODO
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpEdidBuffer
        push    ds:[esi].GNCRTCCX.dwEdidSize
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[esi].GNCRTCCX.lpCrtcModeOut
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        push    ss
        pop     fs
        lea     si,sSettableCrtcModeInfo
        mov     edi,pGNCrtcCXOffset
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetCrtcMode
;
; Purpose:      This routine gets called to get the mode which should
;               be set on this CRTC.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpSuggMode              mode to use if no mode found
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetCrtcMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpSuggMode
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; First, if there is a forced mode we MUST set that
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnGetForcedDisplayMode,es,ax
        or      ax,ax
        jne     @F

        ; If not, just read the last mode that was set on this device
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        jne     @F

        ; Use the suggested mode passed in
        sub     edi,edi
        les     di,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    es:[edi].MODEINFO.MIDevData
        sub     esi,esi
        lfs     si,lpSuggMode
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        sub     edi,SIZE MODEINFO
        pop     es:[edi].MODEINFO.MIDevData
@@:
        
        ; Validate the mode but first update the color depth to match
        ; the desktop. It also resets the lpCrtcModeInfo passed in to
        ; something it can handle if the mode provided was out of its
        ; range.
        mov     esi,pGNCrtcCXOffset
        sub     edi,edi
        les     di,lpSuggMode
        mov     eax,es:[edi].MODEINFO.dwBpp
        les     di,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        mov     es:[edi].MODEINFO.dwBpp,eax
        
        ; Now we are ready to validate!
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpEdidBuffer
        push    ds:[esi].GNCRTCCX.dwEdidSize
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[esi].GNCRTCCX.lpCrtcModeOut
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        push    ss
        pop     fs
        lea     si,sSettableCrtcModeInfo
        mov     edi,pGNCrtcCXOffset
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestrictOtherModeSpatial
;
; Purpose:      This routine gets called to munge down some other
;               mode to something smaller than the CRTC mode. If
;               the other mode is already smaller, then nothing
;               happens.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpOtherModeInfo         MODEINFO structure describing mode
;                                       to restrict CRTC mode to
;
; Returns:
;               eax     1 then mode was reduced
;                       0 then mode did not need to be changed
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestrictOtherModeSpatial, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpOtherModeInfo
OPENPROC
        PUSHR   esi

        mov     eax,pGNCrtcCXOffset
        sub     ebx,ebx
        lfs     bx,ds:[eax].GNCRTCCX.lpCrtcModeInfo
        sub     edx,edx
        les     dx,lpOtherModeInfo
        sub     esi,esi

        mov     eax,fs:[ebx].MODEINFO.dwXRes
        mov     ecx,fs:[ebx].MODEINFO.dwYRes
        cmp     eax,es:[edx].MODEINFO.dwXRes
        jb      DropOther
        cmp     ecx,es:[edx].MODEINFO.dwYRes
        jae     IsOK

DropOther:
        mov     es:[edx].MODEINFO.dwXRes,eax
        mov     es:[edx].MODEINFO.dwYRes,ecx
        mov     esi,1
IsOK:
        mov     eax,esi
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_RestrictCrtcModeSpatial
;
; Purpose:      This routine gets called to munge down the CRTC
;               mode to something smaller than the other mode. If
;               the CRTC mode is already smaller, then nothing happens.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               lpOtherModeInfo         MODEINFO structure describing mode
;                                       to restrict CRTC mode to
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RestrictCrtcModeSpatial, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpOtherModeInfo
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     eax,pGNCrtcCXOffset
        sub     ebx,ebx
        lfs     bx,lpOtherModeInfo
        sub     edx,edx
        les     dx,ds:[eax].GNCRTCCX.lpCrtcModeInfo

        mov     eax,fs:[ebx].MODEINFO.dwXRes
        mov     ecx,fs:[ebx].MODEINFO.dwYRes

        cmp     eax,es:[edx].MODEINFO.dwXRes
        ja      @F
        mov     es:[edx].MODEINFO.dwXRes,eax
@@:
        cmp     ecx,es:[edx].MODEINFO.dwYRes
        ja      @F
        mov     es:[edx].MODEINFO.dwYRes,ecx
        
@@:
        ; We now need to validate this mode as it may not be a valid mode since
        ; both the XRes and YRes may not have been changed to the new value,
        ; e.g., if the desktop is 1600x900 and the GNCRTCCX.lpCrtcModeInfo
        ; is set to 1400x1050, we'll end up with 1400x900.
        mov     esi,pGNCrtcCXOffset
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpEdidBuffer
        push    ds:[esi].GNCRTCCX.dwEdidSize
        push    ds:[esi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[esi].GNCRTCCX.lpCrtcModeOut
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        push    ss
        pop     fs
        lea     si,sSettableCrtcModeInfo
        mov     edi,pGNCrtcCXOffset
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CrtcWriteModeToReg
;
; Purpose:      This routine can write out the phys CRTC mode to
;               the registry under certain conditions. It can either
;               always write it out, or only write it out if there
;               is no current phys mode in the registry for the
;               current CRTCCX device.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               dwFlag                  if FALSE, always write mode to reg
;                                       if TRUE, only write mode to reg if
;                                       there is no mode in the reg for it
;                                       already
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CrtcWriteModeToReg, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   dwFlag
LOCALV  sModeInfo,MODEINFO
LOCALD  lpThisModeInfo
OPENPROC
        PUSHR   esi,edi

        cmp     dwFlag,0
        je      @F

        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        mov     lpThisModeInfo,eax

        ; Copy the CRTC MODEINFO struct over to a temporary spot
        mov     edi,pGNCrtcCXOffset
        sub     esi,esi
        lfs     si,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        sub     edi,edi
        les     di,lpThisModeInfo
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]

        ; Is there already a mode for it?
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.lpBoardRegistryData
        push    lpThisModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        jne     DoneIt
@@:
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.lpBoardRegistryData
        push    ds:[eax].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax
DoneIt:
        POPR    esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GN_SetCrtcMode
;
; Purpose:      This routine gets called to get the mode which should
;               be set on this CRTC. This routine cannot fail. Hence,
;               the caller must have validated that this mode can be
;               set on this CRTC. The mode is revalidated in here
;               however, and backed down if there is a problem.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;               pGNLogDevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetCrtcMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGNLogDevCXOffset
LOCALD  lpSettableModeInfo
LOCALV  sSettableModeInfo,MODEINFO
LOCALD  dwTopEdge
LOCALD  dwLeftEdge
LOCALD  dwBottomEdge
LOCALD  dwRightEdge
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset

        ; Need this a few times
        mov     ax,ss
        shl     eax,10H
        lea     ax,sSettableModeInfo
        mov     lpSettableModeInfo,eax

        ; Make sure the refresh rate list in the registry
        ; is the intersection of this specific hardware
        ; device and our board's capabilities.
        mov     ebx,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        lea     ebx,[ebx].MODEINFO.MIDevData
        push    ebx
        push    ds:[edi].GNCRTCCX.lpNvmodeDispData
        push    ds:[edi].GNCRTCCX.lpEdidBuffer
        push    ds:[edi].GNCRTCCX.dwEdidSize
        call    FFP16 PTR lpfnResetRefreshRates

        ; Get the correct timings for this CRTC
        push    ds:[edi].GNCRTCCX.lpNvmodeDispData
        push    ds:[edi].GNCRTCCX.lpEdidBuffer
        push    ds:[edi].GNCRTCCX.dwEdidSize
        push    ds:[edi].GNCRTCCX.lpCrtcModeInfo
        push    ds:[edi].GNCRTCCX.lpCrtcModeOut
        push    lpSettableModeInfo
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Copy the SettableModeInfo into the CrtcModeInfo
        sub     esi,esi
        lfs     si,lpSettableModeInfo
        les     di,ds:[edi].GNCRTCCX.lpCrtcModeInfo
        movzx   edi,di
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        mov     edi,pGNCrtcCXOffset

        ; Remember the bytes per pixel and bytes per line of this mode
        push    pGNLogDevCXOffset
        push    edi
        call    GN_SetBytesPerPixelAndBytesPerLine

        ; Update the mode pitch to the desktop pitch
        mov     ecx,pGNLogDevCXOffset
        mov     eax,ds:[ecx].DIBENGINEHDR.deDeltaScan
        lfs     bx,ds:[edi].GNCRTCCX.lpCrtcModeOut
        mov     fs:[bx].MODEOUT.dwPitchInBytes,eax

        ; Fill in the Format field of the ModeOut structure whether
        ; or not this is the primary physical device on the primary
        ; logical device
        cmp     ds:[edi].GNCRTCCX.dwLogicalDeviceInstance,0
        jne     NotPrimary
        cmp     ds:[edi].GNCRTCCX.dwPhysicalDeviceInstance,0
        jne     NotPrimary
        sub     ebx,ebx
        lfs     bx,ds:[edi].GNCRTCCX.lpCrtcModeOut
        or      fs:[ebx].MODEOUT.dwFormat,10000000h

NotPrimary:
        ; Call the hardware to program the timings
        mov     ebx,pGNLogDevCXOffset
        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        push    dword ptr ds:[ebx].DIBENGINEHDR.deBitsOffset
        push    ds:[edi].GNCRTCCX.lpCrtcModeOut
        call    HW_SetCrtcMode

        ; Get the registry key for whether or not a StopImage needs to
        ; be issued. If StopImage is issued, this will blank the display.
        mov     ebx,pGNLogDevCXOffset
        push    ds:[ebx].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetModesetStopImage,es,ax
        cmp     ax,1
        jne     SetViewPort
        
        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        call    HW_SetStopImage
        jmp     Done
        
SetViewPort:
        ; Set the viewport coordinates
        push    ds:[edi].GNCRTCCX.lpBoardRegistryData
        lfs     bx,ds:[edi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpDevData
        mov     ax,ss
        shl     eax,10h
        lea     ax,dwLeftEdge
        push    eax
        lea     ax,dwTopEdge
        push    eax
        lea     ax,dwRightEdge
        push    eax
        lea     ax,dwBottomEdge
        push    eax
        CALLFAR16IND lpfnGetAutoPanMode,es,ax

        cmp     ax,0
        je      NoAutoPanRegKey

        ; Make sure the PhysicalViewport in the registry is smaller
        ; than the virtual mode.
        mov     ecx,pGNLogDevCXOffset
        movzx   edx,ds:[ecx].GNLOGDEVCX.Dibeng.deWidth
        cmp     edx,dwRightEdge
        jl      NoAutoPanRegKey
        movzx   edx,ds:[ecx].GNLOGDEVCX.Dibeng.deHeight
        cmp     edx,dwBottomEdge
        jl      NoAutoPanRegKey

        ; Make sure that the PhysicalViewport in the registry is the
        ; same dimensions as the mode that was set.
        sub     ebx,ebx
        lfs     bx,ds:[edi].GNCRTCCX.lpCrtcModeOut
        movzx   eax,fs:[ebx].MODEOUT.wXRes
        mov     edx,dwRightEdge
        sub     edx,dwLeftEdge
        cmp     eax,edx
        jne     NoAutoPanRegKey
        movzx   eax,fs:[ebx].MODEOUT.wYRes
        mov     edx,dwBottomEdge
        sub     edx,dwTopEdge
        cmp     eax,edx
        jne     NoAutoPanRegKey

SetScanLineStart:
        ; Use registry entry to set scanline start and freeze origin.
        mov     ds:[edi].GNCRTCCX.dwPanAndScanEnabled,0
        mov     eax,dwTopEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,eax
        mov     eax,dwLeftEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,eax
        mov     eax,dwBottomEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax
        mov     eax,dwRightEdge
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        jmp     DoPanSet

NoAutoPanRegKey:
        ; No AutoPanMode registry entry start in upper left hand corner
        ; and enable PanAndScan.
        mov     ds:[edi].GNCRTCCX.dwPanAndScanEnabled,1
        lea     ebx,ds:[edi].GNCRTCCX.sCrtcModeInfo
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwLeft,0
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwTop,0
        mov     eax,ds:[ebx].MODEINFO.dwXRes
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwRight,eax
        mov     eax,ds:[ebx].MODEINFO.dwYRes
        mov     ds:[edi].GNCRTCCX.rcPhysicalViewport.dwBottom,eax

DoPanSet:
        push    edi
        call    GN_SetPanRectangle

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDisplayDevice
;
; Purpose:      This routine gets called to get the desired display
;               device.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetDisplayDevice, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
LOCALD  LocalDevData
OPENPROC
        mov     ebx,pGNCrtcCXOffset

        ; Now let us get the display device
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.dwLogicalDeviceInstance
        push    ds:[ebx].GNCRTCCX.dwPhysicalDeviceInstance
        mov     ax,ss
        shl     eax,10h
        lea     ax,LocalDevData
        push    eax
        CALLFAR16IND lpfnGetDisplayDevice,es,ax
        or      ax,ax
        jne     GetTVFormat

        ; We didn't find one so setup for CRT0
        mov     LocalDevData,DEVTYPE_CRT
        jmp     SetDevData
        
GetTVFormat:
        ; Get the TV format from the ResMan. IF this is not a TV, the Format
        ; will be returned as 0.
        mov     ebx,pGNCrtcCXOffset
        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax

SetDevData:
        push    pGNCrtcCXOffset
        push    dword ptr LocalDevData
        call    GN_SetDevData
CLOSEPROC



;==============================================================================
;
; Function:     GN_SetCrtcGamma
;
; Purpose:      This function is called to set the gamma ramp.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;               pGammaRamp      ptr to gamma ramp
;                               256 words of red followed by
;                               256 words of greed followed by
;                               256 words of blue followed by
;                               Only the high byte of each
;                               word is relevant.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_SetCrtcGamma, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGammaRamp
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; First, copy the gamma table passed in
        mov     edi,pGammaRamp
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        mov     ecx,100H
@@:
        movzx   eax,byte ptr ds:[edi + 200H * 0 + 1]
        shl     eax,10H
        mov     ah,byte ptr ds:[edi + 200H * 1 + 1]
        mov     al,byte ptr ds:[edi + 200H * 2 + 1]
        add     edi,2
        mov     ds:[esi],eax
        add     esi,4
        dec     ecx
        jne     @B

        ; If we are in a palettized mode, then we are done!
        mov     esi,pGNCrtcCXOffset
        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        cmp     fs:[bx].MODEINFO.dwBpp,8
        je      Done

        lea     eax,[esi].GNCRTCCX.dwGammaTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetGamma
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetCrtcGamma
;
; Purpose:      This function is called to get the gamma ramp.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;               pGammaRamp      ptr to gamma ramp
;                               256 words of red followed by
;                               256 words of greed followed by
;                               256 words of blue followed by
;                               Only the high byte of each
;                               word is relevant.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_GetCrtcGamma, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pGammaRamp
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Copy the current gamma table to the passed in array ptr
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        mov     edi,pGammaRamp
        mov     ecx,100H
        sub     eax,eax
        sub     ebx,ebx
        sub     edx,edx
@@:
        mov     dh,ds:[esi + 0]
        mov     bh,ds:[esi + 1]
        mov     ah,ds:[esi + 2]
        add     esi,4
        mov     ds:[edi + 200H * 0],ax
        mov     ds:[edi + 200H * 1],bx
        mov     ds:[edi + 200H * 2],dx
        add     edi,2
        dec     ecx
        jne     @B

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetCrtcPalette
;
; Purpose:      This function is called to set the palette.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;               pPalette        ptr to palette
;                               256 dwords of XBGR
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_SetCrtcPalette, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   pPalette
PARMD   dwFirstIndex
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     edi,pGNCrtcCXOffset

        ; First, copy the gamma table passed in
        mov     esi,pPalette
        lea     edi,[edi].GNCRTCCX.dwPaletteTable
        mov     eax,dwFirstIndex
        lea     esi,[esi][eax * 4]
        lea     edi,[edi][eax * 4]
        mov     ecx,dwNumEntries
@@:
        mov     eax,ds:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,4
        dec     ecx
        jne     @B

        ; If we are not in a palettized mode, then we are done!
        mov     esi,pGNCrtcCXOffset
        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        cmp     fs:[bx].MODEINFO.dwBpp,8
        jne     Done

        lea     eax,[esi].GNCRTCCX.dwPaletteTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        push    dwFirstIndex
        push    dwNumEntries
        call    HW_SetPalette
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResetColorMap
;
; Purpose:      This function tells the hardware to reload the color
;               map -- either the palette or the gamma table, whichever
;               one is currently being used.
;
; Arguments:
;               ds              Context Selector
;               pGNCrtcCXOffset GNCRTCCX ptr
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GN_ResetColorMap, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNCrtcCXOffset

        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        cmp     fs:[bx].MODEINFO.dwBpp,8
        jne     IsGamma

IsPal:
        lea     eax,[esi].GNCRTCCX.dwPaletteTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetPalette
        jmp     DoneIt

IsGamma:
        lea     eax,[esi].GNCRTCCX.dwGammaTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetGamma
DoneIt:
        mov     eax,1
        POPR    esi
CLOSEPROC

CLOSESEG  _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDIBXIT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndibxit.asm
;
; Purpose:      This file streamlines the exit process on SetDIBitsToDevice
;               and StretchDIBits.
;
;               The code is kind of messy -- I don't understand what
;               is going on everywhere, but I just tried to optimize.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

EXPORT_ORDINAL_FOR_WRITE_PRINTER        TEXTEQU <269>
EXPORT_ORDINAL_FOR_GETDIBITS            TEXTEQU <441>
EXPORT_ORDINAL_FOR_POLYGON              TEXTEQU <36>
EXPORT_ORDINAL_FOR_ALLOCCSTODSALIAS     TEXTEQU <170>

;  From MSVC60/INCLUDE/OLENLS.H: 
;
;  A language ID is a 16 bit value which is the combination of a
;  primary language ID and a secondary language ID.  The bits are
;  allocated as follows:
;
;       +-----------------------+-------------------------+
;       |      Sublanguage ID   |   Primary Language ID   |
;       +-----------------------+-------------------------+
;        15                   10 9                       0   bit
;
;
;  Language ID creation/extraction macros:
;
;    MAKELANGID    - construct language id from primary language id and
;                    sublanguage id.
;    PRIMARYLANGID - extract primary language id from a language id.
;    SUBLANGID     - extract sublanguage id from a language id.
;
PRIMARY_LANG_MASK                       TEXTEQU <03FFh>

OPENSEG  _DATA, USE16, DATA
szGdi           DB      "GDI",0
szKernel        DB      "KERNEL",0
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bUseStretchDIBitsFastExit, bUseSetDIBitsFastExit
bUseSetDIBitsFastExit           DB      0
bUseStretchDIBitsFastExit       DB      0

PUBLIC  lpfnGdiCode03_20B7
lpfnGdiCode03_20B7      DD      0

PUBLIC  lpfnGdiCode03_2119
lpfnGdiCode03_2119      DD      0

CLOSESEG _NVTEXT32

OPENSEG  _NVTEXT16, USE16, CODE

PUBLIC  lpfnGdiCode43_165E
lpfnGdiCode43_165E      DD      0

PUBLIC  lpfnGdiCode03_20C9
lpfnGdiCode03_20C9      DD      0

PUBLIC  lpfnGdiCode25_01B8
lpfnGdiCode25_01B8      DD      0

PUBLIC  dwFlatKernelDataSeg
dwFlatKernelDataSeg     DD      0

PUBLIC  wKernelDataSeg, wLDTSelector
wKernelDataSeg          DW      0
wLDTSelector            DW      0

PUBLIC  dwTableRightToLeftLangIDs
dwTableRightToLeftLangIDs       LABEL   WORD
;       Arabic
DD      0001H
;       Hebrew.
DD      000DH
;       -1 signals the end of the table
DD      -1

szNlsLocalePath DB      "System\CurrentControlSet\Control\Nls\Locale",0

;==========================================================================
;
; Function:     GN_InitDibFastExit
;
; Purpose:      This routine inits stuff for the fast exit code on
;               SetDIBitsToDevice and StretchDIBits.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==========================================================================
DECPROC GN_InitDibFastExit, PASCAL, FRAME, FAR16
PARMD	lpNvmodeDispData
LOCALD  hLocaleKey
LOCALD  dwSize
LOCALS  szDefault,4
LOCALS  szDefaultLang,16
OPENPROC
        PUSHR   ds,esi,edi

        ; Clear these out to begin with
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[bUseSetDIBitsFastExit],0
        mov     ds:[bUseStretchDIBitsFastExit],0

        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]

        ; We are going to read the registry -- if we are on Arabic
        ; or Hebrew Windows (right to left reading languages), then
        ; we cannot do this patch.
        pushd   HKEY_LOCAL_MACHINE      ; hKey
        mov     ax,cs
        lea     ebx,szNlsLocalePath
        push    ax
        push    bx                      ; lpSubKey
        lea     ebx,hLocaleKey
        mov     ax,ss
        push    ax
        push    bx                      ; phkResult
        call    RegCreateKey
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done

        ; Read the "" string in this key. It should be equal
        ; to something like: "00000401" or "0000040D"  -- it
        ; will be the string version of a language identifier.
        sub     ecx,ecx
        mov     szDefault[0],cl
        mov     szDefaultLang[0],cl
        mov     dwSize,16
        mov     ax,ss
        shl     eax,10H
        push    hLocaleKey
        lea     ax,szDefault
        push    eax
        push    ecx
        push    ecx
        lea     ax,szDefaultLang
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx
        shl     edx,10H
        mov     dx,ax
        mov     edi,edx

        ; close the key
        push    hLocaleKey
        call    RegCloseKey

        ; If there was an error reading, then to be safe, leave
        ; the fast dib stuff off.
        cmp     edi,ERROR_SUCCESS
        jne     Done

        ; Convert the language ID returned to a number
        sub     edx,edx
        sub     ebx,ebx
        sub     eax,eax
@@:
	add	ebp,ebx
        movzx   ecx,byte ptr szDefaultLang
	sub	ebp,ebx
        cmp     ecx,'0'
        jc      NoMoreDigits
        cmp     ecx,'9'
        jbe     FoundNumber
        cmp     ecx,'A'
        jc      NoMoreDigits
        cmp     ecx,'F'
        jbe     FoundHexCap
        cmp     ecx,'a'
        jc      NoMoreDigits
        cmp     ecx,'f'
        ja      NoMoreDigits
FoundHexSmall:
        sub     ecx, 'a' - 10
        jmp     NextDigit
FoundHexCap:
        sub     ecx, 'A' - 10
        jmp     NextDigit
FoundNumber:
        sub     ecx, '0'
NextDigit:
        imul    eax,10H
        add     eax,ecx
        inc     ebx
        jmp     @B

NoMoreDigits:
        and     eax, PRIMARY_LANG_MASK

        ; Compare the primary language ID returned against all the
        ; right to left language IDs. If it matches any one of them,
        ; then no fast dib exit.
        mov     edi, OFFSET dwTableRightToLeftLangIDs
@@:
        mov     ebx, cs:[edi]
        add     edi, 4
        cmp     ebx, -1
        je      NoMatch
        cmp     eax, ebx
        jne     @B
        jmp     Done
NoMatch:

	push	lpNvmodeDispData
        CALLFAR16IND lpfnGetControlVisionFlag,es,ax
	cmp	ax,0FEH
	jne	Done

        ; Get GDI module handle
        mov     ax,_DATA
        mov     cx,OFFSET szGdi
        push    ax
        push    cx
        call    GetModuleHandle
        mov     si,ax

        ; I need the selector value of GDI code segment 43 and the
        ; WRITE_PRINTER function happens to be in Gdi Code segment 43.
        push    si
        pushd   EXPORT_ORDINAL_FOR_WRITE_PRINTER
        call    GetProcAddress
        shl     edx,10H
        or      edx,edx
        je      Done
        mov     dx,165EH
        mov     ds:[lpfnGdiCode43_165E],edx

        ; I need the selector value of GDI code segment 3 and the
        ; GetDIBits function happens to be in Gdi Code segment 3.
        push    si
        pushd   EXPORT_ORDINAL_FOR_GETDIBITS
        call    GetProcAddress
        shl     edx,10H
        or      edx,edx
        je      Done
        mov     dx,20C9H
        mov     ds:[lpfnGdiCode03_20C9],edx

        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     dx,2119H
        mov     ds:[lpfnGdiCode03_2119],edx
        mov     dx,20B7H
        mov     ds:[lpfnGdiCode03_20B7],edx

        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]

        ; I need the selector value of GDI code segment 25 and the
        ; Polygon function happens to be in Gdi Code segment 25.
        push    si
        pushd   EXPORT_ORDINAL_FOR_POLYGON
        call    GetProcAddress
        shl     edx,10H
        or      edx,edx
        je      Done
        mov     dx,01B8H
        mov     ds:[lpfnGdiCode25_01B8],edx

        ; Get the module handle for KERNEL
        mov     ax,_DATA
        mov     cx,OFFSET szKernel
        push    ax
        push    cx
        call    GetModuleHandle
        mov     si,ax

        ; I need the Kernel Data selector which is in the Kernel Code
        ; segment 1 and offset 2. AllocCSToDSAlias is in Kernel Code Seg 1.
        push    si
        pushd   EXPORT_ORDINAL_FOR_ALLOCCSTODSALIAS
        call    GetProcAddress
        or      dx,dx
        je      Done
        mov     di,dx

        ; Get the kernel data seg and the flat data seg pointer.
        ; The fast exit code requires that the Data seg selector be
        ; an LDT selector and not a GDT selector.
        mov     es,di
        sub     ebx,ebx
        movzx   eax,word ptr es:[ebx + 02H]
        test    eax,4
        jz      Done
        mov     ds:[wKernelDataSeg],ax
        push    ax
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        mov     ds:[dwFlatKernelDataSeg],edx

        ; Get the selector which points to the base of the LDT.
        ; The fast exit code requires that this selector be
        ; an LDT selector and not a GDT selector.
        mov     es,di
        sub     ebx,ebx
        movzx   eax,word ptr es:[ebx + 06H]
        test    eax,4
        jz      Done
        mov     ds:[wLDTSelector],ax

        ; Everything worked! Set the flags saying we can do fast exit.
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[bUseSetDIBitsFastExit],1
        mov     ds:[bUseStretchDIBitsFastExit],1

Done:
        POPR    ds,esi,edi
CLOSEPROC


;==========================================================================
;
; Function:     GdiCode03_2119
;               GdiCode03_217C
;
; Purpose:      This is the routine we return to from SetDibBitsToDevice.
;               It is in GDI Code segment 3 at offset 2119. We pick up
;               execution at this point.
;               StretchDIBits initially returns to Gdi Code segment 3
;               at offset 20B7. But almost always (and the only time we
;               come here), goes on to Gdi Code segment 3 at offset 217C.
;
; Arguments:    eax     Return Value from SetDIBitsToDevice
;               20H bytes of parameters
;               STACK:  CODE3:2119
;               OldEbp
;
; Returns:      None
;
; Preserve:     ds,es,fs
;==========================================================================
GdiCode03_2119	PROC    FAR16
        ; Don't know what this test is for, but do it
        test    byte ptr ss:[di + 02H],40H
        jz      G3_20C9
        .errnz  $ - OFFSET GdiCode03_217C
GdiCode03_2119	ENDP

GdiCode03_217C	PROC    FAR16
        ; We may need to free this handle
        cmp     word ptr ss:[bp - 28H],0
        jne     G3_2183

G3_2189:
        ; I don't know what this does.
        cmp     dword ptr ss:[bp - 32H],0
        jne     G3_2192

G3_2199:
        ; I don't know what this does.
        and     byte ptr ds:[si + 00FEH],0EFH

        ; I know this test has to do with ICM. If ICM was involved
        ; then we jump and clear out the ICM ptr. That's all I know.
        test    byte ptr ds:[si + 00B6H],80H
        jnz     G3_21A9

G3_21B1:
        ; Clear these off to go "out" to the next routine
        pop     edi
        pop     si
        pop     cx
        mov     ds,cx
        mov     sp,bp
        pop     bp

        ; Check the return address. It must be Code43:165E or
        ; we cannot handle it ourselves
        mov     ecx,cs:[lpfnGdiCode43_165E]
        movzx   ebx,sp
        cmp     ecx,ss:[ebx]
        je      G43_165E
        RETFAR16 20H

PLABEL  G3_20C9
        ; This path doesn't seem to happen much in the benchmark,
        ; so I will just jmp back in line to the correct place.
        mov     ss:[bp - 02H],ax
        jmp     FFP16 PTR cs:[lpfnGdiCode03_20C9]

G3_2183:
        ; Free the handle
        push    eax
        push    word ptr ss:[bp - 28H]
        call    GlobalFree
        pop     eax
        jmp     G3_2189

G3_2192:
        push    eax
        push    dword ptr ss:[bp - 32H]
        call    FFP16 PTR cs:[lpfnGdiCode25_01B8]
        pop     eax
        jmp     G3_2199

G3_21A9:
        mov     dword ptr ds:[si + 006EH],0
        jmp     G3_21B1
GdiCode03_217C	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;==========================================================================
;
; Function:     G43_165E
;
; Purpose:      This is the routine we evetually end up at when we return
;               from SetDibBitsToDevice or StretchDIBits.
;               It is in GDI Code segment 43 at offset 165E -- G43_165E.
;
; Arguments:    eax     return value from SetDIBitsToDevice or
;                       StretchDIBits
;
; Returns:      None
;
; Preserve:     ds,es,fs
;==========================================================================
; These parameters are valid at this point.
dwSelectorColonFlag     TEXTEQU <dword ptr ss:[bp - 04H]>
wSelector1ToFree        TEXTEQU < word ptr ss:[bp - 02H]>
wSelector2ToFree        TEXTEQU < word ptr ss:[bp - 0AH]>

PUBLIC  G43_165E
G43_165E:
        ; This mimicks a RETFAR16 20H
        add     sp,24H

K2_7C9D:
        ; Save this guy!
        push    eax

        ; If both the selector and flag are zero, then nothing to free
        mov     eax,dwSelectorColonFlag
        or      ax,ax
        je      G43_166B
        test    eax,0FFFF0000H
        jz      G43_166B

        ; We will be needing the following register values throughout
        ; the routines so load them up now.
        mov     ds,cs:[wKernelDataSeg]
        mov     es,cs:[wLDTSelector]
        mov     fs,ds:[13A6H]

        ; Call the kernel routine to clean up one of the selectors
        ; it allocated to map a flat ptr for the thunk.
        movzx   edx,wSelector1ToFree
        call    K1_4BA0

G43_166B:
K1_593B:
        movzx   edx,wSelector2ToFree
        sub     edi,edi
        and     edx,0FFFFFFF8H
        je      K1_59BD

        movzx   eax,word ptr ds:[edi + 1A50H]
        sub     ecx,ecx
        mov     es:[edx + 00H],eax
        mov     es:[edx + 04H],ecx
        mov     ds:[edi + 1A50H],dx
        inc     word ptr ds:[edi + 1A52H]

K1_5970:
        cmp     word ptr ds:[edi + 1A52H],2AH
        jc      K1_59BD
        dec     word ptr ds:[edi + 1A52H]
        mov     ds:[edi + 1A50H],ax
        mov     dword ptr es:[edx + 00H],1
        mov     dword ptr es:[edx + 04H],0F300H
        or      edx,7
        call    K1_4BA0
        sub     edi,edi
        jmp     K1_5970

K1_59BD:
G43_168F:
        ; Restore the return value
        pop     eax
        mov     ebx,34H
        mov     sp,bp
        RETFAR32

; This is the end of the routine G43_165E
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;==============================================================================
;
; Function:     K1_4BA0
;
; Purpose:      This function is my implementation of K1_4BA0 -- Kernel
;               code segment 1, the routine at offset 4BA0. K1_4BA0
;               actually calls a number of other routines which call
;               other routines, etc. I have flattened the whole thing
;               and eliminated ALOT of code. I have tried to put
;               labels in my implementation that link to the correct
;               Kernel offset so that it is easier to see the
;               correspondence between the two.
;
; Arguments:    edx     selector to deal with
;
; Returns:      None
;
; Preserve:     ds,es,fs
;==============================================================================
PUBLIC  K1_4BA0
K1_4BA0:
K1_356A:
K1_356F:
        sub     edi,edi
        mov     gs,ds:[121EH]

        ; I don't know what this is for
        cmp     edi,ds:[12E0H]
        je      K1_358D

K1_7F14:
        ; I don't know what this does
        mov     ebx,1364H
        mov     ecx,ds:[12E4H]
        mov     ecx,fs:[ecx]
        inc     dword ptr fs:[ecx + 38H]
        dec     dword ptr ds:[ebx + 10H]
        jne     K1_7F37
        inc     dword ptr ds:[ebx + 04H]
        mov     ds:[ebx + 08H],ecx
        jmp     K1_358D
K1_7F37:
        cmp     ds:[ebx + 08H],ecx
        jne     K1_7F43
        inc     dword ptr ds:[ebx + 04H]

K1_358D:
        ; I don't know what this does
        inc     word ptr gs:[edi + 1EH]

K1_4BAB:
K1_555D:
        ; Updating special arena area to indicate selector is going away.
        ; This is NOT the LDT.
        mov     gs,ds:[13AAH]
        mov     eax,ds:[1234H]
        mov     ebx,edx
        and     ebx,0FFFFFFF8H
        shr     ebx,1
        mov     gs:[eax + ebx],edi

K1_4BC2:
K1_4C85:
        ; Assume just 1 selector in the tile
        mov     ecx,1

        ; Make sure the selector is valid
        lar     ax,dx
        jne     K1_4CBD

        ; Test for system segment
        test    ah,10H
        jz      K1_4CBD

        ; Test for segment present
        test    ah,80H
        jz      K1_4CA4

K1_4CB1:
        ; Segment is present. The number of tiled selectors is
        ; the number of 64K chunks in the selector limit. If lsl
        ; fails, then ecx is unchanged -- i.e. just 1 selector.
        lsl     ecx,edx
        jnz     K1_4CBD
        shr     ecx,10H
        inc     ecx

K1_4CBD:
K1_4BF0:
        cmp     edi,ds:[12E0H]
        je      K1_4C18

K1_4C10:
K1_7F00:
K1_7E8E:
K1_7F0A:
K1_7D85:
        mov     eax,ds:[12E4H]
        mov     ebx,1364H
        mov     eax,fs:[eax]
        inc     dword ptr fs:[eax + 38H]
        dec     dword ptr ds:[ebx + 10H]
        je      K1_7DCD
        cmp     eax,ds:[ebx + 08H]
        jne     K1_7DB5
        inc     dword ptr ds:[ebx + 04H]
        jmp     K1_7DE9
K1_7DB5:
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0AH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_7DE9
K1_7DCD:
        inc     dword ptr ds:[ebx + 04H]
        mov     ds:[ebx + 08H],eax

K1_7DE9:
K1_4C18:
        mov     ebx,edx
        and     ebx,00000FFF8H
        mov     esi,ebx
        shr     esi,1
        cmp     si,ds:[1232H]
        jnc     K1_4C52

K1_4C30:
        ; The unused descriptors in the LDT are a linked list!
        ; ds:[13ACH] points to the head and ds:[13AEH] is the
        ; number of unused descriptors (e.g. selectors). The
        ; low word of a descriptor entry gives the next selector
        ; that is unused.
        movzx   esi,word ptr ds:[13ACH]
        inc     word ptr ds:[13AEH]
        movzx   eax,word ptr es:[esi]
        mov     es:[esi],bx
        mov     es:[ebx],ax
        mov     word ptr es:[ebx + 02H],di
        mov     dword ptr es:[ebx + 04H],0F0000H

K1_4C60:
        ; Once again -- don't know what this stuff does
        cmp     edi,ds:[12E0H]
        je      K1_4C76

K1_4C73:
K1_7FD1:
K1_7FDC:
K1_7DF2:
        mov     ebx,1364H
        dec     dword ptr ds:[ebx + 04H]
        je      K1_7E08
        inc     dword ptr ds:[ebx + 10H]
        jmp     K1_7E2C
K1_7E08:
        mov     ds:[ebx + 08H],edi
        inc     dword ptr ds:[ebx + 10H]
        jle     K1_7E1A

K1_7E2C:
K1_7FDF:
K1_7EA9:
        mov     eax,ds:[12E4H]
        mov     eax,fs:[eax]
        dec     dword ptr fs:[eax + 38H]
        jne     K1_7EFF
        cmp     edi,fs:[eax + 4CH]
        je      K1_7EFF
        mov     ah,12H
        call    FFP16 PTR ds:[1A80H]
        mov     eax,ds:[12E0H]
        mov     eax,fs:[eax]
        btr     dword ptr fs:[eax + 44H],7
        jnc     K1_7EFF
        movzx   eax,sp
        mov     ax,ss:[eax + 0FFFFF000H]
K1_7EFF:
K1_7FE2:
K1_4C76:
K1_4CC1:
        add     edx,8
        dec     ecx
        jne     K1_4CBD

K1_4CCB:
K1_4BDE:
K1_4BE4:
K1_359D:
        mov     gs,ds:[121EH]
        dec     word ptr gs:[edi + 1EH]
        jne     K1_35B2
        test    word ptr gs:[edi + 44H],1
        jz      K1_35B2
        and     word ptr gs:[edi + 44H],-2
        int     2
K1_35B2:
        cmp     edi,ds:[edi + 12E0H]
        je      K1_35D2

K1_35C9:
K1_7F56:
        mov     ebx,1364H
        dec     dword ptr ds:[ebx + 04H]
        jne     K1_7FA4
        mov     ds:[ebx + 08H],edi
        inc     dword ptr ds:[ebx + 10H]
        jle     K1_7F8E
K1_7F6C:
        mov     eax,ds:[edi + 12E4H]
        mov     eax,fs:[eax]
        dec     dword ptr fs:[eax + 38H]
        jne     K1_7F8B
        cmp     edi,fs:[eax + 4CH]
        jne     K1_7FAA
        jmp     K1_7F8B

K1_7FA4:
        inc     dword ptr ds:[ebx + 10H]
        jmp     K1_7F8B
K1_7FAA:
        mov     ah,12H
        call    FFP16 PTR ds:[1A80H]
        mov     eax,ds:[edi + 12E0H]
        mov     eax,fs:[eax]
        btr     dword ptr fs:[eax + 44H],7
        jnc     K1_7F8B
        movzx   eax,sp
        mov     ax,ss:[eax + 0FFFFF000H]
        jmp     K1_7F8B

K1_7F8B:
K1_35D2:
K1_4BED:
        ret

; This is the end of routine K1_4BA0. We need it a few times, so
; we made it a sub-routine.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

K1_7F43:
K1_5830:
        ; Make a flat ptr to wKernelDataSeg+1364H and
        ; Service to main VDD -- I don't know what it does
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0AH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_358D

K1_4CA4:
        ; If the segment is not present then Windows stores the
        ; number of contiguous tiled selectors in the top byte
        ; of the LDT entry for the selector.
        movzx   ecx,byte ptr es:[ebx + 07H]
        jmp     K1_4CBD

K1_7E1A:
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0BH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_7E2C

K1_7F8E:
        add     ebx,cs:[dwFlatKernelDataSeg]
        mov     ah,0BH
        call    FFP16 PTR ds:[1A80H]
        jmp     K1_7F6C

K1_4C52:
        or      ebx,7
        mov     eax,1
        int     31H
        jmp     K1_4C60

CLOSESEG  _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDISABL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndisabl.asm
;
; Purpose:      This file holds the Disable display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include minivdd.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_Disable
;
; Purpose:      This function is the Disable display driver entry point.
;               It handles proper device disabling in a multi-monitor
;               environment.
;
; Arguments:    lpDstDev  - The device to disable.
;
; Returns:      eax     should always be set to -1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Disable, PASCAL, FRAME, FAR16
PARMD   lpDstDev
LOCALD  dwRet
LOCALD  dwVddDeviceHandle
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; Split into primary and secondary cases
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        je      AsIfPrimary

        ; Enable access to the secondary device
        mov     dwRet,0
        pushd   ENABLE_ALL
        call    GN_VddEnableDevice
        cmp     eax,ENABLE_ERROR
        je      done

AsIfPrimary:
        ; This is either the primary device or it is a secondary device
        ; with full access turned on. We can disable the device now.
        push    esi
        call    GN_DisableDevice
        mov     dwRet,eax

        ; If we are a secondary, we have a few things to clean up.
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        je      done

        ; Turn off all access to our device.
        pushd   ENABLE_NONE
        call    GN_VddEnableDevice

        ; We are done with the secondary device -- close it
        call    GN_VddCloseDevice
done:
        mov     eax,dwRet
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DisableDevice
;
; Purpose:      This function does the disabling once a specific device has
;               been selected.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX
;
; Returns:      eax     should always be set to -1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DisableDevice, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNLogdevCXOffset

        ; If we are not "attached to the desktop", then
        ; don't blank the screen.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      SkipBlankScreen

        ; Don't access to the FB if we're in powerdown
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jne     SkipBlankScreen
        
        push    pGNLogdevCXOffset
        call    GN_BlankScreen

SkipBlankScreen:
        ; Let the DIBENG do its thing
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        call    DIB_Disable

        ; Send a message down to disable the device
        push    esi
        pushd   MSG_DISABLE
        push    esi
        push    cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    GN_LogdevMessage

        ; Free the primary surface memory.
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_FreeLogicalSurface
        
        ; Don't access to the FB if we're in powerdown
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jne     SkipBlankScreen1
        
        ; Blank the screen. If we just rely on the earlier GN_BlankScreen,
        ; then when we free the logical surface, tiling may be disabled which
        ; can cause garbage on the screen. However, if we don't do the earlier
        ; GN_BlankScreen, we get a flash of garbage when the surface is
        ; untiled.
        push    pGNLogdevCXOffset
        call    GN_BlankScreen

SkipBlankScreen1:
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
@@:

        ; Enable IO trapping if we are not a secondary device.
        ; The GN_VddEnableIOTrapping checks the device ID.
        pushd   1
        call    GN_VddEnableIOTrapping
        POPR    esi

        ; Return Success
        mov     eax,-1
CLOSEPROC


;==============================================================================
;
; Function:     GN_BlankScreen
;
; Purpose:      This function blts black to the screen.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_BlankScreen, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
OPENPROC
        PUSHR   ds,es,esi,edi

        ; Clear the screen to black so there won't be wierd artifacts
        ; if we switch back to a lower resolution mode.
        mov     esi,pGNLogdevCXOffset

        ; Make sure we have the primary surface
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      GN_BlankScreen_Exit

        ; Check DOS FS or power state.
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jne     GN_BlankScreen_Exit

        ; We can't use DIBENG at this point because
        ; CSpGNLogicalDevice_In_NVTEXT16 not initialize yet.
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        movzx   ebx,word ptr ds:[esi].DIBENGINE.deHeight
        imul    ecx,ebx
        shr     ecx,2
        mov     es,ds:[esi].DIBENGINEHDR.deBitsSelector
        mov     edi,ds:[esi].DIBENGINEHDR.deBitsOffset
        sub     eax,eax
        rep     stos dword ptr es:[edi]

GN_BlankScreen_Exit:
        POPR    ds,es,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNGAMMA.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gngamma.asm
;
; Purpose:      This file holds the GammaRamp display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_GammaRamp
;
; Purpose:      This function is the GammaRamp display driver entry point.
;
; Arguments:    GammaRamp Display Driver Stack Frame
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GENERIC_GammaRamp, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGetSet
PARMD   lpGammaRamp
LOCALD  dwCRTCCount
LOCALD  pGammaRamp
OPENPROC
        PUSHR   ds,esi,edi

        ; Load up the GNLOGDEVCX
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Get a flat ptr to the gamma ramp
        movzx   eax,word ptr lpGammaRamp+2
        push    eax
        call    GN_GetSelectorBase
        movzx   edx,word ptr lpGammaRamp+0
        add     eax,edx
        mov     pGammaRamp,eax

        ; Run through all the CRTCs attached to this logical device
        ; and program them all, or get the gamma ramp from the first.
        ; The first is sufficient on a Get since if there is more
        ; than 1 CRTC attached, then we are in CLONE mode.
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX

Loopit3:
        ; Now call to set this mode
        cmp     dword ptr ds:[edi],0
        je      SkipIt3
        cmp     fGetSet,0
        jne     SetGamma
GetGamma:
        push    dword ptr ds:[edi]
        push    pGammaRamp
        call    GN_GetCrtcGamma
        jmp     DoneIt

SetGamma:
        push    dword ptr ds:[edi]
        push    pGammaRamp
        call    GN_SetCrtcGamma
SkipIt3:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
	cmp	eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loopit3

DoneIt:
        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNINIT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gninit.asm
;
; Purpose:      This file holds the DllEntryPoint code.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include escape.inc

OPENSEG  _DATA, USE16, DATA
szModeSetDll            DB      "nvmode.dll",0
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  CSlp16LogDevice
CSlp16LogDevice                 DD      0

PUBLIC  CSpGNLogicalDevice
CSpGNLogicalDevice              DD      0

PUBLIC  wNVTEXT32_Alias_In_NVTEXT32
wNVTEXT32_Alias_In_NVTEXT32     DW      0

PUBLIC  wNVTEXT16_Alias_In_NVTEXT32
wNVTEXT16_Alias_In_NVTEXT32     DW      0

PUBLIC  wFlatDataSel
wFlatDataSel                    DW      0
CLOSESEG _NVTEXT32


OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  CSlp16LogDevice_In_NVTEXT16
CSlp16LogDevice_In_NVTEXT16     DD      0

PUBLIC  CSpGNLogicalDevice_In_NVTEXT16
CSpGNLogicalDevice_In_NVTEXT16  DD      0

PUBLIC  wNVTEXT32_Alias_In_NVTEXT16
wNVTEXT32_Alias_In_NVTEXT16     DW      0

PUBLIC  wNVTEXT16_Alias_In_NVTEXT16
wNVTEXT16_Alias_In_NVTEXT16     DW      0

PUBLIC  wFlatDataSel_In_NVTEXT16
wFlatDataSel_In_NVTEXT16        DW      0

PUBLIC  ModesetTable
ModesetTable  LABEL   WORD
DW      OFFSET szModeSetDll, SEG szModeSetDll
hModesetDll                     DW              0
lpfnFindModeEntry                       MODULELINK      <0, 1>
lpfnFindVirtualModeEntry                MODULELINK      <0, 2>
lpfnGetModeList                         MODULELINK      <0, 3>
lpfnGetDesktopModeList                  MODULELINK      <0, 4>
lpfnSetVirtualDesktop                   MODULELINK      <0, 5>
lpfnGetVirtualDesktop                   MODULELINK      <0, 6>
lpfnSetDesktopState                     MODULELINK      <0, 7>
lpfnGetDesktopState                     MODULELINK      <0, 8>
lpfnGetBootDevice                       MODULELINK      <0, 9>
lpfnGetDisplayDevice                    MODULELINK      <0, 10>
lpfnSetDisplayDevice                    MODULELINK      <0, 11>
lpfnGetRefreshRateForDesktop            MODULELINK      <0, 12>
lpfnGetForcedDesktopMode                MODULELINK      <0, 13>
lpfnGetLargestEdidMode                  MODULELINK      <0, 14>
lpfnGetDeviceDesktopMode                MODULELINK      <0, 15>
lpfnSetDeviceDesktopMode                MODULELINK      <0, 16>
lpfnGetForcedDisplayMode                MODULELINK      <0, 17>
lpfnGetDeviceDisplayMode                MODULELINK      <0, 18>
lpfnSetDeviceDisplayMode                MODULELINK      <0, 19>
lpfnGetEdidRegistryKey                  MODULELINK      <0, 20>
lpfnGetLocalNvidiaDisplayRegValue       MODULELINK      <0, 21>
lpfnGetLocalNvidiaDisplayRegString      MODULELINK      <0, 22>
lpfnDeleteLocalRegEntry                 MODULELINK      <0, 23>
lpfnResetRefreshRates                   MODULELINK      <0, 24>
lpfnGetSafeTiming                       MODULELINK      <0, 25>
lpfnSetResolutionAndColorDepth          MODULELINK      <0, 26>
lpfnSetAutoPanMode                      MODULELINK      <0, 27>
lpfnGetAutoPanMode                      MODULELINK      <0, 28>
lpfnSetTimingOverride                   MODULELINK      <0, 29>
lpfnGetTimingOverride                   MODULELINK      <0, 30>
lpfnGetControlVisionFlag                MODULELINK      <0, 31>
lpfnGetBootDeviceSelection              MODULELINK      <0, 32>
lpfnIsDriverAttachedToDesktop           MODULELINK      <0, 33>
lpfnGetAllowAllModesFlag                MODULELINK      <0, 34>
lpfnGetAllowMightyModesFlag             MODULELINK      <0, 35>
lpfnGetCheckSXGAPanelFlag               MODULELINK      <0, 36>
lpfnGetClonePanningFlag                 MODULELINK      <0, 37>
lpfnSetClonePanningFlag                 MODULELINK      <0, 38>
lpfnDisplayDriverControl                MODULELINK      <0, 39>
lpfnFreeMasterLists                     MODULELINK      <0, 40>
lpfnGetCloneDesktopSelection            MODULELINK      <0, 41>
lpfnGetRestrictLargestMode              MODULELINK      <0, 42>
lpfnGet1400x1050Override                MODULELINK      <0, 43>
lpfnGetMaxDfpMode                       MODULELINK      <0, 44>
lpfnGetModesetStopImage                 MODULELINK      <0, 45>
                                        MODULELINK      <0, 0>

;==============================================================================
;
; Function:     DllEntryPoint
;
; Purpose:      The OS calls this function immediaetly after the DLL
;               loads. We don't do anything here.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DllEntryPoint, PASCAL, NOFRAME, FAR16
OPENPROC
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_DllEntryPoint
;
; Purpose:      This routine does all the global init for the driver.
;               It should be called by Enable the very first time the
;               driver loads.
;
; Arguments:
;               lpDstDevType            We can use this to get the
;                                       logical devic handle from the
;                                       minivdd
;               lpThisGdiInfo           GDIINFO ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DllEntryPoint, PASCAL, FRAME, FAR16
PARMD   lpDstDevType
PARMD   lpThisGdiInfo
LOCALV  sDispInfo,DISPLAYINFO
LOCALD  dwDesktopState
LOCALD  pGNLogdevCXOffset
LOCALD  pGNBoardCXOffset
LOCALD  dwFirstBoardContext
OPENPROC
        PUSHR   ds,esi,edi

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Constants Creation
        push    lpDstDevType
        call    GN_CreateConstants
        or      eax,eax
        je      FailIt_00

IFDEF DEBUG
        ; Catch driver loading for the debugger
        mov     eax,1
        CALLFAR16IND lpfnDisplayDriverControl,es,bx
ENDIF

        call    HW_CreateConstants
        or      eax,eax
        je      FailIt_0

        ; This will keep throughout the routine
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]

        ; See if we already have an attachment to the board
        ; We need to get the board dev node handle. One way
        ; is through the GetDisplayInfo call.
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        push    eax
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo

        ; See if a GNBOARDCX already exists for this board
        push    sDispInfo.diDevNodeHandle
        call    GN_FindBoardContext
        mov     dwFirstBoardContext,0
        or      eax,eax
        jne     DoneBoard

First:
        mov     dwFirstBoardContext,1

        ; Create the GNBOARDCX
        push    cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    GN_CreateBoardContext
        or      eax,eax
        je      FailIt_1

DoneBoard:
        mov     pGNBoardCXOffset,eax

        ; Now create our logical device context
        push    pGNBoardCXOffset
        call    GN_CreateLogdevContext
        or      eax,eax
        je      FailIt_2
        mov     pGNLogdevCXOffset,eax

        ; We usually only need to attach children to their parents,
        ; but in this one special case we need to attach a parent
        ; to the child. Attach this logical device to the board.
        push    pGNBoardCXOffset
        push    pGNLogdevCXOffset
        call    GN_AttachLogicalDeviceToBoard
        or      eax,eax
        je      FailIt_3
        mov     esi,pGNLogdevCXOffset
        mov     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,ecx

        ; Se the GDIINFO ptr
        push    pGNLogdevCXOffset
        push    lpThisGdiInfo
        call    GN_SetGdiInfoPtr

        ; Save off the ptr
        mov     esi,pGNLogdevCXOffset
        mov     es,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     es:[CSpGNLogicalDevice_In_NVTEXT16],esi
        mov     es,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     es:[CSpGNLogicalDevice],esi

        ; The init can handle having more logical devices on the
        ; board than the board has CRTCs. This may seem weird,
        ; but abstractly it works. We limit it here as an external
        ; condition.
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        cmp     eax,ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        jbe     FailIt_4

        ; If the secondry driver is not enabled ("AttachedToDesktop"),
        ; then don't create any CRTCCXs since we will be unloaded immed.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      DoneClone

        ; Before we get any farther, figure out if we need to make
        ; modifications to the device connections. This is largely
        ; for mobile support.
        push    esi
        call    GN_ResolveDeviceConnectionsOnLoad

        ; Attach a CRTC to this logical device
        push    pGNLogdevCXOffset
        call    GN_LogdevAttachCrtc
        or      eax,eax
        je      FailIt_5

        ; Determine this driver's desktop state -- clone or standard.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10h
        lea     ax,dwDesktopState
        push    eax
        call    FFP16 PTR cs:[lpfnGetDesktopState]
        cmp     dwDesktopState,NVTWINVIEW_STATE_CLONE
        jne     DoneClone

        ; Attach a second CRTC to this logical device
        push    pGNLogdevCXOffset
        call    GN_LogdevAttachCrtc
        or      ax,ax
        jne     DoneClone

        ; Don't fail if there wasn't a device to use as a
        ; clone device. Just revert to standard mode.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_NORMAL
        CALLFAR16IND lpfnSetDesktopState,es,ax

DoneClone:
        ; Setup control offscreen allocations callbacks
        ; for the primary device
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     Secondary
        call    GN_VddSetLockAndUnlockOffscreen
        call    GN_VddSetPowerManagementCallbacks

Secondary:
        mov     eax,1
        jmp     DoneIt

FailIt_6:
FailIt_5:
FailIt_4:
        push    pGNBoardCXOffset
        push    pGNLogdevCXOffset
        call    GN_DetachLogicalDeviceFromBoard

FailIt_3:
        push    pGNLogdevCXOffset
        call    GN_DestroyLogdevContext

FailIt_2:
        cmp     dwFirstBoardContext,0
        je      FailIt_1
        push    pGNBoardCXOffset
        call    GN_DestroyBoardContext

FailIt_1:
        push    dwThisLogicalDeviceHandle_In_NVTEXT16
        call    HW_DestroyConstants

FailIt_0:
        call    GN_DestroyConstants
        sub     eax,eax

FailIt_00:
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GENERIC_WEP
;
; Purpose:      This function is the WEP entry point.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve      ds,esi,edi
;==============================================================================
PUBLIC  WEP
WEP     PROC    FAR16
        ; Windows requires that WEP be exported by name. I have the
        ; real routine GENERIC_WEP equated to the same address.
        .errnz  $ - OFFSET GENERIC_WEP
WEP     ENDP

DECPROC GENERIC_WEP, PASCAL, FRAME, FAR16
LOCALD  dwCRTCCount
LOCALD  dwLogdevAttachedToBoard
LOCALD  pGNBoardContext
LOCALD  pGNBoardCXOffset
LOCALD  dwDriverEnabled
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        ; Catch driver unloading for the debugger
        mov     eax,0
        CALLFAR16IND lpfnDisplayDriverControl,es,bx
ENDIF

        ; Check to see how far in the creation process we got.
        ; We are guaranteed from the way GN_DllEntryPoint is
        ; written that if wNVTEXT16_Alias_In_NVTEXT16 is non-0,
        ; then we have a GNLOGDEVCX created.
        cmp     cs:[wNVTEXT16_Alias_In_NVTEXT16],0
        je      DoneIt

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,CSpGNLogicalDevice_In_NVTEXT16

        ; Sometimes disable doesn't get called, but WEP does
        ; and we see a flash of garbage when shutting down.
        ; This may prevent that. Windows clears the AttachToDesktop
        ; flag before calling WEP!! So, check to see if we
        ; created a primary CRTCCX to know if this driver was
        ; really enabled or not -- unh!
        mov     eax,dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     dwDriverEnabled,eax

        cmp     dwDriverEnabled,0
        je      @F
        push    esi
        call    GN_BlankScreen
@@:
        ; Tell everyone that we are unloading.
        sub     eax,eax
        push    esi
        pushd   MSG_DISPLAY_DRIVER_UNLOADING
        push    eax
        push    eax
        call    GN_LogdevMessage

        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     pGNBoardCXOffset,eax

        ; One less logical device on this board
        push    pGNBoardCXOffset
        push    esi
        call    GN_DetachLogicalDeviceFromBoard
        mov     dwLogdevAttachedToBoard,eax

        cmp     dwDriverEnabled,0
        je      @F
        cmp     dwLogdevAttachedToBoard,0
        je      @F
        ; The secondary driver is being unloaded. Tell ResMan we are
        ; leaving spanning mode.
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        pushd   0
        call    HW_TellResManSpanningState
@@:
        ; Destroy the logical device context
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     pGNBoardContext,eax
        push    esi
        call    GN_DestroyLogdevContext

        cmp     dwDriverEnabled,0
        je      @F
        cmp     dwLogdevAttachedToBoard,0
        je      @F
        ; We might want to change display device configurations now
        mov     eax,pGNBoardCXOffset
        push    dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX
        call    GN_ResolveDeviceConnectionsOnUnload
@@:
        cmp     dwLogdevAttachedToBoard,0
        jne     @F
        push    pGNBoardContext
        call    GN_DestroyBoardContext
@@:
        push    dwThisLogicalDeviceHandle_In_NVTEXT16
        call    HW_DestroyConstants

        call    GN_DestroyConstants

DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CreateConstants
;
; Purpose:      This functions should init any things that are
;               effectively constants in the driver. Usually these
;               are items that go in the code segment. This routine
;               is called only once at boot and no context has yet
;               been created.
;
; Arguments:    None
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateConstants, PASCAL, FRAME, FAR16
PARMD   lpDstDevType
OPENPROC
        PUSHR   ds

        ; Allocate a writable alias for the 16bit code segment.
        mov     ax,SEG wNVTEXT16_Alias_In_NVTEXT16
        push    ax
        call    AllocCSToDSAlias
        or      ax,ax
        je      Done
        mov     ds,ax
        mov     ds:[wNVTEXT16_Alias_In_NVTEXT16],ax

        ; Allocate a writable alias for the 32bit code segment
        mov     ax,SEG wNVTEXT16_Alias_In_NVTEXT32
        push    ax
        call    AllocCSToDSAlias
        or      ax,ax
        je      Done
        mov     es,ax
        mov     es:[wNVTEXT32_Alias_In_NVTEXT32],ax

        ; Now put each in the other
        mov     ax,es:[wNVTEXT32_Alias_In_NVTEXT32]
        mov     ds:[wNVTEXT32_Alias_In_NVTEXT16],ax
        mov     ax,ds:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     es:[wNVTEXT16_Alias_In_NVTEXT32],ax

        ; The VDDEntryPoint is just an address that is constant
        call    GN_VddGetEntryPoint

        ; Let's get the device handle so we can get a unique
        ; board identifier.
        push    lpDstDevType
        call    GN_VddGetDeviceHandle
        or      eax,eax
        je      Done

        lea     esi,ModesetTable
        call    GN_LoadDllAndGetExports
Done:
        POPR    ds
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyConstants
;
; Purpose:      This functions should destroy any "constants"
;               created by the CreateConstants routine. This
;               routine is called once when the driver is about
;               to be unloaded.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyConstants, PASCAL, NOFRAME, FAR16
OPENPROC

        ; Make sure that none of the selectors
        ; has any selectors we are about to free in them.
        sub     ax,ax
        mov     ds,ax
        mov     es,ax
        mov     fs,ax
        mov     gs,ax

        ; Did we even create an NVTEXT32 Code Alias?
        mov     ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        or      ax,ax
        je      Done32

        ; Zero out the variables in this code segment.
        mov     ds,ax
        mov     ds:[CSpGNLogicalDevice],0
        mov     ds:[wNVTEXT16_Alias_In_NVTEXT32],0

        sub     eax,eax
        mov     ds:[wNVTEXT32_Alias_In_NVTEXT32],ax
        mov     cx,ds
        mov     ds,ax

        ; Free our writable NVTEXT32 code segment alias
        push    cx
        call    FreeSelector
Done32:

        ; Did we even create a NVTEXT16 Code Alias?
        mov     ax,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        or      ax,ax
        je      Done16
        mov     ds,ax

        ; Zero out the variables in this code segment.
        mov     ds:[CSpGNLogicalDevice_In_NVTEXT16],0
        mov     ds:[wNVTEXT32_Alias_In_NVTEXT16],0

        sub     eax,eax
        mov     ds:[wNVTEXT16_Alias_In_NVTEXT16],ax
        mov     cx,ds
        mov     ds,ax

        ; Free our writable NVTEXT16 code segment alias
        push    cx
        call    FreeSelector
Done16:
CLOSEPROC


;==============================================================================
;
; Function:     GN_LoadDllAndGetExports
;
; Purpose:      This function loads the NvSys 16-bit RM interface dll
;               and gets addresses to the exports.
;
; Arguments:
;               ds:esi  offset of a MODULELINK array
;
; Returns:      eax     0       then load or export grab failed
;                       non-0   then everything was a success
;
; Preserve:     ds,esi
;==============================================================================
DECPROC GN_LoadDllAndGetExports, PASCAL, FRAME, FAR16
LOCALW  hDll
OPENPROC
        PUSHR   ds,esi,edi      ; LoadLibrary trashes DI and SI

        ; Load the library.  If it fails to load, we are totally hosed
        ; and there is no way to recover so blow off error code check.
        PUSHR   esi
        push    dword ptr ds:[esi]
        call    LoadLibrary
        POPR    esi
        mov     hDll,ax
        mov     ds:[esi + 4],ax
        add     esi,6

        ; Get some proc address
@@:     push    hDll
        pushw   0
        push    ds:[esi].MODULELINK.wOrdinal
        call    GetProcAddress
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].MODULELINK.lpfnFunc,edx
        add     esi,SIZE MODULELINK
        add     edi,2
        cmp     word ptr ds:[esi].MODULELINK.wOrdinal,0
        jne     @B

        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END     DllEntryPoint
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNENABLE.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnenable.asm
;
; Purpose:      This file holds the Enable and ReEnable display driver
;               entry points.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include escape.inc
include minivdd.inc
include modeext.inc

; Keep the caps we are supporting here for ease of modification
CAPS_C1         TEXTEQU <C1_DIBENGINE + C1_REINIT_ABLE + C1_COLORCURSOR + C1_GLYPH_INDEX + C1_GAMMA_RAMP>
CAPS_CLIP       TEXTEQU <CP_RECTANGLE>
CAPS_CURVE      TEXTEQU <0>
CAPS_LINE       TEXTEQU <LC_POLYLINE + LC_STYLED + LC_POLYSCANLINE>
CAPS_POLYGONAL  TEXTEQU <PC_SCANLINE + PC_ALTPOLYGON + PC_RECTANGLE + PC_WINDPOLYGON + PC_INTERIORS>
CAPS_RASTER     TEXTEQU <RC_BITBLT + RC_BITMAP64 + RC_GDI20_OUTPUT + RC_DI_BITMAP + RC_DIBTODEV + RC_BIGFONT + RC_STRETCHBLT + RC_STRETCHDIB + RC_OP_DX_OUTPUT + RC_SAVEBITMAP + RC_DEVBITS>
CAPS_TEXT       TEXTEQU <TC_CP_STROKE + TC_RA_ABLE>

; For different resolutions, we need to give GDI different Window/Viewport
; scaling combinations. There is an array of data in the following format
; located in this file -- each element in the array is for a different
; screen resolution.
METRICDATA      STRUCT
        wMetLowX        DW      0
        wMetLowY        DW      0
        wEngLowX        DW      0
        wEngLowY        DW      0
        wEngHighX       DW      0
        wEngHighY       DW      0
        wTwipX          DW      0
        wTwipY          DW      0
METRICDATA      ENDS


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA


OPENSEG  _NVTEXT16, USE16, CODE

ALIGN 2
PUBLIC  sMetricData
sMetricData  LABEL   METRICDATA
;       nXres,  nYres,  nEngLoX nEngLoY,nEngHiX,nEngHiY,nTwipX, nTwipY
DW      320,    200,    127,    127,    64,     64,     64,     64
DW      640,    480,    254,    254,    127,    127,    127,    127
DW      800,    600,    318,    318,    159,    159,    159,    159
DW      1024,   768,    407,    407,    203,    203,    203,    203
DW      1280,   1024,   509,    509,    254,    254,    254,    254
DW      1152,   864,    457,    457,    230,    230,    230,    230
DW      1600,   1200,   635,    635,    320,    320,    320,    320
DW      2048,   1536,   635,    635,    320,    320,    320,    320
DW      0

IFDEF DEBUG
szReEnable      DB      'DISPLAY:GENERIC_ReEnable',0DH,0AH,0
szEnable        DB      'DISPLAY:GENERIC_Enable',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GENERIC_ReEnable
;
; Purpose:      This function is the ReEnable display driver entry point.
;               Mostly it just sequences the two Enable calls to do the
;               ReEnable plus a few extra things unique to ReEnable.
;
; Arguments:    ReEnable Display Driver Stack Frame
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_ReEnable, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMD   lpGdiInfoA
LOCALS  dwTempPalette,400H
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szReEnable
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        ; Load up the GNLOGDEVCX
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        cmp     ds:[esi].GNLOGDEVCX.bSetModeBypass,0
        je      @F
        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,0
        jmp     Bypass_ReEnable

@@:
        ; Save the ptr to the GDIINFO table in case it has changed
        mov     eax,lpGdiInfoA
        mov     ds:[esi].GNLOGDEVCX.lpGdiInfo,eax

        ; Save off the palette in case we need to restore it later
        mov     ax,ss
        mov     es,ax
        lea     edi,dwTempPalette
        lea     esi,[esi].GNLOGDEVCX.dwPalette
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]

        ; The DIBENG is clobbering the spotsize which should only be
        ; touched by GDI so we save and restore it around the call.
        lds     di,lpGdiInfoA
        push    ds:[edi].GDIINFO.dpSpotSizeX
        push    ds:[edi].GDIINFO.dpSpotSizeY

        ; Do the GDIINFO flavor of the enable call.
        sub     eax,eax
        mov     ecx,1
        push    lpGdiInfoA
        push    cx
        push    eax
        push    eax
        inc     eax
        push    eax
        call    GENERIC_Enable

        ; Here is where the Restore happens.
        pop     ds:[edi].GDIINFO.dpSpotSizeY
        pop     ds:[edi].GDIINFO.dpSpotSizeX

        ; Do the Enable Device flavor of the enable call.
        sub     eax,eax
        push    lpDstDev
        push    ax
        push    eax
        push    eax
        inc     eax
        push    eax
        call    GENERIC_Enable

        ; Restore and set the palette if we are palettized.
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     es,cs:[wFlatDataSel_In_NVTEXT16]
        test    es:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTIZED
        jz      @F

        ; Restore the palette we saved off
        ; This palette is not the one that actually gets set
        ; into the hardware. That palette in in the CRTC objects
        ; and their palette does not get trashed. Hence, there is
        ; no need to resend the palette to the CRTC objects.
        lea     edi,[esi].GNLOGDEVCX.dwPalette
        mov     ax,ss
        mov     ds,ax
        lea     esi,dwTempPalette
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
@@:

Bypass_ReEnable:
        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_Enable
;
; Purpose:      This function is the Enable display driver entry point.
;               It deals with multi-monitor stuff and then hands off to
;               the real enable routine which implements the enable
;               for the selected device.
;
; Arguments:    Enable Display Driver Stack Frame
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Enable, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wAction
PARMD   lpDstDevType
PARMD   lpOutputFile
PARMD   lpData
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szEnable
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        ; This is one of the two functions in the driver that can be
        ; called first. If we haven't initted yet, we must do it now.
        cmp     cs:[wNVTEXT32_Alias_In_NVTEXT16],0
        jne     @F
        push    lpDstDevType
        push    lpDstDev                ; GDIINFO PTR the first time.
        call    GN_DllEntryPoint
        or      eax,eax
        je      DoneIt
@@:
        ; Load up the GNLOGDEV
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]

        ; Which case is it? Primary or secondary
        mov     eax,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        cmp     eax,1
        je      AsIfPrimary

        ; We are a secondary card. Hence, we must first enable access
        ; to the board. If we are truly multi-monitor compliant, we
        ; can just enable Memory access and leave it on all the time.
        ; If we use I/O (in or out) instructions anywhere, this won't
        ; work because I will not Enable I/O access to the board.
        pushd   ENABLE_MEM
        call    GN_VddEnableDevice
        cmp     eax,ENABLE_ERROR
        je      Exit_Fail

AsIfPrimary:
        ; At this point, we are either primary, or we are secondary and
        ; Memory accesses to our board have been enabled. Hence, we can
        ; now dispatch to the correct subfunction.
        ; Split based on action.
        push    esi
        push    lpDstDev
        push    wAction
        push    lpDstDevType
        push    lpOutputFile
        push    lpData

        push    OFFSET DoneIt
        movzx   eax,wAction
        test    al,1
        jz      GN_EnableDevice
        jmp     GN_EnableGdiInfo

Exit_Fail:
        sub     eax,eax
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_EnableGdiInfo
;
; Purpose:      This function is jumped to from the Enable display driver
;               entry point once it is known that the flavor of the call
;               is to get the GDIINFO table.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     esi,edi
;==============================================================================
DECPROC GN_EnableGdiInfo, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   lpThisGdiInfo
PARMW   wAction
PARMD   lpDstDevType
PARMD   lpOutputFile
PARMD   lpData
OPENPROC
        PUSHR   esi,edi

        ; Let the DIBENG do its own thing
        push    lpThisGdiInfo
        push    wAction
        push    lpDstDevType
        push    lpOutputFile
        push    lpData
        call    DIB_Enable

        PUSHR   ds

        sub     esi,esi
        lds     si,lpThisGdiInfo
        mov     ds:[esi].GDIINFO.dpVersion,400H
        mov     ds:[esi].GDIINFO.dpTechnology,DT_RASDISPLAY
        mov     ds:[esi].GDIINFO.dpHorzSize,208
        mov     ds:[esi].GDIINFO.dpVertSize,156
;        mov     ds:[esi].GDIINFO.dpHorzRes
;        mov     ds:[esi].GDIINFO.dpVertRes
;        mov     ds:[esi].GDIINFO.dpBitsPixel
        mov     ds:[esi].GDIINFO.dpPlanes,1
        mov     ds:[esi].GDIINFO.dpNumBrushes,-1
        mov     ds:[esi].GDIINFO.dpNumPens,20*5
        mov     ds:[esi].GDIINFO.dpCapsFE,0
        mov     ds:[esi].GDIINFO.dpNumFonts,0
        mov     ds:[esi].GDIINFO.dpNumColors,-1
        mov     ds:[esi].GDIINFO.dpDEVICEsize,SIZE GNLOGDEVCX
        mov     ds:[esi].GDIINFO.dpCurves,CAPS_CURVE
        mov     ds:[esi].GDIINFO.dpLines,CAPS_LINE
        mov     ds:[esi].GDIINFO.dpPolygonals,CAPS_POLYGONAL
        mov     ds:[esi].GDIINFO.dpText,CAPS_TEXT
        mov     ds:[esi].GDIINFO.dpClip,CAPS_CLIP
        mov     ds:[esi].GDIINFO.dpRaster,CAPS_RASTER
        mov     ds:[esi].GDIINFO.dpAspectX,10
        mov     ds:[esi].GDIINFO.dpAspectY,10
        mov     ds:[esi].GDIINFO.dpAspectXY,14
        mov     ds:[esi].GDIINFO.dpStyleLen,28

        ; Based upon the screen resolution, we need to find
        ; the best set of Window/Viewport scalings.
        mov     ebx,OFFSET sMetricData
@@:     mov     ax,cs:[ebx].METRICDATA.wMetLowX
        cmp     ax,ds:[esi].GDIINFO.dpHorzRes
        je      Match
        add     ebx,SIZE METRICDATA
        cmp     cs:[ebx].METRICDATA.wMetLowX,0
        jne     @B
        mov     ebx,OFFSET sMetricData
Match:
        mov     ds:[esi+0].GDIINFO.dpMLoWin,2080
        mov     ds:[esi+2].GDIINFO.dpMLoWin,1560
        mov     ax,cs:[ebx].METRICDATA.wMetLowY
        mov     dx,cs:[ebx].METRICDATA.wMetLowX
        neg     ax
        mov     ds:[esi+0].GDIINFO.dpMLoVpt,dx
        mov     ds:[esi+2].GDIINFO.dpMLoVpt,ax

        mov     ds:[esi+0].GDIINFO.dpMHiWin,20800
        mov     ds:[esi+2].GDIINFO.dpMHiWin,15600
        mov     ds:[esi+0].GDIINFO.dpMHiVpt,dx
        mov     ds:[esi+2].GDIINFO.dpMHiVpt,ax

        mov     ds:[esi+0].GDIINFO.dpELoWin,325
        mov     ds:[esi+2].GDIINFO.dpELoWin,325
        mov     ax,cs:[ebx].METRICDATA.wEngLowY
        neg     ax
        mov     ds:[esi+2].GDIINFO.dpELoVpt,ax
        mov     ax,cs:[ebx].METRICDATA.wEngLowX
        mov     ds:[esi+0].GDIINFO.dpELoVpt,ax

        mov     ds:[esi+0].GDIINFO.dpEHiWin,1625
        mov     ds:[esi+2].GDIINFO.dpEHiWin,1625
        mov     ax,cs:[ebx].METRICDATA.wEngHighY
        neg     ax
        mov     ds:[esi+2].GDIINFO.dpEHiVpt,ax
        mov     ax,cs:[ebx].METRICDATA.wEngHighX
        mov     ds:[esi+0].GDIINFO.dpEHiVpt,ax

        mov     ax,cs:[ebx].METRICDATA.wTwipY
        neg     ax
        mov     ds:[esi+2].GDIINFO.dpTwpVpt,ax
        mov     ax,cs:[ebx].METRICDATA.wTwipX
        mov     ds:[esi+0].GDIINFO.dpTwpVpt,ax
        mov     ds:[esi+0].GDIINFO.dpTwpWin,2340
        mov     ds:[esi+2].GDIINFO.dpTwpWin,2340

        ; Always set to 96 right now. GDI overrides this as needed.
        mov     ax,96
        mov     ds:[esi].GDIINFO.dpLogPixelsX,ax
        mov     ds:[esi].GDIINFO.dpLogPixelsY,ax

        ; The display driver doesn't use File Name Pair matching
        mov     ds:[esi].GDIINFO.dpDCManage,DC_IgnoreDFNP

        ; The CAPS_C1 are at the top of the file.
        mov     ds:[esi].GDIINFO.dpCaps1,CAPS_C1

        mov     es,cs:[wFlatDataSel_In_NVTEXT16]
        mov     edi,pGNLogdevCXOffset
        mov     eax,es:[edi].GNLOGDEVCX.dwFontFormat
        or      ds:[esi].GDIINFO.dpCaps1,ax

        ; The dpSpotSize are set by GDI, not the driver -- do not touch!
        ; mov    ds:[esi].GDIINFO.dpSpotSizeX
        ; mov    ds:[esi].GDIINFO.dpSpotSizeY

        ; The color resolution. We will always be 8 bits per gun.
        mov     ds:[esi].GDIINFO.dpColorRes,24

        mov     ecx,pGNLogdevCXOffset
        mov     eax,lpThisGdiInfo
        mov     es:[ecx].GNLOGDEVCX.lpGdiInfo,eax

        ; Set the desktop mode first.
        PUSHR   es
        POPR    ds
        push    ecx
        call    GN_GetLogicalAndPhysicalModes

        ; Reload stuff after the call
        sub     esi,esi
        lds     si,lpThisGdiInfo
        mov     es,cs:[wFlatDataSel_In_NVTEXT16]

        ; If we are not PALETTE_MANAGED, then clear out palette fields
        cmp     ds:[esi].GDIINFO.dpBitsPixel,8
        je      IsPal
        sub     eax,eax
        mov     ds:[esi].GDIINFO.dpNumPalReg,ax
        mov     ds:[esi].GDIINFO.dpPalReserved,ax
        mov     ds:[esi].GDIINFO.dpColorRes,ax
        jmp     @F
IsPal:  mov     ds:[esi].GDIINFO.dpNumPalReg,256
        or      ds:[esi].GDIINFO.dpRaster,RC_PALETTE
        mov     ds:[esi].GDIINFO.dpPalReserved,20
        mov     ds:[esi].GDIINFO.dpNumColors,20
        mov     ebx,es:[edi].GNLOGDEVCX.pGNCrtcCX
        mov     eax,es:[ebx].GNCRTCCX.dwBitsPerColorChannel
        imul    eax,3
        mov     ds:[esi].GDIINFO.dpColorRes,ax
@@:
        POPR    ds

        ; Give the correct return value
        mov     eax,SIZE GDIINFO

        POPR    esi,edi
CLOSEPROC

;==============================================================================
;
; Function:     GN_EnableDevice
;
; Purpose:      This function is jumped to from the Enable display driver
;               entry point once it is known that the flavor of the call
;               is to Enable the Physical Device.  (Actually this flavor
;               of call breaks out into two itself -- Enable the device
;               or just return the device context.)
;
; Arguments:    Enable Display Driver Stack Frame
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     ss,ebp,esp
;==============================================================================
DECPROC GN_EnableDevice, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   lpDstDevice
PARMW   wAction
PARMD   lpDstDevType
PARMD   lpOutputFile
PARMD   lpData
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        call    GN_CheckInterlacedStereoConnection
        mov     ds:[esi].GNLOGDEVCX.bInterlacedStereo, al
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    eax
        call    NV_SetInterlacedStereoMode

        ; The high bit of the Action argument tells whether or not to
        ; enable the hardware or simply return the device context.
        movzx   eax,wAction
        test    ah,80H
        jz      EnableDev

GetDeviceContext:
        mov     esi,pGNLogdevCXOffset
        sub     edi,edi
        les     di,lpDstDevice
        mov     ecx,SIZE GNLOGDEVCX
        rep     movs byte ptr es:[edi], ds:[esi]
        jmp     DoneIt

EnableDev:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Everything in the driver is based upon the GNLOGDEVCX as the
        ; sole piece of context data. Before the very first time this
        ; function is called, however, we technically do not yet have
        ; a GNLOGDEVCCX. A temporary one was initalized at driver load
        ; time and has been used up to this point. We copy over the
        ; template to the one passed in here and reassign the ptr to
        ; the real GNLOGDEVCX.
        mov     eax,lpDstDevice
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        cmp     eax,pGNLogdevCXOffset
        je      DoneFirst

        ; Copy the GNLOGDEVCX over to the new ptr
        mov     esi,pGNLogdevCXOffset
        sub     edi,edi
        les     di,lpDstDevice
        mov     ecx,SIZE GNLOGDEVCX
        rep     movs byte ptr es:[edi], ds:[esi]

        ; Free the old ptr
        mov     esi,eax
        push    pGNLogdevCXOffset
        call    HW_FreeFlatMemory

        ; Load these up
        mov     es,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     fs,cs:[wNVTEXT32_Alias_In_NVTEXT16]

        ; Set the new ptr
        mov     es:[CSpGNLogicalDevice_In_NVTEXT16],esi
        mov     fs:[CSpGNLogicalDevice],esi

        ; Also fill these in
        mov     eax,lpDstDevice
        mov     es:[CSlp16LogDevice_In_NVTEXT16],eax
        mov     fs:[CSlp16LogDevice],eax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice,eax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Let everyone know that Logical device has moved.
        push    esi
        pushd   MSG_LOGDEVMOVED
        push    esi                             ; push new prt
        push    pGNLogdevCXOffset               ; push old ptr
        call    GN_LogdevMessage
        mov     pGNLogdevCXOffset,esi
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoneFirst:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Ugh! If we are not "attached to the desktop", then
        ; don't set the mode! We might not have any CRTCCXs
        ; if we are not attached to the desktop.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      DoneIt
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Do not get any modes from the registry, etc. All the GDIINFO
        ; stuff and mode fetching should have been snapshotted at
        ; GetGdiInfo time. In this call, just set whatever is in the
        ; CRTCCXs. Some weird apps and WHQL stuff just call Enable and
        ; not ReEnable after going out to a DOS box. They expect that
        ; to just reset the mode that existed before the DOS box.

        push    esi
        call    GN_SetLogicalAndPhysicalModes

        ; Make sure we turn off busy so we can paint to the screen.
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0

        ; Register the driver with the VDD
        call    GN_VddDriverRegister

        ; Tell the VDD to save the driver state
        call    GN_VddSaveDriverState

        ; Disable IO trapping if we are not a secondary device.
        ; The GN_VddEnableIOTrapping checks the device ID.
        sub     eax,eax
        push    eax
        call    GN_VddEnableIOTrapping

        ; We need to force all logical devices to redraw themselves
        ; since all the desktops may have been repositioned in
        ; video memory.
        push    esi
        call    GN_UserRepaint

        ; We let the driver load if it is disabled, but we don't
        ; give it a GNCRTCCX. Protect against NULL ptr.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        or      ebx,ebx
        je      DoneIt

IF DIB_FAST_EXIT
        ; Init the Fast Exit Stiff for DIBS
        push    ds:[ebx].GNCRTCCX.lpNvmodeDispData
        call    GN_InitDibFastExit
ENDIF

DoneIt:
        ; Return Success
        mov     eax,-1
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetLogicalAndPhysicalModes
;
; Purpose:      This function gets the logical (GDIINFO or desktop) mode
;               as well as the physical modes for all the CRTCs attached
;               to the logical device.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;               lpThisGdiInfo
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetLogicalAndPhysicalModes, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALW  wForcedModePresent
LOCALV  sDispInfo,DISPLAYINFO
LOCALD  lpDispInfo
LOCALV  sDesktopModeInfo,MODEINFO
LOCALD  lpDesktopModeInfo
LOCALD  dwSettableModeFreeBlockSize
LOCALD  dwMemoryNeededFor640x480x8
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aHWCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpHWCrtcCX
LOCALS  aGNCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpGNCrtcCX
LOCALD  dwOriginalXRes
LOCALD  dwOriginalYRes
LOCALD  dwCloneRefreshRate
LOCALW  wClone
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Build some things we will need
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        mov     lpDispInfo,eax
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax

        ; We will be needing this
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        pushd   640
        pushd   480
        pushd   8
        call    HW_GetModeDimensions
        mov     dwMemoryNeededFor640x480x8,ebx
        
        ; Get the registry key for clone behavior
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetCloneDesktopSelection,es,ax
        mov     wClone,ax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Get the Desktop mode that the system wants to set
        ; This is the LOGICAL DEVICE mode.
        push    lpDispInfo
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo

        ; Microsoft uses a 0 return for the refresh rate to indicate
        ; that we should make the CONFIG2 call for display res info.
        cmp     sDispInfo.diRefreshRateMax,0
        jne     @F
        push    lpDispInfo
        pushd   VDD_GET_DISPLAY_CONFIG2
        call    GN_VddGetDisplayInfo
@@:
        ; Save the xres,yres that Windows wants us to set
        sub     ecx,ecx
        lfs     cx,lpDispInfo
        mov     eax,dword ptr fs:[ecx].DISPLAYINFO.diXRes
        mov     dword ptr ds:[esi].GNLOGDEVCX.wWindowsXRes,eax

        ; Make sure that the mode Windows is asking us for
        ; hasn't been wierdly modified by Windows. If it has,
        ; then correct it to our real mode.
        mov     ebx,lpDispInfo
        lea     eax,[ebx].DISPLAYINFO.diXRes
        push    eax
        lea     eax,[ebx].DISPLAYINFO.diYRes
        push    eax
        call    GN_CheckForMultipleOf8Mode

        ; Peg the pixel depth to something we can handle
        sub     ecx,ecx
        lfs     cx,lpDispInfo
        mov     al,fs:[ecx].DISPLAYINFO.diBpp
        cmp     al,08H
        je      @F
        cmp     al,10H
        je      @F
        cmp     al,20H
        je      @F
        mov     al,08H
@@:     mov     fs:[ecx].DISPLAYINFO.diBpp,al

        ; Get this into a MODEINFO format which we need later
        sub     ebx,ebx
        les     bx,lpDesktopModeInfo
        movzx   eax,fs:[ecx].DISPLAYINFO.diXRes
        mov     es:[ebx].MODEINFO.dwXRes,eax
        mov     dwOriginalXRes,eax
        movzx   eax,fs:[ecx].DISPLAYINFO.diYRes
        mov     es:[ebx].MODEINFO.dwYRes,eax
        mov     dwOriginalYRes,eax
        movzx   eax,fs:[ecx].DISPLAYINFO.diBpp
        mov     es:[ebx].MODEINFO.dwBpp,eax

        ; Ugh! If we are not "attached to the desktop", then
        ; don't set the mode! We might not have any CRTCCXs
        ; if we are not attached to the desktop.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      JustRes
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Is this a first boot (are we initting still?)
        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      NotInit0

        ; OK, this is a pain. There is one circumstance under
        ; which we do not want to set the desktop mode that
        ; Windows is asking us to. If the user changed the color
        ; depth, but said, reboot to make it happen, then we might
        ; not set what Windows asks. Why? Because, suppose the user
        ; changed the color depth on the CRT and asked for a reboot.
        ; Then the user unplugs the CRT and goes with a DFP and
        ; boots up.  The color depth switch does not apply to the
        ; DFP, but rather the "Shutdown device" which was the CRT.
        ; No biggie, this scenario will only happen on boot. All
        ; we need to do is write out the mode Windows is asking us
        ; to boot in to the Shutdown device. If the shutdown device
        ; is the current device, that is OK.

        ; OK, what device did we shut down on last time?
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        pushd   0
        push    lpLocalDevData
        CALLFAR16IND lpfnGetDisplayDevice,es,ax

        ; If there was no physical device 0 on this logical device,
        ; then don't worry about it.
        or      ax,ax
        je      NotInit0
        
        ; Get the TV Format for this device from the ResMan. Please note
        ; if this device is not a TV, this function will return 0.
        mov     eax,dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax

        ; Write out the desired desktop mode for that device
        mov     eax,dword ptr LocalDevData
        mov     sDesktopModeInfo.MIDevData,eax
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        mov     eax,0
        cmp     wClone,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax

        ; Now what device are we booting on this time?
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        cmp     sDesktopModeInfo.MIDevData.cType,al
        je      MergeInit
        mov     sDesktopModeInfo.MIDevData,eax

        ; Get Last Desktop mode set on this new device
        push    sDesktopModeInfo.dwBpp
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        mov     eax,0
        cmp     wClone,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnGetDeviceDesktopMode,es,ax
        pop     sDesktopModeInfo.dwBpp
        jmp     MergeInit

NotInit0:
        ; Since we are not initting, we can just use the DevData
        ; for PhysicalDevice0
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        mov     sDesktopModeInfo.MIDevData,eax
MergeInit:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Now we may modify the desktop mode the system requested.

        ; Get any forced desktop mode
        push    sDesktopModeInfo.dwBpp
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        CALLFAR16IND lpfnGetForcedDesktopMode,es,ax
        mov     wForcedModePresent,ax
        mov     eax,sDesktopModeInfo.dwBpp
        pop     sDesktopModeInfo.dwBpp

        ; If Windows is booting, then we can change the color depth.
        ; Otherwise, we cannot.
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      @F
        mov     sDesktopModeInfo.dwBpp,eax
@@:

        ; It is possible that the forced desktop mode has XRes = 0
        ; This is a signal to use the largest EDID mode.
        cmp     sDesktopModeInfo.dwXRes,0
        jne     GetRefreshRateForDesktop

        ; Ask the CRTC for its largest EDID mode.
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    lpDesktopModeInfo
        call    GN_GetLargestEdidMode
        or      ax,ax
        jne     GotDesktopAndRefreshRate

        ; Restore the original desktop size for non DDC display
        mov     eax,dwOriginalXRes
        mov     sDesktopModeInfo.dwXRes,eax
        mov     eax,dwOriginalYRes
        mov     sDesktopModeInfo.dwYRes,eax

GetRefreshRateForDesktop:
        ; We don't have a refresh rate yet. Get one.
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    lpDesktopModeInfo
        call    GN_GetRefreshRateForDesktop
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GotDesktopAndRefreshRate:
        ; Get the largest block size that we could put this mode in
        ; If this is smaller than a 640x480x8 mode, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        cmp     eax,dwMemoryNeededFor640x480x8
        jae     DoneRecoverFromNoPrimary

RecoverFromNoPrimary:
        push    esi
        call    GN_NoPrimarySurfaceRecovery

DoneRecoverFromNoPrimary:
        mov     dwSettableModeFreeBlockSize,eax

        test    dwSettableModeFreeBlockSize,80000000H
        jnz     EnoughSpace
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        pushd   sDesktopModeInfo.dwXRes
        pushd   sDesktopModeInfo.dwYRes
        pushd   sDesktopModeInfo.dwBpp
        call    HW_GetModeDimensions
        cmp     ebx,dwSettableModeFreeBlockSize
        jg      RecoverFromNoPrimary

EnoughSpace:
        and     dwSettableModeFreeBlockSize,NOT 80000000H

        ; Restrict the desktop mode based upon the memory requirements
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[ebx].GNCRTCCX.lpNvmodeDispData
        push    lpDesktopModeInfo
        push    lpDesktopModeInfo
        push    dwSettableModeFreeBlockSize
        CALLFAR16IND lpfnFindVirtualModeEntry,es,ax

        ; Write any forced desktop mode out to the registry.
        ; Technically Windows will do this, but if we have modified
        ; the desktop mode in any way from what Windows requested,
        ; and if we reboot right away, then Windows will not have
        ; updated its registry section to what we wanted the desktop
        ; to be. Hence, the reboot will not come up in the desktop
        ; that we 'modified' to this time.
        cmp     wForcedModePresent,0
        je      @F
        push    sDesktopModeInfo.dwBpp
        push    sDesktopModeInfo.dwXRes
        push    sDesktopModeInfo.dwYRes
        CALLFAR16IND lpfnSetResolutionAndColorDepth,es,ax
@@:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; There are two possibilities here. We may get called by
        ; 1) Windows Control Panel
        ; 2) NVidiaControlPanel or hotkey handler

        ; If we are called by the Windows Control Panel, then skip
        ; this section and go on to the next section -- normal
        ; processing.
        cmp     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,0
        je      SkipNVSet

        ; OK, if we get here, it means that we received a
        ; NVTWINVIEW_ACTION_SETGET_DISPLAY_CONFIG escape
        ; call with a delayed state change. The NV Control
        ; Panel or HotKey handler is making this modeset
        ; call to snap the new state into the hardware.

        ; First, clear out the pending display config flag
        mov     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,0
        lea     edi,[esi].GNLOGDEVCX.sDispConfig

        ; Issue the Begin
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        or      eax,80000000H
        push    eax
        call    HW_BeginDisplayChange
        mov     ds:[esi].GNLOGDEVCX.dwBeginDisplayChangeIssued,1

        push    esi
        push    lpDesktopModeInfo
        call    GN_DoFullStateChange
        
        ; Set the refresh rate for the desktop to the refresh rate we
        ; got for the primary CRTCCX from GN_DoFullStateChange.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        sub     edx,edx
        lfs     dx,ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        mov     eax,fs:[edx].MODEINFO.dwRefreshRate
        mov     sDesktopModeInfo.dwRefreshRate,eax

SkipNVSet:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; OK, what we need to do now is to have the hardware take
        ; all the devices and map each device to some head. We
        ; know this can be done or we wouldn't even be here.
        push    esi
        call    GN_CrtcRemapArray
        mov     ds:[esi].GNLOGDEVCX.dwDeviceHasBeenRemapped,eax
        
        ; Now that everything's been remapped, make sure the local copy
        ; of sDesktopModeInfo has the MIDevData for the primary GNCrtcCX.
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        mov     sDesktopModeInfo.MIDevData,eax
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ; We may need to override the desktop resolution here if
        ; we are responding to an Enable call after the NV Control Panel
        ; or the hotkey handler issued ChangeDisplaySettings. If this
        ; Enable call is in response to the Windows Control Panel then
        ; use the desktop resolution already provided.
        cmp     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,1
        jne     SkipDesktopOverride
        
        mov     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,0

        ; We only want to override the desktop resolution if we are writing
        ; separate registry keys for the desktop mode in clone and standard
        ; mode.
        cmp     wClone,1
        jne     SkipDesktopOverride

        ; In order to know which registry key to read, LastCloneDesktopMode or
        ; LastDesktopMode, we need to know if we are in clone mode or not.
        ; Unfortunately, if this Enable is as a result of the hotkey handler,
        ; GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice is not yet set to
        ; the correct value. However, if called by the hotkey handler,
        ; GNLOGDEVCX.dwDisplayConfigPending = 1 and
        ; NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices is valid.
        cmp     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,1
        jne     NvControlPanelSet
        
        lea     edi,[esi].GNLOGDEVCX.sDispConfig
        mov     edx,0
        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices,1
        je      GetDesktopFromRegistry
        mov     edx,1
        jmp     GetDesktopFromRegistry

NvControlPanelSet:
        mov     edx,0
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        je      GetDesktopFromRegistry
        mov     edx,1

GetDesktopFromRegistry:
        ; Get Last Desktop mode set on this new device
        push    sDesktopModeInfo.dwBpp
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        push    edx
        CALLFAR16IND lpfnGetDeviceDesktopMode,es,ax
        pop     sDesktopModeInfo.dwBpp

        ; Write any forced desktop mode out to the registry.
        push    sDesktopModeInfo.dwBpp
        push    sDesktopModeInfo.dwXRes
        push    sDesktopModeInfo.dwYRes
        CALLFAR16IND lpfnSetResolutionAndColorDepth,es,ax

SkipDesktopOverride:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Now for the physical modes.
        ; At this point, I am going to assume that a Windows
        ; Control Panel modeset and an NVidia Control Panel
        ; modeset are essentially the same thing.

        ; Run through all devices.
        sub     edi,edi

GetLoop0:
        ; The first PhysicalDevice attached to this logical device
        ; will set, as it's physical mode, the mode and refresh rate of
        ; the desktop. If it is unable to, then back off the phys mode.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        sub     edx,edx
        lfs     dx,ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        mov     eax,fs:[edx].MODEINFO.dwRefreshRate
        mov     dwCloneRefreshRate,eax
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_AssignCrtcModeOnlyBackOffSpatial
        or      edi,edi
        je      SkipRestoreRefreshRate
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        sub     edx,edx
        lfs     dx,ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        mov     eax,dwCloneRefreshRate
        cmp     eax,0
        je      SkipRestoreRefreshRate
        mov     fs:[edx].MODEINFO.dwRefreshRate,eax
        
SkipRestoreRefreshRate:
        jmp     PickupGetLoop

GetLoop1:
        ; For any clone monitors attached to this logical
        ; device, read the CRTC mode from the registry.
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      PickupGetLoop

        ; Read the panning flag for appropriate clone device.
        ; If this flag is 0 than set the desktop resolution,
        ; Otherwise set mode from the registry
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnGetClonePanningFlag,es,ax
        or      ax,ax
        jz      GetLoop0

        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_GetCrtcMode

PickupGetLoop:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      GetLoop1
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Now start restricting things ...

        ; If we aren't allowing all modes, then make sure the
        ; desktop mode does not exceed the mode of the primary
        ; CRTC. We always allow virtualization on secondaries.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetAllowMightyModesFlag,es,ax
        or      ax,ax
        jne     @F
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    lpDesktopModeInfo
        call    GN_RestrictOtherModeSpatial
@@:
        sub     edi,edi

RestrictLoop:
        ; We can never set a physical mode larger than the desktop mode
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      @F
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_RestrictCrtcModeSpatial
@@:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      RestrictLoop
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; We've got all the info we need. We know the desktop and
        ; the physical modes on each attached CRTC.

        ; For the first physical device attached, write out the
        ; last desktop mode for that device.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        mov     eax,0
        cmp     wClone,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax

        ; Also, for the first physical device ONLY, write out its
        ; physical mode. Only the NVidia Control Panel can change
        ; the physical mode of a Clone device. We may have had to
        ; back off what the CRTC modes in the registry for the
        ; Clone devices, but we still don't change them here. This
        ; solves the problem of D3D changing to a fullscreen 6x4
        ; mode, and when it restores the original desktop mode
        ; all cloned device physical modes were left at 6x4. No!
        ; OK, We can write out secondary devices modes as well,
        ; but ONLY if there is not currently any mode for the
        ; secnodary device in the registry.
        sub     edi,edi
@@:
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      ELoop
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    edi
        call    GN_CrtcWriteModeToReg
ELoop:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

JustRes:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Finally! Update the GDIInfo table with our desktop
        sub     edi,edi
        les     di,ds:[esi].GNLOGDEVCX.lpGdiInfo
        mov     eax,sDesktopModeInfo.dwXRes
        mov     ebx,sDesktopModeInfo.dwYRes
        mov     ecx,sDesktopModeInfo.dwBpp
        mov     es:[edi].GDIINFO.dpHorzRes,ax
        mov     es:[edi].GDIINFO.dpVertRes,bx
        mov     es:[edi].GDIINFO.dpBitsPixel,cx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetLogicalAndPhysicalModes
;
; Purpose:      This function sets the desktop mode and and the physical
;               modes in each attached CRTC.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;               lpThisGdiInfo
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetLogicalAndPhysicalModes, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  dwJustOnePrimaryCanMove
LOCALD  pOtherGNLogdevCXOffset
LOCALD  dwMemoryNeededFor640x480x8
LOCALD  dwMemoryNeededForPrimarySurface
LOCALD  dwMemoryNeededForOtherPrimarySurface
LOCALD  pFirstNonNullCRTCForLogdev2
LOCALD  dwClearAndPanSecondSurface
LOCALD  dwDevDataMask
LOCALD  dwSetModeOnPrimary
LOCALD  dwSetModeOnSecondary
LOCALD  dwForceBothDevices
OPENPROC
        PUSHR   esi,edi

        mov     dwForceBothDevices,0

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; We will be needing this
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        pushd   640
        pushd   480
        pushd   8
        call    HW_GetModeDimensions
        mov     dwMemoryNeededFor640x480x8,ebx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TryItAgain:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Figure out whether one, or more than one (which means 2
        ; right now) primary surfaces will be moving.
        push    esi
        push    dwForceBothDevices
        call    GN_GetOtherLogdev
        mov     dwJustOnePrimaryCanMove,ecx
        or      ecx,ecx
        jne     ClearJustOnePrimary

        mov     dwMemoryNeededForOtherPrimarySurface,ebx
        mov     pOtherGNLogdevCXOffset,edi
        mov     eax,ds:[edi].GNLOGDEVCX.pGNCrtcCX
        mov     pFirstNonNullCRTCForLogdev2,eax

ClearBothPrimaries:
        cmp     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      ClearJustOnePrimary
        push    edi
        call    GN_BlankScreen

ClearJustOnePrimary:
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        push    esi
        call    GN_BlankScreen
@@:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Isolate ourselves so that the modeswitch is atomic

        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      @F

        ; We are initting. Are we the second display driver
        cmp     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        je      @F

        ; We are the second display driver and we are initting.
        ; We must call the hardware side to allow them to do some
        ; stuff.
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        mov     edx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[4]
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        push    ds:[edx].GNLOGDEVCX.pHWLogdevCX
        call    HW_DriverTwinviewStateChanging
@@:

        ; The first thing we do is send the PRE_MODESET message.
        ; All other components should stop all interactions with
        ; the board and video memory from this point until they
        ; see the POST_MODESET message. This way all our code
        ; and calculations herein appear atomic. For the most
        ; part just being inside the Win16 mutex does this.
        push    esi
        pushd   MSG_PREMODESET
        push    esi
        push    ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice
        call    GN_LogdevMessage
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; NOTE: The general fitting algorithm is too difficult to do in
        ; its full generality. Hence, we just implement the two specific
        ; cases that we know are the only ones that can happen right now.
        cmp     dwJustOnePrimaryCanMove,0
        jne     FillInPDevice

FreeBothPrimaries:
        ; Do we even have the secondary?
        mov     eax,ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        or      eax,eax
        je      FillInPDevice

        ; Can we use the same surface?
        or      eax,dwForceBothDevices
        cmp     eax,dwMemoryNeededForOtherPrimarySurface
        je      FillInPDevice

        push    ds:[edi].GNLOGDEVCX.pHWLogdevCX
        call    HW_FreeLogicalSurface
        mov     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FillInPDevice:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Fill in the resolution to the GDIINFO table
        sub     edi,edi
        sub     eax,eax
        sub     ebx,ebx
        les     di,ds:[esi].GNLOGDEVCX.lpGdiInfo
        mov     ax,es:[edi].GDIINFO.dpHorzRes
        mov     bx,es:[edi].GDIINFO.dpVertRes
        mov     cx,es:[edi].GDIINFO.dpBitsPixel
        mov     ds:[esi].DIBENGINEHDR.deWidth,ax
        mov     ds:[esi].DIBENGINEHDR.deHeight,bx
        mov     ds:[esi].DIBENGINEHDR.deBitsPixel,cl

        ; Flesh out the Dibeng structure
        and     ds:[esi].DIBENGINEHDR.deFlags,NOT FIVE6FIVE
        mov     edx,ds:[esi].GNLOGDEVCX.dw16BppFormat
        cmp     cl,16
        jne     @f
        or      ds:[esi].DIBENGINEHDR.deFlags,dx
        cmp     edx,FIVE6FIVE
        je      @F
        mov     cl,15
@@:
        mov     ds:[esi].DIBENGINEHDR.bRealBpp,cl
        les     di,ds:[esi].DIBENGINEHDR.deBitmapInfo
        mov     es:[edi].BitmapInfoHeader.biWidth,eax
        mov     es:[edi].BitmapInfoHeader.biHeight,ebx
        mov     es:[edi].BitmapInfoHeader.biBitCount,cx

        mov     edx,ecx
        imul    ecx,eax
        shr     ecx,3
        inc     ecx
        and     cl,NOT 1
        mov     ds:[esi].DIBENGINEHDR.deWidthBytes,cx

        ; Set the palettized flag if needed
        and     ds:[esi].DIBENGINEHDR.deFlags,NOT PALETTIZED
        cmp     ds:[esi].DIBENGINEHDR.deBitsPixel,8
        jne     @F
        or      ds:[esi].DIBENGINEHDR.deFlags,PALETTIZED
@@:
        ; Get the size of the primary we are going to set.
        ; We NEVER get less than 640x480x8 amount of memory
        ; or we might not be able to set the mode back to a
        ; reasonable desktop (if we are going to 320x200, say)
        ; since we might not be able to get the memory later.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        movzx   eax,ds:[esi].DIBENGINEHDR.deWidth
        push    eax
        movzx   eax,ds:[esi].DIBENGINEHDR.deHeight
        push    eax
        movzx   eax,ds:[esi].DIBENGINEHDR.deBitsPixel
        push    eax
        call    HW_GetModeDimensions
        mov     ds:[esi].DIBENGINEHDR.deDeltaScan,eax
        mov     ecx,ebx
        cmp     ecx,dwMemoryNeededFor640x480x8
        ja      @F
        mov     ecx,dwMemoryNeededFor640x480x8
@@:     mov     dwMemoryNeededForPrimarySurface,ecx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Do we even have the primary?
        mov     eax,ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        or      eax,eax
        je      @F

        ; Can we use the same surface?
        or      eax,dwForceBothDevices
        cmp     eax,ebx
        je      @F

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_FreeLogicalSurface
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
@@:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     dwClearAndPanSecondSurface,0
        cmp     dwJustOnePrimaryCanMove,0
        jne     AllocJustOnePrimary

AllocBothPrimary:
        ; We need to re-allocate these in order from larger to smaller
        ; or we might not get both. As long as we allocate in the
        ; correct order, code earlier in this routine should have
        ; guaranteed that we will get the surfaces.
        mov     dwClearAndPanSecondSurface,1
        mov     edi,pOtherGNLogdevCXOffset
        mov     eax,dwMemoryNeededForOtherPrimarySurface
        cmp     eax,dwMemoryNeededForPrimarySurface
        ja      SecondSurfaceAlloc

FirstSurfaceAlloc:
        mov     dwSetModeOnPrimary,1;!!!
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        jne     HavePrimary

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    esi
        call    HW_AllocLogicalSurface
        cmp     eax,-1
        jne     FirstAllocOk

        push    esi
        call    GN_NoPrimarySurfaceRecovery
        test    eax,80000000H
        jz      FirstSurfaceAlloc

CheckForceBothDevicesFlag:
        cmp     dwForceBothDevices,0
        mov     dwForceBothDevices,1
        je      TryItAgain

        ;VMEM deadlock. Never should be here.
IFDEF DEBUG
        int     3
ENDIF
@@:
        mov     eax,0DEADBEEFH
        jmp     @B

FirstAllocOk:
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset,eax
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,ebx
        mov     dwSetModeOnPrimary,ebx

HavePrimary:
        mov     eax,dwMemoryNeededForOtherPrimarySurface
        cmp     eax,dwMemoryNeededForPrimarySurface
        ja      FinishUp

SecondSurfaceAlloc:
        ; Now alloc the other guy
        mov     dwSetModeOnSecondary,1;!!!
        cmp     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        jne     HaveSecondary

        push    ds:[edi].GNLOGDEVCX.pHWLogdevCX
        push    edi
        call    HW_AllocLogicalSurface
        cmp     eax,-1
        jne     @F
        push    esi
        call    GN_NoPrimarySurfaceRecovery
        test    eax,80000000H
        jz      SecondSurfaceAlloc
        jmp     CheckForceBothDevicesFlag

@@:
        mov     ds:[edi].GNLOGDEVCX.Dibeng.deBitsOffset,eax
        mov     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,ebx
        mov     dwSetModeOnSecondary,ebx

HaveSecondary:
        mov     eax,dwMemoryNeededForOtherPrimarySurface
        cmp     eax,dwMemoryNeededForPrimarySurface
        ja      FirstSurfaceAlloc
        jmp     FinishUp
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AllocJustOnePrimary:
        mov     dwSetModeOnPrimary,1;!!!
        mov     dwSetModeOnSecondary,0
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        jne     FinishUp

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    esi
        call    HW_AllocLogicalSurface
        cmp     eax,-1
        jne     @F
        push    esi
        call    GN_NoPrimarySurfaceRecovery
        test    eax,80000000H
        jz      AllocJustOnePrimary
        jmp     CheckForceBothDevicesFlag

@@:
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset,eax
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,ebx
        mov     dwSetModeOnPrimary,ebx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FinishUp:
        ; Tell all other componenets that the modeset is complete.
        push    esi
        pushd   MSG_POSTMODESET
        push    esi
        push    ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice
        call    GN_LogdevMessage

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Get the Device Data Mask for all display devices.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ebx
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwDevDataMask,eax

        ; Did we already issue a BeginDisplayChange in
        ; GetLogicalAndPhysicalModes?
        cmp     ds:[esi].GNLOGDEVCX.dwBeginDisplayChangeIssued,0
        jne     @F
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_BeginDisplayChange
@@:
        cmp     dwSetModeOnSecondary,0
        je      DoneSecondary

        ; Don't forget to clear the OTHER surface if needed
        cmp     dwClearAndPanSecondSurface,0
        je      @F
        push    edi
        call    GN_BlankScreen
@@:

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; We need to call and reset the mode on the OTHER guy now.
        ; The problem is that the other guys CRTC timings may have
        ; gotten messed up when we set the mode here because we may
        ; have had to do a head reassignment in order to get all the
        ; heads to display to their appropriate output devices. If
        ; we did, then the other logical device's HW CRTC state is
        ; uninitted.
        cmp     dwClearAndPanSecondSurface,0
        je      DoneSecondary

        push    dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX
        push    edi
        call    GN_RestoreCrtcState

DoneSecondary:
        ; Now we can actually set the modes in the CRTCCXs
        ; which are attached to THIS logical device.
        ; Let's make the screen look pretty by clearing it to black.
        push    esi
        call    GN_BlankScreen

        sub     edi,edi
        cmp     dwSetModeOnPrimary,0
        je      NextCrtc7

Loopit7:
        ; Is this CRTCCX valid?
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      NextCrtc7

        ; Set the mode on this CRTC.
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    esi
        call    GN_RestoreCrtcState

NextCrtc7:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loopit7

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_EndDisplayChange

        ; We just issued the matching end.
        mov     ds:[esi].GNLOGDEVCX.dwBeginDisplayChangeIssued,0

        ; See if we need to modify some results back to the
        ; Windows requested mode (which is one of our modes
        ; ANDed with 8 -- this only happens in multimon).
        mov     ax,ds:[esi].GNLOGDEVCX.wWindowsXRes
        mov     cx,ds:[esi].GNLOGDEVCX.wWindowsYRes
        mov     bx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        cmp     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        jne     Skip10
        and     bx,NOT 7
        and     cx,NOT 7
        cmp     bx,cx
        jne     Skip10

        mov     cx,ds:[esi].GNLOGDEVCX.wWindowsYRes
        mov     dword ptr ds:[esi].GNLOGDEVCX.wWindowsXRes,0
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deHeight,cx
        sub     edi,edi
        les     di,ds:[esi].GNLOGDEVCX.lpGdiInfo
        mov     es:[edi].GDIINFO.dpVertRes,cx
Skip10:

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetOtherLogdev
;
; Purpose:      This routine is called to get whether or not there
;               is more than one logical device on this board, and,
;               if there is, to get information on the other logical
;               device.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      ecx     0 if parm pGNLogdevCXOffset is the only device on
;                               the board
;                       non-0 if there is another logdev on this board
;               edi     if ecx is non-0, then edi is the other pGNLogdevCX
;               ebx     if ecx is non-0, then ebx is the memory needed
;                               for the primary surface of the other
;                               pGNLogdevCX
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetOtherLogdev, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   dwForceBothDevices
OPENPROC
        PUSHR   esi
        mov     esi,pGNLogdevCXOffset

        mov     ecx,1
        sub     edi,edi
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX

        ; Is there another primary surface on this board?
        cmp     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        je      GotPrimaryData

        ; OK, there is more than 1 primary (that means 2 right now),
        ; but can the other primary be moved? First figure out
        ; which is the OTHER logical device
        mov     edi,ds:[ebx].GNBOARDCX.pGNLogdevCX[0]
        cmp     edi,esi
        jne     @F
        mov     edi,ds:[ebx].GNBOARDCX.pGNLogdevCX[4]
@@:
        ; HACK -- if the OTHER logical device is disabled,
        ; then just say there is only 1 logical device. Do NOT
        ; call IsDriverAttachedToDesktop!! We are in the wrong
        ; display driver for this to get called. Just see if
        ; there is a primary CRTC attached to the other logdev
        cmp     dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX,0
        je      GotPrimaryData

        ; The OTHER logical device is enabled. If dwForceBothDevices is true
        ; then it can be moved. Otherwise it shouldn't.
        mov     ebx,ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        cmp     dwForceBothDevices,0
        jne     ForceBothDevices

        ; Check for remapped devices
        mov     eax,ds:[esi].GNLOGDEVCX.dwDeviceHasBeenRemapped
        or      eax,eax
        jz      GotPrimaryData

        ; Determine how many devices has been remapped
@@:
        test    eax,1
        jnz     @F
        shr     eax,1
        jmp     @B

@@:
        ; Don't set mode on the primary if the only one device has been remapped
        shr     eax,1
        je      GotPrimaryData

ForceBothDevices:
        ; Set mode on both devices
        sub     ecx,ecx

GotPrimaryData:
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     GN_NoPrimarySurfaceRecovery
;
; Purpose:      This routine is only called in dire emergencies when
;               we are unable to get the memory for even a 640x480x8
;               primary surface. The display driver should be able to
;               guarantee that this will never happen. As long as its
;               code is correct and the heap doesn't get corrupted,
;               etc. then everything is fine. However, we need to be
;               able to recover somehow if we can't alloc the screen.
;
;               In here, we do a purge of all of video memory and ask
;               the hareware code to reset its offscreen heap manager.
;               This will probably result in some temporary drawing
;               problems, because some offscreen surfaces that are
;               allocated to various clients will be written over as
;               the memory freed behind their backs gets reallocated
;               to other clients. However, these drawing issues will
;               probably be short lived and this strategy does allow
;               us to recover fully.
;
;       JKTODO -- purge all offscreen video memory through special
;       RM call which does not yet exist. OGL wants us to increment the
;       mode counter so that they will reallocate appropriately.
;       We would also need to flush, etc...
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      eax                     New size of free offscreen memory
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_NoPrimarySurfaceRecovery, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
LOCALD  dwOldOffscreenFreeSpace
OPENPROC
        PUSHR   esi
        mov     esi,pGNLogdevCXOffset

        ; Send a broadcast message around that video memory
        ; is about to be reset. Since the heap is probably
        ; already trashed, object cleanup may not be that
        ; effective, but it iw worth a shot.

        ; Get the largest block size before purge
        ; If this is the same as before purge, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        mov     dwOldOffscreenFreeSpace,eax

        ; Purge DX video memory
        ; Specifically call the HWBOARD routine so that it
        ; can do stuff that is global and crucial to the
        ; board.
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_DxHeapPurge

        ; Send a broadcast message around that video memory
        ; has been reset. Everyone can realloc stuff.

        ; Get the largest block size again
        ; If this is the same as before purge, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        cmp     eax,dwOldOffscreenFreeSpace
        jg      DoneIt

        ; There is not enough memory to set the requested mode, and purging
        ; DX video memory didn't help. Now, purge everything except the
        ; primary surface which was purged earlier. After we purge everything,
        ; we will need to purge the cursor cache.
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_HeapPurgeAllExceptPrimarySurface
        
        ; Clear all cursor cahces.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_ClearAllCursorCaches
        
        ; Get the largest block size again
        ; If this is the same as before purge, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        cmp     eax,dwOldOffscreenFreeSpace
        jg      DoneIt

        ; At this point we might not realloc the secondary surface.
        ; Return E31 to force it.
        or      eax,80000000H

DoneIt:
        POPR    esi
CLOSEPROC



;==============================================================================
;
; Function:     GN_DoFullStateChange
;
; Purpose:      This routine is called when the information in the
;               NVTWINVIEW_DISPAY_CONFIG buffer in the GNLOGDEVCX
;               is to be processed. This may happen at escape time
;               or it may be deferred until the next modeset.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      eax                     New size of free offscreen memory
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DoFullStateChange, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   lpPassedInModeInfo
LOCALD  dwMaxMonitors
LOCALD  dwMonitorNum
LOCALD  dwLocalDeviceMask
LOCALD  dwDeviceCount
LOCALV  sModeInfo,MODEINFO
LOCALD  lpModeInfo
LOCALV  sDesktopModeInfo,MODEINFO
LOCALD  lpDesktopModeInfo
LOCALS  LocalDevData,MAX_ATTACHED_CRTCS*4
LOCALD  lpLocalDevData
OPENPROC
        PUSHR   esi,edi

        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        mov     lpModeInfo,eax
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax

        mov     esi,pGNLogdevCXOffset
        lea     edi,[esi].GNLOGDEVCX.sDispConfig

        ; If we are going to standard mode then destroy any CLONE CRTCCX
        ; if one exists
        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices,1
        jne     @F
        mov     dwMaxMonitors,1
        push    esi
        pushd   1
        call    GN_LogdevDetachCrtc
        jmp     DoneDevice
@@:
        ; If we are going to clone mode and we are currently in
        ; standard mode then add a clone
        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices,3
        jne     DoneDevice
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX[4],0
        jne     DoneDevice
        mov     dwMaxMonitors,2
        push    esi
        call    GN_LogdevAddAClone

DoneDevice:

        ; Loop on all the modes.
        mov     dwMonitorNum,0

        ; We have to do the primary device first. But then we will want
        ; to skip whiever one it was later, so remove it from the mask.
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        mov     dwLocalDeviceMask,eax
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwPrimaryDeviceMask
        xor     dwLocalDeviceMask,eax
        mov     edx,eax

        sub     ecx,ecx
        mov     dwDeviceCount,ecx
@@:     shr     edx,1
        je      Merge1
        inc     ecx
        mov     dwDeviceCount,ecx
        jmp     @B


LoopNow1:
        ; Does this guy have a mode to set?
        mov     ecx,dwDeviceCount
        mov     eax,1
        shl     eax,cl

        test    eax,dwLocalDeviceMask
        jz      SkipInitNoDev

Merge1:
        PUSHR   eax

        mov     ebx,ecx
        shr     cl,3
        and     ebx,07H
        mov     ch,bl
        mov     dword ptr sModeInfo.MIDevData,ecx

        ; Get the TV Format from the ResMan.
        mov     ebx,dwMonitorNum
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    ecx
        call    HW_GetResManTvFormat
        
        mov     sModeInfo.MIDevData.cFormat,al

        ; Now change the device type in the CRTCCX
        mov     ecx,dwMonitorNum
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    dword ptr sModeInfo.MIDevData
        call    GN_SetDevData

        POPR    eax
        test    eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwPhysicalModeFlags
        jz      SkipInit

        mov     ecx,dwDeviceCount
        imul    ecx,SIZE PHYSICAL_MODE
        lea     eax,[edi].NVTWINVIEW_DISPLAY_CONFIG.PhysModes
        add     eax,ecx
        push    eax
        
        ; Figure out the EDID thing
        mov     ebx,dwMonitorNum
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        mov     ds:[ebx].GNCRTCCX.dwEdidSize,0
        cmp     sModeInfo.MIDevData.cType,DEVTYPE_TV
        je      DoneEdidRead

        ; Read the EDID for this device
        mov     ds:[ebx].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    dword ptr sModeInfo.MIDevData
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,ds:[ebx].GNCRTCCX.sEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,ds:[ebx].GNCRTCCX.dwEdidSize
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid

DoneEdidRead:
        ; Assume that this is a normal mode
        pop     eax
        mov     ebx,ds:[eax].MODEINFO.dwXRes
        mov     ecx,ds:[eax].MODEINFO.dwYRes
        mov     edx,ds:[eax].MODEINFO.dwRefreshRate
        or      ebx,ebx
        jne     UseTwinViewMode

        ; Special max device mode when dwXRes, dwYRes, and dwRefreshRate = 0.
        ; First, check to see if this is a Toshiba mobile system. If so, use
        ; the refresh rate out of the registry unless the monitor is
        ; non-DDC (no EDID) in which case use 60Hz. If this is not a
        ; Toshiba mobile system, use the largest dwXRes, dwYRes, and
        ; dwRefreshRate allowable for the current desktop.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        mov     edx,1000
        cmp     ax,2
        jne     UseRefreshRate
        
        ; Check to see if there is an EDID, and if not, use 60Hz.
        mov     ebx,dwMonitorNum
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        cmp     ds:[ebx].GNCRTCCX.dwEdidSize,0
        mov     edx,60
        je      UseRefreshRate

        ; Get the refresh rate from the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     edx,ss:[ebx].MODEINFO.dwRefreshRate
        or      ax,ax
        jne     UseRefreshRate

        ; No mode in the registry, use 60Hz as default.
        mov     edx,60

UseRefreshRate:
        mov     ebx,7FFFH
        mov     ecx,ebx
        
UseTwinViewMode:
        sub     eax,eax
        lfs     ax,lpPassedInModeInfo
        cmp     ebx,fs:[eax].MODEINFO.dwXRes
        jl      @F
        mov     ebx,fs:[eax].MODEINFO.dwXRes
@@:     
        mov     sModeInfo.dwXRes,ebx
        
        cmp     ecx,fs:[eax].MODEINFO.dwYRes
        jl      @F
        mov     ecx,fs:[eax].MODEINFO.dwYRes
@@:     
        mov     sModeInfo.dwYRes,ecx
        mov     sModeInfo.dwRefreshRate,edx
        mov     eax,fs:[eax].MODEINFO.dwBpp
        mov     sModeInfo.dwBpp,eax

        ; NOTE: At this point, the DISPDATA.dwMaxDacSpeedInHertzXXbpp
        ; structure members are stale, but since we don't have a head
        ; mapping yet, we can not get the real values for the DAC.
        ; Set this to a large number so we won't restrict now according
        ; to the DAC speed. The DAC speed will be filled in after we
        ; have a head mapping, and the mode will be revalidated using
        ; the correct DAC speed. This only needs to be done for the
        ; primary as GN_LogdevAddAClone already does this for the secondary.
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     edx,[edx].GNCRTCCX.sNvmodeDispData
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz8bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz16bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz32bpp,40000000H

        mov     ecx,dwMonitorNum
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    lpModeInfo
        call    GN_AssignCrtcModeOnlyBackOffSpatial

        ; We should now have a mode that is settable on this device.
        ; Let's write this out to the registry
        mov     ecx,dwMonitorNum
        sub     eax,eax
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    eax
        call    GN_CrtcWriteModeToReg

SkipInit:
        ; Go to the next monitor
        inc     dwMonitorNum
        mov     ecx,dwMonitorNum
        cmp     ecx,dwMaxMonitors
        jnc     DoneInit

        cmp     ecx,1
        jne     SkipInitNoDev
        ; We just did MonitorNum = 0 which is the primary.
        ; Start over with the beginning of the deviceMask.
        ; The primary won't be repeated -- we reomved it from
        ; the deviceMask at the beginning.
        mov     dwDeviceCount,-1

SkipInitNoDev:
        inc     dwDeviceCount
        cmp     dwDeviceCount,18H
        jc      LoopNow1

DoneInit:
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNLINE.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnline.asm
;
; Purpose:      This file holds the Output(OS_POLYLINE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is and OS_POLYLINE style.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_Polyline
;
; Purpose:      This function is the Output(OS_POLYLINE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is the OS_POLYLINE style.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Polyline, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
OPENPROC
        PUSHR   ds,esi,edi

        ; Load HW Logical Device Context
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]

        ; Get a ptr to the dst bitmap
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; Load dst flags and prep some registers
        sub     edx,edx
        sub     edi,edi
        movzx   eax,gs:[esi].DIBENGINE.deFlags

        ; Filter out Null Pens
        cmp     edx,lpPen
        je      GN_PolylinePunt

        ; Filter out old style destinations
        cmp     dx,gs:[esi].DIBENGINE.deType
        je      GN_PolylinePunt

        ; Filter out based upon deFlags
        test    ah,VRAM / 256
        jz      GN_PolylinePunt

        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_PolylinePunt

        ; Load up the pen color
        les     di,lpPen
        mov     ecx,es:[edi].DIB_Pen.dpPenColor
        movzx   edx,byte ptr es:[edi].DIB_Pen.dpPenStyle
        cmp     edx,LS_NOLINE
        je      GN_PolylineSuccess
        
        test    ah,PALETTE_XLAT / 256
        jz      @F

        ; Get color from bPaletteXlatTable
        and     ecx,0FFh
        lea     eax,ds:[ebx].GNLOGDEVCX.bPaletteXlatTable
        mov     cl,byte ptr ds:[eax+ecx]

@@:
        ; Push arguments for Hardware specific polyline routine
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    lpPoints
        movzx   eax,wCount
        push    eax
        push    ecx

        ; We need the background color in case this is a styled line
        les     di,lpDrawMode
        mov     eax,es:[edi].DRAWMODE.bkColor
        push    eax

        ; Get the Rop2 from the DRAWMODE struct
        movzx   eax,byte ptr es:[edi].DRAWMODE.Rop2
        dec     eax
        push    eax
        push    edx

        ; Get the clip rect if there is one
        mov     eax,-1
        cmp     lpClipRect,0
        je      NoClipRect
        les     di,lpClipRect
        mov     eax,dword ptr es:[edi].RECT.left
        mov     ebx,dword ptr es:[edi].RECT.right

        ; Right may exceed bitmap Width
        cmp     bx,gs:[esi].DIBENGINE.deWidth
        jle     @F
        mov     bx,gs:[esi].DIBENGINE.deWidth
@@:

NoClipRect:
        push    ebx
        push    eax

        ; Check for degenerate clip rectangles before calling.
        ; This almost never happens, but should be checked for.
        cmp     ax,bx
        jge     GN_PolylinePuntPop
        shr     eax,10H
        shr     ebx,10H
        cmp     ax,bx
        jge     GN_PolylinePuntPop

        cmp     edx,LS_SOLID
        jne     GN_PolylineNonSolid

        ; Call the hardware specific routine to draw the lines
        call    HW_Polyline
        test    eax,eax
        jz      GN_PolylinePunt
        jmp     GN_PolylineSuccess
GENERIC_Polyline        ENDP


PUBLIC  GN_PolylineNonSolid
GN_PolylineNonSolid PROC    NEAR
        call    HW_PolyStyledLine
        test    eax,eax
        jz      GN_PolylinePunt
        jmp     GN_PolylineSuccess
GN_PolylineNonSolid ENDP

;==============================================================================
;
; Function:     Polyline ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of Polyline. You can either return a success code,
;               punt to the DIBENG, etc.
;
; Arguments:    Output Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_PolylinePuntPop
GN_PolylinePuntPop       PROC    NEAR
        ; Clean off parameters for HW_Polyline
        add     sp,9 * 4
GN_PolylinePuntPop       ENDP

PUBLIC  GN_PolylinePunt
GN_PolylinePunt  PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL  Punt_Polyline
        jmp     DIB_Output
GN_PolylinePunt  ENDP

PUBLIC  GN_PolylineSuccess
GN_PolylineSuccess       PROC    NEAR
        mov     eax,1
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH
GN_PolylineSuccess       ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNLOGDEV.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnlogdev.asm
;
; Purpose:      This file holds the init and deinit of the
;               GNLOGDEVCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_CreateLogdevContext
;
; Purpose:      This routine initializes a GNLOGDEV structure.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateLogdevContext, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
LOCALD  dwVirtualDesktopState
LOCALD  dwCRTCIndex
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        ; Allocate memory for the GNLOGDEVCX
        pushd   SIZE GNLOGDEVCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; Crate the HW logical device next
        mov     eax,pGNBoardCXOffset
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_CreateLogdevContext
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].GNLOGDEVCX.pHWLogdevCX,eax

        ; We are initting. This will be cleared after the first modeset.
        mov     ds:[esi].GNLOGDEVCX.dwInitting,1

        ; Fill in the logical board ptr
        mov     eax,pGNBoardCXOffset
        mov     ds:[esi].GNLOGDEVCX.pGNBoardCX,eax

        ; Save off the code segment values -- Ugh!
        mov     ds:[esi].GNLOGDEVCX.dw16BitCodeSegment,_NVTEXT16
        mov     ds:[esi].GNLOGDEVCX.dw32BitCodeSegment,_NVTEXT32

	; This gets initted to -1
        mov     ds:[esi].GNLOGDEVCX.dwCplData,-1

        ; We need a 16:16 ptr in the GNLOGDEVCX.Dibeng.deBitmapInfo
        ; field to the GNCRTCCX.bmi field.
        mov     eax,1
        lea     ebx,[esi].GNLOGDEVCX.bmi
        mov     ecx,SIZE DIBHEADER + 410H       ; 400H for palette table +
                                                ; some slack just in case
        ; Fill in the DIBENG header, Default to 640x480x8
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        sub     edx,edx
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitmapInfo,eax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deType,'RP'
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deWidth,640
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deHeight,480
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deWidthBytes,640
        mov     ds:[esi].GNLOGDEVCX.Dibeng.dePlanes,1
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel,8
        mov     dword ptr ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp,8
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan,640
        mov     ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice,edx
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset,edx

        ; Get the frame buffer selector from the GNBOARDCX
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_GetFrameBufferSelector
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector,ax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,MINIDRIVER + VRAM
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deVersion,400H
        mov     eax,OFFSET GENERIC_BeginAccess
        mov     ecx,OFFSET GENERIC_EndAccess
        mov     dx,SEG GENERIC_BeginAccess
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBeginAccess,edx
        mov     dx,cx
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deEndAccess,edx

        ; Fill in the bmi Header
        sub     edx,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biSize,SIZE DIBHEADER
        mov     ds:[esi].GNLOGDEVCX.bmi.biWidth,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biHeight,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biPlanes,1
        mov     ds:[esi].GNLOGDEVCX.bmi.biBitCount,dx
        mov     ds:[esi].GNLOGDEVCX.bmi.biCompression,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biSizeImage,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biXPelsPerMeter,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biYPelsPerMeter,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biClrUsed,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biClrImportant,edx

        ; Assume 0 for these right now
        mov     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        mov     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,0

        ; Get the number of CRTCS
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_GetNumCRTCs
        mov     ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard,eax

        ; Do we have virtual desktops? The registry knows.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_GetBoardRegistryPath
        mov     ds:[esi].GNLOGDEVCX.lpBoardRegistryData,eax

        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0

        ; Are they using 1-5-5-5 or 5-6-5 mode for this logical device
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_Get16BppPixelFormat
        mov     ds:[esi].GNLOGDEVCX.dw16BppFormat,eax

        ; Are they bitpacked or byte packed fonts
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetTextFormat
        mov     ds:[esi].GNLOGDEVCX.dwFontFormat,eax

        ; Init the save screen bitmap stuff
        push    esi
        call    GN_ClearSaveScreenBitmapCache

        ; Init the macrovision stuff
        mov     ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey,-1
        mov     ds:[esi].GNLOGDEVCX.dwNextMacrovisionKey,99999999H
        mov     ds:[esi].GNLOGDEVCX.dwMacrovisionMode,0
        mov     ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID,0

        ; Hook int2F. This protects itself from hooking more than once
        ; and also will not hook unless we are the primary device.
        push    pGNLogdevCXOffset
        call    GN_HookInt2F

        mov     eax,esi
DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the GNLOGDEVCX. was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; GN_DestroyLogdevContext can clean up partial inits
        push    esi
        call    GN_DestroyLogdevContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyLogdevContext
;
; Purpose:      This routine destroys a GNLOGDEVCX structure.
;               You do not need to free its memory. Just free any
;               resources inside the structure.
;
; Arguments:
;               ds              Context Selector
;               pGNLogdevCXOffset       Offset to the pdev context data
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyLogdevContext, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  pGNBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     pGNBoardCXOffset,eax

        ; UnHook int2F. This routine will not unhook if we are not
        ; already hooked.
        push    pGNLogdevCXOffset
        call    GN_UnhookInt2F

        sub     edi,edi
@@:
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      NextCrtc

        call    GN_VddIsDriverAttachedToDesktop
        or      eax,eax
        jnz     DoNotInitResolutionForClone

        ; Clear panning flag to prevent the next clone limitation
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        pushd   0
        CALLFAR16IND lpfnSetClonePanningFlag,es,ax

DoNotInitResolutionForClone:
        push    esi
        push    edi
        call    GN_LogdevDetachCrtc
NextCrtc:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B

        ; Free the primary surface memory.
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        call    HW_FreePrimarySurface
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
@@:
        ; Free the selector we were using for the BitmapInfo
        mov     eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitmapInfo
        or      eax,eax
        je      Skip0
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitmapInfo,0
Skip0:
        cmp     ds:[esi].GNLOGDEVCX.pHWLogdevCX,0
        je      @F
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_DestroyLogdevContext
        mov     ds:[esi].GNLOGDEVCX.pHWLogdevCX,0
@@:
        ; Clear out a few fields
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetGdiInfoPtr
;
; Purpose:      This routine sets the GDIINFO ptr in the GNLOGDEVCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX
;               lpThisGdiInfo           16:16 ptr to GdiInfo table
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetGdiInfoPtr, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   lpThisGdiInfo
LOCALD  dwState
OPENPROC
        mov     eax,lpThisGdiInfo
        mov     edx,pGNLogdevCXOffset
        mov     ds:[edx].GNLOGDEVCX.lpGdiInfo,eax

        ; OK, it is kind of weird to put this code in this routine,
        ; but there is an order problem. We can do this at create
        ; time because we don't know the value of
        ; dwLogicalDeviceInstanceOnThisBoard at that time. But by
        ; the time we get called here, we do know it. So....
        push    ds:[edx].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[edx].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        mov     ax,ss
        shl     eax,10H
        lea     ax,dwState
        push    eax
        CALLFAR16IND lpfnGetVirtualDesktop,es,ax
        mov     edx,pGNLogdevCXOffset
        mov     eax,dwState
        mov     ds:[edx].GNLOGDEVCX.dwVirtualDesktopEnabled,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_LogdevAttachCrtc
;
; Purpose:      This routine attaches a CRTC to a logical device
;               giving a viewable display to a logical desktop.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       else    Success
;                               In this case, ebx is the physical device num
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevAttachCrtc, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  pGNCrtcCXOffset
LOCALD  dwPhysicalDeviceNum
LOCALD  dwDeviceCount
LOCALD  dwIsBootCrtc
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALS  aHWCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
LOCALD  dwUnusedIndex
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Find a free attachment point
        sub     eax,eax
        sub     ebx,ebx
@@:
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4],0
        je      FoundIt
        inc     ebx
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B
        jmp     DoneIt

FoundIt:
        mov     dwPhysicalDeviceNum,ebx

        ; If this is PhysicalDevice0 on the primary driver, then this
        ; is the boot crtc.
        sub     edx,edx
        or      ebx,ebx
        jne     @F
        mov     dx,SEG dwThisLogicalDeviceHandle
        mov     es,dx
        mov     edx,es:[dwThisLogicalDeviceHandle]
        cmp     edx,1
        sete    dl
        movzx   edx,dl
@@:     mov     dwIsBootCrtc,edx

        ; OK, this is a bit tricky. If this is dwPhysicalDeviceNum = 0,
        ; then we are here because a driver is loading. In that case,
        ; it is because we are booting, OR because we are running multimon
        ; and someone enabled another device on the Windows Settings page.
        ; We want to allow this driver to come up if at all possible.
        ; The one thing that might hinder us is if there are no more
        ; physical CRTCS available to assign to this driver as the primary.
        ; Let's see if this is the case currently.

        ; How many CRTCS are currently in use?
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      AnAvailCrtc

        ; All CRTCs are currently in use. However, if any of them
        ; is currently being used as a clone device, we will steal
        ; it away so that we can use it as the primary for this
        ; driver.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_FindFirstCloneDevice
        or      ebx,ebx
        je      DoneIt

        ; HA! We found a GNLOGDEVCX with a clone device
        ; Bump the number of clones awaited by 1 in the logical device
        ; that we are stealing the CRTCCX from. When we destroy the Logdev
        ; which stole the clone away, we will give it back to a logdev
        ; which is awaiting clones (in GN_DestroyLogdevContext).
        inc     ds:[ebx].GNLOGDEVCX.dwNumClonesAwaited

        ; Remove the clone
        push    ebx
        push    eax
        call    GN_LogdevDetachCrtc

        ; Now there should be an available CRTCCX

AnAvailCrtc:
        ; Create a GNCRTCCX
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        push    dwPhysicalDeviceNum
        push    dwIsBootCrtc
        call    GN_CreateCrtcContext
        or      eax,eax
        je      DoneIt
        mov     pGNCrtcCXOffset,eax

        ; This is UGLY and a bit of a hack right now. In multiomon
        ; this routine can be called with the context of the other
        ; driver. That is fine, but CreateCrtcContext stores the
        ; address of the function GN_Far16GetModeSize in the GNCRTCCX.
        ; The problem is that the code segment is incorrect because
        ; the code seg it stores is for this driver! Ugh! One driver
        ; is what we really want with all data just context. But for now..
        mov     ecx,ds:[esi].GNLOGDEVCX.dw16BitCodeSegment
        lea     edx,[eax].GNCRTCCX.sNvmodeDispData
        mov     word ptr ds:[edx].DISPDATA.lpfnGetModeSize+2,cx
        mov     word ptr ds:[edx].DISPDATA.lpfnIsModeAcceptedByDriver+2,cx

        ; This is tentative! We haven't yet determined if it is OK
        ; to attach the CRTC, so we have to clear it out if it fails.
        ; We need to do it though for some of the other tests to work.
        mov     ebx,dwPhysicalDeviceNum
        mov     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4],eax

        ; Get the Device Data specifying the device the CRTC desires
        push    pGNCrtcCXOffset
        call    GN_GetDevData
        mov     dword ptr LocalDevData,eax

        ; Make sure that the device desired by this CRTC is not
        ; in use by any other active CRTCCX on the board.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    pGNCrtcCXOffset
        call    GN_IsDevDataUniqueOnBoard
        or      eax,eax
        mov     dwUnusedIndex,0
        jne     IsUnique

TryOther:
        ; Nope! The device is in use!
        ; Set the device used by the CRTCCX to nothing
        push    pGNCrtcCXOffset
        pushd   0FFFFFFFFH
        call    GN_SetDevData

        ; Find an unused device
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    dwUnusedIndex
        call    GN_FindUnusedDevice

        ; If there isn't an unused device, then abort the attach
        cmp     eax,-1
        je      FailIt
        mov     dword ptr LocalDevData,eax

        ; Find unused device can find a device type and a device
        ; number. However, in order to get a device format (like
        ; NTSCM, or PALA), we need to ask the ResMan what the
        ; last format was on that device. Right now, this only
        ; applies if the device type is a tv, but for consistency
        ; I always get the last display format. For non-tv's,
        ; this will simply set the format to 0.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     GotDevData
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax
        jmp     GotDevData

IsUnique:
        ; OK, sure it's unique, but is the device connectable to some
        ; head? (any head - it doesn't matter right now which one.)
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    dword ptr LocalDevData
        call    HW_IsDeviceAttached
        or      eax,eax
        je      TryOther

        ; If this device doesn't work, then dwUnusedIndex will
        ; be incremented and we will start scanning at the zeroth
        ; unused device for others that might.
        mov     dwUnusedIndex,-1

GotDevData:
        ; OK, tentatively, we will allow this CRTCCX to be
        ; the device type / number found.
        push    pGNCrtcCXOffset
        push    dword ptr LocalDevData
        call    GN_SetDevData

        ; OK, we have a unique device (from the others in use)
        ; that is connected to the system. Now can we find an
        ; arrangment whereby this device can be used?
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; Ask the hardware if it is possible to have all the
        ; devices specified enabled simultaneously by assigning
        ; each to a different head.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    dwDeviceCount
        call    HW_CanDevicesBeMapped
        or      eax,eax
        jne     GoodToGo

        ; If we only have one device, failing the mapping is fatal.
        cmp     dwDeviceCount,1
        je      FailIt

        ; Failing the mapping when there is more than one device
        ; may simply mean that the set of devices requested cannot
        ; all be used simultaneously. But there might be a different
        ; device which is available which could be used for the new
        ; CRTC we are trying to attach.
        inc     dwUnusedIndex
        jmp     TryOther

GoodToGo:
        ; OK, NOW we can read the EDID
        mov     edi,pGNCrtcCXOffset
        lea     ebx,[edi].GNCRTCCX.sCrtcModeInfo
        cmp     ds:[ebx].MODEINFO.MIDevData.cType,DEVTYPE_TV
        je      SkipEdidRead
        
        mov     ds:[edi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        push    ds:[ebx].MODEINFO.MIDevData
        lea     eax,[edi].GNCRTCCX.sEdidBuffer
        push    eax
        lea     eax,[edi].GNCRTCCX.dwEdidSize
        push    eax
        call    HW_ReadEdid
        
SkipEdidRead:
        ; Write out the display device for the CRTCCX
        push    pGNCrtcCXOffset
        call    GN_GetDevData
        mov     dword ptr LocalDevData,eax
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        push    dwPhysicalDeviceNum
        push    lpLocalDevData
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     SkipTVFormat
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_SetResManTvFormat
        
SkipTVFormat:
        ; Tell the HWLOGDEVCX about its new CRTCCX
        mov     eax,pGNCrtcCXOffset
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwPhysicalDeviceNum
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        call    HW_LogdevAttachCrtc

        ; One more CRTC attached to this logical device
        inc     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        mov     ebx,dwPhysicalDeviceNum
        mov     eax,1

        ; If this was a clone device that was added, then we can
        ; decrement WaitingOnAClone if it is > 0.
        or      ebx,ebx
        je      DoneIt
        sub     ds:[esi].GNLOGDEVCX.dwNumClonesAwaited,1
        jge     DoneIt
        mov     ds:[esi].GNLOGDEVCX.dwNumClonesAwaited,0
        jmp     DoneIt

FailIt:
        ; remove the CRTCCX from our array since it isn't
        ; going to work.
        sub     eax,eax
        mov     ecx,dwPhysicalDeviceNum
        mov     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4],eax

        push    pGNCrtcCXOffset
        call    GN_DestroyCrtcContext
        sub     eax,eax

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_LogdevDetachCrtc
;
; Purpose:      This routine detaches a CRTC from a logical device
;               removing a viewable display from a logical desktop.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwPhysDevNum            0 based CRTCCX to detach
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevDetachCrtc, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   dwPhysDevNum
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpHWCrtcCX
LOCALD  dwDeviceCount
LOCALD  dwDevicesChanged
LOCALD  dwDeviceMask
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; Is there a valid GNCRTCCX in that logical slot?
        mov     edi,dwPhysDevNum
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        or      ecx,ecx
        je      DoneIt

        ; Some prep for other code
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Tell the HWLOGDEVCX to detach its CRTCCX
        ; We MUST be careful here. If DDRAW has locked
        ; our HWCRTCCX, we must use the cached copy to free
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        mov         eax,ds:[ecx].GNCRTCCX.pHWCrtcCX
        or          eax,eax
        jne         @F
        mov         eax,ds:[ecx].GNCRTCCX.pHWCrtcCXWhenLocked
        mov         ds:[ecx].GNCRTCCX.pHWCrtcCX,eax
        mov         ds:[ecx].GNCRTCCX.pHWCrtcCXWhenLocked,0
@@:
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwPhysDevNum
        push    eax
        call    HW_LogdevDetachCrtc

        ; What display devices will be in use AFTER we detach this
        ; CRTC. Well, GetDevDataMask will tell give us a mask of
        ; all the display devices EXCEPT the one is use by the
        ; CRTCCX passed in.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        call    GN_GetDevDataMask
        mov     dwDeviceMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    eax
        call    HW_BeginDisplayChange

        ; Destroy the CRTCCX
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        mov     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        call    GN_DestroyCrtcContext

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDeviceMask
        call    HW_EndDisplayChange

        ; One less CRTC attached to this logical device
        dec     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        mov     eax,1

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_LogdevAddAClone
;
; Purpose:      This routine tries to adda clone display to the logical
;               device.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwPhysDevNum            0 based CRTCCX to detach
;
; Returns:
;               eax                     0       Failed
;                                       non-0   Success
;                                               In this case ebx holds
;                                               the physical device index
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevAddAClone, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALV  sDesktopModeInfo,MODEINFO
LOCALD  lpDesktopModeInfo
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; OK, normal->clone means we attach a crtc
        push    esi
        call    GN_LogdevAttachCrtc

        ; If we couldn't attach, then stay in normal mode
        or      eax,eax
        je      DoneIt
        mov     edi,ebx

        ; Build up the desktop MODEINFO
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax

        ; Set the MIDevData into sDesktopModeInfo.
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        call    GN_GetDevData
        mov     sDesktopModeInfo.MIDevData,eax
        
        ; Get the refresh rate from the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        jne     UseRefreshRate

        ; No mode in the registry, use 60Hz as default.
        mov     sDesktopModeInfo.dwRefreshRate,60

UseRefreshRate:
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     sDesktopModeInfo.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     sDesktopModeInfo.dwYRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     sDesktopModeInfo.dwBpp,eax

        ; Only set the desktop mode into the registry of the primary
        ; display device.
        cmp     edi,0
        jne     SkipSetDesktop
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDesktopModeInfo
        push    eax
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetCloneDesktopSelection,es,ax
        cmp     ax,1
        mov     eax,0
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax

SkipSetDesktop:
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDesktopModeInfo
        push    eax
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax
        mov     sDesktopModeInfo.dwRefreshRate,60

        ; I know these are wrong. We haven't yet mapped devices.
        ; There is a partial chicken or egg problem here. It is
        ; not too big a deal because by the time we actually go
        ; to set the physical mode, these will be valid and we
        ; will back off if need be.
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        lea     edx,[edx].GNCRTCCX.sNvmodeDispData
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz8bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz16bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz32bpp,40000000H

        ; Get the CRTC mode (the desktop mode is just a suggestion)
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_GetCrtcMode

        ; There are a few things whose state we would like to grab
        ; from the primary CRTCCX and copy into this new clone device's
        ; CRTCCX.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[0 * 4]
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]

        ; First, The pan base and pitch
        mov     eax,ds:[ebx].GNCRTCCX.dwBytesPerPixelInCurrentMode
        mov     ds:[ecx].GNCRTCCX.dwBytesPerPixelInCurrentMode,eax
        mov     eax,ds:[ebx].GNCRTCCX.dwBytesPerLineInCurrentMode
        mov     ds:[ecx].GNCRTCCX.dwBytesPerLineInCurrentMode,eax

        ; One last thing. Right now the default palette / gamma table
        ; is in the new clone CRTCCX. This is probably not right. We
        ; should copy the palette and gamma table from the primary
        ; CRTCCX just as a starting point.
        PUSHR   esi,edi
        mov     ebx,esi
        mov     edx,edi
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        lea     edi,[edi].GNCRTCCX.dwPaletteTable
        mov     esi,[esi].GNLOGDEVCX.pGNCrtcCX
        lea     esi,[esi].GNCRTCCX.dwPaletteTable
        mov     ax,ds
        mov     es,ax
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]

        sub     esi,400H
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        sub     edi,400H
        lea     edi,[edi].GNCRTCCX.dwGammaTable
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
        POPR    esi,edi

        ; Copy the Cursor cache from the primary CRTCCX into the
        ; Clone CRTCCX
        PUSHR   esi,edi
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        mov     edi,ds:[edi].GNCRTCCX.pCursorCache
        mov     esi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[esi].GNCRTCCX.pCursorCache
        mov     ecx,SIZE CURSORCACHE + (SIZE CURSORDESCEX * MAX_CACHEABLE_CURSORS)
        rep     movs byte ptr es:[edi], ds:[esi]
        POPR    esi,edi

        ; Success
        mov     eax,1
        mov     ebx,edi

DoneIt:
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNGETID.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gngetrid.asm
;
; Purpose:      This file holds the GetDriverResourceID display driver
;               entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_GetDriverResourceID
;
; Purpose:      This function is the GetDriverResourceID display driver
;               entry point.
;
; Arguments:    GetDriverResourceID Display Driver Stack Frame
;
; Returns:      The remapped resource id.
;
;==============================================================================
DECPROC GENERIC_GetDriverResourceID, PASCAL, FRAME, FAR16
PARMW   wResID
PARMD   lpResType
OPENPROC
        PUSHR   ds
        sub     edx,edx
        movzx   eax,wResID
        cmp     eax,3
        jne     @F
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     ebx,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        lds     bx,ds:[ebx].GNLOGDEVCX.lpGdiInfo
        cmp     ds:[ebx].GDIINFO.dpLogPixelsX,96
        je      @F
        mov     eax,2003
@@:     POPR    ds
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNINT2F.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnint2f.asm
;
; Purpose:      This file holds the routines dealing with int2f.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

SCREEN_SWITCH_OUT       EQU     4001H
SCREEN_SWITCH_IN        EQU     4002H

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  lpfnOldInt2FHandler
lpfnOldInt2FHandler     DD      0
dwInt2FInstalled        DD      0

PUBLIC	lpUserFullscreenDOSBoxFlag
lpUserFullscreenDOSBoxFlag	DD	0

IFDEF DEBUG
szToWindows     DB      'DISPLAY:GN_Int2FSwitchingToWindows',0DH,0AH,0
szToDos         DB      'DISPLAY:Int2FSwitchingToDos',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GN_HookInt2F
;
; Purpose:      This function hooks into the int2f chain if this is
;               the primary device and we have not already hooked
;               the chain. It is a NOP if we are a secondary
;               device or we are already in the chain.
;
; Arguments:
;               ds              Context Selector
;               pLogdevCXOffset GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HookInt2F, PASCAL, FRAME, FAR16
PARMD   pLogdevCXOffset
OPENPROC
        PUSHR   ds
        sub     eax,eax

        ; Have we already hooked it?
        cmp     eax,cs:[dwInt2FInstalled]
        jne     done

        ; Are we the primary device?
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        jne     done

        ; Use the DOS int 21H interface to get and set the 2F vector
        cli
        mov     ax,3500H+2FH
        int     21H
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     word ptr ds:[lpfnOldInt2FHandler + 0],bx
        mov     word ptr ds:[lpfnOldInt2FHandler + 2],es
        mov     ds:[dwInt2FInstalled],1

        ; Now set it to our interrupt handler
        mov     ax,SEG Int2FHandler
        mov     edx,OFFSET Int2FHandler
        mov     ds,ax
        mov     ax,2500H + 2FH
        int     21H
        sti

	push    pLogdevCXOffset
	call	GN_GetUserDosBoxFlagAddress

        ; We must tell the main VDD that we;d like to recieve int2fs.
        mov     eax,4000H
        int     2FH
done:
        POPR    ds
CLOSEPROC


;==============================================================================
;
; Function:     GN_UnhookInt2F
;
; Purpose:      This function unhooks us from the int2f chain if
;               we are currently hooked. Otherwise it just returns.
;
; Arguments:
;               ds              Context Selector
;               pLogdevCXOffset GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_UnhookInt2F, PASCAL, FRAME, FAR16
PARMD   pLogdevCXOffset
OPENPROC
        PUSHR   ds

        sub     eax,eax
        cmp     eax,cs:[dwInt2FInstalled]
        je      done

        ; Use the DOS int 21H interface to reset the old vector
        cli
        sub     ecx,ecx
        mov     eax,cs:[lpfnOldInt2FHandler]
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[dwInt2FInstalled],ecx
        mov     dx,ax
        shr     eax,10H
        mov     ds,ax
        mov     ax,2500H + 2FH
        int     21H
        sti
done:
       POPR     ds
CLOSEPROC


;==============================================================================
;
; Function:     Int2FHandler
;
; Purpose:      This function is the int2F handler. Lots of things come
;               through here, but we only care about ScreenSwitchIn and
;               ScrenSwitchOut.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC Int2FHandler, PASCAL, NOFRAME, FAR16
OPENPROC
        cmp     ax,SCREEN_SWITCH_IN
        je      Int2FSwitchingToWindows
        cmp     ax,SCREEN_SWITCH_OUT
        je      Int2FSwitchingToDos
        jmp     FFP16 PTR lpfnOldInt2FHandler

Int2FHandler    ENDP


;==============================================================================
;
; Function:     Int2FSwitchingToWindows
;
; Purpose:      This function is the int2F handler once it is known
;               that we are doing a screen switch in (going to Windows).
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC Int2FSwitchingToWindows, PASCAL, NOFRAME, FAR16
OPENPROC
        push    bp
        mov     bp,sp
        PUSHR   alld,ds,es,fs,gs
        call    GN_Int2FSwitchingToWindows
        POPR    alld,ds,es,fs,gs
        and     word ptr [bp + 6],NOT 1
        pop     bp
        iret

Int2FSwitchingToWindows ENDP


;==============================================================================
;
; Function:     GN_Int2FSwitchingToWindows
;
; Purpose:      This function is the same as GN_Int2FSwitchingToWindows
;               and is called from it.  The only difference is, this
;               routine can be called from anywhere because it does a
;               ret instead of an iret.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds, esi, edi
;==============================================================================
DECPROC GN_Int2FSwitchingToWindows, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szToWindows
        push    eax
        call    GENERIC_OutputDebugString
ENDIF
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,0

        ; Bypass routine if we are already in windows mode.
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        je      @F

        ; Send a message down the chain
        push    esi
        pushd   MSG_DOSOFF
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        ; Tell the VDD we are going to HiRes
        call    GN_VddDriverRegister

        ; UserRepaint sometimes takes a few seconds to take effect.
        ; Clear the screen to black or else we see garbage on the
        ; screen for those few seconds.
        sub     eax,eax
        push    CSlp16LogDevice_In_NVTEXT16
        push    eax
        push    eax
        push    eax
        push    ds:[esi].DIBENGINE.deWidth
        push    ds:[esi].DIBENGINE.deHeight
        push    eax
        push    eax
        push    eax
        call    GENERIC_BitBlt

        ; Now ask User to repaint the screen
        push	esi
        call    GN_UserRepaint

	cmp	cs:[lpUserFullscreenDOSBoxFlag],0
	je	@F
	; This corrects for the fact that occassionally USER does
	; not RESET its own internal flag that indicates that it is
	; no longer in a fullscreen DOS box.
	lds	si,cs:[lpUserFullscreenDOSBoxFlag]
	and	byte ptr ds:[si],NOT 8
@@:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     Int2FSwitchingToDos
;
; Purpose:      This function is the int2F handler once it is known
;               that we are doing a screen switch out (going to Dos).
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC Int2FSwitchingToDos, PASCAL, NOFRAME, FAR16
OPENPROC
        push    bp
        mov     bp,sp
        PUSHR   alld,ds,es,fs,gs

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szToDos
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; Clear the screen before issuing the unregister. Otherwise
        ; we sometimes see a flash of garbage.
        sub     eax,eax
        push    CSlp16LogDevice_In_NVTEXT16
        push    eax
        push    eax
        push    eax
        push    ds:[esi].DIBENGINE.deWidth
        push    ds:[esi].DIBENGINE.deHeight
        push    eax
        push    eax
        push    eax
        call    GENERIC_BitBlt

        ; If the BUSY bit is already set, it is beacuse the VDD is
        ; orchestrating the switch to DOS (e.g. user pressed Alt-Tab)
        ; If it is not set, then inform the VDD we are going to DOS.
        test    ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY
        jnz     @F

        call    GN_VddDriverUnregister
@@:
        ; Send a message down the chain
        push    esi
        pushd   MSG_DOSON
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        POPR    alld,ds,es,fs,gs
        and     word ptr [bp + 6],NOT 1
        pop     bp
        iret

Int2FSwitchingToDos     ENDP


;==============================================================================
;
; Function:     GENERIC_ResetHiresMode
;
; Purpose:      This function is called from the main VDD when switching
;               from a full screen DOS back to Windows. We need to get
;               back into a HiRes mode here. (The resource manager
;               may be catching the SET_FOCUS call in VDD land and
;               doing the mode set itself, so we may not need to do
;               anything here. Just in case.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC GENERIC_ResetHiresMode, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        mov     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,1
        call    GN_Int2FSwitchingToWindows

        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:	GN_GetUserDosBoxFlagAddress
;
; Purpose:
;		This fixes a bug in USER that is DOS-box switching timing
;		related. The probem is that USER maintains a bit, which
;		when set, indicates we are in a full-screen DOS box; when
;		clear, we are in the Windows desktop. Sometimes, when
;		coming back from a fullscreen DOS box, particularly on
; 		the character mode tests in WHQL, for some reason, the
;		bit does not get cleared and USER ends up thinking that
;		we are in a full-screen DOS BOX when we are really on
;		the Windows desktop. This causes ChangeDisplaySettingsEx
;		to fail without even getting to the display driver.
;
;		The solution is to flip this bit ourselves whenever we
;		receive a SET_DEVICE_FOCUS message in the minivdd to
;		switch from FullScreenDos to FullScreen Windows.
;
; Arguments:	pLogdevCXOffset		GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetUserDosBoxFlagAddress, PASCAL, FRAME, FAR16
PARMD   pLogdevCXOffset
LOCALW	wUserHandle
LOCALV	sVersionInfo,OSVERSIONINFOW
OPENPROC
	PUSHR	esi,edi

	; Assume for a second Let's get USER
        mov     ax,_DATA
        shl     eax,10H
        mov     ax,OFFSET szUserModuleName
        push    eax
        call    GetModuleHandle
        mov	wUserHandle,ax

	; Now check the version of the OS
	mov	sVersionInfo.dwOSVersionInfoSize,SIZE OSVERSIONINFOA
	mov	ax,ss
	shl	eax,10H
	lea	ax,sVersionInfo
	push	eax
	call	GetVersionEx
	or	ax,ax
	je	DoneIt

	; Dispatch to correct OS handler
	mov	eax,sVersionInfo.dwMajorVersion
	mov	ecx,sVersionInfo.dwMinorVersion
	mov	edx,sVersionInfo.dwBuildNumber

	; Make sure it is Windows 9X
	cmp	eax,4
	jne	DoneIt

	; We don't care about Windows 95
	cmp	ecx,0			; Windows 95
	je	DoneIt

	; Check for the three versions of 9X we care about
	cmp	ecx,90			; Windows ME
	jne	NotWinME
	cmp	edx,45A0BB8H
	je	IsOK
	jmp	DoneIt

NotWinME:
	; Windows 98 and Windows 98SE have the same Major
	; and Minor version numbers and build number.
	cmp	ecx,10			; Windows 98,98SE
	jne	DoneIt
	cmp	edx,040A08AEH		; Windows 98,98SE
	jne	DoneIt

IsOK:
	; The technique to get the address of the flag is the same
	; in Win98, Win98SE and WinME so we just use one code path.
	push	wUserHandle
	pushd	602
	call	GetProcAddress
	mov	cx,dx
	or	cx,ax
	je	DoneIt

	; Lets' make sure we won't fault if we read it
	PUSHR	ax,dx
	push	dx
	push	ax
	pushw	30H
	call	IsBadReadPtr
	POPR	di,si
	or	ax,ax
	jne	DoneIt

	; Now we can load the ptr to the code.
	; Let's do a few checks to see if everything is cool.
	mov	fs,si
	cmp	byte ptr fs:[di + 5],0B8H
	jne	DoneIt
	cmp	word ptr fs:[di + 25H],6F6H
	jne	DoneIt

	; There should be a ptr to USER's data selector at offset 6
	mov	si,fs:[di + 6]
	mov	di,fs:[di + 27H]

	; Suppsedly si is the data selector we want. The bit that
	; says "I am in fullscreen DOS" is at si:76A bit 3. Let's
	; make sure that we can read and write that byte.
	push	si
	push	di
	pushw	1
	call	IsBadWritePtr
	or	ax,ax
	jne	DoneIt

	; Everything looks OK. Let's save the address
	mov     es,cs:[wNVTEXT16_Alias_In_NVTEXT16]
	shl	esi,10H
	mov	si,di
	mov	es:[lpUserFullscreenDOSBoxFlag],esi

DoneIt:
	POPR	esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNLOGDEV2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnlogdev.asm
;
; Purpose:      This file holds runtime routines dealing with the
;               GNLOGDEVCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include escape.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_LogdevMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
;               The dwData1 and dwData2 parameters may get
;               overridden by this routine.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwMessage               which message
;               dwData1                 extra data
;               dwData2                 extra data
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevMessage, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
LOCALD  pGNCrtcCXOffset
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        cmp     eax,MSG_LOGDEVMOVED
        je      LogdevMove
        jmp     ChainIt

PreMS:
        ; Flag that we are busy
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,1

        ; Clear the SaveScrenBitmapCache
        push    pGNLogdevCXOffset
        call    GN_ClearSaveScreenBitmapCache
        jmp     ChainIt

PostMS:
        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      @F

        ; Only if we are initting AND only if this is the first
        ; logical device on this board (i.e. we are booting windows.)
        cmp     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        jne     @F
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_DoOddballStuffAtBoot
@@:
        ; Flag that we are no longer busy
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0

        ; If this is a secondary driver, tell the ResMan we are in
        ; spanning mode.
        cmp     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        je      SkipCallToRM

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        pushd   1
        call    HW_TellResManSpanningState

SkipCallToRM:

        ; We are no longer initting after the first modeset
        mov     ds:[esi].GNLOGDEVCX.dwInitting,0
        jmp     ChainIt

DXEnum:
DXOn:
DXOff:
        jmp     ChainIt

DosOff:
PowerOn:
        ; Enable SW access to device
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT BUSY

        ; Indicate a screen switch in has occurred.
        mov     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jmp     ChainIt

DosOn:
PowerOff:
        ; Disable SW access to device
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY

        ; Wait until all hardware contexts are idle
        push    esi
        mov     esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess_Far32
        pop     esi

        ; Indicate a screen switch out has occurred.
        mov     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,1
        jmp     ChainIt

DrvDis:
        ; Disable HW & SW access to device
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,1
        jmp     ChainIt

LogdevMove:
        ; Reset the ptr to the BitmapInfo structure
        ; alloc pointer to new location.
        mov     eax,[esi].GNLOGDEVCX.Dibeng.deBitmapInfo
        shr     eax,10h
        lea     ebx,[esi].GNLOGDEVCX.bmi
        push    ax
        push    ebx
        call    SetSelectorBase

        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    dwData2
        push    dwData1
        call    GN_ReattachLogicalDeviceToBoard
        jmp     ChainIt

ChainIt:
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    GN_BoardMessage

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    HW_LogdevMessage

        ; Create the GNCRTCCXs
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     dwCRTCCount,0
@@:
        ; Make sure this CRTC ptr is not NULL
        cmp     dword ptr ds:[edi],0
        je      SkipIt3

        push    dword ptr ds:[edi]
        push    dwMessage
        push    dwData1
        push    dwData2
        call    GN_CrtcMessage

SkipIt3:
        ; Next CRTCCX
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B

DoneIt:
        POPR    esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GN_OffscreenHeapDisappearing
;
; Purpose:      This routine gets called whenever the offscreen
;               heap is disappearing.
;
;               Right now, we simply flush our save screen bitmap cache.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_OffscreenHeapDisappearing, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
OPENPROC
        push    pGNLogdevCXOffset
        call    GN_ClearSaveScreenBitmapCache
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResolveDeviceConnectionsOnLoad
;
; Purpose:      This routine gets called just before we attach the
;               first CRTC in a display driver. It gives us a chance
;               to modify what we think the display devices should be.
;
;               UseHwSelectedDevice registry key is interpreted as:
;               0 - use NVidia behavior for establishing device types
;                   when a driver loads (whatever means NVidia wants)
;               1 - Ask the RM for the device types
;               2 - Use a specific behavior described later
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ResolveDeviceConnectionsOnLoad, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  LocalDevData
LOCALD  LocalDevData2
LOCALD  BootDevData
LOCALW  wMobile
LOCALV  tvd,NVTWINVIEWDATA
LOCALD  lpTVD
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset
        mov     ax,ss
        shl     eax,10H
        lea     ax,tvd
        mov     lpTVD,eax

        ; This routine returns TRUE if we want mobile device behavior
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        mov     wMobile,ax

        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     SecondaryDriver

PrimaryDriver:
        ; See if we want mobile device bahavior
        cmp     wMobile,0
        je      DoneIt

        ; Ask the HW for the boot device
        ; (the HW probably asks the BIOS or RM).
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        pushd   0                       ; get the primary device instance
        call    HW_GetBootDevice
        mov     dword ptr LocalDevData,eax

        ; We only get called for the primary once when it first
        ; loads. Hence, at this point, we may even want to override
        ; what the HW told us is the boot device with a forced boot
        ; device from the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10h
        lea     ax,BootDevData
        push    eax
        CALLFAR16IND lpfnGetBootDevice,es,ax
        or      ax,ax
        je      @F
        mov     eax,BootDevData
        mov     LocalDevData,eax
@@:
        ; If for some reason, the HW didn't return any display
        ; devices, we'll just leave things as is.newu
        cmp     LocalDevData,-1
        je      DoneIt

        ; OK, we know the primary boot display. Write it out
        sub     ecx,ecx
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ecx                             ; Logical device 0
        push    ecx                             ; Physical Device 0
        mov     bx,ss
        shl     ebx,10H
        lea     bx,LocalDevData
        push    ebx
        CALLFAR16IND lpfnSetDisplayDevice,es,ax
        
        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     SkipTVFormat
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    LocalDevData
        call    HW_SetResManTvFormat
        
SkipTVFormat:
        ; Now, ask the HW if we booted with more than one display
        ; active and, if so, what was the second display device type.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        pushd   1                       ; get the next instance
        call    HW_GetBootDevice
        mov     dword ptr LocalDevData2,eax
        cmp     eax,-1
        je      PrimaryIsStandard

PrimaryIsCloned:
        ; Write the desktop state to clone
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_CLONE
        CALLFAR16IND lpfnSetDesktopState,es,ax

        ; Write out the clone display device type
        sub     ecx,ecx
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ecx                             ; Logical device 0
        inc     ecx
        push    ecx                             ; Physical Device 1
        mov     bx,ss
        shl     ebx,10H
        lea     bx,LocalDevData2
        push    ebx
        CALLFAR16IND lpfnSetDisplayDevice,es,ax
        jmp     DoneIt

        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     PrimaryIsStandard
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    LocalDevData2
        call    HW_SetResManTvFormat
        
PrimaryIsStandard:
        ; Write the desktop state to clone
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_NORMAL
        CALLFAR16IND lpfnSetDesktopState,es,ax
        jmp     DoneIt


SecondaryDriver:
        ; Write out desktop state to standard. If we have a secondary
        ; display driver loaded, we definitely aren't in clone.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_NORMAL
        CALLFAR16IND lpfnSetDesktopState,es,ax

        ; This routine returns TRUE if we want mobile device behavior
        cmp     wMobile,1
        jc      DoneIt
        cmp     wMobile,2
        je      SpecialBehavior2

SecondDriverAskRm:
        ; Now, ask the HW if we booted with more than one display
        ; active and, if so, what was the second display device type.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        pushd   1                               ; get the next instance
        call    HW_GetBootDevice
        mov     dword ptr LocalDevData2,eax

        ; If we only booted on a single display device, then
        ; we just leave the registry as is and we will end up
        ; using whatever the registry said was the last display
        ; device used by the secondary driver.
        cmp     eax,-1
        je      DoneIt

        ; If we booted on two display devices, then use the second
        ; one as the secondary device.
        sub     ecx,ecx
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ecx                             ; Logical device 1
        push    ecx                             ; Physical Device 0
        mov     bx,ss
        shl     ebx,10H
        lea     bx,LocalDevData2
        push    ebx
        CALLFAR16IND lpfnSetDisplayDevice,es,ax
        
        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     DoneIt
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    LocalDevData2
        call    HW_SetResManTvFormat
        
        jmp     DoneIt
        
SpecialBehavior2:

        ; NOTE:
        ;       (N) means Normal (standard mode)
        ;       (C) means clone,                (M) Multi-mon
        ;       In clone mode
        ;       (1) means primary device        (2) means clone device
        ;       In multi-mon
        ;       (P) means primary device        (S) means secondary device
        ;
        ; At this point we are definitely going to multi-mon
        ; (if there are at least two display devices connected).
        ; It is just a question of which display devices we will
        ; be using for the primary and the secondary.
        ;
        ; If currently in this config,  then go to this config
        ; (N) LCD                       (M) LCD (P), CRT (S)
        ; (C) LCD (1), CRT (2)          (M) LCD (P), CRT (S)
        ; (N) CRT                       (M) LCD (P), CRT (S)
        ; (C) LCD (1), TV (2)           (M) LCD (P), TV  (S)
        ; (N) TV                        (M) LCD (P), TV  (S)

        ; Is the primary driver currently in clone mode?
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     edi,dword ptr ds:[ebx].GNBOARDCX.pGNLogdevCX

CheckCurrentPrimary:
        ; Is the current primary the DFP?
        push    dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        mov     LocalDevData,eax

        ; Remember this ... and assume normal mode
        mov     ebx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        mov     ds:[ebx].GNBOARDCX.dwOldPrimaryDevData,eax
        mov     ds:[ebx].GNBOARDCX.dwOldTwinviewState,NVTWINVIEW_STATE_NORMAL
        mov     ds:[ebx].GNBOARDCX.dwCheckCursorTicksSinceSecondDriverLoaded,0

        cmp     al,DEVTYPE_DFP
        jne     @F

        ; OK, the primary is the DFP. If there is a clone device,
        ; it will determine the device type to set on the second driver.
        ; If there isn't a clone device, the second driver gets a CRT.
        mov     LocalDevData,DEVTYPE_CRT
        mov     eax,dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX+4
        or      eax,eax
        je      @F
        push    eax
        call    GN_GetDevData
        mov     LocalDevData,eax

        ; Remember the clone device type and that we were in clone mode
        mov     ebx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        mov     ds:[ebx].GNBOARDCX.dwOldCloneDevData,eax
        mov     ds:[ebx].GNBOARDCX.dwOldTwinviewState,NVTWINVIEW_STATE_CLONE

@@:
        ; First, go to normal mode (if we are already, there, that's fine.)
        mov     tvd.dwFlag,NVTWINVIEW_FLAG_SET
        mov     tvd.dwAction,NVTWINVIEW_ACTION_SETGET_STATE
        mov     tvd.dwState,NVTWINVIEW_STATE_NORMAL

        push    ds:[edi].GNLOGDEVCX.Dibeng.delpPDevice
        pushw   NV_ESC_SETGET_TWINVIEW_DATA
        push    lpTVD
        push    lpTVD
        call    Control

        ; Make the DFP primary (just in case it isn't)
        mov     tvd.dwFlag,NVTWINVIEW_FLAG_SET
        mov     tvd.dwAction,NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE
        mov     tvd.dwCrtc,0
        mov     ecx,DEVTYPE_DFP
        call    HW_MapGNDeviceTypeToHWDeviceType
        mov     tvd.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType,ecx
        mov     tvd.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat,0

        push    ds:[edi].GNLOGDEVCX.Dibeng.delpPDevice
        pushw   NV_ESC_SETGET_TWINVIEW_DATA
        push    lpTVD
        push    lpTVD
        call    Control

        ; Set the physical mode in the GNCRTCCX to the desktop mode
        ; so the physical mode set will be as close as possible to the
        ; desktop mode.
        sub     ebx,ebx
        mov     eax,ds:[edi].GNLOGDEVCX.pGNCrtcCX
        les     bx,ds:[eax].GNCRTCCX.lpCrtcModeInfo
        sub     eax,eax
        mov     ax,ds:[edi].DIBENGINEHDR.deWidth
        mov     es:[ebx].MODEINFO.dwXRes,eax
        mov     ax,ds:[edi].DIBENGINEHDR.deHeight
        mov     es:[ebx].MODEINFO.dwYRes,eax
        sub     ax,ax
        mov     al,ds:[edi].DIBENGINEHDR.deBitsPixel
        mov     es:[ebx].MODEINFO.dwBpp,eax
        
WriteOutType:
        ; If device type is TV, get the TV format from the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        je      @F
        mov     eax,dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX[4]
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax
@@:
        ; Now we can set the display device type. Please note the ResMan
        ; already has the correct TV Format which we just got above.
        mov     ebx,dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX
        mov     eax,1
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    eax
        dec     eax
        push    eax
        mov     ax,ss
        shl     eax,10h
        lea     ax,LocalDevData
        push    eax
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResolveDeviceConnectionsOnUnload
;
; Purpose:      This routine gets called just before we attach the
;               first CRTC in a display driver. It gives us a chance
;               to modify what we think the display devices should be.
;
;               UseHwSelectedDevice registry key is interpreted as:
;               0 - use NVidia behavior for establishing device types
;                   when a driver loads (whatever means NVidia wants)
;               1 - Ask the RM for the device types
;               2 - Use a specific behavior described later
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ResolveDeviceConnectionsOnUnload, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALV  LocalDevData,DEVDATA
LOCALW  wMobile
LOCALV  sModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; This routine returns the type of mobile behavior we want
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        mov     wMobile,ax

        ; Nothing to do if we are unloading the primary driver!
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        je      DoneIt

SecondaryDriver:
        cmp     wMobile,2
        je      SpecialBehavior2

        ; Standard mobile behavior is NVidia default behavior
        ; which is to restore the last Clone or standard state
        ; they had before enabling multi-mon.

        ; So, we probably detached a CRTCCX when the logical device
        ; was destroyed. There may be another logical device on this
        ; board that would like to have the CRTCCX. Let's find out.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_FindLogdevWaitingToClone
        or      eax,eax
        je      DoneIt

        ; There was a logical device that wanted a clone! Try to
        ; add a clone to it.
        push    eax
        call    GN_LogdevAddAClone
        or      eax,eax
        je      DoneIt

        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        call    HW_DriverTwinviewStateChanging

        ; We aren't going to receive a ReEnable call to reset all the
        ; CRTC modes. We must force a refresh here.
        push    esi
        call    GN_CrtcRemapArray
        push    esi
        call    GN_RestoreAllCrtcStates
        jmp     DoneIt

SpecialBehavior2:
        ; Special behavior #2 says that from any multi-mon config,
        ; we should always go back to Clone with LCD on the primary
        ; and CRT as the clone device.

        ; HOWEVER!!!! If we are unloaded very soon (within a second
        ; or two of when we are loaded), then this is probably just
        ; a "FAKE" unload. i.e. When enabling multi-mon, Windows
        ; loads and unloads the display driver a couple times. If
        ; we go back to LCD/CRT clone mode now, and then we instantly
        ; get reloaded, then we will go into LCD/CRT multimon. If
        ; this whole sequence started with LCD/TV clone, then we
        ; end up in the wrong state. Hence, on "FAKE" unloads, we
        ; restore the display device state that existed when we were
        ; loaded.
        mov  edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp  ds:[edi].GNBOARDCX.dwCheckCursorTicksSinceSecondDriverLoaded,20H
        ja   DriverUnloadIsReal

DriverUnloadIsFake:
        ; Reset the old state.

        ; Reset the primary device type to be what it was
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[edi].GNBOARDCX.dwOldPrimaryDevData
        call    GN_SetDevData

        ; Were we in clone mode?????
        cmp     ds:[edi].GNBOARDCX.dwOldTwinviewState,NVTWINVIEW_STATE_NORMAL
        je      FinishUp

        ; Add a clone device.
        push    esi
        call    GN_LogdevAddAClone
        or      eax,eax
        je      FinishUp

        ; Make sure the clone device type is whatever it was previously
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        push    ds:[edi].GNBOARDCX.dwOldCloneDevData
        call    GN_SetDevData

DriverUnloadIsReal:
        ; First, make the primary device the DFP
        mov     LocalDevData.cType,DEVTYPE_DFP
        mov     LocalDevData.cNumber,0
        mov     LocalDevData.cFormat,0

        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    dword ptr LocalDevData
        call    GN_SetDevData

        ; Add a clone device.
        push    esi
        call    GN_LogdevAddAClone
        or      eax,eax
        je      FinishUp

        ; Make sure the clone is the CRT
        mov     LocalDevData.cType,DEVTYPE_CRT
        mov     LocalDevData.cNumber,0
        mov     LocalDevData.cFormat,0
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        push    dword ptr LocalDevData
        call    GN_SetDevData

        ; Now that we have the correct display device for the clone, we
        ; need to make sure we write the desktop mode to the MODEINFO
        ; structure so we will set the clone as close as possible to
        ; the desktop mode.
        
        ; Build up the desktop MODEINFO
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        sub     ebx,ebx
        lfs     bx,ds:[eax].GNCRTCCX.lpCrtcModeInfo
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     fs:[ebx].MODEINFO.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     fs:[ebx].MODEINFO.dwYRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     fs:[ebx].MODEINFO.dwBpp,eax
        
        ; Get the refresh rate from the registry for the CRT as the clone.
        mov     ah,LocalDevData.cFormat
        mov     al,LocalDevData.cNumber
        shl     eax,8
        mov     al,LocalDevData.cType
        mov     sModeInfo.MIDevData,eax
        
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        push    ds:[eax].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     ebx,ss:[ebx].MODEINFO.dwRefreshRate
        or      ax,ax
        jne     UseRefreshRate

        ; No mode in the registry, use 60Hz as default.
        mov     ebx,60  

UseRefreshRate:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        sub     eax,eax
        lfs     ax,ds:[ecx].GNCRTCCX.lpCrtcModeInfo
        mov     fs:[eax].MODEINFO.dwRefreshRate,ebx
        
FinishUp:
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        call    HW_DriverTwinviewStateChanging

        ; We aren't going to receive a ReEnable call to reset all the
        ; CRTC modes. We must force a refresh here.
        push    esi
        call    GN_CrtcRemapArray
        push    esi
        call    GN_RestoreAllCrtcStates

DoneIt:
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNMEM.ASM ===
;===================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnmem.asm
;
; Purpose:      This file holds routines for the linear memory heap
;               manager. You can create and destroy heaps, allocate
;               memory from the heap and free memory back to heap.
;
; The basic strategy is to maintain three doubly linked lists for every
; heap. The elements in every list are always MEMINFO structures. There
; are a fixed number of total elements which places a limit on how many
; allocations that can be oustanding at any one time. This fixed number
; can be run-time decided, however, and shouldn't affect performance as
; long as it is made large enough to accomodate sufficient simultaneous
; allocations. The three lists are:
;
; The ALLOC list contains elements describing linear chunks of the heap
; which are currently allocated.
;
; The FREE list contains elements describing linear chunks of the heap
; which are NOT currently allocated.
;
; The MANAGEMENT list (or MAN list) contains elements which can be used
; as either an element in the ALLOC list or the FREE list.
;
; Whenever a new chunk of memory is allocated, a MEMINFO element is
; pulled out of the MAN list and placed into the ALLOC list after being
; filled in appropriately to describe the new allocation. Also, a MEMINFO
; element in the FREE list is modified to reflect that it no longer
; describes as large a chunk of memory as it used to. Alternatively, if
; the newly alloced chunk was less than but close to the size of the
; chunk in the FREE list, then the MEMINFO element from the FREE list
; is just placed in the ALLOC list and removed from the FREE list.
;
; When memory is freed a similar process takes place. The MEMINFO element
; in the ALLOC list that is being freed is checked to see if it can be
; merged into a larger contiguous block with other elements in the FREE
; list. If it can, then a block already in the FREE list is modified to
; reflect the larger free chunk and the MEMINFO element from the ALLOC
; list is removed and placed into the MAN list. If the belock being
; freed cannot be merged, then the MEMINFO element is removed from the
; ALLOC list and placed into the FREE list.
;
; There is one block in each list that is the head block. That is an
; anchor from which I can start walking the list.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

PREPEND_BLOCK_TO_LIST   MACRO   listhead,block
        LOCAL   Eol

        mov     edi,listhead
        mov     eax,ds:[edi].MEMINFO.dwNext
        mov     ds:[edi].MEMINFO.dwNext,block
        mov     ds:[block].MEMINFO.dwPrev,listhead
        mov     ds:[block].MEMINFO.dwNext,eax
        cmp     eax,SENTINEL
        je      Eol
        mov     edi,eax
        mov     ds:[edi].MEMINFO.dwPrev,block
Eol:
ENDM

INSERT_BLOCK1_AFTER_BLOCK2      MACRO  blocka,blockb
        LOCAL   Eol

        mov     edi,ds:[blockb].MEMINFO.dwNext
        mov     ds:[blockb].MEMINFO.dwNext,blocka
        mov     ds:[blocka].MEMINFO.dwPrev,blockb
        mov     ds:[blocka].MEMINFO.dwNext,edi
        cmp     edi,SENTINEL
        je      Eol
        mov     ds:[edi].MEMINFO.dwPrev,blocka
Eol:
ENDM

EXTRACT_BLOCK_FROM_LIST MACRO   block
        LOCAL   Eol

        mov     edi,ds:[block].MEMINFO.dwPrev
        mov     eax,ds:[block].MEMINFO.dwNext
        mov     ds:[edi].MEMINFO.dwNext,eax
        cmp     eax,SENTINEL
        je      Eol
        mov     ds:[eax].MEMINFO.dwPrev,edi
Eol:
ENDM

; Every allocation will be rounded up to next MINALLOCUNIT multiple
MINALLOCUNIT    EQU     64

; This marks the beginning and ending of lists
SENTINEL        TEXTEQU <-1>

; This is the list element for all three lists. It holds doubly linked
; pointers and the base and length of an allocation.
MEMINFO STRUC
        dwBase          DD      0
        dwLength        DD      0
        dwPrev          DD      0
        dwNext          DD      0
MEMINFO ENDS

; I want to keep stats on the allocations and it makes the most sense
; to store these in a few fields of the MEMINFO structures that are
; unused since I have to allocate memory for these anyway. Here are
; the stats I will be keeping and where they are being placed.

; MANHEAD.dwBase        Number of MEMINFO elements in MAN list
; MANHEAD.dwLength      Number of MEMINFO elements (Total)
; ALLOCHEAD.dwBase      Number of Allocations currently outstanding
; ALLOCHEAD.dwLength    Number of Bytes in all Outstanding Allocations
; FREEHEAD.dwLength     Number of Free Bytes left in the Heap

NUMMEMINFOS     TEXTEQU <(MEMINFO PTR ds:[MANHEAD]).dwLength>
NUMMANS         TEXTEQU <word ptr (MEMINFO PTR ds:[MANHEAD]).dwBase>
NUMALLOCS       TEXTEQU <(MEMINFO PTR ds:[ALLOCHEAD]).dwBase>
ALLOCEDBYTES    TEXTEQU <(MEMINFO PTR ds:[ALLOCHEAD]).dwLength>
TOTALBYTES      TEXTEQU <(MEMINFO PTR ds:[FREEHEAD]).dwBase>
FREEBYTES       TEXTEQU <(MEMINFO PTR ds:[FREEHEAD]).dwLength>

; The first five blocks of a heap are fixed function. These equates
; make sure I am consistent about the usage of the blocks.
MANHEAD         EQU     ((SIZE MEMINFO) * 0)
FREEHEAD        EQU     ((SIZE MEMINFO) * 1)
ALLOCHEAD       EQU     ((SIZE MEMINFO) * 2)
FIRSTFREEBLOCK  EQU     ((SIZE MEMINFO) * 3)
FIRSTMANBLOCK   EQU     ((SIZE MEMINFO) * 4)



OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_HeapCreate
;
; Purpose:      This routine creates a linear memory heap. The base
;               minimum number of simultaneous
;               allocations (MSA) are determined by the caller. For
;               example, the caller might request that the MSA be 100H.
;               Then any attempt to allocate from the
;               heap when there are alredy 100H other allocations
;               might fail even if there is enough memory. I say might
;               because it depends upon how fragmented the heap is.
;               The less fragmented the more requests can be handled
;               at the same time. However, you never get less than
;               the number requested herein and you will never get
;               more than about 2 x the number you request.
;
;               NOTE: This routine does not actually allocate allocate
;               memory for a heap. It just sets up data structures to
;               manage a linear heap. The caller must allocate memory
;               if it wants something to actually match these number to.
;
; Arguments:
;               eax     The minimum number of simultaneous allocations
;                       allowed before allocs fail
;
; Returns:      eax     Heap token if successful
;                       NULL if unsuccessful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HeapCreate, PASCAL, FRAME, FAR32
LOCALD  dwTotalMemInfos
OPENPROC
        PUSHR   ds,esi,edi

        ; There is an alloc list, a free list and a manage list.
        ; All three lists must have a header block. Plus, the worst
        ; fragmented heap will have alternating FREE and ALLOC
        ; blocks with a FREE block at the beginning and the end.
        ; Also I have a few blocks that I keep statistics in.
        ; Hence, to guarantee ecx allocations, we need at
        ; least 2 * eax + 6 MEMINFO structs.
        lea     eax,[eax * 2 + 6]
        mov     dwTotalMemInfos,eax

        ; Now allocate enough bytes for eax MEMINFO structs
        mov     ecx,SIZE MEMINFO
        imul    eax,ecx
        call    GN_MemoryAlloc
        or	eax,eax
        je	DoneIt

        mov	ds,ax
        mov	ecx,dwTotalMemInfos
	mov	NUMMEMINFOS,ecx
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapInit
;
; Purpose:      This routine inits a linear memory heap.
;
; Arguments:
;		eax	Heap Token returned from GN_HeapCreate
;		ebx     The desired base address
;               ecx     The number of bytes in the heap
;
; Returns:      Nothing
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HeapInit, PASCAL, FRAME, FAR32
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,ax

        ; Save the base address and heap size. Round heap size down to
        ; the closest multiple of the MINALLOCUNIT.
        mov     esi,ebx
        mov     edi,ecx
        and     edi,NOT (MINALLOCUNIT - 1)
        mov     eax,SENTINEL

        ; First setup the FREE list
        mov     ebx,FREEHEAD
        mov     ds:[ebx].MEMINFO.dwPrev,eax
        mov     ds:[ebx].MEMINFO.dwNext,FIRSTFREEBLOCK
        mov     FREEBYTES,edi
        mov	TOTALBYTES,edi
        mov     ebx,FIRSTFREEBLOCK
        mov     ds:[ebx].MEMINFO.dwPrev,FREEHEAD
        mov     ds:[ebx].MEMINFO.dwNext,eax
        mov     ds:[ebx].MEMINFO.dwBase,esi
        mov     ds:[ebx].MEMINFO.dwLength,edi

        ; Next, setup the ALLOC list
        mov     ebx,ALLOCHEAD
        mov     ds:[ebx].MEMINFO.dwPrev,eax
        mov     ds:[ebx].MEMINFO.dwNext,eax
        sub     ecx,ecx
        mov     NUMALLOCS,ecx
        mov     ALLOCEDBYTES,ecx

        ; Lastly, setup the MAN list
        mov     ebx,MANHEAD
        mov     ds:[ebx].MEMINFO.dwPrev,eax
        mov     ds:[ebx].MEMINFO.dwNext,FIRSTMANBLOCK
        mov     ecx,NUMMEMINFOS
        mov     NUMMANS,cx

        ; All the remaining blocks belong in the MAN list -- doubly linked
        mov     ebx,FIRSTMANBLOCK
        mov     ds:[ebx].MEMINFO.dwPrev,MANHEAD
        mov     ds:[ebx].MEMINFO.dwNext,eax
        sub     ecx,5
        jle     Done
@@:     lea     esi,[ebx + SIZE MEMINFO]
        mov     ds:[ebx].MEMINFO.dwNext,esi
        mov     edx,ebx
        add     ebx,SIZE MEMINFO
        mov     ds:[ebx].MEMINFO.dwPrev,edx
        mov     ds:[ebx].MEMINFO.dwNext,eax
        dec     ecx
        jg      @B

Done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapDestroy
;
; Purpose:      This routine destroys a linear memory heap.
;
; Arguments:    eax     Heap Token returned by GN_HeapCreate
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HeapDestroy, PASCAL, NOFRAME, FAR32
OPENPROC
        call    GN_MemoryFree
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapAlloc
;
; Purpose:      This routine allocates memory from a heap.
;
; Arguments:    eax     Heap Token returned by GN_HeapCreate
;               ecx     bytes needed from heap.
;                       NOTE: This number will be rounded up to
;                       the next multiple of MINALLOCUNIT.
;
; Returns:      eax     Offset of the allocation if successful
;                               In this case ecx = actual size allocated
;                       -1 if it could not allocate
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_HeapAlloc, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,esi,edi

        ; Get the heap token (which is the selector of a memory block
        ; that has the heap info in it) into ds.
        mov     ds,ax

        ; Round the requested allocation amount up to next multiple
        ; of MINALLOCUNIT.
        add     ecx,MINALLOCUNIT - 1
        sub     eax,eax
        and     ecx,NOT (MINALLOCUNIT - 1)

        ; See if we have at least this many bytes free in the heap.
        ; If not, don't bother walking the FREE list.
        cmp     ecx,FREEBYTES
        ja      Done

        ; Is there a MEMINFO block that can hold this allocation or
        ; will we exceed the simultaneous allocation limit?
        mov     edi,MANHEAD
        cmp     ds:[edi].MEMINFO.dwNext,SENTINEL
        je      Done

        ; Walk the FREE list looking for a free block at least as big
        ; as the rounded up request size. If we reach the end of the
        ; free list without finding one, that is an error.
        mov     esi,FREEHEAD
@@:     mov     esi,ds:[esi].MEMINFO.dwNext
        cmp     esi,SENTINEL
        je      Done
        cmp     ecx,ds:[esi].MEMINFO.dwLength
        ja      @B

        ; We found a block in the FREE list that is big enough. If the
        ; block is exactly the requested size, then just remove the free
        ; block from the free list and put it in the alloced list.
        je      MoveFreeBlockToAllocList

        ; The free block is bigger than we need. Use the first portion of
        ; the free block as our allocated area and adjust the free block
        ; to describe only the free memory after the newly allocated area.

        ; Remember the base of the free block. It will become the
        ; base of our allocation.
        mov     eax,ds:[esi].MEMINFO.dwBase

        ; Update the block in the FREE list to show it is a smaller region
        add     ds:[esi].MEMINFO.dwBase,ecx     ; The base is further
        sub     ds:[esi].MEMINFO.dwLength,ecx   ; The length is less

        ; Get a new MEMINFO struct to use to describe the allocation.
        ; One exists or we would never have gotten this far.
        mov     esi,ds:[edi].MEMINFO.dwNext     ; edi = MANHEAD remember
        dec     NUMMANS                         ; We used a MAN list block

        ; Set the base and length of this new alloced block
        mov     ds:[esi].MEMINFO.dwBase,eax     ; Base of allocation
        mov     ds:[esi].MEMINFO.dwLength,ecx   ; And the is the length

MoveFreeBlockToAllocList:
        ; Pull the MEMINFO block pointed to by esi out of the list
        ; it is in. This may be the FREE list or the MAN list, but
        ; it doesn't matter. The same code is used for both.
        EXTRACT_BLOCK_FROM_LIST esi

        ; The MEMINFO block pointed to by esi describes an allocation
        ; so place it at the head of the ALLOC list.
        PREPEND_BLOCK_TO_LIST  ALLOCHEAD,esi

        ; Now return the base address of the length of the allocation
        mov     eax,ds:[esi].MEMINFO.dwBase
        mov     ecx,ds:[esi].MEMINFO.dwLength

        ; Keep track of these -- simple and takes little time.
        inc     NUMALLOCS
        add     ALLOCEDBYTES,ecx
        sub     FREEBYTES,ecx

Done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapFree
;
; Purpose:      This routine frees memory from a heap.
;
; Arguments:    eax     Heap Token returned by GN_HeapCreate
;               ecx     Allocation offset returned by GN_HeapAlloc
;
; Returns:      eax     non-0   Valid allocation was found and freed
;                               In this case ecx = number of bytes in
;                               the allocation.
;                       0       Could not find this allocation
;                               Nothing bad happens here, but as long
;                               as you match the allocs and frees this
;                               case shouldn't really ever happen.
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_HeapFree, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,esi,edi

        ; Get the heap token (which is the selector of a memory block
        ; that has the heap info in it) into ds.
        mov     ds,ax
        sub     eax,eax

        ; Search the ALLOC list for the allocation offset
        mov     esi,ALLOCHEAD
@@:     mov     esi,ds:[esi].MEMINFO.dwNext
        cmp     esi,SENTINEL
        je      Fail
        cmp     ecx,ds:[esi].MEMINFO.dwBase
        jne     @B

        ; Found It! Remove the allocation from the ALLOC list
        EXTRACT_BLOCK_FROM_LIST esi

        ; save the amount we are freeing
        push    ds:[esi].MEMINFO.dwLength

        ; The FREE list is kept sorted so that we can merge newly
        ; freed blocks back in with existing free blocks to make
        ; the largest free blocks available. Keeping the list
        ; sorted makes this much easier.
        mov     ebx,FREEHEAD
        cmp     ds:[ebx].MEMINFO.dwNext,SENTINEL
        je      InsertEsiBlockAfterEbxBlock
@@:     mov     ebx,ds:[ebx].MEMINFO.dwNext
        cmp     ecx,ds:[ebx].MEMINFO.dwBase
        jc      TryMergeWithNextAndPrev
        cmp     ds:[ebx].MEMINFO.dwNext,SENTINEL
        jne     @B

TryMergeAtEnd:
        ; If we get here, then the esi block we are freeing might merge
        ; on the end of the last block currently in the FREE list, or it
        ; might be the new last block on the FREE list.
        mov     eax,ds:[ebx].MEMINFO.dwBase
        add     eax,ds:[ebx].MEMINFO.dwLength
        cmp     eax,ecx
        jne     InsertEsiBlockAfterEbxBlock

        ; The newly freed block pointed to by esi does merge with the
        ; current last free block pointed to by ebx.
        mov     eax,ds:[esi].MEMINFO.dwLength
        add     ds:[ebx].MEMINFO.dwLength,eax

        ; We no longer need the MEMINFO struct pointed to by esi which
        ; described the block just freed so give it back to the MAN list.
        ; Also, update the number of blocks in the MAN list.
        PREPEND_BLOCK_TO_LIST  MANHEAD,esi
        inc     NUMMANS
        jmp     Success

InsertEsiBlockAfterEdiBlock:
        mov     ebx,edi

InsertEsiBlockAfterEbxBlock:
        ; [esi] block belongs after [ebx] block
        INSERT_BLOCK1_AFTER_BLOCK2 esi,ebx
        jmp     Success

TryMergeWithNextAndPrev:
        ; We now know that the block pointed to by esi goes in the FREE
        ; list in between the block pointed to by ebx and the block
        ; before ebx in the FREE list. Let's see if the esi block merges
        ; with the ebx block, first.
        mov     edx,ds:[esi].MEMINFO.dwBase
        mov     eax,ds:[ebx].MEMINFO.dwBase
        add     edx,ds:[esi].MEMINFO.dwLength
        cmp     eax,edx
        jne     TryMergeWithPrev

        ; It does! Back up the base of the ebx block to include the
        ; esi block and increase the ebx block length.
        mov     edx,ds:[esi].MEMINFO.dwLength
        sub     ds:[ebx].MEMINFO.dwBase,edx
        add     ds:[ebx].MEMINFO.dwLength,edx

        ; Now we can get rid of the esi block since we don't need it.
        ; Indicate that we have given back a block to the MAN list.
        PREPEND_BLOCK_TO_LIST  MANHEAD,esi
        inc     NUMMANS

        ; Now see if we can merge this new free block with the previous
        ; block in the FREE list. Careful because we may already be at
        ; the start of the free list.
        mov     edi,ds:[ebx].MEMINFO.dwPrev
        cmp     edi,FREEHEAD
        je      Success
        mov     eax,ds:[edi].MEMINFO.dwBase
        add     eax,ds:[edi].MEMINFO.dwLength
        cmp     eax,ds:[ebx].MEMINFO.dwBase
        jne     Success

        ; It does merge! So combine these two blocks.
        mov     ecx,ds:[ebx].MEMINFO.dwLength
        add     ds:[edi].MEMINFO.dwLength,ecx
        jmp     RemoveEbxFromFreeListAndInsertItInManList

TryMergeWithPrev:
        ; The esi block did not merge with the block after it in the
        ; FREE list, so now let's see if it merges with the one before
        ; it in the FREE list. The one before it may be the FREEHEAD,
        ; so we need to check for that as well. DOn't forget that ecx
        ; holds the base addr of the allocation we are freeing.
        mov     edi,ds:[ebx].MEMINFO.dwPrev
        cmp     edi,FREEHEAD
        je      InsertEsiBlockAfterEdiBlock
        mov     eax,ds:[edi].MEMINFO.dwBase
        add     eax,ds:[edi].MEMINFO.dwLength
        cmp     eax,ecx
        jne     InsertEsiBlockAfterEdiBlock

        ; Yep! The esi block merges with the edi block -- so do it.
        mov     edx,ds:[esi].MEMINFO.dwLength
        add     ds:[edi].MEMINFO.dwLength,edx

        ; Now we can stick the esi block back into the MAN list
        ; and update the count of available MEMINFO blocks.
        PREPEND_BLOCK_TO_LIST  MANHEAD,esi
        inc     NUMMANS
        jmp     Success

RemoveEbxFromFreeListAndInsertItInManList:
        ; We no longer need the ebx block -- it was merged with another
        ; block. Remove it from the list it is currently in...
        EXTRACT_BLOCK_FROM_LIST ebx

        ; ... and stick the ebx block back in the MAN list.
        ; Update the count of available MEMINFO blocks.
        PREPEND_BLOCK_TO_LIST  MANHEAD,ebx
        inc     NUMMANS
        jmp     Success

Fail:   sub     eax,eax
        jmp     Done

Success:
        ; This is the number of bytes freed. We need to return this.
        pop     ecx

        ; Keep track of these -- simple and takes little time.
        dec     NUMALLOCS
        sub     ALLOCEDBYTES,ecx
        add     FREEBYTES,ecx
        mov     eax,1

Done:
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNOFFBMP.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnoffbmp.asm
;
; Purpose:      This file holds routines for flushing, initting,
;               de-initting, allocating and freeing offscreen bitmaps.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc


; I want to keep stats on the allocations and it makes the most sense
; to store these in a few fields of the first OFFBMPINFO structure.
; Here are the stats I will be keeping and where they are being placed.
;
; dwBitmapLength - total number of offscreen bitmaps ever allocated
; dwBitmapVRAMOffset - bytes of offscreen memory currently allocated to
;                         offscreen bitmaps
; wHeaderSel     - number of offscreen bitmaps currently allocated
; wUnused        - Byte Offset in array of next OFFBMPINFO struct
;                         to use for the next offscreen bitmap,

NEXT_FREE_ENTRY                         MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.wUnused>)>
ENDM

NUM_ALLOCED_OFFSCREEN_BITMAPS           MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.wBitmapSel>)>
ENDM

BYTES_USED_FOR_OFFSCREEN_BITMAPS        MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.dwBitmapVRAMOffset>)>
ENDM

TOTAL_ALLOCED_OFFSCREEN_BITMAPS         MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.dwBitmapLength>)>
ENDM


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
;==============================================================================
;
; Function:     GN_ClearOffscreenBitmapCache
;
; Purpose:      This function clears the offscreen bitmap cache.
;
; Arguments:
;               ds              Selector for the board Context data
;               pBoardCXOffset  Offset to the board context data
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearOffscreenBitmapCache, PASCAL, FRAME, FAR32
PARMD   pBoardCXOffset
OPENPROC
        PUSHR   es,esi,edi
        mov     esi,pBoardCXOffset
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo

LoopY:
        ; Are there more headers?
        lea     ebx,[esi].GNBOARDCX.OffscreenBitmapCache
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,ebx
        jc      ClearStats

        ; Is the bitmap still valid?
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
        call    GN_OffscreenBitmapValidCheck
        or      eax,eax
	jnz	FlushIt

	; Bitmap lost. Free offscreen memory.
	push	esi
	push	edi
	call	GN_OffscreenBitmapDelete
	jmp	LoopY

FlushIt:
        ; Yes it is, so flush it out to system memory and clear
        ; out the ptr to the bitmap header.
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
	mov	es,ax
	push	esi
        mov     esi,ds:[edi].OFFBMPINFO.dwBitmapOffset
        call	GN_FlushOffscreenBitmap
	pop	esi
        mov     dword ptr ds:[edi],0
        jmp     LoopY

ClearStats:
        ; Reset the statistics
        sub     eax,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenBitmapsAllocatedSinceLastFlush,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenBitmapsCurrentlyAllocated,eax
        mov     ds:[esi].GNBOARDCX.dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps,eax
        lea     eax,[esi].GNBOARDCX.OffscreenBitmapCache
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,eax

        POPR    es,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenBitmapCreate
;
; Purpose:      This routine will create an offscreen bitmap by allocating
;               memory and modifying an existing DIBENGINE header.
;
; Arguments:
;               ds                      CXSel
;               pGNBoardCXOffset
;               es:edi                  ptr to DEVBMP.
;                                       The fields below are valid:
;                                       deWidth
;                                       deHeight
;                                       deWidthBytes
;                                       dePlanes
;                                       deBitsPixel
;                                       delpPDevice
;
; Returns:
;               eax     0       If the routine did not create the bitmap
;                       non-0   If the routine did create the bitmap
;                               In this case, the routine must have
;                               filled in the fields below:
;                               ds:[esi].DIBENGINE.deDeltaScan - bitmap pitch
;                               ds:[esi].DIBENGINE.deBits - ptr to bits
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_OffscreenBitmapCreate, PASCAL, FRAME, NEAR
PARMD   pGNBoardCXOffset
LOCALD  dwBmpOffset
LOCALD  dwBmpSize
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset
        mov     dwBmpOffset,edi

        ; Can our list of offscreen bitmaps hold another one?
        sub     eax,eax
        lea     ecx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        add     ecx,(MAX_OFFSCREEN_BITMAPS + 1) * SIZE OFFBMPINFO
        cmp     ecx,ds:[esi].GNBOARDCX.pNextOffbmpinfo
        jbe     Done

        ; Is there an offscreen heap?
        test	ds:[esi].GNBOARDCX.dwOffscreenFlags,NO_OFFS_BMPS
        jnz     Done

        ; Call the hardware specific routine to make sure it is OK
        ; to place this bitmap in offscreen memory.
        mov     ebx,ds:[esi].GNBOARDCX.pHWBoardCX
        call    HW_CreateOffscreenBitmap
        or      eax,eax
        je      Done

	; Check for the same selector at first
        sub     ebx,ebx
        mov     bx,es
        or      ebx,3
        lea     edx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
@@:
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,edx
        jb      AllocSpace
        cmp     ebx,ds:[edi].OFFBMPINFO.dwBitmapSel
        jne     @B
	mov	eax,ds:[edi].OFFBMPINFO.dwBitmapOffset
        cmp	eax,dwBmpOffset
        jne     @B

	; We've found the same selector in cache.
	; We have to free offscreen memory and update cache table.
        push    esi
        push    edi
	call	GN_OffscreenBitmapDelete

AllocSpace:
        ; Hardware specific code approved the bitmap. Now, see
        ; if we can allocate the offscreen memory for it.
        mov     edi,dwBmpOffset
        movzx   edx,es:[edi].DEVBMP.Dibeng.deHeight
        mov     ecx,es:[edi].DEVBMP.Dibeng.deDeltaScan
        imul    ecx,edx
        mov     dwBmpSize,ecx
        or      es:[edi].DEVBMP.Dibeng.deFlags,VRAM OR OFFSCREEN
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        call    GN_HeapAlloc
        sub     ebx,ebx
        or      eax,eax
        jne     Success

        ; The bitmap could not fit into the free offscreen memory.
        ; Look for a bitmap that we can flush out to system memory
        ; that is bigger than the new one we want to put in vidmem.
        lea     edx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
@@:
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,edx
        jb      Done
        cmp     ds:[edi].OFFBMPINFO.dwBitmapLength,ecx
        jl      @B

Found:
        ; Is the bitmap still valid?
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
        call    GN_OffscreenBitmapValidCheck
        or      eax,eax
        jne	SelectorValid

	; Here we have to remove invalid element from the chain.
        push    esi
        push    edi
	call	GN_OffscreenBitmapDelete

	; Try to allocate again
	jmp	AllocSpace

SelectorValid:
        ; Yes it is, so flush it out to system memory and clear
        ; out the ptr to the bitmap header.
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
	push	es
	mov	es,ax
	push	esi
        mov     esi,ds:[edi].OFFBMPINFO.dwBitmapOffset
        call    GN_FlushOffscreenBitmap
	pop	esi
	pop	es
        mov     ecx,dwBmpSize

RedoAlloc:
        xor     ebx,ebx
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        call    GN_HeapAlloc
        sub     ebx,ebx
        or      eax,eax
        je      Done

Success:
        ; We got the memory for an offscreen bitmap. The selector
        ; for the bits ptr is the same as the screen. The offset
        ; is what we got back from the HeapAlloc.
        mov     ebx,dwBmpOffset
        mov     es:[ebx].DEVBMP.Dibeng.deBitsOffset,eax

        ; Keep track of the new offscreen bitmap in our header list.
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
        mov     ds:[edi].OFFBMPINFO.dwBitmapLength,ecx
        mov     ds:[edi].OFFBMPINFO.dwBitmapVRAMOffset,eax
	sub	edx,edx
        mov     dx,es
        or      edx,3
        mov     ds:[edi].OFFBMPINFO.dwBitmapSel,edx
        mov     ds:[edi].OFFBMPINFO.dwBitmapOffset,ebx
        add     edi,SIZE OFFBMPINFO
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,edi

        ; Minimal time taken to keep some statistics as well.
        inc     ds:[esi].GNBOARDCX.dwOffscreenBitmapsAllocatedSinceLastFlush
        inc     ds:[esi].GNBOARDCX.dwOffscreenBitmapsCurrentlyAllocated
        add     ds:[esi].GNBOARDCX.dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps,ecx
        mov     eax,1
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenBitmapDelete
;
; Purpose:      This routine deletes an offscreen bitmap and frees
;               up memory associated with it.
;
; Arguments:
;               ds                      CXSel
;               pGNBoardCXOffset
;               es:edi                  ptr to DEVBMP.
;                                       es:[esi].DIBENGINE.deBitsOffset
;                                       has base address of the bitmap.
;               dwCacheOffset		offset OffscreenBitmapCache if selector invalid
;
; Returns:      None
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_OffscreenBitmapDelete, PASCAL, FRAME, NEAR
PARMD   pGNBoardCXOffset
PARMD   dwCacheOffset
LOCALD	dwBitsOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset

	cmp	dwCacheOffset,0
	je	GetOffsetFromBmp
	mov	edi,dwCacheOffset
	mov	ecx,ds:[edi].OFFBMPINFO.dwBitmapVRAMOffset
	jmp	@F

GetOffsetFromBmp:
        mov     ecx,es:[edi].DEVBMP.Dibeng.deBitsOffset
@@:
	mov	dwBitsOffset,ecx

        ; Call the hardware specific routine to do their thing
        mov     ebx,ds:[esi].GNBOARDCX.pHWBoardCX
	mov	eax,ecx
        call    HW_DeleteOffscreenBitmap

        ; Make sure we have an offscreen heap
        test	ds:[esi].GNBOARDCX.dwOffscreenFlags,NO_OFFS_BMPS
        jnz     Done

        ; Attempt to free the offscreen memory used by the bitmap.
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
	mov	ecx,dwBitsOffset
        call    GN_HeapFree

        ; If the memory manager found the allocation, we can update
        ; our statistics on offscreen bitmap memory usage.
        or      eax,eax
        je      @F
        sub     ds:[esi].GNBOARDCX.dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps,ecx
@@:
	cmp	dwCacheOffset,0
	jnz	Found

        ; Search for the offscreen bitmap in the list.
	sub	ebx,ebx
	mov	ecx,edi
        mov     bx,es
        or      ebx,3
        lea     edx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
@@:
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,edx
        jb      Done
        cmp     ebx,ds:[edi].OFFBMPINFO.dwBitmapSel
        jne     @B
	mov	eax,ds:[edi].OFFBMPINFO.dwBitmapOffset
        cmp	eax,ecx
        jne     @B

Found:
        ; The bitmap was in our list. Adjust statistics again.
        dec     ds:[esi].GNBOARDCX.dwOffscreenBitmapsCurrentlyAllocated

        ; Now, to remove the bitmap from our list, take the last entry
        ; in the list and move it into the spot that has this current
        ; bitmap info. Then, drop the list count by 1 entry.
        ; and drop the free entry pointer by one array entry.
        mov     ebx,ds:[esi].GNBOARDCX.pNextOffbmpinfo
        sub     ebx,SIZE OFFBMPINFO
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,ebx

	; We don't need to copy if we are the last element.
	cmp	edi,ebx
	je	Done

        .errnz  (SIZE OFFBMPINFO - 10H)
        mov     eax,ds:[ebx + 00H]
        mov     ecx,ds:[ebx + 04H]
        mov     edx,ds:[ebx + 08H]
        mov     ebx,ds:[ebx + 0CH]
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],ebx

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenBitmapValidCheck
;
; Purpose:      This routine checks a bitmap header to make sure it is
;               still valid and that the memory doesn't appear to have
;               been allocated to someone else. Unfortunately, the
;               display driver does not always get informed of when
;               memory belonging to bitmaps is deleted, discarded, etc
;               so this routine is necessary.
;
; Arguments:    eax     selector for bitmap header (header at ax:0)
;
; Returns:      eax     0       invalid bitmap header
;                       non-0   valid bitmap header
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_OffscreenBitmapValidCheck, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   es

        ; Is this even a valid selector?
        lar     edx,eax
        jnz     Fail

        ; The selector must be PRESENT, RING3, DATA
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     Fail

	; The selector base must exceed 7fffffffH
	push	eax
        push    ax
        call    GetSelectorBase
	test	edx,8000H
	pop	eax
	jz	Fail

        ; The selector limit must be large enough to hold
        ; at least a DEVBMP header.
        lsl     ebx,eax
        inc     ebx
        cmp     ebx,SIZE DEVBMP
        jc      Fail

        ; Now we can load the selector without a GPF.
        ; Make sure the first word in the memory block looks like
        ; the start of a DIBENGINE header.
        mov     es,ax
        sub     edx,edx
        cmp     es:[edx].DIBENGINE.deType,5250H
        jne     Fail

        ; Check the selector limit against the total size the bitmap
        ; would take up -- header and the bits.
        movzx   eax,es:[edx].DEVBMP.Dibeng.deWidthBytes
        movzx   edx,es:[edx].DEVBMP.Dibeng.deHeight
        add     eax,3
        and     eax,NOT 3
        imul    eax,edx
        add     eax,SIZE DEVBMP
        cmp     ebx,eax
        jae     @F

Fail:
        sub     eax,eax
@@:
        POPR    es
CLOSEPROC


;==============================================================================
;
; Function:     GN_FlushOffscreenBitmap
;
; Purpose:      This routine will copy an offscreen bitmap into
;               its system memory backup region and adjust the
;               bitmap header appropriately to point to the new
;               location of the bitmap data. The offscreen
;               memory used by the bitmap is freed.
;
; Arguments:    es:esi  ptr to DEVBMP.
;               The bitmap header MUST be valid. No
;               validity checking is performed in here.
;
; Returns:      None
;
; Preserve:     ds,es,gs,esi,edi
;==============================================================================
DECPROC GN_FlushOffscreenBitmap, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,esi,edi,gs

        ; The deDeltaScan of the new system memory copy is always
        ; (deWidthBytes + 3) AND NOT 3 -- the DIBENG assumes this.
        movzx   eax,es:[esi].DEVBMP.Dibeng.deWidthBytes
        mov     edx,es:[esi].DEVBMP.Dibeng.deDeltaScan
        add     eax,3
        and     eax,NOT 3

        ; Compute the dst wrap width and load up src and dst ptrs
        sub     edx,eax
        shr     eax,2
        mov     edi,SIZE DEVBMP
        movzx   ebx,es:[esi].DEVBMP.Dibeng.deHeight
	;--->
	push	esi
        lds     esi,fword ptr es:[esi].DEVBMP.Dibeng.deBitsOffset

        ; Copy the bitmap from offscreen to system memory area
@@:     mov     ecx,eax
        rep     movs dword ptr es:[edi], ds:[esi]
        add     esi,edx
        dec     ebx
        jne     @B

	pop	edi
	;<---

        ; Now we need to delete the offscreen bitmap which will
        ; cause the offscreen memory allocated for it to be released.
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
	pushd	0
        call    GN_OffscreenBitmapDelete

        ; The DeltaScan and bits ptrs in the bitmap should now be
        ; updated to reflect the new location and bitmap pitch.
        movzx   eax,es:[edi].DEVBMP.Dibeng.deWidthBytes
        add     eax,3
        and     eax,NOT 3
        mov     es:[edi].DIBENGINE.deDeltaScan,eax
        mov     eax,SIZE DEVBMP
        mov     es:[edi].DIBENGINEHDR.deBitsOffset,eax
        mov     es:[edi].DIBENGINEHDR.deBitsSelector,es

        ; Since the bitmap is now in system memory, clear
        ; the offscreen flags and the access routines.
        sub     eax,eax
        and     es:[edi].DIBENGINEHDR.deFlags,NOT (VRAM OR OFFSCREEN)
        mov     es:[edi].DIBENGINEHDR.deBeginAccess,eax
        mov     es:[edi].DIBENGINEHDR.deEndAccess,eax
        POPR    ds,esi,edi,gs
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNOUTPUT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnoutput.asm
;
; Purpose:      This file holds the Output display driver entry point.
;
;==============================================================================
.586
incOutput = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

; These all have to be marked as NEAR or else the conditional jumps to them
; below will cause an assembler error. They are really FAR16 functions.
EXTERNDEF       GENERIC_Rectangle:NEAR
EXTERNDEF       GENERIC_Polyline:NEAR
EXTERNDEF       GENERIC_PolyScanOrScanLine:NEAR
EXTERNDEF       GENERIC_BeginScan:NEAR
EXTERNDEF       GENERIC_EndScan:NEAR

;==============================================================================
;
; Function:     GENERIC_Output
;
; Purpose:      This function is the Output display driver entry point.
;
; Arguments:    Output Display Driver Stack Frame
;
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Output, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wStyle
;PARMW   wCount
;PARMD   lpPoints
;PARMD   lpPen
;PARMD   lpBrush
;PARMD   lpDrawMode
;PARMD   lpClipRect
OPENPROC
        movzx   ebx,sp
        movzx   eax,word ptr ss:[ebx + 1AH]
        cmp     eax,OS_RECTANGLE
        je      GENERIC_Rectangle
        cmp     eax,OS_POLYLINE
        je      GENERIC_Polyline
        cmp     eax,OS_POLYSCANLINE
        je      GENERIC_PolyScanOrScanLine
        cmp     eax,OS_BEGINNSCAN
        je      GENERIC_BeginScan
        cmp     eax,OS_ENDNSCAN
        je      GENERIC_EndScan
        cmp     eax,OS_SCANLINES
        je      GENERIC_PolyScanOrScanLine
        cmp     eax,OS_ALTPOLYGON
        je      O_Ret
        cmp     eax,OS_WINDPOLYGON
        jne	Punt_Output     
O_Ret:	mov     eax,-1
        RETFAR16 1CH
PLABEL	Punt_Output
        jmp     DIB_Output
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNOFFMGR.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnoffmgr.asm
;
; Purpose:      This file holds the routines that manage offscreen
;               memory.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_ControlOffscreenAllocations
;
; Purpose:      This routine gets called to either allocate memory
;               for offscreen allocations or free it up.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwFlag                  TRUE then enable, FALSE then disable
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ControlOffscreenAllocations, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwFlag
LOCALD	dwLogdevCount
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset

        cmp     dwFlag,0
        jne     DoEnable

DoDisable:
        test   	ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        jnz	DoneIt

        ; Flush all offscreen bitmaps
        push    pGNBoardCXOffset
        call    GN_ClearOffscreenBitmapCache

	; OK, this is funky. We have to run through all the logical
	; devices that are attached to this board and tell them that
	; the offscreen heap is disappearing.
	lea	edi,[esi].GNBOARDCX.pGNLogdevCX
	mov	dwLogdevCount,0
Loop1:
	mov	eax,ds:[edi]
	or	eax,eax
	je	@F
	push	eax
	call	GN_OffscreenHeapDisappearing
@@:
	add	edi,4
	inc	dwLogdevCount
	mov	ecx,dwLogdevCount
	cmp	ecx,MAX_ATTACHED_CRTCS
	jc	Loop1

        ; Mark the offscreen heap as unavailable
        or     	ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE

        ; Call the hardware to have it free the offscreen block
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        push    ds:[esi].GNBOARDCX.dwOffscreenBaseAddress
        call    HW_FreeOffscreenBlock
        mov     ds:[esi].GNBOARDCX.dwOffscreenBaseAddress,0
        mov     ds:[esi].GNBOARDCX.dwOffscreenLength,0
        jmp     DoneIt

DoEnable:
        ; If we are already enabled, then ignore the call
        test   	ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        jz	DoneIt

        ; Call the hardware to get the largest offscreen block.
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        call    HW_GetLargestOffscreenBlock

        ; Allocate it
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        push    eax
        call    HW_AllocOffscreenBlock

        ; Set up an offscreen heap if there was any memory
        cmp	eax,-1
        je      DoneIt

        mov     ds:[esi].GNBOARDCX.dwOffscreenBaseAddress,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenLength,ebx

	mov	ecx,ebx
	mov	ebx,eax
        mov    	eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        call    GN_HeapInit

        and    	ds:[esi].GNBOARDCX.dwOffscreenFlags,NOT OFFS_HEAP_UNAVAILABLE

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenAllocationsLock
;
; Purpose:      This function increments a lock count which begins at 0.
;               When the lock count goes from 0 to 1, all offscreen
;               allocations are flushed and offscreen usage by the display
;               driver is inhibited until the lock count goes to 0 via
;               matching calls to GN_OffscreenAllocationsUnlock.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC GN_OffscreenAllocationsLock, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        mov     ds,wFlatDataSel_In_NVTEXT16
        mov     esi,CSpGNLogicalDevice_In_NVTEXT16
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     ds:[edi].GNBOARDCX.dwOffscreenLockCount,0
        jne     @F

        ; Flush the offscreen list
        push    edi
        call    GN_ClearOffscreenBitmapCache
@@:
        or      ds:[edi].GNBOARDCX.dwOffscreenFlags,OFFS_ALLOCS_BLOCKED
        inc     ds:[edi].GNBOARDCX.dwOffscreenLockCount
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenAllocationsUnlock
;
; Purpose:      See GN_OffscreenAllocationsLock for details.
;
; Arguments:    None
;
; Returns:      eax     Current Lock count
;
; Preserve:     All registers except eax
;==============================================================================
DECPROC GN_OffscreenAllocationsUnlock, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,wFlatDataSel_In_NVTEXT16
        mov     esi,CSpGNLogicalDevice_In_NVTEXT16
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        dec     ds:[edi].GNBOARDCX.dwOffscreenLockCount
        jne     @F
        and     ds:[edi].GNBOARDCX.dwOffscreenFlags,NOT OFFS_ALLOCS_BLOCKED
@@:
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNMONBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnmonblt.asm
;
; Purpose:      This file holds the routines to do Bitblt's involving
;               a mono source located in system memory. There may
;               also be a pattern involved but maybe not. The code is
;               generic in terms of not touching hardware, but it does
;               make assumptions about hardware capability and to some
;               extent programming order. These should all be fine for
;               Nvidia products.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_BitBltSrcMonoDstVram
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a mono system memory bitmap and the
;               dst is in VRAM. There may be a pattern involved as well
;               but there may not be. The general strategy implemented
;               in this routine is
;
;               1) Compute all the neccessary data
;
;               2) Call the HW_BeginSrcMonoDstVram routine to set up
;                  the chip to expect to receive dwExtX * dwExtY pixels
;                  in the Destination Pixel Depth and place them
;                  in the rectangle whose upper left corner is at
;                  dwDstLeft,dwDstTop. HW_BeginSrcMonoDstVram will
;                  also set the rop, base address, set up the pattern, etc.
;
;               3) GN_BitBltSrcMonoDstVram calls the routine
;                  HW_BlockSrcMonoDstVram to wait for enough space
;                  in the hardware buffer.
;
;               4) GN_BitBltSrcMonoDstVram calls an inner loop routine
;                  which reads src pixels, translates them to dst space
;                  and stores them in the hardware. The inner loop routine
;                  can do partial scanlines or an integral number of scans.
;
;               5) Steps 3 and 4 are repeated until the entire bitmap has
;                  been transferred.
;
;               6) HW_EndSrcMonoDstVram is called to allow the hardware
;                  specific code to clean up anything it needs to.
;
; Arguments:
;		ds		Context Selector
;		pGNLogdevCXOffset  GNLOGDEVCX ptr
;               dwDstBitsSel    Selector for the dst bits
;               dwDstBitsOffset Offset to the dst bits
;               dwDstBpp        bits per pixel of the dst bitmap
;               dwDstPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwDstLeft       left edge of the dst rectangle
;               dwDstTop        top  edge of the dst rectangle
;               dwSrcBitsSel    selector to the src bits
;               dwSrcBitsOffset offset to the start of the source bits
;               dwSrcPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwSrcLeft       left edge of the src rectangle
;               dwSrcTop        top  edge of the src rectangle
;               dwExtX          extent of the src (and dst) rectangle.
;               dwExtY          extent of the src (and dst) rectangle.
;               dwBgColor       expand 0 bits in the src to this color
;               dwFgColor       expand 1 bits in the src to this color
;               dwRop3          3-operand rop
;               lpBrush         ptr to a DIB_Brush struct
;               lpDrawMode      This is only needed for the case where
;                               the rop involves a brush and the brush
;                               is a mono pattern. In this case,
;                               DRAWMODE.TextColor specifies the color
;                               to which to translate pattern 0 bits, and
;                               DRAWMODE.bkColor specifies the color to
;                               which to translate pattern 1 bits. Note
;                               that these are not the same colors used
;                               translate 0 and 1 bits from the src
;                               bitmap.
;               dwScansLeftInSeg number of scanlines to process starting
;                               from the dwSrcTop coord passed in before
;                               the segment break and byte padding.
;               dwScansPerSeg   number of scans between segment breaks
;               dwFillBytes     number of bytes to add to src ptr to
;                               skip padding between bitmap segment breaks.
;
; Returns:      eax     0       The routine will be punted to software
;                       non-0   the return code to GDI
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_BitBltSrcMonoDstVram, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwBgColor
PARMD   dwFgColor
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwScansLeftInSeg
PARMD   dwScansPerSeg
PARMD   dwFillBytes

LOCALD  dwExtraWord
LOCALD  dwPixelsIgnoredOnLeft
LOCALD  dwAlignedDstLeft
LOCALD  dwAlignedSrcLeft
LOCALD  dwAlignedExtXInPixels
LOCALD  dwAlignedSrcExtXInBytes
LOCALD  dwAlignedSrcExtXInDwords
LOCALD  dwMaxTransferSizeInBytes
LOCALD  dwSrcStart
LOCALD  dwDstWrapWidth
LOCALD  dwSrcWrapWidth
LOCALD  dwDwordsPerBlock
LOCALD  dwScansPerBlock
LOCALD  dwBytesPerBlock
LOCALD	pHWBoardCXOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; We assume a hardware clip rect; hence, drop the starting
        ; src coord back to the start of a dword. The dst will need
        ; to be dropped back the same amount and the width will need
        ; to be increased by the same amount. Then to make things
        ; even simpler, increase the width from this new value until
        ; it is a multiple of 32, thus making the amount of src data
        ; to transfer per scan a multiple of a dword.
        mov     eax,dwSrcLeft
        mov     ebx,eax
        and     eax,NOT 1FH
        mov     dwAlignedSrcLeft,eax
        sub     ebx,eax
        mov     ecx,dwDstLeft
        mov     edx,dwExtX
        mov     dwPixelsIgnoredOnLeft,ebx
        sub     ecx,ebx
        lea     eax,[edx][ebx + 0FH]
        lea     edx,[edx][ebx + 1FH]
        and     eax,NOT 0FH
        and     edx,NOT 1FH
        mov     dwAlignedExtXInPixels,edx
        sub     eax,edx
        mov     dwExtraWord,eax
        mov     dwAlignedDstLeft,ecx
        shr     edx,3
        mov     dwAlignedSrcExtXInBytes,edx
        shr     edx,2
        mov     dwAlignedSrcExtXInDwords,edx

        ; Now we compute the src starting address and wrap width
        mov     eax,dwSrcTop
        sub     edx,edx
        div     dwScansPerSeg
        shl     eax,10H
        imul    edx,dwSrcPitch
        mov     ebx,dwAlignedSrcLeft
        add     eax,edx
        shr     ebx,3
        add     eax,dwSrcBitsOffset
        add     eax,ebx
        mov     dwSrcStart,eax
        mov     eax,dwSrcPitch
        sub     eax,dwAlignedSrcExtXInBytes
        mov     dwSrcWrapWidth,eax

        ; Call the hardware specific routine to setup for the transfer
        mov	ebx,pGNLogdevCXOffset
        mov    	ecx,ds:[ebx].GNLOGDEVCX.pGNBoardCX
	mov	eax,ds:[ecx].GNBOARDCX.pHWBoardCX
	mov	pHWBoardCXOffset,eax

        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    dwDstBitsOffset
        push    dwDstPitch
        push    dwDstBpp
        push    dwDstLeft
        push    dwDstTop
        push    dwAlignedDstLeft
        push    dwExtX
        push    dwExtY
        push    dwAlignedSrcExtXInBytes
        push    dwAlignedExtXInPixels
        push    dwPixelsIgnoredOnLeft
        push    dwBgColor
        push    dwFgColor
        push    lpBrush
        push    lpDrawMode
        push    dwRop3
        call    HW_BeginSrcMonoDstVram
        or      eax,eax
        je      DoneIt
        mov     dwDstWrapWidth,ebx
        mov     dwMaxTransferSizeInBytes,ecx

        ; At this point, the generic and hardware code are linked
        ; until the HW_EndSrcMonoDstVram routine is called.
        ; The generic code has agreed not to touch es -- it is the
        ; hardware's selector for whatever purposes it may need.

        ; Now we can begin the inner loop. Ther are two major cases
        ; that can occur and we will handle them separately.
        ; 1) The number of bytes that are to be transferred for a single
        ;    scanline is larger than the most the hardware can accept
        ;    in one shot. Each scanline must be broken into multiple
        ;    pieces. This is most typically the FIFO based model.
        ; 2) At least one scanline, possibly many, can be sent as a
        ;    single transfer. This is the typical DMA scenario.
        ;
        ; For each of these cases, there are two subcases. Mono bitmaps
        ; are only guaranteed to have a word width and if we transfer a
        ; multiple of 4 bytes per scan, on the last scan we could walk
        ; off the end of the bitmap casuing a GPF unless we handle the
        ; scan properly. We don't have to worry about this unless the
        ; dwSrcPitch is NOT a multiple of 4 AND in extending the width
        ; of the transfer out to be dword aligned on the left edge, we
        ; have included a word in which all pixels are clipped.
        push    OFFSET CRet
        mov     eax,dwSrcPitch
        mov     ebx,dwExtraWord
        and     eax,3
        je      IsAlgn
        or      ebx,ebx
        je      IsAlgn
IsUnAl: cmp     ecx,dwAlignedSrcExtXInBytes
        jle     GN_XferPartialUnalignedMonoScans
        jmp     GN_XferWholeUnalignedMonoScans
IsAlgn: cmp     ecx,dwAlignedSrcExtXInBytes
        jle     GN_XferPartialAlignedMonoScans
Whole:  jmp     GN_XferWholeAlignedMonoScans
CRet:
        ; Let the hardware know we are done
        mov	esi,pHWBoardCXOffset
        call    HW_EndSrcMonoDstVram

        mov     eax,1
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_XferWholeAlignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when at least one whole scan will fit in the transfer
;               area of the chip AND the pitch of the src bitmap is a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferWholeAlignedMonoScans
GN_XferWholeAlignedMonoScans    PROC    NEAR

        ; Figure out how many scanlines can be done in a single shot
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        div     dwAlignedSrcExtXInBytes
        mov     dwScansPerBlock,eax
        imul    eax,dwAlignedSrcExtXInBytes
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel
LoopY:
        ; Compute the number of scans in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwScansPerBlock
        sub     dwExtY,ebx
        jge     @F
        add     ebx,dwExtY
        mov     dwExtY,0
        mov     eax,dwAlignedSrcExtXInBytes
        imul    eax,ebx
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi
@@:
        ; Now we transfer the data
        mov     ecx,dwAlignedSrcExtXInDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     ebx
        jne     @B
        cmp     ebx,dwExtY
        jne     LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferWholeAlignedMonoScans    ENDP


;==============================================================================
;
; Function:     GN_XferWholeUnalignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when at least one whole scan will fit in the transfer
;               area of the chip AND the pitch of the src bitmap is NOT a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferWholeUnalignedMonoScans
GN_XferWholeUnalignedMonoScans  PROC    NEAR

        ; Figure out how many scanlines can be done in a single shot
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        div     dwAlignedSrcExtXInBytes
        mov     dwScansPerBlock,eax
        imul    eax,dwAlignedSrcExtXInBytes
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel

        ; We must transfer one less dword and then one extra word
        ; so adjust some things to make up for this change.
        mov     eax,4
        dec     dwAlignedSrcExtXInDwords
        add     dwSrcWrapWidth,eax
        add     dwDstWrapWidth,eax
LoopY:
        ; Compute the number of scans in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwScansPerBlock
        sub     dwExtY,ebx
        jge     @F
        add     ebx,dwExtY
        mov     dwExtY,0
        mov     eax,dwAlignedSrcExtXInBytes
        imul    eax,ebx
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi
@@:
        ; Now we transfer the data
        mov     ecx,dwAlignedSrcExtXInDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ax,ds:[esi]
        mov     es:[edi],ax
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     ebx
        jne     @B
        cmp     ebx,dwExtY
        jne     LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferWholeUnalignedMonoScans  ENDP


;==============================================================================
;
; Function:     GN_XferPartialAlignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when one whole scan will not fit in the transfer
;               area of the chip AND the pitch of the src bitmap is a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferPartialAlignedMonoScans
GN_XferPartialAlignedMonoScans  PROC    NEAR

        ; We can't send a whole scanline in a single transfer so compute
        ; how many dwords (chunks of 32 pixels) we can send in one shot.
        mov     eax,dwMaxTransferSizeInBytes
        mov     dwBytesPerBlock,eax
        shr     eax,2
        mov     dwDwordsPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel

LoopY:
        push    dwAlignedSrcExtXInDwords
LoopX:
        ; Compute the number of pixels in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwDwordsPerBlock
        sub     dwAlignedSrcExtXInDwords,ebx
        jge     @F
        add     ebx,dwAlignedSrcExtXInDwords
        mov     dwAlignedSrcExtXInDwords,0
        lea     eax,[ebx * 4]
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi

        ; Now we transfer the data
        mov     ecx,ebx
        rep     movs dword ptr es:[edi], ds:[esi]

        ; Are there more pixels left on this scanline?
        cmp     ecx,dwAlignedSrcExtXInDwords
        jne     LoopX
        pop     dwAlignedSrcExtXInDwords

        ; Go to the next scanline
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     dwExtY
        jg      LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferPartialAlignedMonoScans  ENDP


;==============================================================================
;
; Function:     GN_XferPartialUnalignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when one whole scan will not fit in the transfer
;               area of the chip AND the pitch of the src bitmap is NOT a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferPartialUnalignedMonoScans
GN_XferPartialUnalignedMonoScans        PROC    NEAR

        ; We can't send a whole scanline in a single transfer so compute
        ; how many dwords (chunks of 32 pixels) we can send in one shot.
        mov     eax,dwMaxTransferSizeInBytes
        mov     dwBytesPerBlock,eax
        shr     eax,2
        mov     dwDwordsPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel

        ; We must transfer one less dword and then one extra word
        ; so adjust some things to make up for this change.
        mov     eax,4
        add     dwSrcWrapWidth,eax
        add     dwDstWrapWidth,eax

LoopY:
        push    dwAlignedSrcExtXInDwords
LoopX:
        ; Compute the number of pixels in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwDwordsPerBlock
        sub     dwAlignedSrcExtXInDwords,ebx
        jge     @F
        add     ebx,dwAlignedSrcExtXInDwords
        mov     dwAlignedSrcExtXInDwords,0
        lea     eax,[ebx * 4]
        dec     ebx             ; allocate, but don't fill last dword
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi

        ; Now we transfer the data
        mov     ecx,ebx
        rep     movs dword ptr es:[edi], ds:[esi]

        ; Are there more pixels left on this scanline?
        cmp     ecx,dwAlignedSrcExtXInDwords
        jne     LoopX
        mov     ax,ds:[esi]
        mov     es:[edi],ax
        pop     dwAlignedSrcExtXInDwords

        ; Go to the next scanline
        add     esi,dwSrcWrapWidth 
        add     edi,dwDstWrapWidth 
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     dwExtY
        jg      LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferPartialUnalignedMonoScans        ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNPALET.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnsetpal.asm
;
; Purpose:      This file holds the SetPalette, SetPaletteTranslate, and
;               the UpdateColors display driver entry points.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_SetPalette
;
; Purpose:      This function is the SetPalette display driver entry point.
;
; Arguments:    SetPalette Display Driver Stack Frame
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetPalette, PASCAL, FRAME, FAR16
PARMW   wStartIndex
PARMW   wNumEntries
PARMD   lpPalette
LOCALD  dwCRTCCount
LOCALD  pPalette
OPENPROC
        PUSHR   ds,esi,edi
		jmp		GN_SetPalette
GENERIC_SetPalette	ENDP

;==============================================================================
PUBLIC	GN_SetPaletteExit
GN_SetPaletteExit PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 08H
GN_SetPaletteExit ENDP

;==============================================================================
PUBLIC	GN_SetPalette
GN_SetPalette	PROC	NEAR

        ; Load up the GNLOGDEVCX
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        ; See if screen is busy
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
		jne		GN_SetPalettePunt

        ; Get a flat ptr to the gamma ramp
        movzx   eax,word ptr lpPalette+2
        push    eax
        call    GN_GetSelectorBase
        movzx   edx,word ptr lpPalette+0
        add     eax,edx
        mov     pPalette,eax

        ; Copy the palette given into the GNLOGDEVCX palette.
        ; We need to maintain this for the DIBENGINE.
        ; We have to swap red and blue
        movzx   eax,wStartIndex
        movzx   ecx,wNumEntries
        mov     edi,pPalette
        lea     ebx,[esi][eax * 4].GNLOGDEVCX.dwPalette
@@:
        mov     eax,ds:[edi]
        add     edi,4
        bswap   eax
        ror     eax,8
        mov     ds:[ebx],eax
        add     ebx,4
        dec     ecx
        jne     @B

        ; Run through all the CRTCs attached to this logical device
        ; and program them all.
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     ebx,[esi].GNLOGDEVCX.dwPalette
        mov     pPalette,ebx

Loopit3:
        ; Now call to set the palette on this DAC
        cmp     dword ptr ds:[edi],0
        je      @F
        push    dword ptr ds:[edi]
        push    pPalette
        movzx   eax,wStartIndex
        push    eax
        movzx   eax,wNumEntries
        push    eax
        call    GN_SetCrtcPalette
@@:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loopit3
		jmp		GN_SetPaletteExit
GN_SetPalette	ENDP

PUBLIC  GN_SetPalettePunt
GN_SetPalettePunt	PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        pop     eax
        push    cs:[CSlp16LogDevice]
        push    eax
        jmp     DIB_SetPaletteExt
GN_SetPalettePunt	ENDP


;==============================================================================
;
; Function:     GENERIC_SetPaletteTranslate
;
; Purpose:      This function is the SetPaletteTranslate display driver
;               entry point.
;
; Arguments:    SetPaletteTranslate Display Driver Stack Frame
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetPaletteTranslate, PASCAL, FRAME, FAR16
PARMD   lpTranslate
OPENPROC
        PUSHR   ds,esi,edi

        ; Call the DIBENG to do what it needs to do
        push    lpTranslate
        push    cs:[CSlp16LogDevice]
        call    DIB_SetPaletteTranslateExt

        ; If we are in a palettized mode then handle the xlat table
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        test    ds:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTIZED
        jz      done

        ; Load up a few things and break into identity/non-identity cases
        sub     eax,eax
        lea     ebx,[esi].GNLOGDEVCX.bPaletteXlatTable
        lea     edi,[esi].GNLOGDEVCX.bPaletteInverseXlatTable
        mov     ecx,0FFH
        cmp     eax,lpTranslate
        je      isID

        ; There is an xlat table that is not the identity
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTE_XLAT
        sub     edx,edx
        les     dx,lpTranslate
@@:
        mov     al,es:[edx][ecx * 2]
        mov     ds:[ebx][ecx],al
        mov     ds:[edi][eax],cl
        dec     ecx
        jns     @B
        jmp     done

        ; The xlat table is NULL -- set the identity translate table
isID:
        mov     ds:[ebx][ecx],cl
        mov     ds:[edi][eax],cl
        dec     ecx
        jns     isID
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT PALETTE_XLAT

done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_UpdateColors
;
; Purpose:      This function is the UpdateColors display driver entry point.
;
; Arguments:    UpdateColors Display Driver Stack Frame
;
; Returns:      None
;
;==============================================================================
DECPROC GENERIC_UpdateColors, PASCAL, FRAME, FAR16
PARMW   wStartX
PARMW   wStartY
PARMW   wExtX
PARMW   wExtY
PARMD   lpTranslate

LOCALD  lpBmp
LOCALD  lpBits
OPENPROC
        PUSHR   ds,esi,edi
	jmp	GN_UpdateColors
GENERIC_UpdateColors	ENDP

;==============================================================================
PUBLIC	GN_UpdateColorsExit
GN_UpdateColorsExit PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 0CH
GN_UpdateColorsExit ENDP

;==============================================================================
PUBLIC	GN_UpdateColors
GN_UpdateColors	PROC	NEAR
	sub	ebx,ebx
	mov	lpBmp,ebx
        ; Load up the DstDev for dispatching
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        cmp	ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp,8
	jne	GN_UpdateColorsPunt

        ; See if screen is busy
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
	jne	GN_UpdateColorsPunt

	;Ask memory size for shadow bitmap
	push	cs:[CSlp16LogDevice]
	push	word ptr 5					;OBJ_BITMAP
	push	cs:[CSlp16LogDevice]
	push	ebx
	push	ebx
	push	cs:[CSlp16LogDevice]
	call	DIB_RealizeObjectExt
	or	eax,eax
	jz	GN_UpdateColorsPunt

	;Allocate shadow memory
	call	GN_MemoryAlloc
	or	eax,eax
	jz	GN_UpdateColorsPunt
	shl	eax,10H
	mov	lpBmp,eax
	mov	edi,GN_UpdateColorsPunt

	;Create shadow bitmap in system memory
	sub	ebx,ebx
	push	cs:[CSlp16LogDevice]
	push	word ptr 5					;OBJ_BITMAP
	push	cs:[CSlp16LogDevice]
	push	lpBmp
	push	ebx
	push	cs:[CSlp16LogDevice]
	call	DIB_RealizeObjectExt
	or	eax,eax
	jz	FreeRes

	sub	ebx,ebx
	mov	es,word ptr lpBmp+2
	movzx	eax,word ptr es:[ebx].DIBENGINE.deBits+4
	shl	eax,10H
	mov	ax,word ptr es:[ebx].DIBENGINE.deBits
	mov	lpBits,eax

	;Copy screen --> shadow
        push    cs:[CSpGNLogicalDevice]
        push    lpBmp
        push    ebx
	movzx   eax,word ptr lpBits+2
        mov	ecx,8						;Bpp
        push    eax
	movzx   eax,word ptr lpBits
        push    eax
        push    ecx
        movzx	eax,es:[ebx].DIBENGINE.deWidthBytes
        push    eax
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax

        push    ebx						;lpSrcDev
        movzx   eax,word ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        push    eax
        push    dword ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        push    ecx
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        push    ebx
        push    ebx
        movzx   ebx,cs:bTableBppToIndex[8]
	mov	edx,ebx
        imul    ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
	push	ecx
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jbe	FreeRes

	;Copy shadow <-- screen
        mov     ds,cs:[wFlatDataSel]
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        mov	ecx,8						;Bpp
        push    eax
        push    dword ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        push    ecx
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax
        movzx   eax,word ptr lpBits+2
        movzx	ecx,word ptr lpBits+0
        push    eax
        push    ecx
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        movzx	ecx,ds:[esi].GNLOGDEVCX.Dibeng.deWidthBytes
        push    eax
        push    ecx
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        push    ebx						;lpBrush
        push    ebx						;lpDrawMode
        push    2						;size color table entry in bytes
        push    100H						;num color table entries
        push    lpTranslate					;lpColorTable
        push    ebx
        call    GN_BitBltSrcColorDstVram
        or      eax,eax
        jbe	FreeRes
	mov	edi,GN_UpdateColorsExit

FreeRes:
	;Delete shadow bitmap if exist
	mov	eax,lpBmp
	or	eax,eax
	je	JustFreeMem
        sub     ebx,ebx
	push	cs:[CSlp16LogDevice]
	push	word ptr -5					;-OBJ_PBITMAP
	push	eax
	push	ebx
	push	ebx
	push	cs:[CSlp16LogDevice]
	call	DIB_RealizeObjectExt

JustFreeMem:
	;Free shadow memory
	mov	eax,lpBmp
	shr	eax,10H
	call	GN_MemoryFree
	mov	eax,1
	jmp	edi
GN_UpdateColors	ENDP

PUBLIC  GN_UpdateColorsPunt
GN_UpdateColorsPunt PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        pop     eax
        push    cs:[CSlp16LogDevice]
        push    eax
PLABEL	Punt_UpdateColors
        jmp     DIB_UpdateColorsExt
GN_UpdateColorsPunt	ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnpower.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnpower.asm
;
; Purpose:      This file holds the routines dealing with power management support.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

IFDEF DEBUG
szPowerOn       DB      'DISPLAY:GN_PowerOn',0DH,0AH,0
szPowerOff      DB      'DISPLAY:GN_PowerOff',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GN_PowerOn
;
; Purpose:      This function gets called from minivdd when
;               we are going to resume from powerdown.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC GN_PowerOn, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szPowerOn
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; Send a message down the chain
        push    esi
        pushd   MSG_POWERON
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,0

        ; Do the Enable Device.
        sub     eax,eax
        push    CSlp16LogDevice_In_NVTEXT16
        push    ax
        push    eax
        push    eax
        inc     eax
        push    eax
        call    GENERIC_Enable

        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,1

        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_PowerOff
;
; Purpose:      This function gets called from minivdd when
;               we are going to resume from powerdown.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC GN_PowerOff, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szPowerOff
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ;Check for power call after INT2F
        inc     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,2
        jge     @F

        ; Send a message down the chain
        push    esi
        pushd   MSG_POWEROFF
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        push    esi
        call    GN_BlankScreen

@@:
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnpanel.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnpanel.asm
;
; Purpose:      This file holds the Control Panel interface as
;               implemented through the display driver escapes.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include valmode.inc
include escape.inc
include tvout.inc
include modeext.inc

IF      ((MAX_DISP_CONFIG * 4) LT (SIZE NVTWINVIEW_DISPLAY_CONFIG))
        echo MAX_DISP_CONFIG is less than NVTWINVIEW_DISPLAY_CONFIG
        echo Make MAX_DISP_CONFIG in gnlogdev.h bigger
        .err
ENDIF

CONTROL_FRAME_AND_LOCALS        MACRO
PARMD   pGNLogdevCXOffset
PARMD   lpDstDev
PARMW   wFunction
PARMD   lpIn
PARMD   lpOut
LOCALD  dwRequestedDeviceType
LOCALD  dwRequestedTVFormat
LOCALD  dwSizeEdidBuffer
LOCALS  sLocalEdidBuffer,512
LOCALD  dwCRTCCount
LOCALS  LocalDevData,MAX_ATTACHED_CRTCS*4
LOCALD  lpLocalDevData
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpHWCrtcCX
LOCALS  aGNCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpGNCrtcCX
LOCALD  dwDeviceCount
LOCALD  dwDevicesChanged
LOCALD  OldCrtcDevData
LOCALD  dwDevDataMask
LOCALD  dwMaxMonitors
LOCALD  dwMonitorNum
LOCALD  dwLocalDeviceMask
LOCALD  pGNLogdevCXUsingTheHead
LOCALD  pGNCrtcCXUsingTheHead
LOCALD  pHWCrtcCXUsingTheHead
LOCALD  dwLogCrtcIndex
LOCALD  lpDesktopModeInfo
LOCALD  lpModeInfo
LOCALV  sDesktopModeInfo,MODEINFO
LOCALV  sModeInfo,MODEINFO
LOCALV  sModeOut,MODEOUT
LOCALV  sSettableModeInfo,MODEINFO
LOCALS  aGammaTable,400H
LOCALW  wClone
ENDM

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     ControlPanelInterface
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC ControlPanelInterface, PASCAL, FRAME, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi

        sub     ecx,ecx
        movzx   eax,wFunction
        cmp     eax,NV_ESC_SETGET_TWINVIEW_DATA
        jne     Done

        push    OFFSET ReturnAddr
        mov     esi,pGNLogdevCXOffset
        sub     edi,edi
        les     di,lpOut
        mov     eax,es:[edi].NVTWINVIEWDATA.dwAction

        cmp     eax,NVTWINVIEW_ACTION_SETGET_STATE
        je      NV_SetGet_State
        cmp     eax,NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE
        je      NV_SetGet_Device_Type
        cmp     eax,NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP
        je      NV_SetGet_VirtualDesktop
        cmp     eax,NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN
        je      NV_SetGet_Freeze_Origin
        cmp     eax,NVTWINVIEW_ACTION_SETGET_VIRTUAL_MODE
        je      NV_SetGet_VirtualMode
        cmp     eax,NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE
        je      NV_SetGet_PhysicalMode
        cmp     eax,NVTWINVIEW_ACTION_VALIDATE_VIRTUAL_MODE
        je      NV_ValidateVirtualMode
        cmp     eax,NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE
        je      NV_ValidatePhysicalMode
        cmp     eax,NVTWINVIEW_ACTION_SETGET_TIMING_OVERRIDE
        je      NV_SetGet_Timing_Override
        cmp     eax,NVTWINVIEW_ACTION_SETGET_CLONE_GAMMA
        je      NV_SetGetCloneGamma
        cmp     eax,NVTWINVIEW_ACTION_ROTATE_CLONE_DEVICES
        je      GN_RotateCloneDevices
        cmp     eax,NVTWINVIEW_ACTION_LOCK_HWCRTC
        je      GN_LockHWCrtcOnHead
        cmp     eax,NVTWINVIEW_ACTION_UNLOCK_HWCRTC
        je      GN_UnlockHWCrtcOnHead
        cmp     eax,NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE
        je      GN_SpecialSetPhysicalMode
        cmp     eax,NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD
        je      GN_MapLogToPhysHead
        cmp     eax,NVTWINVIEW_ACTION_SETGET_DISPLAY_CONFIG
        je      GN_SetGetDisplayConfig
        cmp     eax,NVTWINVIEW_ACTION_GET_LARGEST_EDID_MODE
        je      GN_GetBiggestEdidMode

        add     sp,@WordSize
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,0
        sub     ecx,ecx
        jmp     Done

ReturnAddr:
Done:
        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_State
;
; Purpose:      This function gets or sets the desktop state.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;               es:edi          NVTWINVIEWDATA
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_State, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        sub     edi,edi
        les     di,lpOut

        ; Let's get the current state first!
        mov     eax,NVTWINVIEW_STATE_CLONE
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        ja      @F
        mov     eax,NVTWINVIEW_STATE_MULTIMON
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        ja      @F
        mov     eax,NVTWINVIEW_STATE_NORMAL
@@:
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetState

GetState:
        ; We got it and we're done!
        mov     es:[edi].NVTWINVIEWDATA.dwState,eax
        mov     eax,1
        jmp     Done

SetState:
        cmp     eax,NVTWINVIEW_STATE_NORMAL
        je      CurrentNormal
        cmp     eax,NVTWINVIEW_STATE_CLONE
        je      CurrentClone
        mov     eax,NVTWINVIEW_STATE_CHANGE_FAILED
        jmp     Done

CurrentNormal:
        cmp     es:[di].NVTWINVIEWDATA.dwState,NVTWINVIEW_STATE_NORMAL
        je      NoChange

        ; OK, normal->clone means we attach a crtc
        ; The caller will issue a ChangeDisplaySettings after we return
        push    esi
        call    GN_LogdevAddAClone
        mov     eax,NVTWINVIEW_STATE_CLONE
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1
        jmp     WriteItOut

CurrentClone:
        cmp     es:[di].NVTWINVIEWDATA.dwState,NVTWINVIEW_STATE_CLONE
        je      NoChange

        ; Clear panning flag to prevent the next clone limitation
        mov     edi,1
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]

        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        pushd   0
        CALLFAR16IND lpfnSetClonePanningFlag,es,ax

        ; Save last mode for this device
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax

        ; Clone->Normal means we detach a CRTCCX.
        ; The caller will issue a ChangeDisplaySettings after we return
        push    esi
        push    edi
        call    GN_LogdevDetachCrtc
        mov     eax,NVTWINVIEW_STATE_NORMAL

WriteItOut:
        ; The change succeeded -- write out the new state
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    eax
        CALLFAR16IND lpfnSetDesktopState,es,ax
        
        mov     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,1

NoChange:
        mov     eax,NVTWINVIEW_STATE_CHANGE_DONE

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_Device_Type
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;               es:edi          NVTWINVIEWDATA
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_Device_Type, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     eax,eax

        ; Determine the correct CRTC to address
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     WriteRegistry

        ; Get the CRTC context ptr
        lea     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ecx][edx * 4]
        or      esi,esi
        je      DoneIt

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     NV_SetDisplayDeviceType
        jmp     NV_GetDisplayDeviceType

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IDEBUG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HACK!!!
; JKTODO - Jim, Sorry about this, but it was the only solution I could
;          come up with given the current time constraints. We can talk
;          about this further.
WriteRegistry:
        ; If we are in Normal Mode, and a request is coming in to write
        ; logical head 1 then write the registry with the new display
        ; device to LogicalDevice0 PhysicalDevice1.
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        ja      DoneIt
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        ja      DoneIt
        
        ; We are in normal mode. Check if we are being asked to write
        ; logical device 1.
        cmp     es:[edi].NVTWINVIEWDATA.dwCrtc,1
        jne     DoneIt

        ; Get the type of device we are pointing to
        ; and convert it to the DEVTYPE_XXX type list.
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR LocalDevData).cType,cl

        ; Map the RM TvFormat to the NVmode Tvformat
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR LocalDevData).cFormat,cl

        ; Assume device number 0 for now
        mov     (DEVDATA PTR LocalDevData).cNumber,0

        ; Write this out to the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     eax,0
        push    eax
        inc     eax
        push    eax
        mov     ax,ss
        shl     eax,10h
        lea     ax,LocalDevData
        push    eax
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

        mov     eax,1                   ; return success
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetDisplayDeviceType
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_SET_DISPLAY_DEVICE_TYPE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNCRTCCX
;               es:edi          NVTWINVIEWDATA
;
; Returns:      ecx             1
;               eax             1
;
; Preserve:
;==============================================================================
DECPROC NV_SetDisplayDeviceType, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax

        ; Get the type of device we are pointing to
        ; and convert it to the DEVTYPE_XXX type list.
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR LocalDevData).cType,cl
        cmp     cl,DEVTYPE_TV
        mov     cl,0
        jne     @F

        ; Map the RM TvFormat to the NVmode Tvformat
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
@@:
        mov     (DEVDATA PTR LocalDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR LocalDevData).cNumber,ch

        ; Save off the old device data
        push    esi
        call    GN_GetDevData
        mov     OldCrtcDevData,eax

        ; Temporarily set the new device
        push    esi
        push    dword ptr LocalDevData
        call    GN_SetDevData

        mov     edi,pGNLogdevCXOffset

        ; Make sure that the device desired by this CRTC is not
        ; in use by any other active CRTCCX on the board.
        push    ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    esi
        call    GN_IsDevDataUniqueOnBoard
        or      eax,eax
        je      DeviceInUse

        ; OK, sure it's unique, but is the device connectable to some
        ; head? (any head - it doesn't matter right now which one.)
        mov     ecx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    dword ptr LocalDevData
        call    HW_IsDeviceAttached
        or      eax,eax
        je      DeviceNotAttached

        ; OK, we have a unique device (from the others in use)
        ; that is connected to the system. Now can we find an
        ; arrangment whereby this device can be used?
        push    ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; Ask the hardware if it is possible to have all the
        ; devices specified enabled simultaneously by assigning
        ; each to a different head.
        mov     ecx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    dwDeviceCount
        call    HW_CanDevicesBeMapped
        or      eax,eax
        je      AssignmentNotPossible

        ; Don't bother and try to read the edid on a tv
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0
        cmp     (DEVDATA PTR LocalDevData).cType,DEVTYPE_TV
        je      DoneEdidRead

        ; Read the EDID for this device if it has an EDID
        mov     ds:[esi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,ds:[esi].GNCRTCCX.sEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,ds:[esi].GNCRTCCX.dwEdidSize
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid

        ; Set a flag in this CRTCCX that this is a display device
        ; change
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1

DoneEdidRead:
        ; The caller will issue a ChangeDisplaySettings after we return
        mov     eax,1
        jmp     DoneIt

AssignmentNotPossible:
DeviceNotAttached:
DeviceInUse:
        ; Restore the old dev data
        push    esi
        push    dword ptr OldCrtcDevData
        call    GN_SetDevData
        sub     eax,eax

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDisplayDeviceType
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_DISPLAY_DEVICE_TYPE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNCRTCCX
;               es:edi          NVTWINVIEWDATA
;
; Returns:      eax             1
;               ecx             1
;
; Preserve:
;==============================================================================
DECPROC NV_GetDisplayDeviceType, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        movzx   ecx,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cType
        call    HW_MapGNDeviceTypeToHWDeviceType
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType,ecx
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        movzx   ecx,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cFormat
        call    HW_MapGNTvFormatToHWTvFormat
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat,ecx

        ; Create the bitmask for the display type and number.
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        mov     cl,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cType
        shl     cl,3
        mov     eax,1
        shl     eax,cl
        mov     cl,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cNumber
        shl     eax,cl
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask,eax

        mov     eax,1
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_VirtualDesktop
;
; Purpose:      This function is for setting or getting the state of the
;               virtual desktop. Panning is only possible if the virtual
;               desktop is enabled.
;
; Arguments:    Control Display Driver Stack Frame
;               ds      Context selector
;               esi     GNLOGDEVCX ptr
;               es:edi  NVTWINVIEWDATA
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetGet_VirtualDesktop, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetAutoPan

        mov     eax,ds:[esi].GNLOGDEVCX.dwVirtualDesktopEnabled
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwvirtualdesktopdata.dwVirtualDesktop,eax
        jmp     Done

SetAutoPan:
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwvirtualdesktopdata.dwVirtualDesktop
        mov     ds:[esi].GNLOGDEVCX.dwVirtualDesktopEnabled,eax

        ; Write this out to the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        push    eax
        CALLFAR16IND lpfnSetVirtualDesktop,es,ax
Done:
        sub     edi,edi
        les     di,lpOut
        mov     eax,1
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_VirtualMode
;
; Purpose:      This function writes/reads the virtual mode for the
;               desktop to/from the registry.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_VirtualMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; I need to do this regarless of get or set
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR sModeInfo.MIDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR sModeInfo.MIDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR sModeInfo.MIDevData).cNumber,ch

        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetCloneDesktopSelection,es,ax
        mov     wClone,ax

        sub     edi,edi
        les     di,lpOut

        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        je      GetVirt

SetVirt:
        ; Get the Twinview data into a MODEINFO structure
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax

        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        cmp     wClone,1
        mov     eax,0
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax
        jmp     DoneIt

GetVirt:
        ; What device is he asking about?
        mov     eax,dword ptr sModeInfo.MIDevData
        lea     ecx,[ebx].GNCRTCCX.sCrtcModeInfo
        xor     eax,ds:[ecx].MODEINFO.MIDevData
        and     eax,0FFFFFFFFH
        jne     NotCurrent

UseCurrent:
        ; He is asking about the current device
        sub     edi,edi
        les     di,lpOut
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        jmp     DoneIt

NotCurrent:
        ; Read the registry for the virtual desktops of devices that
        ; are not currently active
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        cmp     wClone,1
        mov     eax,0
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnGetDeviceDesktopMode,es,ax
        or      ax,ax
        je      UseCurrent

        ; Copy the data back from our MODEINFO to the Twinview struct
        sub     edi,edi
        les     di,lpOut
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_PhysicalMode
;
; Purpose:      This function writes/reads the physical mode for a
;               specific CRTC to/from the registry.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_PhysicalMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     DoneIt

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      DoneIt

        ; I need to do this regardles of set or get
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR sModeInfo.MIDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR sModeInfo.MIDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR sModeInfo.MIDevData).cNumber,ch

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        je      GetPhys

SetPhys:
        ; Get the Twinview data into a MODEINFO structure
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh
        mov     sModeInfo.dwRefreshRate,eax

        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax

        cmp     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,0
        je      DoneIt

        ; Set panning flag for the clone device
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        pushd   1
        CALLFAR16IND lpfnSetClonePanningFlag,es,ax
        jmp     DoneIt

GetPhys:
        ; What device is he asking about?
        movzx   eax,(DEVDATA PTR sModeInfo.MIDevData).cType
        lea     ecx,[esi].GNCRTCCX.sCrtcModeInfo
        xor     eax,ds:[ecx].MODEINFO.MIDevData
        and     eax,0FFFFFFH
        jne     NotCurrent

UseCurrent:
        ; He is asking about the current device
        sub     edi,edi
        les     di,lpOut
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        mov     eax,fs:[ebx].MODEINFO.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,fs:[ebx].MODEINFO.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,fs:[ebx].MODEINFO.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,fs:[ebx].MODEINFO.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        jmp     DoneIt

UseDefault:
        sub     edi,edi
        les     di,lpOut
        mov     eax,640                 ;XRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,480                 ;YRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,10H                 ;bpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,60                  ;RefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        jmp     DoneIt

NotCurrent:
        ; Read the registry for the virtual desktops of devices that
        ; are not currently active
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        je      UseDefault

        ; Copy the data back from our MODEINFO to the Twinview struct
        sub     edi,edi
        les     di,lpOut
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,sModeInfo.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_ValidateVirtualMode
;
; Purpose:      This function validates a virtual mode for the desktop.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_ValidateVirtualMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up our context
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        push    es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        push    es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        call    HW_GetModeDimensions

        ; Get the largest block size that we could put this mode in
        push    ebx
        push    esi
        call    GN_GetFreeBlockSizeForMode
        pop     ebx

        ; Is it enough?
        cmp     eax,ebx
        jl      Invalid

Valid:
        mov     eax,1
        jmp     Done

Invalid:
        sub     eax,eax

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_ValidatePhysicalMode
;
; Purpose:      This function validates the physical mode for the
;               desktop.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_ValidatePhysicalMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     Done

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      Done

        ; Get the type of device we are validating the mode on
        ; and convert it to the DEVTYPE_XXX type list.
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR LocalDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR LocalDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR sModeInfo.MIDevData).cNumber,ch
        mov     (DEVDATA PTR LocalDevData).cNumber,ch

        ; Don't bother and try to read the edid on a tv
        mov     dwSizeEdidBuffer,0
        cmp     (DEVDATA PTR LocalDevData).cType,DEVTYPE_TV
        je      DoneEdidRead

        ; Read the EDID for this device if it has an EDID
        mov     dwSizeEdidBuffer,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,sLocalEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,dwSizeEdidBuffer
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid

DoneEdidRead:
        ; Get everything into a MODEINFO structure
        sub     edi,edi
        les     di,lpOut
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh
        mov     sModeInfo.dwRefreshRate,eax
        mov     eax,dword ptr LocalDevData
        mov     sModeInfo.MIDevData,eax

        ; Validate the mode.
        push    esi
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.dwMonitorInfType
        mov     ax,ss
        shl     eax,10H
        lea     ax,sLocalEdidBuffer
        push    eax
        push    dwSizeEdidBuffer
        call    GN_ValidatePhysicalMode
        mov     edx,eax

        ; Otherwise, we need an exact match
        mov     eax,1
        cmp     edx,MODE_EXACT_MATCH
        je      Done

        ; Fail, but copy back the best match to Twinview
        sub     edi,edi
        les     di,lpOut
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,sModeInfo.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        sub     eax,eax

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_Timing_Override
;
; Purpose:      This function gets or sets the timing override.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;               es:edi          NVTWINVIEWDATA
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_Timing_Override, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        ; See we are in clone or extended mode
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        jg      @F
        sub     edx,edx
@@:
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     Done

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      Done

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetTimingOverride

GetTimingOverride:
        ; Read the registry for the virtual desktops of devices that
        ; are not currently active
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    fs:[bx].DISPDATA.lpDevData
        mov     ax,es
        shl     eax,10h
        lea     ax,es:[di].NVTWINVIEWDATA.dwState
        push    eax
        CALLFAR16IND lpfnGetTimingOverride,es,ax
        movzx   eax,ax
        or      ax,ax
        jmp     Done

SetTimingOverride:
        ; Write this out to the registry.
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    fs:[bx].DISPDATA.lpDevData
        push    es:[di].NVTWINVIEWDATA.dwState
        CALLFAR16IND lpfnSetTimingOverride,es,ax
        mov     eax,1
Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_Freeze_Origin
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetGet_Freeze_Origin, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     Done

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      Done

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetFreeze

        ; dwPanAndScanEnabled has the opposite sense of dwFreezeOrigin.
        mov     eax,ds:[esi].GNCRTCCX.dwPanAndScanEnabled
        cmp     eax,0
        mov     eax,1
        je      WriteData
        mov     eax,0
WriteData:
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwfreezedata.dwFreezeOrigin,eax
        jmp     Done

SetFreeze:
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwfreezedata.dwFreezeOrigin
        cmp     eax,0
        je      Unfreeze

        mov     ds:[esi].GNCRTCCX.dwPanAndScanEnabled,0

        ; Write this out to the registry.
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpDevData
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwTop
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwBottom
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwRight
        push    eax
        CALLFAR16IND lpfnSetAutoPanMode,es,ax

        jmp     Done

Unfreeze:
        mov     ds:[esi].GNCRTCCX.dwPanAndScanEnabled,1

        ; Write this out to the registry.
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpDevData
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwTop
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwBottom
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwRight
        push    eax
        CALLFAR16IND lpfnSetAutoPanMode,es,ax

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1

CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGetCloneGamma
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetGetCloneGamma, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     EndIt

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      EndIt

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetGamma

GetGamma:
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        lea     edi,[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.adwGammaTable
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     eax,1
        jmp     EndIt

SetGamma:
        PUSHR   ds
        mov     ax,ds
        mov     cx,es
        mov     es,ax
        mov     ds,cx
        mov     ebx,esi
        lea     esi,[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.adwGammaTable
        lea     edi,[ebx].GNCRTCCX.dwGammaTable
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
        POPR    ds

        ; Now put it into the hardware
        push    ebx
        call    GN_ResetColorMap
        mov     eax,1

EndIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_RotateCloneDevices
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
;               This escape will take the display device the primary
;               is using and use that device for the first clone. It
;               will take the display device used by the first clone
;               and make the primary use it. For a dual head board
;               this functions as a "Swap display devices". For more
;               than a two head board, it is a "rotate display devices."
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RotateCloneDevices, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        mov     dwDeviceCount,edi

        ; Get the primary CRTC dislay device
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        call    GN_GetDevData
        mov     OldCrtcDevData,eax
        jmp     NextCrtc

TopL:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        or      ecx,ecx
        je      NextCrtc

        ; Aha! Found another one. Get it's DevData
        push    ecx
        call    GN_GetDevData
        push    eax

        ; Set the prior CRTCCX's DevData into this one
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    OldCrtcDevData
        call    GN_SetDevData

        ; Now save this guys old one as the next one to rotate in
        pop     OldCrtcDevData

        ; We actually rotated one
        inc     dwDeviceCount

NextCrtc:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      TopL

        ; Did we rotate any?
        cmp     dwDeviceCount,0
        mov     eax,0
        je      DoneIt

        ; Yes! That means that the display device used by the last
        ; CRTCCX we found should go into the primary.
        sub     edi,edi
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    OldCrtcDevData
        call    GN_SetDevData

        ; Get the Device Data Mask for all display devices.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwLocalDeviceMask,eax

        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_BeginDisplayChange

        ; Go into each GNCRTCCX and set the physical resolution
        ; equal to the desktop resolution. The mode will be
        ; backed off if it cannot be set directly.
        sub     edi,edi
Loop8:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        or      ecx,ecx
        je      NextCrtc8

        lea     ebx,ds:[ecx].GNCRTCCX.sCrtcModeInfo
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     ds:[ebx].MODEINFO.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     ds:[ebx].MODEINFO.dwYRes,eax

NextCrtc8:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      Loop8

        ; remap everything
        push    esi
        call    GN_CrtcRemapArray
        push    esi
        call    GN_RestoreAllCrtcStates

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_EndDisplayChange

        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1
        mov     eax,1

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_LockHWCrtcOnHead
;
; Purpose:      This function locks the HWCRTCCX on the head specified
;               for use by the caller. The display driver will not change
;               the hardware state of the CRTC controller on the head
;               specified for any reason. It is the caller's
;               responsibility to unlock when he is done.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LockHWCrtcOnHead, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the ptr to the Data
        sub     edi,edi
        les     di,lpOut
        mov     pHWCrtcCXUsingTheHead,0

        ; Find the GNLOGDEVCX that is using this head number
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    es:[edi].NVTWINVIEWDATA.dwCrtc
        call    GN_MapHeadToGNLogdev
        or      eax,eax
        je      DoneIt
        mov     pGNLogdevCXUsingTheHead,ebx
        mov     pGNCrtcCXUsingTheHead,eax
        mov     dwLogCrtcIndex,ecx

        ; We need to reset the panning rectangle to be justified
        ; in the upper left corner.
        sub     ecx,ecx
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwLeft,ecx
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwTop,ecx
        lea     ebx,[eax].GNCRTCCX.sCrtcModeInfo
        mov     ecx,ds:[ebx].MODEINFO.dwXRes
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwRight,ecx
        mov     ecx,ds:[ebx].MODEINFO.dwYRes
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwBottom,ecx
        push    eax
        call    GN_SetPanRectangle

        ; Save the HWCRTCCX using the head to return to the caller
        mov     eax,pGNCrtcCXUsingTheHead
        mov     ebx,ds:[eax].GNCRTCCX.pHWCrtcCX
        mov     pHWCrtcCXUsingTheHead,ebx

        ; Play some games here! NULL out the HWCRTCCX in the GNCRTCCX
        ; so that the display driver will not mess with that head.
        mov     ds:[eax].GNCRTCCX.pHWCrtcCXWhenLocked,ebx
        mov     ds:[eax].GNCRTCCX.pHWCrtcCX,0

        ; Tell the hwlogdev that the HWCRTCCX is NULL
        mov     eax,pGNLogdevCXUsingTheHead
        push    ds:[eax].GNLOGDEVCX.pHWLogdevCX
        push    dwLogCrtcIndex
        push    pHWCrtcCXUsingTheHead
        call    HW_LogdevDetachCrtc

        ; Reset the gamma ramp to the identity
        lea     ebx,aGammaTable
        sub     ecx,ecx
@@:     mov     ss:[ebx],ecx
        add     ebx,4
        add     ecx,010101H
        or      cl,cl
        jne     @B

        ; Get a flat ptr to the identity gamma table
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     edx,aGammaTable
        add     eax,edx

        ; Tell the hardware to set it
        push    pHWCrtcCXUsingTheHead
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetGamma

        ; Turn the cursor off on the CRTC in question
        push    pHWCrtcCXUsingTheHead
        pushd   0
        call    HW_CursorEnable_FAR32
        mov     eax,1

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     eax,pGNLogdevCXUsingTheHead
        mov     es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pGNLogdevCX,eax
        mov     eax,dwLogCrtcIndex
        mov     es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex,eax
        mov     eax,pHWCrtcCXUsingTheHead
        mov     es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pHWCrtcCX,eax
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_UnlockHWCrtcOnHead
;
; Purpose:      This function unlocks the HWCRTCCX on the head specified
;               for use by the caller. The display driver can once again
;               change the hardware state of the CRTC controller on the
;               head specified for any reason.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds
;==============================================================================
DECPROC GN_UnlockHWCrtcOnHead, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the ptr to the Data
        sub     edi,edi
        les     di,lpOut
        mov     ebx,es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pGNLogdevCX
        mov     pGNLogdevCXUsingTheHead,ebx
        mov     ecx,es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex
        mov     dwLogCrtcIndex,ecx
        mov     eax,es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pHWCrtcCX
        mov     pHWCrtcCXUsingTheHead,eax

        ; Check for NULL ptrs.
        mov     eax,1
        cmp     pHWCrtcCXUsingTheHead,0
        je      DoneIt

        ; Is this a legal logical crtc index for this device?
        sub     eax,eax
        cmp     ecx,ds:[ebx].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     DoneIt

        ; Let's just make sure we don't already have a HWCRTCCX there
        sub     eax,eax
        mov     edx,ds:[ebx].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        cmp     ds:[edx].GNCRTCCX.pHWCrtcCX,0
        jne     DoneIt
        mov     pGNCrtcCXUsingTheHead,edx

        ; Now Attach the HWCRTCCX to the GNCRTCCX
        mov     eax,pHWCrtcCXUsingTheHead
        mov     ds:[edx].GNCRTCCX.pHWCrtcCX,eax
        mov     ds:[edx].GNCRTCCX.pHWCrtcCXWhenLocked,0

        ; Now Attach the HWCRTCCX to the HWLOGDEVCX
        mov     esi,pGNLogdevCXUsingTheHead
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwLogCrtcIndex
        push    pHWCrtcCXUsingTheHead
        call    HW_LogdevAttachCrtc

        ; Get the Device Data Mask for all display devices.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwLocalDeviceMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_BeginDisplayChange

        ; Restore the software state into the hardware
        push    pGNCrtcCXUsingTheHead
        push    pGNLogdevCXUsingTheHead
        call    GN_RestoreCrtcState

        ; Reset the last active cursor
        push    pGNCrtcCXUsingTheHead
        call    GN_ResetSelectedCursor

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_EndDisplayChange

        mov     eax,1
DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_SpecialSetPhysicalMode
;
; Purpose:      This function can be called as part of the DVD Zoom
;               escapes. Once the caller has locked a HWCRTCCX on a
;               given head, they can call this routine to set the
;               physical mode on the given head.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds
;==============================================================================
DECPROC GN_SpecialSetPhysicalMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the ptr to the Data
        sub     edi,edi
        les     di,lpOut

        mov     ebx,es:[edi].NVTWINVIEWDATA.nvtwPhysicalModeImmediate.pGNLogdevCX
        mov     pGNLogdevCXUsingTheHead,ebx
        mov     ecx,es:[edi].NVTWINVIEWDATA.nvtwPhysicalModeImmediate.dwLogicalCrtcIndex
        mov     dwLogCrtcIndex,ecx
        mov     eax,es:[edi].NVTWINVIEWDATA.nvtwPhysicalModeImmediate.pHWCrtcCX
        mov     pHWCrtcCXUsingTheHead,eax
        or      eax,eax
        je      DoneIt

        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh
        mov     sModeInfo.dwRefreshRate,eax
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR sModeInfo.MIDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR sModeInfo.MIDevData).cFormat,cl

        ; This gets the timing parameters for the mode requested
        ; or a smaller mode if the requested mode was not settable.
        mov     ebx,pGNLogdevCXUsingTheHead
        mov     ecx,dwLogCrtcIndex
        mov     edx,ds:[ebx].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        mov     pGNCrtcCXUsingTheHead,edx

        ; Get timings
        push    ds:[edx].GNCRTCCX.lpNvmodeDispData
        push    ds:[edx].GNCRTCCX.lpEdidBuffer
        push    ds:[edx].GNCRTCCX.dwEdidSize
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        lea     ax,sModeOut
        push    eax
        lea     ax,sSettableModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Get the devices in use
        mov     ebx,pGNLogdevCXUsingTheHead
        push    ds:[ebx].GNLOGDEVCX.pGNBoardCX
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwDevDataMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,pGNLogdevCXUsingTheHead
        mov     ebx,ds:[ebx].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_BeginDisplayChange

        ; Call the hardware to program the timings
        mov     eax,pGNCrtcCXUsingTheHead
        mov     ebx,pGNLogdevCXUsingTheHead
        push    pHWCrtcCXUsingTheHead
        push    ds:[ebx].DIBENGINEHDR.deBitsOffset
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeOut
        push    eax
        call    HW_SetCrtcMode

        mov     ebx,pGNLogdevCXUsingTheHead
        mov     ebx,ds:[ebx].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_EndDisplayChange

        ; Return the mode actually set
        sub     edi,edi
        les     di,lpOut
        mov     eax,sSettableModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sSettableModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sSettableModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,sSettableModeInfo.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        movzx   ecx,(DEVDATA PTR sSettableModeInfo.MIDevData).cType
        call    HW_MapGNDeviceTypeToHWDeviceType
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType,ecx
        movzx   ecx,(DEVDATA PTR sSettableModeInfo.MIDevData).cFormat
        call    HW_MapGNTvFormatToHWTvFormat
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat,ecx
        mov     eax,1

DoneIt:
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_MapLogToPhysHead
;
; Purpose:      This routine takes a 0 based head logical head number
;               and returns a physical head number.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx             1
;                               Also the logical head number in
;                               lpOut->NVTINWVIEWDATA.dwCrtc was
;                               replaced with the physical head
;                               number that corresponds to it.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MapLogToPhysHead, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut

        ; Assume failure
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,0

        ; Get the logical CRTC number -- make sure it is within range
        ; for this display driver.
        mov     ebx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     MLTPH_End

        ; Is that logical CRTC NULL?
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      edx,edx
        je      MLTPH_End

        ; Nope it is fine.  Get the physical head number
        mov     eax,ds:[edx].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F

        ; This CRTC has already been locked
        mov     eax,ds:[edx].GNCRTCCX.pHWCrtcCXWhenLocked
        or      eax,eax
        je      MLTPH_End

@@:
        push    eax
        call    HW_GetPhysicalCrtcIndex
        mov     es:[edi].NVTWINVIEWDATA.dwCrtc,eax
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,1

MLTPH_End:
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetGetDisplayConfig
;
; Purpose:      This routine either sts or gets the display configuration
;               which includes, the desktop state (normal or clone), the
;               display devices being used, and the physical modes on
;               each display device.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx             1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetGetDisplayConfig, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; We might need these
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        mov     lpModeInfo,eax
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax

        sub     edi,edi
        les     di,lpOut

        ; Determine Set or Get
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetDisplayConfig

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetDisplayConfig:

        ; Find out info on the display devices
        mov     dwDeviceCount,0
        mov     dwDevDataMask,1
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwActiveDevices,0
Loop1:
        mov     ecx,dwDeviceCount
        mov     edx,dwDevDataMask
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4],0
        je      Next1

        ; CRTCCX is present -- OR in a present bit for this
        or      es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwActiveDevices,edx

        ; Get the device type
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        call    GN_GetDevData
        mov     OldCrtcDevData,eax

        ; Convert the DevData type to a mask
        shl     al,3
        add     al,ah
        mov     cl,al
        mov     ebx,1
        shl     ebx,cl
        movzx   eax,cl
        or      es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwDeviceMask,ebx

        ; If this is the primary device, set its mask
        cmp     dwDeviceCount,0
        jne     @F
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwPrimaryDeviceMask,ebx
@@:
        ; Compute the correct offset to store the PhysMode at
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwPhysicalModeFlags
        imul    eax,SIZE PHYSICAL_MODE
        lea     edi,[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.PhysModes
        add     edi,eax

        ; Is bit mask ebx set in the dwPhysicalModeFlags field?
        test    ebx,ecx
        jz      GetMaxMode

GetCurrentMode:
        mov     ecx,dwDeviceCount
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        lea     ebx,[ebx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.dwXRes
        mov     es:[edi].PHYSICAL_MODE.dwXRes,eax
        mov     eax,ds:[ebx].MODEINFO.dwYRes
        mov     es:[edi].PHYSICAL_MODE.dwYRes,eax
        mov     eax,ds:[ebx].MODEINFO.dwRefreshRate
        mov     es:[edi].PHYSICAL_MODE.dwRefreshRate,eax
        jmp     Next1

GetMaxMode:
        ; Pass in a ridiculously large mode to FindModeEntry and it
        ; will bump it down to something the device can set.
        mov     sModeInfo.dwXRes,7FFFH
        mov     sModeInfo.dwYRes,7FFFH
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     sModeInfo.dwBpp,eax
        mov     sModeInfo.dwRefreshRate,1000
        mov     eax,OldCrtcDevData
        mov     dword ptr sModeInfo.MIDevData,eax

        mov     ecx,dwDeviceCount
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    edx
        push    lpModeInfo
        lfs     bx,ds:[edx].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.dwMonitorInfType
        push    ds:[edx].GNCRTCCX.lpEdidBuffer
        push    ds:[edx].GNCRTCCX.dwEdidSize
        call    GN_ValidatePhysicalMode

        ; We don't care about the return value. The point is,
        ; whatever is in sModeInfo is the largest settable mode.
        ; Copy it into the PHYSICAL_MODE structure.
        mov     es,word ptr lpOut+2
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].PHYSICAL_MODE.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].PHYSICAL_MODE.dwYRes,eax
        mov     eax,sModeInfo.dwRefreshRate
        mov     es:[edi].PHYSICAL_MODE.dwRefreshRate,eax

Next1:
        inc     dwDeviceCount
        shl     dwDevDataMask,1
        mov     ecx,dwDeviceCount
        cmp     ecx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loop1
        jmp     Success

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SetDisplayConfig:
        ; Let's shotgun save the entire _NVTWINVIEW_DISPLAY_CONFIG
        ; structure into our GNLOGDEVCX in case we need it.
        PUSHR   ds,esi
        mov     ebx,edi
        push    ds
        push    es
        pop     ds
        pop     es
        lea     edi,[esi].GNLOGDEVCX.sDispConfig
        lea     esi,[ebx].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig
        mov     ecx,SIZE NVTWINVIEW_DISPLAY_CONFIG
        cld
        rep     movs byte ptr es:[edi], ds:[esi]
        POPR    ds,esi
        lea     edi,[esi].GNLOGDEVCX.sDispConfig

        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwSetModesNow,0
        jne     FailIt

        ; Now we can reference everything from ds:[edi]
        ; This code assumes only two heads and assumes that
        ; it will never be called when we are in multi-mon mode.
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices
        shr     eax,1
        inc     eax
        mov     dwDeviceCount,eax
        or      eax,eax
        je      FailIt
        cmp     eax,2
        ja      FailIt

        ; Convert the dwDeviceMask to an array of DevDatas and ask if
        mov     edx,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        lfs     bx,lpLocalDevData

Loop3:
        sub     ecx,ecx
Loop4:
        test    edx,1
        jz      @F
        mov     dword ptr fs:[bx],0
        mov     ch,cl
        shr     ch,3
        mov     byte ptr fs:[bx].DEVDATA.cType,ch
        mov     ch,cl
        and     ch,07H
        mov     byte ptr fs:[bx].DEVDATA.cNumber,ch
        add     bx,4
        dec     eax
        je      Out1
@@:     inc     cl
        shr     edx,1
        cmp     cl,18H
        jc      Loop4
Out1:

        ; Ask the hardware if it is possible to have all the
        ; devices specified enabled simultaneously by assigning
        ; each to a different head.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    dwDeviceCount
        call    HW_CanDevicesBeMapped
        or      eax,eax
        je      FailIt

        ; dwPrimaryDeviceMask should be one of dwDeviceMask bits
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        mov     ebx,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwPrimaryDeviceMask
        and     eax,ebx
        je      FailIt

DeferChange:
        mov     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,1
        mov     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,1
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ds:[ebx].GNCRTCCX.dwDisplayDeviceChange,1
        
        jmp     Success
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FailIt:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,0
        jmp     Done
Success:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,1
Done:
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetBiggestEdidMode
;
; Purpose:      This routine gets the largest mode in the EDID for the
;               display device passed in.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx             1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetBiggestEdidMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC


        ; Need to change dwDeviceMask into DevData
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwDeviceMask

        ; First look at CRTS
        mov     eax,DEVTYPE_CRT + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next1
        jmp     GotDevData
Next1:  shr     cl,1
        cmp     ah,8
        jc      @B

        ; Nope. Try DFPS
        shr     ecx,8
        mov     eax,DEVTYPE_DFP + 0FF00H
@@:     inc     ah
        test    ch,1
        jz      Next2
        jmp     GotDevData
Next2:  shr     ch,1
        cmp     ah,8
        jc      @B

        ; Last hope is TVS
        mov     eax,DEVTYPE_TV + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next3
        jmp     GotDevData
Next3:  shr     cl,1
        cmp     ah,8
        jc      @B
        
        ; No valid device attached. Fail
        jmp     FailIt
        
GotDevData:
        mov     (DEVDATA PTR LocalDevData).cType,al
        mov     (DEVDATA PTR LocalDevData).cNumber,ah

        ; TV has no EDID. Return largest TV mode.
        cmp     (DEVDATA PTR LocalDevData).cType,DEVTYPE_TV
        jne     GetEdid

        ; The specific GNCRTCCX is not important as dwMaxTVOutResolution is
        ; the same regardless of the GNCRTCCX.
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX

        ; The largest TV mode is in the DispData structure.
        sub     ebx,ebx
        lfs     bx,ds:[edx].GNCRTCCX.lpNvmodeDispData
        mov     eax,fs:[ebx].DISPDATA.dwMaxTVOutResolution
        lea     ecx,ds:[edx].GNCRTCCX.sCrtcModeInfo
        mov     ecx,ds:[ecx].MODEINFO.dwBpp

        mov     ebx,eax
        shr     ebx,16  
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,ebx
        and     eax,0FFFFh
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,ecx
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,60

        jmp     Success

GetEdid:
        ; Read the EDID for this device if it has an EDID
        mov     dwSizeEdidBuffer,MAX_EDID_BUFFER_SIZE
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[edx].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,sLocalEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,dwSizeEdidBuffer
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid
        
        cmp     dwSizeEdidBuffer,0
        jne     DoneEdidRead
        
        ; No EDID for this display device. Return something safe like
        ; 800x600@60Hz.
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,800
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,600
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     edx,ds:[edx].GNCRTCCX.sCrtcModeInfo
        mov     edx,ds:[edx].MODEINFO.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,edx
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,60
        
        jmp     Success

DoneEdidRead:
        ; Now get the largest mode for this EDID.
        mov     ax,ss
        shl     eax,10h
        lea     ax,sLocalEdidBuffer
        push    eax
        push    dwSizeEdidBuffer
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetLargestEdidMode,es,ax

        sub     edi,edi
        les     di,lpOut
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,ss:[ebx].MODEINFO.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     edx,ds:[edx].GNCRTCCX.sCrtcModeInfo
        mov     edx,ds:[edx].MODEINFO.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,edx
        mov     eax,ss:[ebx].MODEINFO.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax

        jmp     Success

FailIt:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,0
        jmp     Done
Success:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,1
Done:
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_MapHeadToGNLogdev
;
; Purpose:      This routine takes a 0 based head nmber and returns
;               the GNLOGDEVCX ptr that the head number is attached to.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwHead                  0 based head number
;
; Returns:      eax                     GNCRTCCX using the head
;               ebx                     GNLOGDEVCX owning the GNCRTCCX
;                                       which is using the head
;               ecx                     dwLogicalCrtcIndex of GNCRTCCX
;                                       in GNLOGDEVCX
;               eax,ebx, are NULL if not found
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MapHeadToGNLogdev, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwHead
LOCALD  dwCRTCCount
LOCALD  dwLogdevCount
OPENPROC
        PUSHR   esi
        mov     ebx,pGNBoardCXOffset
        mov     dwLogdevCount,0
        sub     eax,eax

LoopLogdev:
        mov     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        or      edx,edx
        je      NextLogdev

        ; Is this head on this GNLOGDEVCX?
        lea     ecx,[edx].GNLOGDEVCX.pGNCrtcCX
        mov     dwCRTCCount,0

LoopCrtc:
        mov     eax,ds:[ecx]
        or      eax,eax
        je      NextCrtc

        PUSHR   eax,ebx,ecx,edx
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        call    HW_GetPhysicalCrtcIndex
        mov     esi,eax
        POPR    eax,ebx,ecx,edx
        cmp     esi,dwHead
        je      Found

NextCrtc:
        inc     dwCRTCCount
        add     ecx,4
        mov     eax,dwCRTCCount
        cmp     eax,ds:[edx].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jc      LoopCrtc

NextLogdev:
        inc     dwLogdevCount
        mov     eax,dwLogdevCount
        cmp     eax,ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
        jc      LoopLogdev

NotFound:
        sub     eax,eax
        sub     ebx,ebx
        jmp     DoneIt

Found:
        mov     ebx,edx
        mov     ecx,dwCRTCCount
DoneIt:
        POPR    esi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNREPNT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnrepnt.asm
;
; Purpose:      This file holds the UserRepaint display driver entry point.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

USER_REPAINT_ORDINAL    EQU     275
MAX_USER_REPAINT_CALLS  EQU     5
GRAPHICS_IDLE_TIME      EQU     200H

OPENSEG  _DATA, USE16, DATA
; This must be in a DATA segment or else Kernel chokes on it.
PUBLIC  szUserModuleName
szUserModuleName        DB      'USER',0
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC	lpfnUserRepaint
lpfnUserRepaint	DD	0

IFDEF DEBUG
szIssueRepnt    DB      'DISPLAY:GN_IssueUserRepaint',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GN_InitUserRepaint ()
;
; Purpose:      This function inits the ptr to the GDI function
;               UserRepaint which forces all Windows on the screen
;               to redraw themselves (places a WM_PAINT message in
;               everyones queue for every Window rectangle).
;
; Arguments:	None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_InitUserRepaint, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds
        mov     ax,_DATA
        shl     eax,10H
        mov     ax,OFFSET szUserModuleName
        push    eax
        call    GetModuleHandle

        mov     edx,USER_REPAINT_ORDINAL
        push    ax
        push    edx
        call    GetProcAddress
        shl     edx,10H
        mov     dx,ax
        mov	ds,wNVTEXT16_Alias_In_NVTEXT16
        mov	ds:[lpfnUserRepaint],edx
        POPR    ds
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_UserRepaintDisable
;
; Purpose:      This function is the gdi bitblt entry point.
;
; Arguments:    UserRepaintDisable display driver stack FRAME
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_UserRepaintDisable, PASCAL, FRAME, FAR16
PARMB   argRepaintDisable
OPENPROC
        PUSHR   ds,esi
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; If we haven't initialized yet, then do so now
        cmp	lpfnUserRepaint,0
        jnz     @F
        call    GN_InitUserRepaint
@@:
        mov     al,argRepaintDisable
        mov     ds:[esi].GNLOGDEVCX.bRepaintDisable,al
        or      al,al
        jne     @F

        ; We can call UserRepaint -- is there one pending?
        cmp     al,ds:[esi].GNLOGDEVCX.bRepaintPending
        je      @F
        mov     ds:[esi].GNLOGDEVCX.bRepaintPending,al
        push	esi
        call    GN_IssueUserRepaint
@@:
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_UserRepaint
;
; Purpose:      This function can be called to transfer a disabled
;               repaint request into a pending request.
;
; Arguments:    ds			CX Selector
;		pGNLogdevCXOffset	GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_UserRepaint, PASCAL, FRAME, FAR16
PARMD	pGNLogdevCXOffset
OPENPROC
        PUSHR   ds,esi
        mov     esi,pGNLogdevCXOffset

        ; If we haven't initialized yet, then do so now
        cmp	lpfnUserRepaint,0
        jnz     @F
        call    GN_InitUserRepaint
@@:
        mov     al,ds:[esi].GNLOGDEVCX.bRepaintDisable
        mov     ds:[esi].GNLOGDEVCX.bRepaintPending,al
        or      al,al
        jne     @F
        push	esi
        call    GN_IssueUserRepaint
@@:
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_IssueUserRepaint
;
; Purpose:      Occassionally there is a problem (Windows OS problem --
;               not our's) with toggling back from a DOS box. The issue
;               is that sometimes our request to USER to repaint the
;               screen is discarded. Hence, the Windows screen is
;               black and gets repainted bit by bit as the user clicks
;               on different pieces of it. The solution is to issue the
;               USER repaint request again if the first request hasn't
;               caused a good amount of graphics activity within a
;               reasonable amount of time.
;
; Arguments:
;		ds			Context Selector
;		pGNLogdevCXOffset	GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_IssueUserRepaint, PASCAL, FRAME, NEAR
PARMD	pGNLogdevCXOffset
OPENPROC
        PUSHR   ds,esi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szIssueRepnt
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov	esi,pGNLogdevCXOffset

        ; Set a flag saying a repaint has been issued
        mov     ds:[esi].GNLOGDEVCX.bRepaintIssued,1

        ; Call the hardware specific code to get a cookie
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetGraphicsTimeStamp
        mov     ds:[esi].GNLOGDEVCX.dwGraphicsTimeStamp,eax

        ; Now issue a repaint
        call    FFP16 PTR lpfnUserRepaint
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckUserRepaint
;
; Purpose:      Occassionally there is a problem (Windows OS problem --
;               not our's) with toggling back from a DOS box. The issue
;               is that sometimes our request to USER to repaint the
;               screen is discarded. Hence, the Windows screen is
;               black and gets repainted bit by bit as the user clicks
;               on different pieces of it. The solution is to issue the
;               USER repaint request again if the first request hasn't
;               caused a good amount of graphics activity within a
;               reasonable amount of time.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     everything!
;==============================================================================
DECPROC GN_CheckUserRepaint, PASCAL, NOFRAME, FAR16
OPENPROC
        cmp     ds:[esi].GNLOGDEVCX.bRepaintIssued,0
        je      DoneIt
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne	DoneIt
        cmp     ds:[esi].GNLOGDEVCX.bDirectXActive,0
        jne	DoneIt
        mov     ds:[esi].GNLOGDEVCX.bRepaintIssued,0

        ; Has alot of graphics activity occurred since then?
        ; Call the hardware specific code to get a cookie
        PUSHR   alld,ds,es,fs,gs

        ; Get the current time stamp
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetGraphicsTimeStamp

        ; Has it changed much?
        sub     eax,ds:[esi].GNLOGDEVCX.dwGraphicsTimeStamp
        cmp     eax,GRAPHICS_IDLE_TIME
        ja      NoMoreRepaints
	cmp	ds:[esi].GNLOGDEVCX.bUserRepaintCallCount,MAX_USER_REPAINT_CALLS
	ja	NoMoreRepaints

        ; Not much graphics activity has happened. Better issue
        ; another repaint.
        push	esi
        call    GN_IssueUserRepaint
	inc	ds:[esi].GNLOGDEVCX.bUserRepaintCallCount
	jmp	RepaintIssued

NoMoreRepaints:
	mov	ds:[esi].GNLOGDEVCX.bUserRepaintCallCount,0

RepaintIssued:
        POPR    alld,ds,es,fs,gs
DoneIt:
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSCAN.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnscan.asm
;
; Purpose:      This file holds the Output display driver implementation
;               when the style is either OS_SCANLINE, OS_POLYSCANLINE,
;               OS_BEGINNSCAN, or OS_ENDNSCAN.
;               The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the style is one of
;               these four.
;
;==============================================================================
.586
incOutput = 1
incLogical = 1
incPolyScanline = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc


EXTERNDEF       GENERIC_BeginScan:FAR16
EXTERNDEF       GENERIC_EndScan:FAR16

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_BeginScan
;
; Purpose:      The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the Output style is
;               OS_BEGINNSCAN.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_BeginScan, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD  dwRop2
LOCALD  pHWLogDevCXOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the logical device context
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]

        ; Get a ptr to the dst bitmap
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; Keep track of the fact that we are in a BeginScan
        mov     ds:[edi].GNLOGDEVCX.bInScanSequence,1

        ; Load dst flags and prep some registers
        sub     ebx,ebx
        movzx   eax,gs:[esi].DIBENGINE.deFlags

        ; Filter out old style destinations
        cmp     bx,gs:[esi].DIBENGINE.deType
        je      GN_BeginScanPunt

        ; Filter out based upon deFlags
        test    ah,VRAM / 256
        jz      GN_BeginScanPunt
        test    ah,PALETTE_XLAT / 256
        jnz     GN_BeginScanPunt

        ; Watch for busy hardware -- some other API owns the screen
        cmp     ebx,ds:[edi].GNLOGDEVCX.dwHardwareBusy
        jne     GN_BeginScanPunt

        ; If both the pen and brush are null, then we are done!
        ; The only way the two ptrs can be equal is if they are
        ; both NULL!
        mov     eax,lpBrush
        cmp     eax,lpPen
        je      BeginScanHollow

        ; Load up the drawmode ptr
        sub     ecx,ecx
        lfs     cx,lpDrawMode

	; Save off the hwlogdev for later
        mov     edx,ds:[edi].GNLOGDEVCX.pHWLogdevCX
	mov     pHWLogDevCXOffset,edx

        ; Get the rop
        movzx   edx,fs:[ecx].DRAWMODE.Rop2
        mov     dwRop2,edx

        ; Is there a brush?
        or	eax,eax
        je      UsePen

UseBrush:
        ; If the brush is hollow, then even if the rop only involves
        ; the dst (like BLACKNESS, WHITENESS, or INVERTDST), we blow
        ; off doing the output calls whatever they are. This sounds
        ; wierd but it is WHQL-correct behavior.
        sub     esi,esi
        les     si,lpBrush
        cmp     es:[esi].DIB_Brush8.dp8BrushStyle,BS_HOLLOW
        je      BeginScanHollow

        ; It is not a hollow brush. If the rop only involves the
        ; dst (no pattern involvement), then skip the pattern load.
        dec     edx
        je      RetSetPat
        cmp     edx,05H
        je      RetSetPat
        cmp     edx,0AH
        je      RetSetPat
        cmp     edx,0FH
        je      RetSetPat

        ; Load up the pattern
        mov     cl,byte ptr es:[esi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[esi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[esi].DIB_Brush8.dp8BrushBits
        mov     ebx,pHWLogDevCXOffset
        PUSH    OFFSET RetSetPat
        cmp     cl,BS_HOLLOW
        jnc     @F
        test    al,COLORSOLID
        jz      HW_LoadColorPattern
        jmp     HW_LoadSolidPattern
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      GN_BitBltFail
        test    al,PATTERNMONO
        jz      HW_LoadColorPattern
IsMono:
        sub     edx,edx
        lfs     dx,lpDrawMode
	lea	esi,[esi].DIB_Brush16.dp16BrushMono
        mov     ecx,fs:[edx].DRAWMODE.TextColor
        mov     edx,fs:[edx].DRAWMODE.bkColor
        mov     eax,-1
        jmp     HW_LoadMonoPattern
IsHatch:
        sub     edx,edx
        lfs     dx,lpDrawMode
        cmp     fs:[edx].DRAWMODE.bkMode,TRANSPARENT
        sete    al
        cmp     al,1
        sbb     eax,eax
	mov     ecx,es:[esi].DIB_Brush8.dp8BgColor
        mov     edx,es:[esi].DIB_Brush8.dp8FgColor
	lea	esi,[esi].DIB_Brush16.dp16BrushMask
        jmp     HW_LoadMonoPattern

UsePen:
	sub	ebx,ebx
        les     bx,lpPen
        cmp     es:[ebx].DIB_Pen.dpPenStyle,LS_SOLID
        jne     BeginScanHollow
        mov     edx,es:[ebx].DIB_Pen.dpPenColor
        mov     ebx,pHWLogDevCXOffset
        call    HW_LoadSolidPattern
        jmp     RetSetPat

BeginScanHollow:
        mov     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,1
        jmp     BeginScanSuccess

GN_BeginScanPunt:
        mov     ds:[edi].GNLOGDEVCX.bPuntingScan,1
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_BeginScan
        jmp     DIB_Output

RetSetPat:
        ; We are not punting Scanlines AND they are not hollow
        mov     edi,cs:[CSpGNLogicalDevice]
	movzx	esi,word ptr lpDstDev
        mov     ds:[edi].GNLOGDEVCX.bPuntingScan,0
        mov     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,0

        ; Call the hardware begin rect routine
        sub	ebx,ebx
        mov	ecx,7FFF7FFFH
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        cmp     lpClipRect,0
        je      @F
        lfs     cx,lpClipRect
        mov     ebx,dword ptr fs:[ecx].RECT.left
        mov     ecx,dword ptr fs:[ecx].RECT.right
@@:
	push	pHWLogDevCXOffset
	push	gs:[esi].DIBENGINEHDR.deBitsOffset
	push	gs:[esi].DIBENGINEHDR.deDeltaScan
	push	dwRop2
	push	ecx
	push	ebx
        call    HW_BeginRect

BeginScanSuccess:
        mov     eax,1

BeginScanDone:
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_PolyScanOrScanLine
;
; Purpose:      The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the Output style is
;               OS_POLYSCANLIE or OS_SCANLINE. They are very similar
;               except for the inner loop so we process them in the
;               same routine.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
; Purpose:      This function is the gdi Polyscan/Scnaline entry point.
;
; Arguments:
;
; Returns:
;
;==============================================================================
DECPROC GENERIC_PolyScanOrScanLine, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD  dwXPairs
LOCALD  dwYPairs
LOCALD  dwLocalBeginScan
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the logical device context
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]

        ; If we are not in a BEGINSCAN sequence, then do BeginScan now
        cmp     ds:[edi].GNLOGDEVCX.bInScanSequence,0
        je      DoBeginScan
        mov     dwLocalBeginScan,0

        ; We did receive a BeginScan call earlier, but are we punting
        ; the whole scan sequence to the DIBENG?
        cmp     ds:[edi].GNLOGDEVCX.bPuntingScan,0
        jne     GN_ScanPunt
DoneBeginScan:

        ; We are supposed to do it, but nothing to do if brush was hollow
        cmp     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,0
        jne     ScanDone

        ; Watch for busy hardware -- some other API owns the screen
        cmp     ds:[edi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_ScanPunt

        ; Now go into the appropriate loop calling the hardware
        xor     esi,esi                 ; clear high word of ESI
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        cmp     wStyle,OS_SCANLINES
        je      DoScanline

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DoPolyScan:
        les     si,lpPoints
        movzx   ecx,wCount
        mov     dwYPairs,ecx
LoopY:
        movzx   ecx,es:[esi].SCAN.scnPntCnt
        movsx   eax,es:[esi].SCAN.scnPntTop
        movsx   ebx,es:[esi].SCAN.scnPntBottom
        shr     ecx,1
        je      NextY
        cmp     ebx,eax
        jle     NextY
        lea     esi,es:[esi].SCAN.scnPntX
        shl     eax,10H
        shl     ebx,10H
        mov     dwXPairs,ecx

        ; high word of eax = top of block
        ; high word of ebx = bottom of block
        ; es:esi = ptr to begin of coord pairs for this scan group
LoopX:
        mov     ax,es:[esi + 0]
        mov     bx,es:[esi + 2]
        add     esi,4
        cmp     ax,bx
        jge     @F
        cmp     eax,ebx
        jge     @F
        call    HW_BlockRect
@@:
        dec     dwXPairs
        jg      LoopX
        add     esi,2                    ; skip unused field
NextY:
        dec     dwYPairs
        jg      LoopY
        jmp     ScanDone
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoScanline:
        les     si,lpPoints
        mov     eax,es:[esi]
        add     esi,4
        movzx   ecx,wCount
        lea     ebx,[eax + 10000H]
        dec     ecx
        mov     dwXPairs,ecx
LoopX1: mov     ax,es:[esi + 0]
        mov     bx,es:[esi + 2]
        add     esi,4
        cmp     ax,bx
        jge     @F
        cmp     eax,ebx
        jge     @F
        call    HW_BlockRect
@@:
        dec     dwXPairs
        jne     LoopX1
        jmp     ScanDone
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ScanDone:
        ; If we are not in a Begin/Scan/End sequence and had to do the
        ; begin locally, then we need to do the end locally as well.
        cmp     dwLocalBeginScan,0
        jne     DoEndScan

DoneEndScan:
        mov     eax,1
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH

GN_ScanPunt:
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_Scan
        jmp     DIB_Output

DoBeginScan:
        mov     dwLocalBeginScan,1
        push    lpDstDev
        pushw   OS_BEGINNSCAN
        push    wCount
        push    lpPoints
        push    lpPen
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
        CALLFAR16 GENERIC_BeginScan
        cmp     ds:[edi].GNLOGDEVCX.bPuntingScan,0
        je      DoneBeginScan

        ; We are punting to the DIBENG -- let it handle everything
        push    lpDstDev
        push    wStyle
        push    wCount
        push    lpPoints
        push    lpPen
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
        call    DIB_Output

DoEndScan:
        push    lpDstDev
        pushw   OS_ENDNSCAN
        push    wCount
        push    lpPoints
        push    lpPen
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
        CALLFAR16  GENERIC_EndScan
        jmp     DoneEndScan

GENERIC_PolyScanOrScanLine      ENDP


;==============================================================================
;
; Function:     GENERIC_EndScan
;
; Purpose:      The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the Output style is
;               OS_ENDNSCAN.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_EndScan, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the logical device context
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]
        sub     eax,eax

        ; If we are not in a BEGINSCAN sequence, get out
        cmp     al,ds:[edi].GNLOGDEVCX.bInScanSequence
        je      EndScanSuccess
        mov     ds:[edi].GNLOGDEVCX.bInScanSequence,al

        ; If we have a hollow brush, get out
        cmp     al,ds:[edi].GNLOGDEVCX.bHollowBrushForScan
        mov     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,al
        jne     EndScanSuccess

        ; If we have routed the whole scan sequence to the DIBENG,
        ; then don't stop now.
        cmp     al,ds:[edi].GNLOGDEVCX.bPuntingScan
        jne     GN_EndScanPunt

        ; Watch for busy hardware -- some other API owns the screen
        cmp     eax,ds:[edi].GNLOGDEVCX.dwHardwareBusy
        jne     GN_EndScanPunt

        ; call the hardware specific routine
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        call    HW_EndRect

EndScanSuccess:
        POPR    ds,esi,edi
        mov     eax,1
        STOPPROC
        RETFAR16 1CH

GN_EndScanPunt:
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_EndScan
        jmp     DIB_Output

GENERIC_EndScan     ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNROBJ.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:       gnrobj.asm
;
; Purpose:    This file holds the RealizeObject display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

DO_NOT_DITHER_16BPP_SOLID_BRUSHES       TEXTEQU <0>

OPENSEG  _DATA, USE16, DATA
EXTERNDEF                       szUserModuleName:BYTE
PUBLIC  szGDIModuleName
szGDIModuleName                 DB      'GDI',0

lfArray         LABEL   LogFont
LogFont         <-2048,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-1000,0,0,0,400,0,0,0,0,2,0,1,0,'Arial'>
LogFont         <-228,108,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-169,0,0,0,400,0,0,0,0,4,0,0,32,'Tahoma'>
LogFont         <-96,0,0,0,400,0,0,0,0,0,0,1,34,'Arial'>
LogFont         <-88,44,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-86,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-85,40,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-72,36,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-71,0,0,0,700,0,0,0,0,0,0,0,34,'Arial Narrow'>
LogFont         <-64,32,0,0,700,0,0,0,0,0,0,2,0,'Helvetica'>
LogFont         <-62,0,0,0,700,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-57,27,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-56,0,0,0,700,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-52,0,0,0,700,0,0,0,0,0,0,0,34,'Arial Narrow'>
LogFont         <-48,0,0,0,700,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-45,0,2700,2700,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <-40,0,3600,3600,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <-39,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-37,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <-35,0,0,0,400,0,0,0,0,0,0,0,34,'Arial'>
LogFont         <-33,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-32,0,0,0,700,0,0,0,0,0,0,0,0,'Times New Roman'>
LogFont         <-31,0,0,0,400,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-30,0,0,0,400,0,0,0,0,0,0,0,34,'Arial'>
LogFont         <-29,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-28,0,0,0,400,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-27,0,0,0,700,0,0,0,0,0,0,2,34,'Arial'>
LogFont         <-26,0,0,0,400,0,0,0,2,0,0,0,2,'Marlett'>
LogFont         <-25,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-24,12,0,0,700,0,0,0,0,0,0,2,0,'Helvetica'>
LogFont         <-23,0,0,0,700,0,0,0,0,4,0,0,34,'Arial'>
LogFont         <-22,0,0,0,700,0,0,0,0,4,0,0,34,'Arial'>
LogFont         <-21,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-20,0,0,0,400,0,0,0,0,0,0,2,34,'Arial'>
LogFont         <-19,0,0,0,700,0,0,0,1,4,0,2,0,'verdana'>
LogFont         <-18,0,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-17,0,0,0,700,0,0,0,0,0,0,2,34,'Arial'>
LogFont         <-16,0,0,0,400,0,0,0,0,0,0,0,0,'Arial'>
LogFont         <-15,9,0,0,700,0,0,0,0,0,2,2,2,'MS Sans Serif'>
LogFont         <-14,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-13,0,0,0,700,1,0,0,0,4,0,2,0,'arial'>
LogFont         <-12,0,0,0,400,0,0,0,0,5,0,1,0,'Arial'>
LogFont         <-11,0,0,0,700,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <-10,0,0,0,400,0,0,0,0,0,0,0,0,'Times New Roman'>
LogFont         <-9,0,0,0,0,0,0,0,0,4,0,2,34,'Small Fonts'>
LogFont         <-8,0,0,0,400,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <-7,0,0,0,400,0,0,0,0,3,2,1,34,'Small Fonts'>
LogFont         <-6,0,0,0,400,0,0,0,0,0,0,0,34,'MS Sans Serif'>
LogFont         <-5,0,0,0,400,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <-4,0,0,0,700,0,0,0,0,0,0,1,18,'Times New Roman'>
LogFont         <-3,0,900,900,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <-2,0,0,0,700,0,0,0,0,0,0,0,32,'\0'>
LogFont         <-1,0,0,0,400,0,0,0,0,4,0,0,18,'Times New Roman'>
LogFont         <0,10,0,0,1000,0,0,0,0,0,0,0,0,'System'>
LogFont         <1,0,900,900,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <2,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <3,1,0,0,700,0,0,0,0,4,2,2,34,'System'>
LogFont         <4,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <5,0,3600,3600,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <6,0,0,0,400,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <7,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <8,0,3600,3600,400,1,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <9,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <10,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <11,0,0,0,700,0,0,0,0,2,0,2,2,'AdobeSm'>
LogFont         <12,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <13,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <14,0,3600,3600,400,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <15,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <16,0,0,0,500,0,0,0,0,4,0,2,0,'Times New Roman'>
LogFont         <17,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <18,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <19,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <21,0,3600,3600,400,1,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <22,0,3600,3600,700,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <24,0,3600,3600,400,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <25,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <26,0,3600,3600,400,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <27,0,3600,3600,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <29,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <46,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <50,0,0,0,800,1,0,0,1,0,0,2,32,'Arial'>
LogFont         <-10000,0,0,0,0,0,0,0,0,0,0,0,0,'\0'>


szAllChars      LABEL   BYTE
                DW        0,  1,  2,  3,  4,  5,  6,  7,  8,  9
                DW       10, 11, 12, 13, 14, 15, 16, 17, 18, 19
                DW       20, 21, 22, 23, 24, 25, 26, 27, 28, 29
                DW       30, 31, 32, 33, 34, 35, 36, 37, 38, 39
                DW       40, 41, 42, 43, 44, 45, 46, 47, 48, 49
                DW       50, 51, 52, 53, 54, 55, 56, 57, 58, 59
                DW       60, 61, 62, 63, 64, 65, 66, 67, 68, 69
                DW       70, 71, 72, 73, 74, 75, 76, 77, 78, 79
                DW       80, 81, 82, 83, 84, 85, 86, 87, 88, 89
                DW       90, 91, 92, 93, 94, 95, 96, 97, 98, 99
                DW      100,101,102,103,104,105,106,107,108,109
                DW      110,111,112,113,114,115,116,117,118,119
                DW      120,121,122,123,124,125,126,127,128,129
                DW      130,131,132,133,134,135,136,137,138,139
                DW      140,141,142,143,144,145,146,147,148,149
                DW      150,151,152,153,154,155,156,157,158,159
                DW      160,161,162,163,164,165,166,167,168,169
                DW      170,171,172,173,174,175,176,177,178,179
                DW      180,181,182,183,184,185,186,187,188,189
                DW      190,191,192,193,194,195,196,197,198,199
                DW      200,201,202,203,204,205,206,207,208,209
                DW      210,211,212,213,214,215,216,217,218,219
                DW      220,221,222,223,224,225,226,227,228,229
                DW      230,231,232,233,234,235,236,237,238,239
                DW      240,241,242,243,244,245,246,247,248,249
                DW      250,251,252,253,254,255
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  lpfnUserGetDC, lpfnUserReleaseDC, lpfnGDICreateFontIndirect
PUBLIC  lpfnGDISelectObject, lpfnGDIDeleteObject, lpfnGDIExtTextOut
PUBLIC  dwFontInited
lpfnUserGetDC                   DD      0
lpfnUserReleaseDC               DD      0
lpfnGDICreateFontIndirect       DD      0
lpfnGDISelectObject             DD      0
lpfnGDIDeleteObject             DD      0
lpfnGDIExtTextOut               DD      0
dwFontInited                    DD      0


;==============================================================================
;
; Function:     GENERIC_RealizeObject
;
; Purpose:      This function is the display driver RealizeObject entry point.
;
; Arguments:    RealizeObject Display driver stack FRAME
;
; Returns:      For Object Creation
;               If lpOut is NULL
;                       return the size in bytes of the phys object whose
;                       type is given by wStyle
;               If lpOut is not NULL
;                       for solid brushes to a mono device --   ax = 8001H
;                       for solid brushes to a color device --  ax = 8002H
;                       for bitmaps                             ax = 1
;                       for everything else that is a succes -- ax = 8000H
;                       If unsuccessful                         ax = 0000H
;
;               For Object Deletion
;                       for a success                           ax = 1
;                       for a failure                           ax = 0
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_RealizeObject, PASCAL, NOFRAME, FAR16
OPENPROC
        ; Convert to the DIB_RealizeObjectExt stack FRAME
        pop     eax
        push    dword ptr cs:[CSlp16LogDevice]
        push    eax
        jmp	GN_RealizeObjectExt
CLOSEPROC

;==============================================================================
;
; Function:     GN_RealizeObjectExt
;
; Purpose:      This function is jumped to by the the display driver
;               GENERIC_RealizeObject entry point after the additional
;               parameter (the PDEVICE) is added to the parameter list.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      If lpOut is NULL
;                       return the size in bytes of the phys object whose
;                       type is given by wStyle
;               If lpOut is not NULL
;                       for solid brushes to a mono device --   ax = 8001H
;                       for solid brushes to a color device --  ax = 8002H
;                       for everything else that is a succes -- ax = 8000H
;                       If unsuccessful                         ax = 0000H
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RealizeObjectExt, PASCAL, FRAME, FAR16
PARMD   lpDevice
PARMW   wStyle
PARMD   lpIn
PARMD   lpOut
PARMD   lpXForm
PARMD   lpPDevice
OPENPROC
        PUSHR   ds,esi,edi

        ; Dispatch based upon style
        movsx   eax,wStyle
        cmp     eax,2
        je      GN_RealizeObjectExtBrush
        cmp     eax,5
        je      GN_RealizeObjectExtBitmap
        cmp     eax,-5
        je      GN_RealizeObjectExtDeleteBitmap
        cmp     eax,3
        je      GN_RealizeObjectExtFont

        ; Pin: DIBENG doesn't handle DeleteObject anyway
        test    eax, eax
        js      GN_RealizeObjectExtSuccess
        .errnz  $ - OFFSET GN_RealizeObjectExtPunt

GN_RealizeObjectExt     ENDP


;==============================================================================
;
; Function:     RealizeObjectExt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of RealizeObjectExt. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_RealizeObjectExtPunt
GN_RealizeObjectExtPunt   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_RealizeObjectExt
        jmp     DIB_RealizeObjectExt
GN_RealizeObjectExtPunt   ENDP

; NOTE: This routine is not a place to jump for everything. Some of the
; RealizeObjectExt flavors must return specific success codes -- not
; just a 1. See the main header in this file for more info.
PUBLIC  GN_RealizeObjectExtSuccess
GN_RealizeObjectExtSuccess   PROC         NEAR
        mov     eax,1
        .errnz  $ - OFFSET GN_RealizeObjectExtDone
GN_RealizeObjectExtSuccess   ENDP

PUBLIC  GN_RealizeObjectExtDone
GN_RealizeObjectExtDone   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 16H
GN_RealizeObjectExtDone   ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtBrush
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the object is known to be a brush. We need to do two
;               things in here.
;               1) If the brush is a color pattern and it is located in
;                  Video Memory, then we must wait for the graphics engine
;                  to go idle since the bitmap may not yet be drawn.
;               2) We normally let the DIBENG realize brushes. However,
;                  in 16bpp mode, the DIBENG will dither solid brushes
;                  that are not an exact color match. We prevent this by
;                  realizing solid brushes ourselves in 16bpp mode.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      jump to one of the RealizeObjectExt ending routines
;               when you are done
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtBrush
GN_RealizeObjectExtBrush  PROC    NEAR

        ; We will be needing these
        sub     edi,edi
        les     di,lpDevice
        sub     esi,esi
        lds     si,lpIn

	; Check for ICM
	xor	eax,eax
	cmp     ds:[esi].LogBrush.lbhcmXform,eax
	jne     GN_RealizeObjectExtPunt

        ; Check for a solid brush
        cmp     ds:[esi].LogBrush.lbStyle,BS_SOLID
        je      SolidWorry

NonSolidWorry:
        ; If it is only a sizing call, then pass it on
        cmp     lpOut,0
        je      GN_RealizeObjectExtPunt

        xor     eax,eax
        cmp     cs:[dwFontInited], eax
        jle     @F
        call    GN_LoadAndInitFonts
@@:
        ; Check for color pattern brushes
        cmp     ds:[esi].LogBrush.lbStyle,BS_PATTERN
        jne     GN_RealizeObjectExtPunt

        ; Punt NULL bitmap ptrs
        sub     eax,eax
        cmp     eax,ds:[esi].LogBrush.lbColor
        je      GN_RealizeObjectExtPunt

        ; Punt any bitmaps which are definitely not in VRAM
        lds     si,ds:[esi].LogBrush.lbColor
        cmp     ax,ds:[esi].DIBENGINE.deType
        je      GN_RealizeObjectExtPunt
        test    ds:[esi].DIBENGINE.deFlags,VRAM OR OFFSCREEN
        jz      GN_RealizeObjectExtPunt

        ; Must wait for idle
        xor     edi,edi                 ; clear high word of EDI
        les     di,cs:[CSlp16LogDevice]
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    FFP16 PTR es:[edi].DIBENGINE.deBeginAccess
        jmp     GN_RealizeObjectExtPunt

SolidWorry:
IF  (DO_NOT_DITHER_16BPP_SOLID_BRUSHES NE 0)
        ; Check for 16bpp
        cmp     es:[edi].DIBENGINE.deBitsPixel,10H
        jne     GN_RealizeObjectExtPunt

        ; Handle the sizing call, also
        mov     ecx,lpOut
        mov     eax,52H
        or      ecx,ecx
        je      GN_RealizeObjectExtDone

        ; Realize a solid brush without dithering
        movzx   edx,es:[edi].DIBENGINE.deFlags
        xor     edi,edi                 ; clear high word of EDI
        les     di,lpOut
        movzx   eax,ds:[esi].LogBrush.lbStyle
        mov     ebx,ds:[esi].LogBrush.lbColor
        mov     es:[edi].DIB_Brush16.dp16BrushStyle,ax
        mov     dword ptr es:[edi].DIB_Brush16.dp16FgColor,ebx
        movzx   eax,ds:[esi].LogBrush.lbHatch
        mov     ecx,dword ptr ds:[esi].LogBrush.lbBkColor
        mov     word ptr es:[edi].DIB_Brush16.dp16Hatch,ax
        mov     dword ptr es:[edi].DIB_Brush16.dp16BgColor,ecx

        ; To be comatible with the DIBENG, we must place
        ; 1) the RGB color in the dp16BrushMono field
        ; 2) the lpXForm argument in the dp16BrushMono+4 field
        ; 3) Use 14H for the BPP for 5-6-5 and 10H for BPP for 5-5-5
        mov     eax,lpXForm
        mov     dword ptr es:[edi].DIB_Brush16.dp16BrushMono,ebx
        mov     dword ptr es:[edi + 4].DIB_Brush16.dp16BrushMono,eax
        mov     ecx,0403H
        mov     eax,01000h+COLORSOLID
        test    edx,FIVE6FIVE
        jz      @F
        mov     ecx,0202H
        mov     eax,01400h+COLORSOLID
@@:     mov     dword ptr es:[edi].DIB_Brush16.dp16BrushFlags,eax

        ; This code is functionally equivalent to the DIBENG
        ; Convert 24bpp RGB (8-8-8) to 16bpp (5-6-6) or 15bpp (5-5-5)
        sub     edx,edx
        mov     dl,bl
        sub     dl,04
        cmc
        sbb     al,al
        and     dl,al
        shl     dx,05

        mov     dl,bh
        sub     dl,ch
        cmc
        sbb     al,al
        and     dl,al
        shr     dx,cl

        shr     ebx,10H
        sub     bl,04
        cmc
        sbb     al,al
        and     bl,al

        shl     ebx,18H
        shld    edx,ebx,05

        mov     bx,dx
        shl     edx,16
        mov     dx,bx
        mov     dword ptr es:[edi].DIB_Brush16.dp16BrushBits,edx
        mov     eax,8002h
        jmp     GN_RealizeObjectExtDone
ELSE
        jmp     GN_RealizeObjectExtPunt
ENDIF

GN_RealizeObjectExtBrush  ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtBitmap
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the object is known to be a bitmap. We need to either
;               size the bitmap or create a bitmap header.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      If sizing call (lpOut is NULL)
;                       dx:ax   number of bytes for header + bits
;               else
;                       fill in bitmap header pointed to by lpOut
;                       ax = 1
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtBitmap
GN_RealizeObjectExtBitmap PROC    NEAR

        ; Load all these up.
        mov     ecx,lpOut
        sub     edi,edi
        les     di,lpIn

        ; Split into a sizing or a creation call
        or      ecx,ecx
        jne     create

        movzx   eax,es:[edi].DIBENGINE.deWidthBytes
        movzx   edx,es:[edi].DIBENGINE.deHeight
        add     eax,3
        and     eax,NOT 3
        imul    eax,edx
        add     eax,SIZE DEVBMP
        shld    edx,eax,10H
        jmp     GN_RealizeObjectExtDone

create:
        ; Build the generic portions of the DEVBMP header
        mov	ds,cs:[wFlatDataSel]
        mov	esi,cs:[CSpGNLogicalDevice]
        mov     eax,dword ptr es:[edi].DIBENGINE.deWidth
        mov     edx,dword ptr es:[edi].DIBENGINE.deWidthBytes
        les     di,lpOut
        mov     es:[edi].DIBENGINE.deType,5250H
        mov     dword ptr es:[edi].DIBENGINE.deWidth,eax
        mov     dword ptr es:[edi].DIBENGINE.deWidthBytes,edx
        mov     eax,cs:[CSlp16LogDevice]
        mov     cx,ds:[esi].DIBENGINE.deVersion
        mov     es:[edi].DIBENGINE.delpPDevice,eax
        mov     es:[edi].DIBENGINE.deVersion,cx
        mov     ax,ds:[esi].DIBENGINEHDR.deBitsSelector
        mov     ecx,ds:[esi].DIBENGINE.deBitmapInfo
        mov     es:[edi].DIBENGINEHDR.deBitsSelector,ax
        mov     es:[edi].DIBENGINE.deBitmapInfo,ecx
        mov     eax,ds:[esi].DIBENGINE.deBeginAccess
        mov     ecx,ds:[esi].DIBENGINE.deEndAccess
        mov     es:[edi].DIBENGINE.deBeginAccess,eax
        mov     es:[edi].DIBENGINE.deEndAccess,ecx

        ; Have to get the flags right.
        movzx   eax,es:[edi].DIBENGINE.deBitsPixel
        mov     es:[edi].DIBENGINEHDR.bRealBpp,al
        mov     ebx,MINIDRIVER OR PALETTIZED
        cmp     eax,10H
        jc      @F
        mov     ebx,MINIDRIVER
        ja      @F
        or      ebx,ds:[esi].GNLOGDEVCX.dw16BppFormat
        test    ebx,FIVE6FIVE
        jnz     @F
        mov     es:[edi].DIBENGINEHDR.bRealBpp,0FH
@@:     mov     es:[edi].DIBENGINEHDR.deFlags,bx

        ; Decide whether to put the bitmap in video memory.
        ; Block if hardware is busy, a DOS box is open, or the
        ; bitmap is to small to make it worthwhile.
        mov	eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        test    ds:[eax].GNBOARDCX.dwOffscreenFlags,NO_OFFS_BMPS
        jnz     regbmp
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     regbmp
        cmp     es:[edi].DIBENGINEHDR.deHeight,1
        je	regbmp
        cmp     es:[edi].DIBENGINEHDR.deWidth,10H
        jg	@F
        cmp     es:[edi].DIBENGINEHDR.deHeight,10H
        jle	regbmp
        cmp     es:[edi].DIBENGINEHDR.deBitsPixel,08H
        je      @F
        cmp     es:[edi].DIBENGINEHDR.deBitsPixel,10H
        je	@F
        cmp     es:[edi].DIBENGINEHDR.deBitsPixel,20H
        jne	regbmp
@@:
     	push	eax
        call    GN_OffscreenBitmapCreate
        or      eax,eax
        jne     GN_RealizeObjectExtSuccess

regbmp:
        and     es:[edi].DIBENGINE.deFlags,NOT (VRAM OR OFFSCREEN)
        movzx   eax,es:[edi].DIBENGINE.deWidthBytes
        add     eax,3
        and     al,NOT 3
        mov     es:[edi].DIBENGINE.deDeltaScan,eax
        mov     eax,SIZE DEVBMP
        mov     cx,word ptr lpOut+2
        mov     dword ptr es:[edi].DIBENGINE.deBits,eax
        mov      word ptr es:[edi].DIBENGINE.deBits+4,cx
        sub     eax,eax
        mov     es:[edi].DIBENGINE.deBeginAccess,eax
        mov     es:[edi].DIBENGINE.deEndAccess,eax
        jmp     GN_RealizeObjectExtSuccess

GN_RealizeObjectExtBitmap       ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtDeleteBitmap
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the action is to delete a bitmap.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      eax     1
;               edx     0
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtDeleteBitmap
GN_RealizeObjectExtDeleteBitmap PROC    NEAR

        ; If it is only a sizing call, then pass it on. This case shouldn't
        ; happen, but it appears that GDI sometimes passes this case to us.
        cmp     lpOut,0
        je      GN_RealizeObjectExtPunt

	; Load up the DIBENGINEHDR for the bitmap we are deleting
        sub     edi,edi
        les     di,lpOut

        movzx   eax,es:[edi].DIBENGINE.deFlags
        test    eax,VRAM
        jz      GN_RealizeObjectExtSuccess

	; Load up our context
	sub	eax,eax
        mov	ax,cs:[wFlatDataSel]

        ; Is this even a valid selector?
        lar     edx,eax
        jnz     GN_RealizeObjectExtSuccess

        ; The selector must be PRESENT, RING3, DATA
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     GN_RealizeObjectExtSuccess

	mov	ds,ax
        mov	esi,cs:[CSpGNLogicalDevice]

	push	ds:[esi].GNLOGDEVCX.pGNBoardCX
	pushd	0
        call    GN_OffscreenBitmapDelete
        jmp     GN_RealizeObjectExtSuccess

GN_RealizeObjectExtDeleteBitmap ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtFont
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the action is to realize a font.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      Nothing
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtFont
GN_RealizeObjectExtFont         PROC    NEAR

        xor     eax,eax
        cmp     cs:[dwFontInited], eax
        jne     GN_RealizeObjectExtDone
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT32]
        inc     eax
        mov     ds:[dwFontInited], eax
        dec     eax
        jmp     GN_RealizeObjectExtDone

GN_RealizeObjectExtFont         ENDP


;==============================================================================
;
; Function:     GN_InitFunctionPtr
;
; Purpose:      This function returns the function ptr inside the 
;               windows module
;
; Arguments:    eax     ptr to the name of the windows module
;               esi     ORDINAL no of the function
;
; Returns:      eax     16:16 ptr to the requested function
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_InitFunctionPtr, PASCAL, NOFRAME, NEAR
OPENPROC
        push    eax
        call    GetModuleHandle
        and     eax, 0ffffh
        jz      Done
        push    ax
        push    esi
        call    GetProcAddress
        shl     edx, 10H
        mov     dx, ax
        mov     eax, edx
Done:
CLOSEPROC


USER_GETDC_ORDINAL              EQU     66
USER_RELEASEDC_ORDINAL          EQU     68
GDI_CREATEFONTINDIRECT_ORDINAL  EQU     57
GDI_SELECTOBJECT_ORDINAL        EQU     45
GDI_DELETEOBJECT_ORDINAL        EQU     69
GDI_EXTTEXTOUT_ORDINAL          EQU     351


;==============================================================================
;
; Function:     GN_LoadAndInitFonts
;
; Purpose:      This function realizes many common fonts at once
;
; Arguments:    none
;
; Returns:      eax
;
; Preserve:     ds,es,esi,edi,esp
;==============================================================================
DECPROC GN_LoadAndInitFonts, PASCAL, FRAME, NEAR
LOCALV  rcClip,RECT
LOCALW  hDC
OPENPROC
        PUSHR   ds,es,esi,edi,esp
        mov     ax,_DATA
        mov     es,ax
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT32]
        mov     eax,0ffffffffh
        mov     ds:[dwFontInited], eax
        mov     eax,_DATA
        shl     eax,10H
        mov     ax,OFFSET szUserModuleName
        push    eax
        mov     esi, USER_GETDC_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnUserGetDC],eax
        pop     eax
        push    eax
        mov     esi, USER_RELEASEDC_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnUserReleaseDC],eax
        pop     eax

        mov     ax,OFFSET szGDIModuleName
        push    eax
        mov     esi, GDI_CREATEFONTINDIRECT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDICreateFontIndirect],eax
        pop     eax
        push    eax
        mov     esi, GDI_SELECTOBJECT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDISelectObject],eax
        pop     eax
        push    eax
        mov     esi, GDI_DELETEOBJECT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDIDeleteObject],eax
        pop     eax
        push    eax
        mov     esi, GDI_EXTTEXTOUT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDIExtTextOut],eax
        xor     eax, eax
        push    ax
        call    FFP16 PTR ds:[lpfnUserGetDC]
        test    ax,ax
        jz      InitDone
        mov     hDC, ax
        xor     eax,eax
        mov     dword ptr rcClip.RECT.left, eax
        mov     dword ptr rcClip.RECT.right, eax
        mov     ax,_DATA
        mov     ds,ax
        mov     si,ax
        shl     esi,10H
        mov     si,OFFSET lfArray
        mov     edi, esi
        mov     di,OFFSET szAllChars

InitNextFont:
        cmp     [si].LogFont.lfHeight,-10000
        je      DoReleaseDC
        push    esi
        call    FFP16 PTR cs:[lpfnGDICreateFontIndirect]
        test    ax, ax
        jz      DoReleaseDC
        push    ax                                  ; for delete object later

        push    hDC
        push    ax
        call    FFP16 PTR cs:[lpfnGDISelectObject]
        push    hDC                                 ; for select oldfont later
        push    ax

        ; ExtTextOut (hDC, X, Y, fuOptions, lpClipRect, lpString, wCount, lpDX)
        push    hDC
        xor     ebx,ebx
        push    ebx
        mov     eax, 4
        push    ax                                  ; fuOptions=ETO_CLIPPED
        mov     ax,ss
        shl     eax,10H
        lea     ax, rcClip
        push    eax                                 ; lpClip
        push    edi                                 ; szAllChars
        mov     eax, 256
        push    ax
        push    ebx                                 ; lpDX=NULL
        call    FFP16 PTR cs:[lpfnGDIExtTextOut]

        call    FFP16 PTR cs:[lpfnGDISelectObject]  ; select oldfont
        call    FFP16 PTR cs:[lpfnGDIDeleteObject]  ; remove new hfont on stack
        add     si,SIZE LogFont
        jmp     InitNextFont


DoReleaseDC:
        xor     eax, eax
        push    ax
        push    hDC
        call    FFP16 PTR cs:[lpfnUserReleaseDC]

InitDone:
        pop     eax
Done:

        POPR    ds,es,esi,edi,esp
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSDIB.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnsdib.asm
;
; Purpose:      This file holds the StretchDIBits display driver entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_StretchDIBits
;
; Purpose:      This function is the StretchDIBits display driver entry point.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_StretchDIBits, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwBmpRight
LOCALD  dwBmpBottom
LOCALD  dwDibLeft
LOCALD  dwDibTop
LOCALD  dwDibRight
LOCALD  dwDibBottom
LOCALD  dwDibBitsOffset
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwDibPitch
LOCALD  dwDibWidth
LOCALD  dwDibHeight
LOCALD  dwDstBitsPixel
LOCALD  lpPhysColor
LOCALD  dwPhysColor
LOCALD  dwScaleX
LOCALD  dwScaleY
LOCALD  dwDstExtX
LOCALD  dwDstExtY
LOCALD  dwStretchFlag
OPENPROC
        PUSHR   ds,esi,edi

        ; Load up the DstDev and the DIB Header for dispatching
        sub     eax,eax
        cmp     ax,fGet
        jne     GN_StrDibPunt

        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpDIBInfo
        les     si,lpDstDev

        ; We only do RGB DIBs (No Compression)
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_RGB
        je      @F
        
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     GN_StrDibPunt

@@:
        ; If the bitmap is not in VRAM, then punt it.
        cmp     ax,es:[esi].DIBENGINE.deType
        je      GN_StrDibPunt
        test    es:[esi].DIBENGINE.deFlags,VRAM
        jz      GN_StrDibPunt

        ; Make sure the device is not busy.
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_StrDibPunt

        movsx   eax,wSrcExtX

        ; Punt the negative width (Left-Right mirror Arabic Windows)
        or      eax,eax
        js      GN_StrDibPunt

        movsx   ebx,wDstExtX
        movsx   ecx,wSrcExtY
        movsx   edx,wDstExtY

        cmp     eax,ebx
        mov     eax,1
        jne     @F
        cmp     ecx,edx
        jne     @F
        sub     eax,eax

@@:
        mov     dwStretchFlag,eax

        ; Punt the negative heights
        or      ecx,edx
        js      GN_StrDibPunt

        ; Punt stretched case for the mono dib
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,ax
        je      GN_StrDibPunt

IF DIB_PROCESS_SINGLESCAN
        ; Special case the 8bpp DIBS that are 1 scanline high,
        ; where wSrcExtY = wDstExtY = 1
        cmp     dwStretchFlag,0
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,8
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biHeight,1
        jne     @F
        cmp     ecx,1
        jne     @F

        cmp     byte ptr dwRop3+2,0CCH
        jne     @F
        call    GN_StretchDIBitsSingleScan
        or      eax,eax
        jne     GN_StrDibExit
@@:
ENDIF

IF      (DIB_8BPP_ACCEL NE 0)
        ; If the dst is 8bpp and Rop not srccopy or src is mono, then punt it.
        cmp     es:[esi].DIBENGINE.deBitsPixel,8
        jne     @F
        cmp     byte ptr dwRop3+2,0CCH
        jne     GN_StrDib8BppPunt
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        je      GN_StrDib8BppPunt
@@:
ELSE
        ; If the dst is 8bpp, but not SingleScan case, then punt it.
        cmp     es:[esi].DIBENGINE.deBitsPixel,8
        je      GN_StrDib8BppPunt
ENDIF

        ; First, clip the DIB
        call    GN_StretchDIBitsClip
        or      eax,eax
        je      GN_StrDibExit

        ; If the rop involves a pattern, prepare the pattern now
        movzx   eax,byte ptr [dwRop3 + 2]
        movzx   ecx,byte ptr cs:Rop3Table[eax]
        cmp     ecx,PAD
        je      PrepBrush
        cmp     ecx,PSD
        je      PrepBrush

BackIn:
        ; Break the call out into cases.
        movzx   esi,word ptr lpDstDev+0
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        jne     GN_StretchColorDib
        jmp     GN_StretchMonoDib

PrepBrush:
        mov     es,word ptr lpBrush+2
        movzx   esi,word ptr lpBrush+0
        push    lpDrawMode
        mov     ebx,cs:[CSpGNLogicalDevice]
        call    GN_PrepareBrush
        or      eax,eax
        je      GN_StrDibExit
        mov     eax,0
        jl      GN_StrDibExit

        ; reload some stuff that got trashed
        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpDIBInfo
        les     si,lpDstDev
        jmp     BackIn

GENERIC_StretchDIBits   ENDP


;==============================================================================
;
; Function:     StretchDIBits ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of StretchDIBits. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_StrDibPunt
GN_StrDibPunt     PROC    NEAR

        push    lpDstDev
        push    fGet
        push    wDstX
        push    wDstY
        push    wDstExtX
        push    wDstExtY
        push    wSrcX
        push    wSrcY
        push    wSrcExtX
        push    wSrcExtY
        push    lpDIBBits
        push    lpDIBInfo
        push    lpTranslate
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
PLABEL  Punt_StrDib
        call    DIB_StretchDIBits
        .errnz  $ - OFFSET GN_StrDibExit

GN_StrDibPunt     ENDP

PUBLIC  GN_StrDibExit
GN_StrDibExit   PROC    NEAR

        POPR    ds,esi,edi
        mov     sp,bp
        mov     ecx,ss:[ebp + 4]
        pop     ebp
IF DIB_FAST_EXIT
        cmp     ax,-1
        je      @F
        cmp     cs:[bUseStretchDIBitsFastExit],0
        je      @F
        cmp     ecx,cs:[lpfnGdiCode03_20B7]
        jne     @F
        mov     ss:[bp - 02H],ax
        test    byte ptr ss:[di + 02H],40H
        jz      @F
        add     sp,4 + 32H
        jmp     GdiCode03_217C
@@:
ENDIF
        ; Clean and return normally
        RETFAR16 32H
GN_StrDibExit   ENDP


;==============================================================================
;
; Function:     GN_StrDib8BppPunt (StretchDIBits ending routine)
;
; Purpose:      This function is a work-around for a bug in the
;               DIBEngine DIB compiler.  At 8bpp, if the destination
;               bitmap is not word aligned (i.e. (wDestX & 1) == 1)
;               AND the clip rect is one (1) pixel wide AND the clip
;               rect is misaligned by 3 (i.e. (wClipLeft & 3) == 3),
;               AND the stretch is 1:1, then the DIB compiler will
;               fail to compile the code to do the pixel copy
;               (tested in the 16bpp source case) but will compile
;               the epilogue code incrementing the source and dest
;               pointers furiously.
;               The result of this is somewhat unsatisfying.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
;==============================================================================
DECPROC GN_StrDib8BppPunt, PASCAL, NOFRAME, NEAR
OPENPROC
        test    wDstX,1                 ; Check for unaligned destination
        jz      GN_StrDibPunt
        mov     ax,wDstExtX             ; Check for 1:1 stretch
        mov     bx,wDstExtY
        cmp     ax,wSrcExtX
        jne     GN_StrDibPunt
        cmp     bx,wSrcExtY
        jne     GN_StrDibPunt
        xor     esi,esi
        cmp     word ptr [lpClipRect + 2],si   ; Check for clip rect
        je      GN_StrDibPunt
        lfs     si,lpClipRect

        movzx   eax,fs:[esi].RECT.left
        inc     eax
        cmp     ax,fs:[esi].RECT.right  ; Check if 1 pixel wide
        jne     GN_StrDibPunt
        and     eax,3                   ; Check for (clipleft mod 4) == 3
        jnz     GN_StrDibPunt

        ; Clean and return a failure normally
        POPR    ds,esi,edi
        mov     sp,bp
        mov     eax,-1
        pop     ebp
        RETFAR16 32H
ENDPROC


;==============================================================================
;
; Function:     GN_StretchMonoDib
;
; Purpose:      This function is jumped to from the StretchDIBits
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               ds      Context Selector
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               es:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the StretchDIBits ending routines.
;
;==============================================================================
DECPROC GN_StretchMonoDib, PASCAL, NOFRAME, NEAR
OPENPROC
        ; We can handle this as a mono transfer
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr es:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[esi].DIBENGINE.deBits
        movzx   eax,es:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        push    eax
        push    dwDibBitsOffset
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY

        ; The bg and fg colors come from the color table at end of DIB
        lea     esi,dwPhysColor
        ror     esi,10H
        mov     si,ss
        ror     esi,10H
        mov     lpPhysColor,esi

        mov     esi,dword ptr fs:[edi].BitmapInfo.bmiColors[0]
        cmp     fs:[edi].BitmapInfoHeader.biClrUsed,1
        je      @F
        mov     edi,dword ptr fs:[edi].BitmapInfo.bmiColors[4]
        push    lpDstDev
        bswap   edi
        ror     edi,8
        push    edi
        push    lpPhysColor
        call    GENERIC_ColorInfo
        mov     edi,dwPhysColor
@@:
        push    lpDstDev
        bswap   esi
        ror     esi,8
        push    esi
        push    lpPhysColor
        call    GENERIC_ColorInfo

        ; push two translated colors
        push    dwPhysColor
        push    edi

        mov     edx,07FFFH
        sub     ebx,ebx
        push    dwRop3                          ; Rop3
        push    lpBrush                         ; lpBrush
        push    lpDrawMode                      ; lpDrawmode
        push    edx                             ; scans left in start seg
        push    edx                             ; scans per seg
        push    ebx                             ; fill bytes

        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        je      GN_StrDibPunt
        mov     eax,dwDstExtY
        jmp     GN_StrDibExit
ENDPROC


;==============================================================================
;
; Function:     GN_StretchColorDib
;
; Purpose:      This function is jumped to from the StretchDIBits
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               ds      Context Selector
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               es:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the StretchDIBits ending routines.
;
;==============================================================================
DECPROC GN_StretchColorDib, PASCAL, NOFRAME, NEAR
OPENPROC
        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   ecx,fs:[edi].BitmapInfoHeader.biBitCount
        cmp     ecx,10H
        jne     @F
        mov     ecx,0FH
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_StrDibPunt
        inc     ecx
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_StrDibPunt
@@:
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr es:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[esi].DIBENGINE.deBits
        movzx   eax,es:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        push    eax
        push    dwDibBitsOffset
        push    ecx
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY

        push    dwRop3
        push    lpBrush                         ; lpBrush
        push    lpDrawMode                      ; lpDrawMode
        pushd   4                               ; dwSizeColorTableEntry

        ; If the src is > 8bpp, then there is no color table.
        ; If there is a color table, compute the number of entries.
        sub     eax,eax
        sub     ebx,ebx
        cmp     cl,8
        jbe     IsColorTable
        cmp     es:[esi].DIBENGINEHDR.bRealBpp,8
        jne     @F
        mov     ebx,lpTranslate
        jmp     @F

IsColorTable:
        mov     ebx,lpDIBInfo
        add     bx,word ptr fs:[edi].BitmapInfoHeader.biSize
        mov     edx,fs:[edi].BitmapInfoHeader.biClrUsed
        mov     eax,1
        shl     eax,cl
        or      edx,edx
        je      @F
        cmp     eax,edx
        jc      @F
        mov     eax,edx
@@:
        push    eax                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        sub     eax,eax
        push    eax

        ; Final check for the stretch case
        cmp     dwStretchFlag,0
        jne     StretchCase
        call    HW_BitBltSrcColorDstVram
        jmp     RetFromClrBlt

StretchCase:
        push    dwDstExtX
        push    dwDstExtY
        push    lpClipRect
        call    GN_StretchBltSrcColorDstVram

RetFromClrBlt:
        or      eax,eax
        je      GN_StrDibPunt
        mov     eax,dwDstExtY
        jmp     GN_StrDibExit

GN_StretchColorDib      ENDP


;==============================================================================
;
; Function:     GN_StretchDIBitsClip
;
; Purpose:      This function clips the DIB and Bitmap for StretchDIBits.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     fs,edi,es
;==============================================================================
PUBLIC  GN_StretchDIBitsClip
GN_StretchDIBitsClip    PROC    NEAR

        ; Get the width and height of the DIB and compute the signed pitch.
        mov     ecx,fs:[edi].BitmapInfoHeader.biHeight
        mov     edx,fs:[edi].BitmapInfoHeader.biWidth
        movzx   eax,fs:[edi].BitmapInfoHeader.biBitCount
        imul    eax,edx
        add     eax,1FH
        shr     eax,3
        and     eax,NOT 3
        neg     ecx
        jns     @F
        neg     ecx
        neg     eax
@@:     mov     dwDibWidth,edx
        mov     dwDibHeight,ecx

        movsx   edx,wSrcY
        movsx   ecx,wSrcExtY
        movsx   esi,wDstY
        movsx   ebx,wDstExtY

        or      ecx,ecx
        jns     @F
        add     edx,ecx
        neg     eax
        neg     ecx
@@:
        or      ebx,ebx
        jns     @F
        add     esi,ebx
        neg     eax
        neg     ebx
@@:
        mov     dwDibPitch,eax
        mov     dwExtY,ecx
        mov     dwDstExtY,ebx
        mov     dwDibTop,edx
        mov     dwBmpTop,esi

        ; Compute the unclipped DIB bounding rectangle
        mov     esi,dwDibHeight
        movsx   eax,wSrcX
        mov     edx,dwExtY
        mov     ebx,dwDibTop
        movsx   ecx,wSrcExtX
        add     ecx,eax
        sub     esi,ebx
        mov     dwDibRight,ecx
        mov     dwDibBottom,esi
        mov     dwDibLeft,eax
        sub     esi,edx
        mov     dwDibTop,esi

        ; Compute the unclipped Bitmap bounding rectangle
        movsx   eax,wDstX
        mov     ebx,dwBmpTop
        mov     dwBmpLeft,eax
        movsx   ecx,wDstExtX
        mov     edx,dwDstExtY
        add     eax,ecx
        add     ebx,edx
        mov     dwBmpRight,eax
        mov     dwBmpBottom,ebx

        ; Calculate the scaling factor
        sub     eax,eax
        shrd    eax,ecx,12
        mov     ecx,edx
        movsx   ebx,wSrcExtX
        sub     edx,edx
        idiv    ebx
        mov     dwScaleX,eax
        sub     eax,eax
        shrd    eax,ecx,12
        mov     ebx,dwExtY
        sub     edx,edx
        idiv    ebx
        mov     dwScaleY,eax

        ; Do the source clipping on the left and top of the DIB and bitmap
        mov     eax,dwDibLeft
        mov     ebx,dwDibTop
        or      eax,eax
        jns     @F
        sub     dwDibLeft,eax
        neg     eax
        imul    eax,dwScaleX
        shr     eax,20
        add     dwBmpLeft,eax
@@:     or      ebx,ebx
        jns     @F
        sub     dwDibTop,ebx
        neg     ebx
        imul    ebx,dwScaleY
        shr     ebx,20
        add     dwBmpTop,ebx
@@:
        ; Do source clipping on the right and bottom of the DIB and bitmap
        mov     eax,dwDibBottom
        sub     eax,dwDibHeight
        jle     @F
        sub     dwDibBottom,eax
        imul    eax,dwScaleY
        shr     eax,20
        sub     dwBmpBottom,eax
@@:     mov     eax,dwDibRight
        sub     eax,dwDibWidth
        jle     @F
        sub     dwDibRight,eax
        imul    eax,dwScaleX
        shr     eax,20
        sub     dwBmpRight,eax

@@:
        ; Dst clipping uses the clip rectangle
        sub     esi,esi
        lgs     si,lpClipRect

        ; Clip the dst left and top edges
        mov     eax,dwBmpLeft
        movsx   edx,gs:[esi].RECT.left
        sub     eax,edx
        jge     @F
        neg     eax
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleX
        add     dwDibLeft,eax
        imul    eax,dwScaleX
        shr     eax,20
        add     dwBmpLeft,eax
@@:
        mov     eax,dwBmpTop
        movsx   edx,gs:[esi].RECT.top
        sub     eax,edx
        jge     @F
        neg     eax
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleY
        add     dwDibTop,eax
        imul    eax,dwScaleY
        shr     eax,20
        add     dwBmpTop,eax
@@:

        ; Clip the dst right and bottom edges
        mov     eax,dwBmpRight
        movsx   edx,gs:[esi].RECT.right
        sub     eax,edx
        jle     @F
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleX
        sub     dwDibRight,eax
        imul    eax,dwScaleX
        shr     eax,20
        sub     dwBmpRight,eax
@@:
        mov     eax,dwBmpBottom
        movsx   edx,gs:[esi].RECT.bottom
        sub     eax,edx
        jle     @F
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleY
        sub     dwDibBottom,eax
        imul    eax,dwScaleY
        shr     eax,20
        sub     dwBmpBottom,eax
@@:

DoneClip:
        ; It's all clipped -- now compute the extents
        mov     eax,dwDibRight
        mov     ebx,dwDibBottom
        sub     eax,dwDibLeft
        jle     NothingVisible
        sub     ebx,dwDibTop
        jle     NothingVisible
        mov     dwExtX,eax
        mov     dwExtY,ebx

        mov     eax,dwBmpRight
        mov     ebx,dwBmpBottom
        sub     eax,dwBmpLeft
        jle     NothingVisible
        sub     ebx,dwBmpTop
        jle     NothingVisible
        mov     dwDstExtX,eax
        mov     dwDstExtY,ebx

        ; The bits ptr is normal if the DIB is right side up
        mov     ecx,dwDibPitch
        movzx   ebx,word ptr lpDIBBits
        or      ecx,ecx
        jg      @F
        mov     edx,dwDibHeight
        neg     ecx
        dec     edx
        imul    ecx,edx
        add     ebx,ecx
@@:
        mov     dwDibBitsOffset,ebx
        mov     eax,1
        ret

NothingVisible:
        sub     eax,eax
        ret

GN_StretchDIBitsClip    ENDP


IF DIB_PROCESS_SINGLESCAN
;==============================================================================
;
; Function:     GN_StretchDIBitsSingleScan
;
; Purpose:      This routine is jumped to from GENERIC_StretchDIBits.
;               when the generic code has determined that the call
;               matches this special case: the DIB is 8bpp, 1 scanline
;               high, wSrcExtY = wDstExtY = 1, the rop is 0CCH.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               es:esi  lpDstDev
;
; Returns:      eax     > 0     Success!
;                       0       this routine wants the normal code
;                               to handle the call.
;
; Preserve:     If you return success, you do not need to preserve
;               anything. If you return that you want the normal
;               code to handle the call, then preserve es,esi,fs,edi.
;==============================================================================
DECPROC GN_StretchDIBitsSingleScan, PASCAL, NOFRAME, NEAR
OPENPROC
        movzx   eax,es:[esi].DIBENGINE.deBitsPixel
        mov     dwDstBitsPixel,eax

        sub     ebx,ebx
        lgs     bx,lpClipRect

        ; Clip the YCoord
        movzx   edx,wDstExtY
        movzx   esi,wSrcY
        movzx   eax,wDstY
        mov     ecx,eax
        sub     ax,gs:[ebx].RECT.top
        jge     @F
        movsx   eax,ax
        add     edx,eax
        sub     ecx,eax
@@:
        mov     eax,ecx
        add     eax,edx
        sub     ax,gs:[ebx].RECT.bottom
        jle     @F
        sub     edx,eax
        add     esi,eax
@@:
        ; The ClippedSrcY must be 0 or we can't special case
        or      esi,esi
        jne     Fallback

        ; The ClippedExtY must be 1 or we can't special case
        cmp     edx,1
        jne     Fallback

        ; We can special case it! NOTE: ecx = clipped starting dst y
        mov     dwBmpTop,ecx

        ; We need to compute the clipped DstX, clipped SrcX,
        ; and clipped ExtX
        movzx   ecx,wDstExtX
        movzx   esi,wSrcX
        movsx   eax,wDstX
        or      eax,eax
        jge     @F
        sub     esi,eax
        add     ecx,eax
        sub     eax,eax
@@:
        mov     edx,eax
        sub     ax,gs:[ebx].RECT.left
        jge     @F
        movsx   eax,ax
        add     ecx,eax
        sub     edx,eax
        sub     esi,eax
@@:
        lea     eax,[edx][ecx]
        sub     ax,gs:[ebx].RECT.right
        jle     @F
        sub     ecx,eax
@@:
        ; At this point:
        ; edx = clipped DstX
        ; ecx = clipped ExtX
        ; esi = clipped SrcX

        ; Get edx = DstY * DeltaScan + deBitsOffset
        mov     eax,edx
        movzx   ebx,word ptr lpDstDev
        mov     edx,dwBmpTop
        imul    edx,es:[ebx].DIBENGINE.deDeltaScan
        add     edx,es:[ebx].DIBENGINEHDR.deBitsOffset
        mov     gs,es:[ebx].DIBENGINEHDR.deBitsSelector

        ; Load up ptr to src
        sub     ebx,ebx
        les     bx,lpDIBBits
        add     ebx,esi
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Point to color table
        add     edi,fs:[edi].BitmapInfoHeader.biSize

        ; Sync with the hardware
        mov     esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess

        ; Dispatch to correct color depth routine
        cmp     dwDstBitsPixel,10H
        ja      GN_DibSingleScan_Bpp32
        je      GN_DibSingleScan_Bpp16

        ; if not NULL, need to use lpTranslate
        cmp     lpTranslate,0
        je      GN_DibSingleScan_Bpp8
        sub     edi,edi
        lfs     di,lpTranslate
        jmp     GN_DibSingleScan_Bpp8

Fallback:
        movzx   esi,word ptr lpDstDev
        sub     eax,eax
CLOSEPROC
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNPIXEL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnpixel.asm
;
; Purpose:      This file holds the Pixel display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_Pixel
;
; Purpose:      This function is the Pixel display driver entry point.
;
; Arguments:    Pixel Display driver stack FRAME
;
; Returns:      If lpDrawMode is NULL then
;                       pixel value at coords wDstX,wDstY if succeesful
;                       80000000H is failure
;               If lpDrawMode is NOT NULL then
;                       00000001H is succeesful
;                       80000000H is failure
;
;==============================================================================
DECPROC GENERIC_Pixel, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   dwPhysColor
PARMD   lpDrawMode
LOCALV  sPixel,DIB_Brush8
OPENPROC
        PUSHR   ds,esi,edi
        sub     esi,esi
        lgs     si,lpDstDev

        ; Punt old style bitmaps, Selected Dibs, and Mono Bitmaps
        movzx   eax,gs:[esi].DIBENGINE.deType
        movzx   ecx,gs:[esi].DIBENGINE.deFlags
        movzx   edx,gs:[esi].DIBENGINE.deBitsPixel
        mov     ebx,lpDrawMode
        or      eax,eax
        je      GN_PixelPunt
        test    ecx,SELECTEDDIB
        jnz     GN_PixelPunt
        cmp     edx,1
        je      GN_PixelPunt

        ; Switch on Get or Set
        or      ebx,ebx
        je      GN_GetPixel
        jmp     GN_SetPixel

GENERIC_Pixel   ENDP


;==============================================================================
;
; Functions:    Pixel ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of Pixel. You can either return a success code, a failure
;               code, punt to the DIBENG, etc.
;
; Arguments:    Pixel Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_PixelPunt
GN_PixelPunt       PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_Pixel
        jmp     DIB_Pixel
GN_PixelPunt       ENDP

PUBLIC  GN_PixelDone
GN_PixelDone      PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 10H
GN_PixelDone      ENDP


;==============================================================================
;
; Function:     GN_SetPixel
;
; Purpose:      This function jumped to by the Pixel display driver entry
;               point when it is known the operation is to set a pixel.
;
; Arguments:    Display driver Pixel stack FRAME
;               gs:esi  lpDstDev
;               ecx     lpDstDev->deFlags
;
; Returns:      00000001H is succeesful
;               80000000H is failure
;
;==============================================================================
PUBLIC  GN_SetPixel
GN_SetPixel     PROC    NEAR

        ; We won't do a set into a non-VRAM bitmap since we don't want to
        ; have to handle all the different rops
        test    ch,VRAM / 256
        jz      GN_PixelPunt

        ; Check the screen for busy
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]
        cmp     ds:[edi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_PixelPunt

        ; Use the hardware specific rect functions to do this
        sub     edx,edx
        lfs     dx,lpDrawMode
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        movzx   ecx,fs:[edx].DRAWMODE.Rop2
        mov     eax,dword ptr wDstY
        mov	ebx,10001H
        mov     edx,dwPhysColor
        call    HW_SolidColorRectangle
        jmp     GN_PixelDone

GN_SetPixel     ENDP


;==============================================================================
;
; Function:     GN_GetPixel
;
; Purpose:      This function jumped to by the Pixel display driver entry
;               point when it is known the operation is to get a pixel.
;
; Arguments:    Display driver Pixel stack FRAME
;               gs:esi  lpDstDev
;               ecx     lpDstDev->deFlags
;
; Returns:      00000001H is succeesful
;               80000000H is failure
;
;==============================================================================
PUBLIC  GN_GetPixel
GN_GetPixel     PROC    NEAR
        ; If the pixel is in video memory, we must wait for idle
        test    ch,VRAM / 256
        jz      @F

        ; Check the screen for busy
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_PixelPunt
        push    cs:[CSlp16LogDevice]
        push    ebx
        push    ebx
        pushw   FB_ACCESS
        call    FFP16 PTR gs:[esi].DIBENGINE.deBeginAccess
@@:
        ; Compute the address of the pixel to get
        movzx   edx,wDstX
        movzx   ecx,gs:[esi].DIBENGINE.deBitsPixel
        movzx   eax,wDstY
        imul    edx,ecx
        imul    eax,gs:[esi].DIBENGINE.deDeltaScan
        shr     edx,3
        les     edi,fword ptr gs:[esi].DIBENGINE.deBits
        add     edx,eax
        add     edi,edx

        ; Fetch the pixel based upon the size
        mov     edx,0FF00H
        movzx   eax,byte ptr es:[edi]
        cmp     ecx,16
        jc      @F
        movzx   eax,word ptr es:[edi]
        jbe     @F
        mov     dx,word ptr es:[edi+2]
@@:
        ; If the pixel was in vram, call the end access function
        test    gs:[esi].DIBENGINE.deFlags,VRAM OR OFFSCREEN
        jz      GN_PixelDone
        push    cs:[CSlp16LogDevice]
        pushw   FB_ACCESS
        call    FFP16 PTR gs:[esi].DIBENGINE.deEndAccess
        jmp     GN_PixelDone

GN_GetPixel     ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNRECT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnrect.asm
;
; Purpose:      This file holds the Output(OS_RECTANGLE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is and OS_RECTANGLE style.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_Rectangle
;
; Purpose:      This function is the Output(OS_RECTANGLE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is the OS_RECTANGLE style.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Rectangle, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD	dwDrawInterior
LOCALD  dwPenColor
LOCALD  dwRop2
LOCALD  pHWLogDevCXOffset
LOCALD	dwBottomRight
LOCALD	dwTopLeft
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the dst bitmap
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; Load the Context Selector
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]

        ; Load dst flags and prep some registers
        sub     ebx,ebx
        movzx   eax,gs:[esi].DIBENGINE.deFlags

        ; Filter out old style destinations
        cmp     bx,gs:[esi].DIBENGINE.deType
        je      GN_RectanglePunt

        ; Filter out based upon deFlags
        test    ah,VRAM / 256
        jz      GN_RectanglePunt
        test    ah,PALETTE_XLAT / 256
        jnz     GN_RectanglePunt

        ; Watch for busy hardware -- some other API owns the screen
        cmp     ds:[edi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_RectanglePunt

        ; If both the pen and brush are null, then we are done!
        ; The only way the two ptrs can be equal is if they are
        ; both NULL!
        mov     eax,lpBrush
        cmp     eax,lpPen
        je      RectangleSuccess

	; Get ready to use points
	sub	esi,esi
        les     si,lpPoints
        mov    	eax,dword ptr es:[esi].RECT.left
        mov    	ebx,dword ptr es:[esi].RECT.right

	; If either the left or top has negative coordinates, then
	; we punt. Handling the interior drawing is not too bad even
	; with signed coordinates, but the border drawing is ugly.
	; Negative coordinates happen VERY rarely.
	test	eax,80008000H
	jnz	GN_RectanglePunt

	; Sometimes we get left > right or top > bottom
        cmp     ax,bx
        jge	GN_RectanglePunt
        cmp     eax,ebx
        jge	GN_RectanglePunt

	mov	dwTopLeft,eax
	mov	dwBottomRight,ebx

        ; Load up the drawmode ptr
        sub     ecx,ecx
        lfs     cx,lpDrawMode

	; Save off the hwlogdev for later
        mov     edx,ds:[edi].GNLOGDEVCX.pHWLogdevCX
	mov     pHWLogDevCXOffset,edx

        ; Get the rop
        movzx   edx,fs:[ecx].DRAWMODE.Rop2
        sub     ecx,ecx
        mov     dwRop2,edx

        ; Get the PenColor if the pen is not null
        cmp     ecx,lpPen
        je      RestP
        les     cx,lpPen
        cmp     es:[ecx].DIB_Pen.dpPenStyle,LS_SOLID
        je     	@F
        mov	lpPen,0
@@:     mov     ecx,es:[ecx].DIB_Pen.dpPenColor
RestP:  mov     dwPenColor,ecx

	; Is there a brush?
	mov	dwDrawInterior,1
	cmp	lpBrush,0
	je	UsePen

UseBrush:
        ; If the brush is hollow, then even if the rop only involves
        ; the dst (like BLACKNESS, WHITENESS, or INVERTDST), we blow
        ; off filling the interior of the rectangle. This sounds
        ; wierd but it is WHQL-correct behavior.
        sub	esi,esi
	les	si,lpBrush
	cmp	es:[esi].DIB_Brush8.dp8BrushStyle,BS_HOLLOW
	je	NoInterior

	; It is not a hollow brush. If the rop only involves the
	; dst (no pattern involvement), then skip the pattern load.
	dec	edx
        je	RetSetPat
        cmp     edx,05H
        je	RetSetPat
        cmp     edx,0AH
        je	RetSetPat
        cmp     edx,0FH
        je	RetSetPat

	; Load up the pattern
        mov     cl,byte ptr es:[esi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[esi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[esi].DIB_Brush8.dp8BrushBits
        mov	ebx,pHWLogDevCXOffset
        PUSH	OFFSET RetSetPat
        cmp     cl,BS_HOLLOW
        jnc     @F
        test    al,COLORSOLID
        jz      HW_LoadColorPattern
        jmp     HW_LoadSolidPattern
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      GN_BitBltFail
        test    al,PATTERNMONO
        jz	HW_LoadColorPattern
IsMono:
	sub	edx,edx
	lfs	dx,lpDrawMode
	lea	esi,[esi].DIB_Brush16.dp16BrushMono
	mov	ecx,fs:[edx].DRAWMODE.TextColor
	mov	edx,fs:[edx].DRAWMODE.bkColor
	mov	eax,-1
	jmp	HW_LoadMonoPattern
IsHatch:
	sub	edx,edx
	lfs	dx,lpDrawMode
	cmp	fs:[edx].DRAWMODE.bkMode,TRANSPARENT
	sete	al
	cmp	al,1
	sbb	eax,eax
        mov     ecx,es:[esi].DIB_Brush8.dp8BgColor
        mov     edx,es:[esi].DIB_Brush8.dp8FgColor
	lea	esi,[esi].DIB_Brush16.dp16BrushMask
	jmp	HW_LoadMonoPattern

NoInterior:
	mov	dwDrawInterior,0
	jmp	RetSetPat

UsePen:
        mov	ebx,pHWLogDevCXOffset
	mov	edx,dwPenColor
	call	HW_LoadSolidPattern

RetSetPat:
	; The pattern to draw the interior of the rectangle with
	; has now been loaded. This could have been either the
	; brush or the pen. Now call the HW_DrawRectAndBorder routine.

	sub	esi,esi
	lgs	si,lpDstDev
	push	pHWLogDevCXOffset
	push	gs:[esi].DIBENGINEHDR.deBitsOffset
	push	gs:[esi].DIBENGINEHDR.deDeltaScan
	push	dwRop2

        ; pass in the clip rect as an argument
        sub	ebx,ebx
        mov	ecx,7FFF7FFFH
        cmp     ebx,lpClipRect
        je      @F
        sub	ecx,ecx
        lfs     cx,lpClipRect
        mov     ebx,dword ptr fs:[ecx].RECT.left
        mov     ecx,dword ptr fs:[ecx].RECT.right
@@:     push	ecx
	push	ebx

	; If lpPen is NULL, the border won't be drawn
	; in which case dwPenColor is irrelevant
	push	lpPen
	push	dwPenColor

        mov	ebx,dwBottomRight
        mov	eax,dwTopLeft
	push	ebx
	push	eax

	; Always bring in the bottom and right edge of the interior
	; of the rectangle by 1 pixel. If there is a border, then
	; bring in the left and top by 1 pixel as well.

        cmp     lpPen,0
        je      @F
        add     eax,10001H
@@:     sub     ebx,10001H

	push	dwDrawInterior
	push	ebx
	push	eax
	call	HW_DrawRectAndBorder

RectangleSuccess:
        mov     eax,1
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH

GN_RectanglePunt:
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_Rectangle
        jmp     DIB_Output
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnstrblt.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnstrblt.asm
;
; Purpose:      This file holds the StretchBlt display driver entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_StretchBlt
;
; Purpose:      This function is the StretchBlt display driver entry point.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
; Returns:      ax      1  if successful
;                       0  if not successful
;                       -1 GDI should carry out the operation.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_StretchBlt, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect

LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwBmpRight
LOCALD  dwBmpBottom
LOCALD  dwSrcLeft
LOCALD  dwSrcTop
LOCALD  dwSrcRight
LOCALD  dwSrcBottom
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwSrcWidth
LOCALD  dwSrcHeight
LOCALD  dwScaleX
LOCALD  dwScaleY
LOCALD	dwDstExtX
LOCALD	dwDstExtY
OPENPROC
        PUSHR   ds,esi,edi

        sub     eax,eax

        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpSrcDev
        les     si,lpDstDev

        ; If the dst bitmap is not in VRAM, then punt it.
        cmp     ax,es:[esi].DIBENGINE.deType
        je      GN_StrBltPunt
        test    es:[esi].DIBENGINE.deFlags,VRAM
        jz      GN_StrBltPunt

        ; If the src bitmap is in VRAM, then punt it.
        cmp     ax,fs:[edi].DIBENGINE.deType
        je      GN_StrBltPunt
        test    fs:[edi].DIBENGINE.deFlags,VRAM
        jnz	GN_StrBltPunt

        movsx   eax,wSrcExtX
        movsx   ebx,wDstExtX
        movsx   ecx,wSrcExtY
        movsx   edx,wDstExtY

	; Punt the negative widths (Left-Right mirror Arabic Windows)
	or	eax,ebx
        js	GN_StrBltPunt

	; Punt the negative heights (Top-Bottom mirror)
	or	ecx,edx
        js	GN_StrBltPunt

	; Punt Stretch for mono source
        cmp     fs:[edi].DIBENGINEHDR.bRealBpp,1
	je	GN_StrBltPunt

        ; Make sure the device is not busy.
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_StrBltPunt

        ; First, do clipping
        call    GN_StretchBltClip
        or      eax,eax
	mov	eax,1
        je      GN_StrBltExit

        ; If the rop involves a pattern, prepare the pattern now
        movzx   eax,byte ptr [dwRop3 + 2]
        movzx   ecx,byte ptr cs:Rop3Table[eax]
        cmp     ecx,PAD
        je      PrepBrush
        cmp     ecx,PSD
        je      PrepBrush
        movzx   esi,word ptr lpDstDev+0
        jmp     GN_StretchColorBlt

PrepBrush:
        mov     es,word ptr lpBrush+2
        movzx   esi,word ptr lpBrush+0
        push    lpDrawMode
        mov     ebx,cs:[CSpGNLogicalDevice]
        call    GN_PrepareBrush
        or      eax,eax
        je      GN_StrBltExit
        mov     eax,0
        jl      GN_StrBltExit

        ; reload some stuff that got trashed
        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpSrcDev
        les     si,lpDstDev
        jmp     GN_StretchColorBlt

GENERIC_StretchBlt	ENDP

;==============================================================================
;
; Function:     StretchBlt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of StretchBlt. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_StrBltPunt
GN_StrBltPunt     PROC    NEAR
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	wDstExtX
	push	wDstExtY
	push	lpSrcDev
	push	wSrcX
	push	wSrcY
	push	wSrcExtX
	push	wSrcExtY
	push	dwRop3
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect
PLABEL	Punt_StrBlt
        call    DIB_StretchBlt
        .errnz  $ - OFFSET GN_StrBltExit

GN_StrBltPunt     ENDP

PUBLIC  GN_StrBltExit
GN_StrBltExit   PROC    NEAR

        POPR    ds,esi,edi
        mov     sp,bp
        pop     ebp

        ; Clean and return normally
        RETFAR16 28H
GN_StrBltExit   ENDP


;==============================================================================
;
; Function:     GN_StretchColorBlt
;
; Purpose:      This function is jumped to from the StretchBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;               ds      Context Selector
;               fs:edi  lpSrcDev ptr (ptr to DIBENGINE HDR)
;               es:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the StretchBlt ending routines.
;
;==============================================================================
DECPROC GN_StretchColorBlt, PASCAL, NOFRAME, NEAR
OPENPROC
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr es:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[esi].DIBENGINE.deBits
        movzx   eax,es:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr fs:[edi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr fs:[edi].DIBENGINE.deBits
        movzx   eax,fs:[edi].DIBENGINEHDR.bRealBpp
        push    eax
        push    fs:[edi].DIBENGINE.deDeltaScan
        push    dwSrcLeft
        push    dwSrcTop
        push    dwExtX
        push    dwExtY

        push    dwRop3
        push    lpBrush                         ; lpBrush
        push    lpDrawMode                      ; lpDrawMode

        sub     ebx,ebx
        push	ebx                             ; dwSizeColorTableEntry
        push    ebx                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        push    ebx
	push	dwDstExtX
	push	dwDstExtY
	push	lpClipRect
        call    GN_StretchBltSrcColorDstVram
        or      eax,eax
        je      GN_StrBltPunt
        mov     eax,1
        jmp     GN_StrBltExit

GN_StretchColorBlt      ENDP


;==============================================================================
;
; Function:     GN_StretchBltClip
;
; Purpose:      This function clips the src and dst Bitmaps for StretchBlt.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;               fs:edi  lpSrcDev ptr (ptr to DIBENGINE HDR)
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     fs,edi,es
;==============================================================================
PUBLIC  GN_StretchBltClip
GN_StretchBltClip    PROC    NEAR

        ; Get the width and height of the DIB and compute the signed pitch.
        movsx	edx,fs:[edi].DIBENGINE.deWidth
        movsx	ecx,fs:[edi].DIBENGINE.deHeight
	mov     dwSrcWidth,edx
        mov     dwSrcHeight,ecx

        movsx   edx,wSrcY
        movsx   ecx,wSrcExtY
        movsx   esi,wDstY
	movsx	ebx,wDstExtY

	mov	dwExtY,ecx
	mov	dwDstExtY,ebx
        mov     dwSrcTop,edx
        mov     dwBmpTop,esi

        ; Compute the unclipped src bounding rectangle
        mov     esi,dwSrcHeight
        movsx   eax,wSrcX
        mov	edx,dwExtY
        mov	ebx,dwSrcTop
        movsx   ecx,wSrcExtX
        add     ecx,eax
        sub     esi,ebx
        mov     dwSrcRight,ecx
        mov     dwSrcBottom,esi
        mov     dwSrcLeft,eax
        sub     esi,edx
        mov     dwSrcTop,esi

        ; Compute the unclipped Bitmap bounding rectangle
        movsx	eax,wDstX
        mov     ebx,dwBmpTop
        mov     dwBmpLeft,eax
	movsx	ecx,wDstExtX
	mov	edx,dwDstExtY
        add     eax,ecx
        add     ebx,edx
        mov     dwBmpRight,eax
        mov     dwBmpBottom,ebx

	; Calculate the scaling factor
	sub	eax,eax
	shrd	eax,ecx,12
	mov	ecx,edx
        movsx   ebx,wSrcExtX
	sub	edx,edx
	idiv	ebx
	mov	dwScaleX,eax
	sub	eax,eax
	shrd	eax,ecx,12
        mov	ebx,dwExtY
	sub	edx,edx
	idiv	ebx
	mov	dwScaleY,eax

        ; Do the source clipping on the left and top of the src and dst bitmaps
        mov	eax,dwSrcLeft
        mov	ebx,dwSrcTop
        or      eax,eax
        jns     @F
        sub     dwSrcLeft,eax
	neg	eax
	imul	eax,dwScaleX
	shr	eax,20
        add	dwBmpLeft,eax
@@:     or      ebx,ebx
        jns     @F
        sub     dwSrcTop,ebx
	neg	ebx
	imul	ebx,dwScaleY
	shr	ebx,20
        add	dwBmpTop,ebx
@@:
        ; Do source clipping on the right and bottom of the src and dst bitmaps
        mov     eax,dwSrcBottom
        sub     eax,dwSrcHeight
        jle	@F
        sub     dwSrcBottom,eax
	imul	eax,dwScaleY
	shr	eax,20
        sub     dwBmpBottom,eax
@@:	mov	eax,dwSrcRight
        sub     eax,dwSrcWidth
        jle	@F
        sub     dwSrcRight,eax
	imul	eax,dwScaleX
	shr	eax,20
        sub     dwBmpRight,eax

@@:
        ; Dst clipping uses the clip rectangle
        sub     esi,esi
        lgs     si,lpClipRect

        ; Clip the dst left and top edges
        mov     eax,dwBmpLeft
        movsx   edx,gs:[esi].RECT.left
        sub     eax,edx
        jge	@F
	neg	eax
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleX
        add     dwSrcLeft,eax
	imul	eax,dwScaleX
	shr	eax,20
        add     dwBmpLeft,eax
@@:
	mov     eax,dwBmpTop
        movsx   edx,gs:[esi].RECT.top
        sub     eax,edx
        jge	@F
	neg	eax
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleY
        add     dwSrcTop,eax
	imul	eax,dwScaleY
	shr	eax,20
        add     dwBmpTop,eax
@@:

        ; Clip the dst right and bottom edges
        mov     eax,dwBmpRight
        movsx   edx,gs:[esi].RECT.right
        sub     eax,edx
        jle	@F
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleX
        sub     dwSrcRight,eax
	imul	eax,dwScaleX
	shr	eax,20
        sub     dwBmpRight,eax
@@:
	mov     eax,dwBmpBottom
        movsx   edx,gs:[esi].RECT.bottom
        sub     eax,edx
        jle	@F
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleY
        sub     dwSrcBottom,eax
	imul	eax,dwScaleY
	shr	eax,20
        sub     dwBmpBottom,eax
@@:

DoneClip:
        ; It's all clipped -- now compute the extents
        mov     eax,dwSrcRight
        mov     ebx,dwSrcBottom
        sub     eax,dwSrcLeft
        jle     NothingVisible
        sub     ebx,dwSrcTop
        jle     NothingVisible
        mov     dwExtX,eax
        mov     dwExtY,ebx

        mov     eax,dwBmpRight
        mov     ebx,dwBmpBottom
        sub     eax,dwBmpLeft
        jle     NothingVisible
        sub     ebx,dwBmpTop
        jle     NothingVisible
        mov     dwDstExtX,eax
        mov     dwDstExtY,ebx
        mov     eax,1
        ret

NothingVisible:
        sub     eax,eax
        ret

GN_StretchBltClip    ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNTEXT.ASM ===
;==============================================================================
;
; Copyright (C) 1998,Nvidia Corporation
;
; File:         gntext.asm
;
; Purpose:      This file holds the ExtTextOut display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incFont     = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GLYPHLOOP MACRO IndexSize,TableSize,IsKerning
;
; This macro generates all the inner loops for the text code. There are
; three arguments each of which can be one of two options giving a total
; of 8 inner loops. The options for each argument are as follows:
; IndexSize     ByteGlyph or WordGlyph
; TableSize     WordTable or DwordTable
; IsKerning     Kerning   or NoKerning
;
; The following registers/variables are expected to be setup before
; invoking the macro. The registers on the far right are just notes -
; they describe what registers will be used to hold the variable
; values when they are being used in the macro.
;
; ds                    NewFontSeg selector
; dwGlyphCount          number of glyphs to do
; word ptr lpString+2   selector to list of glyphs      gs
; dwStringOffset        offset to list of glyphs        ecx
; word ptr lpKerning+2  selector to Kerning Vector      fs
; dwkerningOffset       offset to Kerning vector        esi

GLYPHLOOP       MACRO   IndexSize,TableSize,IsKerning
        LOCAL   Loopy

        ;; Load up a few ptrs outside the main loop
        mov     gs,word ptr lpString+2

        IFIDNI  <IsKerning>,<Kerning>
                mov     fs,word ptr lpKerning+2
        ENDIF
Loopy:
        mov     ecx,dwStringOffset
        mov     edi,(NewFontSeg PTR ds:[0]).nfGlyphOffset

        IFDIFI  <IsKerning>,<Kerning>
                ;; If there is no Kerning,we need to know the character width
                mov     esi,(NewFontSeg PTR ds:[0]).nfAWTable
        ENDIF

        ;; Load a byte or word character glyph based upon the glyph size
        IFIDNI  <IndexSize>,<ByteIndex>
                movzx   edx,byte ptr gs:[ecx]
                inc     ecx
        ELSE
                movzx   edx,word ptr gs:[ecx]
                add     ecx,2
        ENDIF

        ;; Handle SMALLBITGLYHP and LARGEBITGLYPH separately.
        IFIDNI  <TableSize>,<WordTable>
                ;; If there is no Kerning,save the glyph width for later
                IFDIFI  <IsKerning>,<Kerning>
                        movzx   eax,word ptr ds:[esi][edx * 2]
                        movzx   esi,word ptr ds:[edi][edx * 2]
                        mov     dwStringOffset,ecx
                        mov     dwGlyphWidth,eax
                ELSE
                        movzx   esi,word ptr ds:[edi][edx * 2]
                        mov     dwStringOffset,ecx
                ENDIF

                mov     ebx,dwDstYDstX
                movsx   eax,ds:[esi].SMALLBITGLYPH.sbgOrgX
                movsx   ecx,ds:[esi].SMALLBITGLYPH.sbgOrgY
                movsx   edx,ds:[esi].SMALLBITGLYPH.sbgHeight
                add     bx,ax
                shl     ecx,10H
                shl     edx,10H

	        ;; Handle the right edge clipping
		cmp     bx,word ptr dwClipRight
	        jge     Doneit

                sub     ebx,ecx
                or      dl,ds:[esi].SMALLBITGLYPH.sbgWidth
                je      next1
                movzx   ecx,ds:[esi].SMALLBITGLYPH.sbgPixels
                add     esi,SIZE SMALLBITGLYPH
        ELSE
                IFDIFI  <IsKerning>,<Kerning>
                        movzx   eax,word ptr ds:[esi][edx * 2]
                        mov     esi,dword ptr ds:[edi][edx * 4]
                        mov     dwStringOffset,ecx
                        mov     dwGlyphWidth,eax
                ELSE
                        mov     esi,dword ptr ds:[edi][edx * 4]
                        mov     dwStringOffset,ecx
                ENDIF

                mov     ebx,dwDstYDstX
                mov     edx,dword ptr ds:[esi].LARGEBITGLYPH.lbgWidth
                add     bx,ds:[esi].LARGEBITGLYPH.lbgOrgX
                mov     ecx,ds:[esi].LARGEBITGLYPH.lbgPixels

	        ;; Handle the right edge clipping
		cmp     bx,word ptr dwClipRight
	        jge     Doneit

                ror     ebx,10H
                sub     bx,ds:[esi].LARGEBITGLYPH.lbgOrgY
                or      dx,dx
                je      next1
                ror     ebx,10H
                add     esi,SIZE LARGEBITGLYPH
        ENDIF

        ;; Call the hardware specific routine to blt the glyph
        call    HW_TextBlt

next1:
        IFIDNI  <IsKerning>,<Kerning>
                mov     edi,dwKerningOffset
                movsx   eax,word ptr fs:[edi]
                add     edi,2
                add     eax,dwDstYDstX
                mov     dwKerningOffset,edi
                mov     word ptr dwDstYDstX,ax
        ELSE
                mov     eax,dwGlyphWidth
                add     eax,dwDstYDstX
                mov     word ptr dwDstYDstX,ax
        ENDIF

        ;; Do all the glyphs in the string
        dec     dwGlyphCount
        jg      Loopy
Doneit:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


OPENSEG  _DATA,USE16,DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32,%DEF_CODE_SIZE,CODE

PUBLIC  GlyphBltTable
GlyphBltTable   LABEL   NEAR
DD      OFFSET  GlyphBltByteIndexWordTableIsKerning
DD      OFFSET  GlyphBltWordIndexWordTableIsKerning
DD      OFFSET  GlyphBltByteIndexWordTableNoKerning
DD      OFFSET  GlyphBltWordIndexWordTableNoKerning
DD      OFFSET  GlyphBltByteIndexDWordTableIsKerning
DD      OFFSET  GlyphBltWordIndexDWordTableIsKerning
DD      OFFSET  GlyphBltByteIndexDWordTableNoKerning
DD      OFFSET  GlyphBltWordIndexDWordTableNoKerning

;==============================================================================
;
; Function:     GENERIC_ExtTextOut
;
; Purpose:      This function is the ExtTextOut display driver entry point.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;
; Returns:      This function returns one of the following values:
;
;               If wCount is negative and the function is successful,
;               it returns the X extent in AX,and the Y extent in DX.
;               If wCount is negative and the function is unsuccessful,
;               it returns the 7FFFH in AX,and wDstY in DX.
;
;               If wCount is 0 or positive and the the function is
;               successful,it returns DX:AX set to 1.
;               If wCount is 0 or positive and the the function is
;               unsuccessful,it returns DX:AX set to 80000000H.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_ExtTextOut,PASCAL,FRAME,FAR16
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi

        ; Grab some arguments for initial filtering
        movsx   edx,wCount
        movzx   eax,wOptions
        mov     ds,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; If this is a sizing call,then punt it.
        or      edx,edx
        jl      GN_ExtTextOutPunt

        ; If the text is anti-aliased,then punt it.
        test    ah,ETO_LEVEL_MODE / 256
        jnz     GN_ExtTextOutPunt

        ; If the font is not packed properly,then punt it.
        test    ah,ETO_BIT_PACKED / 256
        jz      GN_ExtTextOutPunt

        ; Grab some parameters from the dst.
        movzx   ecx,ds:[esi].DIBENGINE.deType
        movzx   eax,ds:[esi].DIBENGINE.deFlags

        ; If the font is not in VRAM,then punt it.
        or      ecx,ecx
        je      GN_ExtTextOutPunt
        test    ah,VRAM / 256
        jz      GN_ExtTextOutPunt

        mov     es,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]

        ; If the text operation involves palette translation then punt it.
        test    ah,PALETTE_XLAT / 256
        jnz     GN_ExtTextOutPunt

        mov     eax,es:[ebx].GNLOGDEVCX.pHWLogdevCX
        mov     ecx,es:[ebx].GNLOGDEVCX.pGNBoardCX
        cmp     es:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_ExtTextOutPunt
        mov     edx,es:[ecx].GNBOARDCX.pHWBoardCX
        mov     pHWLogDevCXOffset_ForExtTextOut,eax
        mov     pHWBoardCXOffset_ForExtTextOut,edx

        ; Save off a few things from the dst device we will need.
        mov     eax,dword ptr ds:[esi].DIBENGINE.deBits
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        mov     dwDstBitsOffset,eax
        mov     dwDstBitsDeltaScan,ecx

        ; We will need the colors from the DRAWMODE structure
        sub     edi,edi
        lds     di,lpDrawMode
        mov     eax,ds:[edi].DRAWMODE.TextColor
        mov     edx,ds:[edi].DRAWMODE.bkColor
        mov     dwFgColor,eax
        mov     dwBgColor,edx

        ; Save the clip rect now for later use.
        lds     di,lpClipRect
        mov     eax,dword ptr ds:[edi].RECT.left
        mov     edx,dword ptr ds:[edi].RECT.right
        mov     dword ptr wOpaqueClipRect.left,eax
        mov     dword ptr wOpaqueClipRect.right,edx
        mov     dword ptr wTextClipRect.left,eax
        mov     dword ptr wTextClipRect.right,edx

        ; Draw opaque rectangles if there are some
        cmp     lpOpaqueRects,0
        je      @F
        call    HW_DrawOpaqueRects
        or      eax,eax
        je      GN_ExtTextOutPunt
@@:
        ; Is there any text to do?
        movsx   eax,wCount
        or      eax,eax
        jle     GN_ExtTextOutSuccess
        mov     dwGlyphCount,eax

IF  (INTERSECT_TEXTXFORM_WITH_CLIP NE 0)
        cmp     lpTextXForm,0
        je      NoX
        mov     eax,dword ptr wTextClipRect.left
        mov     edx,dword ptr wTextClipRect.right
        sub     edi,edi
        lds     di,lpTextXForm
        cmp     ax,ds:[edi].RECT.left
        jg      @F
        mov     ax,ds:[edi].RECT.left
@@:     cmp     dx,ds:[edi].RECT.right
        jl      @F
        mov     dx,ds:[edi].RECT.right
@@:     cmp     dx,ax
        jle     GN_ExtTextOutSuccess
        ror     eax,10H
        ror     edx,10H
        cmp     ax,ds:[edi].RECT.top
        jg      @F
        mov     ax,ds:[edi].RECT.top
@@:     cmp     dx,ds:[edi].RECT.bottom
        jl      @F
        mov     dx,ds:[edi].RECT.bottom
@@:     cmp     dx,ax
        jle     GN_ExtTextOutSuccess
        ror     eax,10H
        ror     edx,10H
        mov     dword ptr wTextClipRect.left,eax
        mov     dword ptr wTextClipRect.right,edx
NoX:
ENDIF
        ; Setup up variables for the glyph loop
        mov     ds,word ptr lpFontInfo+2
        movzx   ecx,wTextClipRect.right
        mov     edx,dword ptr wDstY
        ror     edx,10H
        mov     dwClipRight,ecx
        mov     dwDstYDstX,edx
        movzx   eax,word ptr lpString
        movzx   ecx,word ptr lpKerning
        mov     dwStringOffset,eax
        mov     dwKerningOffset,ecx

        ; Call the hardware specific routine to prepare for glyphs
        call    HW_TextBegin
        or      eax,eax
        je      GN_ExtTextOutPunt1

HostTextBlt:
        ; Dispatch to the correct handler
        sub     ebx,ebx
        push    OFFSET GN_ExtTextOutRet
        mov     cl,byte ptr ds:[ebx].NewFontSeg.nfFormat
        mov     ebx,lpKerning
        mov     al,byte ptr wOptions
        test    cl,NF_LARGE
        jnz     IsLG
IsSG:   or      ebx,ebx
        jne     IsSGK
IsSGNK: test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexWordTableNoKerning
        jmp     GlyphBltWordIndexWordTableNoKerning
IsSGK:  test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexWordTableIsKerning
        jmp     GlyphBltWordIndexWordTableIsKerning
IsLG:   or      ebx,ebx
        jne     IsLGK
IsLGNK: test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexDWordTableNoKerning
        jmp     GlyphBltWordIndexDWordTableNoKerning
IsLGK:  test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexDWordTableIsKerning
        jmp     GlyphBltWordIndexDWordTableIsKerning

GENERIC_ExtTextOut  ENDP


;==============================================================================
;
; Functions:    ExtTextOut ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of ExtTextOut. You can either return a success code,a
;               failure code,punt to the DIBENG,etc.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;               fs      selector of PDEVICE
;
;==============================================================================
PUBLIC  GN_ExtTextOutPunt1
GN_ExtTextOutPunt1      PROC    NEAR
        ; Jump to here when the opaqueing rects have been drawn but you
        ; wish to punt the text.
        mov     lpOpaqueRects,0
GN_ExtTextOutPunt1      ENDP

PUBLIC  GN_ExtTextOutPunt
GN_ExtTextOutPunt     PROC    NEAR
        ; Jump to here when you want to punt the whole call.
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_ExtTextOut
        jmp     DIB_ExtTextOut
GN_ExtTextOutPunt     ENDP

PUBLIC  GN_ExtTextOutRet
GN_ExtTextOutRet  PROC    NEAR
        call    HW_TextEnd
GN_ExtTextOutRet  ENDP

PUBLIC  GN_ExtTextOutSuccess
GN_ExtTextOutSuccess   PROC    NEAR
        mov     eax,1
GN_ExtTextOutSuccess   ENDP

PUBLIC  GN_ExtTextOutExit
GN_ExtTextOutExit     PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 28H
GN_ExtTextOutExit     ENDP


;==============================================================================
;
; Function:     GlyphBltByteIndexWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexWordTableIsKerning
GlyphBltByteIndexWordTableIsKerning     PROC    NEAR

        GLYPHLOOP  ByteIndex,WordTable,Kerning
        ret

GlyphBltByteIndexWordTableIsKerning     ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexWordTableIsKerning
GlyphBltWordIndexWordTableIsKerning     PROC    NEAR

        GLYPHLOOP  WordIndex,WordTable,Kerning
        ret

GlyphBltWordIndexWordTableIsKerning     ENDP



;==============================================================================
;
; Function:     GlyphBltByteIndexWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexWordTableNoKerning
GlyphBltByteIndexWordTableNoKerning PROC    NEAR

        GLYPHLOOP  ByteIndex,WordTable,NoKerning
        ret

GlyphBltByteIndexWordTableNoKerning ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexWordTableNoKerning
GlyphBltWordIndexWordTableNoKerning PROC    NEAR

        GLYPHLOOP  WordIndex,WordTable,NoKerning
        ret

GlyphBltWordIndexWordTableNoKerning ENDP



;==============================================================================
;
; Function:     GlyphBltByteIndexDWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexDWordTableIsKerning
GlyphBltByteIndexDWordTableIsKerning    PROC    NEAR

        GLYPHLOOP  ByteIndex,DWordTable,Kerning
        ret

GlyphBltByteIndexDWordTableIsKerning    ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexDWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexDWordTableIsKerning
GlyphBltWordIndexDWordTableIsKerning PROC    NEAR

        GLYPHLOOP  WordIndex,DWordTable,Kerning
        ret

GlyphBltWordIndexDWordTableIsKerning ENDP



;==============================================================================
;
; Function:     GlyphBltByteIndexDWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexDWordTableNoKerning
GlyphBltByteIndexDWordTableNoKerning PROC    NEAR

        GLYPHLOOP  ByteIndex,DWordTable,NoKerning
        ret

GlyphBltByteIndexDWordTableNoKerning ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexDWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexDWordTableNoKerning
GlyphBltWordIndexDWordTableNoKerning PROC    NEAR

        GLYPHLOOP  WordIndex,DWordTable,NoKerning
        ret

GlyphBltWordIndexDWordTableNoKerning ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSSB.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation.
;
; File:         gnssb.asm
;
; Purpose:      This file holds the SaveScreenBitmap display driver
;               entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

; These aren't in any API header file so include them here
SAVE_AREA       EQU     0
RESTORE_AREA    EQU     1
DISCARD_AREA    EQU     2

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_ClearSaveScreenBitmapCache
;
; Purpose:      This function clears the SaveScreenBitmap cache.
;
; Arguments:
;               ds                      CXSel
;               pGNLogevCXOffset        GNLOGDEVCX ptr
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearSaveScreenBitmapCache, PASCAL, FRAME, FAR32
PARMD   pGNLogevCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogevCXOffset

	PUSHR	ds
	POPR	es
        lea     edi,ds:[esi].GNLOGDEVCX.SaveScreenBitmapCache
        mov     eax,-1
        mov     ebx,MAX_SSBS

        ; Initialize the template SSB headers
@@:
        mov     esi,pGNLogevCXOffset
        mov     ecx,(SIZE DIBENGINE + 3) / 4
        mov     edx,edi
        rep     movs dword ptr es:[edi], ds:[esi]
        and     es:[edx].DIBENGINE.deFlags,MINIDRIVER OR PALETTIZED OR FIVE6FIVE
        mov     es:[edi],eax
        lea     edi,[edx + SIZE DEVBMP]
        dec     ebx
        jne     @B
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_SaveScreenBitmap
;
; Purpose:      This function is the SaveScreenBitmap display driver
;               entry point.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SaveScreenBitmap, PASCAL, FRAME, FAR16
PARMD   lpRect
PARMW   wCommand
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        sub     eax,eax

        ; Make sure the screen is free
        cmp     eax,ds:[ebx].GNLOGDEVCX.dwHardwareBusy
        jne     GN_SaveScreenBitmapFail

        cmp     eax,lpRect
        je      GN_SaveScreenBitmapFail

        ; switch on the command
        cmp     wCommand,RESTORE_AREA
        jc      SSB_SaveArea
        jmp     SSB_RestoreOrDiscardArea

GENERIC_SaveScreenBitmap        ENDP


;==============================================================================
;
; Function:     SaveScreenBitmap ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of SaveScreenBitmap. You can either return a success code, a failure
;               code, punt to the DIBENG, etc.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_SaveScreenBitmapFail
GN_SaveScreenBitmapFail PROC    NEAR
        sub     eax,eax
        jmp     GN_SaveScreenBitmapExit
GN_SaveScreenBitmapFail ENDP

PUBLIC  GN_SaveScreenBitmapSuccess
GN_SaveScreenBitmapSuccess      PROC    NEAR
        mov     eax,1
GN_SaveScreenBitmapSuccess      ENDP

PUBLIC  GN_SaveScreenBitmapExit
GN_SaveScreenBitmapExit PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 06H
GN_SaveScreenBitmapExit ENDP



;==============================================================================
;
; Function:     SSB_SaveArea
;
; Purpose:      This function is jumped to when the SaveScreenBitmap
;               function flavor is to save the area specified.
;
;               We can try to allocate a bitmap both in offscreen or
;               in a page locked DMAable section of memory. Try the
;               offscreen area first -- if that doesn't work, go for
;               the DMAable memory area.
;               NOTE: Right now, only doing offscreen VRAM SSBs.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;               ds              Context Selector
;               ebx             GNLOGDEVCX ptr
;
; Returns:      jump to one of the SSB ending routinee when you are done
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  SSB_SaveArea
SSB_SaveArea    PROC    NEAR

        ; Fail if cannot use any of the SSB area (offscreen, DMAable)
        mov     eax,ds:[ebx].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[eax].GNBOARDCX.dwOffscreenFlags
        test    eax,NO_OFFS_BMPS
        jnz     GN_SaveScreenBitmapFail

        ; Get the rectangle to save
        sub     edi,edi
        lgs     di,lpRect
        mov     eax,dword ptr gs:[edi].RECT.left
        mov     edx,dword ptr gs:[edi].RECT.right

        ; Make sure the rectangle to save is valid
        mov     edi,edx
        mov     esi,edx
        sub     di,ax
        jle     GN_SaveScreenBitmapFail
        sub     esi,eax
        jle     GN_SaveScreenBitmapFail

        ; If any of the existing save screen areas match the new
        ; area to save, then consider the old area trashed and
        ; resave it.
        lea     edi,[ebx].GNLOGDEVCX.SaveScreenBitmapCache
        mov     esi,MAX_SSBS
Loopy1:
        cmp     eax,dword ptr ds:[edi].DEVBMP.wLeft
        jne     @F
        cmp     edx,dword ptr ds:[edi].DEVBMP.wRight
        je      DoBlt
@@:     add     edi,SIZE DEVBMP
        dec     esi
        jne     Loopy1

        ; Find a free SSB header to use.
        lea     edi,[ebx].GNLOGDEVCX.SaveScreenBitmapCache
        mov     ecx,-1
        mov     esi,MAX_SSBS
Loopy2:
        cmp     ecx,dword ptr ds:[edi].DEVBMP.wLeft
        je      @F
        add     edi,SIZE DEVBMP
        dec     esi
        jne     Loopy2
        jmp     GN_SaveScreenBitmapFail
@@:
        ; Complete one of the SSB headers to descibe the region being saved
        mov     dword ptr ds:[edi].DEVBMP.wLeft,eax
        mov     dword ptr ds:[edi].DEVBMP.wRight,edx
        sub     edx,eax
        mov     dword ptr ds:[edi].DIBENGINE.deWidth,edx
        mov     ax,word ptr ds:[ebx].GNLOGDEVCX.Dibeng.dePlanes
        mov     word ptr ds:[edi].DIBENGINE.dePlanes,ax
        movzx   eax,ah
        movzx	edx,dx
        shr     eax,3
        imul    eax,edx
        mov     ds:[edi].DIBENGINE.deWidthBytes,ax

        ; Can we get an offscreen bitmap?
        PUSHR	ds
        POPR	es
        push    ds:[ebx].GNLOGDEVCX.pGNBoardCX
        call    GN_OffscreenBitmapCreate
        or      eax,eax
        jne     DoBlt

        ; If doing DMAable -- try to allocate one in here

        ; If the offscreen allocation failed, mark the SSB slot as
        ; free again and then fail the call
        mov     dword ptr ds:[edi].DEVBMP.wLeft,-1
        jmp     GN_SaveScreenBitmapFail

DoBlt:
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        mov     eax,edi
        sub     eax,ebx
        add     eax,cs:[CSlp16LogDevice]
        push    eax                             ; lpDstDev
        push    cs:[CSlp16LogDevice]            ; lpSrcDev
        sub     eax,eax
        push    eax                             ; lpBrush
        push    eax                             ; lpDrawMode
        push    eax                             ; dstX:dstY
        mov     eax,dword ptr ds:[edi].DEVBMP.wLeft
        mov     ebx,dword ptr ds:[edi].DIBENGINE.deWidth
        ror     eax,10H
        ror     ebx,10H
        push    eax                             ; srcX:srcY
        push    ebx                             ; extX:extY
        mov     eax,0CC0000H
        push    eax                             ; Rop3
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      GN_SaveScreenBitmapSuccess
        sub     eax,eax
        call    GN_SaveScreenBitmap
        jmp     GN_SaveScreenBitmapSuccess

SSB_SaveArea    ENDP


;==============================================================================
;
; Function:     SSB_RestoreOrDiscardArea
;
; Purpose:      This function is jumped to when the SaveScreenBitmap
;               function flavor is to restore or discard a saved area.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;               ds              Context Selector
;               ebx             GNLOGDEVCX ptr
;
; Returns:      jump to one of the SSB ending routines when you are done
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  SSB_RestoreOrDiscardArea
SSB_RestoreOrDiscardArea        PROC    NEAR

        ; Load the rectangle to restore or discard
        sub     esi,esi
        les     si,lpRect
        mov     eax,dword ptr es:[esi].RECT.left
        mov     edx,dword ptr es:[esi].RECT.right

        ; Search for it in the list of saved areas
        lea     edi,[ebx].GNLOGDEVCX.SaveScreenBitmapCache
        sub     edi,SIZE DEVBMP
        mov     esi,MAX_SSBS
        mov     ecx,-1
@@:
        add     edi,SIZE DEVBMP
        dec     esi
        jl      GN_SaveScreenBitmapFail
        cmp     ecx,dword ptr ds:[edi].DEVBMP.wLeft
        je      @B
        cmp     eax,dword ptr ds:[edi].DEVBMP.wLeft
        jne     @B
        cmp     edx,dword ptr ds:[edi].DEVBMP.wRight
        jne     @B

Match:
        ; Only do the copy back if the command was restore
        cmp     wCommand,RESTORE_AREA
        jne     @F

        ; If we are allowing DMAable, figure out which one it is
        ; The below only supports VRAM SSBs

        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    cs:[CSlp16LogDevice]            ; lpDstDev
        mov     eax,edi
        sub     eax,ebx
        add     eax,cs:[CSlp16LogDevice]
        sub     ecx,ecx
        push    eax                             ; lpSrcDev
        push    ecx                             ; lpBrush
        push    ecx                             ; lpDrawMode
        mov     eax,dword ptr ds:[edi].DEVBMP.wLeft
        mov     ebx,dword ptr ds:[edi].DIBENGINE.deWidth
        ror     eax,10H
        ror     ebx,10H
        push    eax                             ; dstX:dstY
        push    ecx                             ; srcX:srcY
        push    ebx                             ; extX:extY
        mov     eax,0CC0000H
        push    eax                             ; rop3
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      @F
        mov     eax,1
        call    GN_SaveScreenBitmap
@@:
        ; Inidicate the SSB cache slot is now free and release the
        ; memory used by the saved area.
        mov     eax,-1
        mov     dword ptr ds:[edi].DEVBMP.wLeft,eax
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pGNBoardCX
	pushd	0
        PUSHR	ds
        POPR	es
        call    GN_OffscreenBitmapDelete
        jmp     GN_SaveScreenBitmapSuccess

SSB_RestoreOrDiscardArea        ENDP



;==============================================================================
;
; Function:     GN_SaveScreenBitmap
;
; Purpose:      This function will save or restore the screen area
;               in software. It is used only if the hardware specific
;               routine fails.
;
; Arguments:    ds      Context Selector
;               edi     DEVBMP ptr. This structure is a DIBENGINE struct
;                       with four extra fields DEVBMP.wLeft, DEVBMP.wRight,
;                       DEVBMP.wTop, DEVBMP.wBottom. These fields specify
;                       a rectangular area of the screen that the bitmap
;                       ds:esi is currently holding or is waiting to hold.
;               eax     0 then copy the rectangle from the primary screen
;                         given by the DEVBMP rectangle specifiers to the
;                         bitmap specified by the DIBENGINE portion of the
;                         DEVBMP structure. This is a SAVE operation.
;                       1 ten copy the bitmap specified by the DIBENGINE
;                         portion of the DEVBMP structure to the rectangle
;                         on the main screen given by the DEVBMP rectangle
;                         specifiers. This is a RESTORE operation.
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SaveScreenBitmap, PASCAL, FRAME, NEAR
LOCALD  dwRestoreOperation
LOCALD  dwWidthInBytes
LOCALD  dwWholeDwords
LOCALD  dwExtraBytes
LOCALD  dwSrcWrapWidth
LOCALD  dwDstWrapWidth
LOCALD  dwHeight
OPENPROC
        PUSHR   ds,esi,edi

        ; Save this for later
        mov     dwRestoreOperation,eax

        ; Compute the Blt width in a few different formats
        movzx   eax,ds:[edi].DEVBMP.wRight
        movzx   ebx,ds:[edi].DEVBMP.wLeft
        movzx   ecx,ds:[edi].DIBENGINE.deBitsPixel
        sub     eax,ebx
        shr     ecx,3
        imul    eax,ecx
        mov     edx,eax
        mov     ecx,eax
        mov     dwWidthInBytes,eax
        and     eax,3
        mov     dwExtraBytes,eax
        shr     edx,2
        mov     dwWholeDwords,edx

        ; Compute the wrap widths
        mov     ebx,cs:[CSpGNLogicalDevice]
        mov     eax,ds:[ebx].GNLOGDEVCX.Dibeng.deDeltaScan
        mov     edx,ds:[edi].DIBENGINE.deDeltaScan
        sub     eax,ecx
        sub     edx,ecx
        mov     dwSrcWrapWidth,eax
        mov     dwDstWrapWidth,edx

        ; Compute the Blt height
        movzx   eax,ds:[edi].DEVBMP.wBottom
        movzx   ecx,ds:[edi].DEVBMP.wTop
        sub     eax,ecx
        mov     dwHeight,eax

        ; Compute the starting address on the primary display
        movzx   eax,ds:[edi].DIBENGINE.deBitsPixel
        movzx   edx,ds:[edi].DEVBMP.wTop
        movzx   ecx,ds:[edi].DEVBMP.wLeft
        shr     eax,3
        imul    edx,ds:[ebx].GNLOGDEVCX.Dibeng.deDeltaScan
        imul    eax,ecx
        add     eax,edx
        les     edi,fword ptr ds:[edi].DIBENGINE.deBits
        lds     esi,fword ptr ds:[ebx].DIBENGINE.deBits
        add     esi,eax

        ; If it is a save, then we are ready to go. If it is a restore
        ; then we need to switch the src and dst ptrs and wrap widths.
        cmp     dwRestoreOperation,0
        je      @F
        xchg    esi,edi
        mov     ax,es
        mov     dx,ds
        mov     ds,ax
        mov     es,dx
        mov     eax,dwSrcWrapWidth
        mov     edx,dwDstWrapWidth
        mov     dwSrcWrapWidth,edx
        mov     dwDstWrapWidth,eax
@@:
        mov     ecx,dwWholeDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,dwExtraBytes
        rep     movs byte ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwHeight
        jne     @B

        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNVALMOD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnvalmod.asm
;
; Purpose:      This file holds the ValidateMode display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include valmode.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_ValidateMode
;
; Purpose:      This function is the ValidateMode driver entry
;               point. Make sure that the requested mode can be
;               supported. This will be based upon the amount of
;               memory, memory speed, output device (tv, monitor),
;               and maybe other things.
;
; Arguments:    ValidateMode display driver stack frame
;
; Returns:      eax     VALMODE_NO_UNKNOWN Can't be sure mode is supported
;                       VALMODE_YES        Mode definitely can be supported
;
; Preserve:     ds,esi,edi
;==============================================================================
PUBLIC  ValidateMode
ValidateMode    PROC    FAR
        ; Windows requires that ValidateMode be exported by name. I
        ; have the real routine GENERIC_ValidateMode equated to the
        ; same address.
        .errnz  $ - OFFSET GENERIC_ValidateMode
ValidateMode    ENDP

DECPROC GENERIC_ValidateMode, PASCAL, FRAME, FAR16
PARMD   lpValMode
LOCALD  dwCRTCCount
LOCALD  dwMemoryNeededForMode
LOCALV  sModeInfo,MODEINFO
LOCALV  sValModeCopy,DISPVALMODE
OPENPROC
        PUSHR   ds,esi,edi

        ; This may be the first call into the display driver besides
        ; the driver entry point which does not do anything. If we
        ; have not initted the driver, then just return VALMODE_YES.
        mov     eax,VALMODE_YES
        cmp     cs:[wNVTEXT16_Alias_In_NVTEXT16],0
        je      DoneIt

        ; Load the context selector and GNLOGDEVCX ptr
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; if we are the primary, ...
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        jne     @F

        ; then don't bother trying to validate modes on a secondary
        ; right now -- just say yes.
        ; Kludge!! Peek up into GDI's stack frame and see if they
        ; want to validate on the primary or secondary
        mov     bx,ss:[bp]
        cmp     dword ptr ss:[bx + 14H],1
        je      @F
        
        ; If we fall through then we are validating a secondary mode on the
        ; primary driver. Check if this mode is overridden by the OEM.
        push    esi
        push    lpValMode
        call    GN_CheckForOEMOverrides
        or      ax,ax
        jne     FailMode
        
        ; Windows has a nasty habit of validating modes for the disabled
        ; secondary display on the primary driver. If we do not validate this
        ; mode, then Windows, in its infinite wisdom, will not let us change
        ; the mode on the primary. Since the secondary is disabled, we don't
        ; know what the actual display device is and therefore can not
        ; properly validate the mode. Therefore, we just say yes for all these
        ; modes. When the secondary display is actually enabled, the secondary
        ; driver will properly fall back to a mode that the display device can
        ; handle.
        jmp     Success
        
@@:
        ; Make sure pGNCrtcCX is not a null pointer.
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX,0
        je      Success

        ; Make a copy of the ValidateMode structure passed in by Windows
        ; so we can modify it if the mode is bogus.
        sub     ebx,ebx
        lfs     bx,lpValMode

        push    esi
        push    edi
        mov     cx,size DISPVALMODE
        sub     edi,edi
        mov     di,ss
        mov     es,di
        lea     di,sValModeCopy
        mov     esi,ebx
        rep     movs byte ptr es:[edi], fs:[esi]
        pop     edi
        pop     esi
        
        ; Load the copy into ES:[EBX] 
        mov     ax,ss
        shl     eax,10h
        lea     ax,sValModeCopy
        mov     lpValMode,eax
        sub     ebx,ebx
        les     bx,lpValMode
        
        ; Check if this mode is overridden by the OEM.
        push    esi
        push    lpValMode
        call    GN_CheckForOEMOverrides
        or      ax,ax
        jne     FailMode

        ; Check if this is a bogus multiple of 8 mode passed in because 
        ; Win98 in multimon mode wants resolutions to be a multiple of 8
        ; so 1600x900 gets changed to 1600x896 and 1400x1050 gets changed
        ; to 1400x1048. GN_CheckForMultipleOf8Mode will adjust to a mode
        ; we can handle
        mov     ax,ss
        shl     eax,10h
        lea     ax,es:[ebx].DISPVALMODE.dvmXRes
        push    eax
        lea     ax,es:[ebx].DISPVALMODE.dvmYRes
        push    eax
        call    GN_CheckForMultipleOf8Mode

        ; Check for bogus mode 604x402 that we sometimes get
        cmp     es:[ebx].DISPVALMODE.dvmXRes,604
        je      FailMode
        cmp     es:[ebx].DISPVALMODE.dvmYRes,402
        je      FailMode

        ; Get the memory needed for the mode
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        movzx   eax,es:[ebx].DISPVALMODE.dvmXRes
        push    eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmYRes
        push    eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmBpp
        push    eax
        call    HW_GetModeDimensions
        mov     dwMemoryNeededForMode,ebx

        ; Get the largest memory size that we could put this mode in.
        ; We suppose we can purge DX heap if we'll need an extra free space.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[ebx].GNBOARDCX.dwMemorySizeForValidateMode

        ; Is it enough?
        cmp     eax,dwMemoryNeededForMode
        jb      FailMode

        ; For right now, if this is 480x360 or 960x720, and the device
        ; is a DFP, then disallow the mode. PLEASE NOTE: There is a
        ; corresponding check for these modes in the Modeset DLL.
        sub     ebx,ebx
        les     bx,lpValMode
        movzx   eax,es:[ebx].DISPVALMODE.dvmXRes
        movzx   edx,es:[ebx].DISPVALMODE.dvmYRes
        
Check480x360:
        cmp     eax,1E0H
        jne     Check960x720
        cmp     edx,168H
        jne     Check960x720
        jmp     CheckDisplayType
        
Check960x720:
        cmp     eax,3C0H
        jne     NotBadMode
        cmp     edx,2D0H
        jne     NotBadMode
        
CheckDisplayType:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     ebx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        cmp     al,DEVTYPE_DFP
        je      FailMode

NotBadMode:
        ; Check for the registry key that says we allow all the modes.
        ; If set, then any desktop is OK and everyone will just pan and
        ; scan as needed.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetAllowMightyModesFlag,es,ax
        or      ax,ax
        jne     Success

MustValPhys:
        ; Always validate on the primary CRTC. We always allow the
        ; secondary to pan.

        ; Get everything into a MODEINFO structure
        sub     ebx,ebx
        les     bx,lpValMode
        movzx   eax,es:[ebx].DISPVALMODE.dvmXRes
        mov     sModeInfo.dwXRes,eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmYRes
        mov     sModeInfo.dwYRes,eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmBpp
        mov     sModeInfo.dwBpp,eax

        ; If this mode validation is occuring after a SetDisplayConfig
        ; escape, then the display device information in the GNCRTCCX
        ; may be stale. Check the dwDisplayDeviceChange flag, and if it
        ; is equal to 1, then just validate the mode. After all display
        ; devices are mapped during Enable, we will clear the flag and
        ; revalidate to make sure the mode can actually be set.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        cmp     ds:[ecx].GNCRTCCX.dwDisplayDeviceChange,1
        je      Success

        ; We don't know what refresh rate they really want. Just
        ; choose a large value so that if we support any refresh
        ; rate at the resolution and pixel depth desired, then
        ; we will validate the mode.
        mov     sModeInfo.dwRefreshRate,1000
        lea     ebx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        mov     sModeInfo.MIDevData,eax

        ; Maybe we should re read the EDID
        push    ecx
        call    GN_CheckAndMaybeReadEdid

        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ecx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        sub     ebx,ebx
        lfs     bx,ds:[ecx].GNCRTCCX.lpNvmodeDispData
        push    fs:[ebx].DISPDATA.dwMonitorInfType
        push    ds:[ecx].GNCRTCCX.lpEdidBuffer
        push    ds:[ecx].GNCRTCCX.dwEdidSize
        call    GN_ValidatePhysicalMode

        test    eax,MODE_RESOLUTION_ADJUSTED
        jnz     FailMode

Success:
        mov     eax,VALMODE_YES
        jmp     DoneIt

FailMode:
        mov     eax,VALMODE_NO_UNKNOWN

DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ValidatePhysicalMode
;
; Purpose:      This function is a more specific version of the
;               Validate Mode call. The mode passed in is validated
;               and adjusted downwards to something that can be set
;               if it is out of range.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX
;               lpModeInfoToValidate    MODEINFO ptr
;               dwTypeMonitorInf
;               lpEdidBuffer            Edid Buffer ptr
;               dwEdidBufferSize        size of lpEdidBuffer. This
;                                       will be 0 if there is no EDID
;
; Returns:      eax                     A combination of the bitflags
;                                       defined in modeext.h like
;                                       MODE_RESOLUTION_ADJUSTED
;                                       MODE_REFRESHRATE_ADJUSTED
;                                       etc..
;
;               Note that if eax indicates that the lpModeInfoToValidate
;               could not be supported, then lpModeInfoToValidate will
;               have been modified on return to reflect the
;               next largest possible mode that can.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ValidatePhysicalMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpModeInfoToValidate
PARMD   dwTypeMonitorInf
PARMD   lpLocalEdidBuffer
PARMD   dwEdidBufferSize
LOCALD  dwSaveMonitorInfType
LOCALV  sDispData,DISPDATA
LOCALV  sMO,MODEOUT
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Build a correct DISPDATA structure
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        mov     eax,fs:[ebx].DISPDATA.dwMonitorInfType
        mov     dwSaveMonitorInfType,eax
        mov     eax,dwTypeMonitorInf
        mov     fs:[ebx].DISPDATA.dwMonitorInfType,eax

        ; Modify refresh rate list in registry.
        mov     ebx,lpModeInfoToValidate
        lea     bx,[bx].MODEINFO.MIDevData
        push    ebx
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    lpLocalEdidBuffer
        push    dwEdidBufferSize
        call    FFP16 PTR lpfnResetRefreshRates

        ; Now we are ready to validate!
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    lpLocalEdidBuffer
        push    dwEdidBufferSize
        push    lpModeInfoToValidate
        mov     ax,ss
        shl     eax,10H
        lea     ax,sMO
        push    eax
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Return the mode that can be set
        sub     edi,edi
        les     di,lpModeInfoToValidate
        push    ss
        pop     fs
        lea     esi,sSettableCrtcModeInfo
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        mov     esi,pGNCrtcCXOffset

        ; Restore the NvmodeDispData
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        mov     ecx,dwSaveMonitorInfType
        mov     fs:[ebx].DISPDATA.dwMonitorInfType,ecx

        POPR    esi,edi
CLOSEPROC

;==============================================================================
;
; Function:     GN_GetFreeBlockSizeForMode
;
; Purpose:      This function is called to get the FreeBlock size
;               that we can fit a mode into. This whole determination
;               is actually very complicated because it depends upon
;               many things. Like whether we are running just one
;               logical device on this board, or more. And, if more
;               than one, whether DirectX is running on the device
;               that we are NOT trying to get a FreeBlock size for.
;               Argh! Just follow the comments along in the code.
;               That is where the details are.
;
; Arguments:
;               ds                      COntext Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax     The largest free block that would be available
;                       to set the mode in.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetFreeBlockSizeForMode, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  dwMyOffscreenFlags
LOCALD  dwJustOnePrimaryCanMove
LOCALD  pOtherGNLogdevCXOffset
LOCALD  dwValidationFreeBlockSize
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX

        ; Assume only one primary surface can move and that there is
        ; not even a second primary surface sharing video memory.
        mov     dwJustOnePrimaryCanMove,1
        mov     pOtherGNLogdevCXOffset,0

        ; Is there another primary surface on this board?
        cmp     ds:[edi].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        je      GotPrimaryData

        ; OK, there is more than 1 primary (that means 2 right now),
        ; but can the other primary be moved? If DX is running on it,
        ; then it cannot. Otherwise it can.
        mov     eax,ds:[edi].GNBOARDCX.pGNLogdevCX[0]
        cmp     eax,esi
        jne     @F
        mov     eax,ds:[edi].GNBOARDCX.pGNLogdevCX[4]
@@:     mov     pOtherGNLogdevCXOffset,eax

        cmp     ds:[eax].GNLOGDEVCX.bDirectXActive,0
        jne     GotPrimaryData
        mov     dwJustOnePrimaryCanMove,0

GotPrimaryData:
        ; NOTE: The general fitting algorithm is too difficult to do in
        ; its full generality. Hence, we just implement the two specific
        ; cases that we know are the only ones that can happen right now.
        cmp     dwJustOnePrimaryCanMove,0
        jne     JustOnePrimaryCanMove


BothPrimariesCanMove:
        ; This scenario allows us the ultimate in flexibility. We
        ; will be able to host the highest resolutions on both
        ; logical devices in small video memory configurations if
        ; we have the flexibility to move both primaries.

        ; First, we need to remember if we currently have an offscreen
        ; heap for bitmaps
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[edi].GNBOARDCX.dwOffscreenFlags
        mov     dwMyOffscreenFlags,eax

        ; Now purge this heap if it exists sweeping all bitmaps to
        ; system memory.
        push    edi
        pushd   0
        call    GN_ControlOffscreenAllocations

        ; Until we get the RM call we want, cross your fingers and
        ; use the largest two things of: 1) The size for one of the
        ; primaries. 2) The size for the other primary. 3) The size
        ; of the largest other free block.

        ; This is not quite accurate since the block may be large
        ; emough if it starts at its base address, but starting at
        ; its aligned address, it may not be large enough. For now
        ; that is all we have.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     eax,-1
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     eax,ds:[esi].DIBENGINEHDR.deBitsOffset
@@:
        push    eax

        mov     ebx,pOtherGNLogdevCXOffset
        mov     eax,-1
        cmp     ds:[ebx].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     eax,ds:[ebx].DIBENGINEHDR.deBitsOffset
@@:
        push    eax
        call    HW_GetLargestOffscreenSpace
        or      ebx,ebx
        je      OneBlock

TwoBlocks:
        ; See if the other guy will fit in one of the two blocks
        mov     ecx,pOtherGNLogdevCXOffset
        mov     ecx,ds:[ecx].GNLOGDEVCX.dwMemorySizeForPrimarySurface

        ; Will other guy fit in the smaller block?
        sub     ebx,ecx
        jge     GotIt
        add     ebx,ecx

OneBlock:
        ; Other guy has to go in larger block (Note, this must work
        ; since the "free" blocks were gotten assuming that both
        ; primaries were freed.)
        mov     ecx,pOtherGNLogdevCXOffset
        mov     ecx,ds:[ecx].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        sub     eax,ecx

GotIt:
        ; The larger of the two free pieces, after the other logical
        ; device's primary surface has been placed in one of them,
        ; should go into dwValidationFreeBlockSize
        cmp     eax,ebx
        jae     @F
        mov     eax,ebx
@@:
        mov     dwValidationFreeBlockSize,eax

        ; If we had an offscreen heap, then let us turn it back on.
        test    dwMyOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        jnz     @F
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        pushd   1
        call    GN_ControlOffscreenAllocations
@@:
        jmp     GotValidationSize


JustOnePrimaryCanMove:
        ; There is only one primary onthis board OR the other primary
        ; cannot be moved for some reason (DX is running on it maybe.)

        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     eax,-1
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     eax,ds:[esi].DIBENGINEHDR.deBitsOffset
@@:
        push    eax
        mov     eax,ds:[ebx].GNBOARDCX.dwOffscreenBaseAddress
        cmp     ds:[ebx].GNBOARDCX.dwOffscreenLength,0
        jne     @F
        mov     eax,-1
@@:
        push    eax
        call    HW_GetLargestOffscreenSpace
        mov     dwValidationFreeBlockSize,eax

GotValidationSize:
        mov     eax,dwValidationFreeBlockSize
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckForMultipleOf8Mode
;
; Purpose:      The following is a HACK! Win98 in multimon mode wants
;               resolutions to be a multiple of 8 so 1600x900 gets
;               changed to 1600x896. When a mode is being changed on
;               the secondary, Windows revalidates the mode on the
;               primary. Since 1600x896 is not in our master mode list,
;               we reject it, and Windows aborts the mode set. Since
;               1600x900 is what was really set, all we need to do is
;               validate 1600x896 and Windows is happy. Please also note
;               that Microsoft has fixed this problem under WinME.
;               NOTE: This is also a problem with 1400x1050 which Windows
;               asks to validate as 1400x1048. Chnage these modes to the
;               real mode so we can validate.
;
; Arguments:
;               lpXRes                  X Res ptr
;               lpYRes                  Y Res ptr
;
; Returns:      Corrected Y Res for modes in question
;
; Preserve:     ds,es,fs,esi,edi
;==============================================================================
DECPROC GN_CheckForMultipleOf8Mode, PASCAL, FRAME, FAR16
PARMD   lpXRes
PARMD   lpYRes
OPENPROC
        PUSHR   es,fs,esi,edi

        sub     esi,esi
        les     si,lpXRes
        sub     edi,edi
        lfs     di,lpYRes
        cmp     word ptr es:[esi],1600
        jne     Check_1400x1048
        cmp     word ptr fs:[edi],896
        jne     Check_1400x1048
        mov     word ptr fs:[edi],900
        jmp     DoneIt

Check_1400x1048:
        cmp     word ptr es:[esi],1400
        jne     DoneIt
        cmp     word ptr fs:[edi],1048
        jne     DoneIt
        mov     word ptr fs:[edi],1050
        
DoneIt:

        POPR    es,fs,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckForOEMOverrides
;
; Purpose:      This routine checks for certain modes that certain OEMs
;               want blocked.
;
; Arguments:
;               ds                      COntext Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               lpModeInfoToValidate    MODEINFO ptr
;
; Returns:      AX = 0                  Continue Mode Validation
;               AX = 1                  Invalidate Mode
;
; Preserve:     ds,es,fs,ebx,esi,edi
;==============================================================================
DECPROC GN_CheckForOEMOverrides, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   lpLocalValMode
LOCALS  sEdidBuf,MAX_EDID_BUFFER_SIZE
LOCALD  dwEdidSze;
LOCALV  sModeInfo,MODEINFO
LOCALD  dwCheckedBothDisplayFlag
OPENPROC
        PUSHR   es,fs,ebx,esi,edi

        mov     esi,pGNLogdevCXOffset

        ; This routine returns TRUE if we want to exclude 1400x1050 when
        ; a 1400x1050 panel is not installed.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGet1400x1050Override,es,ax
        cmp     ax,1
        jne     CheckRestrictLargestMode
        
        ; Only allow 1400x1050 if we are on the SXGA+ panel (1400x1050 panel).
        ; First, check to see if the mode in question is 1400x1050. Then, read
        ; the EDID for DFP0 and check to see if the largest mode is 1400x1050.
        ; If so, PassMode, otherwise FailMode. 
        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,1400
        jne     CheckRestrictLargestMode
        cmp     es:[ebx].DISPVALMODE.dvmYRes,1050
        jne     CheckRestrictLargestMode

        ; Now read the EDID.
        mov     dwEdidSze,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        mov     eax,10000h              ; Device mask for DFP0
        push    eax
        mov     ax,ss
        shl     eax,10h
        lea     ax,sEdidBuf
        push    eax
        lea     ax,dwEdidSze
        push    eax
        call    HW_ReadEdidForDevice

        ; Make sure we read the EDID. If EAX != 0, then FailMode.
        or      eax,eax
        je      FailMode
        
        cmp     dwEdidSze,0
        je      FailMode

        ; Now get the largest mode for this EDID which will be the native
        ; mode of DFP0.
        mov     ax,ss
        shl     eax,10h
        lea     ax,sEdidBuf
        push    eax
        push    dwEdidSze
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetLargestEdidMode,es,ax

        sub     ebx,ebx
        lea     bx,sModeInfo
        cmp     ss:[ebx].MODEINFO.dwXRes,1400
        jne     FailMode
        cmp     ss:[ebx].MODEINFO.dwYRes,1050
        jne     FailMode
        
CheckRestrictLargestMode:
        ; This OEM Override is for OEMs who, in clone mode, only want
        ; modes up to the greatest EDID mode for the lesser display device.
        ; This is due to the fact tha they do not want panning.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetRestrictLargestMode,es,ax
        cmp     ax,1
        jne     CheckMaxDfpMode

        ; If not in clone mode, pass mode to standard validation.
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      CheckMaxDfpMode
        
        ; We are on restricted desktop system and in clone mode. Get the
        ; largest EDID modes for each display device and make sure the
        ; requested mode is less than or equal to the smaller of the two.
        mov     dwCheckedBothDisplayFlag,0
        
        ; Make sure there is an EDID for the primary. If not, check display
        ; type and use safe mode.
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        cmp     ds:[edi].GNCRTCCX.dwEdidSize,0
        je      NoEdidForDevice
        
        ; Get the largest EDID mode of the primary display.
        push    edi
        mov     ax,ss
        shl     eax,10h
        lea     ax,sModeInfo
        push    eax
        call    GN_GetLargestEdidMode

        ; Now, compare to see if the requested mode is greater than the
        ; maximum mode this EDID can handle.
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes

        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode

CheckSecondary:
        mov     dwCheckedBothDisplayFlag,1
        
        ; Make sure there is an EDID for the secondary. If not, check display
        ; type and use safe mode.
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        cmp     ds:[edi].GNCRTCCX.dwEdidSize,0
        je      NoEdidForDevice

        ; Now get the largest EDID mode for the clone device.
        push    edi
        mov     ax,ss
        shl     eax,10h
        lea     ax,sModeInfo
        push    eax
        call    GN_GetLargestEdidMode

        ; Now, compare to see if the requested mode is greater than the
        ; maximum mode this EDID can handle.
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes

        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode
        
        jmp     CheckMaxDfpMode

NoEdidForDevice:
        lea     ebx,[edi].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        cmp     al,DEVTYPE_TV
        je      UseMaxTvResolution

        ; There is no EDID and the display device is not a TV. Use 800x600
        ; as a safe mode.
        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,800
        jg      FailMode
        
        cmp     dwCheckedBothDisplayFlag,1
        jne     CheckSecondary
        
        jmp     CheckMaxDfpMode

UseMaxTvResolution:
        sub     ebx,ebx
        lfs     bx,ds:[edi].GNCRTCCX.lpNvmodeDispData
        mov     eax,fs:[ebx].DISPDATA.dwMaxTVOutResolution
        shr     eax,10h
        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode

        cmp     dwCheckedBothDisplayFlag,1
        jne     CheckSecondary
        
CheckMaxDfpMode:
        ; This OEM override is for OEMs who want to limit the maximum
        ; allowable mode for the DFP. First, check the display type to
        ; make sure this is a DFP.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     ebx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        cmp     al,DEVTYPE_DFP
        jne     PassMode
        
        ; Now check if the registry key MaxDfpMode exists. If so, the max
        ; DFP mode will be returned in sModeInfo.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10h
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetMaxDfpMode,es,ax
        
        cmp     ax,1
        jne     PassMode

        ; Now, compare to see if the requested mode is greater than the
        ; maximum mode for the DFP in the registry. Please note that Windows
        ; considers a mode greater if the XRes is greater.
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes

        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode

PassMode:
        mov     eax,0
        jmp     DoneIt

FailMode:
        mov     eax,1

DoneIt:

        POPR    es,fs,ebx,esi,edi
CLOSEPROC


CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNUTIL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnutil.asm
;
; Purpose:      This file holds services that the rest of the driver
;               commonly needs.
;==============================================================================
.586
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc
include escape.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_MemoryAlloc
;
; Purpose:      This function is called to purchase system memory.
;
; Arguments:    eax     amount of memory to purchase
;
; Returns:      eax     0       then failed
;                       non-0   then success
;                               In this case edx = selector to memory block
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MemoryAlloc, PASCAL, NOFRAME, FAR16
OPENPROC
        ; 2000H = GMEM_SHARE and 0040H = GMEM_ZEROINIT
        mov     edx,2040H
        push    dx
        push    eax
        call    GlobalAlloc
        sub     edx,edx
        or      ax,ax
        je      done

        ; Allocation was successful. Now lock the memory
        push    ax
        push    ax
        call    GlobalLock
        or      dx,dx
        jne     @F

        ; Lock failed so free the memory
        call    GlobalFree
        sub     edx,edx
        jmp     done
@@:
        ; Return edx = selector and ax nonzero to indicate success
        movzx   edx,dx
        pop     ax
done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_MemoryFree
;
; Purpose:      This function is called to free system memory.
;
; Arguments:    eax     selector of memory block to free
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MemoryFree, PASCAL, NOFRAME, FAR16
OPENPROC
        ; Get the handle corresponding to this selector
        push    ax
        call    GlobalHandle
        or      ax,ax
        je      done

        ; Unlock the memory block and free it
        push    ax
        push    ax
        call    GlobalUnlock
        call    GlobalFree
done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetSelectorBase
;
; Purpose:      This function is called to get the base of
;               a selector.
;
; Arguments:
;               dwSelector              Selctor to get base of
;
; Returns:
;               eax                     Linear Base of selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetSelectorBase, PASCAL, FRAME, FAR16
PARMD   dwSelector
OPENPROC
        push    word ptr dwSelector
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        mov     eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     GN_AllocSelectorAndNullIt
;
; Purpose:      This function allocates a selector and sets its base
;               and limit to zero.
;
; Arguments:    None
;
; Returns:      eax     selector if successful
;                       0        if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AllocSelectorAndNullIt, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   edi

        ; Alloc a selector
        mov     ax,cs
        push    ax
        call    AllocCSToDSAlias
        movzx   edi,ax
        or      eax,eax
        je      Done

        ; Set selector to be small, data, and read/write
        mov     eax,00010012H
        push    di
        push    eax
        call    SelectorAccessRights

        ; Set selector base to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorBase

        ; Set selector limit to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorLimit

        ; Return the selector
        mov     eax,edi
Done:
        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_AllocSelectorAndMapIt
;
; Purpose:      This function allocates a selector and sets its base
;               and limit to the values passed in. The selector is
;               always forced to be large, data, read/write.
;
; Arguments:    eax     0       then address in ebx is a physical address
;                       non-0   then address in ebx is a linear address
;               ebx     base address -- physical or linear based on eax
;               ecx     limit of selector
;
; Returns:      eax     selector if successful
;                       0        if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AllocSelectorAndMapIt, PASCAL, FRAME, FAR16
LOCALD  dwBase
LOCALD  dwLimit
LOCALW  wSelector
OPENPROC
        PUSHR   esi,edi

        mov     dwBase,ebx
        mov     dwLimit,ecx

        or      eax,eax
        jne     @F

        ; Convert the physical address to a linear address
        mov     cx,word ptr dwBase+0
        mov     bx,word ptr dwBase+2
        mov     di,word ptr dwLimit+0
        mov     si,word ptr dwLimit+2
        mov     eax,800H
        int     31H
        mov     eax,0
        jc      Done

        ; Call succeeded -- linear address is in bx:cx
        mov     word ptr dwBase+0,cx
        mov     word ptr dwBase+2,bx
@@:
        ; Get a selector
        call    GN_AllocSelectorAndNullIt
        or      eax,eax
        je      Done
        mov     wSelector,ax

        ; Set the selector to be large, data, read/write
        push    wSelector
        pushd   00008012H
        call    SelectorAccessRights

        ; Set the selector base
        push    wSelector
        push    dwBase
        call    SetSelectorBase

        ; Set the selector limit
        dec     dwLimit
        push    wSelector
        push    dwLimit
        call    SetSelectorLimit
        movzx   eax,wSelector
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_UnmapAndFreeSelector
;
; Purpose:      This function sets the mapping for a selector to be
;               small, data. read/write with a NULL base and limit and
;               then frees the selector.
;
; Arguments:    eax     selector to free
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_UnmapAndFreeSelector, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   edi

        ; Safety check
        or      eax,eax
        jz      Exit

        mov     edi,eax

        ; Set selector to be small, data, and read/write
        mov     eax,00010012H
        push    di
        push    eax
        call    SelectorAccessRights

        ; Set selector base to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorBase

        ; Set selector limit to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorLimit

        ; Free selector
        push    di
        call    FreeSelector

Exit:
        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDeviceLocalBasePath
;
; Purpose:      This function just gets the local base path for
;               the specified devnode.
;
; Arguments:
;               dwDevnodeHandle         Device Node handle
;               dwPathSel               sel:offset of place to store
;               dwPathOffset               the monitor registry path
;               dwDeviceNameSel         sel:offset of the device type
;               dwDeviceNameOffset      should be either "Display"
;                                       or "Monitor"
;
;
; Returns:
;               If this routine is successful then the first dword
;               pointed to by dwPathSel:dwPathOffset gets stuffed
;               with a constant HKEY like HKEY_LOCAL_MACHINE. All
;               bytes after that are a registry path inside the key
;               given in the first dword that are that local base
;               registry path for the given device.
;
;               ecx     SPECIFIC_DEVICE
;                       UNKNOWN_DEVICE
;                       PLUG_AND_PLAY_DEVICE
;
; Preserve:     ds,es,fs,esi,edi
;==============================================================================
szToDevice      DB      "System\CurrentControlSet\Services\Class\",0

USE_EBP TEXTEQU <1>

DECPROC GN_GetDeviceLocalBasePath, PASCAL, FRAME, FAR16
PARMD   dwDevnodeHandle
PARMD   dwPathSel
PARMD   dwPathOffset
PARMD   dwDeviceNameSel
PARMD   dwDeviceNameOffset
LOCALS  szPath,MAX_KEY_LEN
LOCALS  szDevice,MAX_KEY_LEN
LOCALS  szDeviceName,MAX_KEY_LEN
LOCALS  szDriver,16
LOCALS  szDeviceDesc,16
LOCALD  dwStackOffsetToDeviceName
LOCALD  hLocalKey
LOCALD  dwSize
LOCALD  dwUnknownDevice
OPENPROC
        PUSHR   alld,ds,es,fs
        mov     dwUnknownDevice,SPECIFIC_DEVICE

        ; Place "Enum\" into szPath
        mov     dword ptr szPath[0],'munE'
        mov     byte  ptr szPath[4],'\'

        cmp     dwDevnodeHandle,0
        je      SetDefaultPath

        ; Create a flat selector to all of memory
        mov     eax,1
        sub     ebx,ebx
        mov     ecx,0FFFFFFFEH
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      SetDefaultPath
        mov     fs,ax

        ; The second DWORD in the devnode structure is a ptr to
        ; a registry path string name.
        mov     eax,dwDevnodeHandle
        mov     edi,fs:[eax + 4]
        cmp     edi,0AAAAAAAAH
        je      SkipCopy

        ; Copy the string to local storage
        mov     ecx,5
@@:     mov     al,fs:[edi]
        inc     edi
        mov     szPath[ecx],al
        inc     ecx
        or      al,al
        jne     @B

SkipCopy:
        mov     ax,fs
        call    GN_UnmapAndFreeSelector
        cmp     edi,0AAAAAAAAH
        je      SetDefaultPath

        ; Open the key
        pushd   HKEY_LOCAL_MACHINE      ; hKey
        mov     ax,ss
        lea     ebx,szPath
        push    ax
        push    bx                      ; lpSubKey
        lea     ebx,hLocalKey
        push    ax
        push    bx                      ; phkResult
        call    RegCreateKey
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     SetDefaultPath

        ; Read the "Driver" string in this key. It should be equal
        ; to something like: "Display\0003"  or "Monitor\0001"
        ; Monitor or Display may be upper or lower case
        mov     dword ptr szDriver[0],'virD'
        mov     dword ptr szDriver[4],'re'
        sub     ecx,ecx
        mov     szDevice[0],cl
        mov     dwSize,128
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szDriver
        push    eax
        push    ecx
        push    ecx
        lea     ax,szDevice
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx

        ; Read the "DeviceDesc" string in this key. It should be equal
        ; to something like: "(Unknown Monitor)" or "Default Monitor".
        ; If it is, then we should flag it as an unknown device.
        mov     dword ptr szDeviceDesc[0],'iveD'
        mov     dword ptr szDeviceDesc[4],'eDec'
        mov     dword ptr szDeviceDesc[8],'cs'
        sub     ecx,ecx
        mov     szDeviceName[0],cl
        mov     dwSize,128
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szDeviceDesc
        push    eax
        push    ecx
        push    ecx
        lea     ax,szDeviceName
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx

        push    hLocalKey
        call    RegCloseKey

        cmp     byte ptr szDevice[0],0
        je      SetDefaultPath

MakePath:
        ; Let's build the final string. First,
        ; System\CurrentControlSet\Services\Class\
        mov     ds,dwPathSel
        mov     ebx,dwPathOffset
        mov     dword ptr ds:[ebx],HKEY_LOCAL_MACHINE
        add     ebx,4
        sub     ecx,ecx
@@:     mov     al,cs:szToDevice[ecx]
        inc     ecx
        mov     ds:[ebx],al
        inc     ebx
        or      al,al
        jne     @B

        ; Attach the device and number for something like
        ; System\CurrentControlSet\Services\Class\Display\0005
        dec     ebx
        sub     ecx,ecx
@@:     mov     al,szDevice[ecx]
        inc     ecx
        mov     ds:[ebx],al
        inc     ebx
        or      al,al
        jne     @B

        ; If DeviceDesc="(Unknown Monitor)" , then flag it.
        ; Windows 98 uses this string to indicate unknown monitors.
        sub     eax,eax
        cmp     dword ptr szDeviceName[0],'knU('
        jne     Check2
        cmp     dword ptr szDeviceName[4],'nwon'
        jne     Check2
        cmp     dword ptr szDeviceName[8],'noM '
        jne     Check2
        cmp     dword ptr szDeviceName[12],'roti'
        jne     Check2
        cmp     byte ptr szDeviceName[16],')'
        je      MarkAsUnknown

        ; If DeviceDesc="Default Monitor" , then flag it as unknown.
        ; Windows 98 SE2 uses this string to indicate unknown monitors.
Check2: cmp     dword ptr szDeviceName[0],'afeD'
        jne     Check3
        cmp     dword ptr szDeviceName[4],' tlu'
        jne     Check3
        cmp     dword ptr szDeviceName[8],'inoM'
        jne     Check3
        cmp     dword ptr szDeviceName[12],'rot'
        jne     Check3
        je      MarkAsUnknown

        ; If DeviceDesc="Plug and Play Monitor" , then flag it as
        ; an unknown monitor since no INF file is really installed.
Check3: sub     eax,eax
        cmp     dword ptr szDeviceName[0],'gulP'
        jne     Check4
        cmp     dword ptr szDeviceName[4],'dna '
        jne     Check4
        cmp     dword ptr szDeviceName[8],'alP '
        jne     Check4
        cmp     dword ptr szDeviceName[12],'oM y'
        jne     Check4
        cmp     dword ptr szDeviceName[16],'otin'
        jne     Check4
        cmp     byte ptr szDeviceName[20],'r'
        mov     dwUnknownDevice,PLUG_AND_PLAY_DEVICE

Check4: jmp     Done

MarkAsUnknown:
        mov     dwUnknownDevice,UNKNOWN_DEVICE
        jmp     Done

SetDefaultPath:
        mov     ds,dwDeviceNameSel
        mov     ecx,dwDeviceNameOffset
        sub     ebx,ebx
@@:     mov     al,ds:[ecx][ebx]
        mov     szDevice[ebx],al
        inc     ebx
        or      al,al
        jne     @B
        mov     dword ptr szDevice[ebx - 1],'000\'
        mov     dword ptr szDevice[ebx + 3],'0'
        mov     dwUnknownDevice,UNKNOWN_DEVICE
        jmp     MakePath

Done:
        POPR    alld,ds,es,fs
        mov     ecx,dwUnknownDevice
CLOSEPROC

;==============================================================================
;
; Function:     GN_CheckInterlacedStereoConnection
;
; Purpose:      This function determines if stereo is enabled and 
;               stereo connection type is interlaced (aka ASUS).
;
; Arguments:
;               None
;
;
; Returns:
;               If stereo is disabled or stereo connection type 
;               is not interlaced the function returns 0 otherwise
;               guess what? Absolutely right. Not zero.
;               bytes after that are a registry path inside the key
;
; Preserve:     ds,es,fs,esi,edi
;==============================================================================
szToStereo      DB      "Software\NVIDIA Corporation\Global\Stereo3D",0

DECPROC GN_CheckInterlacedStereoConnection, PASCAL, FRAME, FAR16
LOCALS  szSubKey,MAX_KEY_LEN
LOCALD  hLocalKey
LOCALD  dwSize
LOCALD  dwInterlacedStereo
LOCALD  dwValue
OPENPROC
        PUSHR   alld,ds,es,fs
        mov     dwInterlacedStereo,0

        ; Open the key
        pushd   HKEY_LOCAL_MACHINE      ; hKey
        mov     ax,cs
        lea     ebx,szToStereo
        push    ax
        push    bx                      ; lpSubKey
        lea     ebx,hLocalKey
        mov     ax,ss
        push    ax
        push    bx                      ; phkResult
        call    RegOpenKey
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done

        ; Read the "StereoEnable" string. If it is not 0 then stereo is enable
        ; Place "StereoEnable" into szSubKey
        mov     dword ptr szSubKey[ 0],'retS'
        mov     dword ptr szSubKey[ 4],'nEoe'
        mov     dword ptr szSubKey[ 8],'elba'
        mov     dword ptr szSubKey[12],0

        sub     ecx,ecx
        mov     dwValue, ecx
        mov     dwSize,4
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szSubKey
        push    eax
        push    ecx
        push    ecx
        lea     ax,dwValue
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done_And_Close

        cmp     dwValue,0
        je      Done_And_Close

        ; Read the "StereoViewerType" string. If it is STEREOCFG_INTERLACED then stereo is interlaced
        ; Place "StereoViewerType" into szSubKey
        mov     dword ptr szSubKey[ 0],'retS'
        mov     dword ptr szSubKey[ 4],'iVoe'
        mov     dword ptr szSubKey[ 8],'rewe'
        mov     dword ptr szSubKey[12],'epyT'
        mov     dword ptr szSubKey[16],0

        sub     ecx,ecx
        mov     dwValue, ecx
        mov     dwSize,4
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szSubKey
        push    eax
        push    ecx
        push    ecx
        lea     ax,dwValue
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done_And_Close

        cmp     dwValue,STEREOCFG_INTERLACED
        jne      Done_And_Close
        mov     dwInterlacedStereo,1

Done_And_Close:
        push    hLocalKey
        call    RegCloseKey

Done:
        POPR    alld,ds,es,fs
        mov     eax,dwInterlacedStereo
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSYSBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnsysblt.asm
;
; Purpose:      This file holds the routines to do Bitblt's involving
;               a source located in video memory and a dst located in
;               system memory. There may also be a pattern involved but
;               maybe not. The code is generic in terms of not touching
;               hardware, but it does make assumptions about hardware
;               capability and to some extent programming order. These
;               should all be fine for Nvidia products.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_BitBltSrcVramDstSystem
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a color video memory bitmap and the
;               dst is in system memory (color or mono). There may be
;               a pattern involved as well but there may not be.
;
; Arguments:
;               ds              Context Selector
;               pGNLogdevCXOffset  GNLOGDEVCX ptr
;               lpDstDev        Ptr to the dst device (DIBENG header)
;                               Can be NULL if the actual dst is really
;                               a DIB in which case the lpDstDib holds
;                               the real dst. Either lpDstDib or lpDstDev
;                               must be valid and the other must be NULL.
;               lpDstDib        Ptr to the dst Device (BitmapInfoHeader)
;                               Can be NULL if the actual dst is really
;                               a bitmap in which case lpDstDev holds
;                               the real dst. Either lpDstDib or lpDstDev
;                               must be valid and the other must be NULL.
;               dwDstLeft       left edge of the dst rectangle
;               dwDstTop        top  edge of the dst rectangle
;               dwSrcBitsSel    selector to the src bits
;               dwSrcBitsOffset offset to the start of the source bits
;               dwSrcBpp        Bits Per Pixel in the src image
;                               This can be 4, 8, 15, 16, 24, or 32
;               dwSrcPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwSrcLeft       left edge of the src rectangle
;               dwSrcLeft       top  edge of the src rectangle
;               dwExtX          extent of the src (and dst) rectangle.
;               dwExtY          extent of the src (and dst) rectangle.
;               dwRop3          3-operand rop
;               lpBrush         ptr to a DIB_Brush struct
;               lpDrawMode      This is only needed for the case where
;                               the rop involves a brhs and the brush
;                               is a mono pattern. In this case,
;                               DRAWMODE.TextColor specifies the color
;                               to which to translate src 0 bits, and
;                               DRAWMODE.bkColor specifies the color
;                               to which to translate src 1 bits. Note
;                               that these are not the same colors used
;                               translate 0 and 1 bits from the src
;                               bitmap.
;               pfnCopyXlat     If this argument is not NULL then it is
;                               the correct inner loop to use. If it is
;                               NULL, then the DIBENG should be used.
;
; Returns:      eax     0       The routine will be punted to software
;                       else    the return code to GDI
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_BitBltSrcVramDstSystem, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   lpDstDev
PARMD   lpDstDib
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   lpSrcDev
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   pfnCopyXlat

LOCALD  pHWLogdevCXOffset
LOCALD  pHWBoardCXOffset
LOCALD  dwScreenPalettized
LOCALD  dwSrcBufferPitch
LOCALD  dwMaxScansPerTransfer
LOCALD  dwDstBltOffset
LOCALD  dwScansRemaining
LOCALD  dwSrcTopOffset
LOCALD  dwSrcWrapWidth
LOCALD  dwDstWrapWidth
LOCALD  dwUseDibeng
LOCALD  lpDMASrcDev
LOCALD  lpDMADstDev
LOCALS  dwBlockTop,8
LOCALS  dwBlockHeight,8
LOCALS  dwBlockTransferInitiated,8
LOCALS  dwBlockOffset,8
LOCALV  sSrcPDevice,DIBENGINEHDR
LOCALV  sDstPDevice,DIBENGINEHDR
OPENPROC
        PUSHR   ds,esi,edi
        mov     esi,pGNLogdevCXOffset
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        mov     pHWLogdevCXOffset,eax
        mov     eax,ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     pHWBoardCXOffset,eax
        test    ds:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTIZED
        setne   al
        movzx   eax,al
        mov     dwScreenPalettized,eax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Tell the hardware specific code the src bitmap with which
        ; we will be working and have it return some important data.
        push    pHWLogdevCXOffset
        push    dwSrcBitsSel
        push    dwSrcBitsOffset
        push    dwSrcBpp
        push    dwSrcPitch
        push    dwSrcLeft
        push    dwExtX
        call    HW_BeginSrcVramDstSystem
        or      eax,eax
        je      ExitIt
        mov     dwSrcBufferPitch,ebx
        mov     dwMaxScansPerTransfer,ecx

        ; At this point, the generic and hardware code are linked
        ; until the HW_EndSrcVramDstSystem routine is called.
        ; The generic code has agreed not to touch fs -- it is the
        ; hardware's selector for whatever purposes it may need.
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; For each chunk of the bitmap we DMA back, we need to rop it
        ; in with the destination. If the caller passed in a non-NULL
        ; pfnCopyXlat, then it is the routine to use to do the ropping.
        ; Otherwise, we will use the DIBENG to do the ropping.
        push    OFFSET SetupDone
        cmp     pfnCopyXlat,0
        jne     OurRopSetup
        jmp     DibengRopSetup
SetupDone:

        sub     ebx,ebx
        mov     dword ptr dwBlockTransferInitiated[ebx * 4 + 0],0
        mov     dword ptr dwBlockTransferInitiated[ebx * 4 + 4],0
        mov     eax,dwExtY
        mov     dwScansRemaining,eax
        mov     dwSrcTopOffset,ebx

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Enter the following code with ebx = to 0 or 1. ebx is the
        ; ID of which of two ping pong buffers in the DMA transfer
        ; area we are currently using. It doesn't matter which one
        ; you start with -- this inner loop will toggle it for you.
LoopY:
        ; Compute the smaller of:
        ; 1) As many scans as the hardware can
        ; 2) The number of scans remaining to process
        ; Save off the coords of the block we will be DMAing back
        mov     eax,dwMaxScansPerTransfer
        cmp     eax,dwScansRemaining
        jl      @F
        mov     eax,dwScansRemaining
@@:     sub     dwScansRemaining,eax
        or      eax,eax
        je      DoneXfer
        mov     ecx,dwSrcTopOffset
        mov     dword ptr dwBlockHeight[ebx * 4],eax
        mov     dword ptr dwBlockTop[ebx * 4],ecx
        mov     dword ptr dwBlockTransferInitiated[ebx * 4],1
        lea     edx,[eax + ecx]
        mov     dwSrcTopOffset,edx

        ; DMA back what we have computed as the Block rectangle
        push    pHWBoardCXOffset
        push    dwSrcBitsOffset
        push    dwSrcBpp
        push    dwSrcPitch
        push    dwSrcLeft
        add     ecx,dwSrcTop
        push    ecx
        push    dwExtX
        push    eax
        call    HW_BlockSrcVramDstSystem
        mov     dword ptr dwBlockOffset[ebx * 4],ecx

DoneXfer:
        ; Flip to the other block
        xor     ebx,1

        ; Call the hardware specific code to wait for the other block
        ; (the one we did not just issue the transfer for immediately
        ; above) to complete. The first time through, there will be
        ; no "other" block that has yet been transfered, so skip the
        ; waiting and the copy.
        cmp     dword ptr dwBlockTransferInitiated[ebx * 4],0
        je      DoneCopy
        mov     dword ptr dwBlockTransferInitiated[ebx * 4],0
        mov     edx,pHWBoardCXOffset
        call    HW_WaitSrcVramDstSystem

        ; Now call the appropriate routine to handle the Blt for the Block
        cmp     dwUseDibeng,0
        jne     UseDibeng

        ; Using our own internal routines -- faster but only handle
        ; SrcCopy from any color depth to any other.
        push    ebx
        mov     esi,dword ptr dwBlockOffset[ebx * 4]
        mov     edi,dwDstBltOffset
        push    dwExtX
        push    dword ptr dwBlockHeight[ebx * 4]
        push    dwSrcWrapWidth
        push    dwDstWrapWidth
        call    NEAR PTR pfnCopyXlat
        mov     dwDstBltOffset,edi
        pop     ebx

DoneCopy:
        ; We know we are done when there are no active transfers
        mov     eax,dword ptr dwBlockTransferInitiated[0 * 4]
        or      eax,dword ptr dwBlockTransferInitiated[1 * 4]
        jne     LoopY
        jmp     DoneLoop

UseDibeng:
        call    RopBackWithDibeng
        jmp     DoneCopy

DoneLoop:
        ; Let the hardware know we are done
        mov     edx,pHWBoardCXOffset
        call    HW_EndSrcVramDstSystem
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DoneIt:
        mov     eax,1
ExitIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     OurRopSetup
;
; Purpose:      This function is called when we will be using some of
;               our own private routines to do the ropping of data that
;               has been DMAed back from the screen. It sets up some
;               variables that are needed for our inner loop.
;
; Arguments:    stack frame for GN_BitBltSrcVramDstSystem
;               ds      Context Selector
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
PUBLIC  OurRopSetup
OurRopSetup     PROC    NEAR

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Setup variables that we know our pfnCopyXlat routine needs.
        ; Compute the dst addresses. For dst that are multiples of a
        ; byte/pixel, the addresses will be byte addresses. For 4bpp,
        ; addresses will be nibble addresses. For 1bpp, bit addresses.
OurSetup:
        mov     dwUseDibeng,0
        mov     eax,dwDstPitch
        mov     edx,dwDstTop
        imul    edx,eax
        add     edx,dwDstBitsOffset
        mov     es,word ptr dwDstBitsSel

        mov     ecx,dwDstBpp
        mov     ebx,dwExtX
        cmp     ecx,4
        je      Is4
        jc      Is1
Is8orM:
        inc     ecx
        and     ecx,NOT 1
        shr     ecx,3
        imul    ebx,ecx
        sub     eax,ebx
        imul    ecx,dwDstLeft
        add     edx,ecx
        jmp     @F
Is4:
        add     eax,eax
        add     edx,edx
        sub     eax,ebx
        add     edx,dwDstLeft
        jmp     @F
Is1:
        shl     eax,3
        shl     edx,3
        sub     eax,ebx
        add     edx,dwDstLeft
@@:
        mov     dwDstWrapWidth,eax
        mov     dwDstBltOffset,edx

        ; Compute the src wrap width
        mov     eax,dwSrcBufferPitch
        mov     ecx,dwSrcBpp
        inc     ecx
        and     ecx,NOT 1
        shr     ecx,3
        imul    ecx,dwExtX
        sub     eax,ecx
        mov     dwSrcWrapWidth,eax
        ret

OurRopSetup     ENDP


;==============================================================================
;
; Function:     DibengRopSetup
;
; Purpose:      This function is called when the Dibeng will be used
;               to do the ropping of data that has been DMAed back from
;               the screen. It sets up some variables that are needed
;               by either DIB_BitBlt or DIB_DibBlt, one of which will
;               be called by the BitBltSrcVramDstSystem interleaved
;               with calls to the DMA routine. The Dibeng routines
;               need a DIBENGINEHDR structure created that describes
;               the DMA transfer area since that will be the source
;               as far as the DIBENG is concerned.
;
; Arguments:    stack frame for GN_BitBltSrcVramDstSystem
;               ds      Context Selector
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
PUBLIC  DibengRopSetup
DibengRopSetup  PROC    NEAR

        ; We need a DEVICE descriptor for the src which, as far
        ; as the DIBENG is concerned will be the DMA transfer region.
        mov     dwUseDibeng,1
        sub     esi,esi
        les     si,lpSrcDev
        mov     sSrcPDevice.deType,TYPE_DIBENG
        mov     eax,dwExtX
        mov     ebx,dwExtY
        mov     ecx,dwSrcBpp
        inc     ecx
        shr     ecx,3
        imul    ecx,eax
        mov     sSrcPDevice.deWidth,ax
        mov     sSrcPDevice.deHeight,bx
        mov     eax,dword ptr es:[esi].DIBENGINE.deWidthBytes
        mov     ax,cx
        mov     dword ptr sSrcPDevice.deWidthBytes,eax
        mov     eax,dwSrcBufferPitch
        mov     sSrcPDevice.deDeltaScan,eax
        mov     eax,cs:[CSlp16LogDevice]
        mov     sSrcPDevice.delpPDevice,eax
;       mov     dword ptr sSrcPDevice.deBits,           ; Filled in later
        mov     word ptr sSrcPDevice.deBitsSelector,ds
        mov     eax,dword ptr es:[esi].DIBENGINE.deFlags
        and     eax,NOT (VRAM OR OFFSCREEN OR BUSY)
        test    eax,PALETTE_XLAT
        jz      @F
        or      eax,VRAM
@@:
        mov     dword ptr sSrcPDevice.deFlags,eax
        mov     eax,es:[esi].DIBENGINE.deBitmapInfo
        mov     sSrcPDevice.deBitmapInfo,eax
        sub     eax,eax
        ; The bRealBpp field is not needed for this temporary device
        mov     dword ptr sSrcPDevice.bRealBpp,eax
        mov     sSrcPDevice.deBeginAccess,eax
        mov     sSrcPDevice.deEndAccess,eax
        mov     ax,ss
        lea     esi,sSrcPDevice
        shl     eax,10H
        mov     ax,si
        mov     lpDMASrcDev,eax

        mov     eax,lpDstDev
        or      eax,eax
        jne     @F
        mov     eax,lpDstDib
@@:     mov     lpDMADstDev,eax
        ret

DibengRopSetup  ENDP


;==============================================================================
;
; Function:     RopBackWithDibeng
;
; Purpose:      This function is called when the Dibeng should be called
;               to take the data transferred back from the screen, which
;               is now in the DMA transfer region in system memory, and
;               use it as the src in the blt which needs to happen.
;               Based upon whether the caller gave us an lpDstDev or an
;               lpDstDib argument to GN_BitBltSrcVramDstSystem we will
;               call DIB_BitBlt or DIB_DibBlt respectively.
;
; Arguments:    stack frame for GN_BitBltSrcVramDstSystem
;
; Returns:      None
;
; Preserve:     ds,ebx
;==============================================================================
PUBLIC  RopBackWithDibeng
RopBackWithDibeng       PROC    NEAR

        mov     eax,dword ptr dwBlockOffset[ebx * 4]
        mov     dword ptr sSrcPDevice.deBitsOffset,eax

        ; We are using the DIBENG, so we will call either BitBlt or
        ; DibBlt. The src is definitely a bitmap (it is a bitmap in
        ; VRAM, right? -- that's why we are in this routine). The dst
        ; can either be a DIB or a bitmap. Call BitBlt if it is a
        ; bitmap and DibBlt if it is a DIB.
        cmp     lpDstDev,0
        je      UseDibBlt

        PUSHR   ebx
        push    lpDMADstDev
        push    word ptr dwDstLeft
        mov     eax,dwDstTop
        add     eax,dword ptr dwBlockTop[ebx * 4]
        push    ax
        push    lpDMASrcDev
        sub     eax,eax
        push    eax
        mov     eax,dwExtX
        mov     ecx,dword ptr dwBlockHeight[ebx * 4]
        push    ax
        push    cx
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        call    DIB_BitBlt
        POPR    ebx
        ret

UseDibBlt:
IF 1
        PUSHR   ds,ebx

        ; Conceptually, the important things are:
        ; iStart = BlockTop
        ; DIBBitsPtr = abs(dwDstPitch * dwBlockTop) + dwDstBitsOffset
        ; But we have to adjust the DIBBitsPtr since we can only pass
        ; 16:16 ptrs to the DIBENG. See comments later about tiling.

        ; We need to make some adjustments. Conceptually
        ; DIBBitsPtr = dwDstBitsOffset + (BlockTop + BlockHeight) * DibPitch
        ; DibHeightInHdr temporarily becomes BlockHeight
        ;
        ; The only problem is that DIBBitsPtr might be >= 64K which
        ; means we will need to adjust the selector appropriately ...
        sub     esi,esi
        lds     si,lpDMADstDev

        ; First save the current DIB Height and reset it to the band height
        push    ds:[esi].BitmapInfoHeader.biHeight
        cmp     ds:[esi].BitmapInfoHeader.biHeight,0
        jg      positive_height

        ; Negative DIB Height
        mov     ecx,dword ptr dwBlockHeight[ebx * 4]
        neg     ecx
        mov     ds:[esi].BitmapInfoHeader.biHeight,ecx
        neg     ecx

        ; Compute the DIBBitsPtr
        sub     edx,edx
        mov     eax,dword ptr dwBlockTop[ebx * 4]
        imul    eax,dwDstPitch
        add     eax,dwDstBitsOffset
        jmp     neg_continue

positive_height:
        mov     ecx,dword ptr dwBlockHeight[ebx * 4]
        mov     ds:[esi].BitmapInfoHeader.biHeight,ecx

        ; Compute the DIBBitsPtr
        sub     edx,edx
        mov     eax,dword ptr dwBlockTop[ebx * 4]
        add     eax,ecx
        dec     eax
        imul    eax,dwDstPitch
        add     eax,dwDstBitsOffset

        ; The offset is >= 64K. Windows will have tiled the selectors
        ; so we can just add 8 to the selector for every multiple we
        ; are over 64K.
neg_continue:
        test    eax,0FFFF0000H
        jz      @F
        shld    edx,eax,10H + 3
        and     edx,NOT 7
@@:     add     edx,dwDstBitsSel

        push    lpDMASrcDev
        pushd   10000H
        push    cx
        push    dx
        push    ax
        push    lpDMADstDev
        push    lpDrawMode
        xor     eax,eax
        push    eax
        push    word ptr dwScreenPalettized
        call    DIB_DibBltExt

        ; Restore the real dib height
        pop     ds:[esi].BitmapInfoHeader.biHeight
        POPR    ds,ebx
        ret
ENDIF

RopBackWithDibeng       ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNTHK16.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnblt.asm
;
; Purpose:      This file holds the 16 bit entry point for compatibility
;               with some old apps that patch display driver entry points
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

ReserveForPatch	macro name
	nop
	nop
	nop
	nop
	nop
public	Patch_&name&
Patch_&name&	proc	FAR16
Patch_&name&	endp
        jmp     GENERIC_&name&
	endm

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

PUBLIC  wLog, wBreak16
wLog                    DW      1
wBreak16                DW      0

;==============================================================================
;
; Function:     Bitblt
;
; Purpose:      This function is the 16 Bit BitBlt display driver
;               entry point. It jumps to the real 32 Bit BitBlt to
;               do all the work.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC BitBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	BitBlt
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor
;
; Purpose:      This function is the 16 Bit SetCursor display driver
;               entry point. It jumps to the real 32 Bit SetCursor to
;               do all the work.
;
; Arguments:    SetCursor Display Driver Stack Frame
;
;==============================================================================
DECPROC SetCursor, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_SetCursor
CLOSEPROC


;==============================================================================
;
; Function:     MoveCursor
;
; Purpose:      This function is the 16 Bit MoveCursor display driver
;               entry point. It jumps to the real 32 Bit MoveCursor to
;               do all the work.
;
; Arguments:    MoveCursor Display Driver Stack Frame
;
;==============================================================================
DECPROC MoveCursor, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_MoveCursor
CLOSEPROC


;==============================================================================
;
; Function:     SetPalette
;
; Purpose:      This function is the 16 Bit SetPalette display driver
;               entry point. It jumps to the real 32 Bit SetPalette to
;               do all the work.
;
; Arguments:    SetPalette Display Driver Stack Frame
;
;==============================================================================
DECPROC SetPalette, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	SetPalette
CLOSEPROC

;==============================================================================
;
; Function:     BitmapBits
;
; Purpose:      This function is the 16 Bit BitmapBits display driver
;               entry point. It jumps to the real 32 Bit BitmapBits to
;               do all the work.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
DECPROC BitmapBits, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	BitmapBits
CLOSEPROC

;==============================================================================
;
; Function:     Control
;
; Purpose:      This function is the 16 Bit Control display driver
;               entry point. It jumps to the real 32 Bit Control to
;               do all the work.
;
; Arguments:    Control Display Driver Stack Frame
;
;==============================================================================
DECPROC Control, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_Control
CLOSEPROC

;==============================================================================
;
; Function:     ExtTextOut
;
; Purpose:      This function is the 16 Bit ExtTextOut display driver
;               entry point. It jumps to the real 32 Bit ExtTextOut to
;               do all the work.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;
;==============================================================================
DECPROC ExtTextOut, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	ExtTextOut
CLOSEPROC

;==============================================================================
;
; Function:     DibBlt
;
; Purpose:      This function is the 16 Bit DibBlt display driver
;               entry point. It jumps to the real 32 Bit DibBlt to
;               do all the work.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC DibBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	DibBlt
CLOSEPROC

;==============================================================================
;
; Function:     FastBorder
;
; Purpose:      This function is the 16 Bit FastBorder display driver
;               entry point.
;
; Arguments:    FastBorder Display Driver Stack Frame
;
;==============================================================================
DECPROC FastBorder, PASCAL, NOFRAME, FAR16
OPENPROC
        sub     eax,eax
        retf	1CH
CLOSEPROC

;==============================================================================
;
; Function:     Output
;
; Purpose:      This function is the 16 Bit Output display driver
;               entry point. It jumps to the real 32 Bit Output to
;               do all the work.
;
; Arguments:    Output Display Driver Stack Frame
;
;==============================================================================
DECPROC Output, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	Output
CLOSEPROC

;==============================================================================
;
; Function:     Pixel
;
; Purpose:      This function is the 16 Bit Pixel display driver
;               entry point. It jumps to the real 32 Bit Pixel to
;               do all the work.
;
; Arguments:    Pixel Display Driver Stack Frame
;
;==============================================================================
DECPROC Pixel, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	Pixel
CLOSEPROC

;==============================================================================
;
; Function:     RealizeObject
;
; Purpose:      This function is the 16 Bit RealizeObject display driver
;               entry point. It jumps to the real 32 Bit RealizeObject to
;               do all the work.
;
; Arguments:    RealizeObject Display Driver Stack Frame
;
;==============================================================================
DECPROC RealizeObject, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	RealizeObject
CLOSEPROC

;==============================================================================
;
; Function:     ReEnable
;
; Purpose:      This function is the 16 Bit ReEnable display driver
;               entry point. It jumps to the real 32 Bit ReEnable to
;               do all the work.
;
; Arguments:    ReEnable Display Driver Stack Frame
;
;==============================================================================
DECPROC ReEnable, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_ReEnable
CLOSEPROC

;==============================================================================
;
; Function:     ScanLR
;
; Purpose:      This function is the 16 Bit ScanLR display driver
;               entry point. It jumps to the real 32 Bit ScanLR to
;               do all the work.
;
; Arguments:    ScanLR Display Driver Stack Frame
;
;==============================================================================
DECPROC ScanLR, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	ScanLR
CLOSEPROC

;==============================================================================
;
; Function:     SetDIBitsToDevice
;
; Purpose:      This function is the 16 Bit SetDIBitsToDevice display driver
;               entry point. It jumps to the real 32 Bit SetDIBitsToDevice to
;               do all the work.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
;==============================================================================
DECPROC SetDIBitsToDevice, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	SetDIBitsToDevice
CLOSEPROC

;==============================================================================
;
; Function:     SetPaletteTranslate
;
; Purpose:      This function is the 16 Bit SetPaletteTranslate display driver
;               entry point. It jumps to the real 32 Bit SetPaletteTranslate to
;               do all the work.
;
; Arguments:    SetPaletteTranslate Display Driver Stack Frame
;
;==============================================================================
DECPROC SetPaletteTranslate, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_SetPaletteTranslate
CLOSEPROC

;==============================================================================
;
; Function:     StrBlt
;
; Purpose:      This function is the 16 Bit StrBlt display driver
;               entry point. It jumps to the real 32 Bit StrBlt to
;               do all the work.
;
; Arguments:    StrBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC StrBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	StrBlt
CLOSEPROC

;==============================================================================
;
; Function:     StretchBlt
;
; Purpose:      This function is the 16 Bit StretchBlt display driver
;               entry point. It jumps to the real 32 Bit StretchBlt to
;               do all the work.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC StretchBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	StretchBlt
CLOSEPROC

;==============================================================================
;
; Function:     StretchDIBits
;
; Purpose:      This function is the 16 Bit StretchDIBits display driver
;               entry point. It jumps to the real 32 Bit StretchDIBits to
;               do all the work.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
;==============================================================================
DECPROC StretchDIBits, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	StretchDIBits
CLOSEPROC


;==============================================================================
;
; Function:     SaveScreenBitmap
;
; Purpose:      This function is the 16 Bit SaveScreenBitmap display driver
;               entry point. It jumps to the real 32 Bit SaveScreenBitmap to
;               do all the work.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
;==============================================================================
DECPROC SaveScreenBitmap, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	SaveScreenBitmap
CLOSEPROC

;==============================================================================
;
; Function:     UpdateColors
;
; Purpose:      This function is the 16 Bit UpdateColors display driver
;               entry point. It jumps to the real 32 Bit UpdateColors to
;               do all the work.
;
; Arguments:    UpdateColors Display Driver Stack Frame
;
;==============================================================================
DECPROC UpdateColors, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	UpdateColors
CLOSEPROC

IFDEF DEBUG
;==============================================================================
;
; Function:     GENERIC_OutputDebugString
;
; Purpose:      This function checks a global logging variable and then
;               calls OutputDebugString if logging is enabled.
;
;               DO NOT USE the DECPROC macro to define this routine.
;               The DECPROC macro logs when in debug mode. The logging
;               calls this routine. We will nest until the stack
;               overflows.
;
; Arguments:    16:16 ptr to string to print
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
PUBLIC  GENERIC_OutputDebugString
GENERIC_OutputDebugString       PROC    FAR16

        cmp     cs:[wLog],0
        je      DoneIt

        push    bp
        mov     bp,sp
        PUSHR   alld,ds,es,fs,gs
        push    dword ptr ss:[bp + 06H]
        call    OutputDebugString
        POPR    alld,ds,es,fs,gs
        pop     bp
DoneIt:
        retf    4

GENERIC_OutputDebugString       ENDP
ENDIF

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSTUB.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnstub.asm
;
; Purpose:      This file holds all the display driver entry points
;               that we just end up punting to the DIBENG or returning
;               true or false -- all the stubs basically.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_GetCharWidth
;
; Purpose:      This function is the GetCharWidth display driver entry point.
;
;==============================================================================
DECPROC GENERIC_GetCharWidth, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   lpBuffer
;PARMW   wFirstChar
;PARMW   wLastChar
;PARMD   lpFontInfo
;PARMD   lpDrawMode
;PARMD   lpTextXForm
OPENPROC
        jmp     DIB_GetCharWidth
CLOSEPROC

IF 0
;==============================================================================
;
; Function:     GENERIC_ColorInfo
;
; Purpose:      This function is the ColorInfo display driver entry point.
;
;==============================================================================
DECPROC GENERIC_ColorInfo, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   dwColorIn
;PARMD   lpPhysColor
OPENPROC
        jmp     DIB_ColorInfo
CLOSEPROC
ENDIF

;==============================================================================
;
; Function:     GENERIC_DeviceBitmap
;
; Purpose:      This function is the DeviceBitmap display driver entry point.
;
; Returns:      Always return 0.
;
;==============================================================================
DECPROC GENERIC_DeviceBitmap, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wCommand
;PARMD   lpBitmap
;PARMD   lpBits
OPENPROC
        sub     eax,eax
        RETFAR16  0EH
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_EnumDFonts
;
; Purpose:      This function is the EnumDFonts display driver entry point.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GENERIC_EnumDFonts, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   lpFaceName
;PARMD   lpfnCallback
;PARMD   lpClinetData
OPENPROC
        mov     eax,1
        RETFAR16  10H
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_EnumObj
;
; Purpose:      This function is the EnumObj display driver entry point.
;
;==============================================================================
DECPROC GENERIC_EnumObj, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   lpFaceName
;PARMD   lpfnCallback
;PARMD   lpClinetData
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_EnumObjExt
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_FastBorder
;
; Purpose:      This function is the FastBorder display driver entry point.
;
; Returns:      Return 0 so GDI will simulate via BitBlt.
;
;==============================================================================
DECPROC GENERIC_FastBorder, PASCAL, NOFRAME, FAR16
;PARMD   lpRect
;PARMW   wHorzBorderThick
;PARMW   wVertBorderThick
;PARMD   dwRop
;PARMD   lpDstDev
;PARMD   lpBrush
;PARMD   lpDrawMode
;PARMD   lpClipRect
OPENPROC
        sub     eax,eax
        RETFAR16  1CH
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_GetPalette
;
; Purpose:      This function is the GetPalette display driver entry point.
;
;==============================================================================
DECPROC GENERIC_GetPalette, PASCAL, NOFRAME, FAR16
;PARMW   wStartIndex
;PARMW   wNumEntries
;PARMD   lpPalette
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_GetPaletteExt
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_GetPaletteTranslate
;
; Purpose:      This function is the GetPaletteTranslate display driver entry
;               point.
;
;==============================================================================
DECPROC GENERIC_GetPaletteTranslate, PASCAL, NOFRAME, FAR16
;PARMD   lpTranslate
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_GetPaletteTranslateExt
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_Inquire
;
; Purpose:      This function is the Inquire display driver entry point.
;
;==============================================================================
DECPROC GENERIC_Inquire, PASCAL, NOFRAME, FAR16
;PARMD   lpCursorInfo
OPENPROC
        jmp     DIB_Inquire
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_ScanLR
;
; Purpose:      This function is the ScanLR display driver entry point.
;
;==============================================================================
DECPROC GENERIC_ScanLR, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wX
;PARMW   wY
;PARMD   dwPhysColor
;PARMW   wStyle
OPENPROC
        jmp     DIB_ScanLR
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_SelectBitmap
;
; Purpose:      This function is the SelectBitmap display driver entry point.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GENERIC_SelectBitmap, PASCAL, NOFRAME, FAR16
;PARMD   lpDevice
;PARMD   lpPrevBitmap
;PARMD   lpBitmap
;PARMD   dwFlags
OPENPROC
        mov     eax,1
        RETFAR16  10H
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_SetAttribute
;
; Purpose:      This function is the SetAttribute display driver entry point.
;
; Returns:      Always return 0.
;
;==============================================================================
DECPROC GENERIC_SetAttribute, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wStateNum
;PARMW   wIndex
;PARMD   dwAttribute
OPENPROC
        sub     eax,eax
        RETFAR16  0CH
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_Strblt
;
; Purpose:      This function is the Strblt display driver entry point.
;
; Arguments:
;
; Returns:      This function pushes some additional parameters and
;               jumps to the ExtTextOut function. See ExtTextOut for
;               appropiate return values.
;
;==============================================================================
DECPROC GENERIC_Strblt, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wDstX
;PARMW   wDstY
;PARMD   lpClipRect
;PARMD   lpString
;PARMW   wCount
;PARMD   lpFontInfo
;PARMD   lpDrawMode
;PARMD   lpTextXForm
OPENPROC
        sub     ebx,ebx
        pop     eax
        push    ebx
        push    ebx
        push    bx
        push    eax
        jmp     GENERIC_ExtTextOut
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnwrap.asm ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnwrap.asm
;
; Purpose:      This file holds the entry points to drawing functions
;		that may require cursor exclusion / unexclusion. The
;		idea is to see if exclusion is necessary. If not jump
;		to the real code. If it is, then do the exclusion,
;		call the real code, do the unexclusion and return.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incOutput = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

IsItScreen	MACRO	bm,jump
	cmp	bm.DIBENGINE.deType,0
	je	jump
	mov	ax,bm.DIBENGINE.deFlags
	and	ax,VRAM + OFFSCREEN + PALETTE_XLAT
	cmp	ax,VRAM
	jne	jump
	cmp	bm.DIBENGINE.deBeginAccess,0
	je	jump
	ENDM

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     BitBlt_WithExclude
;
; Purpose:      This function is the BitBlt display driver entry point
;		when we are running a software cursor.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC BitBlt_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wExtX
PARMW   wExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

if 0;!!
	; Check the rop and see what type of exclusion to check for
        movzx   bx,byte ptr [dwRop3 + 2]
	mov	ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
	mov	es,ax
        movzx  	ax,es:Rop3Table[bx]
        cmp	ax,PAD
        jae	SrcAndDstCheck
else
	cmp	lpSrcDev,0
	jne	SrcAndDstCheck
endif

JustDstCheck:
	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

JustDst:
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wDstX
	mov	cx,wDstY
	push	ax
	push	cx
	add	ax,wExtX
	add	cx,wExtY
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude

SrcAndDstCheck:
	; See if we have to exclude the src rectangle also
	lfs	si,lpSrcDev
	IsItScreen fs:[si],JustDstCheck

	; Clip the src rect
	call	BitBlt_ClipSrc
	or	ax,ax
	mov	ax,1
	je	DoneIt

	; We have to do the src rect.  How about the dst?
	les	bx,lpDstDev
	IsItScreen es:[bx],JustSrc

SrcAndDst:
	; We need to exclude based on both the src and dst rectangles
        push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wDstX
	mov	si,wSrcX
	mov	cx,wDstY
	mov	dx,wSrcY

	; Order the src and dst X,Y coordinates
	cmp	ax,si
	jc	@F
	xchg	ax,si
@@:	cmp	cx,dx
	jc	@F
	xchg	cx,dx
@@:
	push	ax
	push	cx

	add	si,wExtX
	add	dx,wExtY
	push	si
	push	dx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude

JustSrc:
        push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wSrcX
	mov	cx,wSrcY
	push	ax
	push	cx
	add	ax,wExtX
	add	cx,wExtY
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR fs:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	lpSrcDev
	push	wSrcX
	push	wSrcY
	push	wExtX
	push	wExtY
	push	dwRop3
	push	lpBrush
	push	lpDrawMode

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_BitBlt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_BitBlt

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     BitBlt_ClipSrc
;
; Purpose:      This function clips the src adjusting the stack parameters
;               for BitBlt appropriately to represent the clipped coords
;               and clipped extents.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               fs:si  lpSrcDev
;
; Returns:      eax     1 - there is something to draw
;                       0 - there is nothing to draw
;
; Preserve:     ds,esi,es,edi,fs
;==============================================================================
PUBLIC  BitBlt_ClipSrc
BitBlt_ClipSrc	PROC    NEAR

        mov   	ax,wSrcX
        mov   	cx,wSrcY
        mov   	bx,fs:[si].DIBENGINE.deWidth
        mov   	dx,fs:[si].DIBENGINE.deHeight
        or      ax,ax
        js      ClipLeft
cld1:   or      cx,cx
        js      ClipTop
clt:    add     ax,wExtX
        add     cx,wExtY
        sub     ax,bx
        jg      ClipRight
clr:    sub     cx,dx
        jg      ClipBottom
clb:    mov     ax,1
        ret

ClipLeft:
        add     wExtX,ax
        jle     ClipDone
        sub     wDstX,ax
        sub     ax,ax
        mov     wSrcX,ax
        jmp     cld1

ClipTop:
        add     wExtY,cx
        jle     ClipDone
        sub     wDstY,cx
        sub     cx,cx
        mov     wSrcY,cx
        jmp     clt

ClipRight:
        sub     wExtX,ax
        jg      clr
        jmp     ClipDone

ClipBottom:
        sub     wExtY,cx
        jg      clb

ClipDone:
        sub     ax,ax
        ret

BitBlt_ClipSrc	ENDP


;==============================================================================
;
; Function:     BitmapBits_WithExclude
;
; Purpose:      This function is the BitmapBits display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;
;==============================================================================
DECPROC BitmapBits_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMD   dwFlags
PARMD   dwCount
PARMD   lpBits
OPENPROC
	PUSHR	ds,si

	push	lpDstDev
	push	dwFlags
	push	dwCount
	push	lpBits

	; We don't need exclude here because BitmapBits never use screen.
	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_BitmapBits
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_BitmapBits

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     DibBlt_WithExclude
;
; Purpose:      This function is the DibBlt display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;
;==============================================================================
DECPROC DibBlt_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   iStart
PARMW   cScans
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpDrawMode
PARMD   lpTranslate
OPENPROC
	PUSHR	ds,si

	push	lpDstDev
	push	fGet
	push	iStart
	push	cScans
	push	lpDIBBits
	push	lpDIBInfo
	push	lpDrawMode
	push	lpTranslate

	; We don't need exclude here because DibBlt never use screen.
	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	les	bx,lpDstDev
        ; The DIBENG DibBltExt takes an extra parameter which indicates
        ; whether we are running in a palettized mode right now.
        test    es:[bx].DIBENGINEHDR.deFlags,PALETTE_XLAT
        setne   al
        movzx   ax,al
	push	ax
	call	DIB_DibBltExt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_DibBlt

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     ExtTextOut_WithExclude
;
; Purpose:      This function is the ExtTextOut display driver entry point
;		when we are running a software cursor.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;
; Returns:      This function returns one of the following values:
;
;               If wCount is negative and the function is successful,
;               it returns the X extent in AX,and the Y extent in DX.
;               If wCount is negative and the function is unsuccessful,
;               it returns the 7FFFH in AX,and wDstY in DX.
;
;               If wCount is 0 or positive and the the function is
;               successful,it returns DX:AX set to 1.
;               If wCount is 0 or positive and the the function is
;               unsuccessful,it returns DX:AX set to 80000000H.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC ExtTextOut_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpClipRect
PARMD   lpString
PARMW   wCount
PARMD   lpFontInfo
PARMD   lpDrawMode
PARMD   lpTextXForm
PARMD   lpKerning
PARMD   lpOpaqueRects
PARMW   wOptions
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	cmp	wCount,0
	jl	DoCall
	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

	; Here is a problem! I don't know what the exclusion rect is!
	; Oh well, just do the scan for the entire extent of the bitmap.
	lds	si,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	push	ds:[si].RECT.left
	push	ds:[si].RECT.top
	push	ds:[si].RECT.right
	push	ds:[si].RECT.bottom
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	lpClipRect
	push	lpString
	push	wCount
	push	lpFontInfo
	push	lpDrawMode
	push	lpTextXForm
	push	lpKerning
	push	lpOpaqueRects
	push	wOptions

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_ExtTextOut
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_ExtTextOut

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     Output_WithExclude
;
; Purpose:      This function is the Output display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC Output_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]

	IsItScreen ds:[si],DoCall

	; We dont need to exclude if we are in scan sequence
        cmp	ds:[si].GNLOGDEVCX.bInScanSequence,0
	je	@F

	; We need to unexclude cursor after endscan
	cmp	wStyle,OS_ENDNSCAN
	je	DoCall_WithExclude
	jmp	DoCall

@@:

	; Exclude the save / restore rect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	cmp	lpClipRect,0
	je	NoClipRect
	les	bx,lpClipRect

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax
	jmp	@F

NoClipRect:
	sub	ax,ax
	push	ax
	push	ax
	mov	ax,ds:[si].DIBENGINE.deWidth
	push	ax
	mov	ax,ds:[si].DIBENGINE.deHeight
	push	ax

@@:
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wStyle
	push	wCount
	push	lpPoints
	push	lpPen
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect

	; Busy bit already set if we are in scan sequence
        cmp	ds:[si].GNLOGDEVCX.bInScanSequence,0
	jne	DoRegularCall

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_Output
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_Output

	; We need to keep busy bit until scan sequence end.
        cmp	ds:[si].GNLOGDEVCX.bInScanSequence,0
	jne	KeepBusy

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet
KeepBusy:
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     Pixel_WithExclude
;
; Purpose:      This function is the Pixel display driver entry point
;		when we are running a software cursor.
;
; Arguments:    Pixel Display driver stack FRAME
;
; Returns:      If lpDrawMode is NULL then
;                       pixel value at coords wDstX,wDstY if succeesful
;                       80000000H is failure
;               If lpDrawMode is NOT NULL then
;                       00000001H is succeesful
;                       80000000H is failure
;
;==============================================================================
DECPROC Pixel_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   dwPhysColor
PARMD   lpDrawMode
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wDstX
	mov	cx,wDstY
	push	ax
	push	cx
	inc	ax
	inc	cx
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	dwPhysColor
	push	lpDrawMode

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_Pixel
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_Pixel

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     ScanLR_WithExclude
;
; Purpose:      This function is the ScanLR display driver entry point
;		when we are running a software cursor.
;
;==============================================================================
DECPROC	ScanLR_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wX
PARMW   wY
PARMD   dwPhysColor
PARMW   wStyle
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

	; Here is a problem! I don't know what the exclusion rect is!
	; Oh well, just do the scan for the entire extent of the bitmap.
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wX
	mov	cx,wY
	push	ax
	push	cx
	mov	ax,es:[bx].DIBENGINE.deWidth
	inc	cx
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess


DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wX
	push	wY
	push	dwPhysColor
	push	wStyle

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_ScanLR
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_ScanLR

	; Turn off BUSY bit because we don't use h/w here
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	les	bx,lpDstDev
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     SetDIBitsToDevice_WithExclude
;
; Purpose:      This function is the SetDIBitsToDevice driver entry point
;		when we are running a software cursor.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC SetDIBitsToDevice_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wInitScan
PARMW   wNumScans
PARMD   lpClipRect
PARMD   lpDrawMode
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,lpDstDev
	IsItScreen ds:[si],DoCall

	; The lpClipRect may not be entirely accurate. To get it correct,
	; I really need to clip against the src rectangle. However, why
	; bother? Just make sure the clip coordinates are bounded by the
	; screen borders. Then it will be close enough -- that is we
	; might be excluding the cursor from a little larger an area than
	; necessary, but it won;t hurt.
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	wInitScan
	push	wNumScans
	push	lpClipRect
	push	lpDrawMode
	push	lpDIBBits
	push	lpDIBInfo
	push	lpTranslate

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_DibToDevice
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_SetDIBitsToDevice

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     StretchBlt_WithExclude
;
; Purpose:      This function is the StretchBlt display driver entry point.
;		when we are running a software cursor.
;
;==============================================================================
DECPROC StretchBlt_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

if 0;!!
	; Check the rop and see what type of exclusion to check for
        movzx   bx,byte ptr [dwRop3 + 2]
	mov	ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
	mov	es,ax
        movzx  	ax,es:Rop3Table[bx]
        cmp	ax,PAD
        jae	SrcAndDstCheck
else
	cmp	lpSrcDev,0
	jne	SrcAndDstCheck
endif

JustDstCheck:
	lds	si,lpDstDev
	IsItScreen ds:[si],DoCall

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Just exclude the dst rect. Use cliprect for this but bound it
	; to the bitmap coords
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


SrcAndDstCheck:
	; See if we have to exclude the src rectangle also
	lfs	si,lpSrcDev
	IsItScreen fs:[si],JustDstCheck

	; Clip the src rect
	call	StretchBlt_ClipSrc
	or	ax,ax
	mov	ax,1
	je	DoneIt

	; We have to do the src rect.  How about the dst?
	les	bx,lpDstDev
	IsItScreen es:[bx],JustSrc

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SrcAndDst:
	; We need to exclude based on both the src and dst rectangles
	; I don't actually do the clip to generate the smallest possible
	; nounding rectangle. This might result in occassionally
	; excluding the cursor when we don't need to, but it won't hurt.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	; Order the src and dst X coordinates
	mov	ax,wDstX
	mov	bx,wSrcX
	cmp	ax,bx
	jl	@F
	mov	ax,bx
@@:	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	; Order the src and dst Y coordinates
	mov	ax,wDstY
	mov	bx,wSrcY
	cmp	ax,bx
	jl	@F
	mov	ax,bx
@@:	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	; Now find the larger of the src/dst right edges
	mov	ax,wDstX
	mov	bx,wSrcX
	add	ax,wDstExtX
	add	bx,wSrcExtX
	cmp	ax,bx
	jg	@F
	mov	ax,bx
@@:	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	; Now find the larger of the src/dst bottom edges
	mov	ax,wDstY
	mov	bx,wSrcY
	add	ax,wDstExtY
	add	bx,wSrcExtY
	cmp	ax,bx
	jg	@F
	mov	ax,bx
@@:	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	sub	bx,bx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JustSrc:
	; Just exclude the dst rect. Use cliprect for this but bound it
	; to the bitmap coords
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,wSrcX
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,wSrcY
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,wSrcX
	add	ax,wSrcExtX
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,wSrcY
	add	ax,wSrcExtY
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	wDstExtX
	push	wDstExtY
	push	lpSrcDev
	push	wSrcX
	push	wSrcY
	push	wSrcExtX
	push	wSrcExtY
	push	dwRop3
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_StretchBlt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_StretchBlt

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     StretchBlt_ClipSrc
;
; Purpose:      This function clips the src adjusting the stack parameters
;               for StrBlt appropriately to represent the clipped coords
;               and clipped extents.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;               fs:si  lpSrcDev
;
; Returns:      eax     1 - there is something to draw
;                       0 - there is nothing to draw
;
; Preserve:     ds,esi,es,edi,fs
;==============================================================================
PUBLIC	StretchBlt_ClipSrc
StretchBlt_ClipSrc	PROC	NEAR

        mov   	ax,wSrcX
        mov   	cx,wSrcY
        mov   	bx,fs:[si].DIBENGINE.deWidth
        mov   	dx,fs:[si].DIBENGINE.deHeight
        or      ax,ax
        js      ClipLeft
cld1:   or      cx,cx
        js      ClipTop
clt:    add     ax,wExtX
        add     cx,wExtY
        sub     ax,bx
        jg      ClipRight
clr:    sub     cx,dx
        jg      ClipBottom
clb:    mov     ax,1
        ret

ClipLeft:
        add     wExtX,ax
        jle     ClipDone
        sub     wDstX,ax
        sub     ax,ax
        mov     wSrcX,ax
        jmp     cld1

ClipTop:
        add     wExtY,cx
        jle     ClipDone
        sub     wDstY,cx
        sub     cx,cx
        mov     wSrcY,cx
        jmp     clt

ClipRight:
        sub     wExtX,ax
        jg      clr
        jmp     ClipDone

ClipBottom:
        sub     wExtY,cx
        jg      clb

ClipDone:
        sub     ax,ax
        ret

StretchBlt_ClipSrc	ENDP


;==============================================================================
;
; Function:     StretchDIBits_WithExclude
;
; Purpose:      This function is the StretchDIBits display driver entry point
;		when we are running a software cursor.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC StretchDIBits_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,lpDstDev
	IsItScreen ds:[si],DoCall

	; The lpClipRect may not be entirely accurate. To get it correct,
	; I really need to clip against the src rectangle. However, why
	; bother? Just make sure the clip coordinates are bounded by the
	; screen borders. Then it will be close enough -- that is we
	; might be excluding the cursor from a little larger an area than
	; necessary, but it won't hurt.
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	fGet
	push	wDstX
	push	wDstY
	push	wDstExtX
	push	wDstExtY
	push	wSrcX
	push	wSrcY
	push	wSrcExtX
	push	wSrcExtY
	push	lpDIBBits
	push	lpDIBInfo
	push	lpTranslate
	push	dwRop3
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_StretchDIBits
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_StretchDIBits

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     StrBlt_WithExclude
;
; Purpose:      This function is the StrBlt display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    StrBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;
;==============================================================================
DECPROC StrBlt_WithExclude, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wDstX
;PARMW   wDstY
;PARMD   lpClipRect
;PARMD   lpString
;PARMW   wCount
;PARMD   lpFontInfo
;PARMD   lpDrawMode
;PARMD   lpTextXForm
OPENPROC
        sub     ebx,ebx
        pop     eax
        push    ebx
        push    ebx
        push    bx
        push    eax
        jmp     ExtTextOut_WithExclude
CLOSEPROC


;==============================================================================
;
; Function:     UpdateColors_WithExclude
;
; Purpose:      This function is the UpdateColors display driver entry point
;		when we are running a software cursor.
;
; Arguments:    UpdateColors Display Driver Stack Frame
;
; Returns:      None
;
;==============================================================================
DECPROC UpdateColors_WithExclude, PASCAL, FRAME, FAR16
PARMW   wStartX
PARMW   wStartY
PARMW   wExtX
PARMW   wExtY
PARMD   lpTranslate
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	IsItScreen ds:[si],DoCall

	; Exclude the update rectangle
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wStartX
	mov	bx,wStartX
	push	ax
	push	bx
	add	ax,wExtX
	add	bx,wExtX
	push	ax
	push	bx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	wStartX
	push	wStartY
	push	wExtX
	push	wExtY
	push	lpTranslate

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	call	DIB_UpdateColorsExt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_UpdateColors

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     SaveScreenBitmap_WithExclude
;
; Purpose:      This function is the SaveScreenBitmap display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
; These aren't in any API header file so include them here
SAVE_AREA       EQU     0
RESTORE_AREA    EQU     1
DISCARD_AREA    EQU     2

DECPROC SaveScreenBitmap_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpRect
PARMW   wCommand
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]

	; Discard does not require exclude
        cmp     wCommand,DISCARD_AREA
        je	DoCall

	IsItScreen ds:[si],DoCall

	; Exclude the save / restore rect
	les	bx,lpRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

	mov	wExclude,1

	; Prepare return value if busy bit set.
	xor	ax,ax

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jc	DoneIt

DoCall:
	push	lpRect
	push	wCommand
	call	GENERIC_SaveScreenBitmap

DoneCall:
	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet
DoneIt:
	POPR	ds,si
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_BitBlt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_BitBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_BitBlt
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_BitmapBits
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_BitmapBits, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_BitmapBits
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_ExtTextOut
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_ExtTextOut, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_ExtTextOut
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_DibBltExt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_DibBltExt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_DibBltExt
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_DibToDevice
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_DibToDevice, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_DibToDevice
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_Output
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_Output, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_Output
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_Pixel
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_Pixel, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_Pixel
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_StretchBlt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_StretchBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_StretchBlt
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_StretchDIBits
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_StretchDIBits, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_StretchDIBits
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_UpdateColorsExt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_UpdateColorsExt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_UpdateColorsExt
CLOSEPROC

;================================================================
DECPROC DIB_DibBlt, PASCAL, NOFRAME, FAR16
OPENPROC
        ; The DIBENG DibBltExt takes an extra parameter which indicates
        ; whether we are running in a palettized mode right now.
	mov	bx,sp
	lgs	bx,ss:[bx+30]
        test    gs:[bx].DIBENGINEHDR.deFlags,PALETTIZED
        setne   bl
        movzx   bx,bl
        pop     eax
        push    bx
        push    eax
        jmp     DIB_DibBltExt
CLOSEPROC

;================================================================
DECPROC DIB_RealizeObject, PASCAL, NOFRAME, FAR16
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_RealizeObjectExt
CLOSEPROC

;================================================================
DECPROC DIB_SetPalette, PASCAL, NOFRAME, FAR16
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_SetPaletteExt
CLOSEPROC

;================================================================
DECPROC DIB_UpdateColors, PASCAL, NOFRAME, FAR16
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_UpdateColorsExt
CLOSEPROC

;================================================================
DECPROC DIB_SaveScreenBitmap, PASCAL, NOFRAME, FAR16
OPENPROC
	sub	eax,eax
        RETFAR16 06H
CLOSEPROC

;================================================================
GN_PatchedProcTable:
	dd	[Patch_BitBlt]
	dd	[Patch_BitmapBits]
	dd	[Patch_DibBlt]
	dd	[Patch_ExtTextOut]
	dd	[Patch_Output]
	dd	[Patch_Pixel]
	dd	[Patch_RealizeObject]
	dd	[Patch_ScanLR]
	dd	[Patch_SetDIBitsToDevice]
	dd	[Patch_SetPalette]
	dd	[Patch_StretchBlt]
	dd	[Patch_StretchDIBits]
	dd	[Patch_StrBlt]
	dd	[Patch_UpdateColors]
	dd	[Patch_SaveScreenBitmap]
PatchedProcTableSize	equ	( $ - GN_PatchedProcTable ) / 4

GN_HWCursorProcTable:
	dd	[GENERIC_BitBlt]
	dd	[GENERIC_BitmapBits]
	dd	[GENERIC_DibBlt]
	dd	[GENERIC_ExtTextOut]
	dd	[GENERIC_Output]
	dd	[GENERIC_Pixel]
	dd	[GENERIC_RealizeObject]
	dd	[GENERIC_ScanLR]
	dd	[GENERIC_SetDIBitsToDevice]
	dd	[GENERIC_SetPalette]
	dd	[GENERIC_StretchBlt]
	dd	[GENERIC_StretchDIBits]
	dd	[GENERIC_StrBlt]
	dd	[GENERIC_UpdateColors]
	dd	[GENERIC_SaveScreenBitmap]
        .errnz  $ - GN_HWCursorProcTable - PatchedProcTableSize * 4

GN_SWCursorProcTable:
	dd	[BitBlt_WithExclude]
	dd	[BitmapBits_WithExclude]
	dd	[DibBlt_WithExclude]
	dd	[ExtTextOut_WithExclude]
	dd	[Output_WithExclude]
	dd	[Pixel_WithExclude]
	dd	[GENERIC_RealizeObject]
	dd	[DIB_ScanLR]
	dd	[SetDIBitsToDevice_WithExclude]
	dd	[GENERIC_SetPalette]
	dd	[StretchBlt_WithExclude]
	dd	[StretchDIBits_WithExclude]
	dd	[StrBlt_WithExclude]
	dd	[UpdateColors_WithExclude]
	dd	[SaveScreenBitmap_WithExclude]
        .errnz  $ - GN_SWCursorProcTable - PatchedProcTableSize * 4

GN_PuntProcTable:
	dd	[DIB_BitBlt]
	dd	[DIB_BitmapBits]
	dd	[DIB_DibBlt]
	dd	[DIB_ExtTextOut]
	dd	[DIB_Output]
	dd	[DIB_Pixel]
;;	dd	[GENERIC_RealizeObject]
	dd	[DIB_RealizeObject]; do not create offscreen objects
	dd	[DIB_ScanLR]
	dd	[DIB_DibToDevice]
	dd	[GENERIC_SetPalette]	;[DIB_SetPalette]; to exclude h/w access at all
	dd	[DIB_StretchBlt]
	dd	[DIB_StretchDIBits]
	dd	[DIB_StrBlt]
	dd	[DIB_UpdateColors]
	dd	[DIB_SaveScreenBitmap]
        .errnz  $ - GN_PuntProcTable - PatchedProcTableSize * 4

;================================================================
GN_PatchedPuntTable:
	dd	[Punt_BitmapBits]
	dd	[Punt_BitBlt]
	dd	[Punt_DibBlt]
	dd	[Punt_DibToDevice]
	dd	[Punt_ExtTextOut]
	dd	[Punt_Output]
	dd	[Punt_Polyline]
	dd	[Punt_Rectangle]
	dd	[Punt_BeginScan]
	dd	[Punt_Scan]
	dd	[Punt_EndScan]
	dd	[Punt_Pixel]
	dd	[Punt_StrBlt]
	dd	[Punt_StrDib]
	dd	[Punt_UpdateColors]
PatchedPuntTableSize	equ	( $ - GN_PatchedPuntTable ) / 4

GN_DibengTable:
	dd	[DIB_BitmapBits]
	dd	[DIB_BitBlt]
	dd	[DIB_DibBltExt]
	dd	[DIB_DibToDevice]
	dd	[DIB_ExtTextOut]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Pixel]
	dd	[DIB_StretchBlt]
	dd	[DIB_StretchDIBits]
	dd	[DIB_UpdateColorsExt]
        .errnz  $ - GN_DibengTable - PatchedPuntTableSize * 4

GN_JuncToDibTable:
	dd	[Wrap_BitmapBits]
	dd	[Wrap_BitBlt]
	dd	[Wrap_DibBltExt]
	dd	[Wrap_DibToDevice]
	dd	[Wrap_ExtTextOut]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Pixel]
	dd	[Wrap_StretchBlt]
	dd	[Wrap_StretchDIBits]
	dd	[Wrap_UpdateColorsExt]
        .errnz  $ - GN_JuncToDibTable - PatchedPuntTableSize * 4

;==============================================================================
;
; Function:     GN_TurnExcludeOffOrOn
;
; Purpose:      This function do patch of drv entry points
;		to work with h/w - s/w cursors.
;
; Arguments:    dwCursorFlags
;
;==============================================================================
DECPROC GN_TurnExcludeOffOrOn, PASCAL, FRAME, FAR16
PARMD   dwCursorFlags
OPENPROC
	PUSHR	ds,es,si,di
	mov	ax,cs:[wNVTEXT16_Alias_In_NVTEXT16]
	mov	es,ax
	mov	bx,GN_PuntProcTable
	or	ax,ax

	;;;In order to punt everything to dibengine change jz --> jnz
	jz	@F
	mov	bx,GN_HWCursorProcTable
@@:
	test	dwCursorFlags,CURSOR_HAS_TRAILS
	jz	@F
	mov	bx,GN_SWCursorProcTable
@@:
	mov	si,offset GN_PatchedProcTable
	mov	cx,PatchedProcTableSize
ProcLoop:
	mov	di,word ptr cs:[si]
	inc	di
	mov	eax,dword ptr cs:[bx]
	mov	dword ptr es:[di],eax
	add	bx,size DWORD
	add	si,size DWORD
	dec	cx
	jnz	ProcLoop

	mov	ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
	mov	es,ax
	mov	bx,GN_DibengTable
	test	dwCursorFlags,CURSOR_HAS_TRAILS
	jz	@F
	mov	bx,GN_JuncToDibTable
@@:
	mov	si,offset GN_PatchedPuntTable
	mov	cx,PatchedPuntTableSize
PuntLoop:
	mov	di,word ptr cs:[si]
	add	di,2
	mov	eax,dword ptr cs:[bx]
	mov	dword ptr es:[di],eax
	add	bx,size DWORD
	add	si,size DWORD
	dec	cx
	jnz	PuntLoop
	POPR	ds,es,si,di
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNVDD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnvdd.asm
;
; Purpose:      This file holds the interface calls to the main VDD.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include minivdd.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  dwThisLogicalDeviceHandle
dwThisLogicalDeviceHandle       DD      0
CLOSESEG _NVTEXT32

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  lpfnVddEntryPoint
lpfnVddEntryPoint               DD      0

PUBLIC  dwThisLogicalDeviceHandle_In_NVTEXT16
dwThisLogicalDeviceHandle_In_NVTEXT16   DD      0

;==============================================================================
;
; Function:     GN_VddGetEntryPoint
;
; Purpose:      This function gets the entry point for the VDD Protected
;               Mode API services.
;
; Arguments:    None
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddGetEntryPoint, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,edi
        mov     eax,1684h
        mov     ebx,0AH
        int     2fh
        mov     ax,es
        shl     eax,10H
        mov     ax,di
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[lpfnVddEntryPoint],eax
        POPR    ds,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddGetDeviceHandle
;
; Purpose:      This function gets the device handle for this
;               instance of the driver. This function should
;               not rely on the CSlp16LogDevice being set.
;
; Arguments:    eax     lpDstDevType argument to GENERIC_Enable
;
; Returns:      eax     0     then there was an error getting the handle
;                       non-0 then ecx has the dwDeviceHandle
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddGetDeviceHandle, PASCAL, FRAME, FAR16
PARMD   lpDstDevType
OPENPROC
        PUSHR   ds,esi,edi

        ; If lpDstDevType is NULL, then we are the primary display.
        mov     ecx,1
        mov     eax,1
        cmp     lpDstDevType,0
        je      DoneIt

        ; Call the main VDD to have it open us as a secondary device
        mov     eax,lpDstDevType
        movzx   edi,ax
        shr     eax,10H
        mov     es,ax
        mov     eax,VDD_OPEN
        sub     edx,edx
        sub     ecx,ecx
        mov     si,es
        sub     ebx,ebx                 ; use EBX to point to PDEVICE
        call    FFP16 PTR lpfnVddEntryPoint

        ; 0 and -1 are not valid device handles
        ; Anything else we must accept as valid
        ; (Note: minivdd.inc does not specify any error codes.)
        mov     ecx,eax
        sub     eax,eax
        cmp     ecx,-1
        je      DoneIt

        mov     eax,1
        cmp     ecx,0
        jne     DoneIt
        mov     ecx,1

DoneIt:
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[dwThisLogicalDeviceHandle_In_NVTEXT16],ecx
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[dwThisLogicalDeviceHandle],ecx
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddEnableDevice
;
; Purpose:      This function will make a call to the VDD to enable
;               some type of access to the device.
;
; Arguments:
;               dwEnableType            Enable type like ENABLE_MEM, etc.
;                                       minivdd.inc has all the equates
;
; Returns:      eax     ENABLE_ERROR if there was a problem
;                       anything else if there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddEnableDevice, PASCAL, FRAME, FAR16
PARMD   dwEnableType
OPENPROC
        PUSHR   ds,esi,edi
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     edx,dwEnableType
        mov     eax,VDD_ENABLE
        sub     edi,edi
        mov     es,di
        mov     esi,edi
        sub     ecx,ecx
        call    FFP16 PTR lpfnVddEntryPoint
        cmp     eax,VDD_ENABLE
        jne     @F
        mov     eax,ENABLE_ERROR
@@:     POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddCloseDevice
;
; Purpose:      This function closes the device specified in
;               GNBOARDCX.dwDeviceHandle
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddCloseDevice, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
	mov	eax,VDD_CLOSE
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        sub     ecx,ecx
        sub     edx,edx
        mov     es,dx
        sub     edi,edi
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddGetDisplayInfo
;
; Purpose:      This function gets the DISPLAYINFO strcuture from the
;               main VDD.
;
; Arguments:
;               lpDisplayInfo           16:16 ptr to DUISPLAYINFO
;               dwDisplayCallIndex      either VDD_GET_DISPLAY_CONFIG
;                                       or VDD_GET_DISPLAY_CONFIG2
;
; Returns:      The DISPLAYINFO structure is filled in
;               There are no failure codes listed in minivdd.h
;               although the DISPLAYINFO.diInfoFlags has some error info.
;
; Preserve:     ds,esi,es,edi
;==============================================================================
DECPROC GN_VddGetDisplayInfo, PASCAL, FRAME, FAR16
PARMD   lpDisplayInfo
PARMD   dwDisplayCallIndex
OPENPROC
        PUSHR   ds,es,esi,edi
        sub     edi,edi
        les     di,lpDisplayInfo
        mov     eax,dwDisplayCallIndex
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,SIZE DISPLAYINFO
        mov     es:[edi].DISPLAYINFO.diHdrSize,cx
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,es,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddDriverRegister
;
; Purpose:      This function calls the main VDD to register the
;               display driver. The driver can tell the VDD the function
;               that should be called when the driver needs to be put
;               back in a high resolution mode. Also, the driver can
;               specify an area of offscreen memory to be used for
;               VGA virtualization and whether or not planar modes
;               are supported in a Windowed DOS box.
;
;               The call to the VDD requires the following:
;               es:edi  ptr to ResetHiResMode function
;               ecx     Offscreen virtualization offset. The VDD may use
;                       from 32K to 64K beginning at this offset into
;                       video memory. If you don't want to allow
;                       VGA virtualization, pass in ecx equal to 0
;                       and edx below equal to -1.
;               edx     0 if planar mode virtualization is to be supported
;                         for Windowed DOS boxes.
;                       -1 if not
;                          If edx is set to -1, then ecx should be set
;                          to 0 -- ignore the minivdd.inc documentation.
;                          There was a bug in an early cut of the main VDD.
;
; Arguments:
;
; Returns:      eax     The offset of the end of the virtualization area
;                       if virtualization is being allowed (via edx,ecx).
;                       Hence, eax minus the value of ecx passed in will
;                       give the amount of memory the VDD is using for
;                       planar mode virtualization.
;                       If the caller requested no virtualization, then
;                       there is no return value.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddDriverRegister, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ax,SEG GENERIC_ResetHiresMode
        mov     es,ax
        mov     edi,OFFSET GENERIC_ResetHiresMode
        sub     ecx,ecx
        mov     edx,-1
        mov     eax,VDD_DRIVER_REGISTER
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddDriverUnregister
;
; Purpose:      This function unregisters the display driver with the VDD.
;
; Arguments:
;
; Returns:      Nothing.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddDriverUnregister, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_DRIVER_UNREGISTER
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddRegisterDisplayDriver
;
; Purpose:      This function was setup up by Windows to allow the
;               display driver to have a private communication with
;               its minivdd. The only required parameters for the
;               VDD_REGISTER_DISPLAY_DRIVER_INFO call are eax equal
;               to this service number and ebx equal to the
;               dwDeviceHandle. All other registers values are
;               private to the driver.
;
; Arguments:
;               ax                      desired value for ds
;               ebx                     desired value for esi
;
;               Whatever other arguments are desired in registers.
;               ax will be moved into ds and ebx will be moved into
;               esi. Then eax will be set to the value
;               VDD_REGISTER_DISPLAY_DRIVER_INFO and ebx will be set
;               the dwDeviceHandle and the call will be made to the
;               main VDD.
;
; Returns:      Whatever is returned from the
;               VDD_REGISTER_DISPLAY_DRIVER_INFO call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddRegisterDisplayDriver, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,ax
        mov     esi,ebx
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddSaveDriverState
;
; Purpose:      This function tells the VDD to save the driver state.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddSaveDriverState, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_SAVE_DRIVER_STATE
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddEnableIOTrapping
;
; Purpose:      This function can enable or disable IO trapping. The
;               routine is a NOP is we are not the primary display.
;
; Arguments:
;               dwEnableFlag            1 to enable trapping,
;                                       0 to disable trapping
;
; Returns:      None
;
; Preserve:     ds,esi
;==============================================================================
STOP_IO_TRAP    TEXTEQU         <4000H>
START_IO_TRAP   TEXTEQU         <4007H>
DECPROC GN_VddEnableIOTrapping, PASCAL, FRAME, FAR16
PARMD   dwEnableFlag
OPENPROC
        PUSHR   ds,esi,edi

        ; If we are the secondary display or if we are unsure what
        ; display we are -- do NOT enable trapping.
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        jne     done

        ; Otherwise, enable or disable based upon eax
        mov     eax,STOP_IO_TRAP
        cmp     dwEnableFlag,0
        je      @F
        mov     eax,START_IO_TRAP
@@:
        int     2FH
done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddSetLockAndUnlockOffscreen
;
; Purpose:      Send the address of the Lock and Unlock Offscreen
;               Allocations up to the miniVDD. When a DOS box is created
;               the miniVDD will call Lock and whenever one is destroyed,
;               Unlock will be called. Since the display driver does not
;               get control in time to save the offscreen memory area
;               before a DOS box flips full screen, offscreen allocations
;               are inhibited while DOS boxes are active.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddSetLockAndUnlockOffscreen, PASCAL, FRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS
        mov     dx,SEG GN_OffscreenAllocationsLock
        movzx   edx,dx
        mov     esi,OFFSET GN_OffscreenAllocationsLock
        mov     edi,OFFSET GN_OffscreenAllocationsUnlock
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddSetPowerManagementCallbacks
;
; Purpose:      Send the address of the PowerOn and PowerOff
;               routines up to the miniVDD. When a power state will change
;               the miniVDD will call these routines respectively
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddSetPowerManagementCallbacks, PASCAL, FRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,MVDD_SET_POWER_MANAGEMENT_CALLBACKS
        mov     dx,SEG GN_PowerOn
        movzx   edx,dx
        mov     esi,OFFSET GN_PowerOn
        mov     edi,OFFSET GN_PowerOff
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddReenumerateDevNode
;
; Purpose:      Reenumerate the current DevNode.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddReenumerateDevNode, PASCAL, FRAME, FAR16
PARMD   dwLogicalDevIndex
PARMD   dwCrtcHead
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,MVDD_REENUMERATE_DEVNODE
        mov     edx,dwCrtcHead
        mov     esi,dwLogicalDevIndex
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddIsDriverAttachedToDesktop
;
; Purpose:      This routine determines if the display driver
;               is drivering a windows logical device that is
;               "attached to the desktop" -- i.e. is it enabled.
;               NOTE: If this is the primary driver, it is
;               always attached.
;
; Arguments:    ds      Context Selector
;               dwLogicalDeviceInstance
;
; Returns:      eax     0       not attached to the desktop
;                       non-0   is attached to the desktop
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddIsDriverAttachedToDesktop, PASCAL, FRAME, FAR16
LOCALS  szPciSpec,80H
OPENPROC
        mov     eax,1
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        je      DoneIt

        ; Copy the Pci Specifier to a local stack location
        mov     eax,dwThisLogicalDeviceHandle_In_NVTEXT16
        and     eax,NOT 03H
        mov     ebx,ds:[eax + 4]
        sub     edx,edx
        sub     ecx,ecx
        lea     cx,szPciSpec
@@:
        mov     al,ds:[ebx][edx]
        mov     ss:[ecx][edx],al
        inc     edx
        or      al,al
        jne     @B

        mov     ax,ss
        shl     eax,10H
        lea     ax,szPciSpec
        push    eax

        mov     eax,dwThisLogicalDeviceHandle_In_NVTEXT16
        and     eax,03H
        push    eax
        call    FFP16 PTR cs:[lpfnIsDriverAttachedToDesktop]
        movzx   eax,ax
DoneIt:
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\GNLOGDEV.H ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       gnlogdev.h

    Purpose:    This file holds structures and equates dealing with the
                pdevice.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

#define MAX_DISP_CONFIG 80

// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;;;;;;;;;;;;;;;;  A DEVICE BITMAP HEADER  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure must have a DIBENGINEHDR as the first field. After that,
// anything is fine.
typedef struct  _DEVBMP
{
    DIBENGINEHDR    Dibeng;
    USHORT          wLeft;
    USHORT          wTop;
    USHORT          wRight;
    USHORT          wBottom;
}   DEVBMP;

#define MAX_SSBS    3
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;;;;;;;;;;;;;;;;;;  The PHYSICAL DEVICE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

typedef struct  _GNLOGDEVCX
{
    // This must go first
    DIBENGINEHDR    Dibeng;

    // Tells us if we are initting or not. This is cleared after
    // the second enable call (the one that inits the PPDEVICE.
    ULONG       dwInitting;

    // The GNBOARDCX that is attached to this GNLOGDEV
    ULONG       pGNBoardCX;

    // Which GNLOGDEV instance this is on the board (0, 1, 2, ...)
    ULONG       dwLogicalDeviceInstanceOnThisBoard;

    // How many CRTCs are attached to this logical device
    ULONG       dwNumCRTCsAttachedToThisLogicalDevice;

    // The number of clone devices that this logical device is
    // waiting for. Generally a logical device is waiting for a
    // clone if a clone device got stolen from it at one point
    // in time. As the stolen CRTCCXs get freed, they will be
    // restored when they become available again.
    ULONG       dwNumClonesAwaited;

    // How many CRTCs are on this board
    ULONG       dwTotalCRTCsOnBoard;

    // Do we allow desktops larger than a CRTC will set?
    ULONG       dwVirtualDesktopEnabled;

    // Is this an Nvidia Control Panel SetMode?
    ULONG       lpBoardRegistryData;

    // This variable holds the number of bytes of video memory needed
    // by the primary surface. For safety sake, because we can set
    // low res DX modes, this will never be less than the amount of
    // memory required for a 640x480x8 screen even if the actual
    // display is smaller.
    ULONG       dwMemorySizeForPrimarySurface;

    // OK, this is a bit ugly. We keep the two code segments we are
    // using in the driver in here.
    ULONG       dw16BitCodeSegment;
    ULONG       dw32BitCodeSegment;

    // There can be a number of GNCRTCCXs attached to this GNLOGDEVCX.
    ULONG       pGNCrtcCX[MAX_ATTACHED_CRTCS];

    // How about the hw logdevice data
    ULONG       pHWLogdevCX;

    // Keep a ptr to the GDI info for this PDEVICE.
    ULONG       lpGdiInfo;

    // If the hardware uses a 5-6-5 format for 16bpp, then set this
    // field to FIVE6FIVE. If the hardware uses 1-5-5-5 format, then
    // set this field to 0.
    ULONG       dw16BppFormat;      // FIVE6FIVE or 0 (which means 5-5-5)
    ULONG       dwFontFormat;        // C1_BIT_PACKED or C1_BYTE_PACKED

    // Here is where we crate pseudo bitmap headers for
    // save-screen offscreen bitmaps.
    DEVBMP      SaveScreenBitmapCache[MAX_SSBS];

    // These are for handling a Windows bug having to do with
    // Screen repaints coming back from a DOS box.
    ULONG       dwCheckCursorCount;
    ULONG       dwGraphicsTimeStamp;
    ULONG       lpfnUserRepaint;

    // This flag indiactes that device(s) has been remapped.
    ULONG       dwDeviceHasBeenRemapped;

    //--------------- Begin byte alignment!!! ------------
    UCHAR       bRepaintDisable;
    UCHAR       bRepaintPending;
    UCHAR       bUserRepaintCallCount;
    UCHAR       bRepaintIssued;

    // Scanline and Polyscanline stuff
    UCHAR       bInScanSequence;
    UCHAR       bHollowBrushForScan;
    UCHAR       bPuntingScan;

    UCHAR       bDirectXActive;

    UCHAR       bInterlacedStereo;
    UCHAR       bSetModeBypass;
    UCHAR       bReserved1;
    UCHAR       bReserved2;
    //---------------   End byte alignment!!!  ------------

    // Macrovision Support
    ULONG       dwMacrovisionNavigatorID;
    ULONG       dwCurrentMacrovisionKey;
    ULONG       dwNextMacrovisionKey;
    ULONG       dwMacrovisionMode;

    // This flag indiactes that the hardware should not be touched.
    ULONG       dwHardwareBusy;

    // fInt2FScreenSwitchOut is used to indicate we have received
    // a ScreenSwitchOut but not a screenSwitchIn.
    ULONG       dwInt2FScreenSwitchOut;

    // This is used to store some black-box control panel data
    ULONG       dwCplData;

    // dwCurrentLine is used as the last address for GN_RollerToolEscape
    ULONG       dwCurrentLine;

    // This memory block will be used for the hotkey display switch
    // escape. We save off the state information for the state that
    // the hotkey handler wants us to switch to on the next Enable.
    // We don't know the exact size in here, but there is a sizecheck
    // in the file that references this data structure, so that the
    // build will break if it is not big enough.
    ULONG       sDispConfig[MAX_DISP_CONFIG];
    ULONG       dwDisplayConfigPending;
    ULONG       dwNvDisplayChangePending;
    ULONG       dwBeginDisplayChangeIssued;

    // This will temporarily hold the xres,yres that Windows wants
    // us to change to. In multimon, Windows will truncate our
    // mode heights so that they are a multiple of 8. Hence, we
    // have to play a few games with the mode they ask us to
    // set and the mode that we validate against our table.
    USHORT      wWindowsXRes;
    USHORT      wWindowsYRes;

    DIBHEADER   bmi;
    ULONG       dwPalette[256];
    UCHAR       bPaletteXlatTable[256];
    UCHAR       bPaletteInverseXlatTable[256];
}   GNLOGDEVCX;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\gndata.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         gndata.inc
;
; Purpose:      This file holds some data/structures/externs that
;               the generic code needs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DibBlt, SetDIBitsToDevice, StretchDIBits 8 bpp h/w acceleration define.
; Set to 1 will turn on.
DIB_FAST_EXIT           TEXTEQU <1>
DIB_8BPP_ACCEL          TEXTEQU <1>
DIB_PROCESS_SINGLESCAN  TEXTEQU <1>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _DATA, USE16, DATA
EXTERNDEF       szUserModuleName:BYTE
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

; gnaccess.asm
EXTERNDEF       GENERIC_BeginAccess:FAR16
EXTERNDEF       GENERIC_EndAccess:FAR16

; gnblt.asm
NOROP   TEXTEQU <0>
OND     TEXTEQU <1>
PAD     TEXTEQU <2>
SAD     TEXTEQU <3>
PSD     TEXTEQU <4>
EXTERNDEF       GENERIC_BitBlt:FAR16
EXTERNDEF       Punt_BitBlt:NEAR
EXTERNDEF       GN_BitBltPatDstRop:NEAR
EXTERNDEF       GN_BitBltPatUnknownSrcUnknownDstVram:NEAR
EXTERNDEF       GN_BitBltSrcUnknownDstVram:NEAR
EXTERNDEF       GN_BitBltClipSrc:NEAR
EXTERNDEF       GN_BitBltSrcVramDstVram:NEAR
EXTERNDEF       GN_BitBltSrcMonoDstVram_1:NEAR
EXTERNDEF       GN_BitBltSrcColorDstVram_1:NEAR
EXTERNDEF       GN_BitBltSystemMemoryDst:NEAR
EXTERNDEF       GN_PrepareBrush:NEAR
EXTERNDEF       Rop3Table:BYTE

; gnbmpbts.asm
EXTERNDEF       GENERIC_BitmapBits:FAR16
EXTERNDEF       Punt_BitmapBits:NEAR
EXTERNDEF       GN_BitmapBitsSuccess:NEAR
EXTERNDEF       BitmapBits_Set:NEAR
EXTERNDEF       BitmapBits_SetWithFiller:NEAR
EXTERNDEF       BitmapBits_Get:NEAR
EXTERNDEF       BitmapBits_Copy:NEAR
EXTERNDEF       BitmapBits_CopyVramToVram:NEAR
EXTERNDEF       BitmapBits_CopySystemToVram:NEAR
EXTERNDEF       BitmapBits_CopyVramToSystem:NEAR
EXTERNDEF       BitmapBits_CopySystemToSystem:NEAR
EXTERNDEF       BitmapBits_CopyByScan:NEAR
EXTERNDEF       BitmapBits_CopyAll:NEAR

; gnclrinf.asm
EXTERNDEF       GENERIC_ColorInfo:FAR16

; gnclrblt.asm
EXTERNDEF       bTableBppToIndex:BYTE
EXTERNDEF       dwTableBppToXlatFunc:DWORD
; This needs to reflect how many entries per color depth are in the
; above table. Right now, we have routines for 1,4,8,15,16,24,32
; which is 7 different color depths. So MAX_BPP_INDICES should be 7.
MAX_BPP_INDICES TEXTEQU <7>
EXTERNDEF       GN_XferWholeColorScans:NEAR
EXTERNDEF       GN_XferPartialColorScans:NEAR
EXTERNDEF       GN_ConvertColorTableFrom32To16:NEAR

; gncp8.asm
EXTERNDEF       GN_Xfer1To8:NEAR
EXTERNDEF       GN_Xfer4To8WordXlat:NEAR
EXTERNDEF       GN_Xfer8To8NoXlat:NEAR
EXTERNDEF       GN_Xfer8To8ByteXlat:NEAR
EXTERNDEF       GN_Xfer8To8WordXlat:NEAR
EXTERNDEF       GN_Xfer15To8:NEAR
EXTERNDEF       GN_Xfer16To8:NEAR
EXTERNDEF       GN_Xfer24To8:NEAR
EXTERNDEF       GN_Xfer32To8:NEAR
EXTERNDEF       FindLMSPaletteIndex:NEAR

; gncp15.asm
EXTERNDEF       GN_Xfer4To15DwordXlat:NEAR
EXTERNDEF       GN_Xfer4To15WordXlat:NEAR
EXTERNDEF       GN_Xfer8To15WordXlat:NEAR
EXTERNDEF       GN_Xfer8To15DwordXlat:NEAR
EXTERNDEF       GN_Xfer15To15:NEAR
EXTERNDEF       GN_Xfer16To15:NEAR
EXTERNDEF       GN_Xfer24To15:NEAR
EXTERNDEF       GN_Xfer32To15:NEAR

; gncp16.asm
EXTERNDEF       GN_Xfer4To16DwordXlat:NEAR
EXTERNDEF       GN_Xfer4To16WordXlat:NEAR
EXTERNDEF       GN_Xfer8To16WordXlat:NEAR
EXTERNDEF       GN_Xfer8To16DwordXlat:NEAR
EXTERNDEF       GN_Xfer15To16:NEAR
EXTERNDEF       GN_Xfer16To16:NEAR
EXTERNDEF       GN_Xfer24To16:NEAR
EXTERNDEF       GN_Xfer32To16:NEAR

; gncp32.asm
EXTERNDEF       GN_Xfer4To32:NEAR
EXTERNDEF       GN_Xfer8To32:NEAR
EXTERNDEF       GN_Xfer15To32:NEAR
EXTERNDEF       GN_Xfer16To32:NEAR
EXTERNDEF       GN_Xfer24To32:NEAR
EXTERNDEF       GN_Xfer32To32:NEAR

; gncursor.asm
EXTERNDEF       GN_CreateCursorCache:FAR32
EXTERNDEF       GN_DestroyCursorCache:FAR32
EXTERNDEF       GN_ClearCursorCache:FAR32
EXTERNDEF       GN_ClearAllCursorCaches:FAR32
EXTERNDEF       GN_Convert8BppCursorTo32BppCursor:NEAR
EXTERNDEF       GENERIC_SetCursor:FAR16
EXTERNDEF       GN_CursorAction:NEAR
EXTERNDEF       GENERIC_MoveCursor:FAR16
EXTERNDEF       GENERIC_CheckCursor:FAR16
EXTERNDEF       GN_TurnCursorOffOrOn:FAR32
EXTERNDEF       GN_ResetSelectedCursor:FAR32

; gndibblt.asm
EXTERNDEF       GENERIC_DibBlt:FAR16
EXTERNDEF       Punt_DibBlt:NEAR
EXTERNDEF       GN_DibBltSuccess:NEAR
EXTERNDEF       GN_DibBltSetMono:NEAR
EXTERNDEF       GN_DibBltSetColor:NEAR
EXTERNDEF       GN_DibBltGet:NEAR
EXTERNDEF       GN_DibBltClip:NEAR

; gndibdev.asm
EXTERNDEF       GENERIC_SetDIBitsToDevice:FAR16
EXTERNDEF       Punt_DibToDevice:NEAR
EXTERNDEF       GN_DibDevExit:NEAR
EXTERNDEF       GN_SetMonoDibToDevice:NEAR
EXTERNDEF       GN_SetColorDibToDevice:NEAR
EXTERNDEF       GN_SetDIBitsToDeviceClip:NEAR
EXTERNDEF       GN_SetDIBitsSingleScan:NEAR

; gndibs.asm
EXTERNDEF       GN_DibSingleScan_Bpp8:NEAR
EXTERNDEF       GN_DibSingleScan_Bpp16:NEAR
EXTERNDEF       GN_DibSingleScan_Bpp32:NEAR

; gndibxit.asm
EXTERNDEF       GN_InitDibFastExit:FAR16
EXTERNDEF       bUseSetDIBitsFastExit:BYTE
EXTERNDEF       bUseStretchDIBitsFastExit:BYTE
EXTERNDEF       lpfnGdiCode03_2119:DWORD
EXTERNDEF       lpfnGdiCode03_20B7:DWORD
EXTERNDEF       GdiCode03_2119:FAR16
EXTERNDEF       GdiCode03_217C:FAR16

; gngamma.asm
EXTERNDEF       GENERIC_GammaRamp:FAR16

; gninit.asm
EXTERNDEF       wFlatDataSel:WORD
EXTERNDEF       CSlp16LogDevice:DWORD
EXTERNDEF       CSpGNLogicalDevice:DWORD

; gnline
;EXTERNDEF      GENERIC_Polyline:FAR16
EXTERNDEF       GN_PoylineNonSolid:NEAR
EXTERNDEF       Punt_Polyline:NEAR
EXTERNDEF       GN_PolylineSuccess:NEAR

; gnmem.asm
EXTERNDEF       GN_HeapCreate:FAR32
EXTERNDEF       GN_HeapInit:FAR32
EXTERNDEF       GN_HeapDestroy:FAR32
EXTERNDEF       GN_HeapAlloc:NEAR
EXTERNDEF       GN_HeapFree:NEAR

; gnmonblt.asm
EXTERNDEF       GN_BitBltSrcMonoDstVram:NEAR
EXTERNDEF       GN_XferWholeAlignedMonoScans:NEAR
EXTERNDEF       GN_XferWholeUnalignedMonoScans:NEAR
EXTERNDEF       GN_XferPartialAlignedMonoScans:NEAR
EXTERNDEF       GN_XferPartialUnalignedMonoScans:NEAR

; gnoffbmp.asm
EXTERNDEF       GN_ClearOffscreenBitmapCache:FAR32
EXTERNDEF       GN_OffscreenBitmapCreate:NEAR
EXTERNDEF       GN_OffscreenBitmapDelete:NEAR
EXTERNDEF       GN_OffscreenBitmapValidCheck:NEAR
EXTERNDEF       GN_FlushOffscreenBitmap:NEAR

; gnoutput.asm
EXTERNDEF       GENERIC_Output:FAR16
EXTERNDEF       Punt_Output:NEAR
;EXTERNDEF      GENERIC_Polygon:FAR16
;EXTERNDEF      GENERIC_Polyline:FAR16
;EXTERNDEF      GENERIC_PolyScanOrScanLine:FAR16

; gnpalet.asm
EXTERNDEF       GENERIC_SetPalette:FAR16
EXTERNDEF       GENERIC_SetPaletteTranslate:FAR16
EXTERNDEF       GENERIC_UpdateColors:FAR16
EXTERNDEF       GN_UpdateColorsExit:NEAR
EXTERNDEF       GN_UpdateColors:NEAR
EXTERNDEF       Punt_UpdateColors:NEAR

; gnpixel.asm
EXTERNDEF       GENERIC_Pixel:FAR16
EXTERNDEF       Punt_Pixel:NEAR
EXTERNDEF       GN_PixelDone:NEAR
EXTERNDEF       GN_SetPixel:NEAR
EXTERNDEF       GN_GetPixel:NEAR

; gnrect.asm
;EXTERNDEF      GENERIC_Rectangle:FAR16
EXTERNDEF       Punt_Rectangle:NEAR

; gnrobj.asm
EXTERNDEF       GENERIC_RealizeObject:FAR16
EXTERNDEF       GN_RealizeObjectExt:FAR16
EXTERNDEF       Punt_RealizeObjectExt:NEAR
EXTERNDEF       GN_RealizeObjectExtSuccess:NEAR
EXTERNDEF       GN_RealizeObjectExtDone:NEAR
EXTERNDEF       GN_RealizeObjectExtBrush:NEAR
EXTERNDEF       GN_RealizeObjectExtBitmap:NEAR
EXTERNDEF       GN_RealizeObjectExtDeleteBitmap:NEAR
EXTERNDEF       GN_RealizeObjectExtFont:NEAR
EXTERNDEF       GN_InitFunctionPtr:NEAR
EXTERNDEF       GN_LoadAndInitFonts:NEAR

; gnscan.asm
;EXTERNDEF      GENERIC_BeginScan:FAR16
;EXTERNDEF      GENERIC_EndScan:FAR16
;EXTERNDEF      GENERIC_PolyScanOrScanLine:FAR16
EXTERNDEF       Punt_BeginScan:NEAR
EXTERNDEF       Punt_Scan:NEAR
EXTERNDEF       Punt_EndScan:NEAR

; gnsdib.asm
EXTERNDEF       GENERIC_StretchDIBits:FAR16
EXTERNDEF       Punt_StrDib:NEAR
EXTERNDEF       GN_StrDibExit:NEAR
EXTERNDEF       GN_StretchMonoDib:NEAR
EXTERNDEF       GN_StretchColorDib:NEAR
EXTERNDEF       GN_StretchDIBitsClip:NEAR
EXTERNDEF       GN_StretchDIBitsSingleScan:NEAR

; gnssb.asm
EXTERNDEF       GN_ClearSaveScreenBitmapCache:FAR32
EXTERNDEF       SaveScreenBitmap:FAR16
EXTERNDEF       GENERIC_SaveScreenBitmap:FAR16
EXTERNDEF       GN_SaveScreenBitmapFail:NEAR
EXTERNDEF       GN_SaveScreenBitmapSuccess:NEAR
EXTERNDEF       GN_SaveScreenBitmapExit:NEAR
EXTERNDEF       SSB_SaveArea:NEAR
EXTERNDEF       SSB_RestoreOrDiscardArea:NEAR
EXTERNDEF       GN_SaveScreenBitmap:NEAR

; gnstrblt.asm
EXTERNDEF       GENERIC_StretchBlt:FAR16
EXTERNDEF       Punt_StrBlt:NEAR

; gnstub.asm
EXTERNDEF       GENERIC_GetCharWidth:FAR16
EXTERNDEF       GENERIC_DeviceBitmap:FAR16
EXTERNDEF       GENERIC_EnumDFonts:FAR16
EXTERNDEF       GENERIC_EnumObj:FAR16
EXTERNDEF       GENERIC_FastBorder:FAR16
EXTERNDEF       GENERIC_GetPalette:FAR16
EXTERNDEF       GENERIC_GetPaletteTranslate:FAR16
EXTERNDEF       GENERIC_Inquire:FAR16
EXTERNDEF       GENERIC_ScanLR:FAR16
EXTERNDEF       GENERIC_SetAttribute:FAR16
EXTERNDEF       GENERIC_StrBlt:FAR16

; gnsysblt.asm
EXTERNDEF       GN_BitBltSrcVramDstSystem:NEAR
EXTERNDEF       OurRopSetup:NEAR
EXTERNDEF       DibengRopSetup:NEAR

; gntext.asm
EXTERNDEF       GENERIC_ExtTextOut:FAR16
EXTERNDEF       Punt_ExtTextOut:NEAR
EXTERNDEF       GN_ExtTextOutRet:NEAR
EXTERNDEF       GN_ExtTextOutSuccess:NEAR
EXTERNDEF       GN_ExtTextOutExit:NEAR
EXTERNDEF       GlyphBltByteIndexWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltWordIndexWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltByteIndexWordTableNoKerning:NEAR
EXTERNDEF       GlyphBltWordIndexWordTableNoKerning:NEAR
EXTERNDEF       GlyphBltByteIndexDWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltWordIndexDWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltByteIndexDWordTableNoKerning:NEAR
EXTERNDEF       GlyphBltWordIndexDWordTableNoKerning:NEAR

; gnvdd.asm
EXTERNDEF       dwThisLogicalDeviceHandle:DWORD
CLOSESEG _NVTEXT32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT16, USE16, CODE
; gnboard.asm
EXTERNDEF       GN_FindBoardContext:FAR16
EXTERNDEF       GN_CreateBoardContext:FAR16
EXTERNDEF       GN_DestroyBoardContext:FAR16
EXTERNDEF       GN_AttachLogicalDeviceToBoard:FAR16
EXTERNDEF       GN_ReattachLogicalDeviceToBoard:FAR16
EXTERNDEF       GN_DetachLogicalDeviceFromBoard:FAR16
EXTERNDEF       GN_GetPciDeviceID:FAR16
EXTERNDEF       GN_GetFrameBufferSelector:FAR16
EXTERNDEF       GN_GetNumCRTCs:FAR16
EXTERNDEF       GN_GetBoardRegistryPath:FAR16

; gnboard2.asm
EXTERNDEF       GN_BoardMessage:FAR16
EXTERNDEF       GN_FindFirstCloneDevice:FAR16
EXTERNDEF       GN_FindUnusedDevice:FAR16
EXTERNDEF       GN_SendDevicesRemapMsgToAllLogDevs:FAR16
EXTERNDEF       GN_FindLogdevWaitingToClone:FAR16
EXTERNDEF       GN_IsDevDataUniqueOnBoard:FAR16
EXTERNDEF       GN_GetAllDeviceData:FAR16
EXTERNDEF       GN_GetDevDataMask:FAR16

; gncntrl.asm
EXTERNDEF       GENERIC_Control:FAR16
EXTERNDEF       GN_ControlQuery:NEAR
EXTERNDEF       GN_ControlDDraw:NEAR
EXTERNDEF       GN_ControlDDrawNewCallbackFns:NEAR
EXTERNDEF       GN_ControlDDrawGet32BitDriverName:NEAR
EXTERNDEF       GN_ControlDDrawCreateDriverObject:NEAR
EXTERNDEF       GN_ControlDDrawDestroyDriverObject:NEAR
EXTERNDEF       GN_ControlDDrawDDVersionInfo:NEAR
EXTERNDEF       GN_MouseTrails:NEAR
EXTERNDEF       GN_ControlReturnPDevice:NEAR
EXTERNDEF       GN_ControlAllocSelectorAndMap:NEAR
EXTERNDEF       GN_ControlUnmapAndFreeSelector:NEAR
EXTERNDEF       GN_ControlSetCursor:NEAR
EXTERNDEF       GN_DvdMacrovisionCommand:NEAR
EXTERNDEF       GN_OpenGLGetInfo:NEAR
EXTERNDEF       GN_OpenGLCommand:NEAR
EXTERNDEF       GN_VideoParameters:NEAR
EXTERNDEF       GN_VpCommandGet:NEAR
EXTERNDEF       GN_VpCommandSet:NEAR
EXTERNDEF       GN_GetLocalRegistryPath:NEAR
EXTERNDEF       GN_GetRegistryModeList:NEAR

; gncrtc.asm
EXTERNDEF       GN_CreateCrtcContext:FAR16
EXTERNDEF       GN_DestroyCrtcContext:FAR16
EXTERNDEF       GN_SetLogicalCrtcInstance:FAR16
EXTERNDEF       GN_CrtcSetMonitorDevNode:FAR16
EXTERNDEF       GN_GetLargestEdidMode:FAR16
EXTERNDEF       GN_GetRefreshRateForDesktop:FAR16
EXTERNDEF       GN_DoOddballStuffAtBoot:FAR16
EXTERNDEF       GN_CheckAndMaybeReadEdid:FAR16
EXTERNDEF       GN_Far16GetModeSize:FAR16

; gncrtc2.asm
EXTERNDEF       GN_CrtcMessage:FAR16
EXTERNDEF       GN_RestoreCrtcState:FAR16
EXTERNDEF       GN_CrtcRemapArray:FAR16
EXTERNDEF       GN_RestoreAllCrtcStates:FAR16
EXTERNDEF       GN_CrtcDeviceHasBeenRemapped:FAR16
EXTERNDEF       GN_SetBytesPerPixelAndBytesPerLine:FAR16
EXTERNDEF       GN_SetPanRectangle:FAR16
EXTERNDEF       GN_GetDevData:FAR16
EXTERNDEF       GN_SetDevData:FAR16
EXTERNDEF       GN_AssignCrtcModeOnlyBackOffSpatial:FAR16
EXTERNDEF       GN_CrtcWriteModeToReg:FAR16
EXTERNDEF       GN_GetCrtcMode:FAR16
EXTERNDEF       GN_RestrictOtherModeSpatial:FAR16
EXTERNDEF       GN_RestrictCrtcModeSpatial:FAR16
EXTERNDEF       GN_SetCrtcMode:FAR16
EXTERNDEF       GN_GetDisplayDevice:FAR16
EXTERNDEF       GN_SetCrtcGamma:FAR16
EXTERNDEF       GN_GetCrtcGamma:FAR16
EXTERNDEF       GN_SetCrtcPalette:FAR16
EXTERNDEF       GN_ResetColorMap:FAR16

; gndisabl.asm
EXTERNDEF       GENERIC_Disable:FAR16
EXTERNDEF       GN_DisableDevice:NEAR
EXTERNDEF       GN_BlankScreen:NEAR

; gnenable.asm
EXTERNDEF       GENERIC_ReEnable:FAR16
EXTERNDEF       GENERIC_Enable:FAR16
EXTERNDEF       GN_EnableGdiInfo:NEAR
EXTERNDEF       GN_EnableDevice:NEAR
EXTERNDEF       GN_GetLogicalAndPhysicalModes:FAR16
EXTERNDEF       GN_SetLogicalAndPhysicalModes:FAR16
EXTERNDEF       GN_NoPrimarySurfaceRecovery:NEAR
EXTERNDEF       GN_DoFullStateChange:FAR16

; gngetid.asm
EXTERNDEF       GENERIC_GetDriverResourceID:FAR16

; gninit.asm
EXTERNDEF       wFlatDataSel_In_NVTEXT16:WORD
EXTERNDEF       CSlp16LogDevice_In_NVTEXT16:DWORD
EXTERNDEF       CSpGNLogicalDevice_In_NVTEXT16:DWORD
EXTERNDEF       lpfnFindModeEntry:DWORD
EXTERNDEF       lpfnFindVirtualModeEntry:DWORD
EXTERNDEF       lpfnGetModeList:DWORD
EXTERNDEF       lpfnGetDesktopModeList:DWORD
EXTERNDEF       lpfnSetVirtualDesktop:DWORD
EXTERNDEF       lpfnGetVirtualDesktop:DWORD
EXTERNDEF       lpfnSetDesktopState:DWORD
EXTERNDEF       lpfnGetDesktopState:DWORD
EXTERNDEF       lpfnSetAutoPanMode:DWORD
EXTERNDEF       lpfnGetAutoPanMode:DWORD
EXTERNDEF       lpfnSetTimingOverride:DWORD
EXTERNDEF       lpfnGetTimingOverride:DWORD
EXTERNDEF       lpfnGetBootDevice:DWORD
EXTERNDEF       lpfnGetLastDisplayFormat:DWORD
EXTERNDEF       lpfnGetDisplayDevice:DWORD
EXTERNDEF       lpfnSetDisplayDevice:DWORD
EXTERNDEF       lpfnGetRefreshRateForDesktop:DWORD
EXTERNDEF       lpfnGetForcedDesktopMode:DWORD
EXTERNDEF       lpfnGetLargestEdidMode:DWORD
EXTERNDEF       lpfnGetDeviceDesktopMode:DWORD
EXTERNDEF       lpfnSetDeviceDesktopMode:DWORD
EXTERNDEF       lpfnGetForcedDisplayMode:DWORD
EXTERNDEF       lpfnGetDeviceDisplayMode:DWORD
EXTERNDEF       lpfnSetDeviceDisplayMode:DWORD
EXTERNDEF       lpfnGetEdidRegistryKey:DWORD
EXTERNDEF       lpfnDeleteLocalRegEntry:DWORD
EXTERNDEF       lpfnResetRefreshRates:DWORD
EXTERNDEF       lpfnGetSafeTiming:DWORD
EXTERNDEF       lpfnSetResolutionAndColorDepth:DWORD
EXTERNDEF       lpfnGetControlVisionFlag:DWORD
EXTERNDEF       lpfnGetBootDeviceSelection:DWORD
EXTERNDEF       lpfnIsDriverAttachedToDesktop:DWORD
EXTERNDEF       lpfnGetAllowAllModesFlag:DWORD
EXTERNDEF       lpfnResetDisabledDeviceResolutions:DWORD
EXTERNDEF       lpfnGetAllowMightyModesFlag:DWORD
EXTERNDEF       lpfnGetCheckSXGAPanelFlag:DWORD
EXTERNDEF       lpfnGetClonePanningFlag:DWORD
EXTERNDEF       lpfnSetClonePanningFlag:DWORD
EXTERNDEF       lpfnFreeMasterLists:DWORD
EXTERNDEF       lpfnGetCloneDesktopSelection:DWORD
EXTERNDEF       lpfnGetRestrictLargestMode:DWORD
EXTERNDEF       lpfnGet1400x1050Override:DWORD
EXTERNDEF       lpfnGetMaxDfpMode:DWORD
EXTERNDEF       lpfnGetModesetStopImage:DWORD


EXTERNDEF       DllEntryPoint:FAR16
EXTERNDEF       GN_DllEntryPoint:FAR16
EXTERNDEF       GENERIC_WEP:FAR16
EXTERNDEF       WEP:FAR16
EXTERNDEF       GN_CreateConstants:FAR16
EXTERNDEF       GN_DestroyConstants:FAR16

; gnint2f.asm
EXTERNDEF       lpUserFullscreenDOSBoxFlag:DWORD

EXTERNDEF       GN_HookInt2F:FAR16
EXTERNDEF       GN_UnhookInt2F:FAR16
EXTERNDEF       Int2FHandler:FAR16
EXTERNDEF       Int2FSwitchingToWindows:FAR16
EXTERNDEF       Int2FSwitchingToDos:FAR16
EXTERNDEF       GENERIC_ResetHiresMode:FAR16
EXTERNDEF       GN_Int2FSwitchingToWindows:FAR16

; gnlogdev.asm
EXTERNDEF       GN_CreateLogdevContext:FAR16
EXTERNDEF       GN_DestroyLogdevContext:FAR16
EXTERNDEF       GN_SetGdiInfoPtr:FAR16
EXTERNDEF       GN_LogdevAttachCrtc:FAR16
EXTERNDEF       GN_LogdevDetachCrtc:FAR16
EXTERNDEF       GN_LogdevAddAClone:FAR16

; gnlogdev2.asm
EXTERNDEF       GN_LogdevMessage:FAR16
EXTERNDEF       GN_OffscreenHeapDisappearing:FAR16
EXTERNDEF       GN_ResolveDeviceConnectionsOnLoad:FAR16
EXTERNDEF       GN_ResolveDeviceConnectionsOnUnload:FAR16

; gnoffmgr.asm
EXTERNDEF       GN_ControlOffscreenAllocations:FAR16
EXTERNDEF       GN_OffscreenAllocationsLock:FAR16
EXTERNDEF       GN_OffscreenAllocationsUnlock:FAR16

; gnpanel.asm
EXTERNDEF       ControlPanelInterface:NEAR
EXTERNDEF       NV_SetGet_State:NEAR
EXTERNDEF       NV_SetGet_Device_Type:NEAR
EXTERNDEF       NV_SetDisplayDeviceType:NEAR
EXTERNDEF       NV_GetDisplayDeviceType:NEAR
EXTERNDEF       NV_SetGet_Autopan:NEAR
EXTERNDEF       NV_SetGet_VirtualMode:NEAR
EXTERNDEF       NV_SetGet_PhysicalMode:NEAR
EXTERNDEF       NV_SetGet_PhysicalModeImmediate:NEAR
EXTERNDEF       NV_ValidateVirtualMode:NEAR
EXTERNDEF       NV_ValidatePhysicalMode:NEAR
EXTERNDEF       NV_SetGet_Freeze_Origin:NEAR
EXTERNDEF       NV_SetGet_PanOffset:NEAR
EXTERNDEF       NV_SetGet_Primary_Crtc:NEAR
EXTERNDEF       GN_MapHeadToGNLogdev:FAR16

; gnpower.asm
EXTERNDEF       GN_PowerOn:FAR16
EXTERNDEF       GN_PowerOff:FAR16
EXTERNDEF       GN_VddSetPowerManagementCallbacks:FAR16

; gnrepnt
EXTERNDEF       GN_InitUserRepaint:FAR16
EXTERNDEF       GENERIC_UserRepaintDisable:FAR16
EXTERNDEF       GN_UserRepaint:FAR16
EXTERNDEF       GN_IssueUserRepaint:NEAR
EXTERNDEF       GN_CheckUserRepaint:FAR16

; gnthk16.asm
EXTERNDEF       wLog:WORD
EXTERNDEF       Patch_BitBlt:FAR16
EXTERNDEF       SetCursor:FAR16
EXTERNDEF       MoveCursor:FAR16
EXTERNDEF       SetPalette:FAR16
EXTERNDEF       Patch_BitmapBits:FAR16
EXTERNDEF       Control:FAR16
EXTERNDEF       Patch_ExtTextOut:FAR16
EXTERNDEF       Patch_DibBlt:FAR16
EXTERNDEF       FastBorder:FAR16
EXTERNDEF       Patch_Output:FAR16
EXTERNDEF       Patch_Pixel:FAR16
EXTERNDEF       RealizeObject:FAR16
EXTERNDEF       ReEnable:FAR16
EXTERNDEF       Patch_RealizeObject:FAR16
EXTERNDEF       Patch_ScanLR:FAR16
EXTERNDEF       Patch_SetDIBitsToDevice:FAR16
EXTERNDEF       Patch_SetPalette:FAR16
EXTERNDEF       SetPaletteTranslate:FAR16
EXTERNDEF       Patch_StrBlt:FAR16
EXTERNDEF       Patch_StretchBlt:FAR16
EXTERNDEF       Patch_StretchDIBits:FAR16
EXTERNDEF       Patch_SaveScreenBitmap:FAR16
EXTERNDEF       Patch_UpdateColors:FAR16
EXTERNDEF       GENERIC_OutputDebugString:FAR16

; gnvalmod
EXTERNDEF       ValidateMode:FAR16
EXTERNDEF       GENERIC_ValidateMode:FAR16
EXTERNDEF       GN_ValidatePhysicalMode:FAR16
EXTERNDEF       GN_GetFreeBlockSizeForMode:FAR16
EXTERNDEF       GN_CheckForMultipleOf8Mode:FAR16

; gnvdd.asm
EXTERNDEF       lpfnVddEntryPoint:DWORD
EXTERNDEF       dwThisLogicalDeviceHandle_In_NVTEXT16:DWORD
EXTERNDEF       GN_VddGetEntryPoint:FAR16
EXTERNDEF       GN_VddGetDeviceHandle:FAR16
EXTERNDEF       GN_VddEnableDevice:FAR16
EXTERNDEF       GN_VddCloseDevice:FAR16
EXTERNDEF       GN_VddGetDisplayInfo:FAR16
EXTERNDEF       GN_VddDriverRegister:FAR16
EXTERNDEF       GN_VddDriverUnregister:FAR16
EXTERNDEF       GN_VddRegisterDisplayDriver:FAR16
EXTERNDEF       GN_VddSaveDriverState:FAR16
EXTERNDEF       GN_VddEnableIOTrapping:FAR16
EXTERNDEF       GN_VddSetLockAndUnlockOffscreen:FAR16
EXTERNDEF       GN_VddReenumerateDevNode:FAR16
EXTERNDEF       GN_VddDriverRegister:FAR16
EXTERNDEF       GN_VddSaveDriverState:FAR16
EXTERNDEF       GN_VddEnableIOTrapping:FAR16
EXTERNDEF       GN_VddGetDisplayInfo:FAR16
EXTERNDEF       GN_VddIsDriverAttachedToDesktop:FAR16

;  gnwrap.asm
EXTERNDEF       BitBlt_WithExclude:FAR16
EXTERNDEF       Pixel_WithExclude:FAR16
EXTERNDEF       ScanLR_WithExclude:FAR16
EXTERNDEF       ExtTextOut_WithExclude:FAR16
EXTERNDEF       SetDIBitsToDevice_WithExclude:FAR16
EXTERNDEF       UpdateColors_WithExclude:FAR16
EXTERNDEF       StretchBlt_WithExclude:FAR16
EXTERNDEF       StretchDIBits_WithExclude:FAR16
EXTERNDEF       SaveScreenBitmap_WithExclude:FAR16
EXTERNDEF       Output_WithExclude:FAR16
EXTERNDEF       GN_TurnExcludeOffOrOn:FAR16
CLOSESEG _NVTEXT16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DIBENG exports
EXTERNDEF       DIB_BeginAccess:FAR16
EXTERNDEF       DIB_EndAccess:FAR16
EXTERNDEF       DIB_BitBlt:FAR16
EXTERNDEF       DIB_BitmapBits:FAR16
EXTERNDEF       DIB_ColorInfo:FAR16
EXTERNDEF       DIB_Control:FAR16
EXTERNDEF       DIB_DibBltExt:FAR16
EXTERNDEF       DIB_Disable:FAR16
EXTERNDEF       DIB_Enable:FAR16
EXTERNDEF       DIB_EnumObjExt:FAR16
EXTERNDEF       DIB_ExtTextOut:FAR16
EXTERNDEF       DIB_GetCharWidth:FAR16
EXTERNDEF       DIB_GetPaletteExt:FAR16
EXTERNDEF       DIB_GetPaletteTranslateExt:FAR16
EXTERNDEF       DIB_Inquire:FAR16
EXTERNDEF       DIB_Output:FAR16
EXTERNDEF       DIB_Pixel:FAR16
EXTERNDEF       DIB_RealizeObjectExt:FAR16
EXTERNDEF       DIB_ScanLR:FAR16
EXTERNDEF       DIB_DibToDevice:FAR16
EXTERNDEF       DIB_SetPaletteExt:FAR16
EXTERNDEF       DIB_SetPaletteTranslateExt:FAR16
EXTERNDEF       DIB_StrBlt:FAR16
EXTERNDEF       DIB_StretchBlt:FAR16
EXTERNDEF       DIB_StretchDIBits:FAR16
EXTERNDEF       DIB_UpdateColorsExt:FAR16
EXTERNDEF       DIB_SetCursorExt:FAR16
EXTERNDEF       DIB_MoveCursorExt:FAR16
EXTERNDEF       DIB_CheckCursorExt:FAR16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\GNBOARD.H ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       gnboard.h

    Purpose:    This file holds structures and equates dealing with the
                GNBOARDCX.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// The following data structure holds information about a logical device
// to board context.

typedef struct  _LOGDEVTOBOARD
{
    ULONG   dwBoardDevnodeHandle;
    ULONG   dwGNBoardCXOffset;
}   LOGDEVTOBOARD;

// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// The following data structure holds information about a particular
// offscreen bitmap. There is an array of these structures.

typedef struct  _OFFBMPINFO
{
    ULONG   dwBitmapSel;
    ULONG   dwBitmapOffset;
    ULONG   dwBitmapLength;
    ULONG   dwBitmapVRAMOffset;
}   OFFBMPINFO;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// The following is for the shared memory allocation escapes.
typedef struct  _ID_AND_DATA
{
    ULONG   dwID;
    ULONG   dwData;
}   ID_AND_DATA;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;;;;;;;;;;;;;;;;  The Generic Board Context  ;;;;;;;;;;;;;;;;;;;;;;;;

#define MAX_OFFSCREEN_BITMAPS       0x0300
#define MAX_SHARED_MEM_BLOCKS       0x04

typedef struct  _GNBOARDCX
{
    // Set to 1 when initting. Cleared on first modeset.
    ULONG       dwInitting;

    // How many CRTCs are available on this board?
    ULONG       dwNumCrtcsOnBoard;

    // How many GNLOGDEV structs are attached to this board.
    ULONG       dwLogicalDeviceInstancesOnThisBoard;

    // Here are all the logical devices attached to the board
    ULONG       pGNLogdevCX[MAX_ATTACHED_CRTCS];

    // This is the flat data selector that this board is using.
    ULONG       dwFlatDataSelector;

    // This field is TRUE if DX is active, and FALSE if not.
    ULONG       dwDirectXActive;

    // Keep track of this.
    ULONG       pHWBoardCX;

    // This variable holds the number of bytes of video memory needed
    // to validate mode.
    ULONG       dwMemorySizeForValidateMode;

    // This is the registry path that this board will be using as
    // the local base path -- the place in the registry where values
    // specific to this board are stored.
    ULONG       dwDeviceNodeHandle;
    ULONG       lpLocalDisplayBasePath;
    UCHAR       szLocalDisplayBasePath[128];

    // The starting offset and length in video memory of the space
    // available for offscreen allocations.
    ULONG       dwOffscreenBaseAddress;
    ULONG       dwOffscreenLength;

    // Offscreen Memory And Bitmap Management
    ULONG       dwOffscreenHeap;
    ULONG       dwOffscreenFlags;
    ULONG       dwOffscreenLockCount;

    ULONG       dwOffscreenBitmapsAllocatedSinceLastFlush;
    ULONG       dwOffscreenBitmapsCurrentlyAllocated;
    ULONG       dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps;
    ULONG       pNextOffbmpinfo;
    OFFBMPINFO  OffscreenBitmapCache[MAX_OFFSCREEN_BITMAPS];

    // Used for some crazy display device management stuff.
    ULONG       dwCheckCursorTicksSinceSecondDriverLoaded;
    ULONG       dwOldTwinviewState;
    ULONG       dwOldPrimaryDevData;
    ULONG       dwOldCloneDevData;

    // This array is for shared memory allocated by clients.
    ID_AND_DATA sSharedMemBlocks[MAX_SHARED_MEM_BLOCKS];
}   GNBOARDCX;

// These flags can be used in the dwOffscreenFlags field.
#define OFFS_ALLOCS_BLOCKED         0x0001
#define OFFS_HEAP_UNAVAILABLE       0x0002
#define NO_OFFS_BMPS                0x0003
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\COLORTAB.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

        title   Control Panel Color Table
	%out	config
	page	,132


RGB     macro   R, G, B
        db      R,G,B,0
	endm



COLORTABLE  segment public

        dw  48                  ; # colors in table
        RGB 0FFh,080h,080h
        RGB 0FFh,0FFh,0E8h
        RGB 080h,0FFh,080h
        RGB 000h,0FFh,080h
        RGB 080h,0FFh,0FFh
        RGB 000h,080h,0FFh
        RGB 0FFh,080h,0C0h
        RGB 0FFh,080h,0FFh
        RGB 0FFh,000h,000h
        RGB 0FFh,0FFh,080h
        RGB 080h,0FFh,000h
        RGB 000h,0FFh,040h
        RGB 000h,0FFh,0FFh
        RGB 000h,080h,0C0h
        RGB 080h,080h,0C0h
        RGB 0FFh,000h,0FFh
        RGB 080h,040h,040h
        RGB 0FFh,0FFh,000h
;       RGB 0FFh,080h,040h
        RGB 000h,0FFh,000h
        RGB 000h,080h,080h
        RGB 000h,040h,080h
        RGB 080h,080h,0FFh
        RGB 080h,000h,040h
        RGB 0FFh,000h,080h
        RGB 080h,000h,000h
        RGB 0FFh,080h,000h
        RGB 000h,080h,000h
        RGB 000h,080h,040h
        RGB 000h,000h,0FFh
        RGB 000h,000h,0A0h
        RGB 080h,000h,080h
        RGB 080h,000h,0FFh
        RGB 040h,000h,000h
        RGB 080h,040h,000h
        RGB 000h,040h,000h
        RGB 000h,040h,040h
        RGB 000h,000h,080h
        RGB 000h,000h,040h
        RGB 040h,000h,040h
        RGB 040h,000h,080h
        RGB 000h,000h,000h
        RGB 080h,080h,000h
        RGB 080h,080h,040h
        RGB 080h,080h,080h
        RGB 040h,080h,080h
        RGB 0C0h,0C0h,0C0h
        RGB 082h,082h,082h
        RGB 0FFh,0FFh,0FFh
COLORTABLE     ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\GNCRTC.h ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       gncrtc.h

    Purpose:    This file holds structures and equates dealing with the
                GNCRTCCX.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

#define MAX_DISPDATA_SIZE                   96
#define MAX_EDID_BUFFER_SIZE                512
#define MAX_MODEINFO_SIZE                   48
#define MAX_MODEOUT_SIZE                    40
#define MIN_TICKS_BEFORE_REREADING_EDID     40

///////////////////////////////////////////////////////////////////////
#define XOR_DATA_SIZE   ((CURSOR_WIDTH * CURSOR_HEIGHT) * 4)

typedef struct  _CURSOREXTRA
{
    ULONG       dwCursorType;       // This is for H/W specific code
    ULONG       dwCursorHash;       // This is for generic code
}   CURSOREXTRA;

typedef struct  _CURSORDESCEX
{
    CURSOREXTRA ExtraData;
    USHORT      wHotX;
    USHORT      wHotY;
    USHORT      wWidth;
    USHORT      wHeight;
    USHORT      wWidthBytes;
    UCHAR       bPlanes;
    UCHAR       bBitsPerPixel;
    UCHAR       bCursorAndMask[AND_MASK_SIZE];
    UCHAR       bCursorXorData[XOR_DATA_SIZE];
}   CURSORDESCEX;

//  This structure is immediately followed by some number of
//  CURSORDESC structures which hold all the cached cursor desciptions.
typedef struct  _CURSORCACHE
{
    ULONG       dwCursorFlags;
    USHORT      wCursorX;
    USHORT      wCursorY;
    ULONG       dwNextCacheSlot;
    ULONG       dwSelectedCacheSlot;
}   CURSORCACHE;

// These flags are for the dwCursorFlags field in the CURSORCACHE structure
// The interrupt handler which changes cursor settings will only look at
// the low 3 bits if the CURSOR_IS_NULL bit is not set.

#define CURSOR_HAS_TRAILS       0x0001
#define CURSOR_MOVE             0x0002
#define CURSOR_SELECT           0x0004
#define CURSOR_IS_NULL          0x0008
#define CURSOR_SEMAPHORE        0x0010
#define CURSOR_IS_SOFTWARE      0x0020
#define CURSOR_SEMAPHORE_BIT    4

// Bits 8 through 31 are the 'SETTING' bits. They indicate that SetCursor
// was called with a cursor pattern, but the pattern has not yet been
// supplied to the hardware. Bit n set means that the cursor corresponding
// to Cache slot n-8 needs to be placed in the hardware's cache. This is
// done to allow for lazy setting of cursor shapes. The CURSOR_SET bit
// is a global SETTING bit to indicate at least one of bits 8 - 31 is set.
#define NUM_CURSOR_FLAGS        8
#define MAX_CACHEABLE_CURSORS   (32 - NUM_CURSOR_FLAGS)

#if (MAX_CACHEABLE_CURSORS > (32 - NUM_CURSOR_FLAGS))
    error
#endif
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;; The Generic CRTC Instance Specific portion of the DEVICE ;;;;;;;;
typedef struct  _GNCRTCCX
{
    // 1 means we are initting. Cleared to 0 on first mode set.
    ULONG           dwInitting;

    // This GNCRTCCX is tied to the following board.
    ULONG           pGNBoardCX;

    // The HW specific crtc context data ptr
    ULONG           pHWCrtcCX;

    // For VideoMirror modes, the Video module issues an Escape to
    // "LOCK" the hw crtccx. What this means is that the GNCRTCCX
    // no longer controls the HW CRTC. To implement this, we NULL
    // out the pHWCrtcCX ptr above. In order that we can still
    // make some hwcrtc calls (just to get state information and
    // maybe do macrovision), we keep a copy of what the HWCRTCCX
    // was in the field below.
    ULONG           pHWCrtcCXWhenLocked;

    // This gives the windows logical device number considering this
    /// board as 0 based. So in normal and clone mode, this will be 0.
    // In multi-mon mode, this number is 0 or 1 (for a 2 head board.)
    ULONG           dwLogicalDeviceInstance;

    // This is a number from 0 to the number of physical devices - 1
    // as an ordinal. It tells which physical device number this is
    // that is attached to the logical device in the prior variable.
    // So for normal and multi-mon mode this will be a 0. For clone
    // mode, you can have several physical devices attached to a
    // given logical device. This would tell which one it is.
    ULONG           dwPhysicalDeviceInstance;

    // This is true if this is the primary CRTC.
    ULONG           dwBootCrtc;

    // This is the registry path that this CRTC will be using as
    // the local monitor base path -- the place in the registry
    // where values specific to the monitor are stored. It may not,
    // however, always be valid since the user can plug new monitors
    // in on the fly. Basically it tells the last .inf that was
    // installed, or the EDID monitor that was seen at boot.
    ULONG           lpLocalMonitorBasePath;
    UCHAR           szLocalMonitorBasePath[128];

    // There is some data in the DISPDATA structure that is specific
    // to each CRTC.
    ULONG           lpBoardRegistryData;
    ULONG           lpNvmodeDispData;
    ULONG           sNvmodeDispData[(MAX_DISPDATA_SIZE + 3) / 4];
    ULONG           lpCrtcModeOut;
    ULONG           sCrtcModeOut[(MAX_MODEOUT_SIZE + 3) / 4];

    // Save the Edid buffer so we don't have to reread all the time.
    ULONG           lpEdidBuffer;
    UCHAR           sEdidBuffer[MAX_EDID_BUFFER_SIZE];
    ULONG           dwEdidSize;

    // Don't want to read the EDID too often because if a monitor
    // doesn't have an EDID, the timeouts take a long time.
    ULONG           dwTicksSinceLastEdidRead;

    // Tells how many bits per color gun the hardware supports for this CRTC
    ULONG           dwBitsPerColorChannel;

    // Tells how many cached cursor slots the hardware has allowed.
    ULONG           dwMaxCacheableCursors;

    // When changing the display device, we ask Windows to recompute
    // the .inf status by reenumerating the attached display devices.
    // Unfortunately, this is asyncronous, and so the modeset that
    // occurs when changing display devices will not give a valid
    // .inf status. This flag tells us to ignore the status
    ULONG           dwDisplayDeviceChange;

    // Our cursor cache for this CRTC
    ULONG           pCursorCache;

    // A flag to indicate whether pan and scan is enabled and also
    // the coordinates of the monitor viewport on the desktop.
    // Enough additional stuff to fully specify the mode.
    ULONG           dwPanAndScanEnabled;
    MYRECTL         rcPhysicalViewport;
    ULONG           dwBytesPerPixelInCurrentMode;
    ULONG           dwBytesPerLineInCurrentMode;
    UCHAR           sCrtcModeInfo[MAX_MODEINFO_SIZE];
    ULONG           lpCrtcModeInfo;

    // The LOGDEV needs one copy of these for each CRTC
    ULONG           dwPaletteTable[256];
    ULONG           dwGammaTable[256];
}   GNCRTCCX;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\CONFIG.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

	title	Hardware Dependent Parameters
	%out	config
	page	,132


RGB     macro   R, G, B
        db      R,G,B,0
	endm



OEM	segment public

;	Machine dependent parameters

        dw      17                      ;Height of vertical thumb
        dw      17                      ;Width of horizontal thumb
	dw	2			;Icon horiz compression factor
	dw	2			;Icon vert compression factor
; Notes on the cursor compression factors:
;       Cursor size = int(32 / compression factor)
;       i.e. 1 = 32 pixels, 2 = 16, 3 = 10, 4 = 8, 5 = 6, 6 = 5, 7 = 4, 8 = 4, ... 32 = 1
;       DO NOT USE 0 - Windows98 will shut down immediately (divide by 0 probably...)
;       64 will give you a single 32x32 cursor
;       -1 gives NO cursor - always calls SetCursor with NULL
	dw	1			;Cursor horz compression factor
	dw	1			;Cursor vert compression factor
	dw	0			;Kanji window height
	dw	1			;cxBorder (thickness of vertical lines)
	dw	1			;cyBorder (thickness of horizontal lines)

;	Default system color values

        RGB 192,192,192     ;clrScrollbar
        RGB 192,192,192     ;clrDesktop
        RGB 000,000,128     ;clrActiveCaption
        RGB 255,255,255     ;clrInactiveCaption
        RGB 255,255,255     ;clrMenu
        RGB 255,255,255     ;clrWindow
        RGB 000,000,000     ;clrWindowFrame
        RGB 000,000,000     ;clrMenuText
        RGB 000,000,000     ;clrWindowText
        RGB 255,255,255     ;clrCaptionText
        RGB 192,192,192     ;clrActiveBorder
        RGB 192,192,192     ;clrInactiveBorder
        RGB 255,255,255     ;clrAppWorkspace
        RGB 000,000,128     ;clrHiliteBk
        RGB 255,255,255     ;clrHiliteText
        RGB 192,192,192     ;clrBtnFace
        RGB 128,128,128     ;clrBtnShadow
        RGB 192,192,192     ;clrGrayText
        RGB 000,000,000     ;clrBtnText


;	dw	0			;Unused words
;	dw	0
;	dw	0
;	dw	0
;	dw	0
;	dw	0
	dw	0
	dw	0

OEM	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\FONTS.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

	title	High Resolution Font Definitions
	%out	fonts
	page	,132




OEM	segment public


;	OEM Font Description

OEMFixed	dw	12		;lfheight
		dw	8		;lfwidth
		dw	0		;lfescapement
		dw	0		;character orientation
		dw	0		;weight
		db	0		;Italic
		db	0		;underline
		db	0		;strikeout
		db	255		;charset
		db	0		;output precision
		db	2		;clip precision
		db	2		;quality
		db	1		;pitch
		db	'Terminal',0	;face

;	Ansi Fixed Font Description

AnsiFixed	dw	12		;lfheight
		dw	9		;lfwidth
		dw	0		;lfescapement
		dw	0		;character orientation
		dw	0		;weight
		db	0		;Italic
		db	0		;underline
		db	0		;strikeout
		db	0		;charset
		db	0		;output precision
		db	2		;clip precision
		db	2		;quality
		db	1		;pitch
		db	'Courier',0	;face

;	Ansi Variable Pitch Font Definition

AnsiVar 	dw	12		;lfheight
		dw	9		;lfwidth
		dw	0		;lfescapement
		dw	0		;character orientation
		dw	0		;weight
		db	0		;Italic
		db	0		;underline
		db	0		;strikeout
		db	0		;charset
		db	0		;output precision
		db	2		;clip precision
		db	2		;quality
		db	2		;pitch
		db	'Helv',0	;face


OEM	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\FONTS120.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

        title   High Resolution Font Definitions
        %out    fonts
        page    ,132


        FONT_WIDTH      equ     10
        FONT_HEIGHT     equ     20


OEM     segment public


;       OEM Font Description

OEMFixed        dw      FONT_HEIGHT     ;lfheight
                dw      FONT_WIDTH      ;lfwidth
                dw      0               ;lfescapement
                dw      0               ;character orientation
                dw      0               ;weight
                db      0               ;Italic
                db      0               ;underline
                db      0               ;strikeout
                db      255             ;charset
                db      0               ;output precision
                db      2               ;clip precision
                db      2               ;quality
                db      1               ;pitch
                db      'Terminal',0    ;face

;       Ansi Fixed Font Description

AnsiFixed       dw      12              ;lfheight
                dw      9               ;lfwidth
                dw      0               ;lfescapement
                dw      0               ;character orientation
                dw      0               ;weight
                db      0               ;Italic
                db      0               ;underline
                db      0               ;strikeout
                db      0               ;charset
                db      0               ;output precision
                db      2               ;clip precision
                db      2               ;quality
                db      1               ;pitch
                db      'Courier',0     ;face

;       Ansi Variable Pitch Font Definition

AnsiVar         dw      12              ;lfheight
                dw      9               ;lfwidth
                dw      0               ;lfescapement
                dw      0               ;character orientation
                dw      0               ;weight
                db      0               ;Italic
                db      0               ;underline
                db      0               ;strikeout
                db      0               ;charset
                db      0               ;output precision
                db      2               ;clip precision
                db      2               ;quality
                db      2               ;pitch
                db      'Helv',0        ;face



OEM     ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWBOARD2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwboard2.asm
;
; Purpose:      This file contains all the hardware specific BOARD
;               routines for run-time. The board specific init
;               routines are in hwboard.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include nvcm.inc
include nvreg.inc
include hwmacs.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include nvos.inc
include modeext.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BoardMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BoardMessage, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        jmp     DoneIt

PreMS:
        ; OpenGL mode switch count must be changed to an odd
        ; number before setting the mode.
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        or      ds:[esi].HWBOARDCX.dwModeSwitchCount,1

        ; Wait until everyone goes idle
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; JKTODO - Talk to the RM guys about getting rid of this.
        ; We can't possibly need it.  One thing that happens right
        ; now is that if the RM sees this call come before a heap
        ; allocation, then they treat the heap as an NV11 type heap
        ; where nothing goes away on a modeset. But I'm sure we can
        ; work out some better strategy than using this call.
        push    esi
        call    Enable_HiRes
        jmp     DoneIt

PostMS:
        ; Sync with other channels
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Reset the two offsets and pitches
        mov     eax,ds:[esi].HWBOARDCX.dwMinContextSurface2dPitch
        imul    eax,10001H
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax
        mov     eax,0FFFF0000h
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset,eax
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        push    esi
        push    eax
        mov     ebx,dwData1
        push    ds:[ebx].DIBENGINEHDR.deDeltaScan
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        call    SetDstBaseAndPitchToDsEdi
        SETPUTPTR ds,esi,edi

        ; OpenGL mode switch should be bumped to next even number
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        and     ds:[esi].HWBOARDCX.dwModeSwitchCount,-2

        ; We are no longer initting after the first modeset
        mov     ds:[esi].HWBOARDCX.dwInitting,0
        jmp     DoneIt

DXEnum:
DXOn:
DXOff:
        jmp     DoneIt

DosOff:
PowerOn:
        push    esi
        call    Enable_HiRes

        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        and     ds:[esi].HWBOARDCX.dwModeSwitchCount,-2
        jmp     DoneIt

DosOn:
PowerOff:
        push    esi
        call    Enable_VGA

        ; OpenGL mode switch count must be changed to an odd
        ; number before setting the mode or while in DOS or POWERDOWN.
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        or      ds:[esi].HWBOARDCX.dwModeSwitchCount,1
        jmp     DoneIt

DrvDis:
        ; Always enable VGA mode for the boards with single head.
        cmp     ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard,1
        je      @F

        ; Check for the secondary device to prevent FIFO disable.
        ; dwData2 = dwThisLogicalDeviceHandle.
        cmp     dwData2,1
        je      @F
        test    dwData2, 03H
        jnz     DoneIt

@@:
        ; OpenGL mode switch count must be changed to an odd
        ; number before setting the mode or while in DOS.
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        or      ds:[esi].HWBOARDCX.dwModeSwitchCount,1

        push    esi
        call    Enable_VGA
        jmp     DoneIt

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     Enable_HiRes
;
; Purpose:      This routine calls the ResMan to disable VGA (enable hires)
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC Enable_HiRes, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi

        ; Tell RM to disable VGA
        pushd   0
        mov     eax,pHWBoardCXOffset
        push    ds:[eax].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigVga

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     Enable_VGA
;
; Purpose:      This routine calls the ResMan to enable VGA (disable hires)
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC Enable_VGA, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi

        ; Tell RM to enable VGA
        pushd   1
        mov     eax,pHWBoardCXOffset
        push    ds:[eax].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigVga

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetLargestOffscreenBlock
;
; Purpose:      This routine returns the size in bytes of the
;               largest contiguous offscreen block.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax     length in bytes of offscreen block
;               ebx     offset in bytes of offscreen block
;
;               eax can be 0 if there is no offscreen memory
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetLargestOffscreenBlock, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     heapParams.NVIOCONTROL_hObjectParent,NV_WIN_DEVICE
        mov     heapParams.NVIOCONTROL_owner,GDI2D_HEAP_OWNER
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_INFO

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        ; Return the correct things
        ; The size field is the size of the largest linearly
        ; contguous free block.
        mov     eax,heapParams.NVIOCONTROL_size
        mov     ebx,heapParams.NVIOCONTROL_offset
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     HW_GetLargestOffscreenSpace
;
; Purpose:      This routine returns the size in bytes of the
;               largest TWO contiguous offscreen spaces assuming
;		that the allocations at offset1 and offset2 are
;		free (note, the offset1 and offset2 allocations
;		are NOT freed, but the contiguous block sizes
;		returned are what they would be IF THE TWO
;		offets were freed.)
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               offset1                 framebuffer offset or -1
;               offset2                 offscreen heap offset or -1
;
; Returns:
;               eax     length of largest contiguous offscreen
;			block in bytes. (can be 0, if none available)
;               eax     length of second largest contiguous offscreen
;			block in bytes. (can be 0, if none available)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetLargestOffscreenSpace, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   offset1
PARMD   offset2
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     heapParams.NVIOCONTROL_hObjectParent,NV_WIN_DEVICE
        mov     heapParams.NVIOCONTROL_owner,GDI2D_HEAP_OWNER
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_INFO_FREE_BLOCKS
        mov     eax,offset1
        mov     heapParams.NVIOCONTROL_offset,eax
        mov     eax,offset2
        mov     heapParams.NVIOCONTROL_limit,eax

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        ; Return the correct things
        ; The size field is the size of the largest linearly
        ; contguous free block.
        mov     eax,heapParams.NVIOCONTROL_size
        sub	ebx,ebx
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     HW_AllocOffscreenBlock
;
; Purpose:      This routine allocates a block of offscreen
;               memory the size requested.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwSizeInBytesToAlloc
;
; Returns:
;               eax     offset into video memory of start of offscreen block
;               ebx     length in bytes of offscreen block
;
;               eax can be 0 if there isn't a contguous block
;               of the size requested.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocOffscreenBlock, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwSizeInBytesToAlloc
OPENPROC
        push    pHWBoardCXOffset
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_HEAP_OWNER
        pushd   NVIOCONTROL_TYPE_IMAGE
        push    dwSizeInBytesToAlloc
        call    NV_OffscreenHeapAlloc
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreeOffscreenBlock
;
; Purpose:      This routine frees a block of offscreen memory
;               that was allocated via HW_AllocOffscreenBlock.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOffsetToBlockStart
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreeOffscreenBlock, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOffsetToBlockStart
OPENPROC
        ; Comment to avoid assembler error.
        push    pHWBoardCXOffset
        pushd   GDI2D_HEAP_OWNER
        push    dwOffsetToBlockStart
        call    NV_OffscreenHeapFree
CLOSEPROC



;==============================================================================
;
; Function:     HW_OffscreenHeapPurge
;
; Purpose:      This function purges the offscreen heap of all
;               allocations whose owner is GDI2D_HEAP_OWNER.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_OffscreenHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        push    pHWBoardCXOffset
        pushd   GDI2D_HEAP_OWNER
        call    NV_OffscreenHeapPurge
CLOSEPROC


DX_HEAP_ID      TEXTEQU <'NVDX'>
;==============================================================================
;
; Function:     HW_DxHeapPurge
;
; Purpose:      This function purges the offscreen heap of all
;               allocations whose owner is DX_HEAP_ID.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DxHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        push    pHWBoardCXOffset
        pushd   DX_HEAP_ID
        call    NV_OffscreenHeapPurge
CLOSEPROC


;==============================================================================
;
; Function:     HW_HeapPurgeAllExceptPrimarySurface
;
; Purpose:      This routine purges everything except for a non-NVRM primary
;               surface.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_HeapPurgeAllExceptPrimarySurface, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     heapParams.NVIOCONTROL_hObjectParent,NV_WIN_DEVICE
        mov     heapParams.NVIOCONTROL_owner,GDI2D_HEAP_OWNER
        mov     heapParams.NVIOCONTROL_function,NVOS11_HEAP_DESTROY

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        ; Now that everything is purged, we need to realloc 'NVBD'.
        call    NV_AllocRequiredMemory

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_AllocPrimarySurface
;
; Purpose:      This routine allocates a block of offscreen
;               memory for a primary surface.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwSizeInBytesToAlloc
;
; Returns:
;               eax     offset into video memory of start of offscreen block
;                       (-1 if failure)
;               ebx     length in bytes of offscreen block
;
;
;               This routine really can't fail. Do whatever
;               you can to make it succeed.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocPrimarySurface, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwPitch
PARMD   dwHeight
PARMD   dwCRTCIndex
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        push    pHWBoardCXOffset
        pushd   NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT
        pushd   GDI2D_DESKTOP_OWNER
        mov     eax,dwCRTCIndex
        shl     eax,31
        or      eax,NVIOCONTROL_TYPE_PRIMARY
        push    eax
        mov     eax,dwHeight
        shl     eax,10H
        mov     ax,word ptr dwPitch
        push    eax
        call    NV_OffscreenHeapAlloc
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreePrimarySurface
;
; Purpose:      This routine frees a block of offscreen
;               memory that is used as an offscreen surface.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOffsetToBlockStart    vram offset to start of block to free
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreePrimarySurface, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOffsetToBlockStart
OPENPROC
        push    pHWBoardCXOffset
        pushd   GDI2D_DESKTOP_OWNER
        push    dwOffsetToBlockStart
        call    NV_OffscreenHeapFree
CLOSEPROC


;==============================================================================
;
; Function:     HW_PrimarySurfaceHeapPurge
;
; Purpose:      This routine purges all primary surface allocations
;               from video memory.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_PrimarySurfaceHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        push    pHWBoardCXOffset
        pushd   GDI2D_DESKTOP_OWNER
        call    NV_OffscreenHeapPurge
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetPciDeviceID
;
; Purpose:      This function gets the PCI Device ID for this board.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax                     PCI Device ID
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetPciDeviceID, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset
        pushd   NV_CFG_PCI_ID
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigGet
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetFrameBufferSelector
;
; Purpose:      This function gets the frame buffer selector.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax                     frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetFrameBufferSelector, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset
        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySel
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     HW_GetModeDimensions
;
; Purpose:      This function gets the pitch and the amount of memory
;               used for the mode specified.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwXResolution           Xresolution of mode
;               dwYResolution           Yresolution of mode
;               dwBitsPerPixel          Bits Per Pixel of mode
;
; Returns:      eax             Pitch in bytes for the mode
;               ebx             Total amount of memory in bytes for the mode
;                               (including tiling)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetModeDimensions, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwXResolution
PARMD   dwYResolution
PARMD   dwBitsPerPixel
LOCALV  Params,NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS
OPENPROC

        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        ; Get the parameters for NV_CFGEX_GET_SURFACE_PITCH from stack.
        mov     eax,dwXResolution
        mov     Params.dwWidth,eax
        mov     eax,dwYResolution
        mov     Params.Height,eax
        mov     eax,dwBitsPerPixel
        mov     Params.Depth,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS
        mov     ecx,NV_CFGEX_GET_SURFACE_DIMENSIONS
        call    NV_ConfigExCall

        ; Return pitch in DX:AX
        mov     eax,Params.Pitch
        mov     ebx,Params.dwSize

		cmp		ds:[esi].HWBOARDCX.dwStereoConnectionType, INTERLACED_STEREO
		jnz		@F
		shl		eax, 1
		shl		ebx, 1
@@:

        POPR    esi

CLOSEPROC


;==============================================================================
;
; Function:     HW_GetNumCRTCs
;
; Purpose:      This routine returns the number of CRTCs on the
;               board.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      eax     Num total CRTCs on the board
;               ebx     number of available CRTCs
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetNumCRTCs, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset
        mov     ecx,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        mov     eax,1
        sub     ebx,ebx
Back1:
        test    eax,ds:[esi].HWBOARDCX.dwCRTCsAllocatedFlags
        jnz     @F
        inc     ebx
@@:     shl     eax,1
        dec     ecx
        jne     Back1

        mov     eax,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_ConfigExCall
;
; Purpose:      This function returns TRUE if the monitor is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds:esi  HWBOARDCX
;               eax     16:16 ptr to particular EX structure
;               ebx     size of particular ex structure in bytes
;               ecx     index of EX function
;
; Returns:      eax     status
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_ConfigExCall, PASCAL, FRAME, FAR32
LOCALV  sExGetParams,NVOS_CONFIG_GET_EX_PARAMS
OPENPROC
        ; Get client
        mov     sExGetParams.paramSize,ebx
        mov     sExGetParams.index,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     sExGetParams.hClient,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwhDevice
        mov     sExGetParams.hDevice,ecx

        ; Get flat ptr to EX structure
        push    eax
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        pop     ebx
        and     ebx,0FFFFh
        add     eax,ebx
        mov     sExGetParams.paramStructPtr,eax

        ; Call ConfigGetEx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sExGetParams
        push    eax
        call    FFP16 PTR lpfnArch_Nv04ConfigGetEx

        mov     eax,sExGetParams.status
CLOSEPROC

;==============================================================================
;
; Function:     NV_ConfigExSetCall
;
; Purpose:      This function returns TRUE if the monitor is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds:esi  HWBOARDCX
;               eax     16:16 ptr to particular EX structure
;               ebx     size of particular ex structure in bytes
;               ecx     index of EX function
;
; Returns:      eax     status
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_ConfigExSetCall, PASCAL, FRAME, FAR32
LOCALV  sExSetParams,NVOS_CONFIG_SET_EX_PARAMS
OPENPROC
        ; Get client
        mov     sExSetParams.paramSize,ebx
        mov     sExSetParams.index,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     sExSetParams.hClient,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwhDevice
        mov     sExSetParams.hDevice,ecx

        ; Get flat ptr to EX structure
        push    eax
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        pop     ebx
        and     ebx,0FFFFh
        add     eax,ebx
        mov     sExSetParams.paramStructPtr,eax

        ; Call ConfigSetEx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sExSetParams
        push    eax
        call    FFP16 PTR lpfnArch_Nv04ConfigSetEx

        mov     eax,sExSetParams.status
CLOSEPROC


;==============================================================================
;
; Function:     NV_OffscreenHeapAlloc
;
; Purpose:      This function allocates from the offscreen heap.
;
; Arguments:
;       ds                      Context Selector
;       pHWBoardCXOffset        HWBOARDCX ptr
;       dwFunction              what type of allocation
;                               like NVIOCONTROL_HEAP_ALLOC_SIZE or
;       dwOwnerID               ID you want for the owner
;       dwAllocType             heapParams.type value
;                               Like:  NVIOCONTROL_TYPE_CURSOR, etc.
;       dwSizeInBytes           if type is NVIOCONTROL_HEAP_ALLOC_SIZE,
;                               then this is num bytes for allocation
;                               if type is NVIOCONTROL_TYPE_PRIMARY
;                               then high word is height and low
;                               word is pitch in bytes
;
; Returns:      eax     video memory offset to allocation
;               ebx     size of allocation (may be bigger than requested)
;               ecx     number of free bytes left in the heap
;
;               If the allocation fails, then eax = -1.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_OffscreenHeapAlloc, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwFunction
PARMD   dwOwnerID
PARMD   dwAllocType
PARMD   dwSizeInBytes
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,dwFunction
        mov     heapParams.NVIOCONTROL_function,eax
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     eax,ds:[esi].HWBOARDCX.dwhDevice
        mov     heapParams.NVIOCONTROL_hObjectParent,eax
        mov     eax,dwOwnerID
        mov     heapParams.NVIOCONTROL_owner,eax
        mov     ebx,dwAllocType
        mov     heapParams.NVIOCONTROL_type,ebx
        mov     ecx,dwSizeInBytes
        mov     heapParams.NVIOCONTROL_size,ecx
        cmp     dwFunction,NVIOCONTROL_HEAP_ALLOC_SIZE
        je      @F
        movzx   eax,cx
        shr     ecx,10H
        mov     heapParams.NVIOCONTROL_pitch,eax
        mov     heapParams.NVIOCONTROL_height,ecx
@@:
        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        mov     eax,-1
        cmp     heapParams.NVIOCONTROL_status,NVIOCONTROL_STATUS_SUCCESS
        jne     Done

        ; Return the correct things
        mov     eax,heapParams.NVIOCONTROL_offset
        mov     ebx,heapParams.NVIOCONTROL_limit
        inc     ebx
        mov     ecx,heapParams.NVIOCONTROL_free
Done:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_OffscreenHeapFree
;
; Purpose:      This routine frees a block of offscreen memory
;               that was allocated via HW_AllocOffscreenBlock.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOwnerID               ID you want for the owner
;               dwOffsetToBlockStart
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_OffscreenHeapFree, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOwnerID
PARMD   dwOffsetToBlockStart
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,ecx
        mov     eax,ds:[esi].HWBOARDCX.dwhDevice
        mov     heapParams.NVIOCONTROL_hObjectParent,eax
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_FREE
        mov     eax,dwOwnerID
        mov     heapParams.NVIOCONTROL_owner,eax
        mov     eax,dwOffsetToBlockStart
        mov     heapParams.NVIOCONTROL_offset,eax
        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_OffscreenHeapPurge
;
; Purpose:      This routine purges all primary surface allocations
;               from video memory.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOwnerID               Owner ID of allocations to purge
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_OffscreenHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOwnerID
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     cx,ss
        push    cx
        lea     cx,heapParams
        push    cx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,ecx
        mov     eax,ds:[esi].HWBOARDCX.dwhDevice
        mov     heapParams.NVIOCONTROL_hObjectParent,eax
        mov     eax,dwOwnerID
        mov     heapParams.NVIOCONTROL_owner,eax
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_PURGE
        call    FFP16 PTR lpfnNvIoControl

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetAllAttachedDevices
;
; Purpose:      This routine returns a mask that describes all attached
;               devices.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax             bits 7:0   indicate if CRTC #X is attached
;                               bits 15:8  indicate if TV   #X is attached
;                               bits 23:16 indicate if DFP  #X is attached
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetAllAttachedDevices, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALD  dwAllDevices
OPENPROC
        PUSHR   esi

        ; First get all the device ports
        mov     esi,pHWBoardCXOffset
        pushd   NV_CFG_GET_ALL_DEVICES
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigGet
        shl     edx,10H
        mov     dx,ax
        mov     dwAllDevices,edx

        ; OK, it is. Find out if the device is connected
        mov     ax,ss
        shl     eax,10H
        lea     ax,dwAllDevices
        mov     ebx,4
        mov     ecx,NV_CFGEX_CHECK_CONNECTED_DEVICES
        call    NV_ConfigExCall

        mov     eax,dwAllDevices
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsDeviceAttached
;
; Purpose:      This routine determines if the specified device is
;               attached.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwDevData               low byte:       0 - CRT
;                                                       1 - TV
;                                                       2 - DFP
;                                       next byte:      0-7 for device number
;
; Returns:
;               eax                     TRUE, the device is attached
;                                       FALSE is is not
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsDeviceAttached, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDevData
LOCALD  dwDeviceToCheck
OPENPROC
        PUSHR   esi

        ; First get all the device ports
        mov     esi,pHWBoardCXOffset
        pushd   NV_CFG_GET_ALL_DEVICES
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigGet
        shl     edx,10H
        mov     dx,ax
        mov     dwAllDevices,edx

        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        test    eax,edx
        jz      DeviceNotPresent

        ; OK, it is. Find out if the device is connected
        mov     dwDeviceToCheck,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,dwDeviceToCheck
        mov     ebx,4
        mov     ecx,NV_CFGEX_CHECK_CONNECTED_DEVICES
        call    NV_ConfigExCall

        ; a 0 is success!
        or      eax,eax
        je      @F

DeviceNotPresent:
        mov     dwDeviceToCheck,0

@@:
        ; The bit for the device we were checking is turned off
        ; if the device is not connected. Otherwise it is left on.
        mov     eax,dwDeviceToCheck

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_CanDevicesBeMapped
;
; Purpose:      This routine checks to see whether all the devices
;               specified can be used simultaneously. It doesn't
;               matter what the head assignment actually is, just
;               indicate whether it is possible.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               lpDevData               dword array ptr
;                                       Each dword looks like
;                                       low byte:       0 - CRT
;                                                       1 - TV
;                                                       2 - DFP
;                                       next byte:      0-7 for device number
;                                       next two bytes ignored
;               array length
;
; Returns:
;               eax                     TRUE, then they can
;                                       In this case ebx is the mapping
;                                       FALSE, then they can't
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CanDevicesBeMapped, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   lpDevData
PARMD   dwArrayLen
LOCALV  sConfig,NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS
OPENPROC
        PUSHR   esi,edi

        ; Form a bitmask of the desired device connections
        sub     eax,eax
        sub     edx,edx
        sub     ebx,ebx
        les     bx,lpDevData
@@:
        mov     ecx,es:[ebx][edx * 4]
        shl     cl,3
        add     cl,ch
        mov     esi,1
        shl     esi,cl
        or      eax,esi
        inc     edx
        cmp     edx,dwArrayLen
        jc      @B

        ; OK, it is. Find out if the device is connected
        mov     sConfig.DevicesConfig,eax
        sub     edx,edx
        mov     sConfig.DevicesAllocationMap,edx
        mov     sConfig.OldDevicesConfig,edx
        mov     sConfig.OldDevicesAllocationMap,edx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sConfig
        mov     ebx,SIZE NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS
        mov     ecx,NV_CFGEX_GET_DEVICES_CONFIGURATION
        mov     esi,pHWBoardCXOffset
        call    NV_ConfigExCall
        mov     ebx,sConfig.DevicesAllocationMap

        ; a 0 is success!
        mov     ecx,eax
        sub     eax,eax
        or      ecx,ecx
        jne     DoneIt
        mov     eax,1
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapDevices
;
; Purpose:      This routine shuffles around the heads for the
;               CRTCs to get a mapping of heads to devices that
;               uses all the devices in the list passed in. It
;               is the callers responsibility to check and make
;               sure that such a mapping is possible by calling
;               HW_CanDevicesBeMapped before calling this routine.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               lpDevData               dword array ptr
;                                       Each dword looks like
;                                       low byte:       0 - CRT
;                                                       1 - TV
;                                                       2 - DFP
;                                       next byte:      0-7 for device number
;                                       next two bytes ignored
;               lpHWCrtcCX              array of HWCRTCCXs
;               array length
;
; Returns:
;               eax                     A dword specifying which devices
;                                       have changed. If bit 0 is a 1,
;                                       then first device in the lpDevData
;                                       array was remapped. If bit 1, is a
;                                       1, then the 2nd device in lpDevData
;                                       array was remapped, etc...
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_MapDevices, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   lpDevData
PARMD   lpHWCrtcCX
PARMD   dwArrayLen
LOCALD  dwPass
LOCALD  dwArrayCount
LOCALD  lpHWCrtcCX_Inc
LOCALD  lpDevData_Inc
LOCALD  dwPitchInBytes
LOCALD  dwDevicesConfig
LOCALD  dwDevicesAllocationMap
LOCALD  dwDeviceBit
LOCALD  dwDevicesChanged
OPENPROC
        PUSHR   esi,edi
        mov     dwDevicesChanged,0

        push    pHWBoardCXOffset
        push    lpDevData
        push    dwArrayLen
        call    HW_CanDevicesBeMapped
        or      eax,eax
        je      DoneIt
        mov     dwDevicesAllocationMap,ebx

        ; Form a bitmask of the desired device connections
        sub     eax,eax
        sub     edx,edx
        sub     ebx,ebx
        les     bx,lpDevData
@@:
        mov     ecx,es:[ebx][edx * 4]
        shl     cl,3
        add     cl,ch
        mov     esi,1
        shl     esi,cl
        or      eax,esi
        inc     edx
        cmp     edx,dwArrayLen
        jc      @B
        mov     dwDevicesConfig,eax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; OK, everything is fine. We have the mapping. Now
        ; we just need to change VidLutCursorDac objects
        ; in each HWCRTCCX to match the mapping.
        ;
        ; In an attempt to be spiffy, we make two passes through
        ; the array of all CRTCCXs. The first will free every
        ; VidLutCursorDac object corresponding to a device whose
        ; head is changing. Any CRTCCXs that by chance are on the
        ; same head this time as last time will not be freed and
        ; realloced. This eliminates flashing when there is no
        ; need for it to flash.

        ; Let the RM know we are beginning a CHANGE
        push    pHWBoardCXOffset
        push    dwDevicesConfig
        call    HW_BeginDisplayChange

        mov     dwPass,0

LoopOnAction:
        mov     eax,dwArrayLen
        mov     dwArrayCount,eax
        mov     eax,lpHWCrtcCX
        mov     lpHWCrtcCX_Inc,eax
        mov     eax,lpDevData
        mov     lpDevData_Inc,eax
        mov     dwDeviceBit,1

LoopOnCX:
        les     bx,lpDevData_Inc
        mov     ecx,es:[bx]
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl

        ; Count the number of 1 bits less than the bit set in eax.
        ; This will be the nibble number in dwDevicesAllocationMap
        ; that holds the head number to use for this HWCRTCCX
        mov     edx,1
        sub     ebx,ebx

LoopOnNibble:
        test    edx,eax
        jnz     GotNibbleNumber
        test    edx,dwDevicesConfig
        jz      @F
        inc     ebx
@@:     shl     edx,1
        jmp     LoopOnNibble

GotNibbleNumber:
        ; ebx holds the nibble number
        mov     ecx,ebx
        shl     ecx,2
        mov     edi,dwDevicesAllocationMap
        shr     edi,cl
        and     edi,0FH
        les     bx,lpHWCrtcCX_Inc
        push    dword ptr es:[bx]
        call    HW_GetPhysicalCrtcIndex
        cmp     edi,eax
        je      SameHead

        ; Which Pass is this?
        cmp     dwPass,0
        jne     ReAlloc

FreeIt:
        ; OK, if this is the first pass, then we want to free
        ; all head related info in the HWCRTCCX if it is changing.
        les     bx,lpHWCrtcCX_Inc
        push    dword ptr es:[bx]
        call    NV_FreeHeadRelatedInfo
        jmp     NextCX

ReAlloc:
        ; If it is the second pass, then realloc all head related
        ; info to get the new stuff.
        les     bx,lpHWCrtcCX_Inc
        push    dword ptr es:[bx]
        push    edi
        call    NV_AllocHeadRelatedInfo

        ; If we are reallocing, then the device must have changed head.
        mov     eax,dwDeviceBit
        or      dwDevicesChanged,eax
        jmp     NextCX

NextCX:
SameHead:
        shl     dwDeviceBit,1
        add     lpHWCrtcCX_Inc,4
        add     lpDevData_Inc,4
        dec     dwArrayCount
        jne     LoopOnCX

        inc     dwPass
        cmp     dwPass,2
        jc      LoopOnAction
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Let the RM know we are beginning a CHANGE
        push    pHWBoardCXOffset
        push    dwDevicesConfig
        call    HW_EndDisplayChange

DoneIt:
        mov     eax,dwDevicesChanged
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BeginDisplayChange
;
; Purpose:      This routine issues the DISPLAY_CHANGE_START
;               message to the RM. It is an API because the
;               generic code can call this whenever they
;               are about to detach or attach devices.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwDeviceMask            correclty formatted
;                                       mask that syas which devices
;                                       will be enabled after the
;                                       change is completed.
;
; Returns:
;               Nothing
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BeginDisplayChange, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDeviceMask
LOCALV  Params,NV_CFGEX_DISPLAY_CHANGE_START_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

	; OK, this is a hack for now. We have multiple nested calls to
	; BeginDisplayChange all over the driver. We are working to
	; change this, but for now I keep a "lock count". The first
	; Begin call gets changed up to the RM. No other begin call
	; goes up until I receive the matching end call.
	inc	ds:[esi].HWBOARDCX.dwDisplayChangeCount
	cmp	ds:[esi].HWBOARDCX.dwDisplayChangeCount,1
	jne	SkipIt

        mov     eax,dwDeviceMask
        mov     Params.NewDevices,eax
        sub     eax,eax
        mov     Params.Properties,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_DISPLAY_CHANGE_START_PARAMS
        mov     ecx,NV_CFGEX_DISPLAY_CHANGE_START
        call    NV_ConfigExSetCall

SkipIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndDisplayChange
;
; Purpose:      This routine issues the DISPLAY_CHANGE_END
;               message to the RM. It is an API because the
;               generic code can call this whenever they
;               are done detaching or attaching devices.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               Nothing
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_EndDisplayChange, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDeviceMask
LOCALV  Params,NV_CFGEX_DISPLAY_CHANGE_END_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

	; OK, this is a hack for now. We have multiple nested calls to
	; BeginDisplayChange all over the driver. We are working to
	; change this, but for now I keep a "lock count". The first
	; Begin call gets changed up to the RM. No other begin call
	; goes up until I receive the matching end call.
	cmp	ds:[esi].HWBOARDCX.dwDisplayChangeCount,1
	jne	SkipIt

        mov     eax,dwDeviceMask
        mov     Params.NewDevices,eax
        sub     eax,eax
        mov     Params.Properties,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_DISPLAY_CHANGE_END_PARAMS
        mov     ecx,NV_CFGEX_DISPLAY_CHANGE_END
        call    NV_ConfigExSetCall

SkipIt:
	dec	ds:[esi].HWBOARDCX.dwDisplayChangeCount
        POPR    esi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCLRBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwclrblt.asm
;
; Purpose:      This file transfers color bitmaps or DIBs from system
;               memory to video memory. The src color Bitmap can be
;               4, 8, 15, 16, 24, 32 bpp, and, the dst video memory
;               bitmap can be 8, 15, 16, or 32 bpp. There may be
;               a rop and a pattern as well.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwgdi.inc
include hwmacs.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. This routine gets called to do setup,
;               and then the HW_BlockSrcColorDstVram gets called before
;               each chunk of lines is transferred, and finally the
;               function HW_EndColorSrcDstVram is called when the main
;               routine is done. You need to do the following:
;
;               2) Set the Rop (which is the byte at dwRop3+2)
;
;               3) Set the starting destination coordinates to be:
;                  dwDstTop, dwDstLeft
;
;               4) Set the extents of the transfer which are:
;                  dwExtX, dwExtY
;
;                  Note that the number of pixels sent for each scan
;                  will not necessarily be dwExtX, but will be instead
;                  dwExtXAligned. dwExtXAligned is equal to dwExtX plus
;                  from 0 to 3 extra pixels required to make the byte
;                  length of a transferred scan a multiple of a dword.
;                  dwExtX is simply the dst rectangle width in pixels.
;                  If there are any extra pixels beyond dwExtX, they
;                  should be dropped by the hardware. That may mean
;                  you need to tell the hardware the blt width is
;                  really dwExtXAligned and set a hardware clip rect.
;
;               5) Program the base and pitch of the dst bitmap which are:
;                  dwDstBitsOffset, dwDstPitch
;
;               6) Anything else you need to do to prepare the
;                  hardware for a transfer of the src bitmap.
;
;               7) You must return three important values to the generic
;                  code. One is a pseudo wrap width.  The second is the
;                  maximum number of bytes you can handle in a single
;                  transfer (without waiting or writing new header info,
;                  or whatever the hardware requires.) The third is
;                  your hardware ptr (either MMIO or DMA buffer.)
;
;                  Here is how it works:
;
;                  When you return from this routine, you should have
;                  es set to your hardware selector.
;
;                  The generic code will call HW_BlockSrcColorDstVram
;                  and have it wait for enough fifo slots or DMA buffer
;                  space. HW_BlockSrcColorDstVram will return a ptr to
;                  the generic code telling it where to begin writing
;                  pixels. The generic code starts xlatting and copying
;                  pixels incrementing this ptr as it goes. When the
;                  generic code reaches the end of a scanline, it will
;                  add in the pseudo wrap width you returned to the current
;                  value of the ptr and begin transferring pixels on
;                  the next scanline at this new address. If the
;                  generic code reaches the maximum number of pixels
;                  that can be handled in a single transfer (which was
;                  the second parameter you returned) before transferring
;                  the whole bitmap, it will call the block routine
;                  HW_BlockSrcColorDstVram again to both wait for more
;                  space and get a new dst ptr.
;
;                  So what exactly should these return values be?
;
;                  For a fifo based part like NV3/ZX, the pseudo wrap width
;                  should be -dwExtAligned * (dwDstBpp which is simply the
;                  negative of one of the locals on the predefined frame.
;                  The maximum single transfer size should be 128 bytes
;                  (or whatever the size of the fifo is in bytes.)
;
;                  For a DMA based part like NV4, the pseudo wrap width
;                  should be somewhere near 0 -- what does this mean?
;                  What we would like is for the next scanline's data to
;                  immediately follow the preceeding scanline's data.
;                  You might think that this implies the pseudo wrap
;                  width is 0. However, we will need to play with the
;                  dwExtX and dwExtXAligned to see if this is true.
;                  If dwExtX and dwExtXAligned are equal, the pseudo
;                  wrap width should be 0. If dwExtXAligned is greater
;                  (it can't be less since it is equal to dwExtX
;                  rounded up to the next number of pixels which gives
;                  a dword aligned scanline length), then the pseudo
;                  wrap width should be
;                  (dwExtXAligned - dwExtX) * dwDstBytesPerPixel
;
;                  The maximum single transfer size in bytes for DMAs is
;                  the size of the method to which the color pixels
;                  will be written. (Or the size of the DMA buffer if
;                  it is smaller, but for other driver policy reasons,
;                  the DMA buffer must be more than twice the size of
;                  the largest method so go with the method size.)
;
; Arguments:
;               ds                      Context Sel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwDstBitsOffset         offset of dst bitmap in VRAM
;               dwDstPitch              pitch of dst bitmap in VRAM
;               dwDstBpp                bpp of dst bitmap (8,15,16,or 32)
;               dwDstLeft               left edge coord of dst rectangle
;               dwDstTop                top edge coord of dst rectangle
;               dwExtX                  width of dst rectangle in pixels
;               dwExtY                  height of dst rectangle in scanlines
;               dwExtXAligned           See description above for definition
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               dwRop3                  rop 3 in Microsoft rop format
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  - The pseudo wrap width
;                       ecx  - The max single transfer size in bytes
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsOffset
PARMD   dwDstPitch
PARMD   dwDstBpp
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwExtXAligned
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwRop3
OPENPROC
        mov     edx,pHWLogdevCXOffset
        mov     esi,ds:[edx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,dwDstPitch

        ; Prepare for a src transfer
        CHECKDMASPACE ds,esi,edi,30H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov     ecx,ds:[edx].HWLOGDEVCX.dwPatternAlpha1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr dwRop3+2
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(ImageFromCpuHdr.object,1)
        mov     ebx,OBJ_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,CHNRUN(ImageFromCpu.SetColorFormat,4)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwImageFromCpuColorFormat
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     ebx,dwDstTop
        mov     ecx,dwExtY
        shl     ebx,10H
        shl     ecx,10H
        mov     edx,ecx
        mov     bx,word ptr dwDstLeft
        mov     cx,word ptr dwExtX
        mov     dx,word ptr dwExtXAligned
        mov     ds:[edi + 24H],ebx
        mov     ds:[edi + 28H],ecx
        mov     ds:[edi + 2CH],edx
        add     edi,30H

        ; I need to return a few things
        mov     ebx,dwExtXAligned
        sub     ebx,dwExtX
        mov     ecx,dwDstBpp
        inc     ecx
        shr     ecx,3
        imul    ebx,ecx         ; pseudo wrap width
        mov     ecx,1792 * 4    ; size of color transfer method
        mov     ax,ds
        mov     es,ax
        mov     eax,1
Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcColorDstVram eariler
;               in this file.
;
;               Here, wait for eax bytes of space in the DMA buffer or
;               in the fifo. You may adjust es:edi to whatever you wish.
;               Hence, if you need to wrap the DMA buffer, you may do
;               do and then reset es:edi to the start of the buffer.
;               The generic code never touches es and only adjusts edi
;               by incrementing it appropriately for every dst pixel
;               that is transferred.
;
; Arguments:
;               es      Context Seletor
;               eax     bytes to wait for
;               esi     pHWBoardCX
;               edi     push buffer ptr
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcColorDstVram time.
;               es:edi must point to the location for the generic code
;               to copy the next eax bytes of dst pixels translated from
;               src pixels.
;
; Preserve:     ds,esi,fs,ebx
;==============================================================================
DECPROC HW_BlockSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
        shrd    ecx,eax,10H
        lea     edx,[eax + 4]
        mov     cx,CHNRUN(ImageFromCpu.Color,0)
        CHECKDMASPACE es,esi,edi,edx
        mov     es:[edi],ecx
        add     edi,4
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcColorDstVram eariler
;               in this file.
;
;               You may do anything you wish to here. There is nothing
;               specifically required. Some possibiliites are:
;               1) Bump the DMA ptr if you are DMA based
;               2) Reset the hardware clip rect if that was needed.
;
; Arguments:
;               es      Context Selector
;               esi     pHWBoardCX
;               edi     es has not changed since the last call to
;                       HW_BlockSrcColorDstVram and edi has only
;                       changed by being incremented for each dst
;                       pixel transferred.
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcColorDstVram time.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_EndSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitBltSrcColorDstVram
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a color system memory bitmap and the
;               dst is in VRAM. There may be a pattern involved as well
;               but there may not be.
;
;               Unless the blt is from one pixel depth to another and
;               you have hardware that handles the pixel translation
;               itself, you may just wish to call the generic routine
;               GN_BitBltSrcColorDstVram which will handle 95% of the
;               work of this routine for you. If you use the
;               GN_BitBltSrcColorDstVram service, you must implement
;               the three functions: HW_BeginSrcColorDstVram,
;               HW_BlockSrcColorDstVram and HW_EndSrcColorDstVram.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX
;               lpDstDev                Ptr to dst device (DIBENG header)
;               dwDstLeft               left edge of the dst rectangle
;               dwDstTop                top  edge of the dst rectangle
;               dwSrcBitsSel            selector to the src bits
;               dwSrcBitsOffset         offset to start of the source bits
;               dwSrcBpp                Bits Per Pixel in the src image
;                                       This can be 4, 8, 15, 16, 24, or 32
;               dwSrcPitch              address first pixel on line n+1 minus
;                                       address of first pixel on line n.
;                                       This number might be negative if the
;                                       DIB is upside down.
;               dwSrcLeft               left edge of the src rectangle
;               dwSrcLeft               top  edge of the src rectangle
;               dwExtX                  extent of src (and dst) rectangle.
;               dwExtY                  extent of the (and dst) rectangle.
;               dwRop3                  3-operand rop
;               lpBrush                 ptr to a DIB_Brush struct
;               lpDrawMode              This is only needed for case where
;                                       the rop involves a a bursh which
;                                       is a mono pattern. In this case,
;                                       DRAWMODE.TextColor gives the color
;                                       to which to translate src 0 bits,
;                                       DRAWMODE.bkColor gives the color
;                                       to which to translate src 1 bits.
;                                       Note that these are not the same
;                                       colors used translate 0 and 1 bits
;                                       from the src bitmap.
;               dwSizeColorTableEntry   bytes per entry in the color table
;               dwColorTableEntries     number of entries in the color table
;               lpColorTable            ptr to a color table. This ptr will
;                                       be NULL if no color table is
;                                       necessary.
;               pfnCopyXlatArg          If this argument is not NULL then
;                                       it is the correct inner loop to use.
;                                       If it is NULL, then the correct
;                                       inner loop needs to be computed
;                                       from the pixel depths of the src
;                                       and dst, and the color table.
;
;       There will be a color table if:
;
;       1) The src is 4bpp. If the dst is 8bpp, then each entry will be
;          2 bytes. Only the low byte is used and is the remapped dst
;          color. If the dst is any other color depth besides 8bpp, then
;          each entry is 4 bytes -- a 32bpp logical color. These entries
;          will need to be mapped to the correct dst color depth.
;
;       2) the src is 8bpp and the dst is not 8bpp. Each entry is is
;          4 bytes -- a 32bpp logical color. These entries will need
;          to be mapped to the correct dst color depth.
;
;       There may be a color table if the src is 8bpp and the dst is
;       8bpp, but there also may not. If there is a color table then
;       each entry is 2 bytes in length. Only the low byte is used and
;       is the remapped dst color.
;
;       In all other cases, there is no color table. In some cases you
;       don't need one. i.e. if you are going from 15bpp->15bpp no
;       remapping is necessary -- just copy the source to the dst. On
;       the other hand if you are going from 24bpp->15bpp, there is no
;       color table either, but you need to convert each 24bit pixel to
;       a 15bit pixel. You MUST do these conversions in a manner identical
;       to the way the DIBENG does the conversions. If you aren't familiar
;       with the various algorithms the DIBENG uses for converting colors,
;       ask someone who is. They are not necessarily what you think. i.e.
;       15->24 does not just expand each 5bit color to an 8bit color by
;       tacking three 0 bits on the low end. There is a pseudo rounding
;       algorithm that is used.
;
; Returns:      eax     0       Can't handle the call -- please punt
;                       non-0   return code
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwSizeColorTableEntry
PARMD   dwColorTableEntries
PARMD   lpColorTable
PARMD   pfnCopyXlatArg
LOCALD  pHWBoardCXOffset
LOCALD  dwColorIndexFormat
LOCALD  dwNotAlignMask
LOCALD  dwAlignedSrcLeft
LOCALD  dwAlignedDstLeft
LOCALD  dwAlignMask
LOCALD  dwAlignedExtXPixels
LOCALD  dwSrcPixelsToSrcBytesShiftCount
LOCALD  dwAlignedExtXInDwords
LOCALD  dwLUTEntriesShiftCount
LOCALD  dwSrcWrapWidth
LOCALD  dwBlockBytes
LOCALD  dwBlockHeader
LOCALD  dwWholeScansPerBlock
OPENPROC

        ; Filter out NV5 devices before the first beginaccess call
        ; because of hardware bug
        cmp     dwDstBpp,32
        jne     @F
        mov     eax,pHWLogdevCXOffset
        mov     eax,ds:[eax].HWLOGDEVCX.pHWBoardCX
        cmp     ds:[eax].HWBOARDCX.dwGetOffsetAtLastBeginAccess,-1
        jne     @F
        cmp     ds:[eax].HWBOARDCX.dwDeviceVersion, NV_DEVICE_VERSION_5
        je      Nope

@@:
        ; Filter out the 4->N and 8->N conversions to use special
        ; pixel translation hardware. Since we have to transfer
        ; the color table, however, only do so for 8bit if there
        ; are at least as many pixels to be translated as there
        ; are color table entries to be transferred.
        cmp     dwDstBpp,8
        jbe     Nope
        cmp     dwSrcBpp,4
        je      Yup
        cmp     dwSrcBpp,8
        jne     Nope
        mov     eax,dwExtX
        imul    eax,dwExtY
        cmp     eax,dwColorTableEntries
        ja      Yup
Nope:   STOPPROC
        jmp     GN_BitBltSrcColorDstVram

Yup:
        PUSHR   ds,esi,edi

        ; Compute a few things which depend upon some arguments
        mov     dwLUTEntriesShiftCount,0
        cmp     dwDstBpp,32
        je      @F
        mov     dwLUTEntriesShiftCount,1
@@:
        mov     eax,03H
        sub     ecx,ecx
        mov     dwColorIndexFormat,NV060_INDEX_FORMAT_LE_I8
        cmp     dwSrcBpp,8
        je      @F
        mov     eax,07H
        mov     ecx,1
        mov     dwColorIndexFormat,NV060_INDEX_FORMAT_SVGA65_I4
@@:     mov     dwNotAlignMask,eax
        not     eax
        mov     dwSrcPixelsToSrcBytesShiftCount,ecx
        mov     dwAlignMask,eax

        ; Align the src ptr on a dword boundary. Back up the dst
        ; as needed to match the alignment and extend the ExtX by
        ; the amount we backed up. Then pad the ExtX onthe right
        ; to make it a multiple of a dword.
        mov     eax,dwSrcLeft
        mov     ebx,dwDstLeft
        mov     ecx,eax
        mov     edx,dwExtX
        and     eax,dwNotAlignMask
        sub     ecx,eax
        sub     ebx,eax
        add     edx,eax
        mov     dwAlignedSrcLeft,ecx
        mov     dwAlignedDstLeft,ebx
        add     edx,dwNotAlignMask
        and     edx,dwAlignMask
        mov     dwAlignedExtXPixels,edx

        ; We will not do the transfer if we are forced to break up a
        ; src scan into more than one block (greater than 1792 dwords)
        ; as determined by the hardware method size.
        mov     ecx,dwSrcPixelsToSrcBytesShiftCount
        shr     edx,cl
        cmp     edx,1792 * 4
        ja      GN_BitBltSrcColorDstVram
        shr     edx,2
        mov     dwAlignedExtXInDwords,edx

        ; Load the DMA ptr
        mov     esi,pHWLogdevCXOffset
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha0
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     pHWBoardCXOffset,esi

        ; Wait for other contexts
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,ds:[esi].HWBOARDCX.dwIndexedLUTOffset
        CHECKDSTBASE ds,esi,edi,eax,<400H>

        mov     edx,dwColorTableEntries
        lea     edx,[edx * 4 + 34H]
        CHECKDMASPACE ds,esi,edi,edx
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     ecx,0CCH
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(ImageFromCpuHdr.object,1)
        mov     ecx,OBJ_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx
        mov     ecx,pHWLogdevCXOffset
        mov     eax,CHNRUN(ImageFromCpu.SetColorFormat,4)
        mov     ecx,ds:[ecx].HWLOGDEVCX.dwImageFromCpuColorFormat
        mov     ds:[edi + 1CH],eax
        sub     eax,eax
        mov     ds:[edi + 20H],ecx
        mov     ds:[edi + 24H],eax
        mov     eax,dwColorTableEntries
        mov     ecx,dwLUTEntriesShiftCount
        shl     eax,cl
        or      eax,10000H
        lea     ecx,[eax + 3]
        and     ecx,NOT 3
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ecx
        sub     edx,34H
        shl     edx,10H
        mov     dx,CHNRUN(ImageFromCpu.Color,0)
        mov     ds:[edi + 30H],edx
        add     edi,34H

        mov     ecx,dwColorTableEntries
        mov     eax,dwSizeColorTableEntry
        sub     esi,esi
        les     si,lpColorTable
        push    OFFSET RetLUT
        cmp     dwDstBpp,16
        ja      CopyLUT32
        je      CopyLUT16
        jmp     CopyLUT15
RetLUT:
        mov     esi,pHWBoardCXOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,<dwDstPitch>

        ; Prepare to transfer the pixels
        CHECKDMASPACE ds,esi,edi,34H
        mov     ecx,dwDstTop
        mov     edx,dwExtY
        shl     ecx,10H
        shl     edx,10H
        mov     cx,word ptr dwDstLeft
        mov     dx,word ptr dwExtX
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,byte ptr [dwRop3 + 2]
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(IndexedImageFromCpuHdr.object,1)
        mov     ecx,OBJ_INDEXED_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx

        ; We do not need to set the SetColorFormat method on the fly
        ; for this object BECAUSE for the hardware to work correctly,
        ; the 32bpp color format, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8,
        ; MUST be set. The operation actually gets the color format
        ; from the CONTEXT_SURFACES_2D object embedded in it, so it
        ; seems like the SetColorFormat field should be irrelevant,
        ; but if it is not set to NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        ; the hardware draws weird color pixels. The 32Bpp format
        ; is set once when the object is created.

        mov     eax,CHNRUN(IndexedImageFromCpu.IndexFormat,5)
        mov     edx,dwColorIndexFormat
        mov     ecx,ds:[esi].HWBOARDCX.dwIndexedLUTOffset
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],edx
        mov     ds:[edi + 24H],ecx
        mov     ecx,dwExtY
        mov     eax,dwDstTop
        shl     ecx,10H
        shl     eax,10H
        mov     ax,word ptr dwAlignedDstLeft
        mov     cx,word ptr dwAlignedExtXPixels
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ecx
        mov     ds:[edi + 30H],ecx
        add     edi,34H

        ; Load up the pointer and trasnfer the src image
        mov     eax,dwSrcTop
        mov     ebx,dwSrcPitch
        mov     esi,dwAlignedSrcLeft
        mov     ecx,dwSrcPixelsToSrcBytesShiftCount
        imul    eax,ebx
        shr     esi,cl
        mov     edx,dwAlignedExtXInDwords
        shl     edx,2
        sub     ebx,edx
        add     eax,dwSrcBitsOffset
        mov     dwSrcWrapWidth,ebx
        push    ds
        pop     es
        mov     ds,word ptr dwSrcBitsSel
        add     esi,eax

        ; Figure out how many whole scans we can do with one method header
        mov     eax,1792
        sub     edx,edx
        div     dwAlignedExtXInDwords
        mov     dwWholeScansPerBlock,eax
        imul    eax,dwAlignedExtXInDwords
        mov     ecx,eax
        lea     eax,[eax * 4 + 4]
        mov     dwBlockBytes,eax
        shl     ecx,12H
        mov     cx,CHNRUN(IndexedImageFromCpu.Indices,0)
        mov     dwBlockHeader,ecx

        ; Let's transfer as many complete src lines as we can in one chunk
LoopY:  mov     edx,dwExtY
        mov     eax,dwBlockBytes
        sub     edx,dwWholeScansPerBlock
        mov     ecx,dwBlockHeader
        mov     dwExtY,edx
        mov     edx,dwWholeScansPerBlock
        jge     @F

        ; There is only a partial block left. Adjust the parameters
        mov     edx,dwExtY
        mov     dwExtY,0
        add     edx,dwWholeScansPerBlock
        mov     eax,dwAlignedExtXInDwords
        shl     eax,2
        imul    eax,edx
        mov     ecx,eax
        add     eax,4
        shl     ecx,10H
        mov     cx,CHNRUN(IndexedImageFromCpu.Indices,0)
@@:
        ; Wait for space and transfer a whole block
        mov     ebx,pHWBoardCXOffset
        CHECKDMASPACE es,ebx,edi,eax
        mov     es:[edi],ecx
        add     edi,4
@@:
        mov     ecx,dwAlignedExtXInDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        dec     edx
        jne     @B

        ; Let some data go
        SETPUTPTR es,ebx,edi
        cmp     ecx,dwExtY
        jl      LoopY

        ; Reset the ContextClip rectangle to the default
        CHECKDMASPACE es,ebx,edi,0CH
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        sub     edx,edx
        mov     ecx,07FFF7FFFH
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     es:[edi + 08H],ecx
        add     edi,0CH
        SETPUTPTR es,ebx,edi
Done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CopyLUT15
;
; Purpose:      This routine copies the LUT from a src color table with
;               dword entries into a dst area also with dword entries
;               also except the color are really 5-5-5 shifted left by
;               3 bits (the bottom 3 bits should always be 0.)
;
; Arguments:    es:esi          ptr to src LUT
;               ecx             number of LUT entries
;               ds:edi          dst LUT
;
; Returns:      ds:edi          must point immediately after last LUT
;                               entry copied
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  CopyLUT15
CopyLUT15       PROC    NEAR

        mov     eax,es:[esi]
        add     esi,4

        shld    edx,eax,10H
        sub     dl,04
        cmc
        sbb     dh,dh
        and     dh,dl
        and     dh,NOT 7

        mov     dl,ah
        sub     dl,4
        cmc
        sbb     ah,ah
        and     dl,ah
        and     dl,NOT 7

        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        and     al,NOT 7

        shl     eax,18H
        shld    edx,eax,8

        mov     ds:[edi],edx
        add     edi,4
        dec     ecx
        jne     CopyLUT15
        ret

CopyLUT15       ENDP


;==============================================================================
;
; Function:     CopyLUT16
;
; Purpose:      This routine copies the LUT from a src color table with
;               dword entries into a dst area also with dword entries
;               also except the color are really 5-6-5 shifted left by
;               3 bits for the red&blue and 2 bits for the green. (The
;               bottom bits should always be 0.)
;
; Arguments:    es:esi          ptr to src LUT
;               ecx             number of LUT entries
;               ds:edi          dst LUT
;
; Returns:      ds:edi          must point immediately after last LUT
;                               entry copied
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  CopyLUT16
CopyLUT16       PROC    NEAR

        mov     eax,es:[esi]
        add     esi,4

        shld    edx,eax,10H
        sub     dl,04
        cmc
        sbb     dh,dh
        and     dh,dl
        and     dh,NOT 7

        mov     dl,ah
        sub     dl,2
        cmc
        sbb     ah,ah
        and     dl,ah
        and     dl,NOT 3

        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        and     al,NOT 7

        shl     eax,18H
        shld    edx,eax,8

        mov     ds:[edi],edx
        add     edi,4
        dec     ecx
        jne     CopyLUT16
        ret

CopyLUT16       ENDP


;==============================================================================
;
; Function:     CopyLUT32
;
; Purpose:      This routine copies the LUT from a src color table with
;               dword entries into a dst area also with dword entries.
;
; Arguments:    es:esi          ptr to src LUT
;               ecx             number of LUT entries
;               ds:edi          dst LUT
;
; Returns:      ds:edi          must point immediately after last LUT
;                               entry copied
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  CopyLUT32
CopyLUT32       PROC    NEAR

        mov     eax,es:[esi + 0]
        add     esi,4
        mov     ds:[edi + 0],eax
        add     edi,4
        dec     ecx
        jne     CopyLUT32
        ret

CopyLUT32       ENDP


CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCNTRL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         hwcntrl.asm
;
; Purpose:      This file implements hardware-specific escape support.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvcm.inc
include escape.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

CONTROL_FRAME_AND_LOCALS        MACRO
PARMD   pHWLogdevCXOffset
PARMD   lpDstDev
PARMW   wFunction
PARMD   lpIn
PARMD   lpOut
ENDM

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_ControlQuery
;
; Purpose:      This function implements a hardware specific escape call
;               when it is already known that the call is a QUERYESCSUPPORT.
;               The generic code did not recognize the escape function in
;               the first word of the lpIn structure and so passed it on.
;
; Arguments:    Control Display Driver Stack Frame
;               ds      Context Selector
;
; Returns:      ecx     0   queried-escape was not recognized
;                       1   queried-escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC HW_ControlQuery, PASCAL, FRAME, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx
        les     bx,lpIn
        mov     ecx,1
        movzx   edx,word ptr es:[ebx]

        cmp     edx,NV_ESC_INTEL_DIAG
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        ; Unrecognized query escape
        sub     ecx,ecx
Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_ControlAction
;
; Purpose:      This function implements a hardware specific escape call.
;               The generic code did not recognize the escape number and
;               so passed it on.
;
; Arguments:    Control Display Driver Stack Frame
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC HW_ControlAction, PASCAL, FRAME, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        movzx   eax,wFunction

        push    OFFSET ReturnAddr
        cmp     eax,NV_ESC_DMAPUSHMODESWITCHCOUNT
        je      NV_GetFlatModeSwitchPtrCount
        cmp     eax,NV_ESC_GETACTIVECHANNELPTR
        je      NV_GetFlatActiveChannelPtr
IFDEF   NV_ESCAPE_ID
        cmp     eax,NV_ESCAPE_ID
        je      NV_GetEscapeID
ENDIF
        cmp     eax,NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER
        je      NV_IsNvidiaBasedBoardAndDiver
        cmp     eax,NV_ESC_GET_HARDWARE_POINTERS
        je      NV_GetHardwarePointers
        cmp     eax,NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA
        je      NV_GetFlatDirectXSharedData
        cmp     eax,NV_ESC_INC_MODE_SWITCH
        je      NV_IncModeSitchCounter
        cmp     eax,NV_ESC_INTEL_DIAG
        je      NV_IntelDiags
        add     sp,@WordSize
        sub     ecx,ecx
        jmp     Done

ReturnAddr:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetFlatModeSwitchPtrCount
;
; Purpose:      This function returns a flat ptr to the mode switch
;               count variable that open gl uses to track modeswitch
;               state and changes.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetFlatModeSwitchPtrCount, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        mov     ax,ds
        push    ax
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        lea     eax,[edi].HWBOARDCX.dwModeSwitchCount
        add     eax,edx

        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetFlatActiveChannelPtr
;
; Purpose:      This function returns a flat ptr to the current
;               channelID variable that is used to sync between
;               channels.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetFlatActiveChannelPtr, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        mov     ax,ds
        push    ax
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        mov     eax,[edi].HWBOARDCX.pCurrentChannelID
        add     eax,edx

        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetEscapeID
;
; Purpose:      This function returns a constant indicating that
;               this is an NVIDIA driver (as opposed to an OEM
;               driver based upon nvidia source).
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetEscapeID, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     eax,eax
        cmp     eax,lpOut
        je      @F
        sub     edi,edi
        les     di,lpOut
        mov     dword ptr es:[edi],NV_ESCAPE_ID_RETURN
        mov     eax,1
@@:
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_IsNvidiaBasedBoardAndDiver
;
; Purpose:      This function returns a constant indicating that
;               this is an NVIDIA based board and driver (it might
;               be nvidia's own board and driver or a customers
;               modified driver and board).
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_IsNvidiaBasedBoardAndDiver, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
	push	ds:[esi].HWLOGDEVCX.pHWCrtcCX
	call	HW_GetPhysicalCrtcIndex

        sub     edi,edi
        les     di,lpOut
        mov     dword ptr es:[edi],NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     ecx,ds:[ebx].HWBOARDCX.dwDeviceNum
        mov     es:[edi + 4],ecx
        mov     es:[edi + 8],eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetHardwarePointers
;
; Purpose:      This function returns a ptr to the screen and
;               the linear base of the chip registers.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetHardwarePointers, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        sub     edi,edi
        les     di,lpOut

        sub     eax,eax
        mov     es:[edi].HARDWAREPOINTERS.lp16Chip,eax
        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySel
        shl     eax,10H
        mov     es:[edi].HARDWAREPOINTERS.lp16FrameBuffer,eax
        mov     eax,ds:[esi].HWBOARDCX.pVideoMemory
        mov     es:[edi].HARDWAREPOINTERS.lp32FrameBuffer,eax
        mov     eax,ds:[esi].HWBOARDCX.pChipRegs
        mov     es:[edi].HARDWAREPOINTERS.lp32Chip,eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetFlatDirectXSharedData
;
; Purpose:      This function returns a flat ptr to the
;               DirectX shared data structure.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetFlatDirectXSharedData, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset

        push    word ptr ds:[esi].HWLOGDEVCX.lpDirectXSharedData+2
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        xor     edi,edi
        les     di,lpOut
        mov     es:[edi],edx
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_IncModeSitchCounter
;
; Purpose:      This function increments the mode switch counter.
;               It is used for testing OGL stuff.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_IncModeSitchCounter, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        inc     ds:[esi].HWBOARDCX.dwModeSwitchCount

        cmp     lpOut,0
        je      @F
        sub     edi,edi
        les     di,lpOut
        mov     eax,ds:[esi].HWBOARDCX.dwModeSwitchCount
        mov     es:[edi],eax
@@:
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_IntelDiags
;
; Purpose:      This function is a set of Intel diagnostics.
;               Intel requires this Escape and diagnostics in
;               order to purchase our boards.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_IntelDiags, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        push    pHWLogdevCXOffset
        push    lpIn
        push    lpOut
        call    NV_IntelDiagnostics
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWBOARD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwboard.asm
;
; Purpose:      This file contains all the hardware specific BOARD
;               specific routines for init. The board specific run-
;               time routines are in hwboard2.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include dxshare.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc
include escape.inc

OPENSEG  _DATA, USE16, DATA
szNvSysDll              DB      NV4_RM_16_BINARY,0
szModeSetDll            DB      NV4_MODESET_BINARY,0
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_CreateBoardContext
;
; Purpose:      This routine gets called from the generic code
;               the first time a PDEVICE is created on a given
;               board. This routine should create its BOARD
;               specific data and fill it in.
;
;               This routine will only be matched by a call to
;               HW_DestroyBoardContext when the last PDEVICE
;               initted on this board is going away.
;
; Arguments:
;               ds                      Context Selector
;
; Returns:      eax     0       failure
;                       else    This should be a ptr to what the HW
;                               wants as its HWBOARDCX ptr.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateBoardContext, PASCAL, FRAME, FAR32
PARMD   dwThisLogDeviceHandle
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        pushd   SIZE HWBOARDCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax
        mov     ds:[esi].HWBOARDCX.pHWBoardCXReal,eax

        ; Set this to 1 right now.
        mov     ds:[esi].HWBOARDCX.dwInitting,1

        ; Get our device Number from the RM
        push    dwThisLogDeviceHandle
        call    NV_GetDeviceNumber
        or      eax,eax
        je      DoneIt

        ; Allocate the root node from the RM
        call    NV_AllocRoot
        or      eax,eax
        je      DoneIt

        ; Allocate our device slot from the RM
        call    NV_AllocDevice
        or      eax,eax
        je      DoneIt

        ; Get information about video memory.
        call    NV_GetMemoryInfo
        or      eax,eax
        je      DoneIt

        ; Get information on the chip base
        call    NV_GetDeviceInfo
        or      eax,eax
        je      DoneIt

        ; Get information on the chip version
        call    NV_GetDeviceVersion
        or      eax,eax
        je      DoneIt

        ; Get information of bus type
        call    NV_GetBusType
        or      eax,eax
        je      DoneIt

        ; We need to know how many CRTCs there are on this board.
        call    NV_GetNumCRTCs
        or      eax,eax
        je      DoneIt

        ; Allocate the push buffer
        call    NV_AllocPushBuffer
        or      eax,eax
        je      DoneIt

        ; OK, Here is the linear base of the real push buffer
        mov     ds:[esi].HWBOARDCX.pRealPushBuffer,ebx

        ; Allocate a context DMA for the PUSHBUFFER
        push    esi
        pushd   OBJ_DMA_PUSH_BUFFER
        push    ds:[esi].HWBOARDCX.pRealPushBuffer
        push    ds
        pushd   (DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt

        ; Allocate a channel for use with the DMA push buffer
        mov     eax,OBJ_DMA_PUSH_BUFFER
        call    NV_AllocChannelDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWBOARDCX.pDmaChannel,eax

        ; Allocate linear address space of the same size as the
        ; HWBOARDCX + DMA_PUSH_BUFFER_SIZE so we can remap pages.
        mov     eax,(SIZE HWBOARDCX + DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_AllocLinearAddressSpace
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWBOARDCX.pAliasedHWBoardCX,eax

        ; Copy the PTEs for the HWBOARDCX ptr passed in to the
        ; aliased HWBOARDCX so the two ptrs reference the same
        ; physical memory.
        mov     eax,esi
        mov     ebx,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        mov     ecx,(SIZE HWBOARDCX) AND 0FFFFF000H
        call    NV_CopyPTEsForLinearRange
        or      eax,eax
        je      DoneIt

        ; Copy the PTEs for the Real DMA_PUSH_BUFFER memory allocated
        ; previously into the PTEs of our linear address space to the
        ; pages immediately after the ones mapping the HWBOARDCX. This
        ; way the HWBOARDCX and DMA_PUSH_BUFFER are linearly contiguous.
        mov     eax,ds:[esi].HWBOARDCX.pRealPushBuffer
        mov     ebx,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        add     ebx,(SIZE HWBOARDCX) AND 0FFFFF000H
        mov     ecx,(DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_CopyPTEsForLinearRange
        or      eax,eax
        je      DoneIt

        ; Modify the mapping of the page in the middle of the
        ; HWBOARDCX structure that is supposed to point to the
        ; Nv04ControlDma structure.
        mov     eax,ds:[esi].HWBOARDCX.pDmaChannel
        mov     ebx,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        lea     ebx,[ebx].HWBOARDCX.bHWPageStart
        mov     ecx,1000H
        call    NV_CopyPTEsForLinearRange
        or      eax,eax
        je      DoneIt

        ; Now we have to switch over to the mapped HWBOARDCX ptr
        ; since it also has pages that point to the hardware and
        ; to the push buffer mapped after the end of the HWBOARDCX
        ; itself.
        mov     esi,ds:[esi].HWBOARDCX.pAliasedHWBoardCX

        ; Create all the DMA contexts we will need.
        call    NV_CreateDmaContexts
        or      eax,eax
        je      DoneIt

        ; Watch out for chipsets that can't get the cache coherency
        ; implemented correctly.
IF (DOIOTOFLUSHCACHE NE 0)
        pushd   NV_CFG_IO_NEEDED
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        mov     ds:[esi].HWBOARDCX.dwFlushCacheWithIO,eax
ELSE
        mov     ds:[esi].HWBOARDCX.dwFlushCacheWithIO,0
ENDIF

        ; Init the push buffer variables
        lea     edi,ds:[esi].HWBOARDCX.bScrapSpace
        mov     ds:[esi].HWBOARDCX.pPushBufferContextStartOffset,edi
        lea     edi,ds:[esi].HWBOARDCX.bDmaPushBuffer
        mov     ds:[esi].HWBOARDCX.pPushBufferStartOffset,edi
        mov     ds:[esi].HWBOARDCX.dwPushBufferLength,DMA_PUSH_BUFFER_SIZE - WRITE_COMBINE_PAD_SIZE - 10H
        mov     ds:[esi].HWBOARDCX.dwBytesFree,DMA_PUSH_BUFFER_SIZE - WRITE_COMBINE_PAD_SIZE - 08H

        ; The minimum and maximum pitces of a context surface 2D are
        ; dependent upon whether the board is nv04, 05, 10, etc.
        mov     eax,20H
        mov     ebx,8160
        cmp     ds:[esi].HWBOARDCX.dwDeviceVersion,NV_DEVICE_VERSION_10
        jl      @F
        mov     eax,40H
        mov     ebx,10000H
@@:     mov     ds:[esi].HWBOARDCX.dwMinContextSurface2dPitch,eax
        mov     ds:[esi].HWBOARDCX.dwMaxContextSurface2dPitch,ebx
        imul    eax,10001H
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax

        ; Make sure that this gets reinitted properly in BeginAccess
        ; by setting it to an impossible push buffer offset now.
        mov     eax,-1
        mov     ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess,eax

        ; The DMA pusher should be up and running. I'm going to put
        ; some NOPS in the push buffer to get it started. The first
        ; 20H bytes or so of the push buffer are not used because
        ; may need them as a place to access that we know is far
        ; enough away from the last CPU access to WRITE COMBINE
        ; memory so that a flush of the CPU WRITE COMBINE buffers
        ; is forced.
        push    ds
        pop     es
        mov     edi,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        sub     eax,eax
        mov     ecx,(WRITE_COMBINE_PAD_SIZE + 3) / 4
        rep     stos dword ptr es:[edi]
        SETPUTPTR  ds,esi,edi

        ; Now let's just wait until the push buffer fetches those
        ; NOP commands.
        mov     eax,edi
        sub     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
@@:     cmp     ds:[esi].HWBOARDCX.dwDmaGetPtr,eax
        jne     @B

        ; Create all the obects we will need.
        call    NV_CreateObjects
        or      eax,eax
        je      DoneIt

        ; Let's figure out our channel mask
        call    NV_GetGdiChannelMask

        ; Now we have to allocate some memory that will NEVER
        ; go away. This will be for the LUT and for however
        ; many cursors are on the board.
        call    NV_AllocRequiredMemory
        or      eax,eax
        je      DoneIt

        ; Return the HWBOARDCX ptr that we really want to use
        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the HWBOARDCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; HW_DestroyBoardContext can clean up partial inits
        push    esi
        call    HW_DestroyBoardContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyBoardContext
;
; Purpose:      This routine gets called to destroy a HWBOARDCX.
;
; Arguments:
;               ds                      context selector
;               pHWBoardCXOffset        HWBOARDCX to destroy
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyBoardContext, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWBoardCXOffset
        or      esi,esi
        je      DoneIt

        ; Destroy the objects
        call    NV_DestroyObjects

        ; Destroy the context DMAs
        call    NV_DestroyDmaContexts

        ; pAliasedHWBoardCX was allocated via the function
        ; NV_AllocLinearAddressSpace an must be freed by calling
        ; NV_FreeLinearAddressSpace.
        cmp     ds:[esi].HWBOARDCX.pAliasedHWBoardCX,0
        je      @F

        ; esi is currently using the aliased HWBoardCX.
        ; We are about to free this memory block, so we must
        ; switch esi back over to the real allocation offset
        ; which is a different linear range the first part
        ; of which maps to the ssame physical range -- the HWBOARDCX.
        mov     esi,ds:[esi].HWBOARDCX.pHWBoardCXReal

        mov     eax,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        mov     ebx,(SIZE HWBOARDCX + DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_FreeLinearAddressSpace
        mov     ds:[esi].HWBOARDCX.pAliasedHWBoardCX,0
@@:
        ; Destroy the DMA channel
        mov     bx,ss
        shl     ebx,10H
        lea     bx,FreeParam
        push    ebx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     FreeParam.NV01FREE_hObjectParent,NV_WIN_DEVICE
        mov     FreeParam.NV01FREE_hObjectOld,NV_WIN_CHANNEL
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01Free,es,ax

        ; Destroy the push buffer context DMA
        push    esi
        pushd   OBJ_DMA_PUSH_BUFFER
        call    NV_FreeContextDma

        ; If the real push buffer was allocated via SysAllocPages, we
        ; need to free the memory now. If it was allocated with the
        ; NV_AllocMemory function, then the memory will get freed when
        ; we free the RootHandle.
        cmp     esi,ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle
        je      @F
        push    ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvSysFreePages,es,ax
        mov     ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle,0
@@:

        ; Free the screen sel
        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySel
        or      eax,eax
        je      @F
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].HWBOARDCX.dwVideoMemorySel,0
@@:
        ; Now we can free the root.
        call    NV_FreeRoot

        mov     eax,ds:[esi].HWBOARDCX.dwDeviceNum
        or      eax,eax
        jz      @F
        push    eax
        CALLFAR16IND lpfnNvSysDriverDisConnect,es,ax
@@:
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDeviceNumber
;
; Purpose:      Determines the device number for the board controlled by
;               this particular driver since there may be multiple NVidia
;               cards in the same system.
;
; Arguments:    ds:esi          HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetDeviceNumber, PASCAL, FRAME, NEAR
PARMD   dwThisLogDeviceHandle
OPENPROC
        ; Call SysDriverConnect to get the device number.
        mov     edx,dwThisLogDeviceHandle
        sub     eax,eax
        cmp     edx,1
        je      @F
        and     edx, NOT 3H
@@:
        push    edx
        push    eax
        CALLFAR16IND lpfnNvSysDriverConnect,es,ax
        shl     edx,16
        mov     dx,ax
        mov     ds:[esi].HWBOARDCX.dwDeviceNum,edx
        mov     eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocRoot
;
; Purpose:      Allocates the root node for this device.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocRoot, PASCAL, FRAME, NEAR
LOCALV  AllocRootParam,ALLOC_ROOT_PARAM
OPENPROC
        ; Get and save the handle to the root
        mov     ax,ss
        lea     bx,AllocRootParam
        push    ax
        push    bx
        mov     edx,ALLOC_ROOT_CLASS_ROOT
        mov     ecx,ALLOC_ROOT_STATUS_SUCCESS
        mov     AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_hClass,edx
        mov     AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_status,ecx
        CALLFAR16IND lpfnArch_Nv01AllocRoot,es,ax
        mov     eax,AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_hObjectNew
        mov     ds:[esi].HWBOARDCX.dwRootHandle,eax

        mov     ecx,ALLOC_ROOT_STATUS_SUCCESS
        cmp     ecx,AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_status
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeRoot
;
; Purpose:      Frees the root node for this device. This will cause
;               everything allocated under this root to be freed also.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeRoot, PASCAL, FRAME, NEAR
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        mov     bx,ss
        push    bx
        lea     bx,FreeParam
        push    bx
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,eax
        mov     FreeParam.NV01FREE_hObjectParent,eax
        mov     FreeParam.NV01FREE_hObjectOld,eax
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01Free,es,ax

        cmp     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocDevice
;
; Purpose:      Allocates a device slot from the RM.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocDevice, PASCAL, FRAME, NEAR
LOCALV  AllocDevParam,ALLOC_DEV_PARAM
LOCALS  szDevName,10H
OPENPROC
        ; Call and allocate our "device"
        mov     ax,ss
        lea     bx,AllocDevParam
        push    ax
        push    bx
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hObjectParent,eax
        mov     eax,NV_WIN_DEVICE
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hObjectNew,eax
        mov     eax,ds:[esi].HWBOARDCX.dwDeviceNum
        add     eax,(NV01_DEVICE_0 - 1)
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hClass,eax

        push    ss
        call    GN_GetSelectorBase
        lea     edx,szDevName
        add     edx,eax
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_szName,edx
        mov     ecx,ALLOC_DEV_STATUS_SUCCESS
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_status,ecx
        CALLFAR16IND lpfnArch_Nv01AllocDevice,es,ax

        ; Now get the handle and save it
        mov     eax,AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hObjectNew
        mov     ds:[esi].HWBOARDCX.dwhDevice,eax

        ; Set the return code.
        mov     ecx,ALLOC_DEV_STATUS_SUCCESS
        cmp     ecx,AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_status
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetMemoryInfo
;
; Purpose:      This routine gets the amount of onboard memory and
;               information about the memory capabilities.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetMemoryInfo, PASCAL, NOFRAME, NEAR
OPENPROC
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvSysGetRamInfo,es,ax
        movzx   eax,ax
        shl     edx,20
        mov     ds:[esi].HWBOARDCX.dwRamFlags,eax
        mov     ds:[esi].HWBOARDCX.dwVideoMemorySize,edx

        pushd   NV_DEV_BUFFER_0
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvDeviceBaseGet,es,ax
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].HWBOARDCX.pVideoMemory,edx

        ; Alloc a selector to map to this linear address
        mov     eax,1
        mov     ebx,edx
        mov     ecx,ds:[esi].HWBOARDCX.dwVideoMemorySize
        call    GN_AllocSelectorAndMapIt
        mov     ds:[esi].HWBOARDCX.dwVideoMemorySel,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDeviceInfo
;
; Purpose:      This routine gets the linear base address of the device
;               and maps a selector to this linear base.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetDeviceInfo, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_DEV_BASE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvDeviceBaseGet,es,ax
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].HWBOARDCX.pChipRegs,edx
        mov     eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDeviceVersion
;
; Purpose:      This routine gets the device version from the RM.
;               Basically, are we running on NV4, NV5, or NV10.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetDeviceVersion, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_CFG_ARCHITECTURE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        push    eax

        pushd   NV_CFG_REVISION
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        pop     ebx

        ; Is it an NV20 or better?
        mov     ecx,NV_DEVICE_VERSION_20
        cmp     ebx,NV_20_ARCHITECTURE
        jge     Done

        ; Is it an NV10?
        mov     ecx,NV_DEVICE_VERSION_10
        cmp     ebx,NV_10_ARCHITECTURE
        je      Done

        ; If the architecture is < 5, then revision 0 is NV4, else NV5
        mov     ecx,NV_DEVICE_VERSION_4
        or      eax,eax
        je      Done
        mov     ecx,NV_DEVICE_VERSION_5
Done:
        mov     ds:[esi].HWBOARDCX.dwDeviceVersion,ecx

        ; We also want the revision
        pushd   NV_CFG_REVISION
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        mov     ds:[esi].HWBOARDCX.dwDeviceRevision,eax

        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetBusType
;
; Purpose:      This routine gets the bus type of the card -- PCI or AGP.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetBusType, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_CFG_BUS_TYPE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        movzx   eax,al
        mov     ds:[esi].HWBOARDCX.dwBusType,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetNumCRTCs
;
; Purpose:      This routine returns the number of CRTCs on the
;               board.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetNumCRTCs, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_CFG_NUMBER_OF_HEADS
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        mov     ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard,eax
        mov     ds:[esi].HWBOARDCX.dwCRTCsAllocatedFlags,0
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocPushBuffer
;
; Purpose:      This routine allocates the push buffer. I made it a
;               separate routine because potentially I want to be able
;               to allocate the push buffer in PCI, AGP or video memory.
;               There may be some heuristic for determining which one.
;
;               Right now, the push buffer always goes in PCI memory
;               for a retail build, but for testing, I can stick it
;               in video memory and AGP as well.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       Failure
;                       non-0   Success in which case
;                               ebx     linear base of push buffer
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocPushBuffer, PASCAL, FRAME, NEAR
LOCALV  sMem,ALLOC_MEMORY_PARAM
OPENPROC
IFDEF   DEBUG
        cmp     cs:[bLocatePushBuffer],0
        je      PciBuffer
        cmp     cs:[bLocatePushBuffer],1
        je      VidBuffer
        cmp     cs:[bLocatePushBuffer],2
        je      AgpBuffer
        jmp     PciBuffer

PUBLIC  bLocatePushBuffer
bLocatePushBuffer       DB      0

AgpBuffer:
        mov     eax,(DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        mov     ebx,ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY + ALLOC_MEMORY_FLAGS_LOCATION_AGP
        mov     ecx,OBJ_DMA_PUSH_MEMORY
        call    NV_AllocMemory
        or      eax,eax
        je      PciBuffer
        jmp     DoneBuffer

VidBuffer:
        push    esi
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_HEAP_OWNER
        pushd   NVIOCONTROL_TYPE_CURSOR
        pushd   (DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_OffscreenHeapAlloc
        cmp     eax,-1
        je      PciBuffer

        add     eax,ds:[esi].HWBOARDCX.pVideoMemory
        mov	ebx,eax
        jmp     DoneBuffer
ENDIF

PciBuffer:
        ; Allocate the push buffer in PCI memory
        mov     eax,(DMA_PUSH_BUFFER_SIZE + 0FFFH) SHR 0CH
        call    NV_AllocPages
        mov     ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle,eax

DoneBuffer:
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocChannelDma
;
; Purpose:      This function allocates a channel for an existing
;               context DMA object.
;
; Arguments:
;               ds:esi  HWBOARDCX
;               eax     Object ID
;
; Returns:      eax     linear base of a Nv04ControlDma structure
;                       0 if there was an error
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocChannelDma, PASCAL, FRAME, NEAR
LOCALV  AllocChannelDmaParam,ALLOC_CHL_DMA_PARAM
OPENPROC
        PUSHSREG ss
        lea     bx,AllocChannelDmaParam
        push    bx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hClient,ecx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectParent,NV_WIN_DEVICE
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectNew,NV_WIN_CHANNEL
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hClass,NV04_CHANNEL_DMA
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectError,NV01_NULL_OBJECT
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectBuffer,eax
        sub     edx,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_offset,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_pControl,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_pControl+4,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_status,edx
        CALLFAR16IND lpfnArch_Nv03AllocChannelDma,es,ax
        mov     eax,AllocChannelDmaParam.ALLOC_CHL_DMA_pControl
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocPages
;
; Purpose:      This routine allocates a number of pages of memory
;               typically to be used as a DMA buffer, but they can
;               be used for anything.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     number of pages to allocate
;
; Returns:      eax     PageHandle      (0 if failure)
;               ebx     LinearBase
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocPages, PASCAL, FRAME, NEAR
LOCALD  dwLinearBase
LOCALD  dwPageHandle
OPENPROC
        ; Call the RM to allocate some pages
        mov     cx,ss
        lea     bx,dwLinearBase
        push    cx
        push    bx
        lea     bx,dwPageHandle
        push    cx
        push    bx
        push    eax
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvSysAllocPages,es,ax

        ; Return the right things
        mov     eax,dwPageHandle
        mov     ebx,dwLinearBase
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocMemory
;
; Purpose:      This routine allocates different amounts and types
;               of memory. It is typically used to allocate a DMA
;               buffer, but can be used for anything. It also maps
;               a selector:0 to the base address of the allocation.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     number of bytes to allocate
;               ebx     allocation flags
;               ecx     Object ID
;
; Returns:      eax     0       Failure
;                       non-0   Success in which case
;                               ebx     LinearBase
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocMemory, PASCAL, FRAME, FAR32
LOCALV  nvAllocMemoryParam,ALLOC_MEMORY_PARAM
OPENPROC
        mov     dx,ss
        push    dx
        lea     dx,nvAllocMemoryParam
        push    dx
        mov     edx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hObjectClient,edx
        mov     edx,ds:[esi].HWBOARDCX.dwhDevice
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hObjectParent,edx
        sub     edx,edx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hObjectNew,ecx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hClass,NV1_MEMORY_SYSTEM
        mov     nvAllocMemoryParam.ALLOC_MEMORY_flags,ebx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pBase,edx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pBase+4,edx
        dec     eax
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pLimit,eax
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pLimit+4,edx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01AllocMemory,es,ax

        cmp     nvAllocMemoryParam.ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        mov     ebx,nvAllocMemoryParam.ALLOC_MEMORY_pBase
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeMemory
;
; Purpose:      This routine allocates different amounts and types
;               of memory. It is typically used to allocate a DMA
;               buffer, but can be used for anything. It also maps
;               a selector:0 to the base address of the allocation.
;
; Arguments:    ds:esi  HWBOARDCX
;               ecx     Object ID
;
; Returns:      eax     0       Failure
;                       non-0   Success in which case
;                               ebx     LinearBase
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeMemory, PASCAL, FRAME, FAR32
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        mov     bx,ss
        push    bx
        lea     bx,FreeParam
        push    bx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     edx,ds:[esi].HWBOARDCX.dwhDevice
        mov     FreeParam.NV01FREE_hObjectParent,ecx
        mov     FreeParam.NV01FREE_hObjectOld,ecx
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01Free,es,ax

        cmp     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocLinearAddressSpace
;
; Purpose:      This function can be used to allocate linear address
;               space via the minivdd. There is no physical memory to
;               back the address space.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     bytes of linear address space to allocate
;
; Returns:      eax     linear base of address space  (0 if error)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocLinearAddressSpace, PASCAL, FRAME, NEAR
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegEDX,eax
        mov     rmRegs.RegECX,MVDD_ALLOC_LINEAR_ADDRESS_SPACE
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,rmRegs.RegEAX
CLOSEPROC

;==============================================================================
;
; Function:     NV_FreeLinearAddressSpace
;
; Purpose:      This function can be used to free linear address
;               space via the minivdd.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     base of linear address space to free
;               ebx     length in bytes of linear address range to free
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeLinearAddressSpace, PASCAL, FRAME, NEAR
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegEDX,eax
        mov     rmRegs.RegECX,MVDD_FREE_LINEAR_ADDRESS_SPACE
        mov     rmRegs.RegEBX,ebx
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
CLOSEPROC

;==============================================================================
;
; Function:     NV_CopyPTEsForLinearRange
;
; Purpose:      This function can be used to copy the PTEs behind one
;               linear address range to the PTEs behind another linear
;               address range making both ranges address the same
;               physical memory.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     src linear range
;               ebx     dst linear range
;               ecx     length of linear range in bytes
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CopyPTEsForLinearRange, PASCAL, FRAME, NEAR
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegEDX,eax
        mov     rmRegs.RegEBX,ebx
        mov     rmRegs.RegEDI,ecx
        mov     rmRegs.RegECX,MVDD_COPY_PTES_FOR_LINEAR_RANGE
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetGdiChannelMask
;
; Purpose:      This function determines which bit mask position our
;               DMA pusher holds in a chip register so we can tell
;               whether ours and other DMA contexts are active.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      HWBOARDCX.dwGdiPushBufferMask set correctly
;               HWBOARDCX.dwGdiPushBufferIndex set correctly
;               HWBOARDCX.dwGdiDriverChannelID set correctly
;
; Preserve:     ds,esi,edi
;==============================================================================
NV4_PFIFO_CACHE1_PUSH1          EQU     00003204H
DECPROC NV_GetGdiChannelMask, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   edi
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        mov     ecx,-1
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferIndex,1
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferMask,ecx
@@:
        ; This is what we think the PushBufferIndex is
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferIndex,ecx

        ; Trigger off some DMA activity.
        ; The easy thing is to write NOPS in the push buffer!
        CHECKDMASPACE ds,esi,edi,04H
        sub     eax,eax
        mov     ds:[edi + 00H],eax
        add     edi,4
        SETPUTPTR ds,esi,edi

        ; Read the ID of the current active DMA channel
        sub     ebx,ebx
        mov     eax,ds:[esi].HWBOARDCX.pChipRegs
        mov     ecx,ds:[eax + NV4_PFIFO_CACHE1_PUSH1]
        and     ecx,0FH

        ; If not what we thought, go back and test again.
        cmp     ecx,ds:[esi].HWBOARDCX.dwGdiPushBufferIndex
        jne     @B

DMAChannelQueryDone:
        mov     eax,1
        shl     eax,cl
        not     eax
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferMask,eax
        mov     ds:[esi].HWBOARDCX.dwGdiDriverChannelID,ecx

        ; Set up a ptr to the location of the current channel ID
        ; This ptr is used by all the clients with DMA pushers.
        lea     edx,[esi].HWBOARDCX.dwCurrentChannelID
        mov     ds:[esi].HWBOARDCX.pCurrentChannelID,edx

        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocRequiredMemory
;
; Purpose:      This routine allocates memory for the IndexedImageLUT
;               and enough for cursors for all heads on the board.
;               The addresses are saved off so that other objects
;               can ask for them later.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocRequiredMemory, PASCAL, FRAME, NEAR
LOCALD  dwPitchInBytes
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   edi

        ; The Indexed Image Lut needs to be 1K aligned on a 1K boundary
        ; so we have to alloc at least 2K - 1 to be certain of alignment.
        mov     eax,800H
        push    esi
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_BOARD_OWNER
        pushd   NVIOCONTROL_TYPE_CURSOR
        push    eax
        call    NV_OffscreenHeapAlloc
        cmp     eax,-1
        je      FailIt
        mov     ds:[esi].HWBOARDCX.dwIndexedLUTOffset,eax

        ; Set the cursor cache size
        mov     ds:[esi].HWBOARDCX.dwCursorCacheSize,24

        ; Now allocate a cursor cache for each/all heads.
        ; We are going to assume the largest cursor at 32x32 with
        ; alpha which is a 32bpp cursor. This takes 4K bytes. We
        ; must also align to a 4K boundary which means an extra 4K.
        mov     eax,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        imul    eax,ds:[esi].HWBOARDCX.dwCursorCacheSize
        inc     eax
        imul    eax,1000H
        push    esi
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_BOARD_OWNER
        pushd   NVIOCONTROL_TYPE_CURSOR
        push    eax
        call    NV_OffscreenHeapAlloc
        cmp     eax,-1
        je      FailIt

        ; Align to a 4K boundary
        add     eax,0FFFH
        and     eax,NOT 0FFFH

        lea     edi,[esi].HWBOARDCX.adwCursorCacheVramOffset
        sub     ecx,ecx
        mov     edx,ds:[esi].HWBOARDCX.dwCursorCacheSize
        imul    edx,1000H
@@:     mov     ds:[edi + ecx * 4],eax
        add     eax,edx
        inc     ecx
        cmp     ecx,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        jc      @B

        mov     eax,1
        jmp     DoneIt

FailIt:
        sub     eax,eax
DoneIt:
        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetCursorCacheInfo
;
; Purpose:      This routine returns informatin about the cursor
;               cache for the given head.
;
; Arguments:    ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwPhysicalCRTCIndex     index of CRTC to get the cursor
;                                       cache info for
;
; Returns:      eax     offset of cursor cache in video mnemory
;               ebx     number of cache slots
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetCursorCacheInfo, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwPhysicalCRTCIndex
OPENPROC
        mov     edx,pHWBoardCXOffset
        mov     ebx,ds:[edx].HWBOARDCX.dwCursorCacheSize
        mov     ecx,dwPhysicalCRTCIndex
        mov     eax,ds:[edx].HWBOARDCX.adwCursorCacheVramOffset[ecx * 4]
CLOSEPROC


;==============================================================================
;
; Function:     NV_BoardSetDXSharedData
;
; Purpose:      This routine sets the shared DX data structure fields
;               that have board specific information.
;
; Arguments:    ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               pDXShare                DISPDRVDIRECTXCOMMON ptr
;
; Returns:      eax     offset of cursor cache in video mnemory
;               ebx     number of cache slots
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_BoardSetDXSharedData, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   pDXShare
OPENPROC
        mov     ebx,pHWBoardCXOffset
        mov     edx,pDXShare
        mov     eax,ds:[ebx].HWBOARDCX.dwDeviceNum
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwNVDeviceID,eax
        mov     eax,ds:[ebx].HWBOARDCX.dwDeviceVersion
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwDeviceVersion,eax
        mov     eax,ds:[ebx].HWBOARDCX.dwRootHandle
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwRootHandle,eax
        mov     eax,ds:[ebx].HWBOARDCX.pChipRegs
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwDeviceLinearBase,eax
CLOSEPROC

;==============================================================================
;
; Function:     NV_SetInterlacedStereoMode
;
; Purpose:      This routine sets the interlaced stereo mode if needed
;               and lets resman know about it. If stereo type is interlaced 
;               then stereo buffers have to be adjacent in video memory. So 
;               resman must know about it in order to adjust the pitch
;               to accomodate the right eye.
;
; Arguments:    ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwInterlacedMode        1/0
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetInterlacedStereoMode, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwInterlacedMode
LOCALV  StereoParams,NV_CFG_STEREO_PARAMS
OPENPROC
        PUSHR   ds,esi,edi
        
        mov		eax,dwInterlacedMode
        lea     edi,StereoParams
        mov     esi,pHWBoardCXOffset
        mov     ss:[edi].NV_CFG_STEREO_PARAMS.Flags, STEREOCFG_EXIT_ADJACENT 
		mov     ds:[esi].HWBOARDCX.dwStereoConnectionType, eax
        test	eax, eax
        jz      @F
        mov     ss:[edi].NV_CFG_STEREO_PARAMS.Flags, STEREOCFG_ENTER_ADJACENT 
@@:
        pushd   NV_CFG_STEREO_CONFIG    
        mov     ax,ss
        push    ax
        lea     ax,StereoParams
        push    ax
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCRTC.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwcrtc.asm
;
; Purpose:      This file contains all the hardware specific CRTC
;               specific routines for init. The crtc specific run-
;               time routines are in hwcrtc2.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include modeext.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

IFDEF DEBUG
szCreate        DB      'DISPLAY:HW_CreateCrtcContext',0DH,0AH,0
szDestroy       DB      'DISPLAY:HW_DestroyCrtcContext',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     HW_CreateCrtcContext
;
; Purpose:      This routine allocates memory for and initializes
;               a HWCRTCCX structure.
;
; Arguments:
;               ds                      The context selector.
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      eax     0       failure
;                       non-0   HWCRTCCX ptr
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateCrtcContext, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi

        sub     esi,esi
        pushd   SIZE HWCRTCCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; We are initting
        mov     ds:[esi].HWCRTCCX.dwInitting,1

        ; Save the HWBoardCX owning this CRTC
        mov     edi,pHWBoardCXOffset
        mov     ds:[esi].HWCRTCCX.pHWBoardCX,edi

        ; For the rest of init, just assume head 0. It won't
        ; matter. This will all get updated later.
        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,0

        ; We may not be head 0, but that doesn't really matter.
        ; We just need to get the max cacheable cursors, which
        ; we will assume is the same for both heads. The cursor
        ; cache offset will actually be regotten later so if
        ; the head is different it won't matter.
        push    pHWBoardCXOffset
        pushd   0
        call    NV_GetCursorCacheInfo
        mov     ds:[esi].HWCRTCCX.dwCursorCacheVramOffset,eax
        mov     ds:[esi].HWCRTCCX.dwMaxCachedCursors,ebx

        ; Determine the cursor alpha value... Init to -1 for now
        mov     ds:[esi].HWCRTCCX.dwCursorAlpha,-1

        ; Get the encoder information
        push    esi
        call    NV_GetEncoderInfo

        ; Now set it to -1 to show there is no instance
        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,-1

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szCreate
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the HWCRTCCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; HW_DestroyBoardContext can clean up partial inits
        push    esi
        call    HW_DestroyCrtcContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyCrtcContext
;
; Purpose:      This routine allocates memory for and initializes
;               an array of HWCRTCCX structure.
;
; Arguments:
;               ds              The context selector.
;               pHWCrtcCXOffset offset of HWCRTCCX to destroy.
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyCrtcContext, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szDestroy
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        push    esi
        call    NV_FreeHeadRelatedInfo

        ; Clear out the HWBoard ptr
        mov     ds:[esi].HWCRTCCX.pHWBoardCX,0

        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocHeadRelatedInfo
;
; Purpose:      This routine allocates all head related info. This
;               include the VidLutCursorDac and the physical CRTC.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               dwPhysicalHead          physical head to use
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocHeadRelatedInfo, PASCAL, FRAME, NEAR
PARMD   pHWCrtcCXOffset
PARMD   dwPhysicalHead
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

        mov     eax,dwPhysicalHead
        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,eax
        mov     edi,ds:[esi].HWCRTCCX.pHWBoardCX

        ; Ask the board for the cursor cache offset and the
        ; maximum size of the cursor cache ...
        push    edi
        push    ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        call    NV_GetCursorCacheInfo
        mov     ds:[esi].HWCRTCCX.dwCursorCacheVramOffset,eax
        mov     ds:[esi].HWCRTCCX.dwMaxCachedCursors,ebx

        ; Allocate a VideoLutCursorDac object (this shouldn't fail)
        call    CreateVideoLutCursorDac
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeHeadRelatedInfo
;
; Purpose:      This routine frees all head related info. This
;               include the VidLutCursorDac and the physical CRTC.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeHeadRelatedInfo, PASCAL, FRAME, NEAR
PARMD   pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

        mov     edi,ds:[esi].HWCRTCCX.pHWBoardCX
        call    DestroyVideoLutCursorDac

        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,-1
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_CrtcSetLogdev
;
; Purpose:      This routine tells the crtc what logical device
;               owns it.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CrtcSetLogdev, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      SkipSet
        mov     eax,pHWLogdevCXOffset
        mov     ds:[ebx].HWCRTCCX.pHWLogdevCX,eax
SkipSet:
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetEncoderInfo
;
; Purpose:      This routine gets the Encoder type on the card and
;               the I2C address at which it is located.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetEncoderInfo, PASCAL, FRAME, NEAR
PARMD   pHWCrtcCXOffset
LOCALV  sVidTypeParams,NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS
LOCALV  sVidIDInfoParams,NV_CFGEX_VIDEO_ENCODER_ID_PARAMS
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipGet
        mov     edi,ds:[esi].HWCRTCCX.pHWBoardCX

        ; Get the CRTC head number.
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sVidTypeParams.Head,eax
        mov     sVidIDInfoParams.Head,eax

        ; Get the encoder type
        mov     ax,ss
        shl     eax,10H
        lea     ax,sVidTypeParams
        mov     ebx,SIZE NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS
        mov     ecx,NV_CFGEX_VIDEO_ENCODER_TYPE
        push    esi
        mov     esi,edi
        call    NV_ConfigExCall
        pop     esi
        mov     eax,sVidTypeParams.EncoderdwType
        mov     ds:[esi].HWCRTCCX.dwTVOutDeviceID,eax

        mov     ax,ss
        shl     eax,10H
        lea     ax,sVidIDInfoParams
        mov     ebx,SIZE NV_CFGEX_VIDEO_ENCODER_ID_PARAMS
        mov     ecx,NV_CFGEX_VIDEO_ENCODER_ID
        push    esi
        mov     esi,edi
        call    NV_ConfigExCall
        pop     esi
        mov     eax,sVidIDInfoParams.EncoderID
        shr     eax,1
        mov     ds:[esi].HWCRTCCX.dwTVOutDeviceAddr,eax

SkipGet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetMaxTVOutResolution
;
; Purpose:      Find out the maximum resolution for Encoder
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     XRes, YRes
;               ebx     TVEncoder ID
;
;==============================================================================
DECPROC HW_GetMaxTVOutResolution, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     ecx,pHWCrtcCXOffset

        ; Set 1024X768 for Brooktree 871
        mov     eax,04000300h
        mov     ebx,ds:[ecx].HWCRTCCX.dwTVOutDeviceID
        cmp     ebx,NV_ENCODER_BROOKTREE_871
        je      @F
        ; Default 800X600
        mov     eax,03200258h
@@:
CLOSEPROC



;==============================================================================
;
; Function:     CreateVideoLutCursorDac
;
; Purpose:      This function creates a VideoLutCursorDac object
;               for use in the WIN_CHANNEL.
;
; Arguments:
;               ds:esi  HWCRTCCX
;               ds:edi  HWBOARDCX
;
; Returns:
;               eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi
;==============================================================================
DECPROC CreateVideoLutCursorDac, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Allocate a Context DMA for the VidLutCurDac notifier
        mov     ds:[esi].HWCRTCCX.bNotifierCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        push    edi
        push    eax
        lea     ebx,[esi].HWCRTCCX.sVideoLutCursorDacNotifier0
        push    ebx
        mov     ax,ds
        push    eax
        pushd   9 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWCRTCCX.bNotifierCreated,1

        ; Allocate a Context DMA for the Palette
        mov     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_PALETTE
        push    edi
        push    eax
        lea     eax,[esi].HWCRTCCX.dwPaletteTable
        push    eax
        mov     ax,ds
        push    eax
        pushd   400H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,1

        ; Allocate a Context DMA for the Gamma
        mov     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_GAMMA
        push    edi
        push    eax
        lea     eax,[esi].HWCRTCCX.dwGammaTable
        push    eax
        mov     ax,ds
        push    eax
        pushd   400H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,1

        ; Create the object
        mov     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        push    esi
        push    edi
        pushd   NV15_VIDEO_LUT_CURSOR_DAC
        push    eax
        call    NV_RMAllocObject
        or      eax,eax
        je      @F
        jmp     ObjectCreated
@@:
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        push    edi
        pushd   NV04_VIDEO_LUT_CURSOR_DAC
        push    eax
        call    NV_AllocWinChannelObject
        or      eax,eax
        je      DoneIt
        
ObjectCreated:
        mov     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,1

        ; Set the object in a sub-channel
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,edi,eax

        mov     edx,edi
        mov     edi,ds:[edi].HWBOARDCX.pCurrentPushBufferOffset

        CHECKDMASPACE ds,edx,edi,18H
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     ebx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     ebx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(VideoLutCursorDac.SetContextDmaNotifies,1)
        mov     ebx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     ebx,OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(VideoLutCursorDac.SetContextDmaImage,1)
        mov     ebx,OBJ_DMA_IN_VRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx

        add     edi,18H
        SETPUTPTR ds,edx,edi
        mov     edi,edx
        mov     eax,1
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     DestroyVideoLutCursorDac
;
; Purpose:      This function destroys the VideoLutCursorDac object.
;
; Arguments:
;               ds:esi  HWCRTCCX
;               ds:edi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi
;==============================================================================
DECPROC DestroyVideoLutCursorDac, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Destroy the VidLutCurDac object
        cmp     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,0
@@:
        ; Destroy the Context DMA for the gamma
        cmp     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_PALETTE
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,0
@@:
        ; Destroy the Context DMA for the gamma
        cmp     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_GAMMA
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,0
@@:
        ; Destroy the Context DMA for the VidLutCurDac notifier.
        cmp     ds:[esi].HWCRTCCX.bNotifierCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bNotifierCreated,0
@@:
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetDacLimits
;
; Purpose:      This routine gets the DAC limits in all pixel depths.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset HWCRTCCX ptr
;
; Returns:
;               eax             Dac Speed limit in 8bpp in Hertz
;               ebx             Dac Speed limit in 16bpp in Hertz
;               ecx             Dac Speed limit in 32bpp in Hertz
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDacLimits, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALD  dw8BppLimit
LOCALD  dw16BppLimit
LOCALD  dw32BppLimit
LOCALV  sDACInfoParams,NV_CFGEX_DAC_PCLK_LIMIT_PARAMS
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipGet
        
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sDACInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDACInfoParams
        mov     ebx,SIZE NV_CFGEX_DAC_PCLK_LIMIT_PARAMS 
        mov     ecx,NV_CFGEX_DAC_PCLK_LIMIT_8BPP
        call    NV_ConfigExCall
        mov     eax,sDACInfoParams.pclkLimit
        mov     dw8BppLimit,eax

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDACInfoParams
        mov     ebx,SIZE NV_CFGEX_DAC_PCLK_LIMIT_PARAMS 
        mov     ecx,NV_CFGEX_DAC_PCLK_LIMIT_16BPP
        call    NV_ConfigExCall
        mov     eax,sDACInfoParams.pclkLimit
        mov     dw16BppLimit,eax

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDACInfoParams
        mov     ebx,SIZE NV_CFGEX_DAC_PCLK_LIMIT_PARAMS 
        mov     ecx,NV_CFGEX_DAC_PCLK_LIMIT_32BPP
        call    NV_ConfigExCall
        mov     eax,sDACInfoParams.pclkLimit
        mov     dw32BppLimit,eax

        mov     eax,dw8BppLimit
        mov     ebx,dw16BppLimit
        mov     ecx,dw32BppLimit
        
SkipGet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitsPerColorGun
;
; Purpose:      This routine returns the number of bits per
;               color channel in the CRTC given.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         offset of HWCRTCCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BitsPerColorGun, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     eax,8
CLOSEPROC


;==============================================================================
;
; Function:     HW_SizeCursorCache
;
; Purpose:      This routine tells the hardware the maximum
;               number of cursors the generic cursor cache
;               can support. The hardware returns the number
;               of cursors it wants to cache that is less than
;               or equal to the number provided.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         offset of HWCRTCCX
;               dwMaxCursorCacheSize    maximum size of cursor cache
;
; Returns:
;               eax             Number of cursors the hardware wants
;                               to cache. Must be less than
;                               dwMaxCursorCacheSize
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SizeCursorCache, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwMaxCursorCacheSize
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      @F
        mov     eax,dwMaxCursorCacheSize
        cmp     eax,ds:[ebx].HWCRTCCX.dwMaxCachedCursors
        jc      @F
        mov     eax,ds:[ebx].HWCRTCCX.dwMaxCachedCursors
@@:
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsCRTConnected
;
; Purpose:      This function returns TRUE if the CRT is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     TRUE  if CRT is connected
;                       FALSE if it is not connected
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsCRTConnected, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sCRTInfoParams,NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        sub     eax,eax
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sCRTInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        .errnz  NV_CFGEX_GET_MONITOR_INFO_NOT_CONNECTED

        sub     eax,eax
        mov     sCRTInfoParams.MonitorConnected,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,sCRTInfoParams
        mov     ebx,SIZE NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS
        mov     ecx,NV_CFGEX_GET_MONITOR_INFO_MULTI
        call    NV_ConfigExCall
        mov     eax,sCRTInfoParams.MonitorConnected
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsDFPConnected
;
; Purpose:      This function returns TRUE if the DFP is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     TRUE  if DFP is connected
;                       FALSE if it is not connected
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsDFPConnected, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sDFPInfoParams,NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        sub     eax,eax
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sDFPInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        .errnz  NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED

        sub     eax,eax
        mov     sDFPInfoParams.FlatPanelConnected,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDFPInfoParams
        mov     ebx,SIZE NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS
        mov     ecx,NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI
        call    NV_ConfigExCall
        mov     eax,sDFPInfoParams.FlatPanelConnected
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsTVConnected
;
; Purpose:      This function returns TRUE if the TV is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     TRUE  if tv is connected
;                       FALSE if it is not connected
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsTVConnected, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sTVInfoParams,NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        sub     eax,eax
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sTVInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        .errnz  TV_NOT_CONNECTED

        sub     eax,eax
        mov     sTVInfoParams.TVConnected,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,sTVInfoParams
        mov     ecx,NV_CFGEX_GET_TV_ENCODER_INFO_MULTI
        call    NV_ConfigExCall
        mov     eax,sTVInfoParams.TVConnected
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetMaxDfpScaledXRes
;
; Purpose:      This function returns the maximum scanline length
;               in pixels that the hardware can scale to on a DFP.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     max XRes scaling length in pixels
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetMaxDfpScaledXRes, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sTVInfoParams,NV_CFGEX_TV_ENCODER_PARAMS
OPENPROC
        mov     eax,400H
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsMacroVisionEncoderAttached
;
; Purpose:      This function returns whether or not we have a macro
;               vision capable TV out device attached.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax                     0       then no macrovision encoder
;                                       non-0   then yes
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC HW_IsMacroVisionEncoderAttached, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        sub     eax,eax
        or      ebx,ebx
        je      DoneIt
        mov     ebx,ds:[ebx].HWCRTCCX.dwTVOutDeviceID

        ; Check for devices that is not support macrovision
        cmp     ebx,NV_ENCODER_BROOKTREE_868
        je      DoneIt
        cmp     ebx,NV_ENCODER_CHRONTEL_7003
        je      DoneIt
        cmp     ebx,NV_ENCODER_CHRONTEL_7006
        je      DoneIt
        cmp     ebx,NV_ENCODER_CHRONTEL_7008
        je      DoneIt

        ; We assume all next generations should support macrovision.
        mov     eax,ebx
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     HW_ReadEdid
;
; Purpose:      This function reads the EDID.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDevData       type in low byte, num in next byte
;               pEdidBuffer     offset to EDID buffer
;               pEdidSize       offset to place to store edid size
;                               The variable this points to has been
;                               set to the maximum size it can handle.
;
; Returns:      eax     0       then there was a problem reading the EDID.
;                       non-0   then there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_ReadEdid, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwDevData
PARMD   pEdidBuffer
PARMD   pEdidSize
LOCALV  sEdidParams,NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      WasProb

        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        mov     sEdidParams.displayMap,eax

        ; Get the base address of the CX selector
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase

        ; Build a flat offset to the EdidBuffer and EdidSize
        mov     edx,pEdidBuffer
        add     edx,eax
        mov     sEdidParams.edidBuffer,edx
        mov     edx,pEdidSize
        add     eax,edx
        mov     sEdidParams.bufferLength,eax

        ; Make the call to the RM to read the EDID
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sEdidParams
        mov     ebx,SIZE NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
        mov     ecx,NV_CFGEX_GET_LOGICAL_DEV_EDID
        call    NV_ConfigExCall

        or      eax,eax
        mov     eax,1
        je      DoneIt

WasProb:
        sub     eax,eax
        mov     ecx,pEdidSize
        mov     ds:[ecx],eax

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_ReadEdidForDevice
;
; Purpose:      This function reads the EDID to a buffer for the specific
;               display device requested (i.e., CRT0, DFP1, . . .)
;
; Arguments:
;               ds              Context Selector
;               pHWLogDevCXOffset offset in Context selector to HWLOGDEVCX
;               dwDisplayDev    display type device mask for device to read
;               lpEdidBuffer    ptr to EDID buffer
;               lpEdidSize      ptrt to place to store edid size
;                               The variable this points to has been
;                               set to the maximum size it can handle.
;
; Returns:      eax     0       then there was a problem reading the EDID.
;                       non-0   then there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_ReadEdidForDevice, PASCAL, FRAME, FAR32
PARMD   pHWLogDevCxOffset
PARMD   dwDisplayDev
PARMD   lpEdidBuffer
PARMD   lpEdidSize
LOCALV  sEdidParams,NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWLogDevCxOffset
        or      esi,esi
        je      WasProb

        ; Get the base address of the selector for EdidBuffer. This will
        ; also be used for EdidSize.
        mov     eax,lpEdidBuffer
        shr     eax,10h
        push    eax
        call    GN_GetSelectorBase

        ; Build a flat offset to the EdidBuffer and EdidSize
        sub     edx,edx
        les     dx,lpEdidBuffer
        add     edx,eax
        mov     sEdidParams.edidBuffer,edx
        sub     edx,edx
        les     dx,lpEdidSize
        add     eax,edx
        mov     sEdidParams.bufferLength,eax

        ; Make the call to the RM to read the EDID. Set the displayMap to DFP0.
        mov     eax,dwDisplayDev
        mov     sEdidParams.displayMap,eax
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sEdidParams
        mov     ebx,SIZE NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
        mov     ecx,NV_CFGEX_GET_LOGICAL_DEV_EDID
        call    NV_ConfigExCall

        or      eax,eax
        mov     eax,1
        je      DoneIt

WasProb:
        sub     eax,eax

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetPhysicalCrtcIndex
;
; Purpose:      This function returns the physical CRTC index that this
;               HWCRTCCX is attached to.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;
; Returns:      eax     0-based physical CRTC number
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetPhysicalCrtcIndex, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      @F
        sub     eax,eax
        or      ebx,ebx
        je      @F
        mov     eax,ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
@@:
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetBootDevice
;
; Purpose:      This function returns the device the HW would like us
;               to use for this CRTC.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDeviceInstance Primary device (0), secondary device (1), etc.
;
; Returns:      eax             bits 7:0  - Device Type to use
;                               bits 15:8 - Device Number to use
;                               bits 23:16 - format to use if type is TV
;                       -1 if no there are fewer than dwDeviceInstance+1
;                       bits set.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetBootDevice, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDeviceInstance
LOCALD  dwFoundInstance
LOCALB  dbDeviceNumber
OPENPROC
        mov     ebx,pHWBoardCXOffset
        sub     eax,eax
        or      ebx,ebx
        je      NoDevice

        cmp     dwDeviceInstance,7
        ja      NoDevice

        mov     dbDeviceNumber,0
        mov     dwFoundInstance,0

        pushd   NV_CFG_GET_BOOT_DEVICES
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax

        ; Result from ConfigGet is in dx:ax
        ; Put CRTs in DL, TVs in CL, and DFPs in CH. DH = bit to test.
        mov     ch,dl
        mov     cl,ah
        mov     dl,al
        mov     dh,1
        sub     eax,eax

        ; The order of precedence is DFP0, CRT0, TV0, DFP1, CRT1, TV1, . . .
DeviceNumberLoop:

        mov     al,DEVTYPE_DFP
        test    ch,dh
        jz      CheckCRT
        mov     ebx,dwDeviceInstance
        cmp     dwFoundInstance,ebx
        je      FoundDevice
        inc     dwFoundInstance

CheckCRT:
        mov     al,DEVTYPE_CRT
        test    dl,dh
        jz      CheckTV
        mov     ebx,dwDeviceInstance
        cmp     dwFoundInstance,ebx
        je      FoundDevice
        inc     dwFoundInstance

CheckTV:
        mov     al,DEVTYPE_TV
        test    cl,dh
        jz      NextDeviceNumber
        mov     ebx,dwDeviceInstance
        cmp     dwFoundInstance,ebx
        je      FoundDevice
        inc     dwFoundInstance

NextDeviceNumber:
        cmp     dh,80h
        je      NoDevice
        shl     dh,1
        inc     dbDeviceNumber
        jmp     DeviceNumberLoop

FoundDevice:
        mov     ah,dbDeviceNumber
        cmp     al,DEVTYPE_TV
        jne     DoneIt

        ; With the TV, we need the format also
        push    eax
        mov     ebx,pHWBoardCXOffset
        pushd   NV_CFG_BIOS_DEFAULT_TV_TYPE
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        movzx   ecx,ax
        call    HW_MapHWTvFormatToGNTvFormat
        shl     ecx,10H
        pop     eax
        or      eax,ecx
        jmp     DoneIt

NoDevice:
        mov     eax,-1
        jmp     DoneIt

DoneIt:

CLOSEPROC


;==============================================================================
;
; Function:     HW_GetResManTvFormat
;
; Purpose:      This function returns the TV Format
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDevData       Device for which we want the TV Format
;
; Returns:      eax             TvFormat                
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetResManTvFormat, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwDevData
LOCALV  sTVParams,NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
OPENPROC

        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      WasProb

        ; Make sure this is a TV or don't call ResMan
        mov     cl,(DEVDATA PTR dwDevData).cType
        cmp     cl,DEVTYPE_TV
        jne     WasProb
        
        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        mov     sTVParams.DevicesConfig,eax

        ; Make the call to the RM to read the EDID
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sTVParams
        mov     ebx,SIZE NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
        mov     ecx,NV_CFGEX_GET_VIDEO_TV_STANDARD
        call    NV_ConfigExCall

        or      eax,eax
        mov     eax,sTVParams.TVStandard
        je      DoneIt

WasProb:
        sub     eax,eax

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetResManTvFormat
;
; Purpose:      This function sets the Tv Format in the ResMan
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDevData       Device and TV Format to set
;
; Returns:      
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetResManTvFormat, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwDevData
LOCALV  sTVParams,NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
OPENPROC

        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      WasProb

        ; Make sure this is a TV or don't call ResMan
        mov     cl,(DEVDATA PTR dwDevData).cType
        cmp     cl,DEVTYPE_TV
        jne     WasProb
        
        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        mov     sTVParams.DevicesConfig,eax
        
        ; Store the TV Format we want to set in sTVParams.
        mov     ecx,dwDevData
        shr     ecx,10h
        and     ecx,0FFh        
        mov     sTVParams.TVStandard,ecx

        ; Make the call to the RM to read the EDID
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sTVParams
        mov     ebx,SIZE NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
        mov     ecx,NV_CFGEX_GET_VIDEO_TV_STANDARD
        call    NV_ConfigExCall

        or      eax,eax
        je      DoneIt

WasProb:
        sub     eax,eax

DoneIt:
        POPR    esi
CLOSEPROC


CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWACCESS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwaccess.asm
;
; Purpose:      This file implements the BeginAccess Functions and
;               functions for creating and deleting offscreen bitmaps.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwmacs.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_GetGraphicsTimeStamp
;
; Purpose:      This function returns should return a value that is
;               some measure of graphics activity time. The DMA buffer
;               ptr is good since it increases with increasing graphics
;               activity (except when it is reset to the start of the
;               buffer, but I'll ignore that for now.)
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:
;               eax     A graphics time stamp
;
; Preserve:     All registers except eax
;==============================================================================
DECPROC HW_GetGraphicsTimeStamp, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     eax,pHWLogdevCXOffset
        mov     eax,ds:[eax].HWLOGDEVCX.pHWBoardCX
        mov     eax,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
CLOSEPROC

CLOSESEG _NVTEXT16

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginAccess
;
; Purpose:      This function should wait until all hardware contexts
;               are idle before returning. It is probably being called
;               so that the CPU can access the frame buffer directly
;               so wait for idle here to preserve order of operations.
;
; Arguments:
;               ds 	CXSel
;               esi     HWLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC HW_BeginAccess, PASCAL, NOFRAME, NEAR
OPENPROC
	PUSHR	eax,ecx

        mov     eax,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov	ecx,ds:[eax].HWBOARDCX.dwGdiDriverChannelID
        cmp	ecx,ds:[eax].HWBOARDCX.dwCurrentChannelID
        jne	SyncOtherChannels

	; If we are still idle from the last sync, then don't sync again
        mov     ecx,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
        cmp     ecx,ds:[eax].HWBOARDCX.dwGetOffsetAtLastBeginAccess
        jne     SyncThisChannel

Done:
	STOPPROC
	POPR	eax,ecx
	ret

SyncThisChannel:
        PUSHR   alld

	; set edi = HWBOARDCX and edi = PushBufferOffset
        mov	esi,eax
	mov	edi,ecx

        CHECKDMASPACE ds,esi,edi,10H
        SETDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>
        mov     eax,CHNRUN(ContextClipRect.Notify,1)
        mov     ecx,NV019_NOTIFY_WRITE_ONLY
        mov     edx,CHNRUN(ContextClipRect.NoOperation,1)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],esi
        add     edi,10H

        ; Cyrix reorders cached reads ahead of uncached writes. If we
        ; don't execute a serializing instruction, we might spin on the
        ; notifier preventing the command from getting out to the chip.
        xchg    eax,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR ds,esi,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>

        ; Remember the last "synced" get offset. People that want to
        ; write the frame buffer directly can compare the
        ; dwCurrentPushBufferOffset with this value. If they are the
        ; same then, there is no need to issue another sync.
        mov     ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess,edi
        POPR    alld
	jmp	Done

SyncOtherChannels:
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,eax,ecx
	jmp	Done
CLOSEPROC

;==============================================================================
DECPROC HW_BeginAccess_Far32, PASCAL, NOFRAME, FAR32
OPENPROC
	call	HW_BeginAccess
CLOSEPROC

;==============================================================================
;
; Function:     HW_EndAccess
;
; Purpose:      This is the hardware specific EndAccess routine.
;               There is probably nothing you need to do here,
;               but it is called after the CPU is done touching
;               the display so if you need to put the hardware
;               back in "bltter" mode, do so now.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC HW_EndAccess, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC

IF	(HW_WAIT NE 0)
;==============================================================================
;
; Function:     WaitUntilGdiContextIdle
;
; Purpose:      This function should wait until all hardware contexts
;               are idle before returning. It is probably being called
;               so that the CPU can access the frame buffer directly
;               so wait for idle here to preserve order of operations.
;
; Arguments:
;               pHWBoardCXOffset
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC WaitUntilGdiContextIdle, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
OPENPROC
	PUSHR	ds,alld

        mov     ds,cs:[wFlatDataSel]
        mov     eax,pHWBoardCXOffset

	; If we are still idle from the last sync, then don't sync again
        mov     ecx,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
        cmp     ecx,ds:[eax].HWBOARDCX.dwGetOffsetAtLastBeginAccess
        je	Done

	; set edi = HWBOARDCX and edi = PushBufferOffset
        mov	esi,eax
	mov	edi,ecx

        CHECKDMASPACE ds,esi,edi,10H
        SETDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>
        mov     eax,CHNRUN(ContextClipRect.Notify,1)
        mov     ecx,NV019_NOTIFY_WRITE_ONLY
        mov     edx,CHNRUN(ContextClipRect.NoOperation,1)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],esi
        add     edi,10H

        ; Cyrix reorders cached reads ahead of uncached writes. If we
        ; don't execute a serializing instruction, we might spin on the
        ; notifier preventing the command from getting out to the chip.
        xchg    eax,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR ds,esi,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>

IFDEF DEBUG;!!
	;;Trap for MMIO corruption
        mov     eax,ds:[esi].HWBOARDCX.pDmaChannel
	sub	eax,0F0000H
	;;Read RM objects data
	mov	ebx,ds:[eax+50H]
	or	ebx,ebx
	jz	@F
        mov     ecx,ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess
	int	3
@@:
ENDIF
        ; Remember the last "synced" get offset. People that want to
        ; write the frame buffer directly can compare the
        ; dwCurrentPushBufferOffset with this value. If they are the
        ; same then, there is no need to issue another sync.
        mov     ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess,edi

Done:
	POPR	ds,alld
CLOSEPROC
ENDIF


;==============================================================================
;
; Function:     HW_CreateOffscreenBitmap
;
; Purpose:      This function is called by the generic code when it wants
;               to create an offscreen bitmap. You need to do two things
;               in here:
;               1) If the hardware cannot accept any bitmap from 1x1 up
;                  to 32K pixels by 32K pixels then check the bitmap size
;                  and succeed or fail appropriately.
;               2) If you accept the creation, fill in the
;                  ds:[esi].DIBENGINE.deDeltaScan field with the pitch
;                  you wish for the bitmap.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWBOARDCX ptr
;               es:edi          ptr to DEVBMP.
;                               The fields below are valid:
;               deWidth
;               deHeight
;               deWidthBytes
;               dePlanes
;               deBitsPixel
;               delpPDevice
;
; Returns:      eax     0       Do not place this bitmap in offscreen
;                       non-0   OK to put the bitmap in offscreen
;                               In this case you should also fill in
;                               ds:[esi].DIBENGINE.deDeltaScan with
;                               the desired bitmap pitch. The pitch
;                               must be a multiple of 4, but your
;                               hardware may have other restrictions
;                               as well.
;
; Preserve:     ds,esi,edi,es
;               Do not destroy any other fields in the DEVBMP or PDEVICE
;==============================================================================
DECPROC HW_CreateOffscreenBitmap, PASCAL, NOFRAME, NEAR
OPENPROC
        movzx   eax,es:[edi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[ebx].HWBOARDCX.dwMinContextSurface2dPitch
        dec     ecx
        add     eax,ecx
        not     ecx
        and     eax,ecx
        mov     es:[edi].DIBENGINE.deDeltaScan,eax
        dec     eax
        sub     eax,ds:[ebx].HWBOARDCX.dwMaxContextSurface2dPitch
        sbb     eax,eax
CLOSEPROC


;==============================================================================
;
; Function:     HW_DeleteOffscreenBitmap
;
; Purpose:      This routine is called when an offscreen bitmap is being
;               deleted. The hardware specific code can do anything it
;               needs to. Typically, you will need to check to see if
;               the current active bitmap has been set to the one being
;               deleted and set the active base and pitch in the chip
;               to, say, -1. Another bitmap may be allocated at the
;               same address with a different pitch and unless the
;               base and pitch get reset properly, things could get
;               drawn incorrectly.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWBOARDCX ptr
;               eax		DIBENGINEHDR.deBitsOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC HW_DeleteOffscreenBitmap, PASCAL, NOFRAME, NEAR
OPENPROC
        cmp     eax,ds:[ebx].HWBOARDCX.dwContextSurface2dSrcOffset
        jne     @F
        mov     ds:[ebx].HWBOARDCX.dwContextSurface2dSrcOffset,0FFFF0000h
@@:
        cmp     eax,ds:[ebx].HWBOARDCX.dwContextSurface2dDstOffset
        jne     @F
        mov     ds:[ebx].HWBOARDCX.dwContextSurface2dDstOffset,0FFFF0000h
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCRTC2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwcrtc2.asm
;
; Purpose:      This file contains all the hardware specific CRTC
;               routines for run-time. The CRTC specific init
;               routines are in hwcrtc.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include modeext.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  TableMonitorTypeRMToModeset
TableMonitorTypeRMToModeset     LABEL   BYTE
DB      DEVTYPE_CRT, DEVTYPE_CRT, DEVTYPE_TV, DEVTYPE_TV, DEVTYPE_DFP

PUBLIC  TableMonitorTypeModesetToRM
TableMonitorTypeModesetToRM     LABEL   BYTE
DB      MONITOR_TYPE_VGA, MONITOR_TYPE_NTSC, MONITOR_TYPE_FLAT_PANEL

PUBLIC  TableTvFormatRMToModeset
TableTvFormatRMToModeset        LABEL   BYTE
DB      TVTYPE_NTSCM, TVTYPE_NTSCJ, TVTYPE_PALM, TVTYPE_PALA, TVTYPE_PALN
DB      TVTYPE_PALNC

PUBLIC  TableTvFormatModesetToRM
TableTvFormatModesetToRM        LABEL   BYTE
DB      NTSC_M, NTSC_J, PAL_M, PAL_A, PAL_N, PAL_NC

IFDEF DEBUG
szSetMode       DB      'DISPLAY:HW_SetCrtcMode',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     HW_CrtcMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CrtcMessage, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        jmp     DoneIt

PreMS:
        jmp     DoneIt

PostMS:
        ; We are no longer initting after the first modeset
        mov     ds:[esi].HWCRTCCX.dwInitting,0
        jmp     DoneIt

DXEnum:
DXOn:
DXOff:
        jmp     DoneIt

DosOff:
        jmp     DoneIt

DosOn:
        jmp     DoneIt

DrvDis:

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetCrtcMode
;
; Purpose:      This routine gets called to stuff the CRTCs
;               timings into the push buffer and physically
;               set the mode.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               lpModeOut               16:16 ptr to MODEOUT
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetCrtcMode, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwImageOffset
PARMD   lpModeOut
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipSet

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szSetMode
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        sub     ebx,ebx
        les     bx,lpModeOut

        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     ecx,ds:[esi].HWCRTCCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ecx,eax

        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        SETDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier1.status>

        CHECKDMASPACE ds,ecx,edi,38H

        ; Set the object in a sub-channel.
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     ds:[edi + 00H],eax
        add     edx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 04H],edx

        ; get X-res and Y-res
        mov     eax,CHNRUN(VideoLutCursorDac.SetDac.imagedwSize,8)
        mov     ds:[edi + 08H],eax
        mov     eax,dword ptr es:[ebx].MODEOUT.wXRes
        mov     ds:[edi + 0CH],eax

        ; horz blank start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wHBlankStart
        mov     ds:[edi + 10H],eax

        ; horz sync start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wHSyncStart
        mov     ds:[edi + 14H],eax

        ; vert blank start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wVBlankStart
        mov     ds:[edi + 18H],eax

        ; vert sync start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wVSyncStart
        mov     ds:[edi + 1CH],eax

        ; set total size
        mov     eax,dword ptr es:[ebx].MODEOUT.wHTotal
        mov     ds:[edi + 20H],eax

        ; set pixel clock
        mov     eax,dword ptr es:[ebx].MODEOUT.dwPixelClock
        mov     ds:[edi + 24H],eax

        ; set format
        mov     eax,dword ptr es:[ebx].MODEOUT.dwFormat
        mov     ds:[edi + 28H],eax

        ; set image offset and pitch
        mov     eax,CHNRUN(VideoLutCursorDac.SetImage.dwdwOffset,2)
        mov     edx,dwImageOffset
        mov     ds:[edi + 2CH],eax
        mov     ds:[edi + 30H],edx
        mov     edx,dword ptr es:[ebx].MODEOUT.dwPitchInBytes
        mov     ds:[edi + 34H],edx
        mov     ds:[esi].HWCRTCCX.dwPanPitch,edx

        add     edi,38H
        SETPUTPTR ds,ecx,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier1.status>

SkipSet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetStopImage
;
; Purpose:      This routine gets called to send the StopImage method
;               to the VideoLutCursorDac class. This will blank the screen.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetStopImage, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipSet

        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     ecx,ds:[esi].HWCRTCCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ecx,eax

        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        SETDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier0.status>

        CHECKDMASPACE ds,ecx,edi,18H

        ; Set the object in a sub-channel.
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     ds:[edi + 00H],eax
        add     edx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 04H],edx

        ; Request a notifier
        mov     eax,CHNRUN(VideoLutCursorDac.Notify,1)
        mov     ds:[edi + 08H],eax
        mov     eax,NV07C_NOTIFY_WRITE_ONLY
        mov     ds:[edi + 0CH],eax
        
        ; Set StopImage.
        mov     eax,CHNRUN(VideoLutCursorDac.StopImage,1)
        mov     ds:[edi + 10H],eax
        mov     eax,NV07C_STOP_IMAGE_AS_SOON_AS_POSSIBLE
        mov     ds:[edi + 14H],eax

        add     edi,18H
        SETPUTPTR ds,ecx,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier0.status>

SkipSet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetPanOffset
;
; Purpose:      This routine sets the offset in video memory of the
;               first byte scanned out by this crtc for each frame.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         offset of HWCRTCCX
;               dwwPanOffset            offset into the screen surface
;                                       (not into video memory), of the
;                                       new panning position.
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetPanOffset, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwNewPanOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipPan

        mov     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,edx
        mov     ecx,ds:[esi].HWCRTCCX.pHWBoardCX

        push    dwNewPanOffset
        push    ds:[esi].HWCRTCCX.dwPanPitch
        push    ds:[ecx].HWBOARDCX.dwGdiDriverChannelID
        push    eax
        push    ds:[ecx].HWBOARDCX.dwDeviceNum
        push    edx
        call    FFP16 PTR lpfnNvSysUpdateImageOffsetFormat

SkipPan:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetGamma
;
; Purpose:      This is the hardware specific SetGamma routine.
;               Place the gamma passed in into the hardware.
;
; Arguments:
;               ds                      CXSel
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               pGammaRamp              ptr to 256 dwords of XBGR
;               dwFirstEntry            0-255 index of first entry to set
;               dwNumEntries            number of contiguous palette
;                                       indices to set
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetGamma, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   pGammaRamp
PARMD   dwFirstEntry
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     edi,pHWCrtcCXOffset
        or      edi,edi
        je      DoneIt

        ; First, copy the gamma table passed in
        mov     esi,pGammaRamp
        lea     edi,[edi].HWCRTCCX.dwGammaTable
        mov     eax,dwFirstEntry
        lea     esi,[esi][eax * 4]
        lea     edi,[edi][eax * 4]
        mov     ecx,dwNumEntries
@@:
        mov     eax,ds:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,4
        dec     ecx
        jne     @B

        push    pHWCrtcCXOffset
        pushd   OBJ_DMA_IN_SYSRAM_FOR_GAMMA
        push    dwFirstEntry
        push    dwNumEntries
        call    NV_SetColorMap

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetPalette
;
; Purpose:      This is the hardware specific SetGamma routine.
;               Place the gamma passed in into the hardware.
;
; Arguments:
;               ds                      CXSel
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               pPalette                ptr to 256 dwords of XBGR
;               dwFirstEntry            0-255 index of first entry to set
;               dwNumEntries            number of contiguous palette
;                                       indices to set
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetPalette, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   pPalette
PARMD   dwFirstEntry
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     edi,pHWCrtcCXOffset
        or      edi,edi
        je      DoneIt

        ; First, copy the gamma table passed in
        mov     esi,pPalette
        lea     edi,[edi].HWCRTCCX.dwPaletteTable
        mov     eax,dwFirstEntry
        lea     esi,[esi][eax * 4]
        lea     edi,[edi][eax * 4]
        mov     ecx,dwNumEntries
@@:
        mov     eax,ds:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,4
        dec     ecx
        jne     @B

        push    pHWCrtcCXOffset
        pushd   OBJ_DMA_IN_SYSRAM_FOR_PALETTE
        push    dwFirstEntry
        push    dwNumEntries
        call    NV_SetColorMap

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetColorMap
;
; Purpose:      This routine sets a color map into the hardware.
;               It is called by both the set palette and set
;               gamma fcuntions.
;
; Arguments:
;               ds                      CXSel
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               object base to set      Should be either:
;                                       OBJ_DMA_IN_SYSRAM_FOR_PALETTE
;                                       OBJ_DMA_IN_SYSRAM_FOR_GAMMA
;               pColorMap               Ptr to a color map
;               dwFirstEntry            0-255 index of first entry to set
;               dwNumEntries            number of contiguous palette
;                                       indices to set
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetColorMap, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwBaseObjectID
PARMD   dwFirstEntry
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipSet

        mov     ebx,ds:[esi].HWCRTCCX.pHWBoardCX

        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Tell the hardware to load this color map
        CHECKDMASPACE ds,ebx,edi,1CH

        ; Set VideoLutCursorDac in a sub-channel
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     edx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],edx

        ; Set the correct color map object
        mov     eax,CHNRUN(VideoLutCursorDac.SetContextDmaLut,1)
        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     edx,dwBaseObjectID
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],edx

        ; Program the buffer offset for the color map.
        ; We have created a ContextDma just for the
        ; dwColorMap so the offset will be 0.
        mov     eax,CHNRUN(VideoLutCursorDac.SetLut,2)
        sub     edx,edx
        mov     ecx,NV049_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],edx
        mov     ds:[edi + 18H],ecx
        add     edi,1CH

        SETPUTPTR ds,ebx,edi
        sub     edi,ds:[ebx].HWBOARDCX.pPushBufferContextStartOffset
@@:
        cmp     ds:[ebx].HWBOARDCX.dwDmaGetPtr,edi
        jne     @B

SkipSet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsBandwidthOK
;
; Purpose:      This function checks to see whether the mode(s)
;               specified violate bandwidth requirements on the
;               display device.
;
; Arguments:
;               dwTotalWidth0           paramters for physical head 0
;               dwVisibleWidth0
;               dwTotalHeight0
;               dwVisibleHeight0
;               dwPixelDepth0
;               dwPixelClock0
;               dwRefreshRate0
;
;               dwTotalWidth1           parameters for physical head 1
;               dwVisibleWidth1
;               dwTotalHeight1
;               dwVisibleHeight1
;               dwPixelDepth1
;               dwPixelClock1
;               dwRefreshRate1
;
;               If the dwTotaldwWidth field is 0, then that head
;               is not being used.
;
; Returns:      eax     non-0   then bandwidth is OK
;                       0       then bandwidth is violated
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsBandwidthOK, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwTotaldwWidth0
PARMD   dwVisibledwWidth0
PARMD   dwTotalHeight0
PARMD   dwVisibleHeight0
PARMD   dwPixelDepth0
PARMD   dwPixelClock0
PARMD   dwRefreshRate0
PARMD   dwTotaldwWidth1
PARMD   dwVisibledwWidth1
PARMD   dwTotalHeight1
PARMD   dwVisibleHeight1
PARMD   dwPixelDepth1
PARMD   dwPixelClock1
PARMD   dwRefreshRate1
LOCALV  Params,NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        mov     Params.VidScalerHead,NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE

        mov     eax,dwTotaldwWidth0
        mov     Params.HeadActive0,eax
        or      eax,eax
        je      Skip0
        mov     Params.HeadActive0,-1
        mov     Params.TotaldwWidth0,eax
        mov     eax,dwVisibledwWidth0
        mov     Params.VisibledwWidth0,eax
        mov     eax,dwTotalHeight0
        mov     Params.TotalHeight0,eax
        mov     eax,dwVisibleHeight0
        mov     Params.VisibleHeight0,eax
        mov     eax,dwPixelDepth0
        mov     Params.PixelDepth0,eax
        mov     eax,dwPixelClock0
        mov     Params.PixelClock0,eax

        ; Isn't being used now
;       mov     Params.RefreshRate0,eax

Skip0:
        mov     eax,dwTotaldwWidth1
        mov     Params.HeadActive1,eax
        or      eax,eax
        je      Skip1
        mov     Params.HeadActive1,-1
        mov     eax,dwTotaldwWidth1
        mov     Params.TotaldwWidth1,eax
        mov     eax,dwVisibledwWidth1
        mov     Params.VisibledwWidth1,eax
        mov     eax,dwTotalHeight1
        mov     Params.TotalHeight1,eax
        mov     eax,dwVisibleHeight1
        mov     Params.VisibleHeight1,eax
        mov     eax,dwPixelDepth1
        mov     Params.PixelDepth1,eax
        mov     eax,dwPixelClock1
        mov     Params.PixelClock1,eax

        ; Isn't being used now
;       mov     Params.RefreshRate1,0

Skip1:
;       mov     Params.status;

        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS
        mov     ecx,NV_CFGEX_VALIDATE_BANDWIDTH
        call    NV_ConfigExCall

        ; Return success/fail in eax
        ; Status = 0 is Success, so flip the sense
        or      eax,eax
        mov     eax,1
        je      @F
        sub     eax,eax
@@:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapHWDeviceTypeToGNDeviceType
;
; Purpose:      This function maps the device type constants
;               MONITOR_XXXX defined in nvcm.h to the device type
;               constants defined in modeext.h.
;
; Arguments:    ecx     RM device type -- MONITOR_XXX
;
; Returns:      ecx     Modeset device constant -- DEVTYPE_XXXX
;
; Preserve:     everything except ecx
;==============================================================================
DECPROC HW_MapHWDeviceTypeToGNDeviceType, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,MONITOR_TYPE_FLAT_PANEL
        jbe     @F
        mov     ecx,MONITOR_TYPE_VGA
@@:     movzx   ecx,TableMonitorTypeRMToModeset[ecx]
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapGNDeviceTypeToHWDeviceType
;
; Purpose:      This function maps the device type constants
;               DEVTYPE_XXXX defined in modeext.h to the device type
;               constants MONITOR_XXXX defined in nvcm.h.
;
; Arguments:    ecx     Modeset device type -- DEVTYPE_XXX
;
; Returns:      ecx     RM device constant -- MONITOR_XXXX
;
; Preserve:     everythin except ecx
;==============================================================================
DECPROC HW_MapGNDeviceTypeToHWDeviceType, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,DEVTYPE_DFP
        jbe     @F
        mov     ecx,DEVTYPE_CRT
@@:     movzx   ecx,TableMonitorTypeModesetToRM[ecx]
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapHWTvFormatToGNTvFormat
;
; Purpose:      This function maps the Tv Format constants
;               NTSC_X and PAL_X defined in nvcm.h to the
;               Tv Format constants defined in modeext.h
;
; Arguments:    ecx     RM Tv Format -- NTSC_X and PAL_X
;
; Returns:      ecx     Modeset TV Format -- TVTYPE_XXX
;
; Preserve:     everything except ecx
;==============================================================================
DECPROC HW_MapHWTvFormatToGNTvFormat, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,KNOWN_TV_FORMATS
        jbe     @F
        mov     ecx,NTSC_M
@@:     movzx   ecx,TableTvFormatRMToModeset[ecx]
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapGNTvFormatToHWTvFormat
;
; Purpose:      This function maps the Tv Format constants
;               TVTYPE_XXXX defined in modeext.h to the TV Format
;               constants NTSC_X and PAL_X defined in nvcm.h.
;
; Arguments:    ecx     Modeset Tv Format -- TVTYPE_XXX
;
; Returns:      ecx     RM Tv Format -- NTSC_X and PAL_X
;
; Preserve:     everything except ecx
;==============================================================================
DECPROC HW_MapGNTvFormatToHWTvFormat, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,TVTYPE_PALNC
        jbe     @F
        mov     ecx,TVTYPE_NTSCM
@@:     movzx   ecx,TableTvFormatModesetToRM[ecx]
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCUR32.ASM ===
;==============================================================================
;
; Copyright (C) 1997, Nvidia Coporation
;
; File:         hwcursor.asm
;
; Purpose:      This file implements the hardware specific code to
;               support the cursor.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

XOR_IS_OK       TEXTEQU <1>

IF  (USE_ALPHA_CURSOR NE 0)

OPENSEG  _DATA, USE16, DATA
PUBLIC  szNVDisplayKey
szNVDisplayKey  DB      NV4_REG_GLOBAL_BASE_PATH, '\'
                DB      NV4_REG_DISPLAY_DRIVER_SUBKEY, 0

PUBLIC  szCursorAlpha
szCursorAlpha   DB      NV4_REG_DRV_CURSOR_ALPHA, 0
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  dwEnableCursorShadow
dwEnableCursorShadow    DD      0

PUBLIC  dwConvert4bppTo32bpp
dwConvert4bppTo32bpp    LABEL   DWORD
        DD      00000000H, 00800000H, 00008000H, 00808000H
        DD      00000080H, 00800080H, 00008080H, 00C0C0C0H
        DD      00808080H, 00FF0000H, 0000FF00H, 00FFFF00H
        DD      000000FFH, 00FF00FFH, 0000FFFFH, 00FFFFFFH

PUBLIC  bConvert5bppTo8bpp
bConvert5bppTo8bpp      LABEL   BYTE
        DB    0,  10h,  18h,  20h,  28h,  30h,  38h,  40h
        DB  48h,  50h,  58h,  60h,  68h,  70h,  78h,  80h
        DB  88h,  90h,  98h, 0A0h, 0A8h, 0B0h, 0B8h, 0C0h
        DB 0C8h, 0D0h, 0D8h, 0E0h, 0E8h, 0F0h, 0F8h, 0FFh

PUBLIC  bConvert6bppTo8bpp
bConvert6bppTo8bpp      LABEL   BYTE
        DB    0,    8,  0Ch,  10h,  14h,  18h,  1Ch,  20h
        DB  24h,  28h,  2Ch,  30h,  34h,  38h,  3Ch,  40h
        DB  44h,  48h,  4Ch,  50h,  54h,  58h,  5Ch,  60h
        DB  64h,  68h,  6Ch,  70h,  74h,  78h,  7Ch,  80h
        DB  84h,  88h,  8Ch,  90h,  94h,  98h,  9Ch, 0A0h
        DB 0A4h, 0A8h, 0ACh, 0B0h, 0B4h, 0B8h, 0BCh, 0C0h
        DB 0C4h, 0C8h, 0CCh, 0D0h, 0D4h, 0D8h, 0DCh, 0E0h
        DB 0E4h, 0E8h, 0ECh, 0F0h, 0F4h, 0F8h, 0FCh, 0FFh


;==============================================================================
;
; Function:     HW_CursorSet8888
;
; Purpose:      This function places a cursor pattern in offscreen video
;               memory. It does not make this new pattern the active
;               cursor, nor should it change the state of the cursor
;               on/off. Remember that the cursor can be many different
;               color depths -- you need to convert it to the color
;               depth in which you store the cursor in video memory.
;
;               This routine in particular tries to set the cursor
;               using the 8888 format which has an alpha component.
;               The hardware is slightly broken with this cursor
;               on NV10 (which was the first noard to support 8888
;               format) and it is not always possible to do this
;               format. Basically, if the XOR mask is used to invert
;               a pixel, the cursor is not doable on NV10.
;
;               Hence, this routine can fail.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwCursorCacheSlot       0 based cache slot
;               pCursorDesc             CURSORDESC ptr
;
; Returns:
;               eax                     0       Failure
;                                       non-0   Success
;               ebx     If eax indicates success, then this is a value
;                       that the hardware needs cached with the cursor
;                       information.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorSet8888, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwCursorCacheSlot
PARMD   pCursorDesc
LOCALD  dwCursorHWType
OPENPROC
        PUSHR   esi,edi
        mov     ebx,pHWCrtcCXOffset
        mov     edx,ds:[ebx].HWCRTCCX.pHWBoardCX

        ; Get a ptr to the place to store the cursor pattern.
        mov     edi,dwCursorCacheSlot
        imul    edi,HW_CURSOR_SIZE
        add     edi,ds:[edx].HWBOARDCX.pVideoMemory
        add     edi,ds:[ebx].HWCRTCCX.dwCursorCacheVramOffset
        mov     esi,pCursorDesc
        mov     dwCursorHWType,NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8

        ; Dispatch to the routine to copy/convert the cursor
        ; pattern to the hardware format and store it in vidmem.
        push    OFFSET Ret8888
        mov     al,ds:[esi].CURSORDESC.bBitsPerPixel
        cmp     al,01H
        je      SetCursor_1Bpp_8888
        cmp     al,10H
        je      SetCursor_16Bpp_8888
        cmp     al,20H
        je      SetCursor_32Bpp_8888
        cmp     al,04H
        je      SetCursor_4Bpp_8888
        cmp     al,18H
        je      SetCursor_24Bpp_8888
        cmp     al,0FH
        je      SetCursor_15Bpp_8888
        cmp     al,08H
        je      SetCursor_8Bpp_8888

        ; 21H bits/pixel is a DEBUG only thing. It allows for playing
        ; around with the alpha. The cursor depth is really 32bpp.
        ; We just say it is 33bpp as a flag.
        cmp     al,21H
        je      SetCursor_3XBpp_8888

        ; 22H bits/pixel is a DEBUG only thing. It allows for playing
        ; around with premultipliedalpha. The cursor depth is really
        ; 32bpp. We just say it is 34bpp as a flag.
        mov     dwCursorHWType,NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8
        cmp     al,22H
        je      SetCursor_3XBpp_8888
        pop     eax
        sub     eax,eax
        jmp     SetDone

Ret8888:
        or      eax,eax
        sete    al
        movzx   eax,al
        mov     ebx,dwCursorHWType
SetDone:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_1Bpp_8888
;
; Purpose:      This function places a 1Bpp cursor pattern in
;               offscreen video memory converting it to the
;               hardware format on the fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Returns:
;               eax                     0       Failure
;                                       non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_1Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
LOCALD  dwAlpha1
LOCALD  dwAndMaskSize
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,16                         ; E:AX = alpha_shadow:alpha_cursor:0
        mov     [dwAlpha1],eax                 ; Save shadow alpha value
        shl     eax,8                          ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        shr     ecx,3                          ; CX = bytes in the AND mask
        mov     [dwAndMaskSize],ecx
        mov     ebx,ecx                        ; EBX = AndMaskSize
        shr     ecx,2                          ; CL = dwords of pixel data
        lea     esi,[esi].CURSORDESC.bCursorAndMask

IF      (XOR_IS_OK EQ 0)
        ; Check for any inverted pixels in the cursor.
        ; You can tell this because the AND mask and the XOR mask
        ; are both non-0 at the same pixel.
        ; If there are none, then we can use alpha.
        ; Otherwise, we must use ROP555 format (no alpha).
        mov     edx,esi
Check_XOR_Loop:
        mov     eax,ds:[edx]                   ; EAX = 32 bits of AND mask
        and     eax,ds:[edx + ebx]             ; EAX = 32 bits of pixel data AND mask
        jnz     SetCursorFail                  ; Ooops, there is an XOR, must use ROP555
        add     edx,4
        dec     ecx
        jnz     Check_XOR_Loop
ENDIF

        ; Set the cursor into video memory.
        mov     ecx,ebx                        ; ECX = bytes of pixel data
        shr     ecx,2                          ; CL = dwords of pixel data
Next_Dword:
        mov     ebx,[dwAndMaskSize]
        mov     eax,ds:[esi]                   ; EAX = 32 bits of AND mask
        mov     ebx,ds:[esi + ebx]             ; EBX = 32 bits of pixel data
        add     esi,4                          ; Src ptr++
        mov     ch,32                          ; 32 pixels per dword
        bswap   eax
        bswap   ebx

        ; On any bit which is not transparent (i.e. which is part of
        ; the actual cursor image), add in the alpha value.
Cont_Dword:
        add     ebx,ebx                        ; Carry = SHL pixel data
        sbb     edx,edx                        ; DX == 0000 or FFFF
        and     edx,00FFFFFFh                  ; Set alpha = 0
        add     eax,eax                        ; Carry = SHL AND mask
        jnc     @F
        or      edx,edx
        je      NoAlfa
        sub     edx,edx
@@:     add     edx,[dwAlpha]
NoAlfa: mov     ds:[edi],edx                   ; Save the two pixels
        add     edi,4                          ; Increment the destination
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword

        xor     eax, eax                        ; Return success
SetCursorFail:                                  ; Return failure (EAX != 0)
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_4Bpp_8888
;
; Purpose:      This function places a 4Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Returns:
;               eax                     0       Failure
;                                       non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_4Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of pixel data

Next_Row:
        ; 4bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; DS:ESI next row of AND mask
        mov     ch,(32 / 2)                    ; CH is bytes to handle
        bswap   edx                            ; Roll the bits off the left

Cont_Row:
        movzx   eax,byte ptr ds:[ebx]          ; EAX = 000000:XX two pixels
        shr     eax,4                          ; EAX = 1 nibble of pixel data
        mov     eax,cs:dwConvert4bppTo32bpp[eax * 4]  ; EAX = converted pixel
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlf0
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlf0: mov     ds:[edi],eax                   ; Save the pixel

        movzx   eax,byte ptr ds:[ebx]          ; E:A:X = 000000:XX two pixels of cursor data
        inc     ebx                            ; DS:EBX -> cursor pixel data++
        and     eax,0FH                        ; EAX   = 1 nibble of pixel data
        mov     eax,cs:dwConvert4bppTo32bpp[eax * 4]   ; EAX = converted pixel
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlf1
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlf1: mov     ds:[edi+4],eax                 ; Save the pixel

        add     edi,8                          ; Increment the destination
        dec     ch                             ; Decrement the loops on this DWORD (EDX)
        jne     Cont_Row
        dec     cl                             ; Decrement the DWORD count
        jne     Next_Row

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_8Bpp_8888
;
; Purpose:      This function places a 8Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_8Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
LOCALB  bColumn
LOCALB  bRow
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   eax,ds:[esi].CURSORDESC.wHeight
        imul    ax,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     eax,3                          ; AX = bytes in the AND mask
        lea     ecx,[ebx].HWCRTCCX.dwPaletteTable
        lea     ebx,[esi + eax]                ; DS:EBX -> cursor pixel data
        shr     eax,2                          ; AL = dwords of mask data
        mov     [bRow],al

Next_Dword:
        ; 8bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; DS:ESI next byte of AND mask
        mov     [bColumn],32                   ; Prepare to handle one dword
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   eax,byte ptr ds:[ebx]          ; E:A:X = 0000:00:XX one pixel
        inc     ebx                            ; Next src pixel
        mov     eax,ds:[ecx][eax * 4]          ; EAX   = XRGB for 8bpp pixel
        and     eax,000FFFFFFh                 ; Clear alpha
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlfa
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlfa: mov     ds:[edi],eax                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_15Bpp_8888
;
; Purpose:      This function places a 15Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_15Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALB  bColumn
LOCALB  bRow
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     eax,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data
        mov     [bRow],cl
        sub     ebx,ebx

Next_Dword:
        ; 15bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     [bColumn],32                   ; Prepare to handle one dword
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   ecx,word ptr ds:[eax]          ; CX = next pixel
        add     eax,2                          ; Next src pixel
        mov     bl,cl
        shl     ecx,3                          ; Save Red and Green
        and     bl,01Fh                        ; Get Blue 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; green to low, blue to high
        mov     bl,cl                          ; BL = some red & green
        shl     cx,3                           ; CH = red
        and     bl,01Fh                        ; Get Green 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; red to low, green to high
        mov     bl,cl
        and     bl,01Fh                        ; Get Red 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,10H                        ; E:CX = R:G:B:0
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      ecx,ecx
        je      NoAlfa
        sub     ecx,ecx
@@:	add     ecx,[dwAlpha]
NoAlfa: mov     ds:[edi],ecx                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_16Bpp_8888
;
; Purpose:      This function places a 16Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_16Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALB  bColumn
LOCALB  bRow
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     eax,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data
        mov     [bRow],cl
        sub     ebx,ebx

Next_Dword:
        ; 16bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     [bColumn],32                   ; 32 pixels per scanline
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   ecx,word ptr ds:[eax]          ; CX = next pixel
        add     eax,2                          ; Next src pixel
        mov     bl,cl
        shl     ecx,3                          ; Save Red and Green
        and     bl,01Fh                        ; Get Blue 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; green to low, blue to high
        mov     bl,cl                          ; BL = some red & green
        shl     cx,2                           ; CH = red
        and     bl,03Fh                        ; Get Green 5bpp
        mov     cl,cs:bConvert6bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; red to low, green to high
        mov     bl,cl
        and     bl,01Fh                        ; Get Red 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,10H                        ; E:CX = R:G:B:0
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      ecx,ecx
        je      NoAlfa
        sub     ecx,ecx
@@:	add     ecx,[dwAlpha]
NoAlfa: mov     ds:[edi],ecx                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_24Bpp_8888
;
; Purpose:      This function places a 24Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_24Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     ch,32                          ; 32 pixels per scan
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        xor     eax,eax                        ; EAX = 0:0:0:0
        mov     al,ds:[ebx + 2]                ; EAX = 0:0:0:R
        shl     eax,16                         ; EAX = 0:R:0:0
        mov     ax,ds:[ebx]                    ; EAX = 0:R:G:B
        add     ebx,3                          ; Next src pixel
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlfa
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlfa: mov     ds:[edi],eax                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_32Bpp_8888
;
; Purpose:      This function places a 32Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_32Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     ch,32                          ; 32 pixels per scan
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        mov     eax,ds:[ebx]                   ; EAX = X:R:G:B
        add     ebx,4                          ; Next src pixel
        and     eax,00FFFFFFh                  ; EAX = 0:R:G:B
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlfa
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlfa: mov     ds:[edi],eax                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_3XBpp_8888
;
; Purpose:      This function places a 32Bpp ARGB cursor pattern in
;               offscreen video memory converting it to the hardware
;               format on the fly.  This is a nonstandard format that
;               is for testing only. The AND mask is ignored.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_3XBpp_8888, PASCAL, FRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shl     ecx,3                          ; ECX = bytes of mask data

Next_Dword:
        mov     eax,ds:[ebx]                   ; EAX = X:R:G:B
        add     ebx,4                          ; Next src pixel
        mov     ds:[edi],eax                   ; Store the new pixel
        add     edi,4                          ; Next dst pixel
        dec     ecx
        jne     Next_Dword
        xor     eax,eax                        ; Return success
CLOSEPROC

CLOSESEG _NVTEXT32

ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCURSOR.ASM ===
;==============================================================================
;
; Copyright (C) 1997, Nvidia Coporation
;
; File:         hwcursor.asm
;
; Purpose:      This file implements the hardware specific code to
;               support the cursor.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  dwAlphaCursorsEnabled
dwAlphaCursorsEnabled   DD      0

; These are shifted left to shift the alpha bit into the MSB
PUBLIC  wConvert4bppTo15bpp
wConvert4bppTo15bpp     LABEL   WORD
        DW      0000H SHL 1,    4000H SHL 1,    0200H SHL 1,    4200H SHL 1
        DW      0010H SHL 1,    4010H SHL 1,    0210H SHL 1,    6318H SHL 1
        DW      4210H SHL 1,    7C00H SHL 1,    03E0H SHL 1,    7FE0H SHL 1
        DW      001FH SHL 1,    7C1FH SHL 1,    03FFH SHL 1,    7FFFH SHL 1


;==============================================================================
;
; Function:     HW_CursorEnable
;
; Purpose:      This function will turn the cursor on or off as specified
;               by the enable argument.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwEnable                0 then turn cursor off
;                                       non-0 then turn cursor on
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorEnable_FAR32, PASCAL, FRAME, FAR32, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwEnable
OPENPROC
        push    pHWCrtcCXOffset
        push    dwEnable
        call    HW_CursorEnable
CLOSEPROC

DECPROC HW_CursorEnable, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwEnable
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt
        mov     eax,ds:[ebx].HWCRTCCX.pHWBoardCX
        cmp     dwEnable,1
        sbb     ecx,ecx
        and     ecx,NV_CURSOR_DISABLE - NV_CURSOR_ENABLE
        add     ecx,NV_CURSOR_ENABLE
        or      ecx,NV_CURSOR_SET_ENABLE
        push    ecx
        push    ecx
        push    ecx
        push    ecx
        pushd   0
        push    ds:[eax].HWBOARDCX.dwDeviceNum
        push   ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
        call    FFP16 PTR lpfnNvSysSetCursorImage
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     HW_CursorSet
;
; Purpose:      This function places a cursor pattern in offscreen video
;               memory. It does not make this new pattern the active
;               cursor, nor should it change the state of the cursor
;               on/off. Remember that the cursor can be many different
;               color depths -- you need to convert it to the color
;               depth in which you store the cursor in video memory.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwCursorCacheSlot       0 based cache slot
;               pCursorDesc             CURSORDESC ptr
;
; Returns:
;               eax                     Any piece of data the hardware
;                                       wants passed back in on other
;                                       calls ....
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorSet, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwCursorCacheSlot
PARMD   pCursorDesc
LOCALD  dwCursorHWType
OPENPROC
        PUSHR   esi,edi
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt

        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX

IF  (USE_ALPHA_CURSOR NE 0)
        ; If this is at least an NV10, then we can try to use alpha
        cmp     ds:[ecx].HWBOARDCX.dwDeviceVersion,NV_DEVICE_VERSION_10
        jl      Is1555Cursor

        ; Revision BX MUST use the 32bit cursor beause of the DFP
        ; downscale dither using the 16bpp cursor cycles
        mov     eax,ds:[ecx].HWBOARDCX.dwDeviceRevision
        and     eax,0F0H
        cmp     eax,0B0H
        jne     Is1555Cursor

        ; Try to set an 8888 cursor.
        push    pHWCrtcCXOffset
        push    dwCursorCacheSlot
        push    pCursorDesc
        call    HW_CursorSet8888
        mov     dwCursorHWType,ebx
        
        or      eax,eax
        jne     SetRet

Is1555Cursor:
        mov     ebx,pHWCrtcCXOffset
        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX
ENDIF

        ; Get a ptr to the place to store the cursor pattern, and then
        ; call the correct routine to convert the incoming cursor
        ; pattern to the hardware format and store it in vram.
        mov     edi,dwCursorCacheSlot
        imul    edi,HW_CURSOR_SIZE
        add     edi,ds:[ecx].HWBOARDCX.pVideoMemory
        add     edi,ds:[ebx].HWCRTCCX.dwCursorCacheVramOffset
        mov     esi,pCursorDesc
        mov     dwCursorHWType,NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5

        push    OFFSET SetRet
        mov     al, ds:[esi].CURSORDESC.bBitsPerPixel
        cmp     al,01H
        je      SetCursor_1Bpp_1555
        cmp     al,10H
        je      SetCursor_16Bpp_1555
        cmp     al,20H
        je      SetCursor_32Bpp_1555
        cmp     al,04H
        je      SetCursor_4Bpp_1555
        cmp     al,18H
        je      SetCursor_24Bpp_1555
        cmp     al,0FH
        je      SetCursor_15Bpp_1555
        cmp     al,08H
        je      SetCursor_8Bpp_1555
        pop     eax

SetRet:
DoneIt:        
                mov     eax,dwCursorHWType
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_CursorSelect
;
; Purpose:      This function will select one of the cached cursors
;               to be the currently active cursor. It should not change
;               the state of the cursor on/off.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwCursorCacheSlot       0 based cache slot
;               dwCursorHWType          returned from HW_CursorSet
;               pCursorDesc             CURSORDESC ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorSelect, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwCursorCacheSlot
PARMD   dwCursorHWType
PARMD   pCursorDesc
OPENPROC
        PUSHR   esi
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt
        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX

        mov     eax,dwCursorCacheSlot
        imul    eax,HW_CURSOR_SIZE
        add     eax,ds:[ebx].HWCRTCCX.dwCursorCacheVramOffset
        mov     esi,ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
        mov     ebx,pCursorDesc

        ; Call the RM to select the correct cursor
        pushd   NV_CURSOR_SET_PARAM
        push    eax                                     ; Cursor Offset
        movzx   edx,ds:[ebx].CURSORDESC.wWidth
        push    edx
        movzx   edx,ds:[ebx].CURSORDESC.wHeight
        push    edx
        push    dwCursorHWType
        push    ds:[ecx].HWBOARDCX.dwDeviceNum
        push   esi
        call    FFP16 PTR lpfnNvSysSetCursorImage
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_CursorMove
;
; Purpose:      This function should move the cursor to the location
;               specified. Do not change the on/off state of the cursor.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwYCoordHiXCoordLo      Ycoord:XCoord
;               dwYSpotHiXSpotLo        HotSpotY:HotSpotX (0-63:0-63)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorMove, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwYCoordHiXCoordLo
PARMD   dwYSpotHiXSpotLo
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt
        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX

        mov     eax,dwYCoordHiXCoordLo
        sub     ax,word ptr dwYSpotHiXSpotLo
        ror     eax,10H
        sub     ax,word ptr dwYSpotHiXSpotLo + 2
        push    eax
        push    ds:[ecx].HWBOARDCX.dwDeviceNum
        push    ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
        call    FFP16 PTR lpfnNvSysMoveCursor
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_1Bpp_1555
;
; Purpose:      This function places a 1Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_1Bpp_1555, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAndMaskSize
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        shr     ecx,3                          ; CX = bytes in the AND mask
        mov     [dwAndMaskSize],ecx
        shr     ecx,2                          ; CL = dwords of pixel data
        lea     esi,[esi].CURSORDESC.bCursorAndMask

Next_Dword:
        mov     ebx,[dwAndMaskSize]
        mov     eax,ds:[esi]                   ; EAX = 32 bits of AND mask
        mov     ebx,ds:[esi + ebx]             ; EBX = 32 bits of pixel data
        add     esi,4                          ; Src ptr++
        not     eax
        mov     ch,16                          ; One dword takes 16 passes
        bswap   eax
        bswap   ebx

Cont_Dword:
        add     ebx,ebx                        ; Carry = SHL pixel data
        sbb     dx,dx                          ; DX == 0000 or FFFF
        add     eax,eax                        ; Carry = SHL AND mask
        rcr     dx,1                           ; MSB of DX == ROP
        ror     edx,10H                        ; Save in the high word of EDX
        add     ebx,ebx                        ; Carry = SHL pixel data
        sbb     dx,dx                          ; DX == 0000 or FFFF
        add     eax,eax                        ; Carry = SHL AND mask
        rcr     dx,1                           ; MSB of DX == ROP
        ror     edx,10H                        ; Rstore the order of the 2 pixels
        mov     ds:[edi],edx                   ; Save the two pixels
        add     edi,4                          ; Increment the destination
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_4Bpp_1555
;
; Purpose:      This function places a 4Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_4Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; EBX = ptr to pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        ; 4bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; increment AND mask pointer
        not     edx
        mov     ch,(32/2)                      ; 16 pairs of 4bpp pixels per 32 bit AND
        bswap   edx

        ; This loop decodes one dword of AND mask,
        ; 32 pixel or 16 bytes of pixel data
Cont_Dword:
        movzx   eax,byte ptr ds:[ebx]
        shr     eax,4                          ; EAX = first 4bpp pixel in byte
        mov     ax,cs:wConvert4bppTo15bpp[eax * 2]
        add     edx,edx                        ; Put AND bit in CARRY
        rcr     ax,1                           ; Put AND bit in MSB of AX
        mov     ds:[edi],ax                    ; Save the 16bpp pixel
        movzx   eax,byte ptr ds:[ebx]
        inc     ebx                            ; Increment pixel pointer
        and     eax,0FH                        ; second 4bpp pixel in byte
        mov     ax,cs:wConvert4bppTo15bpp[eax * 2]
        add     edx,edx                        ; Put AND bit in CARRY
        rcr     ax,1                           ; Put AND bit in MSB of AX
        mov     ds:[edi+2],ax                  ; Save the 16bp pixel
        add     edi,4                          ; Increment the destination
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_8Bpp_1555
;
; Purpose:      This function places a 8Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_8Bpp_1555, PASCAL, FRAME, NEAR, LOGOFF
LOCALB  bColumn
LOCALB  bRow
OPENPROC
        movzx   eax,ds:[esi].CURSORDESC.wHeight
        imul    ax,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     eax,3                          ; AX = bytes in the AND mask
        lea     ebx,[ebx].HWCRTCCX.dwPaletteTable
        lea     ecx,[esi + eax]                ; DS:ECX -> cursor pixel data
        shr     eax,2                          ; AL = dwords of mask data
        mov     [bRow],al

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     [bColumn],32                   ; Prepare to handle one dword
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   eax,byte ptr ds:[ecx]          ; E:A:X = 0000:00:XX one pixel
        inc     ecx                            ; Next src pixel
        mov     eax,ds:[ebx][eax * 4]          ; EAX   = XRGB for 8bpp pixel
        shr     eax,3                          ; Convert to 5 bits of blue
        ror     eax,5                          ; EAX = 5B:X:8R:8G
        shr     ax,3                           ; EAX = 5B:X:8R:5G
        ror     eax,5                          ; EAX = 5G:5B:X:8R
        shr     ax,3                           ; EAX = 5G:5B:X:5R
        rol     eax,10                         ; AX  = X:5R:5G:5B
        add     ax,ax                          ; AX  = 5R:5G:5B:0
        add     edx,edx                        ; Carry <= SHL AND mask
        rcr     ax,1                           ; AX  = A:5R:5G:5B
        mov     ds:[edi],ax                    ; Store the new pixel
        add     edi,2                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_15Bpp_1555
;
; Purpose:      This function places a 15Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_15Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx, ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,(32 / 2)                    ; 2 pixels per iteration
        bswap   edx

Cont_Dword:
        mov     ax,ds:[ebx]                    ; AX = 1 pixel data
        add     ebx,2
        add     ax,ax
        add     edx,edx
        rcr     ax,1
        ror     eax,10H                        ; E:AX = A555:0000
        mov     ax,ds:[ebx]                    ; AX = 1 pixel data
        add     ebx,2
        add     ax,ax
        add     edx,edx
        rcr     ax,1
        ror     eax,10H                        ; E:AX = Pixel2:Pixel1
        mov     ds:[edi],eax                   ; Save both pixels
        add     edi,4                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_16Bpp_1555
;
; Purpose:      This function places a 16Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_16Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx, ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,32                          ; Handle 1 pixel per iteration
        bswap   edx

Cont_Dword:
        movzx   eax,word ptr ds:[ebx]          ; Get one pixel
        add     ebx,2                          ; Increment source pointer
        ror     eax,5
        shr     ax,1
        rol     eax,5
        add     ax,ax
        add     edx,edx
        rcr     ax,1
        mov     ds:[edi],ax                    ; Save pixel
        add     edi,2                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_24Bpp_1555
;
; Purpose:      This function places a 24Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_24Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,32                          ; 1 pixel per iteration
        bswap   edx

Cont_Dword:
        mov     al,ds:[ebx+2]
        shl     eax,10H
        mov     ax,ds:[ebx]                    ; EAX = 24 bpp pixel
        add     ebx,3                          ; Increment source pointer
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,11                         ; AX = 555X pixel
        add     edx,edx
        rcr     ax,1                           ; AX = R555
        mov     ds:[edi],ax                    ; Save pixel
        add     edi,2                          ; Next dst pixel
        dec     ch
        jg      Cont_Dword
        dec     cl
        jg      Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_32Bpp_1555
;
; Purpose:      This function places a 32Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_32Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        ; 32bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,32                          ; Handle 1 pixel per iteration
        bswap   edx

Cont_Dword:
        mov     eax,ds:[ebx]                   ; EAX = 32 bpp pixel
        add     ebx,4                          ; Increment source pointer
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,11                         ; AX = 555X
        add     edx,edx
        rcr     ax,1                           ; AX = R555
        mov     ds:[edi],ax                    ; Save pixel
        add     edi,2
        dec     ch
        jg      Cont_Dword
        dec     cl
        jg      Next_Dword
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLINE.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwline.asm
;
; Purpose:      This file implements the hardware specific Polyline function.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incFont     = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bRop2ToSrc3
bRop2ToSrc3     LABEL   BYTE
DB      000H,   011H,   022H,   033H
DB      044H,   055H,   066H,   077H
DB      088H,   099H,   0AAH,   0BBH
DB      0CCH,   0DDH,   0EEH,   0FFH
DB      000H,   011H,   022H,   033H
DB      044H,   055H,   066H,   077H
DB      088H,   099H,   0AAH,   0BBH
DB      0CCH,   0DDH,   0EEH,   0FFH

PUBLIC  dwLineStyle
dwLineStyle     LABEL   DWORD
DD      000000000H      ; LS_SOLID
DD      00000FF00H      ; LS_DASHED
DD      00F0F0F0FH      ; LS_DOTTED
DD      00FF0FF00H      ; LS_DOTDASHED
DD      00F0F0F00H      ; LS_DASHDOTDOT
DD      000000000H      ; LS_SOLID
DD      000FF0000H      ; LS_DASHED
DD      0F0F0F0F0H      ; LS_DOTTED
DD      000FF0FF0H      ; LS_DOTDASHED
DD      000F0F0F0H      ; LS_DASHDOTDOT
DD      000000000H      ; LS_SOLID
DD      000FF0000H      ; LS_DASHED
DD      0F0F0F0F0H      ; LS_DOTTED
DD      00FF000FFH      ; LS_DOTDASHED
DD      0F0F0F000H      ; LS_DASHDOTDOT

PUBLIC  dwMultiPassSafe
dwMultiPassSafe LABEL   DWORD  ; Rop3  Reverse Polish
DD      1               ; Rop2 =  00   0
DD      0               ; Rop2 =  11   DSon
DD      1               ; Rop2 =  22   DSna
DD      1               ; Rop2 =  33   Sn
DD      0               ; Rop2 =  44   SDna
DD      0               ; Rop2 =  55   Dn
DD      0               ; Rop2 =  66   DSx
DD      0               ; Rop2 =  77   DSan
DD      1               ; Rop2 =  88   DSa
DD      0               ; Rop2 =  99   DSxn
DD      1               ; Rop2 =  AA   D
DD      1               ; Rop2 =  BB   DSno
DD      1               ; Rop2 =  CC   S
DD      0               ; Rop2 =  DD   SDno
DD      1               ; Rop2 =  EE   DSo
DD      1               ; Rop2 =  FF   1

;==============================================================================
;
; Function:     HW_Polyline
;
; Purpose:      This is the hardware specific Polyline routine.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEV ptr
;               gs:esi                  lpDstDev ptr
;               lpPoints                list of points
;               dwCount                 Number of points in list lpPoints
;                                       Lines should be drawn between the
;                                       first and second pair of points,
;                                       the second and third pair, the
;                                       third and fourth, etc.  Hence,
;                                       you will draw dwCount - 1 lines.
;               dwPenColor              Line Color
;               dwRop2                  Rop 2 -- from 00H to 0FH inclusive
;               wClipBottom             These four values define the clip
;               wClipRight              rectangle. If wClipLeft equals -1,
;               wClipTop                there is no clip rectangle. The
;               wClipLeft               clip rect is validated by the
;                                       generic code.
;
; Returns:
;               eax     0       punt call to the DIBENG
;                       > 0     the call succeeded
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_Polyline, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   lpPoints
PARMD   dwCount
PARMD   dwPenColor
PARMD   dwBkColor
PARMD   dwRop
PARMD   dwStyle
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
LOCALD  dwCountCopy
LOCALD  pHWBoardCXOffset
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     pHWBoardCXOffset,ebx
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; The global clip rect must be set if lpClipRect is not NULL
        cmp     wClipLeft,-1
        je      @F
        CHECKDMASPACE ds,ebx,edi,0CH
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        mov     ecx,dword ptr wClipLeft
        mov     edx,dword ptr wClipRight
        sub     edx,ecx
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        add     edi,0CH
@@:
        ; Set the rop and then the color
        CHECKDMASPACE ds,ebx,edi,34H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]

        mov     eax,dwRop
        mov     ebx,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,cs:bRop2ToSrc3[eax]
        mov     ds:[edi + 0CH],ebx
        mov     ds:[edi + 10H],ecx

        ; Must set the line object in the sub-channel
        mov     eax,CHNRUN(RenderSolidLinHdr.object,1)
        mov     ecx,OBJ_SOLID_LINE
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx
        mov     ebx,pHWLogdevCXOffset
        mov     eax,CHNRUN(RenderSolidLin.SetColorFormat,2)
        mov     edx,ds:[ebx].HWLOGDEVCX.dwSolidLinColorFormat
        mov     ecx,dwPenColor
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],edx
        mov     ds:[edi + 24H],ecx

        ; Blast in the first pair of points
        sub     esi,esi
        les     si,lpPoints
        mov     eax,CHNRUN(RenderSolidLin.Lin.point0,2)
        mov     ecx,es:[esi]
        mov     edx,es:[esi + 4]
        add     esi,8
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ecx
        mov     ds:[edi + 30H],edx
        add     edi,34H

        ; If we are done, then get out. Otherwise wait for space.
        ; We can draw 20H lines with one header and we have already
        ; used the first two points to draw the first line. Hence
        ; the number of dwords of space we need is:
        ; 21H * (dwCount >> 5) + (dwCount AND 1FH) +
        ;       1 (if (dwCount AND 1FH) != 0)
        mov     ecx,dwCount
        sub     ecx,2
        jle     Next
        mov     edx,ecx
        mov     ebx,ecx
        shr     edx,5
        and     ebx,1FH
        imul    eax,edx,(21H * 4)
        sub     ecx,ecx
        cmp     ebx,1
        sbb     ecx,-1
        add     ecx,ebx
        lea     eax,[eax][ecx * 4]
        mov     ecx,pHWBoardCXOffset
        CHECKDMASPACE ds,ecx,edi,eax

        ; There are edx chunks of 20H lines to do
        or      edx,edx
        je      Parts
Big1:   mov     ecx,08H
        mov     dword ptr ds:[edi],CHNRUN(RenderSolidLin.PolyLin,20H)
        add     edi,4
Small1: mov     eax,es:[esi]
        mov     ds:[edi],eax
        mov     eax,es:[esi + 04H]
        mov     ds:[edi + 04H],eax
        mov     eax,es:[esi + 08H]
        mov     ds:[edi + 08H],eax
        mov     eax,es:[esi + 0CH]
        mov     ds:[edi + 0CH],eax
        add     esi,10H
        add     edi,10H
        dec     ecx
        jne     Small1
        dec     edx
        jne     Big1

Parts:  ; There are ebx lines left to do
        or      ebx,ebx
        je      Next
        mov     ecx,ebx
        shl     ebx,10H + 2
        mov     bx,CHNRUN(RenderSolidLin.PolyLin,0)
        mov     ds:[edi],ebx
        add     edi,4
@@:     mov     eax,es:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,04H
        dec     ecx
        jne     @B
Next:
        ; Reset the clip rect if needed
        cmp     wClipLeft,-1
        je      Done
        mov     ecx,pHWBoardCXOffset
        CHECKDMASPACE ds,ecx,edi,0CH
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        sub     ecx,ecx
        mov     edx,07FFF7FFFH
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        add     edi,0CH
Done:
        mov     ebx,pHWBoardCXOffset
        SETPUTPTR ds,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_PolyStyledLine
;
; Purpose:      This is the hardware specific PolyStyledLine routine.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEV ptr
;               lpDstDev                lpDstDev ptr
;               lpPoints                list of points
;               dwCount                 Number of points in list lpPoints
;                                       Lines should be drawn between the
;                                       first and second pair of points,
;                                       the second and third pair, the
;                                       third and fourth, etc.  Hence,
;                                       you will draw dwCount - 1 lines.
;               dwPenColor              Line Color
;               dwRop2                  Rop 2 -- from 00H to 0FH inclusive
;               wClipBottom             These four values define the clip
;               wClipRight              rectangle. If wClipLeft equals -1,
;               wClipTop                there is no clip rectangle. The
;               wClipLeft               clip rect is validated by the
;                                       generic code.
;
; Returns:
;               eax     0       punt call to the DIBENG
;                       > 0     the call succeeded
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_PolyStyledLine, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   lpPoints
PARMD   dwCount
PARMD   dwPenColor
PARMD   dwBkColor
PARMD   dwRop
PARMD   dwStyle
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
LOCALD  dwDestLeft
LOCALD  dwDestRight
LOCALD  dwStyleOffset
LOCALD  dwHWStyle
LOCALD  dwLocalStyle
LOCALD  dwRet
LOCALD  pHWBoardCXOffset
OPENPROC
        cmp     word ptr dwCount,2
        je      @f

        ; We can't handle some rops that change if we render more than once.
        ; We need to be able to back out and fail to DIBENG if there are
        ; non-slope0 lines bury inside a long chain of polylines
        mov     eax,dwRop
        cmp     cs:dwMultiPassSafe[eax*4],1
        jne     Fail
@@:
        mov     ecx,gs:[esi].DIBENGINEHDR.deBitsOffset
        mov     edx,gs:[esi].DIBENGINEHDR.deDeltaScan
        xor     esi,esi
        les     si,lpPoints
        mov     eax,es:[esi]
        mov     ebx,es:[esi + 4]
        add     esi,4
        call    SETUPPATTERNHWFORSTYLELINE
        test    eax,eax
        jz      Fail

DoStyleLine:
        dec     word ptr dwCount
        mov     dwRet,1

        mov     ebx,pHWLogdevCXOffset
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0

        ; Sync to other contexts
        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     pHWBoardCXOffset,ebx
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        CHECKDSTBASE ds,ebx,edi,ecx,edx

        ; Set the pattern color even if it is not used
        CHECKDMASPACE ds,ebx,edi,0CH
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ds:[edi + 00H],eax
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        add     edi,0CH

DoNextLine:
        ; Check for space and program the blt
        mov     edx,pHWBoardCXOffset
        CHECKDMASPACE ds,edx,edi,44H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeShape,6)
        mov     ebx,dwHWStyle
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,dwPenColor
        mov     ecx,dwBkColor
        mov     edx,pHWLogdevCXOffset
        or      eax,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        or      ecx,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,dwLocalStyle
        mov     eax,cs:dwLineStyle[eax*4]
        mov     ecx,dwStyleOffset
        ror     eax,cl
        bswap   eax
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],eax
        mov     eax,dwRop
        movzx   ecx,cs:bConvertRop2ToRop3[eax]
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ecx
        xor     ecx,ecx
        mov     edx,7FFF7FFFH
        cmp     wClipLeft,-1
        je      @F
        mov     ecx,dword ptr wClipLeft
        mov     edx,dword ptr wClipRight
@@:
        mov     eax,pHWLogdevCXOffset
        mov     dword ptr ds:[edi + 24H],CHNRUN(RectAndText.SetColorFormat,1)
        mov     eax,ds:[eax].HWLOGDEVCX.dwSolidLinColorFormat
        mov     ds:[edi + 28H],eax

        mov     eax,CHNRUN(RectAndText.ClipPoint0B,5)
        mov     ds:[edi + 2CH],eax
        mov     ds:[edi + 30H],ecx
        mov     ds:[edi + 34H],edx
        mov     ecx,dwDestLeft
        mov     edx,dwDestRight
        ; The color field next is irrelevant but NV architecture requires it
        mov     ds:[edi + 38H],eax
        mov     ds:[edi + 3CH],ecx
        mov     ds:[edi + 40H],edx
        add     edi,44H
        dec     word ptr dwCount
        jle     CleanUp
        mov     eax,es:[esi]
        mov     ebx,es:[esi + 4]
        add     esi,4
        push    edi
        call    SETUPPATTERNHWFORSTYLELINE
        pop     edi
        test    eax,eax
        jnz     DoNextLine
        mov     dwRet,eax

CleanUp:
        mov     edx,pHWBoardCXOffset
        CHECKDMASPACE ds,edx,edi,14H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeShape,4)
        mov     ebx,NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,-1
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],eax
        add     edi,14H
        SETPUTPTR ds,edx,edi
        mov     eax,dwRet
        jmp     Done
Fail:
        xor     eax,eax
Done:
CLOSEPROC


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SETUPPATTERNHWFORSTYLELINE
;
; This macro breaks down the input line into HW rectagular format.  The
; style offset of each start line is also computed and stored.
;
; dwDestLeft    line describes in HW rect (left, top)
; dwDestRight   line describes in HW rect (right, bottom)
; dwStyleOffset Offset to the pattern for starting pixel
; dwHWStyle     Format of the Style (x major or y major)
;
; Arguments:
;       eax     Point0 (x,y)
;       ebx     Point1 (x,y)
;
; Returns:
;       eax     0   Cannot convert.  The line is not a slope 0 line
;       eax     1   Success
;
PUBLIC  SETUPPATTERNHWFORSTYLELINE
SETUPPATTERNHWFORSTYLELINE      PROC    NEAR

        xor     edi,edi
        cmp     ax,bx
        jne     NotVerticalLine
        cmp     eax,ebx
        jle     VerticalForwardLine
        mov     edi,eax
        mov     eax,ebx
        mov     ebx,edi
        add     eax,10000H
        add     ebx,10001H
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        ror     eax,16
        dec     eax
        and     eax,31
        mov     edi,39
        sub     edi,eax
        mov     dwStyleOffset,edi
        mov     eax,5
        add     eax,dwStyle
        mov     dwLocalStyle,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_1X_64Y
        mov     dwHWStyle,eax
        jmp     Success1

VerticalForwardLine:
        inc     ebx
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        ror     eax,16
        and     eax,31
        mov     dwStyleOffset,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_1X_64Y
        mov     dwHWStyle,eax
        mov     eax,dwStyle
        mov     dwLocalStyle,eax
        jmp     Success1

NotVerticalLine:
        ror     eax,16
        ror     ebx,16
        cmp     ax,bx
        jne     Fail1
        cmp     eax,ebx
        jle     HorizontalForwardLine

        ;!!! Punt Horizontal Backward Styled Line to dibengine for now. Temporal fix for 33580.
        jmp     Fail1

        mov     edi,eax
        mov     eax,ebx
        mov     ebx,edi
        ror     eax,16
        ror     ebx,16
        inc     eax
        add     ebx,10001H
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        dec     eax
        and     eax,31
        mov     edi,41
        sub     edi,eax
        mov     dwStyleOffset,edi
        mov     eax,10
        add     eax,dwStyle
        mov     dwLocalStyle,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_64X_1Y
        mov     dwHWStyle,eax
        jmp     Success1

HorizontalForwardLine:
        inc     ebx
        ror     eax,16
        ror     ebx,16
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        and     eax,31
        mov     dwStyleOffset,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_64X_1Y
        mov     dwHWStyle,eax
        mov     eax,dwStyle
        mov     dwLocalStyle,eax

Success1:
        mov     eax,1
        jmp     Done1
Fail1:
        xor     eax,eax
Done1:
        ret

SETUPPATTERNHWFORSTYLELINE      ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLDPAT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwldpat.asm
;
; Purpose:      This file contains routines to load the different kinds
;               of patterns into the hardware when the patterns are
;               going to be used for 3operand blts or cases where there
;               might be xparency.
;
;==============================================================================
.586
incLogical = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_LoadSolidPattern
;
; Purpose:      This function is called by the generic code to load
;               up a solid pattern that will be used in a 3operand blt
;               or in a situation where xparency may be required.
;
; Arguments:
;               ds                      CXSel
;               ebx                     HWLOGDEVCX ptr
;               edx                     Solid Color
;
; Returns:      None
;
; Preserve:     ds,es,esi
;==============================================================================
DECPROC HW_LoadSolidPattern, PASCAL, NOFRAME, NEAR
OPENPROC
	mov	ecx,ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        or      edx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha0,edx
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha1,edx

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        CHECKDMASPACE ds,ebx,edi,18H
        mov     eax,CHNRUN(ContextPattern.SetColorFormat,1)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     eax,CHNRUN(ContextPattern.SetPatternSelect,3)
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],edx
        mov     ds:[edi + 14H],edx
        add     edi,18H

        mov     ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_LoadMonoPattern
;
; Purpose:      This function is called by the generic code to load
;               up a mono pattern that will be used in a 3operand blt
;               or in a situation where xparency may be required.
;
; Arguments:
;               ds                      CXSel
;               ebx                     HWLOGDEVCX ptr
;               es:esi                  ptr to pattern to use
;               ecx                     Color for 0 bits
;               edx                     Color for 1 bits
;               eax                     0 if 0 src bits should be skipped
;                                               (transparent mode)
;                                       -1 if 0 src bits should be expanded
;                                               and written (opaque mode)
; Returns:      None
;
; Preserve:     ds
;==============================================================================
DECPROC HW_LoadMonoPattern, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Hatch is similar to mono, except we have to worry about
        ; the possibility of the bg being xparent.
        or      edx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        or      ecx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        and     ecx,eax
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha0,ecx
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha1,edx
        push    edx
        push    ecx

        mov     eax,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,eax,ecx

        ; Load the push buffer ptr
        mov     edi,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset

        ; Get the pattern
        mov     cl,es:[esi + 08H]
        mov     dl,es:[esi + 18H]
        mov     ch,es:[esi + 0CH]
        mov     dh,es:[esi + 1CH]
        shl     ecx,10H
        shl     edx,10H
        mov     cl,es:[esi + 00H]
        mov     dl,es:[esi + 10H]
        mov     ch,es:[esi + 04H]
        mov     dh,es:[esi + 14H]

        ; Put code in here to set the mono or hatch pattern.
        ; ecx = 0 pattern bits map to this color
        ; edx = 1 pattern bits map to this color

        CHECKDMASPACE ds,eax,edi,20H
        mov	esi,ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetColorFormat,1)
        mov     ds:[edi + 04H],esi
        mov     dword ptr ds:[edi + 08H],CHNRUN(ContextPattern.SetPatternSelect,5)
        mov     dword ptr ds:[edi + 0CH],NV044_SET_PATTERN_SELECT_MONOCHROME
        pop     dword ptr ds:[edi + 10H]
        pop     dword ptr ds:[edi + 14H]
        mov     ds:[edi + 18H],ecx
        mov     ds:[edi + 1CH],edx
        add     edi,20H

        mov     ds:[eax].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_LoadColorPattern
;
; Purpose:      This function is called by the generic code to load
;               up a color pattern that will be used in a 3operand blt
;               or in a situation where xparency may be required.
;
; Arguments:
;               ds                      CXSel
;               ebx                     HWLOGDEVCX ptr
;               es:esi                  DIB_Brush ptr
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
DECPROC HW_LoadColorPattern, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Load the HWBOARDCX
        mov     eax,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,eax,ecx

        mov     ecx,ds:[ebx].HWLOGDEVCX.dwColorPatternAndHeaderSize

        ; Load the push buffer ptr
        mov     edi,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
        lea     esi,[esi].DIB_Brush8.dp8BrushBits

        ; Put code in here to set the color brush
        ; eax   bits per pixel of a pixel in the pattern
        ; es:esi ptr to 64 consecutive pixels describing the pattern

        ; Setup and copy the color pattern into the chip
        CHECKDMASPACE ds,eax,edi,ecx
        mov     edx,ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetColorFormat,6)
        mov     ds:[edi + 04H],edx
        mov	dword ptr ds:[edi + 08H],NV044_SET_MONOCHROME_FORMAT_CGA6_M1
        mov	dword ptr ds:[edi + 0CH],NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov     dword ptr ds:[edi + 10H],NV044_SET_PATTERN_SELECT_COLOR
        mov	edx,ds:[ebx].HWLOGDEVCX.dwPatternAlpha0
        mov     dword ptr ds:[edi + 14H],edx
        mov	edx,ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        mov     dword ptr ds:[edi + 18H],edx
        mov     edx,ds:[ebx].HWLOGDEVCX.dwColorPatternMethodOffset
        mov     ds:[edi + 1CH],edx
        sub     ecx,20H
        add     edi,20H
@@:
	mov     ebx,es:[esi + 00H]
        mov     edx,es:[esi + 04H]
        add     esi,08H
        mov     ds:[edi + 00H],ebx
        mov     ds:[edi + 04H],edx
        add     edi,08H
        sub     ecx,08H
        jg      @B

        mov     ds:[eax].HWBOARDCX.pCurrentPushBufferOffset,edi
        mov     eax,1
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLOGDEV2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwlogdev2.asm
;
; Purpose:      This file contains all the hardware specific
;               logical DEVICE specific run-time routines.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include dxshare.inc
include escape.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
TempStack       DB 400H DUP(0)
TempStackTop    DB 10H  DUP(0)
dwOldSS         DD      0
dwOldEsp        DD      0
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  szDDrawBinaryName, szDDrawEntryPointName, szOGLRegKeyName
szDDrawBinaryName       DB      NV4_DDRAW_BINARY,0
szDDrawEntryPointName   DB      "DriverInit",0
szOGLRegKeyName         DB      "RIVATNT",0

;==============================================================================
;
; Function:     HW_LogdevMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset               HWCRTCCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_LogdevMessage, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        cmp     eax,MSG_LOGDEVMOVED
        je      logdevMoved
        cmp     eax,MSG_DEVICESREMAPPED
        je      DevRemap
        cmp     eax,MSG_DISPLAY_DRIVER_UNLOADING
        je      DispUnload
        jmp     DoneIt

PreMS:
        cmp     ds:[esi].HWLOGDEVCX.dwDirectXActive,0
        je      DoneIt

        ; Tell DDRAW we are going to switch the mode.
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_PRE_MODESET_NOTIFY
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

PostMS:
        push    pHWLogdevCXOffset
        push    dwData1
        call    NV_PostModeset

        ; We are no longer initting after the first modeset
        mov     ds:[esi].HWLOGDEVCX.dwInitting,0

        jmp     DoneIt

DXEnum:
        ; Init the shared Data structure and inform DirectX
        ; of our 16 bit capabilities
        push    pHWLogdevCXOffset
        pushd   0
        CALLFAR16 NV_CreateDrvObj
        jmp     DoneIt

DXOn:
        ; DirectX is coming up
        mov     ds:[esi].HWLOGDEVCX.dwDirectXActive,1
        jmp     DoneIt

DXOff:
        mov     ds:[esi].HWLOGDEVCX.dwDirectXActive,0
        jmp     DoneIt

DosOff:
PowerOn:
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_EXIT_FULL_SCREEN_DOS
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

DosOn:
PowerOff:
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_ENTER_FULL_SCREEN_DOS
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

DrvDis:
        jmp     DoneIt

logdevMoved:
        push    esi
        push    dwData1
        call    NV_PostModeset
        jmp     DoneIt

DevRemap:
        push    esi
        call    NV_DevicesRemapped
        jmp     DoneIt

DispUnload:
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_DRIVER_UNLOADING
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:	HW_DriverTwinviewStateChanging
;
; Purpose:	This is called when the twinview state is changing
;		We may be going in or out of clone mode or in or out
;		of multimon mode.
;		Right now we are only calling this when going in or
;		out of muti-mon to inform the DX driver so they can
;		change resource allocation.
;
; Arguments:
;               pHWLogdevCXOffsetPrimary
;               pHWLogdevCXOffsetSecondary
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DriverTwinviewStateChanging, PASCAL, FRAME, FAR16
PARMD	pHWLogdevCXOffsetPrimary
PARMD	pHWLogdevCXOffsetSecondary
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffsetPrimary

        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_EARLY_DX_CONNECT
        pushd   0
        call    DirectCallToFlatland

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_DevicesRemapped
;
; Purpose:      This routine gets called to update info when the devices
;               get remapped.
;
; Arguments:
;               pHWLogdevCXOffset
;               pDibeng
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_DevicesRemapped, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
LOCALD  dwNumCRTCs
LOCALD  dwCountCRTCs
OPENPROC
        PUSHR   esi
        mov     esi,pHWLogdevCXOffset
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData

        ; We need to get the correct head number for this DX share
        ; structure. We can peek at our HWCRTCCXs. If we have more
        ; than 1 HWCRTCCX attached, then we must be in clone mode in
        ; which case, we can set head 0. If we only have 1 HWCRTCCX
        ; attached, then use the PhysicalCRTCInstance from it.
        lea     eax,ds:[esi].HWLOGDEVCX.pHWCrtcCX
        mov     dwCountCRTCs,MAX_ATTACHED_CRTCS
        mov     dwNumCRTCs,0

        ; Keep head number for the video mirror device.
        mov     ecx,ds:[ebx].DISPDRVDIRECTXCOMMON.dwHeadNumber
BackIt:
        mov     edx,ds:[eax]
        or      edx,edx
        je      @F
        mov     ecx,ds:[edx].HWCRTCCX.dwPhysicalCRTCInstance
        inc     dwNumCRTCs
@@:     add     eax,4
        dec     dwCountCRTCs
        jne     BackIt

        ; More than 1 CRTC implies Clone mode which means Physical
        ; Instance 0.
        cmp     dwNumCRTCs,1
        jbe     @F
        sub     ecx,ecx
@@:     mov     ds:[ebx].DISPDRVDIRECTXCOMMON.dwHeadNumber,ecx

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_PostModeset
;
; Purpose:      This routine gets called right after a modeset from the
;               HW_LogdevMessage routine.
;
; Arguments:
;               pHWLogdevCXOffset
;               pDibeng
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_PostModeset, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   pDibeng
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset
        mov     edi,pDibeng

        ; Let the RM know the desktop mode.
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_SCREEN_WIDTH
        movzx   eax,ds:[edi].DIBENGINEHDR.deWidth
        push    eax
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_SCREEN_HEIGHT
        movzx   eax,ds:[edi].DIBENGINEHDR.deHeight
        push    eax
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_PIXEL_DEPTH
        movzx   eax,ds:[edi].DIBENGINEHDR.deBitsPixel
        push    eax
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        ; Fill in a few fields for the shared data structure
        ; that are changeable or that we coiuldn't know at
        ; HW_CreateLogdevConetext time.
        movzx   ecx,ds:[edi].DIBENGINEHDR.deBitsSelector
        push    ecx
        call    GN_GetSelectorBase
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     ds:[ebx].DISPDRVDIRECTXCOMMON.dwScreenLinearBase,eax
        mov     ds:[ebx].DISPDRVDIRECTXCOMMON.pFlatDibeng,edi

        ; Let the DD driver object know about the modeset
        cmp     ds:[esi].HWLOGDEVCX.dwDirectXActive,0
        je      @F
        push    pHWLogdevCXOffset
        pushd   1
        CALLFAR16 NV_CreateDrvObj
@@:
        ; Start this off at -1 after a mode switch. It is used for
        ; temporary storage of the last value written into the
        ; ContextPattern.SetMonochromeColor0 method. -1 is an OK
        ; value to have because it means the alpha is fully on.
        mov     ds:[esi].HWLOGDEVCX.dwPatternAlpha0,-1
        mov     ds:[esi].HWLOGDEVCX.dwPatternAlpha1,-1

        ; Figure out all the color depth specific object values
        mov     ax,SEG wNVTEXT32_Alias_In_NVTEXT16
        mov     es,ax
        mov     es,es:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     al,ds:[edi].DIBENGINEHDR.bRealBpp
        cmp     al,20H
        je      Is32
        cmp     al,0FH
        je      Is15
        ja      Is16

Is8:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_Y8
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,0FF00H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_A8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,40H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternY8,10H)
        jmp     DoneCD

Is15:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X17R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_X1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_X1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X17R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,8000H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,80H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternX1R5G5B5,20H)
        jmp     DoneCD

Is16:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,0FFFF0000H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_A16R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,80H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternR5G6B5,20H)
        jmp     DoneCD

Is32:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,0FF000000H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_A8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,100H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternX8R8G8B8,40H)
        jmp     DoneCD

DoneCD:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_AllocLogicalSurface
;
; Purpose:      This routine gets called to free the logical display
;               surface.
;
; Arguments:
;               ds                              Context Selector
;               pHWLogdevCXOffset               HWLOGDEVCX ptr
;               lpDibeng                        Describes logical surface
; Returns:
;               eax     offset into video memory of start of offscreen block
;                       (-1 if failure)
;               ebx     length in bytes of offscreen block
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocLogicalSurface, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   lpDibeng
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        or      ebx,ebx
        je      DoneIt

        mov     ecx,lpDibeng
        push    ds:[ebx].HWLOGDEVCX.pHWBoardCX
        push    ds:[ecx].DIBENGINE.deDeltaScan
        movzx   eax,ds:[ecx].DIBENGINE.deHeight
        push    eax
        push    ds:[ebx].HWLOGDEVCX.pHWCrtcCX
        call    HW_GetPhysicalCrtcIndex
        push    eax
        call    HW_AllocPrimarySurface
        cmp     eax,-1
        je	DoneIt
	push	ebx
        mov     ebx,pHWLogdevCXOffset
        mov     ds:[ebx].HWLOGDEVCX.dwLogicalSurfaceOffset,eax
	pop	ebx
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreeLogicalSurface
;
; Purpose:      This routine gets called to free the logical display
;               surface.
;
; Arguments:
;               pHWLogdevCXOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreeLogicalSurface, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        or      ebx,ebx
        je      @F
        push    ds:[ebx].HWLOGDEVCX.pHWBoardCX
        push    ds:[ebx].HWLOGDEVCX.dwLogicalSurfaceOffset
        call    HW_FreePrimarySurface
@@:
CLOSEPROC


;==============================================================================
;
; Function:     NV_CreateDrvObj
;
; Purpose:      This is the hardware specific CreateDriverObject
;               routine. You must fill in the "16bit portion" of the
;               HALInfo structure. It is not well documented what
;               fields exactly must be filled in here vs. which you
;               can put off and fill in when you get to the DirectX
;               driver. You will just have to look at the sample
;               Microsoft code to figure it out.
;
;               After the 16bit portion if filled out, you must call
;               the lpSetInfo routine with the apprpriate parameters
;               like this:
;               (*lpSetInfo) ((DDHALINFO FAR *)lpDDHalInfo, (WORD)dwReason);
;
;               The generic code also calls this routine whenever the
;               DDCREATEDRIVEROBJECT escape is received. This means that
;               the DirectX driver is coming up for use.
;
;               This routine is also called by the hardware specific
;               code itself when a modeset has occurred.
;
;               In both cases, before getting here, the generic code
;               has flushed all offscreen bitmaps. When NV_CreateDrvObj
;               returns, the generic code will re-init the offscreen
;               memory manager based upon the variables returned.
;
;               This gives the hardware specific code the chance to change
;               the amount of offscreen memory used for offscreen bitmaps
;               when DirectX starts up. By setting dwOffscreenLength
;               to 0, the HW specific code can eliminate offscreen
;               bitmap allocation while DirectX is active.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwReason        non-0   then the call to this routine is
;                                       because the mode has changed and
;                                       the DrvObj needs to be updated to
;                                       reflect the new mode.
;                               0       then the call to this routine is
;                                       because the DDCREATEDRIVEROBJECT
;                                       escape was received by the generic
;                                       code.
;
; Returns:      eax     0       then driver object not created. This
;                               probably means that we have not connected
;                               with the 32bit DirectX driver yet.
;                       hModule the HINSTANCE handle of the DirectX driver
;                               which was passed into its DllMain procedure.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CreateDrvObj, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwReason
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pDirectXSharedData

        ; If we don't have any DirectX context data, then we probably
        ; didn't connect with the DirectX driver, or we did, but there
        ; was an init failure.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pDirectXData,0
        je      Done

        ; If we don't have the ptr to the pfnInterfaceFunc routine which
        ; is now located in the DirectX driver, then we can't call it.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc,0
        je      Done

        ; I don't know if this will ever happen, but I was worried
        ; because of some new code paths that have been added to both
        ; display and DX driver, so it won't hurt to check this here.
        cmp     ds:[esi].HWLOGDEVCX.sDDHalDDrawFns.lpSetInfo,0
        je      Done

        ; If we get here, then the DirectX driver must be loaded and
        ; DriverInit must have been called, because that is where the
        ; pDirectXData and pfnInterfaceFunc fields get filled in.

        ; Now do a Direct call into the DirectX driver so it can init
        ; the "16bit portion" of the DDHALINFO structure.
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        push    esi
        push    ds:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    ds:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_PRE_SETINFOINIT
        pushd   0
        call    DirectCallToFlatland

        ; One last conversion -- the ddraw16.dll SetInfo routine needs
        ; a 16:16 ptr to the DDHALInfo structure and ours is currently
        ; a flat32 pointer.
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     eax,1
        mov     ebx,ds:[edi].DISPDRVDIRECTXCOMMON.pHalInfo
        mov     ecx,ds:[edi].DISPDRVDIRECTXCOMMON.dwHALInfoSize
        call    GN_AllocSelectorAndMapIt

        ; Save the selector so we can restore it later.
        push    eax

        ; Now call the ddraw16.dll SetInfo routine
        shl     eax,10H
        push    eax
        push    word ptr dwReason
        call    FFP16 PTR ds:[esi].HWLOGDEVCX.sDDHalDDrawFns.lpSetInfo

        ; Free the selector used to map the DDHALInfo structure
        pop     eax
        call    GN_UnmapAndFreeSelector

SkipIt:
        ; Return the hInstance for the DirectX driver
        mov     eax,ds:[edi].DISPDRVDIRECTXCOMMON.hDirectXInstance

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DirectCallToFlatland
;
; Purpose:      This procedure calls the far routine passed in. The
;               far routine must be in code that wants a USE32 stack
;               and assumes a flat space (ds = es = ss).
;               We map the current stack offset to a 32bit stack and
;               set ds, es, and ss to the flat data selector.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwFarCallCS             cs:eip of call dst
;               dwFarCallOffset
;               dwInterfaceID           GDIDX_XXXX in dxshare.h
;               dwExtraData             parameter to pass up
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DirectCallToFlatland, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwFarCallCS
PARMD   dwFarCallOffset
PARMD   dwInterfaceID
PARMD   dwExtraData
LOCALD  pfnSharedData
LOCALD  dwFlatDataSelector
OPENPROC
        PUSHR   ds,esi,edi
        mov     esi,pHWLogdevCXOffset

        mov     edi,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     pfnSharedData,edi
        mov     ecx,ds:[edi].DISPDRVDIRECTXCOMMON.dwFlatDataSel
        mov     dwFlatDataSelector,ecx

        ; If we don't have any DirectX context data, then we probably
        ; didn't connect with the DirectX driver, or we did, but there
        ; was an init failure.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pDirectXData,0
        je      Done

        ; If we don't have the ptr to the pfnInterfaceFunc routine which
        ; is now located in the DirectX driver, then we can't call it.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc,0
        je      Done

        ; Push the return address on the stack (this is a FAR32)
        sub     eax,eax
        mov     ax,SEG ComeBack
        push    eax
        mov     eax,OFFSET ComeBack
        push    eax

        ; Push the call address on the stack
        push    dwFarCallCS
        push    dwFarCallOffset

        ; Get the linear base address of the current ss and add to sp
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        movzx   edx,sp
        add     edx,eax

        ; Save the old ss and sp in registers that won't get trashed
        ; It's a bit tricky because, the "saved sp" should actually
        ; be the value of sp before pushing the return and calling
        ; addresses above. Why? Because when the addresses are popped
        ; off (via return calls), these returns are made with the
        ; other stack pointer!
        mov     di,ss
        mov     si,sp
        add     si,10H

        ; Load up the flat data segments
        mov     eax,dwFlatDataSelector
        mov     ds,ax
        mov     es,ax

        ; We need to pass these in
        mov     eax,pfnSharedData
        mov     ebx,dwInterfaceID
        mov     ecx,dwExtraData

        ; Load up the new ss and sp. The processor inhibits interrupts
        ; for an additional instruction after loading ss to give you a
        ; chance to load sp as well and prevent non-coherency.
        push    ds
        pop     ss
        mov     esp,edx
        RETFAR32     ; this far return will "call" the pfnInterfaceFunc func

ComeBack:
        ; We still are on the 32bit flat stack. Change back to our stack
        mov     ss,di
        mov     sp,si
Done:

        ; Restore the registers
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetDirectXRuntimeVersion
;
; Purpose:      This routine returns the DD runtime version.
;
; Arguments:
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwOSDirectXVersion      OS version of direct X
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDirectXRuntimeVersion, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwOSDirectXVersion
OPENPROC
        ; If we get asked what version DirectX the driver was built for,
        ; then we will also inform the DirectX driver what version of DX
        ; the OS is running.
        mov     edx,pHWLogdevCXOffset
        les     bx,ds:[edx].HWLOGDEVCX.lpDirectXSharedData
        movzx   ebx,bx
        push    edx
        push    es:[ebx].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[ebx].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_DIRECTX_OS_VERSION
        push    dwOSDirectXVersion
        call    DirectCallToFlatland

        mov     eax,DD_RUNTIME_VERSION
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetDirectXDllNameAndEntryPoint
;
; Purpose:      This routine returns the names of the DirectX DLL
;               and the entry point name.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;               dwDllNameSel            Selector of where to put dll name
;               dwDllNameOffset         Offset of where to put dll name
;               dwEntryPointNameSel     Selector of where to put entry
;                                       point name
;               dwEntryPointNameOffset  Offset of where to put entry
;                                       point name
;
; Returns:      eax     Ptr to DirectX Context Data (must be 16:16 ptr)
;
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDirectXDllNameAndEntryPoint, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwDllNameSel
PARMD   dwDllNameOffset
PARMD   dwEntryPointNameSel
PARMD   dwEntryPointNameOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; Copy the DLL Name
        mov     es,dwDllNameSel
        mov     edi,dwDllNameOffset
        mov     ax,SEG szDDrawBinaryName
        mov     fs,ax
        lea     esi,szDDrawBinaryName
@@:
        mov     ax,fs:[esi]
        inc     esi
        mov     es:[edi],al
        inc     edi
        or      al,al
        jne     @B

        ; Copy the DLL Entry Point Name
        mov     es,dwEntryPointNameSel
        mov     edi,dwEntryPointNameOffset
        mov     ax,SEG szDDrawEntryPointName
        mov     fs,ax
        lea     esi,szDDrawEntryPointName
@@:
        mov     ax,fs:[esi]
        inc     esi
        mov     es:[edi],al
        inc     edi
        or      al,al
        jne     @B

        ; Return a 16:16 ptr to the DirectX shared data
        mov     esi,pHWLogdevCXOffset
        mov     eax,ds:[esi].HWLOGDEVCX.pDirectXSharedData

        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     HW_SetNewDirxCallbacks
;
; Purpose:      This routine tells the ardware what the addresses
;               of the DirectX callback functions are.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;               lpDDHalDDrawFuncs       16:16 ptr to DDraw callbacks
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetNewDirxCallbacks, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   lpDDHalDDrawFuncs
OPENPROC
        PUSHR   ds,esi,edi
        PUSHR   ds
        POPR    es
        mov     edi,pHWLogdevCXOffset
        lea     edi,[edi].HWLOGDEVCX.sDDHalDDrawFns

        sub     esi,esi
        lds     si,lpDDHalDDrawFuncs

        pushf
        cld
        mov     ecx,(SIZE MYDDHALDDRAWFNS) / 4
        rep     movs dword ptr es:[edi], ds:[esi]
        popf

        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     HW_GetDirectXInstance
;
; Purpose:      This routine returns the instance handle of the
;               DirectX dll.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;
; Returns:
;               eax             DirectX Driver instance handle.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDirectXInstance, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWLogdevCXOffset
        mov     eax,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     eax,ds:[eax].DISPDRVDIRECTXCOMMON.hDirectXInstance
        POPR    esi
CLOSEPROC



;==============================================================================
;
; Function:     HW_GetOpenGLRegistryName
;
; Purpose:      This routine returns the names of the OpenGL
;               Registry subkey that should be used by the system.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;               dwDllNameSel            Selector of where to put dll name
;               dwDllNameOffset         Offset of where to put dll name
;
; Returns:      eax                     The OGL ICD version
;               ebx                     The OGL driver version
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetOpenGLRegistryName, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwDllNameSel
PARMD   dwDllNameOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; Copy the DLL Name
        mov     es,dwDllNameSel
        mov     edi,dwDllNameOffset
        mov     ax,SEG szOGLRegKeyName
        mov     fs,ax
        lea     esi,szOGLRegKeyName
@@:
        mov     ax,fs:[esi]
        inc     esi
        mov     es:[edi],al
        inc     edi
        or      al,al
        jne     @B

        mov     eax,OPENGL_ICD_VER
        mov     ebx,OPENGL_DRIVER_VER
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_DirectXService
;
; Purpose:      This routine can be called from the DirectX driver
;               when it is executing within the context of a
;               DirectCallToFlatland. There are various services
;               that are supported.
;
;               This routine is a bit of a pain. The caller is
;               running on a flat 32bit stack. Any system functions
;               we call can only handle 16bit stacks, so we have
;               to switch the stack over before doing anything.
;
; Arguments:    None
;
; Returns:
;
; Preserve:     Everything
;==============================================================================
DECPROC NV_DirectXServiceNoFrame, PASCAL, NOFRAME, FAR32
;PARMD  pHWLogdevCX
;PARMD  dwFunction
;PARMD  pIn
;PARMD  pOut
OPENPROC
        ; Save some registers -- 30H bytes worth
        ; on the 32bit stack.
        PUSHR   alld,ds,es,fs,gs

        ; Load up the parameters
        lea     edi,[esp + 20H + 4 * @WordSize + 08H]
        mov     ebp,ss:[edi + 0CH]                      ; pHWLogdevCX
        mov     eax,ss:[edi + 08H]                      ; dwFunction
        mov     ebx,ss:[edi + 04H]                      ; pIn
        mov     ecx,ss:[edi + 00H]                      ; pOut
        mov     edi,esp
        sub     esi,esi
        mov     si,ss

        ; Load up a temporary stack we have in our data segment
        mov     dx,_DATA
        mov     ss,dx
        mov     sp,OFFSET TempStackTop

        ; Save the 32bit stack registers
        mov     ss:[dwOldSS],esi
        mov     ss:[dwOldEsp],edi

        ; Now push the arguments on the new stack
        push    ebp
        push    eax
        push    ebx
        push    ecx
        call    NV_DirectXService

        ; restore the 32bit stack
        mov     eax,ss:[dwOldSS]
        mov     ecx,ss:[dwOldEsp]
        mov     ss,ax
        mov     esp,ecx

        ; pop all the registers
        POPR    alld,ds,es,fs,gs

        RETFAR32 10H
CLOSEPROC

DECPROC NV_DirectXService, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCX
PARMD   dwFunction
PARMD   pIn
PARMD   pOut
LOCALD  dwFlatSelector
OPENPROC
        ; pIn and pOut are both flat ptrs. We need the flat selector
        ; loaded in order to access them.
        sub     esi,esi
        mov     ds,wFlatDataSel_In_NVTEXT16
        mov     edi,pHWLogdevCX
        mov     edi,ds:[edi].HWLOGDEVCX.pDirectXSharedData
        mov     eax,ds:[edi].DISPDRVDIRECTXCOMMON.dwFlatDataSel
        mov     dwFlatSelector,eax

        mov     eax,dwFunction
        cmp     eax,NV_DRVSERVICE_ALLOC_MEMORY
        je      AllocMem
        cmp     eax,NV_DRVSERVICE_FREE_MEMORY
        je      FreeMem
        cmp     eax,NV_DRVSERVICE_BEGINACCESS
        je      DoBegAcc
        cmp     eax,NV_DRVSERVICE_ENDACCESS
        je      DoEndAcc
        sub     eax,eax
        jmp     Done

AllocMem:
        mov     es,dwFlatSelector
        mov     edx,pIn
        mov     eax,es:[edx].DRVSERVICE_ALLOC_MEMORY.dwNumBytes
        mov     ebx,es:[edx].DRVSERVICE_ALLOC_MEMORY.dwAllocFlags
        mov     ecx,es:[edx].DRVSERVICE_ALLOC_MEMORY.dwObjectID
        mov     esi,pHWLogdevCX
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        call    NV_AllocMemory
        mov     es,dwFlatSelector
        mov     edx,pOut
        mov     es:[edx],eax
        jmp     Done

FreeMem:
        mov     esi,pHWLogdevCX
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     es,dwFlatSelector
        mov     edx,pIn
        mov     ecx,es:[edx].DRVSERVICE_FREE_MEMORY.dwObjectID
        call    NV_FreeMemory
        mov     es,dwFlatSelector
        mov     edx,pOut
        mov     es:[edx],eax
        jmp     Done

DoBegAcc:
        sub     eax,eax
        les     bx,pIn
        mov     di,es:[bx].DIBENGINE.deFlags
        and     di,BUSY
        and     es:[bx].DIBENGINE.deFlags,NOT BUSY
        push    pIn
        push    eax
        push    eax
        pushw   FB_ACCESS OR CURSOREXCLUDE
        call    FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
        les     bx,pIn
        or      es:[bx].DIBENGINE.deFlags,di
        jmp     Done

DoEndAcc:
        les     bx,pIn
        mov     di,es:[bx].DIBENGINE.deFlags
        and     di,BUSY
        and     es:[bx].DIBENGINE.deFlags,NOT BUSY
        push    pIn
        pushw   FB_ACCESS OR CURSOREXCLUDE
        call    FFP16 PTR es:[bx].DIBENGINE.deEndAccess
        les     bx,pIn
        or      es:[bx].DIBENGINE.deFlags,di
        jmp     Done

Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_TellResManSpanningState
;
; Purpose:      This routine informs the Resource Manager that we are
;               in spanning mode.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;
; Returns:      
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_TellResManSpanningState, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwSpanningState
OPENPROC
        PUSHR   ds,esi,edi
        
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        pushd   NV_CFG_DISPLAY_CHANGE_CONFIG    
        push    dwSpanningState
        push    ds:[edi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        POPR    ds,esi,edi
CLOSEPROC


CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\hwidiag.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         hwidiag.asm
;
; Purpose:      This file implements diagnostics that Intel requires
;               for purchase of our boards. The functions in here
;               are all reached via a driver Escape mechanism.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwmacs.inc
include gngdi.inc
include hwgdi.inc
include nvcm.inc

INTEL_DIAG_FRAME_AND_LOCALS	MACRO
PARMD	pHWLogdevCXOffset
PARMD   lpIn
PARMD   lpOut
ENDM

IDIAG_OPEN_INTERFACE            TEXTEQU <0>
IDIAG_CLOSE_INTERFACE           TEXTEQU <1>
IDIAG_GET_ERROR_CODE            TEXTEQU <2>
IDIAG_GET_CRC                   TEXTEQU <3>
IDIAG_GET_DRIVER_INFO           TEXTEQU <4>
IDIAG_GET_MEMORY_INFO           TEXTEQU <5>
IDIAG_GET_CLOCK_RATES           TEXTEQU <6>
IDIAG_GET_PCI_CONFIG            TEXTEQU <7>
IDIAG_GET_BUS_CONFIG            TEXTEQU <8>

IDIAG_ERROR_NONE                TEXTEQU <0>
IDIAG_ERROR_GENERIC             TEXTEQU <1>
IDIAG_ERROR_INVALID_PARAM       TEXTEQU <2>
IDIAG_ERROR_NOT_SUPPORTED       TEXTEQU <3>

; This is bad to redefine these here, but I am doing it for now!
; JKTODO ...
NV_PRAMDAC_TEST_CONTROL		TEXTEQU	<680608H>
NV_PRAMDAC_CHECKSUM		TEXTEQU	<68060CH>


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

PUBLIC dwBuildYear, dwBuildMonth, dwBuildDay
TWO_DIGIT_YEAR      	TEXTEQU @SubStr( %@Date, 7, 2 )
CURRENT_YEAR    	TEXTEQU <2000 + TWO_DIGIT_YEAR>
dwBuildYear     	DD      CURRENT_YEAR
dwBuildMonth		DD	@SubStr( %@Date, 1, 2 )
dwBuildDay		DD	@SubStr( %@Date, 4, 2 )
szNVCompanyString       DB      NV_COMPANY_NAME_STRING_SHORT,0
szDriverVersion         DB      NV_VERSION_STRING,0

;==============================================================================
;
; Function:	NV_IntelDiagnostics
;
; Purpose:      This function is a set of Intel diagnostics.
;               Intel requires this Escape and diagnostics in
;               order to purchase our boards.
;
; Arguments:
;		ds			CX Sel
;		pHWLogdevCXOffset	HWLOGDEVCX ptr
;		lpIn			lpIn ptr of Escape function
;		lpOut			lpOut ptr of Escape function
; Returns:
;		ecx	0 	then pretend the escape was not implemented
;			non-0	then it was handled and eax has the
;				return code.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_IntelDiagnostics, PASCAL, FRAME, FAR16
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
        PUSHR   esi,edi
        mov	ebx,pHWLogdevCXOffset

	; Verify the lpIn and lpOut parameters
	sub	eax,eax
	cmp	eax,lpIn
	je	FailIt
	cmp	eax,lpOut
	je	FailIt

	; Proceed with diagnostics subfunction
	lfs	si,lpIn
	les	di,lpOut
	mov	eax,fs:[si]

	push	OFFSET RetAddr
	cmp	eax,IDIAG_OPEN_INTERFACE
	je	NV_OpenIntelDiagInterface
	add	sp,@WordSize

	; If the interface is not open and this was not an open
	; request, the Intel spec says to pretend that the escape
	; is not implemented.
	cmp	ds:[ebx].HWLOGDEVCX.wDiagInterfaceOpen,0
	je	NotUs

	push	OFFSET RetAddr
	cmp	eax,IDIAG_CLOSE_INTERFACE
	je	NV_CloseIntelDiagInterface
	cmp	eax,IDIAG_GET_ERROR_CODE
	je	NV_IntelDiagGetErrorCode
	cmp	eax,IDIAG_GET_CRC
	je	NV_IntelDiagGetCRC
	cmp	eax,IDIAG_GET_DRIVER_INFO
	je	NV_IntelDiagDriverInfo
	cmp	eax,IDIAG_GET_MEMORY_INFO
	je      NV_IntelDiagMemoryInfo
	cmp	eax,IDIAG_GET_CLOCK_RATES
	je	NV_IntelDiagClockRates
	cmp	eax,IDIAG_GET_PCI_CONFIG
	je	NV_IntelDiagPciConfig
	cmp	eax,IDIAG_GET_BUS_CONFIG
	je	NV_IntelDiagBusConfig
	add	sp,@WordSize

NotSupported:
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NOT_SUPPORTED
	mov	ecx,1
	mov	ax,-1
	jmp	DoneIt

NotUs:
	sub	ecx,ecx
	jmp	DoneIt

FailIt:
	; Comment to keep assembler from weird error
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_INVALID_PARAM
	mov	ecx,1
	sub	ax,ax
	jmp	DoneIt

RetAddr:
	mov	ecx,1

DoneIt:
	POPR	esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     NV_OpenIntelDiagInterface
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_OPEN_INTERFACE
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		if	lpIn->DIAGINPUT.dwOpenKey == INTEL_DIAG_OPEN_KEY
;			lpOut->DIAGOUTPUT.dwOpenAck = INTEL_DIAG_OPEN_ACK
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
OPEN_INPUT	STRUCT
	dwFunction	DD	0
	dwOpenKey	DD	0
OPEN_INPUT	ENDS

OPEN_OUTPUT	STRUCT
	dwOpenAck	DD	0
OPEN_OUTPUT	ENDS

INTEL_DIAG_OPEN_KEY	TEXTEQU	<0B295F38DH>
INTEL_DIAG_OPEN_ACK	TEXTEQU	<070CA14E6h>

DECPROC NV_OpenIntelDiagInterface, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	sub	cx,cx
	mov	ax,IDIAG_ERROR_INVALID_PARAM
	cmp	fs:[si].OPEN_INPUT.dwOpenKey,INTEL_DIAG_OPEN_KEY
	jne	SetErrorCode

	; return the correct value
        mov     es:[di].OPEN_OUTPUT.dwOpenAck,INTEL_DIAG_OPEN_ACK

	; Tell our logical device that the interface is open
	mov	ds:[ebx].HWLOGDEVCX.wDiagInterfaceOpen,1
	mov	ax,IDIAG_ERROR_NONE
	mov	ecx,1

SetErrorCode:
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,ax
	mov	ax,cx
CLOSEPROC


;==============================================================================
;
; Function:     NV_CloseIntelDiagInterface
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_CLOSE_INTERFACE
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		Close the interface
;		Set the last error code to None
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
DECPROC NV_CloseIntelDiagInterface, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; Tell our logical device that the interface is closed
	mov	ds:[ebx].HWLOGDEVCX.wDiagInterfaceOpen,0
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagGetErrorCode
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_ERROR_CODE
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_ERROR_CODE_OUTPUT	STRUCT
	dwError		DD	0
GET_ERROR_CODE_OUTPUT	ENDS

DECPROC NV_IntelDiagGetErrorCode, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; Tell our logical device that the interface is closed
	movzx	eax,ds:[ebx].HWLOGDEVCX.wLastDiagError
	mov	es:[di].GET_ERROR_CODE_OUTPUT.dwError,eax
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagGetCRC
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_CRC
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_CRC_OUTPUT	STRUCT
	dwCRC0		DD	0	; Red   Channel (if applicable)
	dwCRC1		DD	0       ; Green Channel (if applicable)
	dwCRC2		DD	0       ; Blue  Channel (if applicable)
	dwCRC3		DD	0
GET_CRC_OUTPUT	ENDS

DECPROC NV_IntelDiagGetCRC, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; Comment to keep assembler from choking... Don't ask me why.
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     esi,ds:[esi].HWBOARDCX.pChipRegs

	; Read Red Channel
	mov	ecx,2
	call	GetCRC
	mov	es:[di].GET_CRC_OUTPUT.dwCRC0,eax

	; Read Green Channel
	mov	ecx,1
	call	GetCRC
	mov	es:[di].GET_CRC_OUTPUT.dwCRC1,eax

	; Read Blue Channel
	sub	ecx,ecx
	call	GetCRC
	mov	es:[di].GET_CRC_OUTPUT.dwCRC2,eax

	; I don't know what this one is for, but return 0 in it.
	sub	eax,eax
	mov	es:[di].GET_CRC_OUTPUT.dwCRC3,eax
	mov	ax,1
	jmp	DoneIt

GetCRC:
        pushf
        cli

Loopy:	test	dword ptr ds:[esi + 6013DAH],8
	jnz	Loopy
@@:	test	dword ptr ds:[esi + 6013DAH],8
	jz	@B

        mov	eax,11H
        or      ds:[esi + NV_PRAMDAC_TEST_CONTROL],eax
        mov	eax,ecx
        shl     eax,8
        or      eax,10h
        mov     ds:[esi + NV_PRAMDAC_TEST_CONTROL],eax
        sub	eax,eax
        mov     ds:[esi + NV_PRAMDAC_CHECKSUM],eax
        mov     eax,ds:[esi + NV_PRAMDAC_CHECKSUM]

        ; For TNT2 checksum bug.  If the reset bit is on.  Reset again
        test    eax,1 SHL 24
        jnz     Loopy

        ; Wait one frame
@@:	test	dword ptr ds:[esi + 6013DAH],8
	jnz	@B
@@:	test	dword ptr ds:[esi + 6013DAH],8
	jz	@B

	; read the checksum
        mov     eax,ds:[esi + NV_PRAMDAC_CHECKSUM]
        and     eax,0FFFFFFH

	; The popf should restore the interrupt state.
        popf
	ret
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagDriverInfo
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_DRIVER_INFO
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_DRIVER_INFO_OUTPUT	STRUCT
	dwInterfaceRev	DD	0	; major in hi word, minor in lo word
	dwDay		DD	0	; e.g. 23
	dwMonth		DD	0       ; e.g. 2
	dwYear		DD	0       ; e.g. 1999
	szManufacturer	DB	80 DUP(0)
	szDriverVer	DB	80 DUP(0)
	szBiosVer 	DB	80 DUP(0)
GET_DRIVER_INFO_OUTPUT	ENDS

DECPROC NV_IntelDiagDriverInfo, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
	mov	ecx,ebx

	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwInterfaceRev,00004H
	mov	eax,dwBuildDay
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwDay,eax
	mov	eax,dwBuildMonth
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwMonth,eax
	mov	eax,dwBuildYear
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwYear,eax

	lea	si,[di].GET_DRIVER_INFO_OUTPUT.szManufacturer
	lea	bx,szNVCompanyString
@@:	mov	al,cs:[bx]
	inc	bx
	mov	es:[si],al
	inc	si
	or	al,al
	jne	@B

	lea	si,[di].GET_DRIVER_INFO_OUTPUT.szDriverVer
	lea	bx,szDriverVersion
@@:	mov	al,cs:[bx]
	inc	bx
	mov	es:[si],al
	inc	si
	or	al,al
	jne	@B

        mov     esi,ds:[ecx].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_BIOS_REVISION
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov	ax,SEG lpfnNvConfigGet
        mov	gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        shl     edx,16
        mov     dx,ax
        mov     eax,edx
        les	di,lpOut

	mov	cx,8
Loopy:
	shld	edx,eax,4
	shl	eax,4
	and	edx,0FH
	cmp	edx,10
	sbb	ebx,ebx
	not	ebx
	and	ebx,7
	lea	edx,[edx + ebx + 30H]
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.szBiosVer,dl
	inc	di

	cmp	cx,7
	je	DoDot
	cmp	cx,5
	jne	SkipDot
DoDot:
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.szBiosVer,'.'
	inc	di

SkipDot:
	dec	cx
	jne	Loopy
	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagMemoryInfo
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_MEMORY_INFO
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_MEMORY_INFO_OUTPUT	STRUCT
	dwKSize		DD	0 ; size in Kilobytes
	dwType		DD	0 ; DRAM (EDO/FPM) = 1, SDRAM = 2, SGRAM = 3
GET_MEMORY_INFO_OUTPUT	ENDS

DECPROC NV_IntelDiagMemoryInfo, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX

        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySize
        shr	eax,10
	mov	es:[di].GET_MEMORY_INFO_OUTPUT.dwKSize,eax

        pushd   NV_CFG_RAM_TYPE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov     ax,SEG lpfnNvConfigGet
        mov     gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        les	di,lpOut
	mov	es:[di].GET_MEMORY_INFO_OUTPUT.dwType,eax

	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagClockRates
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_CLOCK_RATES
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_CLOCK_RATES_OUTPUT	STRUCT
	dwEngClockKHz	DD	0
	dwMemClockKHz	DD	0
GET_CLOCK_RATES_OUTPUT	ENDS

DECPROC NV_IntelDiagClockRates, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX

        pushd   NV_CFG_DAC_GRAPHICS_CLOCK
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov     ax,SEG lpfnNvConfigGet
        mov     gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        shl     edx,16
        mov     dx,ax
        mov     eax,edx
        mov     ecx,1000
        xor     edx,edx
        div     ecx
        les	di,lpOut
        mov     es:[di].GET_CLOCK_RATES_OUTPUT.dwEngClockKHz,eax

        pushd   NV_CFG_DAC_MEMORY_CLOCK
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov     ax,SEG lpfnNvConfigGet
        mov     gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        shl     edx,16
        mov     dx,ax
        mov     eax,edx
        mov     ecx,1000
        xor     edx,edx
        div     ecx
        les	di,lpOut
        mov     es:[di].GET_CLOCK_RATES_OUTPUT.dwMemClockKHz,eax

	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagPciConfig
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_PCI_CONFIG
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_PCI_CONFIG_OUTPUT	STRUCT
	dwPCI0	DD	0	; PCI DEVICE hi 16 bits: PCI Vendor lo 16
	dwPCI1	DD	0	; PCI Class high 24 bits: PCI Revision lo 8
	dwPCI2	DD	0	; PCI SubSys hi 16 bits: PCI subsys vendor lo 16
	dwPCI3	DD	0	; PCI framebuffer address
GET_PCI_CONFIG_OUTPUT	ENDS

DECPROC NV_IntelDiagPciConfig, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     ecx,ds:[esi].HWBOARDCX.pChipRegs

        ; return PCI Device ID (upper 16), PCI Vendor ID (lower 16)
        mov     eax,ds:[ecx + 1800H]
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI0,eax

        ; return PCI Class Code high high 24 bits, Revision ID low 8 bits
        mov     eax,ds:[ecx + 1808H]
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI1,eax

        ; return PCI Subsystem ID (upper 16), PCI Subsystem Vendor ID (lower 16)
        mov     eax,ds:[ecx + 180CH]
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI2,eax

        ; return PCI Frame buffer base address
        mov     eax,ds:[ecx + 1814H]
        and     eax,0FF000000H
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI3,eax
        mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagBusConfig
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_BUS_CONFIG
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_BUS_CONFIG_OUTPUT	STRUCT
	dwBusMode	DD	0 ; PCI 33MHZ = 1, PCI 66MHZ = 2, AGP = 3
	dwAGPRate	DD	0 ; NA = 0, 1X = 1, 2X = 2, 4X = 3
	dwAGPMode	DD	0 ; NA = 0, Pipelined = 1, Sideband = 2
	dwFastWrite	DD	0 ; NA = 0, Disabled = 1, Enabled = 2
GET_BUS_CONFIG_OUTPUT	ENDS

DECPROC NV_IntelDiagBusConfig, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     ecx,ds:[esi].HWBOARDCX.pChipRegs

        mov     eax,ds:[esi].HWBOARDCX.dwBusType
	cmp	eax,NV_BUS_TYPE_AGP
	jne	BusPci
BusAgp:
        mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwBusMode,3

	; Bus rate is in chip reg at 184CH
        mov     eax,ds:[ecx + 184CH]
        mov     ebx,eax
        and     ebx,7
        test    ebx,4
        jz      @f
        mov     ebx,3
@@:     mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPRate,ebx

        ; AGP side band
        test    eax,1 SHL 8
        setnz   bl
        inc     ebx
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPMode,ebx

        ; AGP fast write
        test    eax,1 SHL 3
        setnz   bl
        inc     ebx
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwFastWrite,ebx
	jmp	DoneIt

BusPci:
        ; Bus type is PCI
        mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwBusMode,1

	sub	eax,eax
     	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPRate,eax
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPMode,eax
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwFastWrite,eax

DoneIt:
	mov	ax,1
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWINIT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwinit.asm
;
; Purpose:      This file does hardware specific initialization that
;               needs to be done before anything else in the driver
;               executes. Also, it holds the routine that gets called
;               just before the driver DLL unloads (the WEP) routine.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
szNvSysDll              DB      NV4_RM_16_BINARY,0
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  NvSysTable
NvSysTable      LABEL   WORD
DW      OFFSET szNvSysDll, SEG szNvSysDll
hNvSysDll                       DW      0
lpfnNvSysMoveCursor             MODULELINK      <0, ORD_NvSysMoveCursorMulti>
lpfnNvSysUpdateImageOffsetFormat MODULELINK     <0, ORD_NvSysUpdateImageOffsetFormat>
lpfnNvSysGetRamInfo             MODULELINK      <0, ORD_NvSysGetRamInfo>
lpfnNvSysAllocPages             MODULELINK      <0, ORD_NvSysAllocPages>
lpfnNvSysFreePages              MODULELINK      <0, ORD_NvSysFreePages>
lpfnNvConfigGet                 MODULELINK      <0, ORD_NvConfigGet>
lpfnNvConfigSet                 MODULELINK      <0, ORD_NvConfigSet>
lpfnNvConfigUpdate              MODULELINK      <0, ORD_NvConfigUpdate>
lpfnNvConfigVga                 MODULELINK      <0, ORD_NvConfigVga>
lpfnNvSysSetCursorImage         MODULELINK      <0, ORD_NvSysSetCursorImageMulti>
lpfnNvSysGetHardwarePointers    MODULELINK      <0, ORD_NvSysGetHardwarePointers>
lpfnNvDeviceBaseGet             MODULELINK      <0, ORD_NvDeviceBaseGet>
lpfnNvDeviceLimitGet            MODULELINK      <0, ORD_NvDeviceLimitGet>
lpfnNvSysDriverConnect          MODULELINK      <0, ORD_NvSysDriverConnect>
lpfnNvSysDriverDisConnect       MODULELINK      <0, ORD_NvSysDriverDisConnect>
lpfnNvSysRegisterDisplayDriver  MODULELINK      <0, ORD_NvSysRegisterDisplayDriver>
lpfnNvIoControl                 MODULELINK      <0, ORD_NvIoControl>
lpfnArch_Nv01Free               MODULELINK      <0, ORD_Nv01Free>
lpfnArch_Nv01AllocRoot          MODULELINK      <0, ORD_Nv01AllocRoot>
lpfnArch_Nv01AllocMemory        MODULELINK      <0, ORD_Nv01AllocMemory>
lpfnArch_Nv01AllocContextDma    MODULELINK      <0, ORD_Nv01AllocContextDma>
lpfnArch_Nv01AllocChannelPio    MODULELINK      <0, ORD_Nv01AllocChannelPio>
lpfnArch_Nv01AllocObject        MODULELINK      <0, ORD_Nv01AllocObject>
lpfnArch_Nv01AllocDevice        MODULELINK      <0, ORD_Nv01AllocDevice>
lpfnArch_Nv03AllocChannelDma    MODULELINK      <0, ORD_Nv03AllocChannelDma>
lpfnArch_Nv03DmaFlowControl     MODULELINK      <0, ORD_Nv03DmaFlowControl>
lpfnArch_Nv01Interrupt          MODULELINK      <0, ORD_Nv01Interrupt>
lpfnArch_Nv01AllocEvent         MODULELINK      <0, ORD_Nv01AllocEvent>
lpfnArch_NvI2CAccess            MODULELINK      <0, ORD_NvI2CAccess>
lpfnArch_Nv04ConfigGetEx        MODULELINK      <0, ORD_Nv04ConfigGetEx>
lpfnArch_Nv04ConfigSetEx        MODULELINK      <0, ORD_Nv04ConfigSetEx>
lpfnArch_Nv04Alloc              MODULELINK      <0, ORD_Nv04Alloc>
                                MODULELINK      <0, 0>
CLOSESEG _NVTEXT32

OPENSEG  _NVTEXT16, USE16, CODE
;==============================================================================
;
; Function:     HW_CreateConstants
;
; Purpose:      This functions should init any things that are
;               effectively constants in the driver. Usually these
;               are items that go in the code segment. This routine
;               is called only once at boot and no context has yet
;               been created.
;
; Arguments:    None
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateConstants, PASCAL, FRAME, FAR16
OPENPROC
        PUSHR   ds,esi
        mov     ds,wNVTEXT32_Alias_In_NVTEXT16
        lea     esi,NvSysTable
        call    GN_LoadDllAndGetExports
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyConstants
;
; Purpose:      This functions should destroy any "constants"
;               created by the CreateConstants routine. This
;               routine is called once when the driver is about
;               to be unloaded.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyConstants, PASCAL, FRAME, FAR16
PARMD   dwThisLogDeviceHandle
OPENPROC
        ; In multi-monitor applications, the secondary device must not
        ; attempt to unload the Dlls, otherwise the system will gpf on
        ; a windows 'quick-boot' (shift-enter on restart). We are
        ; assuming that the primary device has a device handle of 1.
        cmp     dwThisLogDeviceHandle,1
        jne     SkipDllUnload

        ; Unload the RM 16bit dll.
        mov     es,wNVTEXT32_Alias_In_NVTEXT16
        push    es:[hNvSysDll]
        mov     es:[hNvSysDll],0
        call    FreeLibrary
SkipDllUnload:
CLOSEPROC


;==============================================================================
;
; Function:     HW_AllocFlatMemory
;
; Purpose:      This routine buys memory in VDD land (3Gig-4Gig),
;               zeros it out and returns a flat ptr to it.
;
; Arguments:
;               dwAmount                How much to buy
;
; Returns:
;               eax     Flat ptr to memory block
;                       0 if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocFlatMemory, PASCAL, FRAME, FAR16
PARMD   dwAmount
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegECX,MVDD_ALLOC_MEMORY_BLOCK
        mov     eax,dwAmount
        mov     rmRegs.RegEDX,eax
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,rmRegs.RegEAX
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreeFlatMemory
;
; Purpose:      This routine frees a memory block allocated
;               via HW_AllocFlatMemory
;
; Arguments:
;               pFlatMem                ptr to memory to free
;
; Returns:
;               eax     Flat ptr to memory block
;                       0 if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreeFlatMemory, PASCAL, FRAME, FAR16
PARMD   pFlatMem
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegECX,MVDD_FREE_MEMORY_BLOCK
        mov     eax,pFlatMem
        mov     rmRegs.RegEDX,eax
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetLogdevToBoardPtr
;
; Purpose:      This function gets the shared block of memory used
;               for managing logical device to board instance stuff.
;               The memory must be shared across all driver contexts.
;
; Arguments:	None
;
; Returns:      eax                     context ptr to shared memory
;               THIS ROUTINE CANNOT FAIL.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetLogdevToBoardPtr, PASCAL, FRAME, FAR16
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegECX,MVDD_GET_LOGDEV_SHARED_MEMORY
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,rmRegs.RegEAX
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLOGDEV.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwlogdev.asm
;
; Purpose:      This file contains all the hardware specific
;               logical DEVICE specific init routines.
;==============================================================================
.586
incDevice = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include modeext.inc
include dxshare.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_CreateLogdevContext
;
; Purpose:      This routine allocates memory for and initializes
;               a HWLOGDEVCX structure.
;
; Arguments:
;               ds                      Context Selector
;		pHWBoardCXOffset	HWBOARDCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success and eax is a ptr to the HWLOGDEVCX
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateLogdevContext, PASCAL, FRAME, FAR16
PARMD	pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        pushd   SIZE HWLOGDEVCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; We are initting
        mov     ds:[esi].HWLOGDEVCX.dwInitting,1

        ; We don't know this until an attach
        mov	eax,pHWBoardCXOffset
        mov     ds:[esi].HWLOGDEVCX.pHWBoardCX,eax

        ; DirectX is not active right now
        mov     ds:[esi].HWLOGDEVCX.dwDirectXActive,0

        ; Allocate memory for a mastr mode list to give to
        ; DirectX early on.
        pushd   2048 * (SIZE MODEENTRYANDPITCH)
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWLOGDEVCX.pMasterModeList,eax

        ; Create a 16:16 ptr to the MasterModeList
        mov     eax,1
        mov     ebx,ds:[esi].HWLOGDEVCX.pMasterModeList
        mov     ecx,2048 * (SIZE MODEENTRYANDPITCH)
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].HWLOGDEVCX.lpMasterModeList,eax

        ; Alloc memory for the DirectX shared data structure
        pushd   SIZE DISPDRVDIRECTXCOMMON
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWLOGDEVCX.pDirectXSharedData,eax

        ; Create a 16:16 ptr to the Shared Data
        mov     eax,1
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     ecx,SIZE DISPDRVDIRECTXCOMMON
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].HWLOGDEVCX.lpDirectXSharedData,eax

        ; Fill in the DirectX Shared Data
        mov     edi,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     ds:[edi].DISPDRVDIRECTXCOMMON.dwDeviceHandle,NV_WIN_DEVICE
        mov     eax,ds:[esi].HWLOGDEVCX.pMasterModeList
        mov     ds:[edi].DISPDRVDIRECTXCOMMON.lpMasterModeList,eax
	mov	ax,cs
	and	eax,0FFFFH
	mov	ds:[edi].DISPDRVDIRECTXCOMMON.dwDrvCallbackSelector,eax
	mov	eax,OFFSET NV_DirectXServiceNoFrame
	mov	ds:[edi].DISPDRVDIRECTXCOMMON.dwDrvCallbackOffset,eax
	mov	ds:[edi].DISPDRVDIRECTXCOMMON.pDispDriverHWLogDevCX,esi

	; Ask the HWBOARD to fill in its DXShare data
        push	ds:[esi].HWLOGDEVCX.pHWBoardCX
        push	ds:[esi].HWLOGDEVCX.pDirectXSharedData
        call	NV_BoardSetDXSharedData

        mov     eax,esi
DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the HWLOGDEVCX. was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; HW_DestroyLogdevContext can clean up partial inits
        push    esi
        call    HW_DestroyLogdevContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyLogdevContext
;
; Purpose:      This routine allocates memory for and initializes
;               an array of HWCRTCCX structure.
;
; Arguments:
;               ds                      The context selector.
;               pHWLogdevCXOffset       offset of HWLOGDEVCX to destroy
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyLogdevContext, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset
        or      esi,esi
        je      DoneIt

        ; Destroy the 16:16 alias for the shared data
        cmp     ds:[esi].HWLOGDEVCX.lpDirectXSharedData,0
        je      @F

        movzx   eax,word ptr ds:[esi].HWLOGDEVCX.lpDirectXSharedData+2
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].HWLOGDEVCX.lpDirectXSharedData,0
@@:
        ; Destroy the shared data memory
        cmp     ds:[esi].HWLOGDEVCX.pDirectXSharedData,0
        je      @F

        push    ds:[esi].HWLOGDEVCX.pDirectXSharedData
        call    HW_FreeFlatMemory
        mov     ds:[esi].HWLOGDEVCX.pDirectXSharedData,0
@@:

        ; Destroy the 16:16 alias for the shared data
        cmp     ds:[esi].HWLOGDEVCX.lpMasterModeList,0
        je      @F

        movzx   eax,word ptr ds:[esi].HWLOGDEVCX.lpMasterModeList+2
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].HWLOGDEVCX.lpMasterModeList,0

@@:
        ; Destroy the modelist memory
        cmp     ds:[esi].HWLOGDEVCX.pMasterModeList,0
        je      @F

        push    ds:[esi].HWLOGDEVCX.pMasterModeList
        call    HW_FreeFlatMemory
        mov     ds:[esi].HWLOGDEVCX.pMasterModeList,0
@@:
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:	HW_LogdevAttachCrtc
;
; Purpose:      This function is called to tell the HWLOGDEVCX a
;		new HWCRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;		dwLogicalCRTCIndex	The logical index for this
;					attachment (0, 1, 2, etc..
;		pHWCrtcCXOffset		HWCRTCCX ptr
;
; Returns:      eax			0 Fail
;					non-0 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_LogdevAttachCrtc, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD	dwLogicalCRTCIndex
PARMD	pHWCrtcCXOffset
OPENPROC
	; First, put the HWCRTCCX into the HWLOGDEVCX
	mov	ebx,pHWLogdevCXOffset
	mov	eax,dwLogicalCRTCIndex
	mov	ecx,pHWCrtcCXOffset
	mov	ds:[ebx].HWLOGDEVCX.pHWCrtcCX[eax * 4],ecx

	; This HWCRTCCX has a parent HWLOGDEVCX
	push	pHWCrtcCXOffset
	push    pHWLogdevCXOffset
	call	NV_CrtcSetLogdev

	mov	eax,1
CLOSEPROC


;==============================================================================
;
; Function:	HW_LogdevDetachCrtc
;
; Purpose:      This function is called to tell the HWLOGDEVCX to
;		remove a HWCRTCCX from its list of active contexts.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;		dwLogicalCRTCIndex	The logical index for this
;					attachment (0, 1, 2, etc..
;		pHWCrtcCXOffset		HWCRTCCX ptr
;
; Returns:	None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_LogdevDetachCrtc, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD	dwLogicalCRTCIndex
PARMD	pHWCrtcCXOffset
LOCALD	dwPitchInBytes
OPENPROC
	mov	ebx,pHWLogdevCXOffset
	mov	eax,dwLogicalCRTCIndex
	sub	ecx,ecx
	mov	ds:[ebx].HWLOGDEVCX.pHWCrtcCX[eax * 4],ecx

	; This HWCRTCCX no longer has a parent HWLOGDEVCX
	sub	eax,eax
	push	pHWCrtcCXOffset
	push    eax
	call	NV_CrtcSetLogdev
CLOSEPROC


;==============================================================================
;
; Function:     HW_Get16BppPixelFormat
;
; Purpose:      This function should return information about whether
;               the 16bpp mode is 1-5-5-5 or 5-6-5. Note that this is
;               not a per CRTC choice. It is per Logical Device choice.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:
;               eax     FIVE6FIVE if supporting 5-6-5
;                       0  if supporting 1-5-5-5
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_Get16BppPixelFormat, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     eax,FIVE6FIVE
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetTextFormat
;
; Purpose:      This function should return information about whether
;               the controller handles bit packed or byte packed
;               text. Bit packed is much better if you can support it.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:
;               eax     C1_BIT_PACKED
;                       or
;                       C1_BYTE_PACKED
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetTextFormat, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     eax,C1_BIT_PACKED
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWMONBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwmonblt.asm
;
; Purpose:      This file trasnfers mono system memory bitmaps or DIBS
;               to a dst video memory bitmap. The dst bitmap may be 8,
;               15, 16, or 32bpp. There may be a rop and pattern as well.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginSrcMonoDstVram
;
; Purpose:      This function is an easy way to implement mono
;               bitmap transfers. This routine gets called to do setup,
;               and then the HW_BlockSrcMonoDstVram gets called before
;               each chunk of lines is transferred, and finally the
;               function HW_EndSrcMonoDstVram is called when the main
;               routine is done. You need to do the following:
;
;               2) Set the Rop (which is the byte at dwRop3+2)
;
;               3) Set the hardware clipping rectangle to the coords
;                  (dwDstLeft, dwDstTop, dwDstLeft+dwExtX, dwDstTop+dwExtY)
;
;               4) Set the starting destination coordinates to be:
;                  dwAlignedDstLeft, dwDstTop
;
;               5) Set the extents of the transfer. The number of pixels
;                  sent in per line will always be a multiple of 32 and
;                  is given by the parameter dwAlignedSrcExtXInPixels.
;                  Of course, the number of pixels to be written to the
;                  dst rectangle is given by the paramter dwExtX. The
;                  number of scanlines sent in is the same as the number
;                  to be displayed and is given by dwExtY.
;
;               6) Program in the colors to which to expand the bits
;                  in the mono src. These colors should NOT be used
;                  to expand mono bits in a mono pattern if a pattern
;                  is involved. The DRAWMODE TextColor and bkColor
;                  are to be used for that. The generic code would
;                  already have called HW_LoadXXXPattrn to load the
;                  pattrn properly if one were involved.
;
;               7) Program the base and pitch of the dst bitmap which are:
;                  dwDstBitsOffset, dwDstPitch
;
;               8) Anything else you need to do to prepare the
;                  hardware for a transfer of the src bitmap.
;
;               9) You must return three important values to the generic
;                  code. One is a pseudo wrap width.  The second is the
;                  maximum number of bytes you can handle in a single
;                  transfer (without waiting or writing new header info,
;                  or whatever the hardware requires.) The third is
;                  your hardware ptr (either MMIO or DMA buffer.)
;
;                  Here is how it works:
;
;                  When you return from this routine, you should have
;                  es:edi pointing to either the next location in the
;                  DMA buffer if you are DMA based, or pointing to the
;                  MMIO area if you are fifo based.
;
;                  The generic code will call HW_BlockSrcMonoDstVram
;                  and have it wait for enough fifo slots or DMA buffer
;                  space. HW_BlockSrcMonoDstVram will return a ptr to
;                  the generic code telling it where to begin writing
;                  pixels. The generic code starts xlatting and copying
;                  pixels incrementing this ptr as it goes. When the
;                  generic code reaches the end of a scanline, it will
;                  add in the pseudo wrap width you returned to the current
;                  value of the ptr and begin transferring pixels on
;                  the next scanline at this new address. If the
;                  generic code reaches the maximum number of pixels
;                  that can be handled in a single transfer (which was
;                  the second parameter you returned) before transferring
;                  the whole bitmap, it will call the block routine
;                  HW_BlockSrcMonoDstVram again to both wait for more
;                  space and get a new dst ptr.
;
;                  So what exactly should these return values be?
;
;                  For a fifo based part like NV3/ZX, the pseudo wrap width
;                  should be -dwAlignedSrcExtXInBytes -- this is the
;                  negative of one of the locals on the predefined frame.
;                  The maximum single transfer size should be 128 bytes
;                  (or whatever the size of the fifo is in bytes.)
;
;                  For a DMA based part like NV4, the pseudo wrap width
;                  should be 0. This will mean that the data for
;                  the next scanline will fall 0 bytes after the end
;                  of the data for the previous scanline -- exactly
;                  what is needed for DMA buffer sceanrios. The
;                  maximum single transfer size in bytes for DMAs is
;                  the size of the method to which the mono pixels
;                  will be written. (Or the size of the DMA buffer if
;                  it is smaller, but for other driver policy reasons,
;                  the DMA buffer must be more than twice the size of
;                  the largest method so go with the method size.)
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;               dwDstBitsOffset         base address of dst bitmap in VRAM
;               dwDstPitch              pitch of dst bitmap in VRAM
;               dwDstBpp                bpp of dst bitmap (be 8,15,16,or 32)
;               dwDstLeft               left edge coord of dst clip rectangle
;               dwDstTop                top edge coord of dst rectangle
;               dwAlignedDstLeft        left edge of unclipped dst rectangle
;               dwExtX                  width of dst rectangle in pixels
;               dwExtY                  height of dst rectangle in scanlines
;               dwAlignedSrcExtXInBytes number of bytes transferred per
;                                       line - will always be a multiple of 4
;               dwAlignedSrcExtXInPixels number of pixels sent per src line
;                                       -- will always be a multiple of 32 so
;                                       the lines have a multiple of 4 bytes
;               dwPixelsIgnoredOnLeft   number of pixels (bits) of the
;                                       src to be ignored. i.e. ignore this
;                                       many pixels, then then next dwExtX
;                                       pixels should be expanded and placed
;                                       in the dst beginning at the dwDstLeft
;                                       coord. There will be some pixels on
;                                       the right to be ignored also. The
;                                       number of these is:
;                                       dwAlignedSrcExtXInPixels - dwExtX -
;                                       dwPixelsIgnoredOnLeft.
;               dwBgColor               expand 0 bits in src to this color
;               dwFgColor               expand 1 bits in src to this color
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               dwRop3                  rop 3 in Microsoft rop format
;               dwRopFlags              one of NOROP, OND, PAD, SAD, PSD
;                                       See file gngdi.inc for definitions
;                                       and description above for purpose.
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  - The pseudo wrap width
;                       ecx  - The max single transfer size in bytes
;                       edi  - push buffer offset
;                       es   - whatever you want (probably CXSel)
;                       See the discussion under purpose for more
;                       info about these return values.
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginSrcMonoDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsOffset
PARMD   dwDstPitch
PARMD   dwDstBpp
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwAlignedDstLeft
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwAlignedSrcExtXInBytes
PARMD   dwAlignedSrcExtXInPixels
PARMD   dwPixelsIgnoredOnLeft
PARMD   dwBgColor
PARMD   dwFgColor
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwRop3
OPENPROC
        PUSHR   esi

        mov     edx,pHWLogdevCXOffset
        mov     esi,ds:[edx].HWLOGDEVCX.pHWBoardCX

        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,dwDstPitch

        ; Prepare for a src transfer
        CHECKDMASPACE ds,esi,edi,3CH
        mov	eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov	ebx,ds:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov	ecx,ds:[edx].HWLOGDEVCX.dwPatternAlpha1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr dwRop3+2
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwRectAndTextColorFormat
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,CHNRUN(RectAndText.ClipPoint0E,7)
        mov     ecx,dwExtY
        mov     ebx,dwDstTop
        shl     ecx,10H
        shl     ebx,10H
        mov     bx,word ptr dwDstLeft
        mov     cx,word ptr dwExtX
        add     ecx,ebx
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     ds:[edi + 24H],ecx
        mov     eax,dwBgColor
        mov     ebx,dwFgColor
        or      eax,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        or      ebx,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ebx
        mov     eax,dwExtY
        mov     ebx,dwDstTop
        shl     eax,10H
        shl     ebx,10H
        mov     ecx,eax
        mov     bx,word ptr dwAlignedDstLeft
        mov     ax,word ptr dwExtX
        mov     cx,word ptr dwAlignedSrcExtXInPixels
        add     ax,word ptr dwPixelsIgnoredOnLeft
        mov     ds:[edi + 30H],ecx
        mov     ds:[edi + 34H],eax
        mov     ds:[edi + 38H],ebx
        add     edi,3CH
        mov     ds:[esi].HWBOARDCX.pCurrentPushBufferOffset,edi

        ; I need to return a few things
        sub     ebx,ebx         ; pseudo wrap width is 0
        mov     ecx,80H * 4     ; size of mono transfer method
        mov     ax,ds
        mov     es,ax
Done:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockSrcMonoDstVram
;
; Purpose:      This function is an easy way to implement mono
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcMonoDstVram eariler
;               in this file.
;
;               Here, wait for eax bytes of space in the DMA buffer or
;               in the fifo. You may adjust es:edi to whatever you wish.
;               Hence, if you need to wrap the DMA buffer, you may do
;               do and then reset es:edi to the start of the buffer.
;               The generic code never touches es and only adjusts edi
;               by incrementing it appropriately for every dst pixel
;               that is transferred.
;
; Arguments:
;               es      Context Seletor
;               eax     bytes to wait for
;               esi     pHWBoardCX
;               edi     push buffer ptr
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcMonoDstVram time.
;               es:edi must point to the location for the generic code
;               to copy the next eax bytes of dst pixels translated from
;               src pixels.
;
; Preserve:     ds
;==============================================================================
DECPROC HW_BlockSrcMonoDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
        shrd    ecx,eax,10H
        lea     edx,[eax + 4]
        mov     cx,CHNRUN(RectAndText.MonochromeColor01E,0)
        CHECKDMASPACE es,esi,edi,edx
        mov     es:[edi],ecx
        add     edi,4
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndSrcMonoDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcMonoDstVram eariler
;               in this file.
;
;               You may do anything you wish to here. There is nothing
;               specifically required. Some possibiliites are:
;               1) Bump the DMA ptr if you are DMA based
;               2) Reset the hardware clip rect if that was needed.
;
; Arguments:
;               es      Context Selector
;               esi     pHWBoardCX
;               edi     es has not changed since the last call to
;                       HW_BlockSrcMonoDstVram and edi has only
;                       changed by being incremented for each dst
;                       pixel transferred.
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcMonoDstVram time.
;
; Preserve:     ds
;==============================================================================
DECPROC HW_EndSrcMonoDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWRECT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwrect.asm
;
; Purpose:      This file contains a special sequence of three hardware
;               routines which the generic code calls frequently. They
;               are used for ropping a patterned rectangle into a dst
;               bitmap.
;
;==============================================================================
.586
incLogical = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bConvertRop2ToRop3
bConvertRop2ToRop3      LABEL   BYTE
DB      000H,   005H,   00AH,   00FH
DB      050H,   055H,   05AH,   05FH
DB      0A0H,   0A5H,   0AAH,   0AFH
DB      0F0H,   0F5H,   0FAH,   0FFH

;==============================================================================
;
; Function:     HW_DrawRectAndBorder
;
; Purpose:      This function will be called by the generic code to have
;               the hardware draw a rectangle and/or its border int a
;               random bitmap. There is a rop and maybe a clip rect.
;               If the rectangle should be filled, the generic code will
;               already have called one of the pattern load routines to
;               put the appropriate fill pattern into the hardware
;               before calling this routine. Hence, program the dst
;               base, pitch, clip rect, rop, and issue the blt. Once
;               that is done, the border is always drawn in the solid
;               color, dwSolidBorderColor with the same rop at the
;               border coordinates given.
;
; Arguments:
;               ds                      CXSel
;               pHWLogDevCXOffset       HWLOGDEVCX ptr
;               dwDstBase               offset of dst bitmap in video memory
;               dwDstPitch              pitch of dst bitmap in video memory
;               dwRop2                  two operand Rop (1 based)
;               wClipBottom             clip rectangle
;               wClipRight              if there is no clip rect then
;               wClipTop                wClipLeft = wClipTop = 0   and
;               wClipLeft               wclipRight = wClipBottom = 7FFF
;               dwDrawBorder            0       then no border,
;                                       non-0   then there is a border
;               dwSolidBorderColor      border color
;               wBorderBottom           border rectangle.
;               wBorderRight
;               wBorderTop
;               wBorderLeft
;               dwDrawInterior          non-0 then draw inside, 0 then don't
;               wRectBottom             Rectangle coordinates
;               wRectRight
;               wRectTop
;               wRectLeft
;
;               Using the border rect, draw the following four edges
;               as the border
;               inclusive       to      exclusive
;               (left,top)      to      (right,top+1)
;               (right-1,top+1) to      (right,bottom)
;               (left,top+1)    to      (left+1,bottom-1)
;               (left,bottom-1) to      (right-1,bottom)
;
; Returns:      eax             0       Punt to Dibeng
;                               non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC HW_DrawRectAndBorder, PASCAL, FRAME, NEAR
PARMD   pHWLogDevCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
PARMD   dwRop2
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
PARMD   dwDrawBorder
PARMD   dwSolidBorderColor
PARMW   wBorderBottom
PARMW   wBorderRight
PARMW   wBorderTop
PARMW   wBorderLeft
PARMD   dwDrawInterior
PARMW   wRectBottom
PARMW   wRectRight
PARMW   wRectTop
PARMW   wRectLeft
OPENPROC
        ; Load up the logical device CX and the board CX
        mov     esi,pHWLogDevCXOffset
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX

        ; Restore the pattern alpha to -1 in stucture. It may have been 
	; changed because this output call used	a hatch brush with a 
	; transparent background.
        mov      ds:[esi].HWLOGDEVCX.dwPatternAlpha0,-1

        ; sync with other channels
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBase
        CHECKDSTBASE ds,ebx,edi,eax,<dwDstPitch>

        ; Set the Rop, ColorFormat and Local Clip Rect
        CHECKDMASPACE ds,ebx,edi,10H
        mov     eax,dwRop2
        mov     ecx,ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat
        movzx   eax,cs:bConvertRop2ToRop3[eax - 1]
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextRop.SetRop5,1)
        mov     dword ptr ds:[edi + 04H],eax
        mov     dword ptr ds:[edi + 08H],CHNRUN(RectAndText.SetColorFormat,1)
        mov     dword ptr ds:[edi + 0CH],ecx
        add     edi,10H

        cmp     dwDrawInterior,0
        je      DoneInterior

        CHECKDMASPACE ds,ebx,edi,18H
        mov     eax,dword ptr wClipLeft
        mov     ecx,dword ptr wClipRight
        mov     dword ptr ds:[edi + 00H],CHNRUN(RectAndText.ClipPoint0B,5)
        mov     ds:[edi + 04H],eax
        mov     ds:[edi + 08H],ecx

        ; The Color1B value is irrelevant but must be written
        mov     ds:[edi + 0CH],eax

        mov     eax,dword ptr wRectLeft
        mov     ecx,dword ptr wRectRight
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        add     edi,18H

DoneInterior:
        cmp     dwDrawBorder,0
        je      DoneIt

        CHECKDMASPACE ds,ebx,edi,40H

        ; The format of the rop we have set requires that we use the
        ; image pattern sub-channel rather than the solid color field
        ; in the rect and text object for the solid color border.
        mov     edx,dwSolidBorderColor
        mov     eax,CHNRUN(ContextPattern.SetPatternSelect,3)
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        or      edx,ds:[esi].HWLOGDEVCX.dwColorAlphaMask
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],edx

        ; Now we need to reset the clip rect in RectAndText since we
        ; switched the sub-channel and the volatile data was lost.
        mov     eax,CHNRUN(RectAndText.ClipPoint0B,11)
        mov     ecx,dword ptr wClipLeft
        mov     edx,dword ptr wClipRight
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        mov     ds:[edi + 18H],edx
        mov     ds:[edi + 1CH],eax  ; Solid color irrelevant but required

        ; Program up the coordinates for the 4 borders edges
        movzx   eax,wBorderLeft
        movzx   ebx,wBorderTop
        movzx   ecx,wBorderRight
        movzx   edx,wBorderBottom

        ; (left,top)      to      (right,top+1)
        mov     ds:[edi + 20H],ax               ; left
        mov     ds:[edi + 22H],bx               ; top
        inc     ebx
        mov     ds:[edi + 24H],cx               ; right
        mov     ds:[edi + 26H],bx               ; top + 1

        ; (right-1,top+1) to      (right,bottom)
        dec     ecx
        mov     ds:[edi + 28H],cx               ; right - 1
        mov     ds:[edi + 2AH],bx               ; top + 1
        inc     ecx
        mov     ds:[edi + 2CH],cx               ; right
        mov     ds:[edi + 2EH],dx               ; bottom

        ; (left,top+1)    to      (left+1,bottom-1)
        mov     ds:[edi + 30H],ax               ; left
        mov     ds:[edi + 32H],bx               ; top + 1
        inc     eax
        dec     edx
        mov     ds:[edi + 34H],ax               ; left + 1
        mov     ds:[edi + 36H],dx               ; bottom - 1

        ; (left,bottom-1) to      (right-1,bottom)
        dec     eax
        mov     ds:[edi + 38H],ax               ; left
        mov     ds:[edi + 3AH],dx               ; bottom - 1
        dec     ecx
        inc     edx
        mov     ds:[edi + 3CH],cx               ; right - 1
        mov     ds:[edi + 3EH],dx               ; bottom

        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        add     edi,40H

DoneIt:
        SETPUTPTR ds,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BeginRect
;
; Purpose:      Before calling this function, the generic code will have
;               called a LoadPattern function to load a solid, mono, or
;               color pattern into the pattern registers. After that,
;               this function will be called by the generic code to have
;               the hardware prepare for receiving a list of rectangles.
;               This routine should set the rop, the clip rect, and set
;               the dst base and pitch in preparation for a random number
;               (including 0) of HW_BlockRect calls. When the generic code
;               is done drawing all the rectangles via HW_BlockRect,
;               it will call the HW_EndRect routine to allow the hardware
;               specific code to clean up after itself.
;
; Arguments:
;               ds                      CXSel
;               pHWLogDevCXOffset       HWLOGDEVCX ptr
;               dwDstBase               offset of dst bitmap in video memory
;               dwDstPitch              pitch of dst bitmap in video memory
;               dwRop2                  two operand Rop (1 based)
;               wClipBottom             clip rectangle
;               wClipRight              if there is no clip rect then
;               wClipTop                wClipLeft = wClipTop = 0   and
;               wClipLeft               wclipRight = wClipBottom = 7FFF
;
; Returns:
;               eax             0       Punt to Dibeng
;                               non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC HW_BeginRect, PASCAL, FRAME, NEAR
PARMD   pHWLogDevCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
PARMD   dwRop2
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
OPENPROC
        ; Load up the logical device CX and the board CX
        mov     esi,pHWLogDevCXOffset
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX

        ; sync with other channels
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBase
        CHECKDSTBASE ds,ebx,edi,eax,<dwDstPitch>

        ; Set the Rop, ColorFormat and Local Clip Rect
        CHECKDMASPACE ds,ebx,edi,20H
        mov     eax,dwRop2
        mov     ecx,ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat
        movzx   eax,cs:bConvertRop2ToRop3[eax - 1]
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextRop.SetRop5,1)
        mov     dword ptr ds:[edi + 04H],eax
        mov     dword ptr ds:[edi + 08H],CHNRUN(RectAndText.SetColorFormat,1)
        mov     dword ptr ds:[edi + 0CH],ecx
        mov     eax,dword ptr wClipLeft
        mov     ecx,dword ptr wClipRight
        mov     dword ptr ds:[edi + 10H],CHNRUN(RectAndText.ClipPoint0B,3)
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx

        ; The Color1B field value is irrelevant but it must be written
        mov     ds:[edi + 1CH],eax
        add     edi,20H

        mov     ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockRect
;
; Purpose:      This function can be called a random number of times
;               after HW_BeginRect is called and before HW_EndRect is
;               called. See Purpose under HW_BeginRect for more details.
;
; Arguments:
;               ds      CXSel
;               edi     HWLOGDEVCX ptr
;               eax     top:left of rectangle to draw
;               ebx     bottom:right of rectangle to draw
;
; Returns:      None
;
; Preserve:     ds,es,esi,edi,eax,ebx
;==============================================================================
DECPROC HW_BlockRect, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   edi

        ; Load the push buffer ptr
        mov     ecx,ds:[edi].HWLOGDEVCX.pHWBoardCX
        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        mov     edx,CHNRUN(RectAndText.ClippedRectangle.point0,2)
        CHECKDMASPACE ds,ecx,edi,0CH
        mov     ds:[edi + 00H],edx
        mov     ds:[edi + 04H],eax
        mov     ds:[edi + 08H],ebx
        add     edi,0CH
        mov     ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset,edi

        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndRect
;
; Purpose:      This function will get called after some random number
;               of HW_BlockRect calls. See Purpose
;               under HW_BeginRect for more details.
;
;               You can do whatever you want to do in here. Probably
;               reset the hardware clip rect if one was needed or
;               bump the DMA ptr or whatever.
;
; Arguments:
;               ds      CXSel
;               edi     HWLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_EndRect, PASCAL, NOFRAME, NEAR
OPENPROC

        ; Restore the pattern alpha to -1. It may have been changed
        ; via a hwldpat.asm call prior to the HW_BeginRect call. It
        ; also may have been changed because this output call used
        ; a hatch brush with a transparent background.
        mov     ecx,-1
        mov     ds:[edi].HWLOGDEVCX.dwPatternAlpha0,ecx

        ; Load the push buffer ptr
        mov     ebx,ds:[edi].HWLOGDEVCX.pHWBoardCX
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,1)
        CHECKDMASPACE ds,ebx,edi,08H
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        add     edi,08H

        ; Don't need to reset clip rect here because I use the local
        ; clip rect for this sequence which will get cleared by any
        ; sub-channel change. Hence, just bang the put ptr.
        SETPUTPTR ds,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SolidColorRectangle
;
; Purpose:      This function draws a solid color rectangle gievn
;               the coordinates and rop as below. No clipping
;               is done.
;
; Arguments:
;               ds              Context Selector
;               eax             left:top
;               ebx             width:height
;               ecx             dwRop2
;               edx             physical color
;               edi             HWLOGDEVCX ptr
;               gs:esi          DIBENGINEHDR of bitmap in which to draw
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
DECPROC HW_SolidColorRectangle, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Save the color
        or      edx,ds:[edi].HWLOGDEVCX.dwColorAlphaMask

        ; Save the color format for later use.
        push    ds:[edi].HWLOGDEVCX.dwRectAndTextColorFormat

        ; remap the rop

        movzx   ecx,cs:bConvertRop2ToRop3[ecx - 1]
        push    ecx

        ; Save the pattern alpha
	push	edx
	push	edx
	mov	ds:[edi].HWLOGDEVCX.dwPatternAlpha0,edx
	mov	ds:[edi].HWLOGDEVCX.dwPatternAlpha1,edx

        mov     ecx,ds:[edi].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ecx,edx

        ; Load the push buffer ptr
        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     edx,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ecx,edi,edx,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; Check for space and program the blt
        CHECKDMASPACE ds,ecx,edi,30H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetPatternSelect,3)
        mov     dword ptr ds:[edi + 04H],NV044_SET_PATTERN_SELECT_MONOCHROME
        pop     dword ptr ds:[edi + 08H]
        pop     dword ptr ds:[edi + 0CH]
        mov     dword ptr ds:[edi + 10H],CHNRUN(ContextRop.SetRop5,1)
        pop     dword ptr ds:[edi + 14H]
        mov     dword ptr ds:[edi + 18H],CHNRUN(RectAndText.SetColorFormat,1)
        pop     dword ptr ds:[edi + 1CH]
        mov     dword ptr ds:[edi + 20H],CHNRUN(RectAndText.Color1A,3)
        mov     dword ptr ds:[edi + 24H],0
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ebx
        add     edi,30H
        SETPUTPTR ds,ecx,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\hwstrblt.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwclrblt.asm
;
; Purpose:      This file stretches color bitmaps or DIBs from system
;               memory to video memory. The src color Bitmap can be
;               4, 8, 15, 16, 24, 32 bpp, and, the dst video memory
;               bitmap can be 8, 15, 16, or 32 bpp. There may be
;               a rop and a pattern as well.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwgdi.inc
include hwmacs.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginStretchSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap stretch. This routine gets called to do setup,
;               and then the HW_BlockStretchSrcColorDstVram gets called before
;               each chunk of lines is transferred, and finally the
;               function HW_EndStretchSrcColorDstVram is called when the main
;               routine is done. You need to do the following:
;
;               2) Set the Rop (which is the byte at dwRop3+2)
;
;               3) Set the starting destination coordinates to be:
;                  dwDstTop, dwDstLeft
;
;               4) Set the extents of the transfer which are:
;                  dwExtX, dwExtY
;
;                  Note that the number of pixels sent for each scan
;                  will not necessarily be dwExtX, but will be instead
;                  dwExtXAligned. dwExtXAligned is equal to dwExtX plus
;                  from 0 to 3 extra pixels required to make the byte
;                  length of a transferred scan a multiple of a dword.
;                  dwExtX is simply the dst rectangle width in pixels.
;                  If there are any extra pixels beyond dwExtX, they
;                  should be dropped by the hardware. That may mean
;                  you need to tell the hardware the blt width is
;                  really dwExtXAligned and set a hardware clip rect.
;
;               5) Program the base and pitch of the dst bitmap which are:
;                  dwDstBitsOffset, dwDstPitch
;
;               6) Anything else you need to do to prepare the
;                  hardware for a transfer of the src bitmap.
;
;               7) You must return three important values to the generic
;                  code. One is a pseudo wrap width.  The second is the
;                  maximum number of bytes you can handle in a single
;                  transfer (without waiting or writing new header info,
;                  or whatever the hardware requires.) The third is
;                  your hardware ptr (either MMIO or DMA buffer.)
;
;                  Here is how it works:
;
;                  When you return from this routine, you should have
;                  es set to your hardware selector.
;
;                  The generic code will call HW_BlockStretchSrcColorDstVram
;                  and have it wait for enough fifo slots or DMA buffer
;                  space. HW_BlockStretchSrcColorDstVram will return a ptr to
;                  the generic code telling it where to begin writing
;                  pixels. The generic code starts xlatting and copying
;                  pixels incrementing this ptr as it goes. When the
;                  generic code reaches the end of a scanline, it will
;                  add in the pseudo wrap width you returned to the current
;                  value of the ptr and begin transferring pixels on
;                  the next scanline at this new address. If the
;                  generic code reaches the maximum number of pixels
;                  that can be handled in a single transfer (which was
;                  the second parameter you returned) before transferring
;                  the whole bitmap, it will call the block routine
;                  HW_BlockStretchSrcColorDstVram again to both wait for more
;                  space and get a new dst ptr.
;
;                  So what exactly should these return values be?
;
;                  For a fifo based part like NV3/ZX, the pseudo wrap width
;                  should be -dwExtAligned * (dwDstBpp which is simply the
;                  negative of one of the locals on the predefined frame.
;                  The maximum single transfer size should be 128 bytes
;                  (or whatever the size of the fifo is in bytes.)
;
;                  For a DMA based part like NV4, the pseudo wrap width
;                  should be somewhere near 0 -- what does this mean?
;                  What we would like is for the next scanline's data to
;                  immediately follow the preceeding scanline's data.
;                  You might think that this implies the pseudo wrap
;                  width is 0. However, we will need to play with the
;                  dwExtX and dwExtXAligned to see if this is true.
;                  If dwExtX and dwExtXAligned are equal, the pseudo
;                  wrap width should be 0. If dwExtXAligned is greater
;                  (it can't be less since it is equal to dwExtX
;                  rounded up to the next number of pixels which gives
;                  a dword aligned scanline length), then the pseudo
;                  wrap width should be
;                  (dwExtXAligned - dwExtX) * dwDstBytesPerPixel
;
;                  The maximum single transfer size in bytes for DMAs is
;                  the size of the method to which the color pixels
;                  will be written. (Or the size of the DMA buffer if
;                  it is smaller, but for other driver policy reasons,
;                  the DMA buffer must be more than twice the size of
;                  the largest method so go with the method size.)
;
; Arguments:
;               ds                      Context Sel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwDstBitsOffset         offset of dst bitmap in VRAM
;               dwDstPitch              pitch of dst bitmap in VRAM
;               dwDstBpp                bpp of dst bitmap (8,15,16,or 32)
;               dwDstLeft               left edge coord of dst rectangle
;               dwDstTop                top edge coord of dst rectangle
;               dwExtDstX               width of dst rectangle in pixels
;               dwExtDstY               height of dst rectangle in scanlines
;               dwExtSrcX               width of src rectangle in pixels
;               dwExtSrcY               height of dst rectangle in scanlines
;               dwExtSrcXAligned        aligned width of src rectangle in pixels
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               dwRop3                  rop 3 in Microsoft rop format
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  - The pseudo wrap width
;                       ecx  - The max single transfer size in bytes
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginStretchSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsOffset
PARMD   dwDstPitch
PARMD   dwDstBpp
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwExtDstX
PARMD   dwExtDstY
PARMD   dwExtSrcX
PARMD   dwExtSrcY
PARMD   dwExtSrcXAligned
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwRop3
PARMD   lpClipRect
OPENPROC
        mov     edx,pHWLogdevCXOffset
        mov     esi,ds:[edx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,dwDstPitch

        ; Prepare for a src transfer
        CHECKDMASPACE ds,esi,edi,48H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov     ecx,ds:[edx].HWLOGDEVCX.dwPatternAlpha1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr dwRop3+2
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(StretchedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_STRETCHED_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx

        mov     eax,CHNRUN(StretchedImageFromCpu.SetColorFormat,1)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwImageFromCpuColorFormat
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     eax,CHNRUN(StretchedImageFromCpu.dwSizeIn,3)
        mov     ds:[edi + 24H],eax
        mov     ebx,dwExtSrcY
        mov     eax,dwExtSrcXAligned
	shl	ebx,10H
	mov	bx,ax
        mov     ds:[edi + 28H],ebx
	mov	eax,dwExtDstX
	mov	ecx,dwExtSrcX
	shl	eax,20
	sub	edx,edx
	idiv	ecx
        mov     ds:[edi + 2CH],eax
	mov	eax,dwExtDstY
	shl	eax,20
	mov	ecx,dwExtSrcY
	sub	edx,edx
	idiv	ecx
        mov     ds:[edi + 30H],eax
        mov     eax,CHNRUN(StretchedImageFromCpu.ClipPoint,2)
	sub	edx,edx
	mov	ebx,-1
	cmp	lpClipRect,edx
	je	@F
	lgs	dx,lpClipRect
        mov	ebx,dword ptr gs:[edx].RECT.right
        mov	edx,dword ptr gs:[edx].RECT.left
	sub	ebx,edx
@@:
        mov     ds:[edi + 34H],eax
        mov     ds:[edi + 38H],edx
        mov     ds:[edi + 3CH],ebx
        mov     eax,CHNRUN(StretchedImageFromCpu.Point12d4,1)
        mov     ds:[edi + 40H],eax
	mov	eax,dwDstTop
	shl	eax,20
	mov	ebx,dwDstLeft
	shl	ebx,4
	mov	ax,bx
	add	eax,80008H
        mov     ds:[edi + 44H],eax
        add     edi,48H

        ; I need to return a few things
        mov     ebx,dwExtSrcXAligned
        sub     ebx,dwExtSrcX
        mov     ecx,dwDstBpp
        inc     ecx
        shr     ecx,3
        imul    ebx,ecx         ; pseudo wrap width
        mov     ecx,1792 * 4    ; size of color transfer method
        mov     ax,ds
        mov     es,ax
        mov     eax,1
Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockStretchSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginStretchSrcColorDstVram eariler
;               in this file.
;
;               Here, wait for eax bytes of space in the DMA buffer or
;               in the fifo. You may adjust es:edi to whatever you wish.
;               Hence, if you need to wrap the DMA buffer, you may do
;               do and then reset es:edi to the start of the buffer.
;               The generic code never touches es and only adjusts edi
;               by incrementing it appropriately for every dst pixel
;               that is transferred.
;
; Arguments:
;               es      Context Seletor
;               eax     bytes to wait for
;               esi     pHWBoardCX
;               edi     push buffer ptr
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginStretchSrcColorDstVram time.
;               es:edi must point to the location for the generic code
;               to copy the next eax bytes of dst pixels translated from
;               src pixels.
;
; Preserve:     ds,esi,fs,ebx
;==============================================================================
DECPROC HW_BlockStretchSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
        shrd    ecx,eax,10H
        lea     edx,[eax + 4]
        mov     cx,CHNRUN(StretchedImageFromCpu.Color,0)
        CHECKDMASPACE es,esi,edi,edx
        mov     es:[edi],ecx
        add     edi,4
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndStretchSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginStretchSrcColorDstVram eariler
;               in this file.
;
;               You may do anything you wish to here. There is nothing
;               specifically required. Some possibiliites are:
;               1) Bump the DMA ptr if you are DMA based
;               2) Reset the hardware clip rect if that was needed.
;
; Arguments:
;               es      Context Selector
;               esi     pHWBoardCX
;               edi     es has not changed since the last call to
;                       HW_BlockStretchSrcColorDstVram and edi has only
;                       changed by being incremented for each dst
;                       pixel transferred.
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginStretchSrcColorDstVram time.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_EndStretchSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWPATBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwpatblt.asm
;
; Purpose:      This file performs BitBlts involving just
;               the dst or the dst and a pattern.
;
;==============================================================================
.586
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bConvertPatDstToSrcDstRop
bConvertPatDstToSrcDstRop       LABEL   BYTE
DB      000h, 011h, 022h, 033h
DB      000h, 011h, 022h, 033h
DB      000h, 011h, 022h, 033h
DB      000h, 011h, 022h, 033h
DB      044h, 055h, 066h, 077h
DB      044h, 055h, 066h, 077h
DB      044h, 055h, 066h, 077h
DB      044h, 055h, 066h, 077h
DB      088h, 099h, 0AAh, 0BBh
DB      088h, 099h, 0AAh, 0BBh
DB      088h, 099h, 0AAh, 0BBh
DB      088h, 099h, 0AAh, 0BBh
DB      0CCh, 0DDh, 0EEh, 0FFh
DB      0CCh, 0DDh, 0EEh, 0FFh
DB      0CCh, 0DDh, 0EEh, 0FFh
DB      0CCh, 0DDh, 0EEh, 0FFh


;==============================================================================
;
; Function:     HW_BitBltSolidPatDstRop
;
; Purpose:      This function implements Bitblts that involve only
;               a pattern and dst and the pattern is a solid color.
;               At this point, all that needs to be done is to program
;               the chip for the blt.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWLOGDEVCX ptr
;               ecx             dwRop3
;               edx             physical color
;               gs:esi          lpDstDev
;
; Returns:      If you want to
;               report this     then do this
;               Success         jmp to GN_BitBltSuccess
;               Failure         jmp to GN_BitBltFail
;               Punt to DIBENG  jmp to GN_BitBltPunt
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltSolidPatDstRop, PASCAL, ShareFrameFar16, NEAR
BITBLT_FRAME_AND_LOCALS
OPENPROC
        ; Save the color format for later use.
        push    ds:[ebx].HWLOGDEVCX.dwRectAndTextColorFormat
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; Check for space and program the blt
        CHECKDMASPACE ds,ebx,edi,2CH
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ds:[edi + 00H],eax
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        shr     ecx,2
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,cs:bConvertPatDstToSrcDstRop[ecx]
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ds:[edi + 14H],eax
        pop     dword ptr ds:[edi + 18H]
        mov     eax,CHNRUN(RectAndText.Color1A,3)
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],edx
        mov     eax,dword ptr wDstY
        mov     ecx,dword ptr wExtY
        mov     ds:[edi + 24H],eax
        mov     ds:[edi + 28H],ecx
        add     edi,2CH
        SETPUTPTR ds,ebx,edi
        jmp     GN_BitBltSuccess
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitBltMonoPatDstRop
;
; Purpose:      This function implements Bitblts that involve only
;               a pattern and dst and the pattern is a mono pattern.
;               At this point, all that needs to be done is to program
;               the chip for the blt.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWLOGDEVCX ptr
;               gs:esi          lpDstDev
;               es:edi          ptr to pattern to load
;               wDstX,wDstY     dst upper left corner
;               wExtX,wExtY     extent of blt rectangle
;               eax             Color For 0 bits
;               ecx             Color For 1 bits
;
; Returns:      If you want to
;               report this     then do this
;               Success         jmp to GN_BitBltSuccess
;               Failure         jmp to GN_BitBltFail
;               Punt to DIBENG  jmp to GN_BitBltPunt
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltMonoPatDstRop, PASCAL, ShareFrameFar16, NEAR
BITBLT_FRAME_AND_LOCALS
OPENPROC
        ; Save the color format for later use.
        push    ds:[ebx].HWLOGDEVCX.dwRectAndTextColorFormat
        or      ecx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        or      eax,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        mov    	ds:[ebx].HWLOGDEVCX.dwPatternAlpha0,eax
        mov    	ds:[ebx].HWLOGDEVCX.dwPatternAlpha1,ecx
        push    ecx
        push    eax
        push    ds:[ebx].HWLOGDEVCX.dwPatternColorFormat

        mov	edx,edi
        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>
        mov	esi,edx

        ; Check for space and program the blt
        CHECKDMASPACE ds,ebx,edi,40H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetColorFormat,1)
        pop     dword ptr ds:[edi + 04H]
        mov     eax,CHNRUN(ContextPattern.SetPatternSelect,5)
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        pop     dword ptr ds:[edi + 10H]
        pop     dword ptr ds:[edi + 14H]
        mov     al,es:[esi + 08H]
        mov     cl,es:[esi + 18H]
        mov     ah,es:[esi + 0CH]
        mov     ch,es:[esi + 1CH]
        ror     eax,10H
        ror     ecx,10H
        mov     al,es:[esi + 00H]
        mov     cl,es:[esi + 10H]
        mov     ah,es:[esi + 04H]
        mov     ch,es:[esi + 14H]
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,byte ptr dwRop3+2
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ecx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ds:[edi + 28H],eax
        pop     dword ptr ds:[edi + 2CH]
        mov     eax,CHNRUN(RectAndText.Color1A,3)
        mov     ecx,dword ptr wDstY
        mov     edx,dword ptr wExtY
        mov     ds:[edi + 30H],eax

        ; The Color1A field next is irrelevant but the NV
        ; architecture requires that it at least be written.
        mov     ds:[edi + 34H],eax
        mov     ds:[edi + 38H],ecx
        mov     ds:[edi + 3CH],edx
        add     edi,40H
        SETPUTPTR ds,ebx,edi
        jmp     GN_BitBltSuccess
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitBltColorPatDstRop
;
; Purpose:      This function implements Bitblts that involve only
;               a pattern and dst and the pattern is a color pattern.
;               At this point, all that needs to be done is to program
;               the chip for the blt.
;
; Arguments:    ds:ebx          HWLOGDEV ptr
;               es:edi          lpBrush
;               gs:esi          lpDstDev
;               wDstX,wDstY     dst upper left corner
;               wExtX,wExtY     extent of blt rectangle
;
; Returns:      If you want to
;               report this     then do this
;               Success         jmp to GN_BitBltSuccess
;               Failure         jmp to GN_BitBltFail
;               Punt to DIBENG  jmp to GN_BitBltPunt
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltColorPatDstRop, PASCAL, ShareFrameFar16, NEAR
BITBLT_FRAME_AND_LOCALS
OPENPROC
        ; Save the Rect and Text color format for later use.
        push    ds:[ebx].HWLOGDEVCX.dwRectAndTextColorFormat

        ; Save these for later use.
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0
        push    ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        mov     ecx,ds:[ebx].HWLOGDEVCX.dwColorPatternAndHeaderSize
        mov     edx,ds:[ebx].HWLOGDEVCX.dwColorPatternMethodOffset

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; Setup and copy the color pattern into the chip
        CHECKDMASPACE ds,ebx,edi,ecx
        mov	eax,CHNRUN(ContextPattern.SetColorFormat,6)
        mov	esi,NV044_SET_MONOCHROME_FORMAT_CGA6_M1
        mov     ds:[edi + 00H],eax
        pop     dword ptr ds:[edi + 04H]
        mov	ds:[edi + 08H],esi
        mov	eax,NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov	esi,NV044_SET_PATTERN_SELECT_COLOR
        mov	ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],esi
        pop     dword ptr ds:[edi + 14H]
        pop     dword ptr ds:[edi + 18H]
        movzx   esi,word ptr lpBrush
        mov     ds:[edi + 1CH],edx
        sub     ecx,20H
        lea     esi,[esi].DIB_Brush8.dp8BrushBits
        add     edi,20H

@@:     mov     eax,es:[esi + 00H]
        mov     edx,es:[esi + 04H]
        add     esi,08H
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],edx
        add     edi,08H
        sub     ecx,08H
        jg      @B

        ; Now trigger the blt
        CHECKDMASPACE ds,ebx,edi,20H
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,byte ptr dwRop3+2
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     dword ptr ds:[edi + 08H],CHNRUN(RectAndText.SetColorFormat,1)
        pop     dword ptr ds:[edi + 0CH]
        mov     eax,CHNRUN(RectAndText.Color1A,3)
        mov     ecx,dword ptr wDstY
        mov     edx,dword ptr wExtY
        mov     ds:[edi + 10H],eax
        ; The color field next is irrelevant but NV architecture requires it
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx
        mov     ds:[edi + 1CH],edx
        add     edi,20H
        SETPUTPTR ds,ebx,edi
        jmp     GN_BitBltSuccess
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWTEXT.ASM ===
;==============================================================================
;
; Copyright (C) 1998,Nvidia Corporation
;
; File:         hwtext.asm
;
; Purpose:      This file implements the hardware specific text functions.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incFont     = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA,USE16,DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32,%DEF_CODE_SIZE,CODE

;==============================================================================
;
; Function:     HW_DrawOpaqueRects
;
; Purpose:      This function should draw any opaqueing rectangles
;               that exist. Do not do the text now -- that will be
;               done later.
;
;               NOTE: You may set es to anything you wish in this
;               routine and it will not get changed by the generic
;               for the duration of the ExtTextOut call.
;
; Arguments:    Display Driver ExtTextOut frame
;               es              CXSel
;               dwBgColor       the bgColor from the DRAWMODE struct
;                               opaque rects should be drawn in this color
;               wOpaqueClipRect opaque rectangles must be clipped to this
;                               rectangle. It is a RECT struct.
;
; Returns:      eax     0       then rest of ExtTextOut call will be punted
;                               It is not possible to support the text
;                               portion of the call unless you also support
;                               the opaqueing rects portion. However you
;                               can just support the opaqueing rects without
;                               handling the text part by failing TextBegin.
;                       non-0   then ExtTextOut continues
; Preserve:
;==============================================================================
DECPROC HW_DrawOpaqueRects,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        ; Load the board ptr
        mov     ebx,pHWBoardCXOffset_ForExtTextOut

        ; wait until everyone else goes idle, if they are idle now
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE es,ebx,eax

        ; load the push buffer ptr
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Get ready to do opaqueing rects
        sub     esi,esi
        lds     si,lpOpaqueRects

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE es,ebx,edi,eax,dwDstBitsDeltaScan
	mov	edx,pHWLogDevCXOffset_ForExtTextOut

        ; Set the clip rect,color and rop
        CHECKDMASPACE es,ebx,edi,2CH
        mov    	eax,es:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov	ecx,es:[edx].HWLOGDEVCX.dwPatternAlpha1
	mov	dword ptr es:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
	mov	es:[edi + 04H],eax
	mov	es:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     ecx,0CCH
        mov     es:[edi + 0CH],eax
        mov     es:[edi + 10H],ecx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ecx,pHWLogDevCXOffset_ForExtTextOut
        mov     ecx,es:[ecx].HWLOGDEVCX.dwRectAndTextColorFormat
        mov     es:[edi + 14H],eax
        mov     es:[edi + 18H],ecx
        mov     eax,CHNRUN(RectAndText.ClipPoint0B,3)
        mov     ecx,dword ptr wOpaqueClipRect.left
        mov     es:[edi + 1CH],eax
        mov     es:[edi + 20H],ecx
        mov     eax,dword ptr wOpaqueClipRect.right
        mov     ecx,dwBgColor
        mov     es:[edi + 24H],eax
        mov     es:[edi + 28H],ecx
        add     edi,2CH

        ; Draw all opaqeuing rects in the list
Loopy:  mov     edx,dword ptr ds:[esi].RECT.left
        mov     ecx,dword ptr ds:[esi].RECT.right
        add     esi,8
        cmp     cx,dx
        jle     Done
        cmp     ecx,edx
        jle     Done
        mov     eax,CHNRUN(RectAndText.ClippedRectangle.point0,2)
        CHECKDMASPACE es,ebx,edi,0CH
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     es:[edi + 08H],ecx
        add     edi,0CH
        jmp     Loopy
Done:
        SETPUTPTR es,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_TextBegin
;
; Purpose:      This function gets called by the generic code when
;               it is about to start processing glyphs. After you
;               receive this call,you will get some number of
;               HW_BltGlyph calls and finally a HW_EndText call.
;               The es register will not be changed by the generic
;               code between this routine and the call to HW_TextEnd.
;
; Arguments:    Display Driver ExtTextOut frame.
;               es              CXSel
;               dwFgColor       the fgColor from the DRAWMODE struct
;               dwBgColor       the bgColor from the DRAWMODE struct
;               wTextClipRect   opaque rectangles must be clipped to this
;                               rectangle. It is a RECT struct.
;
; Returns:      eax     0       then text portion will be punted
;                       non-0   then you must handle TextBlt and TextEnd
;
; Preserve:     ds,es
;==============================================================================
DECPROC HW_TextBegin,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        ; Load the board ptr
        mov     ebx,pHWBoardCXOffset_ForExtTextOut

        ; If there were opaqueing rects,some things are already setup
        cmp     lpOpaqueRects,0
        jne     PartialSetup

        ; We did not do opaque rectangles,so need complete setup.
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE es,ebx,eax

        ; load the push buffer ptr
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE es,ebx,edi,eax,dwDstBitsDeltaScan
	mov	edx,pHWLogDevCXOffset_ForExtTextOut

        ; Set the clip rect,color and rop
        CHECKDMASPACE es,ebx,edi,2CH
        mov    	eax,es:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov	ecx,es:[edx].HWLOGDEVCX.dwPatternAlpha1
	mov	dword ptr es:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
	mov	es:[edi + 04H],eax
	mov	es:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     edx,0CCH
        mov     es:[edi + 0CH],eax
        mov     es:[edi + 10H],edx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     edx,pHWLogDevCXOffset_ForExtTextOut
        mov     edx,es:[edx].HWLOGDEVCX.dwRectAndTextColorFormat
        mov     es:[edi + 14H],eax
        mov     es:[edi + 18H],edx
        mov     eax,CHNRUN(RectAndText.ClipPoint0F,3)
        mov     edx,dword ptr wTextClipRect.left
        mov     es:[edi + 1CH],eax
        mov     es:[edi + 20H],edx
        mov     eax,dword ptr wTextClipRect.right
        mov     edx,dwFgColor
        mov     es:[edi + 24H],eax
        mov     es:[edi + 28H],edx
        add     edi,2CH
        jmp     DoneIt

PartialSetup:
        ; Set the clip rect,color and rop
        CHECKDMASPACE es,ebx,NONE,10H
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndText.ClipPoint0F,3)
        mov     edx,dword ptr wTextClipRect.left
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     eax,dword ptr wTextClipRect.right
        mov     edx,dwFgColor
        mov     es:[edi + 08H],eax
        mov     es:[edi + 0CH],edx
        add     edi,10H
DoneIt:
        mov     es:[ebx].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_TextBlt
;
; Purpose:      This function is called to blt an individual glyph.
;               The es register has not changed from the value you
;               assigned to it in HW_TextBegin.
;
; Arguments:    Display Driver ExtTextOut frame
;               es      CXSel
;               ds:esi  points to first byte of glyph data
;               ebx     DstYOrg:DstXOrg
;               edx     DstYExtent:DstXExtent
;               ecx     Total number of bits in the glyph
;
; Preserve:     ds,fs,gs
;==============================================================================
DECPROC HW_TextBlt,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        mov     edi,pHWBoardCXOffset_ForExtTextOut

        ; See if there are more bytes than we can send out in one shot
        add     ecx,31
        shr     ecx,3
        and     cl,NOT 3
        cmp     ecx,200H
        ja      BreakIntoChunks

        lea     eax,[ecx + 0CH]
        CHECKDMASPACE es,edi,NONE,eax
        mov     edi,es:[edi].HWBOARDCX.pCurrentPushBufferOffset
        sub     eax,4
        shr     ecx,2
        shl     eax,10H
        add     edi,0CH
        mov     ax,CHNRUN(RectAndText.dwSizeC,0)
        mov     es:[edi - 0CH],eax
        mov     eax,pHWBoardCXOffset_ForExtTextOut
        mov     es:[edi - 08H],edx
        mov     es:[edi - 04H],ebx
        rep     movs dword ptr es:[edi],ds:[esi]
        mov     es:[eax].HWBOARDCX.pCurrentPushBufferOffset,edi
        ret

BreakIntoChunks:
        ; Set the width,height and position of the character
        CHECKDMASPACE es,edi,NONE,0CH
        mov     edi,es:[edi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndText.dwSizeC,2)
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     es:[edi + 08H],ebx
        add     edi,0CH
        mov     edx,ecx
        mov     eax,CHNRUN(RectAndText.MonochromeColor1C,80H)
        mov     ebx,pHWBoardCXOffset_ForExtTextOut
Loopy:
        mov     ecx,200H
        sub     edx,ecx
        jae     @F
        add     edx,ecx
        mov     ecx,edx
        shrd    eax,edx,10H
        mov     ax,CHNRUN(RectAndText.MonochromeColor1C,0)
        xor     edx,edx
@@:
        add     ecx,4
        CHECKDMASPACE es,ebx,edi,ecx
        sub     ecx,4
        mov     es:[edi + 00H],eax
        add     edi,4
        shr     ecx,2
        rep     movs dword ptr es:[edi],ds:[esi]
        or      edx,edx
        jg      Loopy
        SETPUTPTR es,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_TextEnd
;
; Purpose:      This function is called by the generic code after
;               all the individual glyphs have been bltted. You
;               will receive this call only if you received a
;               HW_TextBegin call. Do anything you need to do in
;               here to clean up after doing text.
;
; Arguments:    Display Driver ExtTextOut frame
;               es      CXSel
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_TextEnd,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        mov     ebx,pHWBoardCXOffset_ForExtTextOut
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR es,ebx,edi
CLOSEPROC

CLOSESEG _NVTEXT32
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWVRMBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwvrmblt.asm
;
; Purpose:      This file performs BitBlts involving a source when the
;               source and dst are both in video memory. The blt may
;               also involve a pattern but it does not have to.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BitBltSrcVramDstVram
;
; Purpose:      This function implements Bitblts that involve a source,
;               and both the source and dst are in video memory. There
;               may also be a pattern involved inthe rop, but there may
;               not be.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       GWLOGDEVCX ptr
;               lpDstDev                ptr to dst device (DIBENGINE format)
;               lpSrcDev                ptr to src device (DIBENGINE format)
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               wDstX                   dst left edge coord
;               wDstY                   dst top  edge coord
;               wSrcX                   src left edge coord
;               wSrcY                   src top  edge coord
;               wExtX                   width of blt rectangle
;               wExtY                   height of blt rectangle
;               dwRop3                  rop in standard Microsoft format
;               dwRopFlags              one of: NOROP, OND, PAD, SAD, PSD
;                                       which are defined in gngdi.inc
;
; Returns:
;               If you want to
;               report this     then do this
;               Success         eax should be set to a number > 0
;               Failure         eax should be set equal to 0
;               Punt to DIBENG  eax should be set to a number < 0
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BitBltSrcVramDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   lpDstDev
PARMD   lpSrcDev
PARMD   lpBrush
PARMD   lpDrawMode
PARMW   wDstX
PARMW   wDstY
PARMW   wSrcX
PARMW   wSrcY
PARMW   wExtX
PARMW   wExtY
PARMD   dwRop3
OPENPROC
        PUSHR   esi,edi

        ; Load the board ptr
        mov     esi,pHWLogdevCXOffset
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha0

        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        sub     ecx,ecx

        ; Set the src base and pitch if need be
        sub     edx,edx
        les     dx,lpSrcDev
        mov     eax,es:[edx].DIBENGINEHDR.deBitsOffset
        cmp     eax,ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset
        je      Skip
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset,eax
        mov     eax,es:[edx].DIBENGINEHDR.deDeltaScan
        mov     word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,ax
        mov     ecx,1
Skip:
        ; Set the dst base and pitch if need be
        sub     edx,edx
        les     dx,lpDstDev
        mov     eax,es:[edx].DIBENGINEHDR.deBitsOffset
        cmp     eax,ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset
        je      Skip1
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        mov     eax,es:[edx].DIBENGINEHDR.deDeltaScan
        mov     word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch+2,ax
        mov     ecx,1
Skip1:
        or      ecx,ecx
        je      @F
        movzx   eax,word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch+2
        push    esi
        push    ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset
        push    eax
        call    SetDstBaseAndPitchToDsEdi
@@:
        ; Now fire off the blt
        CHECKDMASPACE ds,esi,edi,24H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr [dwRop3 + 2]
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(ImageBlit.ControlPointIn,3)
        mov     ebx,dword ptr wSrcY
        ror     ebx,10H
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,dword ptr wDstY
        mov     ebx,dword ptr wExtY
        ror     eax,10H
        ror     ebx,10H
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        add     edi,24H
        SETPUTPTR ds,esi,edi

        mov     eax,1
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWSYSBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwsysblt.asm
;
; Purpose:      This file has routines that assist the generic code
;               in doing blts involving a src in video memory and
;               a dst in system memory. There may be a pattern involved
;               with the rop as well, but there may not be.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginSrcVramDstSystem
;
; Purpose:      This function is an easier way to implement blts from
;               video memory back to system memory. The generic code
;               actually orchestrates the process. First it calls this
;               routine to do setup. The the generic code will make
;               some number of calls to HW_BlockSrcVramDstSystem and
;               HW_WaitSrcVramDstSystem which will DMA a chunk of the
;               src back into system memory and wait for its completion.
;               The generic code assumes you have at least two buffers
;               so that it can overlap the DMAing of one with the
;               processing of the other.
;               The generic code processes each chunk ropping it
;               into place in the dst bitmap. Finally when the entire
;               src has been transferred, the generic code calls the
;               routine HW_EndSrcVramDstSystem so the hardware specific
;               code can do cleanup. You will need to do the following
;               in this routine:
;
;               1) Anything special you need to do to prepare the
;                  hardware for multiple DMA transfers.
;
;               2) Compute and return the following three things needed by
;                  the generic code:
;                  dwTransferBufferPitchInBytes -- this is the byte width
;                       of a single scan of the DMAed bitmap. The generic
;                       code knows the dwExtX and the dwSrcBpp, but the
;                       hardware may wish to pad each line out to a
;                       multiple of a dword or a quadword or whatever.
;                       Since the generic code is doing the actual copy
;                       and ropping of the transferred data with the dst,
;                       it needs to know the transfer area pitch.
;                  dwMaxScanlinesPerTransfer -- just in case there is a
;                       limit on how many this can be. For example, the
;                       hardware may only be able to handle up to a
;                       certain number of lines or bytes in a transfer.
;                       Alternatively, the transfer area may have a
;                       limited size. Based upon the variable computed
;                       above, dwTransferBufferPitchInBytes, only some
;                       certain number of scans may fit in the buffer. e.g.
;                       if each scan is 1K long and the transfer area
;                       is 64K in size, then only 64 scans can be
;                       transferred at a time.
;
; Arguments:
;               ds                      Context Sel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwSrcBitsSel    Selector for the src bitmap which is
;                               always the selector for the screen since
;                               the src bitmap is in offscreen memory.
;               dwSrcBitsOffset the offset in video memory of the base of
;                               the bitmap.
;               dwSrcBpp        the pixel depth of the src
;               dwSrcPitch      the pitch of the src bitmap
;               dwSrcLeft       Just in case the hardware cannot DMA back
;                               starting from arbitrary byte alignments,
;                               I have included this argument. You may
;                               need this when computing
;                               dwTransferBufferPitchInBytes
;               dwExtX          The X extent in pixels of the rectangle
;                               that we will be calling the routine
;                               HW_BlockSrcVramDstSystem to DMA back to
;                               system memory. This is also included
;                               here so you can do the appropriate
;                               computations for the return variables.
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  -- dwTransferBufferPitchInBytes
;                       ecx  -- dwMaxScanlinesPerTransfer
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginSrcVramDstSystem, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwExtX
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Load up sub-channels 6 and 7 to use the MemoryToMemoryFormats
        CHECKDMASPACE ds,ebx,edi,10H
        mov     eax,CHNRUN(MemoryToMemoryFormat0Hdr,1)
        mov     ecx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     eax,CHNRUN(MemoryToMemoryFormat1Hdr,1)
        mov     ecx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        add     edi,10H
        SETPUTPTR ds,ebx,edi

        ; The transfer pitch in bytes is always a multiple of a dword
        mov     ebx,dwSrcBpp
        inc     ebx
        shr     ebx,3
        imul    ebx,dwExtX
        add     ebx,3
        and     ebx,NOT 3

        ; Since there must be at least 2 target buffers, limit the
        ; number of scanlines that can be transferred to the amount
        ; that will fit in half of the cacheblae buffer area.
        mov     eax,CACHEABLE_BUFFER_SIZE / 2
        sub     edx,edx
        div     ebx
        mov     ecx,eax
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockSrcVramDstSystem
;
; Purpose:      This function is an easy way to implement Blts where
;               the src is in vram and the dst is in system memory.
;               It is one of a sequence. For full details, please see
;               HW_BeginSrcVramDstSystem eariler in this file.
;
;               This routine must transfer a chunk of the src bitmap
;               back from vram into some system memory area. The base,
;               pitch, bitdepth, rectangle to transfer, and ID as to
;               which transfer buffer to use are all specified here.
;               NOTE: The pitch of a line in the transfer area must
;               be the same as the dwTransferBufferPitchInBytes
;               variable computed and returned to the generic code in
;               HW_BeginSrcVramDstSystem.
;
; Arguments:
;               ds              CXSel
;               ebx             0 or 1 -- which transfer area to use
;               pHWBoardCXOffset   HWBOARDCX
;               dwSrcBase       Offset in VRAM of start of bitmap
;               dwSrcBpp        bits per pixel of src (8, 15, 16, or 32)
;               dwSrcPitch      width of bytes of bitmap
;               dwSrcLeft       left edge coord of rectangle to transfer
;               dwSrcTop        top edge coord of rectangle to transfer
;               dwExtX          width in pixels of rectangle to transfer
;               dwExtY          height in scanlines of rectangle to transfer
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcVramDstSystem time.
;
;               ecx     CTX offset of where rectangle was transferred
;
; Preserve:     ds,es,ebx
;==============================================================================
DECPROC HW_BlockSrcVramDstSystem, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwSrcBase
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
OPENPROC
        ; Load the push buffer ptr
        mov     esi,pHWBoardCXOffset
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        CHECKDMASPACE ds,esi,edi,24H
        mov     eax,CHNRUN(MemoryToMemoryFormat0.dwOffsetIn,8)
        sub     edx,edx
        or      ebx,ebx
        je      @F
        mov     eax,CHNRUN(MemoryToMemoryFormat1.dwOffsetIn,8)
        mov     edx,CACHEABLE_BUFFER_SIZE / 2
@@:     mov     ds:[edi + 00H],eax
        mov     ecx,dwSrcTop
        imul    ecx,dwSrcPitch
        mov     eax,dwSrcBpp
        inc     eax
        shr     eax,3
        imul    eax,dwSrcLeft
        add     eax,ecx
        add     eax,dwSrcBase
        mov     ds:[edi + 04H],eax
        mov     ds:[edi + 08H],edx
        mov     eax,dwSrcPitch
        mov     ecx,dwSrcBpp
        inc     ecx
        shr     ecx,3
        imul    ecx,dwExtX
        lea     edx,[ecx + 3]
        and     edx,NOT 3
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],edx
        mov     eax,dwExtY
        mov     ds:[edi + 14H],ecx
        mov     ds:[edi + 18H],eax
        mov     eax,101H
        sub     ecx,ecx
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ecx
        add     edi,24H
        lea     eax,ds:[esi].HWBOARDCX.sVramToSysramBufferNotifier0.status
        lea     ecx,[esi].HWBOARDCX.bCacheableDmaBuffer
        or      ebx,ebx
        je      @F
        lea     eax,ds:[esi].HWBOARDCX.sVramToSysramBufferNotifier1.status
        add     ecx,CACHEABLE_BUFFER_SIZE / 2
@@:     SETDMASTATUS <word ptr ds:[eax]>
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_WaitSrcVramDstSystem
;
; Purpose:      This function is an easy way to implement Blts where
;               the src is in vram and the dst is in system memory.
;               It is one of a sequence. For full details, please see
;               HW_BeginSrcVramDstSystem eariler in this file.
;
;               This routine must wait until the DMA transfer on the
;               specified transfer region is complete.
;
; Arguments:
;               ds              CXSel
;               edx             HWBOARDCX
;               ebx             0 or 1 -- which transfer area to wait for
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcVramDstSystem time.
;
; Preserve:     ds,es,ebx
;==============================================================================
DECPROC HW_WaitSrcVramDstSystem, PASCAL, NOFRAME, NEAR
OPENPROC
        lea     eax,ds:[edx].HWBOARDCX.sVramToSysramBufferNotifier0.status
        or      ebx,ebx
        je      @F
        lea     eax,ds:[edx].HWBOARDCX.sVramToSysramBufferNotifier1.status
@@:     WAITDMASTATUS <word ptr ds:[eax]>
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndSrcVramDstSystem
;
; Purpose:      This function is an easy way to implement Blts where
;               the src is in vram and the dst is in system memory.
;               It is one of a sequence. For full details, please see
;               HW_BeginSrcVramDstSystem eariler in this file.
;
; Arguments:
;               ds              CXSel
;               edx             HWBOARDCX
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcVramDstSystem time.
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_EndSrcVramDstSystem, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\MISC.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         misc.asm
;
; Purpose:      This file holds a few miscellaneous run-time functions.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvcm.inc
include nvos.inc
include nvmisc.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

IFDEF   DEBUG
PLACE_DST_BITMAP_IN_SCREEN_CORNER       TEXTEQU <1>
ELSE
PLACE_DST_BITMAP_IN_SCREEN_CORNER       TEXTEQU <0>
ENDIF

IF  (PLACE_DST_BITMAP_IN_SCREEN_CORNER NE 0)
PANIT   MACRO   dBase,dPitch
        LOCAL   skip

        cmp     cs:[dwAlignOffscreenBitmap],0
        je      skip
        push    edx
        push    ecx
        mov     edx,dBase
        mov     ecx,dPitch
        call    AlignOffscreenBitmap
        pop     ecx
        pop     edx
skip:
ENDM
ELSE
PANIT   MACRO   dBase,dPitch
ENDM
ENDIF

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

IF  (PLACE_DST_BITMAP_IN_SCREEN_CORNER NE 0)
PUBLIC  dwAlignOffscreenBitmap
dwAlignOffscreenBitmap  DD      0
ENDIF

; This is a HACK! Because some of the objects don't use their own
; SetColorFormat field, but instead use what is in the their embedded
; CONTEXT_SURFACES_2D object, we have to reset the ColorFormat for the
; CONTEXT_SURFACES_2D every time! Unh. The color format is dependent
; upon the logical device. If we have to pass all this information
; into the SetSrcBaseAndPitchToXX routines, the caller gets tongue-
; tied with all the parameters and values to pass. The driver loads
; once for each logical device, so we just remember the correct
; ColorFormat Value here in the code segment. This vairable must
; be updated on modesets to this logical device.
PUBLIC  dwContextSurface2DColorFormat
dwContextSurface2DColorFormat   DD      NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8

;==============================================================================
;
; Function:     SetDstBaseAndPitchToDsEdi
;
; Purpose:      This function sets the dst base and pitch in the
;               ContextSurfaces2d object to the values passed in.
;
; Arguments:
;               ds      Context Selector
;               edi     push buffer ptr
;
; Returns:      None
;
; Preserve:     all registers except edi should be adjusted as
;               appropriate to place some commands in the buffer
;==============================================================================
DECPROC SetDstBaseAndPitchToDsEdi, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
OPENPROC
        PUSHR   eax,esi
        mov     esi,pHWBoardCXOffset
        CHECKDMASPACE ds,esi,edi,14H
        mov     eax,cs:[dwContextSurface2DColorFormat]
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextSurfaces2d.SetColorFormat,4)
        mov     ds:[edi + 04H],eax
        mov     eax,dwDstPitch
        shl     eax,10H
        mov     ax,word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch
        mov     ds:[edi + 08H],eax
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax
        mov     eax,ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset
        mov     ds:[edi + 0CH],eax
        mov     eax,dwDstBase
        mov     ds:[edi + 10H],eax
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        add     edi,14H
        PANIT   dwDstBase,dwDstPitch
        POPR    eax,esi
CLOSEPROC


;==============================================================================
;
; Function:     SetDstBaseAndPitchToEsEdi
;
; Purpose:      This function sets the dst base and pitch in the
;               ContextSurfaces2d object to the values passed in.
;
; Arguments:
;               es      Context Selector
;               edi     push buffer ptr
;
; Returns:      None
;
; Preserve:     all registers except edi should be adjusted as
;               appropriate to place some commands in the buffer
;==============================================================================
DECPROC SetDstBaseAndPitchToEsEdi, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
OPENPROC
        PUSHR   eax,esi
        mov     esi,pHWBoardCXOffset
        CHECKDMASPACE es,esi,edi,14H
        mov     eax,cs:[dwContextSurface2DColorFormat]
        mov     dword ptr es:[edi + 00H],CHNRUN(ContextSurfaces2d.SetColorFormat,4)
        mov     es:[edi + 04H],eax
        mov     eax,dwDstPitch
        shl     eax,10H
        mov     ax,word ptr es:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch
        mov     es:[edi + 08H],eax
        mov     es:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax
        mov     eax,es:[esi].HWBOARDCX.dwContextSurface2dSrcOffset
        mov     es:[edi + 0CH],eax
        mov     eax,dwDstBase
        mov     es:[edi + 10H],eax
        mov     es:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        add     edi,14H
        PANIT   dwDstBase,dwDstPitch
        POPR    eax,esi
CLOSEPROC


;==============================================================================
;
; Function:     WaitUntilOtherContextsIdle
;
; Purpose:      This function will wait until any other graphics
;               contexts DMA pushers are idle.
;
; Arguments:
;               None
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
NV4_PFIFO_DMA					EQU	00002508H
NV4_PFIFO_CACHE1_PUSH1                          EQU   	00003204H
NV4_PFIFO_CACHE1_DMA_PUSH                       EQU   	00003220H
NV4_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY          EQU   	00000100H
NV_PFIFO_CACHE1_PUSH1_MODE_DMA                  EQU   	00000100H
FIFO_CACHE1_STATUS				EQU	00003214H
CACHE1_STATUS_LOW_MARK_EMPTY			EQU	10H
GRAPHICS_STATUS					EQU	00400700H

EXTERNDEF       wFlatDataSel:WORD

DECPROC WaitUntilOtherContextsIdle, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   eax,esi,edi,ds
        mov     ds,cs:[wFlatDataSel]
        mov     esi,pHWBoardCXOffset
        mov     edi,ds:[esi].HWBOARDCX.pChipRegs

busyp:  mov     eax,ds:[edi + NV4_PFIFO_DMA]
        and     eax,ds:[esi].HWBOARDCX.dwGdiPushBufferMask
        jnz     busyp

        mov     eax,ds:[edi + NV4_PFIFO_CACHE1_PUSH1]
        test    eax,NV_PFIFO_CACHE1_PUSH1_MODE_DMA
        jz      syncd
        and     eax,1FH
        cmp     eax,ds:[esi].HWBOARDCX.dwGdiPushBufferIndex
        je      syncd

emptyp: mov     eax,ds:[edi + NV4_PFIFO_CACHE1_DMA_PUSH]
        and     eax,NV4_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY
        jz      emptyp

syncd:
	;
	mov	eax,ds:[edi + FIFO_CACHE1_STATUS]
	and	eax,CACHE1_STATUS_LOW_MARK_EMPTY
	je	syncd
@@:
	; sync on graphics engine not idle
	mov	eax,ds:[edi + GRAPHICS_STATUS]
	and	eax,1
	jne	@B

        POPR    eax,esi,edi,ds
CLOSEPROC


;==============================================================================
;
; Function:     FlushChipsetCache
;
; Purpose:      This function does some things to help motherboard
;               chipsets get their cache coherency correct.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC FlushChipsetCache, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   eax,edx
        mov     edx,3D0H
        xor     eax,eax
        out     dx,al
        POPR    eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     WaitForDmaBufferSpace
;
; Purpose:      This function is called when there are not enough
;               bytes left in the DMA buffer to place a command.
;               Note that this does not necessarily mean that you
;               have reached the end of the DMA buffer, although
;               that is one possibility. It might mean that if you
;               write more commands, you will write over data that
;               the DMA has not yet fetched. In either case, though,
;               waiting of some type is required, and this routine
;               can handle it.
;
; Arguments:
;               HWBOARDCX.pCurrentPushBufferOffset must be up to date.
;
; Returns:      The PDEVICE.HWPDevice.dwCurrentPushBufferOffset
;               field has been modified to the new place to put
;               DMA commands. Also the PDEVICE.HWPDevice.dwBytesFree
;               member has been modified to reflect the new amount
;               of space. You are guaranteed that the new DMA
;               offset can hold at least the amount of bytes you
;               requested as the argument to this routine.
;
; Preserve:     All registers should be preserved
;==============================================================================
DECPROC WaitForDmaBufferSpace, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwBytesNeeded
OPENPROC
        PUSHR   ds,alld
        mov     ds,cs:[wFlatDataSel]
        mov     esi,pHWBoardCXOffset
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR ds,esi,edi

IFDEF   DEBUG
        mov     ds:[esi].HWBOARDCX.dwPushBufferOffsetOnWaitEnter,edi
        mov     eax,dwBytesNeeded
        mov     ds:[esi].HWBOARDCX.dwLastByteRequest,eax
ENDIF

        ; First, regardless of where the GET ptr is, is there enough
        ; space between the PUT ptr and the end of the DMA buffer?
        mov     ecx,dwBytesNeeded
        add     ecx,04H
        mov     ebx,ds:[esi].HWBOARDCX.pPushBufferStartOffset
        add     ebx,ds:[esi].HWBOARDCX.dwPushBufferLength
        sub     ebx,edi
        cmp     ebx,ecx
        jl      WrapPut

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; If we get here, the DMA push buffer looks as follows:
        ;
        ;                          >= dwBytesNeeded + 4
        ;                |--------------------------------------------|
        ;
        ;               PUT
        ;                |
        ;                v
        ; |-----------------------------------------------------------|
        ;
        ; In this case, we need to read the GET ptr and see where it is.
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WaitWhileGetGTPut:
        mov     eax,ds:[esi].HWBOARDCX.dwDmaGetPtr
        add     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        mov     ds:[esi].HWBOARDCX.dwLastGet,eax
        cmp     eax,edi
        jbe     GetLEPut

GetGTPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; GET is greater than PUT as shown in the diagram below. We
        ; might need to wait a bit until GET is enough greater than
        ; PUT to allow for the bytes needed plus maybe a JMP command.
        ;
        ;                          >= dwBytesNeeded + 4
        ;                |--------------------------------------------|
        ;
        ;                          ??????
        ;                |-----------------------|
        ;
        ;               PUT                     GET
        ;                |                       |
        ;                v                       v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Wait until GET - PUT is at least dwBytesNeeded + 4
        sub     eax,edi
        sub     eax,ecx
        jc      WaitWhileGetGTPut

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; GET is enough greater than PUT as shown in the diagram below
        ; that we can grant the space needed.
        ;
        ;                  >= dwBytesNeeded + 4
        ;                |-----------------------|
        ;
        ;               PUT                     GET
        ;                |                       |
        ;                v                       v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,1
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF
        jmp     Done

GetLEPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; The GET is less than the PUT which gives the sceanrio shown
        ; below. We already know that there is enough room from PUT
        ; to the end of the DMA buffer, so grant the request.
        ;
        ;                               >= dwBytesNeeded + 4
        ;                        |------------------------------------|
        ;
        ;          GET          PUT
        ;           |            |
        ;           v            v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     eax,ds:[esi].HWBOARDCX.pPushBufferStartOffset
        add     eax,ds:[esi].HWBOARDCX.dwPushBufferLength
        sub     eax,edi
        sub     eax,ecx
        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,2
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF
        jmp     Done

WrapPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; If we get here, there are not enough bytes from PUT to the end
        ; of the DMA buffer to hold the number of bytes needed as the
        ; diagram below shows. In this case, we must wait until the GET
        ; ptr goes less than or equal to the PUT ptr.
        ;
        ;                                    < dwBytesRequested + 4
        ;                                |----------------------------|
        ;
        ;                               PUT
        ;                                |
        ;                                v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Loopy:  mov     eax,ds:[esi].HWBOARDCX.dwDmaGetPtr
        add     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        mov     ds:[esi].HWBOARDCX.dwLastGet,eax
        cmp     eax,edi
        ja      WaitWithBusFree
        lea     edx,[esi].HWBOARDCX.bDmaPushBuffer
        cmp     eax,edx
        ja      GetLEPutWrapPut

WaitWithBusFree:
        mov     edx,100H
@@:     dec     edx
        jne     @B
        jmp     Loopy


GetLEPutWrapPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Having waited, the situation appears as shown. Now we can place
        ; a JMP command in the DMA buffer at the current PUT ptr to jmp
        ; back to the start of the buffer.
        ;
        ;                            < dwBytesRequested + 4
        ;                        |------------------------------------|
        ;
        ;         GET           PUT
        ;          |             |
        ;  X       v             v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     ebx,edi
        lea     edi,[esi].HWBOARDCX.bDmaPushBuffer
        mov	eax,edi
        sub     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        add     eax,JMP_COMMAND
        mov     dword ptr ds:[ebx],eax
        SETPUTPTR ds,esi,edi

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; After the JMP_COMMAND takes effect (it might be a little bit),
        ; eventually the scenario will be as shown. At this point, all
        ; we need to do is wait until either GET = PUT (which may happen
        ; if the GET reaches the JMP_COMMAND and executes it), OR until
        ; GET is at least dwBytesNeeded from the start of the DMA buffer.
        ;
        ;    dwBytesRequested + 4
        ; |-------------------------|
        ;
        ; PUT           GET
        ;  |             |
        ;  v             v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@:
        mov     eax,ds:[esi].HWBOARDCX.dwDmaGetPtr
        add     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        mov     ds:[esi].HWBOARDCX.dwLastGet,eax
        sub     eax,edi
        je      DmaIsIdle
        sub     eax,ecx
        jc      @B

        ; Now there are two things that could happen.
        ; 1) GET will become equal to PUT -- this will happen if the
        ;    GET command reaches the jmp and and takes the jmp. It
        ;    will then stop because it has reached PUT (which is
        ;    set to the beginning of the buffer).
        ; 2) GET - OFFSET dwDmaPushBufferStart > dwBytesRequested + 4
        ;    This will happen if GET is still fetching data, but
        ;    it has now fetched enough from the beginning of the
        ;    buffer that there is room to put the requested command in.

        ; The DMA is not idle, but there is enough room to place
        ; dwBytesNeeded between the buffer start and the GET ptr.
        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,3
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF
        jmp     Done

DmaIsIdle:
        mov     eax,ds:[esi].HWBOARDCX.dwPushBufferLength
        sub     eax,ecx
        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,4
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF

Done:
        POPR    ds,alld
CLOSEPROC


IF  (PLACE_DST_BITMAP_IN_SCREEN_CORNER NE 0)
;==============================================================================
;
; Function:     AlignOffscreenBitmap
;
; Purpose:      This function can be used for debugging. It is usually
;               used by the SetDstBaseAndPitch functions to center the
;               current bitmap in the uppoer left had corner of the
;               screen. The CRT start address and pitch registers are
;               adjusted to make the offscreen bitmap visible and
;               readable.
;
; Arguments:    edx     Base address
;               ecx     pitch
;		esi	HWBOARDCX ptr
;
; Returns:      None.
;
; Preserve:     Everything
;==============================================================================
EXTERNDEF	wFlatDataSel:WORD

PUBLIC  AlignOffscreenBitmap
AlignOffscreenBitmap    PROC    NEAR

        PUSHR   alld,ds
        mov	ds,cs:[wFlatDataSel]

        mov	edi,ds:[esi].HWBOARDCX.pChipRegs
	shr	ecx,3

	; Set the base address
	mov	ds:[edi + 600800H],edx

        ; Unlock the registers
        mov     dx,3D4H
        mov     al,1FH
        out     dx,al
        inc     dx
        in      al,dx
        mov     ah,al
        mov     al,57H
        out     dx,al

        ; The CRT pitch registers are from low to high 13H and
        ; the top 3 bits of 19H.
        mov     dx,3D4H
        mov     al,13H
        out     dx,al
        inc     dx
        mov     al,cl
        out     dx,al

        dec     dx
        mov     al,19H
        out     dx,al
        inc     dx
        in      al,dx
        and     al,1FH
        mov	ah,ch
        and     ah,7H
        shl     ah,5
        or      al,ah
        out     dx,al

        dec     dx
        mov     al,25H
        out     dx,al
        inc     dx
        in      al,dx
        and     al,0DFH
        mov	ah,ch
        and	ah,08H
        shl     ah,5 - 3
        or      al,ah
        out     dx,al

        POPR    alld,ds
        ret

AlignOffscreenBitmap    ENDP
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWBOARD.H ===
/*=======================================================================

    Copyright (C), 1998 Nvidia Coporation

    File:       hwboard.h

    Purpose:    This file holds the HWBOARDCX structure and other
                board related data.

=========================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// Other NV specific defines
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010
#define NV_DEVICE_VERSION_20    0x0020

// NV Architecture IDs -- NV05 is NV_04_ARCHITECTURE, REVISION 1
#define NV_03_ARCHITECTURE      0x03
#define NV_04_ARCHITECTURE      0x04
#define NV_10_ARCHITECTURE      0x10
#define NV_20_ARCHITECTURE      0x20

// This wasn't defined in the nvidia\sdk header files
#define NV1_MEMORY_SYSTEM       0x3E

// These are for the dwBusType field in the HWBOARDCX
#define NV_BUS_TYPE_PCI         0x01
#define NV_BUS_TYPE_AGP         0x04

// Our push buffer size
#define DMA_PUSH_BUFFER_SIZE    0x400000

// Hey, hope this is correct ...
#define WRITE_COMBINE_PAD_SIZE  0x20

// Normal Heap allocations that are purged on modesets or if we
// need more memory use this ID.
#define GDI2D_HEAP_OWNER        'NV2D'

// Allocations of the primary surface use this ID
#define GDI2D_DESKTOP_OWNER     'NVPS'

// Allocations for the board for things that must never disappear
// use this ID.
#define GDI2D_BOARD_OWNER       'NVBD'

// DDRAW heap ID that are purged on modesets if we need more memory.
#define DX_HEAP_ID      'NVDX'


// The first 100H bytes of each channel is NvControl stuff
typedef volatile struct
{
    V032    object;             // 0000-0003    current object register
    V032    reserved01[0x003];  // 0004-000C
    U016    free;               // 0010-0011    free count
    U016    reserved02[0x001];
    U032    reserved03[0x003];
    struct  tagNvPassword
    {
        V032    token[4];       // 0020-002F    Any write unlocks the chip
    }
    password;
    V032 dwPush;                // 0030-0033    Any write saves channel state
    V032 dwPop;                 // 0034-0037    Any write restores channel state
    V032 SetMethodCtxDma;       // 0038-003B    NV_CONTEXT_DMA_FROM_MEMORY
    V032 SetMethodNotifyCtxDma; // 003C-003F    NV_CONTEXT_DMA_TO_MEMORY
    V032 SetMethodStart;        // 0040-0043    offset within ctxdma in bytes
    V032 SetMethodLength;       // 0044-0047    Context DMA length in bytes
    V032 SetMethodNotify;       // 0048-004B    notification style
    V032 reserved04[0x02d];
}   NvControl;


// This structure is the layout of the GDI display driver's channel.
typedef volatile struct tagGDICHAN
{
    union
    {
        NvControl                   StartOfChannelHdr;
        NvControl                   ContextRopHdr;
    };

    Nv03ContextRop                  ContextRop;
    NvControl                       ContextSurfaces2dHdr;
    Nv04ContextSurfaces2d           ContextSurfaces2d;
    NvControl                       ContextPatternHdr;
    Nv04ImagePattern                ContextPattern;
    NvControl                       ContextClipRectHdr;
    Nv01ImageBlackRectangle         ContextClipRect;
    NvControl                       RectAndTextHdr;
    Nv04GdiRectangleText            RectAndText;
    NvControl                       ImageBlitHdr;
    Nv04ImageBlit                   ImageBlit;
    union
    {
        NvControl                   ImageFromCpuHdr;
        NvControl                   IndexedImageFromCpuHdr;
        NvControl                   StretchedImageFromCpuHdr;
        NvControl                   MemoryToMemoryFormat0Hdr;
        NvControl                   RenderSolidLinHdr;
        NvControl                   VideoSinkHdr;
        NvControl                   VideoFromMemoryHdr;
        NvControl                   VideoColorMapHdr;
        NvControl                   VideoLutCursorDacHdr;
    };
    union
    {
        Nv04ImageFromCpu            ImageFromCpu;
        Nv04IndexedImageFromCpu     IndexedImageFromCpu;
        Nv04StretchedImageFromCpu   StretchedImageFromCpu;
        Nv03MemoryToMemoryFormat    MemoryToMemoryFormat0;
        Nv04RenderSolidLin          RenderSolidLin;
        NvVideoSink                 VideoSink;
        NvVideoFromMemory           VideoFromMemory;
        NvVideoColormap             VideoColorMap;
        Nv04VideoLutCursorDac       VideoLutCursorDac;
    };
    union
    {
        NvControl                   MemoryToMemoryFormat1Hdr;
    };
    union
    {
        Nv03MemoryToMemoryFormat    MemoryToMemoryFormat1;
    };
}   GDICHAN;

typedef GDICHAN *LPGDICHAN;


// These are the objects which we will be using
#define OBJ_DMA_PUSH_BUFFER                     0x00009000
#define OBJ_DMA_PUSH_BUFFER_NOTIFIER            0x00009001
#define OBJ_VRAM_TO_SYSRAM_NOTIFIER0            0x00009002
#define OBJ_VRAM_TO_SYSRAM_NOTIFIER1            0x00009003
#define OBJ_SYSRAM_TO_VIDEO_NOTIFIER            0x00009004
#define OBJ_DMA_TO_SYSRAM                       0x00009006
#define OBJ_DMA_FROM_SYSRAM                     0x00009007
#define OBJ_DMA_FROM_VRAM                       0x00009008
#define OBJ_DMA_IN_VRAM                         0x00009009

#define OBJ_CONTEXT_SURFACES_2D                 0x0000900A
#define OBJ_DMA_FROM_VRAM_TO_SYSRAM_0           0x0000900B
#define OBJ_DMA_FROM_VRAM_TO_SYSRAM_1           0x0000900C
#define OBJ_CONTEXT_CLIP_RECT                   0x0000900D
#define OBJ_CONTEXT_PATTERN                     0x0000900E
#define OBJ_CONTEXT_ROP                         0x0000900F
#define OBJ_IMAGE_BLIT                          0x00009010
#define OBJ_RECT_AND_TEXT                       0x00009011
#define OBJ_IMAGE_FROM_CPU                      0x00009012
#define OBJ_SOLID_LINE                          0x00009013
#define OBJ_INDEXED_IMAGE_FROM_CPU              0x00009014
#define OBJ_STRETCHED_IMAGE_FROM_CPU		0x00009015

#define OBJ_DMA_PUSH_MEMORY                     0x00009999

// Note that there might be multiple VideoLutCursorDac objects
// This ID is for the first one. There is one for each additional
// CRTC on the board and the object IDs are sequential numbers
// starting with this first one.
#define OBJ_VIDEO_LUT_CURSOR_DAC                0x00009020

// Similar to above. Seems like 0x10 CRTCs is enough ...
#define OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER       0x00009030

// Similar to above but for the Palette
#define OBJ_DMA_IN_SYSRAM_FOR_PALETTE           0x00009040

// Similar to above but for the Gamma
#define OBJ_DMA_IN_SYSRAM_FOR_GAMMA             0x00009050

#define	INTERLACED_STEREO						0x00000001

typedef struct  _HWBOARDCX
{
    ////////////////////////////////////////////////////////////////
    // The pages which contain the first part of this structure
    // should be marked as CACHEABLE.

    // These "constants" describe the DMA push buffer
    ULONG    pPushBufferStartOffset;                        // 0000-0003
    ULONG    pPushBufferContextStartOffset;                 // 0004-0007
    ULONG    dwPushBufferLength;                            // 0008-000B

    // Use IO to flush processor and chipset cache if true
    ULONG    dwFlushCacheWithIO;                            // 000C-000F

    // These "variables" are used to manage the push buffer
    ULONG    pCurrentPushBufferOffset;                      // 0010-0013
    ULONG    dwBytesFree;                                   // 0014-0017

    // Keep these variables accessible
    ULONG    dwContextSurface2dDstSrcPitch;                 // 0018-001B
    ULONG    dwContextSurface2dSrcOffset;                   // 001C-001F
    ULONG    dwContextSurface2dDstOffset;                   // 0020-0023
    ULONG    dwMinContextSurface2dPitch;                    // 0024-0027
    ULONG    dwMaxContextSurface2dPitch;                    // 0028-002B

    // I need a variable that reminds me to restore the alpha when
    // I have temporarily set a TRANSPARENT hatch pattern in output.
    ULONG    dwGetOffsetAtLastBeginAccess;                  // 002C-002F

    ULONG    dwTemp[4];                                     // 0030-003F

    // The start of this context will be the PUSHER notifier
    NvNotification  sPushBufferNotifier;                    // 0040-004F

    // I need some notifiers for the MemoryToMemoryFormat objects.
    // The standard MemoryToMemoryFormat object has an array of
    // two notifiers. They are the following:
    // MethodNotifer    -- When certain methods of the object are written
    // BufferNotifier   -- When the MemoryToMemory transfer is completed
    NvNotification  sVramToSysramMethodNotifier0;           // 0050-005F
    NvNotification  sVramToSysramBufferNotifier0;           // 0060-006F
    NvNotification  sVramToSysramMethodNotifier1;           // 0070-007F
    NvNotification  sVramToSysramBufferNotifier1;           // 0080-008F

    // I need some notifiers for the VideoFromMemory object.
    // The standard VideoFromMemory object has an array of
    // two notifiers. They are the following:
    // BufferNotifier   -- When the VideoFromMemory transfer is completed
    // Flip0Notifer     -- Indicates page 0 has been flipped to
    // Flip1Notifier    -- Indicates page 1 has been flipped to
    // Buffer 0 Scan    -- Data field of notifier contains current scanline
    //                     being displayed in buffer 0
    // Buffer 1 Scan    -- Data field of notifier contains current scanline
    //                     being displayed in buffer 1
    NvNotification  sSysramToVideoBufferNotifier;           // 0090-009F
    NvNotification  sSysramToVideoFlip0Notifier;            // 00A0-00AF
    NvNotification  sSysramToVideoFlip1Notifier;            // 00B0-00BF
    NvNotification  sSysramToVideoScan0Notifier;            // 00C0-00CF
    NvNotification  sSysramToVideoScan1Notifier;            // 00D0-00DF

    // These are offscreen video memory addresses of where the cursor
    // cache is located for each CRTC.
    ULONG   dwCursorCacheSize;                              // 00E0-00E4
    ULONG   adwCursorCacheVramOffset[MAX_ATTACHED_CRTCS];   // 00E4-???
    ULONG   adwReservedPrimarySurfaceOffsets[MAX_ATTACHED_CRTCS]; // ????

    // A little slack space ...
    ULONG   tmp[35 - 2 * MAX_ATTACHED_CRTCS];               // ????-016F

    /////////////////////////////////////////////////////////////////
    // Set to non-0 if we are initting. Cleared on first modeset
    ULONG   dwInitting;                                     // 0170-0173

    // The specific Nvidia board number from the RM  (1 based.)
    ULONG   dwDeviceNum;                                    // 0174-0177

    // Root handle
    ULONG   dwRootHandle;                                   // 0178-017B

    // The ResMan device handle returned from allocating the device
    ULONG   dwhDevice;                                      // 017C-017F

    // Information about the frame buffer
    ULONG   dwRamFlags;                                     // 0180-0183
    ULONG   dwVideoMemorySize;                              // 0184-0187
    ULONG   pVideoMemory;                                   // 0188-018B
    ULONG   dwVideoMemorySel;                               // 018C-018F

    // Information about the device
    ULONG   pChipRegs;                                      // 0190-0193

    // Deevice version like NV_DEVICE_VERSION_5 (or _4 or _10, etc.)
    ULONG   dwDeviceVersion;                                // 0194-0197

    // PCI or AGP?
    ULONG   dwBusType;                                      // 0198-019B

    // This field tells how many CRTCs are on the board. The next one
    // field has a one bit set for each CRTC that has been allocated.
    ULONG   dwNumCRTCsOnBoard;                              // 019C-019F
    ULONG   dwCRTCsAllocatedFlags;                          // 01A0-01A3

    // This is information about the push buffer and channel
    // Freed by FreeRoot if Allocated via NV_AllocMemory.
    // If allocated with SysAllocPages, we must free it by
    // calling lpfnNvSysFreePages with dwRealPushBufferPageHandle.
    ULONG   dwRealPushBufferPageHandle;                     // 01A4-01A7
    ULONG   pRealPushBuffer;                                // 01A8-01AB

    // Freed by FreeRoot
    ULONG   pDmaChannel;                                    // 01AC-01AF

    // This is the real ptr that was allocated for the HWBOARDCX.
    // It is not what you return to the generic code as the
    // HWBOARDCX ptr though, so we must save this so that we can
    // free it later. NOTE: We return conctext sekector relative
    // ptr version of pAliasedHWBoardCX. This is different
    // linear address space that maps to the same memory as
    // pHWBoardCXReal.                                      
    ULONG   pHWBoardCXReal;                                 // 01B0-01B3

    // We have aliased the push buffer so we can remap some of the pages
    // to point to other things. As a result, we can reference everything
    // off of the context selector that is passed around.
    ULONG   pAliasedHWBoardCX;                              // 01B4-01B7

    // Non-0 when DirectX is active
    ULONG   dwDirectXActive;                                // 01B8-01BB

    // This is where the table of LUT values is stored
    ULONG   dwIndexedLUTOffset;                             // 01BC-01BF

    // This is used by OpenGL to track the mode switches. The variable
    // is incremented by one when a mode switch begins and by another
    // one when the mode switch is finished. An even number indicates the
    // mode is stable. An odd number indicates a mode set is in progress.
    ULONG   dwModeSwitchCount;                              // 01C0-01C3

    // This is the channel number used by the display driver.
    ULONG   dwGdiDriverChannelID;                           // 01C4-01C7

    // I haven't yet decided if I want the current channel ID variable
    // to be in the PDEVICE or in the HARDWARESEGMENT. It depends on
    // which I have a ptr to more often when I need to access the
    // current channel ID variable. If I decide that I want it in the
    // PDEVICE, then this will be it.
    ULONG   dwCurrentChannelID;                             // 01C8-01CB

    // The pCurrentChannelID is a ptr to a dword variable thats holds
    // the channel ID (0-15) of the most recent channel to trigger
    // their DMA pusher. Every channel should check this variable to
    // see if it matches the channel ID of their channel and, if it
    // does not, the channel should sync to the other channels before
    // triggering its own DMA. Each channel should write their channel
    // ID into the dword pointed to by pCurrentChannelID when triggering
    // their DMA. This variable is used by all the different drivers
    // that can have channels to the hardware (e.g. DirectX, OpenGL).
    ULONG   pCurrentChannelID;                              // 01CC-01CF

    // To sync between the different DMA channels, these are needed
    ULONG   dwGdiPushBufferIndex;                           // 01D0-01D3
    ULONG   dwGdiPushBufferMask;                            // 01D4-01D7


    // Used for debugging
    ULONG    dwTempEnd;                                     // 01D8-01DB
    ULONG    dwLastGet;                                     // 01DC-01DF
    ULONG    dwLastWaitPath;                                // 01E0-01E3
    ULONG    dwPushBufferOffsetOnWaitEnter;                 // 01E4-01E7
    ULONG    dwLastBytesFree;                               // 01E8-01EB
    ULONG    dwLastByteRequest;                             // 01EC-01EF

    // This holds the chip revision
    ULONG   dwDeviceRevision;                               // 01F0-01F3

    ULONG   dwDisplayChangeCount;                           // 01F4-01F7

	// Misc stereo related properties
    ULONG   dwStereoConnectionType;                         // 01F8-01FB
    ULONG   dwReserved;										// 01FC-01FF

    // Next we need a cacheable buffer that MemoryToMemoryFormat can use
    // to transfer chunks of VRAM back into. This should be the remainder
    // of this 4K page plus some whole number of additional 4K pages.
#define CACHEABLE_BUFFER_SIZE   (0x8000 - 0x0200)
    UCHAR   bCacheableDmaBuffer[CACHEABLE_BUFFER_SIZE];

    // End of the CACHEABLE area.
    ////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    // The page that maps the following should be marked as
    // NON_CACHEABLE and NON-WRITECOMBINE -- it is mapping hardware.
    UCHAR   bHWPageStart[0x0040];
    ULONG   dwDmaPutPtr;
    ULONG   dwDmaGetPtr;
    UCHAR   bHWPageEnd[0x1000 - 0x0048];
    // End NON_CACHEABLE, NON WRITE-COMBINE page
    ///////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    // The rest of the structure is the Dma Pusher Buffer. It can be
    // marked NON-CACHEABLE, WRITE-COMBINE but may also run as CACHED
    // memory. We cannot actually put
    // the entire DMA PUSH BUFFER in here as an array if it is larger
    // than 64K because in 16bit land, structures are limited to 64K.
    // But this file will be converted to an assembly include file,
    // and as long as we have a label for the start of the buffer,
    // the assembly code will be able to access the whole push buffer
    // correctly.
    //
    // To force a flush of the CPU's internal Write-Combine (WC) buffer,
    // a write is required to a region of WC memory which is not in the
    // same 32byte window as the last write to a WC memory area. We want
    // the first dword of the first page to provide this mechanism.
    //
    // One more thing. Make the push buffer 0x20 bytes less than a
    // multiple of 4K. Why? Because then the buffer will end just on
    // a page boundary and there won't be any wasted bytes on the end
    // of a 4K page (the OS does page allocation).

    // The start of this context will be the PUSHER notifier
    UCHAR   bScrapSpace[WRITE_COMBINE_PAD_SIZE];

    // I'd like to do what the next line does, but this is 16bit land
    // so I'll just use the line after to provide a label.
//  UCHAR   bDmaPushBuffer[DMA_PUSH_BUFFER_SIZE];
    UCHAR   bDmaPushBuffer;
    ///////////////////////////////////////////////////////////////////

}   HWBOARDCX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\MVISION.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         mvision.asm
;
; Purpose:      This file holds the macrovision control code.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvcm.inc
include nvos.inc
include nvmisc.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_SetMacrovisionMode
;
; Purpose:      Sets the current Macrovision capable TV Out device to
;               the requested Macrovision copy protection mode.
;
; Arguments:    Mode		new macrovision copy protection mode to set
;               ds		Context Selector
;		pHWCrtcCXOffset	HWCRTCCX ptr
;               resX		PhysicalXRes
;               resY		PhysicalYRes
;
; Returns:      eax     0 then fail
;                       non-0 then success
;
; Preserve:     ds:esi,es,edi
;==============================================================================

DECPROC HW_SetMacrovisionMode, PASCAL, FRAME, NEAR
PARMD	Mode
PARMD	resX
PARMD	resY
PARMD	pHWCrtcCXOffset
LOCALV  Params, NV_CFGEX_SET_MACROVISION_MODE_PARAMS
OPENPROC

        PUSHR   ds,es,esi

	mov	eax,Mode
	mov     Params.mode,eax

        mov     esi,pHWCrtcCXOffset
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     Params.head,eax

        mov     eax,resX
        mov     Params.resx,eax
        mov     eax,resY
        mov     Params.resy,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_SET_MACROVISION_MODE_PARAMS
        mov     ecx,NV_CFGEX_SET_MACROVISION_MODE
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        call    NV_ConfigExSetCall

	cmp	eax,NVOS_CGE_STATUS_SUCCESS
	mov	eax,1
	je	SMM_Ok
	sub	eax,eax

SMM_Ok:
        POPR    ds,es,esi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWCRTC.H ===
/*=======================================================================

    Copyright (C), 1998 Nvidia Coporation

    File:       hwcrtc.h

    Purpose:    This file holds the HWCRTCCX structure and other
                CRTC related data.

=========================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// This structure holds dynamic data that is unique for each
// given instance of a CRTC on a given board.
typedef struct  _HWCRTCCX
{
    // Set to non-0 if we are initting. Cleared on first modeset
    ULONG   dwInitting;

    // The HWBOARDCX is needed sometimes so store it here.
    ULONG   pHWBoardCX;

    // This is the HWLOGDEVCX that this HWCRTCCX is a child of
    ULONG   pHWLogdevCX;

    // 0 based number telling us which CRTC we are using with
    // respect to the board device.
    ULONG   dwPhysicalCRTCInstance;

    // This is the offset in vram where the cursor patterns are stored
    // Also the cursor alpha to be applied to color cursors. Also we
    // keep around how many cursors we may have to cache.
    ULONG   dwMaxCachedCursors;
    ULONG   dwCursorCacheVramOffset;
    ULONG   dwCursorAlpha;

    // The TV ID and Addr are sometimes needed so store them both here.
    ULONG   dwTVOutDeviceID;
    ULONG   dwTVOutDeviceAddr;

    // This holds the current CRTC pitch.
    ULONG   dwPanPitch;

    // Each one is set to TRUE if the object is created.
    UCHAR   bNotifierCreated;
    UCHAR   bPaletteContextDmaCreated;
    UCHAR   bGammaContextDmaCreated;
    UCHAR   bVidLutCursorDacObjectCreated;

    NvNotification  sVideoLutCursorDacNotifier0;
    NvNotification  sVideoLutCursorDacNotifier1;
    NvNotification  sVideoLutCursorDacNotifier2;
    NvNotification  sVideoLutCursorDacNotifier3;
    NvNotification  sVideoLutCursorDacNotifier4;
    NvNotification  sVideoLutCursorDacNotifier5;
    NvNotification  sVideoLutCursorDacNotifier6;
    NvNotification  sVideoLutCursorDacNotifier7;
    NvNotification  sVideoLutCursorDacNotifier8;

    // The palette and gamma table are placed here for updating and
    // then a VideoFromMemory transfer is initiated.
    ULONG   dwPaletteTable[256];
    ULONG   dwGammaTable[256];
}   HWCRTCCX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWLOGDEV.H ===
/*=======================================================================

    Copyright (C), 1998 Nvidia Coporation

    File:       hwlogdev.h

    Purpose:    This file holds the HWLOGDEV structure and related data.
=========================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// This structure holds dynamic data that is unique for each
// given instance of a PDEVICE (a logical device actually).
typedef struct  _HWLOGDEVCX
{
    // Set to non-0 if we are initting. Cleared on first modeset
    ULONG   dwInitting;

    // The HWBOARDCX attached to this HWLOGDEV
    ULONG   pHWBoardCX;

    // Keep the HWCRTCCX's around
    ULONG   pHWCrtcCX[MAX_ATTACHED_CRTCS];

    // These variables color depth dependent values for objects and
    // objet methods on this logical device.
    ULONG   dwRectAndTextColorFormat;
    ULONG   dwIndexedImageColorFormat;
    ULONG   dwImageFromCpuColorFormat;
    ULONG   dwSolidLinColorFormat;
    ULONG   dwColorAlphaMask;
    ULONG   dwPatternColorFormat;
    ULONG   dwColorPatternAndHeaderSize;
    ULONG   dwColorPatternMethodOffset;
    ULONG   dwPatternAlpha0;
    ULONG   dwPatternAlpha1;

    // Intel Diagnostic's stuff
    USHORT  wDiagInterfaceOpen;
    USHORT  wLastDiagError;

    // This holds the current offset of the logical desktop surface
    ULONG   dwLogicalSurfaceOffset;

    // DIRECTX STUFF
    // If DirectX is active then this variable is non-0; else it is 0.
    ULONG   dwDirectXActive;

    // This is to hold the callbacks into the internals of Direct Draw
    MYDDHALDDRAWFNS sDDHalDDrawFns;

    // Anybody can use this but it was created for the DirectX driver.
    // DirectX should really call every time there is a mode change to
    // get the available mode list, but some of the old DX apps need
    // the mode list before the 32bit driver has initted, so we need
    // something to give them. Note that this sounds CRTC specific
    // since it has to do with modes. It kinda is, but since it was
    // created for DirectX, it is really PDEVICE specific.
    ULONG   pMasterModeList;
    ULONG   lpMasterModeList;       // 16:16 ptr

    // pFlatDirectXSharedData is a flat ptr to the shared data.
    // pDirectXSharedData is a CXSel relative ptr to the shared data.
    ULONG   pDirectXSharedData;
    ULONG   lpDirectXSharedData;    // 16:16 ptr
}   HWLOGDEVCX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\OBJECTS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         objects.asm
;
; Purpose:      This file creates and destroys objects that are global
;               to the BOARD.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     NV_CreateDmaContexts
;
; Purpose:      This function creates all the DMA contexts we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CreateDmaContexts, PASCAL, NOFRAME, FAR32
OPENPROC
        ; We only create these once -
        ; they are never destroyed untl the driver unloads.
        call    CreatePushBufferNotifier
        call    CreateVramToSysramNotifier0
        call    CreateVramToSysramNotifier1
        call    CreateSysramToVideoNotifier
        call    CreateDmaFromSysram
        call    CreateDmaToSysram
        call    CreateDmaFromVram
        call    CreateDmaInVram
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_CreateObjects
;
; Purpose:      This function creates all the objects we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CreateObjects, PASCAL, NOFRAME, FAR32
OPENPROC
        ; I don't want to have to wait for space anywhere in the
        ; object creation routines. Just wait for 4K bytes. That
        ; will be enough to hold the whole creation process.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        CHECKDMASPACE ds,esi,edi,1000H

        ; Create all the objects we will need.
        call    CreateContextSurfaces2D
        call    CreateVramToSysramCopy0
        call    CreateVramToSysramCopy1
        call    CreateContextClipRect
        call    CreateContextPattern
        call    CreateContextRop
        call    CreateImageBlit
        call    CreateRectAndText
        call    CreateImageFromCpu
        call    CreateSolidLine
        call    CreateIndexedImageFromCpu
	call	CreateStretchedImageFromCpu

        ; I want to track the byte usage in the DMA buffer accurately,
        ; but I didn't wait for the exact number of dwords needed for
        ; the object creations above. Let's stick a JMP_COMMAND in the
        ; DMA buffer to get back to the beginning and then wait until
        ; the DMA pusher goes idle. Then we can reset all our variables
        ; to indicate the whole buffer is free and start out fresh.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        lea     eax,[esi].HWBOARDCX.bDmaPushBuffer
        mov     ecx,eax
        sub     ecx,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        or      ecx,JMP_COMMAND
        mov     ds:[edi],ecx
        xor     ecx,JMP_COMMAND
        SETPUTPTR ds,esi,eax
@@:
        cmp     ds:[esi].HWBOARDCX.dwDmaGetPtr,ecx
        jne     @B

        ; Now set the number of bytes free
        mov     ds:[esi].HWBOARDCX.dwBytesFree,DMA_PUSH_BUFFER_SIZE - WRITE_COMBINE_PAD_SIZE - 10h
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     CreatePushBufferNotifier
;
; Purpose:      This function creates the main push buffer notifier
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreatePushBufferNotifier, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_PUSH_BUFFER_NOTIFIER
        lea     ebx,[esi].HWBOARDCX.sPushBufferNotifier
        push    ebx
        push    ds
        pushd   SIZE NvNotification
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramNotifier0
;
; Purpose:      This function creates a context DMA which is to
;               be used as the notifier for a video memory to
;               system memory MemoryToMemoryFormat copy in
;               the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramNotifier0, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_VRAM_TO_SYSRAM_NOTIFIER0
        lea     ebx,[esi].HWBOARDCX.sVramToSysramMethodNotifier0
        push    ebx
        push    ds
        pushd   2 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramNotifier1
;
; Purpose:      This function creates a context DMA which is to
;               be used as the notifier for a video memory to
;               system memory MemoryToMemoryFormat copy in
;               the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramNotifier1, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_VRAM_TO_SYSRAM_NOTIFIER1
        lea     ebx,[esi].HWBOARDCX.sVramToSysramMethodNotifier1
        push    ebx
        push    ds
        pushd   2 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateSysramToVideoNotifier
;
; Purpose:      This function creates a context DMA to be used as a
;               notifier for a system memory to video (Color Look Up
;               Table stuff) NV_VIDEO_FROM_MEMORY object in the
;               WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateSysramToVideoNotifier, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_SYSRAM_TO_VIDEO_NOTIFIER
        lea     ebx,[esi].HWBOARDCX.sSysramToVideoBufferNotifier
        push    ebx
        push    ds
        pushd   5 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaToSysram
;
; Purpose:      This function creates a context DMA for system memory
;               to be used as the destination in a MemoryToMemoryFormat
;               copy in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaToSysram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_TO_SYSRAM
        lea     ebx,[esi].HWBOARDCX.bCacheableDmaBuffer
        push    ebx
        push    ds
        pushd   (CACHEABLE_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaFromSysram
;
; Purpose:      This function creates a context DMA for system memory
;               to be used as the source in a MemoryToMemoryFormat
;               copy in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaFromSysram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_FROM_SYSRAM
        lea     ebx,[esi].HWBOARDCX.bCacheableDmaBuffer
        push    ebx
        push    ds
        pushd   (CACHEABLE_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaFromVram
;
; Purpose:      This function creates a context DMA for video memory
;               to be used as the source in objects in the WIN_CHANNEL.
;
; Purpose:      This function creates a context DMA from the push buffer.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaFromVram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_FROM_VRAM
        pushd   0
        mov     ecx,ds:[esi].HWBOARDCX.dwVideoMemorySel
        push    ecx
        push    ds:[esi].HWBOARDCX.dwVideoMemorySize
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaInVram
;
; Purpose:      This function creates a context DMA for video memory
;               to be used as a field for objects in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaInVram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_IN_VRAM
        pushd   0
        mov     ecx,ds:[esi].HWBOARDCX.dwVideoMemorySel
        push    ecx
        push    ds:[esi].HWBOARDCX.dwVideoMemorySize
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextSurfaces2D
;
; Purpose:      This function creates a ContextSurfaces2D object
;               to be used in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextSurfaces2D, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        mov     eax,NV4_CONTEXT_SURFACES_2D
        cmp     ds:[esi].HWBOARDCX.dwDeviceVersion,NV_DEVICE_VERSION_10
        jl      @F
        mov     eax,NV10_CONTEXT_SURFACES_2D
@@:
        push    esi
        push    eax
        pushd   OBJ_CONTEXT_SURFACES_2D
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextSurfaces2dHdr.object,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        mov     eax,CHNRUN(ContextSurfaces2d.SetColorFormat,1)
        mov     ds:[edi + 08H],eax
        mov     dword ptr ds:[edi + 0CH],NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8

        ; Program the non-volatile data
        mov     eax,CHNRUN(ContextSurfaces2d.SetContextDmaImageSource,2)
        mov     ecx,OBJ_DMA_IN_VRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        mov     ds:[edi + 18H],ecx
        add     edi,1CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramCopy0
;
; Purpose:      This function creates a MemoryToMemoryFormat object
;               for copying from video memory to system memory. This
;               is one of the two that we will need.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramCopy0, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV03_MEMORY_TO_MEMORY_FORMAT
        pushd   OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat0Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(MemoryToMemoryFormat0.SetContextDmaNotifies,3)
        mov     ecx,OBJ_VRAM_TO_SYSRAM_NOTIFIER0
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     eax,OBJ_DMA_FROM_VRAM
        mov     ecx,OBJ_DMA_TO_SYSRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramCopy1
;
; Purpose:      This function creates a MemoryToMemoryFormat object
;               for copying from video memory to system memory. This
;               is one of the two that we will need.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramCopy1, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV03_MEMORY_TO_MEMORY_FORMAT
        pushd   OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat1Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(MemoryToMemoryFormat1.SetContextDmaNotifies,3)
        mov     ecx,OBJ_VRAM_TO_SYSRAM_NOTIFIER1
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     eax,OBJ_DMA_FROM_VRAM
        mov     ecx,OBJ_DMA_TO_SYSRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextClipRect
;
; Purpose:      This function creates a ContextClipRectangle object
;               for use as a global clip rectangle in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextClipRect, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV01_CONTEXT_CLIP_RECTANGLE
        pushd   OBJ_CONTEXT_CLIP_RECT
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextClipRectHdr.object,1)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(ContextClipRect.SetContextDmaNotifies,1)
        mov     ebx,OBJ_DMA_PUSH_BUFFER_NOTIFIER
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx

        ; Default it to the largest possible clip area
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        sub     ebx,ebx
        mov     ecx,7FFF7FFFH
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     ds:[edi + 18H],ecx
        add     edi,1CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextPattern
;
; Purpose:      This function creates an ContextPattern object
;               for use as a global pattern in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextPattern, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_CONTEXT_PATTERN
        pushd   OBJ_CONTEXT_PATTERN
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextPatternHdr.object,1)
        mov     ebx,OBJ_CONTEXT_PATTERN
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        ; Doesn't matter what we set the color format and the
        mov     eax,CHNRUN(ContextPattern.SetColorFormat,6)
        mov     ds:[edi + 08H],eax
        mov     dword ptr ds:[edi + 0CH],NV044_SET_COLOR_FORMAT_LE_A8R8G8B8
        mov     ebx,NV044_SET_MONOCHROME_FORMAT_CGA6_M1
        mov     ds:[edi + 10H],ebx
        mov     eax,NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov     ebx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ecx,-1
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     ds:[edi + 1CH],ecx
        mov     ds:[edi + 20H],ecx
        
        add     edi,24H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextRop
;
; Purpose:      This function creates a ContextRop object
;               for use as a global rop in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextRop, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV03_CONTEXT_ROP
        pushd   OBJ_CONTEXT_ROP
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextRopHdr.object,1)
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        add     edi,08H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateImageBlit
;
; Purpose:      This function creates an ImageBlit object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateImageBlit, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_IMAGE_BLIT
        pushd   OBJ_IMAGE_BLIT
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ImageBlitHdr.object,1)
        mov     ebx,OBJ_IMAGE_BLIT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(ImageBlit.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(ImageBlit.SetContextSurfaces,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(ImageBlit.SetOperation,1)
        mov     ebx,NV05F_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        add     edi,28H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateRectAndText
;
; Purpose:      This function creates a GdiRectangleText object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateRectAndText, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_GDI_RECTANGLE_TEXT
        pushd   OBJ_RECT_AND_TEXT
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndTextHdr.object,1)
        mov     ebx,OBJ_RECT_AND_TEXT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(RectAndText.SetContextDmaFonts,3)
        mov     ebx,OBJ_DMA_IN_VRAM
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(RectAndText.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(RectAndText.SetOperation,2)
        mov     ebx,NV04A_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     dword ptr ds:[edi + 28H],NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,2CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateImageFromCpu
;
; Purpose:      This function creates an ImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_IMAGE_FROM_CPU
        pushd   OBJ_IMAGE_FROM_CPU
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ImageFromCpuHdr.object,1)
        mov     ebx,OBJ_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(ImageFromCpu.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(ImageFromCpu.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(ImageFromCpu.SetOperation,2)
        mov     ebx,NV061_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     dword ptr ds:[edi + 28H],NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,2CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateSolidLine
;
; Purpose:      This function creates a RenderSolidLin object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateSolidLine, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_RENDER_SOLID_LIN
        pushd   OBJ_SOLID_LINE
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RenderSolidLinHdr.object,1)
        mov     ebx,OBJ_SOLID_LINE
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(RenderSolidLin.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(RenderSolidLin.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(RenderSolidLin.SetOperation,2)
        mov     ebx,NV05C_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     dword ptr ds:[edi + 28H],NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,2CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateIndexedImageFromCpu
;
; Purpose:      This function creates an IndexedImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateIndexedImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        mov     eax,NV04_INDEXED_IMAGE_FROM_CPU
        cmp     ds:[esi].HWBOARDCX.dwDeviceVersion, NV_DEVICE_VERSION_5
        jl      @F
        mov     eax,NV05_INDEXED_IMAGE_FROM_CPU
@@:
        push    esi
        pushd   eax
        pushd   OBJ_INDEXED_IMAGE_FROM_CPU
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(IndexedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_INDEXED_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextDmaLut,1)
        mov     ebx,OBJ_DMA_FROM_VRAM
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     eax,CHNRUN(IndexedImageFromCpu.SetColorConversion,3)
        mov     ebx,NV060_SET_COLOR_CONVERSION_TRUNCATE
        mov     ecx,NV060_SET_OPERATION_ROP_AND
        mov     edx,NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ebx
        mov     ds:[edi + 30H],ecx
        mov     ds:[edi + 34H],edx
        add     edi,38H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateStretchedImageFromCpu
;
; Purpose:      This function creates an StretchedImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateStretchedImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_STRETCHED_IMAGE_FROM_CPU
        pushd   OBJ_STRETCHED_IMAGE_FROM_CPU
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(StretchedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_STRETCHED_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(StretchedImageFromCpu.SetContextPattern,2)
        mov     ebx,OBJ_CONTEXT_PATTERN
        mov     ecx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(StretchedImageFromCpu.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,CHNRUN(StretchedImageFromCpu.SetOperation,2)
        mov     ebx,NV061_SET_OPERATION_ROP_AND
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     dword ptr ds:[edi + 24H],NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,28H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocContextDma
;
; Purpose:      This function allocates an NV01_CONTEXT_DMA in the memory
;               range defined by the arguments and gives that instance the
;               object ID provided.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectID      Object ID
;               pBaseAddr       Base
;               dwSelector      selector
;               dwLimit         limit
;               dwFlags         Flags (e.g.
;                               ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY)
;                               The possible flags are defined in the
;                               header file nvrmarch.inc
;
; Returns:      eax     0       failure
;                       non-0   Sucess
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocContextDma, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectID
PARMD   pBaseAddr
PARMD   dwSelector
PARMD   dwLimit
PARMD   dwFlags
LOCALV  ContextDmaParam,ALLOC_CTX_DMA_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        PUSHSREG ss
        lea     bx,ContextDmaParam
        push    bx
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     ContextDmaParam.ALLOC_CTX_DMA_hObjectParent,eax
        mov     eax,dwObjectID
        mov     ContextDmaParam.ALLOC_CTX_DMA_hObjectNew,eax
        mov     ContextDmaParam.ALLOC_CTX_DMA_hClass,NV01_CONTEXT_DMA
        mov     eax,dwFlags
        mov     ContextDmaParam.ALLOC_CTX_DMA_flags,eax
        mov     eax,pBaseAddr
        mov     ContextDmaParam.ALLOC_CTX_DMA_pBase,eax
        movzx   eax,word ptr dwSelector
        mov     ContextDmaParam.ALLOC_CTX_DMA_pBase+4,eax
        mov     eax,dwLimit
        dec     eax
        mov     ContextDmaParam.ALLOC_CTX_DMA_limit,eax
        mov     ContextDmaParam.ALLOC_CTX_DMA_limit+4,0
        mov     eax,ALLOC_CTX_DMA_STATUS_SUCCESS
        mov     ContextDmaParam.ALLOC_CTX_DMA_status,eax
        call    FFP16 PTR lpfnArch_Nv01AllocContextDma

        cmp     ContextDmaParam.ALLOC_CTX_DMA_status,ALLOC_CTX_DMA_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeContextDma
;
; Purpose:      This function frees a Context Dma.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectID              object ID to allocate
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeContextDma, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectID
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov	bx,ss
        shl	ebx,10H
        lea     bx,FreeParam
        push    ebx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     FreeParam.NV01FREE_hObjectParent,ecx
        mov     eax,dwObjectID
        mov     FreeParam.NV01FREE_hObjectOld,eax
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv01Free
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocWinChannelObject
;
; Purpose:      This function allocates any type of object whose parent
;               should be NV_WIN_CHANNEL.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectClass           object class to allocate
;               dwObjectID              object ID to allocate
;
; Returns:      eax     0       failure
;                       non-0   Sucess
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocWinChannelObject, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectClass
PARMD   dwObjectID
LOCALV  AllocObjectParam,ALLOC_OBJECT_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        PUSHSREG ss
        lea     cx,AllocObjectParam
        push    cx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocObjectParam.ALLOC_OBJECT_hClient,ecx
        mov     AllocObjectParam.ALLOC_OBJECT_hObjectParent,NV_WIN_CHANNEL
        mov     eax,dwObjectID
        mov     AllocObjectParam.ALLOC_OBJECT_hObjectNew,eax
        mov     eax,dwObjectClass
        mov     AllocObjectParam.ALLOC_OBJECT_hClass,eax
        mov     AllocObjectParam.ALLOC_OBJECT_status,ALLOC_OBJ_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv01AllocObject

        cmp     AllocObjectParam.ALLOC_OBJECT_status,ALLOC_OBJ_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_RMAllocObject
;
; Purpose:      This function allocates any type of object whose parent
;               should be NV_WIN_CHANNEL.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectClass           object class to allocate
;               dwObjectID              object ID to allocate
;
; Returns:      eax     0       failure
;                       non-0   Sucess
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_RMAllocObject, PASCAL, FRAME, FAR32
PARMD   pHWCRTCCXOffset
PARMD   pHWBoardCXOffset
PARMD   dwObjectClass
PARMD   dwObjectID
LOCALV  AllocParam,ALLOC_PARAM
LOCALV  AllocParms,NV07C_ALLOCATION_PARAMETERS
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWBoardCXOffset
        mov     edi,pHWCRTCCXOffset

;NvRmAlloc(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass,
;          PVOID pAllocParms); //  NvRmApi.h

        sub     eax,eax
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,AllocParms
        add     ecx,eax
        mov     AllocParam.ALLOC_pAllocParms,ecx

        mov     edx,ds:[edi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     AllocParms.logicalHeadId,edx

        PUSHSREG ss
        lea     cx,AllocParam
        push    cx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocParam.ALLOC_hRoot,ecx
        mov     AllocParam.ALLOC_hObjectParent,NV_WIN_CHANNEL
        mov     eax,dwObjectID
        mov     AllocParam.ALLOC_hObjectNew,eax
        mov     eax,dwObjectClass
        mov     AllocParam.ALLOC_hClass,eax
        mov     AllocParam.ALLOC_status,NVOS21_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv04Alloc

        cmp     AllocParam.ALLOC_status,NVOS21_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeWinChannelObject
;
; Purpose:      This function frees an object whose parent is
;               NV_WIN_CHANNEL.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectID              object ID to allocate
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeWinChannelObject, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectID
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        PUSHSREG ss
        lea     bx,FreeParam
        push    bx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     FreeParam.NV01FREE_hObjectParent,NV_WIN_CHANNEL
        mov     eax,dwObjectID
        mov     FreeParam.NV01FREE_hObjectOld,eax
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv01Free
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_DestroyDmaContexts
;
; Purpose:      This function creates all the DMA contexts we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_DestroyDmaContexts, PASCAL, NOFRAME, FAR32
OPENPROC
	push	esi
        pushd	OBJ_DMA_PUSH_BUFFER_NOTIFIER
        call    NV_FreeContextDma

	push	esi
	pushd	OBJ_VRAM_TO_SYSRAM_NOTIFIER0
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_VRAM_TO_SYSRAM_NOTIFIER1
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_SYSRAM_TO_VIDEO_NOTIFIER
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_TO_SYSRAM
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_FROM_SYSRAM
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_FROM_VRAM
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_IN_VRAM
	call	NV_FreeContextDma
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_DestroyObjects
;
; Purpose:      This function destroys all the objects we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_DestroyObjects, PASCAL, NOFRAME, FAR32
OPENPROC

IF 0
        ; Can't do this right now. By the time we get here,
        ; Windows has thrown us into DOS and the push buffer
        ; is disabled at that time. Oh well!

        ; I don't want to have to wait for space anywhere in the
        ; object destruction routines. Just wait for 4K bytes. That
        ; will be enough to hold the whole destruction process.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        CHECKDMASPACE ds,esi,edi,1000H

        call    DestroyContextSurfaces2D
        call    DestroyVramToSysramCopy0
        call    DestroyVramToSysramCopy1
        call    DestroyContextClipRect
        call    DestroyContextPattern
        call    DestroyContextRop
        call    DestroyImageBlit
        call    DestroyRectAndText
        call    DestroyImageFromCpu
        call    DestroySolidLine
        call    DestroyIndexedImageFromCpu

        ; I want to track the byte usage in the DMA buffer accurately,
        ; but I didn't wait for the exact number of dwords needed for
        ; the object destruction routines above. Sync up here.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        lea     eax,[esi].HWBOARDCX.bDmaPushBuffer
        mov     ecx,eax
        sub     ecx,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        or      ecx,JMP_COMMAND
        mov     ds:[edi],ecx
        xor     ecx,JMP_COMMAND
        SETPUTPTR ds,esi,eax
@@:
        cmp     ds:[esi].HWBOARDCX.dwDmaGetPtr,ecx
        jne     @B
ENDIF

	; Now we can actually free all the objects
	push	esi
        pushd	OBJ_CONTEXT_SURFACES_2D
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_CONTEXT_CLIP_RECT
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_CONTEXT_PATTERN
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_CONTEXT_ROP
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_IMAGE_BLIT
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_RECT_AND_TEXT
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_IMAGE_FROM_CPU
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_SOLID_LINE
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_INDEXED_IMAGE_FROM_CPU
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_STRETCHED_IMAGE_FROM_CPU
        call    NV_FreeWinChannelObject
CLOSEPROC

IF 0
;==============================================================================
;
; Function:     DestroyContextSurfaces2D
;
; Purpose:      This function Destroys a ContextSurfaces2D object
;               to be used in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextSurfaces2D, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextSurfaces2dHdr.object,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Null out the context DMAs
        mov     eax,CHNRUN(ContextSurfaces2d.SetContextDmaImageSource,2)
        sub	ecx,ecx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],ecx
        add     edi,14H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyVramToSysramCopy0
;
; Purpose:      This function destroys a MemoryToMemoryFormat object
;               for copying from video memory to system memory.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyVramToSysramCopy0, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat0Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Clear out the context DMA
        mov     eax,CHNRUN(MemoryToMemoryFormat0.SetContextDmaNotifies,3)
        sub	ecx,ecx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],ecx
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyVramToSysramCopy1
;
; Purpose:      This function destroys a MemoryToMemoryFormat object
;               for copying from video memory to system memory.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyVramToSysramCopy1, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat1Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Clear out the context DMA
        mov     eax,CHNRUN(MemoryToMemoryFormat1.SetContextDmaNotifies,3)
        sub	ecx,ecx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],ecx
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyContextClipRect
;
; Purpose:      This function destroys a ContextClipRectangle object
;               for use as a global clip rectangle in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextClipRect, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextClipRectHdr.object,1)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Clear out the context DMA
        mov     eax,CHNRUN(ContextClipRect.SetContextDmaNotifies,1)
        sub	ebx,ebx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        add     edi,10H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyContextPattern
;
; Purpose:      This function destroys an ContextPattern object
;               for use as a global pattern in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextPattern, PASCAL, NOFRAME, NEAR
OPENPROC
	; Don't need to do anything special
CLOSEPROC


;==============================================================================
;
; Function:     DestroyContextRop
;
; Purpose:      This function destroys a ContextRop object
;               for use as a global rop in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextRop, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroyImageBlit
;
; Purpose:      This function destroys an ImageBlit object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyImageBlit, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroyRectAndText
;
; Purpose:      This function destroys a GdiRectangleText object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyRectAndText, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndTextHdr.object,1)
        mov     ebx,OBJ_RECT_AND_TEXT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(RectAndText.SetContextDmaFonts,1)
        sub	ebx,ebx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        add     edi,10H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyImageFromCpu
;
; Purpose:      This function destroys an ImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroySolidLine
;
; Purpose:      This function destroys a RenderSolidLin object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroySolidLine, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroyIndexedImageFromCpu
;
; Purpose:      This function destroys an IndexedImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyIndexedImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(IndexedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_INDEXED_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextDmaLut,1)
        sub	ebx,ebx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        add     edi,10H
        SETPUTPTR ds,esi,edi
CLOSEPROC
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWMACS.INC ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         hwmacs.inc
;
; Purpose:      This file holds some macros that thehardware specific
;               code uses.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A build option
DOIOTOFLUSHCACHE                TEXTEQU <1>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IDEBUG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;USE_ALPHA_CURSOR                TEXTEQU <0>
USE_ALPHA_CURSOR                TEXTEQU <1>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HW_WAIT                         TEXTEQU <0>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JMP_COMMAND                     TEXTEQU <20000000H>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHNOFF          MACRO   HwSegMember
        EXITM   <(OFFSET GDICHAN.&HwSegMember - OFFSET GDICHAN.StartOfChannelHdr)>
ENDM

CHNRUN          MACRO   HwSegMember,runlen
        EXITM   <(CHNOFF(HwSegMember) + ((runlen) SHL 18))>
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WAIT_UNTIL_OTHER_CONTEXTS_IDLE  MACRO   sreg,hwcxreg,tempreg,mylabel
        LOCAL   skip,dskip

IF      (HW_WAIT NE 0)
        mov     tempreg,sreg:[hwcxreg].HWBOARDCX.dwGdiDriverChannelID
        cmp     tempreg,sreg:[hwcxreg].HWBOARDCX.dwCurrentChannelID
        jne     dskip
        push    hwcxreg
        call    WaitUntilGdiContextIdle
dskip:
ENDIF
        ; This macro should test a bit to see if any other contexts
        ; are active. If there are, then it should call the function
        ; WaitUntilOtherContextsIdle. The sreg:reg should point to
        ; the PDEVICE. tempreg will be trashed.
        mov     tempreg,sreg:[hwcxreg].HWBOARDCX.dwGdiDriverChannelID
        cmp     tempreg,sreg:[hwcxreg].HWBOARDCX.dwCurrentChannelID
        je      skip
        mov     sreg:[hwcxreg].HWBOARDCX.dwCurrentChannelID,tempreg
        push    hwcxreg
        call    WaitUntilOtherContextsIdle

        IFNB    <mylabel>
                jmp     mylabel
        ENDIF
skip:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECKDMASPACE   MACRO   sreg,hwcxreg,pushbufferreg,bytes
        LOCAL   skip, skip2

IFDIFI  <pushbufferreg>,<edi>
        IFDIFI  <pushbufferreg>,<NONE>
                echo  pushbufferreg_ argument must either be edi or NONE in CHECKDMASPACE
                .err
        ENDIF
ENDIF
        sub     sreg:[hwcxreg].HWBOARDCX.dwBytesFree,bytes
        jge     skip
IFDIFI  <pushbufferreg>,<NONE>
        mov     sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset,pushbufferreg
ENDIF
        push    hwcxreg
        pushd   bytes
        call    WaitForDmaBufferSpace

IFDIFI  <pushbufferreg>,<NONE>
        mov     pushbufferreg,sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset
ENDIF


skip:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETDMASTATUS    MACRO   stataddr
        mov     stataddr,-1
ENDM

WAITDMASTATUS   MACRO   stataddr
        LOCAL   back

back:   cmp     stataddr,-1
        je      back
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STARTTIME	MACRO	
IFDEF	DEBUG
	PUSHR	es,eax,edx
	mov	ax,_DATA
	mov	es,ax
	rdtsc
	mov	es:[qwStartTime],eax
	mov	es:[qwStartTime+4],edx
	POPR	es,eax,edx
ENDIF
ENDM

STOPTIME	MACRO	qwThisTime
IFDEF	DEBUG
	PUSHR	es,eax,edx
	mov	ax,_DATA
	mov	es,ax
	rdtsc
	sub	eax,es:[qwStartTime]
	sbb	edx,es:[qwStartTime+4]
	add	es:[qwThisTime],eax
	adc	es:[qwThisTime+4],edx
	POPR	es,eax,edx
ENDIF
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETPUTPTR       MACRO   sreg,hwcxreg,pushbufferreg
        LOCAL   DoneFlush

        or      byte ptr sreg:[pushbufferreg - 40H],0
        mov     sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset,pushbufferreg
        sub     pushbufferreg,sreg:[hwcxreg].HWBOARDCX.pPushBufferContextStartOffset

IF (DOIOTOFLUSHCACHE NE 0)
        push    OFFSET DoneFlush
        cmp     sreg:[hwcxreg].HWBOARDCX.dwFlushCacheWithIO,0
        jne     FlushChipsetCache
        add     sp,4
DoneFlush:
ENDIF
        mov     sreg:[hwcxreg].HWBOARDCX.dwDmaPutPtr,pushbufferreg
        mov     pushbufferreg,sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset
ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
INTERNAL_BEGINACCESS    MACRO   sreg,tempreg
        LOCAL   skip
        mov     tempreg,HWSEGDATA(sreg,dwGetOffsetAtLastBeginAccess)
        cmp     tempreg,HWSEGDATA(sreg,dwCurrentPushBufferOffset)
        je      skip
        call    HW_InternalBeginAccess
skip:
ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECKDSTBASE    MACRO   CXSel,hwcxreg,DmaOff,DstBase,DstPitch
        LOCAL   skip

IFDIFI  <DmaOff>,<edi>
        echo The DmaOffargument to the CHECKDSTBASE macro is not edi
        echo The macro will need modification.
        .err
ENDIF
        cmp     DstBase,CXSel:[hwcxreg].HWBOARDCX.dwContextSurface2dDstOffset
        je      skip
        push    hwcxreg
        pushd   DstBase
        pushd   DstPitch
IFIDNI          <CXSel>,<ds>
        call    SetDstBaseAndPitchToDsEdi
ELSEIFIDN       <CXSel>,<es>
        call    SetDstBaseAndPitchToEsEdi
ELSE
        echo Unknown CXSel arg to macro CHECKDSTBASE
        .err
ENDIF
skip:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NV10 requires 4K byte alignment. NV4/NV5 only require 2K but
; since 4K works for everyone, that is what we use.
HW_CURSOR_WIDTH         TEXTEQU  <CURSOR_WIDTH>
HW_CURSOR_HEIGHT        TEXTEQU  <CURSOR_HEIGHT>
HW_CURSOR_ALIGN         TEXTEQU  <4096>

NV_CURSOR_SET_PARAM     TEXTEQU <1>     ; Indicates that the rest of the
                                        ;   cursor image parameters are valid
                                        ;   and they should be programmed
                                        ;   into the hardware.
NV_CURSOR_SET_ENABLE    TEXTEQU <2>     ; Indicates that the cursor's enable
                                        ;   disable state should be changed.
NV_CURSOR_ENABLE        TEXTEQU <4>     ; Used in conjunction with
                                        ;   NV_CURSOR_SET_ENABLE.
NV_CURSOR_DISABLE       TEXTEQU <0>     ; Used in conjunction with
                                        ;   NV_CURSOR_SET_ENABLE.

; 16 bpp color cursor
; 32 bpp color cursor w/ alpha
HW_CURSOR_16_SIZE       TEXTEQU  <(HW_CURSOR_WIDTH * HW_CURSOR_HEIGHT * 2)>
HW_CURSOR_32_SIZE       TEXTEQU  <(HW_CURSOR_WIDTH * HW_CURSOR_HEIGHT * 4)>

IF      USE_ALPHA_CURSOR
HW_CURSOR_SIZE  TEXTEQU <((HW_CURSOR_32_SIZE + HW_CURSOR_ALIGN - 1) AND (NOT (HW_CURSOR_ALIGN - 1)))>
ELSE
HW_CURSOR_SIZE  TEXTEQU <((HW_CURSOR_16_SIZE + HW_CURSOR_ALIGN - 1) AND (NOT (HW_CURSOR_ALIGN - 1)))>
ENDIF   ; USE_ALPHA_CURSOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
; hwaccess
EXTERNDEF       WaitUntilGdiContextIdle:NEAR

; hwboard.asm
EXTERNDEF       NV_GetDeviceNumber:NEAR
EXTERNDEF       NV_AllocRoot:NEAR
EXTERNDEF       NV_FreeRoot:NEAR
EXTERNDEF       NV_AllocDevice:NEAR
EXTERNDEF       NV_GetMemoryInfo:NEAR
EXTERNDEF       NV_GetDeviceInfo:NEAR
EXTERNDEF       NV_GetDeviceVersion:NEAR
EXTERNDEF       NV_GetBusType:NEAR
EXTERNDEF       NV_GetNumCRTCs:NEAR
EXTERNDEF       NV_AllocPushBuffer:NEAR
EXTERNDEF       NV_AllocChannelDma:NEAR
EXTERNDEF       NV_AllocPages:NEAR
EXTERNDEF       NV_AllocMemory:FAR32
EXTERNDEF       NV_FreeMemory:FAR32
EXTERNDEF       NV_AllocLinearAddressSpace:NEAR
EXTERNDEF       NV_FreeLinearAddressSpace:NEAR
EXTERNDEF       NV_CopyPTEsForLinearRange:NEAR
EXTERNDEF       NV_GetGdiChannelMask:NEAR
EXTERNDEF       NV_AllocRequiredMemory:NEAR
EXTERNDEF       NV_GetCursorCacheInfo:NEAR
EXTERNDEF       NV_BoardSetDXSharedData:FAR32

; hwboard2.asm
EXTERNDEF       Enable_HiRes:FAR32
EXTERNDEF       NV_ConfigExCall:FAR32
EXTERNDEF       NV_ConfigExSetCall:FAR32
EXTERNDEF       NV_OffscreenHeapAlloc:FAR32
EXTERNDEF       NV_OffscreenHeapFree:FAR32
EXTERNDEF       NV_OffscreenHeapPurge:FAR32

; hwcrtc.asm
EXTERNDEF       NV_CrtcSetLogdev:FAR32
EXTERNDEF       HW_GetPhysicalCrtcIndex:FAR32
EXTERNDEF       NV_GetEncoderInfo:NEAR
EXTERNDEF       CreateVideoLutCursorDac:NEAR
EXTERNDEF       DestroyVideoLutCursorDac:NEAR
EXTERNDEF       NV_AllocHeadRelatedInfo:NEAR
EXTERNDEF       NV_FreeHeadRelatedInfo:NEAR

; hwcrtc2.asm
EXTERNDEF       NV_SetColorMap:FAR32

; Functions in hwinit.asm
EXTERNDEF       NvSysTable:WORD
EXTERNDEF       hNvSysDll:WORD
EXTERNDEF       wHWCSAlias:WORD
EXTERNDEF       lpfnNvSysMoveCursor:DWORD
EXTERNDEF       lpfnNvSysUpdateImageOffsetFormat:DWORD
EXTERNDEF       lpfnNvSysGetRamInfo:DWORD
EXTERNDEF       lpfnNvSysAllocPages:DWORD
EXTERNDEF       lpfnNvSysFreePages:DWORD
EXTERNDEF       lpfnNvConfigGet:DWORD
EXTERNDEF       lpfnNvConfigSet:DWORD
EXTERNDEF       lpfnNvConfigUpdate:DWORD
EXTERNDEF       lpfnNvConfigVga:DWORD
EXTERNDEF       lpfnNvSysSetCursorImage:DWORD
EXTERNDEF       lpfnNvSysGetHardwarePointers:DWORD
EXTERNDEF       lpfnNvDeviceBaseGet:DWORD
EXTERNDEF       lpfnNvDeviceLimitGet:DWORD
EXTERNDEF       lpfnNvSysDriverConnect:DWORD
EXTERNDEF       lpfnNvSysDriverDisConnect:DWORD
EXTERNDEF       lpfnNvSysRegisterDisplayDriver:DWORD
EXTERNDEF       lpfnNvIoControl:DWORD
EXTERNDEF       lpfnArch_Nv01Free:DWORD
EXTERNDEF       lpfnArch_Nv01AllocRoot:DWORD
EXTERNDEF       lpfnArch_Nv01AllocMemory:DWORD
EXTERNDEF       lpfnArch_Nv01AllocContextDma:DWORD
EXTERNDEF       lpfnArch_Nv01AllocChannelPio:DWORD
EXTERNDEF       lpfnArch_Nv01AllocObject:DWORD
EXTERNDEF       lpfnArch_Nv01AllocDevice:DWORD
EXTERNDEF       lpfnArch_Nv03AllocChannelDma:DWORD
EXTERNDEF       lpfnArch_Nv03DmaFlowControl:DWORD
EXTERNDEF       lpfnArch_Nv01Interrupt:DWORD
EXTERNDEF       lpfnArch_Nv01AllocEvent:DWORD
EXTERNDEF       lpfnArch_NvI2CAccess:DWORD
EXTERNDEF       lpfnArch_Nv04ConfigGetEx:DWORD
EXTERNDEF       lpfnArch_Nv04ConfigSetEx:DWORD
EXTERNDEF       lpfnArch_Nv04Alloc:DWORD

; hwcur32.asm
IF  (USE_ALPHA_CURSOR NE 0)
EXTERNDEF       HW_CursorSet8888:NEAR
EXTERNDEF       SetCursor_1Bpp_8888:NEAR
EXTERNDEF       SetCursor_4Bpp_8888:NEAR
EXTERNDEF       SetCursor_8Bpp_8888:NEAR
EXTERNDEF       SetCursor_15Bpp_8888:NEAR
EXTERNDEF       SetCursor_16Bpp_8888:NEAR
EXTERNDEF       SetCursor_24Bpp_8888:NEAR
EXTERNDEF       SetCursor_32Bpp_8888:NEAR
EXTERNDEF       SetCursor_3XBpp_8888:NEAR
ENDIF

; hwcursor.asm
EXTERNDEF       SetCursor_1Bpp_1555:NEAR
EXTERNDEF       SetCursor_4Bpp_1555:NEAR
EXTERNDEF       SetCursor_8Bpp_1555:NEAR
EXTERNDEF       SetCursor_15Bpp_1555:NEAR
EXTERNDEF       SetCursor_16Bpp_1555:NEAR
EXTERNDEF       SetCursor_24Bpp_1555:NEAR
EXTERNDEF       SetCursor_32Bpp_1555:NEAR
EXTERNDEF       SetCursor_3XBpp_1555:NEAR

; in hwpatblt.asm
EXTERNDEF       bConvertPatDstToSrcDstRop:BYTE

; hwrect.asm
EXTERNDEF       bConvertRop2ToRop3:BYTE

; Functions in misc.asm
EXTERNDEF       dwContextSurface2DColorFormat:DWORD
EXTERNDEF       SetDstBaseAndPitchToDsEdi:NEAR
EXTERNDEF       SetDstBaseAndPitchToEsEdi:NEAR
EXTERNDEF       WaitUntilOtherContextsIdle:NEAR
EXTERNDEF       FlushChipsetCache:NEAR
EXTERNDEF       WaitForDmaBufferSpace:NEAR

; misc.asm
EXTERNDEF       SetDstBaseAndPitchToDsEdi:NEAR
EXTERNDEF       SetDstBaseAndPitchToEsEdi:NEAR
EXTERNDEF       WaitUntilOtherContextsIdle:NEAR
EXTERNDEF       FlushChipsetCache:NEAR
EXTERNDEF       WaitForDmaBufferSpace:NEAR

; objects.asm
EXTERNDEF       NV_CreateDmaContexts:FAR32
EXTERNDEF       NV_DestroyDmaContexts:FAR32
EXTERNDEF       NV_CreateObjects:FAR32
EXTERNDEF       NV_DestroyObjects:FAR32
EXTERNDEF       NV_AllocContextDma:FAR32
EXTERNDEF       NV_FreeContextDma:FAR32
EXTERNDEF       NV_AllocWinChannelObject:FAR32
EXTERNDEF       NV_FreeWinChannelObject:FAR32
EXTERNDEF       NV_RMAllocObject:FAR32
CLOSESEG _NVTEXT32


OPENSEG  _NVTEXT16, USE16, CODE
; hwcntrl.asm
EXTERNDEF       NV_GetFlatModeSwitchPtrCount:NEAR
EXTERNDEF       NV_GetFlatActiveChannelPtr:NEAR
EXTERNDEF       NV_GetEscapeID:NEAR
EXTERNDEF       NV_IsNvidiaBasedBoardAndDiver:NEAR
EXTERNDEF       NV_GetHardwarePointers:NEAR
EXTERNDEF       NV_GetFlatDirectXSharedData:NEAR
EXTERNDEF       NV_IncModeSitchCounter:NEAR
EXTERNDEF       NV_IntelDiags:NEAR

; hwidiag
EXTERNDEF       NV_IntelDiagnostics:FAR16

; hwlogdev2.asm
EXTERNDEF       NV_PostModeset:FAR16
EXTERNDEF       NV_CreateDrvObj:FAR16
EXTERNDEF       DirectCallToFlatland:FAR16
EXTERNDEF       NV_DirectXServiceNoFrame:FAR32
EXTERNDEF       NV_DirectXService:NEAR
CLOSESEG _NVTEXT16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\GDIDEFS.INC ===
;/*
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;       GDI Definitions for Device Drivers
;
;       Since most of the routines only need a portion of these definitions,
;       conditional assembly flags have been defined in the various files
;       to only include portions as needed (as opposed to having a lot of
;       include files to mess with).  The flags are as follows:
;
;       incFont         include font definitions
;       incDevice       include device definitions
;       incLogical      include logical object definitions
;       incDrawmode     include DrawMode structure definition
;       incOutput       include Output definitions
;       incControl      include Control definitions
;       incPolyScanline include Scan definition

page
;       General definitions that almost everyone will use.



;       Physical Bitmap Structure
;
;       Bitmap data structure passed to OEM routines.  Defines the location and
;       size of a main memory bitmap.



BITMAP          struc                                                       ;*/ typedef struct {                 /*

  bmType            dw  0       ; 0 means main memory bitmap.  Non-zero     ;*/ short int bmType;                /*
                                ; is number of physical display and format
                                ; of the rest of the structure known only
                                ; to device driver
  bmWidth           dw  0       ; Width of bitmap in pixels                 ;*/ unsigned short int bmWidth;      /*
  bmHeight          dw  0       ; Height of bitmap in pixels                ;*/ unsigned short int bmHeight;     /*
  bmWidthBytes      dw  0       ; #bytes per scan line                      ;*/ unsigned short int bmWidthBytes; /*
  bmPlanes          db  0       ; # of planes in bitmap                     ;*/ BYTE               bmPlanes;     /*
  bmBitsPixel       db  0       ; # of bits per pixel                       ;*/ BYTE               bmBitsPixel;  /*
  bmBits            dd  0       ; Far pointer to bits of main memory bitmap ;*/ BYTE FAR          *bmBits;       /*
  bmWidthPlanes     dd  0       ; Product of bmWidthBytes and bmHeight      ;*/ unsigned long int  bmWidthPlanes;/*
  bmlpPDevice       dd  0       ; Pointer to associated PDevice             ;*/ BYTE FAR          *bmlpPDevice;  /*
  bmSegmentIndex    dw  0       ; Index to plaens next segment if non-zero  ;*/ unsigned short int bmSegmentIndex; /*
  bmScanSegment     dw  0       ; Number of scans per segment               ;*/ unsigned short int bmScanSegment; /*
  bmFillBytes       dw  0       ; Number of unused bytes per segment        ;*/ unsigned short int bmFillBytes;   /*
                    dw  0                                                   ;*/ unsigned short int futureUse4;    /*
                    dw  0                                                   ;*/ unsigned short int futureUse5;    /*
BITMAP              ends                                                    ;*/ } BITMAP;                         /*

; structures used for Device Independent Bitmap (DIB) processing.
; all taken out of Presentation Manager's documentation
;  Tuesday 25-October-1988 15:04   -by-   Ron Gery [rong]

; C definitions are provided below (separately).

; triple used in PM1.1 (BitmapCoreInfo) format color table
RGBTriple           struc
  rgbtBlue          db  0
  rgbtGreen         db  0
  rgbtRed           db  0
RGBTriple           ends

; RGB DWORD used in PM2.0 format color table
RGBQuad             struc
  rgbBlue           db  0
  rgbGreen          db  0
  rgbRed            db  0
  rgbReserved       db  0
RGBQuad             ends

BitmapCoreHeader    struc
  bcSize            dd  0
  bcWidth           dw  0
  bcHeight          dw  0
  bcPlanes          dw  0
  bcBitCount        dw  0
BitmapCoreHeader    ends

; new format bitmap structure based on PM2.0 format DCR.
;  Tuesday 23-May-1989 16:05   -by-   Ron Gery [rong]

BitmapInfoHeader    struc
  biSize            dd  0
  biWidth           dd  0
  biHeight          dd  0
  biPlanes          dw  0
  biBitCount        dw  0

  biCompression     dd  0
  biSizeImage       dd  0
  biXPelsPerMeter   dd  0
  biYPelsPerMeter   dd  0
  biClrUsed         dd  0
  biClrImportant    dd  0
BitmapInfoHeader    ends

BitmapInfo          struc
  bmiHeader     db (size BitmapInfoHeader) DUP (?)
  bmiColors     db ?                    ; array of RGBQUADS
BitmapInfo          ends

BitmapCoreInfo      struc
  bmciHeader    db (size BitmapCoreHeader) DUP (?)
  bmciColors    db ?                    ; array of RGBTRIPLES
BitmapCoreInfo      ends

BI_RGB          equ    0h
BI_RLE8         equ    1h
BI_RLE4         equ    2h
BI_BITFIELDS    equ    3h

BitmapV4Header  struc
  bV4Size           dd  0
  bV4Width          dd  0
  bV4Height         dd  0
  bV4Planes         dw  0
  bV4BitCount       dw  0
  bV4Compression    dd  0
  bV4SizeImage      dd  0
  bV4XPelsPerMeter  dd  0
  bV4YPelsPerMeter  dd  0
  bV4ClrUsed        dd  0
  bV4ClrImportant   dd  0
  bV4RedMask        dd  0
  bV4GreenMask      dd  0
  bV4BlueMask       dd  0
  bV4AlphaMask      dd  0
  bV4CSType         dd  0
  bV4Endpoints      db  36 dup (0)
  bV4GammaRed       dd  0
  bV4GammaGreen     dd  0
  bV4GammaBlue      dd  0
BitmapV4Header    ends


        if      0

*/
/* C definitions for DIBs, as defined in windows.h */

typedef struct {
        DWORD   bcSize;
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;

typedef struct {
        DWORD      biSize;
        DWORD      biWidth;
        DWORD      biHeight;
        WORD       biPlanes;
        WORD       biBitCount;

        DWORD      biCompression;
        DWORD      biSizeImage;
        DWORD      biXPelsPerMeter;
        DWORD      biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

typedef struct {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;

typedef struct {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of
// CIEXYZ. The values are fixed point 16.16.

typedef long            FXPT16DOT16, FAR *LPFXPT16DOT16;
typedef long            FXPT2DOT30, FAR *LPFXPT2DOT30;

typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ  FAR *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE    FAR *LPCIEXYZTRIPLE;

typedef struct {
    BITMAPCOREHEADER    bmciHeader;
    RGBQUAD             bmciColors[1];
} BITMAPCOREINFO;

typedef BITMAPCOREINFO FAR *LPBITMAPCOREINFO;
typedef BITMAPCOREINFO *PBITMAPCOREINFO;

typedef struct {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO;

typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;

typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER, FAR *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

typedef struct {
    BITMAPV4HEADER      bmv4Header;
    RGBQUAD             bmv4Colors[1];
} BITMAPV4INFO;

typedef BITMAPV4INFO FAR *LPBITMAPV4INFO;
typedef BITMAPV4INFO *PBITMAPV4INFO;

/* currently, if the low byte of biCompression is non zero,
 * it must be one of following */

#define BI_RGB              0x00
#define BI_RLE8             0x01
#define BI_RLE4             0x02
#define BI_BITFIELDS        0x03

#define BITMAP_SELECTED     0x01
#define BITMAP_64K          0x01

#define DIBSIGNATURE        0x4944
/*
        endif

    if      0
*/
#ifndef NOPTRC
/*
    endif


PTTYPE          struc                                                       ;*/ typedef     struct {        /*

  xcoord        dw      0               ;x coordinate of point              ;*/ short int xcoord;           /*
  ycoord        dw      0               ;y coordinate of point              ;*/ short int ycoord;           /*

PTTYPE          ends                                                        ;*/ } PTTYPE;                   /*
                                                                            ;*/ typedef PTTYPE *PPOINT;     /*
                                                                            ;*/ typedef PTTYPE FAR *LPPOINT; /*
    if      0
*/
#define     POINT   PTTYPE
/*
    endif



RECT            struc                                                       ;*/ typedef struct {            /*

  left          dw      0                                                   ;*/ short int left,             /*
  top           dw      0                                                   ;*/           top,              /*
  right         dw      0                                                   ;*/           right,            /*
  bottom        dw      0                                                   ;*/           bottom;           /*

RECT            ends                                                        ;*/ } RECT;                     /*
                                                                            ;*/ typedef RECT  *PRECT;       /*

    if      0
*/
#endif
/*
    endif


BOXTYPE         struc                                                       ;*/ typedef     struct {        /*

  min           db      SIZE PTTYPE dup (?)   ;x,y starting coord           ;*/ PTTYPE min;                 /*
  ext           db      SIZE PTTYPE dup (?)   ;x,y extents                  ;*/ PTTYPE ext;                 /*

BOXTYPE         ends                                                        ;*/ } BOXTYPE;                  /*


                                                                            ;*/ typedef RECT  FAR * LPRECT; /*

page
;       Logical Object Definitions  - incLogical
                ifdef   incLogical
                if      incLogical



OBJ_PEN         equ     1
OBJ_BRUSH       equ     2
OBJ_FONT        equ     3

    if  0
*/
/* Object definitions used by GDI support routines written in C */

#define OBJ_PEN         1
#define OBJ_BRUSH       2
#define OBJ_FONT        3
/*
    endif


LogBrush        struc                                                       ;*/ typedef struct {            /*
  lbStyle       dw      0               ;Style of logical BRUSH             ;*/ unsigned short int lbStyle; /*
  lbColor       dd      0               ;RGB color                          ;*/ unsigned long int  lbColor; /*
  lbHatch       dw      0               ;Hatching style                     ;*/ unsigned short int lbHatch; /*
  lbBkColor     dd      0               ;Background color for hatched brush ;*/ unsigned long int lbBkColor;/*
  lbhcmXform    dd      0               ;transform for image color matching ;*/ unsigned long int lbhcmXform;/*
LogBrush        ends                                                        ;*/ } LOGBRUSH;                 /*

;lbPattern      =       lbColor          ; pointer to physical pattern

    if  0
*/
#define lbPattern       lbColor
/*
    endif



;       Brush styles defined by GDI

BS_SOLID        equ     0
BS_HOLLOW       equ     1
BS_HATCHED      equ     2
BS_PATTERN      equ     3

MaxBrushStyle   equ     3



;       Hatched Brush hatching styles defined by GDI

HS_HORIZONTAL   equ     0               ; Horizontal             -----
HS_VERTICAL     equ     1               ; Vertical               |||||
HS_FDIAGONAL    equ     2               ; Foreward Diagonal      /////
HS_BDIAGONAL    equ     3               ; Backward Diagonal      \\\\\
HS_CROSS        equ     4               ; Cross                  +++++
HS_DIAGCROSS    equ     5               ; Diagonal Cross         XXXXX

MaxHatchStyle   equ     5

    if  0
*/
/* Brush Style definitions used by GDI support routines written in C */

#define     BS_SOLID            0
#define     BS_HOLLOW           1
#define     BS_HATCHED          2
#define     BS_PATTERN          3

#define     MaxBrushStyle       3


/* Hatch Style definitions used by GDI support routines written in C */

#define     HS_HORIZONTAL       0       /* ----- */
#define     HS_VERTICAL         1       /* ||||| */
#define     HS_FDIAGONAL        2       /* ///// */
#define     HS_BDIAGONAL        3       /* \\\\\ */
#define     HS_CROSS            4       /* +++++ */
#define     HS_DIAGCROSS        5       /* xxxxx */

#define     MaxHatchStyle       5
/*
    endif




;       Logical Pen Structure

LogPen          struc                                                       ;*/ typedef struct {            /*
  lopnStyle     dw      0               ;(solid, hollow, dashed..)          ;*/ unsigned short int lopnStyle;/*
  lopnWidth     dw      0               ;This is really a point type        ;*/ PTTYPE             lopnWidth;/*
                dw      0
  lopnColor     dd      0                                                   ;*/ unsigned long int  lopnColor;/*
  lopnStyle2    dw      0               ;end caps and joins                 ;*/ unsigned short int lopnStyle2;/*
  lopnhcmXform  dd      0               ;transform for image color matching ;*/ unsigned long int  lopnhcmXform;/*
LogPen          ends                                                        ;*/ } LOGPEN;                   /*

;                errnz   <(SIZE PTTYPE) -4>



;       Line Style definitions for lopnStyle

LS_SOLID        equ       0
LS_DASHED       equ       1
LS_DOTTED       equ       2
LS_DOTDASHED    equ       3
LS_DASHDOTDOT   equ       4
LS_NOLINE       equ       5
LS_INSIDEFRAME  equ       6
MaxLineStyle    equ     LS_NOLINE

;       Line Style definitions for lopnStyle2

LS_ENDCAP_FLAT  equ     01h
LS_ENDCAP_ROUND equ     02h
LS_ENDCAP_SQUARE equ    04h
LS_JOIN_BEVEL   equ     08h
LS_JOIN_MITER   equ     10h
LS_JOIN_ROUND   equ     20h

    if  0
*/
/* Line Style definitions used by GDI support routines written in C */

#define     LS_SOLID            0
#define     LS_DASHED           1
#define     LS_DOTTED           2
#define     LS_DOTDASHED        3
#define     LS_DASHDOTDOT       4
#define     LS_NOLINE           5
#define     LS_INSIDEFRAME      6
#define     MaxLineStyle        LS_NOLINE

#define     LS_ENDCAP_FLAT      0x01
#define     LS_ENDCAP_ROUND     0x02
#define     LS_ENDCAP_SQUARE    0x04
#define     LS_JOIN_BEVEL       0x08
#define     LS_JOIN_MITER       0x10
#define     LS_JOIN_ROUND       0x20

/*
    endif



; Various constants for defining a logical font.
LF_FACESIZE             equ     32
OUT_DEFAULT_PRECIS      equ     0
OUT_STRING_PRECIS       equ     1
OUT_CHARACTER_PRECIS    equ     2
OUT_STROKE_PRECIS       equ     3
OUT_TT_PRECIS           equ     4
OUT_DEVICE_PRECIS       equ     5
OUT_RASTER_PRECIS       equ     6
OUT_TT_ONLY_PRECIS      equ     7

CLIP_DEFAULT_PRECIS     equ     0
CLIP_CHARACTER_PRECIS   equ     1
CLIP_STROKE_PRECIS      equ     2
CLIP_MASK               equ     00Fh
CLIP_LH_ANGLES          equ     010h
CLIP_TT_ALWAYS          equ     020h
CLIP_EMBEDDED           equ     080h

DEFAULT_QUALITY         equ     0
DRAFT_QUALITY           equ     1
PROOF_QUALITY           equ     2

DEFAULT_PITCH           equ     0
FIXED_PITCH             equ     1
VARIABLE_PITCH          equ     2

ANSI_CHARSET            equ     0
DEFAULT_CHARSET         equ     1
SYMBOL_CHARSET          equ     2
MAC_CHARSET             equ     77
SHIFTJIS_CHARSET        equ     128
HANGEUL_CHARSET         equ     129
CHINESEBIG5_CHARSET     equ     136
OEM_CHARSET             equ     255



;       GDI font families.
FF_DONTCARE             equ 00000000b   ; Don't care or don't know.
FF_ROMAN                equ 00010000b   ; Variable stroke width, serifed.
                                        ; Times Roman, Century Schoolbook, etc.
FF_SWISS                equ 00100000b   ; Variable stroke width, sans-serifed.
                                        ; Helvetica, Swiss, etc.
FF_MODERN               equ 00110000b   ; Constant stroke width, serifed or sans-serifed.
                                        ; Pica, Elite, Courier, etc.
FF_SCRIPT               equ 01000000b   ; Cursive, etc.
FF_DECORATIVE           equ 01010000b   ; Old English, etc.


;       Font weights lightest to darkest.
FW_DONTCARE             equ     0d
FW_THIN                 equ     100d
FW_EXTRALIGHT           equ     200d
FW_LIGHT                equ     300d
FW_NORMAL               equ     400d
FW_MEDIUM               equ     500d
FW_SEMIBOLD             equ     600d
FW_BOLD                 equ     700d
FW_EXTRABOLD            equ     800d
FW_HEAVY                equ     900d

FW_ULTRALIGHT           equ     FW_EXTRALIGHT
FW_REGULAR              equ     FW_NORMAL
FW_DEMIBOLD             equ     FW_SEMIBOLD
FW_ULTRABOLD            equ     FW_EXTRABOLD
FW_BLACK                equ     FW_HEAVY


; Enumeration font types.
RASTER_FONTTYPE         equ     1
DEVICE_FONTTYPE         equ     2

    if  0
*/

/* The size to allocate for the lfFaceName field in the logical font. */
#ifndef     LF_FACESIZE
#define     LF_FACESIZE     32
#endif

/* Various constants for defining a logical font. */
#define     OUT_DEFAULT_PRECIS      0
#define     OUT_STRING_PRECIS       1
#define     OUT_CHARACTER_PRECIS    2
#define     OUT_STROKE_PRECIS       3
#define     OUT_TT_PRECIS           4
#define     OUT_DEVICE_PRECIS       5
#define     OUT_RASTER_PRECIS       6
#define     OUT_TT_ONLY_PRECIS      7

#define     CLIP_DEFAULT_PRECIS     0
#define     CLIP_CHARACTER_PRECIS   1
#define     CLIP_STROKE_PRECIS      2
#define     CLIP_MASK               0x0F
#define     CLIP_LH_ANGLES          0x10
#define     CLIP_TT_ALWAYS          0x20
#define     CLIP_EMBEDDED           0x80

#define     DEFAULT_QUALITY         0
#define     DRAFT_QUALITY           1
#define     PROOF_QUALITY           2

#define     DEFAULT_PITCH           0
#define     FIXED_PITCH             1
#define     VARIABLE_PITCH          2

#define     ANSI_CHARSET            0
#define     DEFAULT_CHARSET         1
#define     SYMBOL_CHARSET          2
#define     MAC_CHARSET             77
#define     SHIFTJIS_CHARSET        128
#define     HANGEUL_CHARSET         129
#define     CHINESEBIG5_CHARSET     136
#define     OEM_CHARSET             255


/*      GDI font families.                                              */
#define FF_DONTCARE     (0<<4)  /* Don't care or don't know.            */
#define FF_ROMAN        (1<<4)  /* Variable stroke width, serifed.      */
                                /* Times Roman, Century Schoolbook, etc.*/
#define FF_SWISS        (2<<4)  /* Variable stroke width, sans-serifed. */
                                /* Helvetica, Swiss, etc.               */
#define FF_MODERN       (3<<4)  /* Constant stroke width, serifed or sans-serifed. */
                                /* Pica, Elite, Courier, etc.           */
#define FF_SCRIPT       (4<<4)  /* Cursive, etc.                        */
#define FF_DECORATIVE   (5<<4)  /* Old English, etc.                    */


/*      Font weights lightest to darkest.                               */
#define FW_DONTCARE             0
#define FW_THIN                 100
#define FW_EXTRALIGHT           200
#define FW_LIGHT                300
#define FW_NORMAL               400
#define FW_MEDIUM               500
#define FW_SEMIBOLD             600
#define FW_BOLD                 700
#define FW_EXTRABOLD            800
#define FW_HEAVY                900

#define FW_ULTRALIGHT           FW_EXTRALIGHT
#define FW_REGULAR              FW_NORMAL
#define FW_DEMIBOLD             FW_SEMIBOLD
#define FW_ULTRABOLD            FW_EXTRABOLD
#define FW_BLACK                FW_HEAVY

/* Enumeration font types. */
#define     RASTER_FONTTYPE         1
#define     DEVICE_FONTTYPE         2

/*
    endif


LogFont         struc                                                       ;*/ typedef     struct  {          /*

  lfHeight            dw      0                                             ;*/ short int lfHeight;            /*
  lfWidth             dw      0                                             ;*/ short int lfWidth;             /*
  lfEscapement        dw      0                                             ;*/ short int lfEscapement;        /*
  lfOrientation       dw      0                                             ;*/ short int lfOrientation;       /*
  lfWeight            dw      0                                             ;*/ short int lfWeight;            /*
  lfItalic            db      0                                             ;*/ BYTE lfItalic;                 /*
  lfUnderline         db      0                                             ;*/ BYTE lfUnderline;              /*
  lfStrikeOut         db      0                                             ;*/ BYTE lfStrikeOut;              /*
  lfCharSet           db      0                                             ;*/ BYTE lfCharSet;                /*
  lfOutPrecision      db      0                                             ;*/ BYTE lfOutPrecision;           /*
  lfClipPrecision     db      0                                             ;*/ BYTE lfClipPrecision;          /*
  lfQuality           db      0                                             ;*/ BYTE lfQuality;                /*
  lfPitchAndFamily    db      0                                             ;*/ BYTE lfPitchAndFamily;         /*
  lfFaceName          db LF_FACESIZE dup(0) ; A variable length field for the face name.;*/ BYTE lfFaceName[LF_FACESIZE];  /*

LogFont         ends                                                        ;*/ } LOGFONT;                     /*


                endif
                endif
page
;               Device Definitions - incDevice


                ifdef   incDevice
                if      incDevice


InquireInfo     =       00000001b       ;Inquire Device GDI Info
EnableDevice    =       00000000b       ;Enable Device
InfoContext     =           8000h       ;Inquire/Enable for information context


;               Device Technologies

DT_PLOTTER      equ     0               ; Vector plotter
DT_RASDISPLAY   equ     1               ; Raster display
DT_RASPRINTER   equ     2               ; Raster printer
DT_RASCAMERA    equ     3               ; Raster camera
DT_CHARSTREAM   equ     4               ; Character-stream, PLP
DT_METAFILE     equ     5               ; Metafile, VDM
DT_DISPFILE     equ     6               ; Display-file
DT_JUMBO        equ     11              ; SPAG LJ cool thing

;               Curve Capabilities

CC_NONE         equ 0000000000000000B   ; Curves not supported
CC_CIRCLES      equ 0000000000000001B   ; Can do circles
CC_PIE          equ 0000000000000010B   ; Can do pie wedges
CC_CHORD        equ 0000000000000100B   ; Can do chord arcs
CC_ELLIPSES     equ 0000000000001000B   ; Can do ellipses (full arcs)
CC_WIDE         equ 0000000000010000B   ; Can do wide lines
CC_STYLED       equ 0000000000100000B   ; Can do styled lines
CC_WIDESTYLED   equ 0000000001000000B   ; Can do wide styled lines
CC_INTERIORS    equ 0000000010000000B   ; Can do interiors
CC_ROUNDRECT    equ 0000000100000000B   ; Can do round rectangles
CC_POLYBEZIER   equ 0000001000000000B   ; Can do beziers


;               Line Capabilities

LC_NONE         equ     00000000B       ; Lines not supported
LC_POLYSCANLINE equ     00000001B       ; Poly Scanlines supported
LC_POLYLINE     equ     00000010B       ; Can do polylines
LC_MARKER       equ     00000100B       ; Can do markers
LC_POLYMARKER   equ     00001000B       ; Can do polymarkers
LC_WIDE         equ     00010000B       ; Can do wide lines
LC_STYLED       equ     00100000B       ; Can do styled lines
LC_WIDESTYLED   equ     01000000B       ; Can do wide styled lines
LC_INTERIORS    equ     10000000B       ; Can do interiors


;               Polygonal Capabilities

PC_NONE         equ 0000000000000000B   ; Polygonals not supported
PC_ALTPOLYGON   equ 0000000000000001B   ; Can do alternate polygons
PC_POLYGON      equ 0000000000000001B   ; an old name for ALTPOLYGON
PC_RECTANGLE    equ 0000000000000010B   ; Can do rectangles
PC_WINDPOLYGON  equ 0000000000000100B   ; Can do winding polygons
PC_TRAPEZOID    equ 0000000000000100B   ; an old name for WINDPOLYGON
PC_SCANLINE     equ 0000000000001000B   ; Can do scanlines
PC_WIDE         equ 0000000000010000B   ; Can do wide borders
PC_STYLED       equ 0000000000100000B   ; Can do styled borders
PC_WIDESTYLED   equ 0000000001000000B   ; Can do wide styled borders
PC_INTERIORS    equ 0000000010000000B   ; Can do interiors
PC_POLYPOLYGON  equ 0000000100000000B   ; Can do PolyPolygons
PC_PATHS        equ 0000001000000000B   ; Can do Paths

;               Clipping Capabilities

CP_NONE         equ     00000000B       ; No clipping at device level
CP_RECTANGLE    equ     00000001B       ; Device Output clips to rectangles
CP_REGION       equ     00000010B       ; Not supported.
CP_REGION32     equ     00000100B       ; Device Output clips to regions

;               Text Capabilities

TC_OP_CHARACTER equ 0000000000000001B   ; Can do OutputPrecision   CHARACTER
TC_OP_STROKE    equ 0000000000000010B   ; Can do OutputPrecision   STROKE
TC_CP_STROKE    equ 0000000000000100B   ; Can do ClipPrecision     STROKE
TC_CR_90        equ 0000000000001000B   ; Can do CharRotAbility    90
TC_CR_ANY       equ 0000000000010000B   ; Can do CharRotAbility    ANY
TC_SF_X_YINDEP  equ 0000000000100000B   ; Can do ScaleFreedom      X_YINDEPENDENT
TC_SA_DOUBLE    equ 0000000001000000B   ; Can do ScaleAbility      DOUBLE
TC_SA_INTEGER   equ 0000000010000000B   ; Can do ScaleAbility      INTEGER
TC_SA_CONTIN    equ 0000000100000000B   ; Can do ScaleAbility      CONTINUOUS
TC_EA_DOUBLE    equ 0000001000000000B   ; Can do EmboldenAbility   DOUBLE
TC_IA_ABLE      equ 0000010000000000B   ; Can do ItalisizeAbility  ABLE
TC_UA_ABLE      equ 0000100000000000B   ; Can do UnderlineAbility  ABLE
TC_SO_ABLE      equ 0001000000000000B   ; Can do StrikeOutAbility  ABLE
TC_RA_ABLE      equ 0010000000000000B   ; Can do RasterFontAble    ABLE
TC_VA_ABLE      equ 0100000000000000B   ; Can do VectorFontAble    ABLE
TC_RESERVED     equ 1000000000000000B   ; Reserved. Must be returned zero.

;               Raster Capabilities

RC_NONE         equ 0000000000000000b   ; No Raster Capabilities
RC_BITBLT       equ 0000000000000001b   ; Can do bitblt
RC_BANDING      equ 0000000000000010b   ; Requires banding support
RC_SCALING      equ 0000000000000100b   ; does scaling while banding
RC_BITMAP64     equ 0000000000001000b   ; supports >64k bitmaps
RC_GDI20_OUTPUT equ 0000000000010000b   ; has 2.0 output calls
RC_GDI20_STATE  equ 0000000000100000b   ; dc has a state block
RC_SAVEBITMAP   equ 0000000001000000b   ; can save bitmaps locally
RC_DI_BITMAP    equ 0000000010000000b   ; can do device independent bitmaps
RC_PALETTE      equ 0000000100000000b   ; can do color palette management
RC_DIBTODEV     equ 0000001000000000b   ; can do SetDIBitsToDevice
RC_BIGFONT      equ 0000010000000000b   ; does BIGFONTs
RC_STRETCHBLT   equ 0000100000000000b   ; can do StretchBlt
RC_FLOODFILL    equ 0001000000000000b   ; can do FloodFill
RC_STRETCHDIB   equ 0010000000000000b   ; can do StretchDIBits
RC_OP_DX_OUTPUT equ 0100000000000000b   ;dev opaque and dx array capable
RC_DEVBITS      equ 1000000000000000b   ; supports device bitmaps

;       DC Management Flags

DC_SPDevice   equ 00000001b     ;Seperate PDevice required per device/filename
DC_1PDevice   equ 00000010b     ;Only 1 PDevice allowed per device/filename
DC_IgnoreDFNP equ 00000100b     ;Ignore device/filename pairs when matching

;               dpCaps1 capability bits

C1_TRANSPARENT  equ 0000000000000001b   ; supports transparency
TC_TT_ABLE      equ 0000000000000010b   ; can do TT fonts through DDI or brute
C1_TT_CR_ANY    equ 0000000000000100b   ; can do rotated TT fonts
C1_EMF_COMPLIANT equ 0000000000001000b  ; Win95 - supports metafile spooling
C1_DIBENGINE    equ 0000000000010000b   ; DIB Engine compliant driver
C1_GAMMA_RAMP   equ 0000000000100000b   ; supports gamma ramp setting
C1_ICM          equ 0000000001000000b   ; does some form of ICM support
C1_REINIT_ABLE  equ 0000000010000000b   ; driver supports ReEnable call
C1_GLYPH_INDEX  equ 0000000100000000b   ; Driver supports glyph index fonts
C1_BIT_PACKED   equ 0000001000000000b   ; Supports bit-packed glyphs
C1_BYTE_PACKED  equ 0000010000000000b   ; Supports byte-packed glyphs
C1_COLORCURSOR  equ 0000100000000000b   ; Supports color-cursors and async SetCursor
C1_CMYK_ABLE    equ 0001000000000000b   ; Supports CMYK ColorRefs
C1_SLOW_CARD    equ 0010000000000000b   ; Little or no acceleration (VGA, etc.)


;               dpCapsFE capability bits

FEC_TT_DBCS     equ 0000000000100000b   ; can output DBCS TT fonts correctly
FEC_WIFE_ABLE   equ 0000000010000000b   ; can handle WIFE font as Engine font

        if      0
*/

#define     InquireInfo     0x01        /* Inquire Device GDI Info         */
#define     EnableDevice    0x00        /* Enable Device                   */
#define     InfoContext     0x8000      /* Inquire/Enable for info context */

/*              Device Technologies                                */

#define     DT_PLOTTER          0       /* Vector plotter          */
#define     DT_RASDISPLAY       1       /* Raster display          */
#define     DT_RASPRINTER       2       /* Raster printer          */
#define     DT_RASCAMERA        3       /* Raster camera           */
#define     DT_CHARSTREAM       4       /* Character-stream, PLP   */
#define     DT_METAFILE         5       /* Metafile, VDM           */
#define     DT_DISPFILE         6       /* Display-file            */
#define     DT_JUMBO            11      /* SPAG LJ cool thing      */

/*              Curve Capabilities                                 */

#define     CC_NONE         0x0000      /* Curves not supported    */
#define     CC_CIRCLES      0x0001      /* Can do circles          */
#define     CC_PIE          0x0002      /* Can do pie wedges       */
#define     CC_CHORD        0x0004      /* Can do chord arcs       */
#define     CC_ELLIPSES     0x0008      /* Can do ellipese         */
#define     CC_WIDE         0x0010      /* Can do wide lines       */
#define     CC_STYLED       0x0020      /* Can do styled lines     */
#define     CC_WIDESTYLED   0x0040      /* Can do wide styled lines*/
#define     CC_INTERIORS    0x0080      /* Can do interiors        */
#define     CC_ROUNDRECT    0x0100      /* Can do round rectangles */
#define     CC_POLYBEZIER   0x0200      /* Can do polybeziers      */

/*               Line Capabilities                                 */

#define     LC_NONE         0x0000      /* Lines not supported     */
#define     LC_POLYSCANLINE 0x0001      /* Poly Scanlines supported*/
#define     LC_POLYLINE     0x0002      /* Can do polylines        */
#define     LC_MARKER       0x0004      /* Can do markers          */
#define     LC_POLYMARKER   0x0008      /* Can do polymarkers      */
#define     LC_WIDE         0x0010      /* Can do wide lines       */
#define     LC_STYLED       0x0020      /* Can do styled lines     */
#define     LC_WIDESTYLED   0x0040      /* Can do wide styled lines*/
#define     LC_INTERIORS    0x0080      /* Can do interiors        */

/*               Polygonal Capabilities                            */

#define     PC_NONE         0x0000      /* Polygonals not supported*/
#define     PC_ALTPOLYGON   0x0001      /* Can do even odd polygons*/
#define     PC_POLYGON      0x0001      /* old name for ALTPOLYGON */
#define     PC_RECTANGLE    0x0002      /* Can do rectangles       */
#define     PC_WINDPOLYGON  0x0004      /* Can do winding polygons */
#define     PC_TRAPEZOID    0x0004      /* old name for WINDPOLYGON*/
#define     PC_SCANLINE     0x0008      /* Can do scanlines        */
#define     PC_WIDE         0x0010      /* Can do wide borders     */
#define     PC_STYLED       0x0020      /* Can do styled borders   */
#define     PC_WIDESTYLED   0x0040      /* Can do wide styled borders*/
#define     PC_INTERIORS    0x0080      /* Can do interiors        */
#define     PC_POLYPOLYGON  0x0100      /* Can do PolyPolygons     */

/*               Clipping Capabilities                             */

#define     CP_NONE         0x0000      /* no clipping of Output   */
#define     CP_RECTANGLE    0x0001      /* Output clipped to Rects */
#define     CP_REGION       0x0002      /* not supported           */
#define     CP_REGION32     0x0004      /* Output clipped to regions */

/*               Text Capabilities                                             */

#define TC_OP_CHARACTER 0x0001     /* Can do OutputPrecision    CHARACTER      */
#define TC_OP_STROKE    0x0002     /* Can do OutputPrecision    STROKE         */
#define TC_CP_STROKE    0x0004     /* Can do ClipPrecision      STROKE         */
#define TC_CR_90        0x0008     /* Can do CharRotAbility     90             */
#define TC_CR_ANY       0x0010     /* Can do CharRotAbility     ANY            */
#define TC_SF_X_YINDEP  0x0020     /* Can do ScaleFreedom       X_YINDEPENDENT */
#define TC_SA_DOUBLE    0x0040     /* Can do ScaleAbility       DOUBLE         */
#define TC_SA_INTEGER   0x0080     /* Can do ScaleAbility       INTEGER        */
#define TC_SA_CONTIN    0x0100     /* Can do ScaleAbility       CONTINUOUS     */
#define TC_EA_DOUBLE    0x0200     /* Can do EmboldenAbility    DOUBLE         */
#define TC_IA_ABLE      0x0400     /* Can do ItalisizeAbility   ABLE           */
#define TC_UA_ABLE      0x0800     /* Can do UnderlineAbility   ABLE           */
#define TC_SO_ABLE      0x1000     /* Can do StrikeOutAbility   ABLE           */
#define TC_RA_ABLE      0x2000     /* Can do RasterFontAble     ABLE           */
#define TC_VA_ABLE      0x4000     /* Can do VectorFontAble     ABLE           */
#define TC_RESERVED     0x8000     /* Reserved. Must be returned zero.        */

/*               Raster Capabilities                               */

#define RC_NONE         0x0000          /* No Raster Capabilities       */
#define RC_BITBLT       0x0001          /* Can do bitblt                */
#define RC_BANDING      0x0002          /* Requires banding support     */
#define RC_SCALING      0x0004          /* does scaling while banding   */
#define RC_BITMAP64     0x0008          /* supports >64k bitmaps        */
#define RC_GDI20_OUTPUT 0x0010          /* has 2.0 output calls         */
#define RC_GDI20_STATE  0x0020          /* dc has a state block         */
#define RC_SAVEBITMAP   0x0040          /* can save bitmaps locally     */
#define RC_DI_BITMAP    0x0080          /* can do DIBs                  */
#define RC_PALETTE      0x0100          /* can do color pal management  */
#define RC_DIBTODEV     0x0200          /* can do SetDIBitsToDevice     */
#define RC_BIGFONT      0x0400          /* can do BIGFONTs              */
#define RC_STRETCHBLT   0x0800          /* can do StretchBlt            */
#define RC_FLOODFILL    0x1000          /* can do FloodFill             */
#define RC_STRETCHDIB   0x2000          /* can do StretchDIBits         */
#define RC_OP_DX_OUTPUT 0x4000          /* can do smart ExtTextOut w/dx */
#define RC_DEVBITS      0x8000          /* supports device bitmaps      */

/*      DC Management Flags                                        */

#define DC_SPDevice     0000001     /* Seperate PDevice required per device/filename */
#define DC_1PDevice     0000002     /* Only 1 PDevice allowed per device/filename    */
#define DC_IgnoreDFNP   0000004     /* Ignore device/filename pairs when matching    */

/*      dpCaps1 capability bits                                             */

#define C1_TRANSPARENT  0x0001      /* supports transparency                */
#define TC_TT_ABLE      0x0002      /* can do TT through DDI or brute       */
#define C1_TT_CR_ANY    0x0004      /* can do rotated TT fonts              */
#define C1_EMF_COMPLIANT 0x0008     /* Win95 - supports metafile spooling   */
#define C1_DIBENGINE    0x0010      /* DIB Engine compliant driver          */
#define C1_GAMMA_RAMP   0x0020      /* supports gamma ramp setting          */
#define C1_ICM          0x0040      /* does some form of ICM support        */
#define C1_REINIT_ABLE  0x0080      /* Driver supports ReEnable             */
#define C1_GLYPH_INDEX  0x0100      /* Driver supports glyph index fonts    */
#define C1_BIT_PACKED   0x0200      /* Supports bit-packed glyphs           */
#define C1_BYTE_PACKED  0x0400      /* Supports byte-packed glyphs          */
#define C1_COLORCURSOR  0x0800      /* Driver supports color_cursors and async SetCursor */
#define C1_CMYK_ABLE    0x1000      /* Driver supports CMYK ColorRefs       */

/*      dpCapsFE capability bits                                            */

#define FEC_TT_DBCS     0x0020      /* can output DBCS TT fonts correctly   */
#define FEC_WIFE_ABLE   0x0080      /* can handle WIFE font as Engine font  */

/*
        endif

GDIINFO         struc                                                       ;*/ typedef struct {           /*

  dpVersion     dw      0       ; Version = 0100h for now                   ;*/ short int dpVersion;       /*
  dpTechnology  dw      0       ; Device classification                     ;*/ short int dpTechnology;    /*
  dpHorzSize    dw      0       ; Horizontal size in millimeters            ;*/ short int dpHorzSize;      /*
  dpVertSize    dw      0       ; Vertical   size in millimeters            ;*/ short int dpVertSize;      /*
  dpHorzRes     dw      0       ; Horizontal width in pixels                ;*/ short int dpHorzRes;       /*
  dpVertRes     dw      0       ; Vertical   width in pixels                ;*/ short int dpVertRes;       /*
  dpBitsPixel   dw      0       ; Number of bits per pixel                  ;*/ short int dpBitsPixel;     /*
  dpPlanes      dw      0       ; Number of planes                          ;*/ short int dpPlanes;        /*
  dpNumBrushes  dw      0       ; Number of brushes the device has          ;*/ short int dpNumBrushes;    /*
  dpNumPens     dw      0       ; Number of pens the device has             ;*/ short int dpNumPens;       /*
  dpCapsFE      dw      0       ; capability bits for Far East              ;*/ short int dpCapsFE;        /*
  dpNumFonts    dw      0       ; Number of fonts the device has            ;*/ short int dpNumFonts;      /*
  dpNumColors   dw      0       ; Number of colors in color table           ;*/ short int dpNumColors;     /*
  dpDEVICEsize  dw      0       ; Size required for the device descriptor   ;*/ short int dpDEVICEsize;    /*
  dpCurves      dw      0       ; Curves    capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpCurves;     /*
  dpLines       dw      0       ; Line      capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpLines;      /*
  dpPolygonals  dw      0       ; Polygonal capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpPolygonals; /*
  dpText        dw      0       ; Text      capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpText;       /*
  dpClip        dw      0       ; Clipping  capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpClip;       /*
  dpRaster      dw      0       ; Bitblt    capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpRaster;     /*
  dpAspectX     dw      0       ; Length of X leg                           ;*/ short int dpAspectX;       /*
  dpAspectY     dw      0       ; Length of Y leg                           ;*/ short int dpAspectY;       /*
  dpAspectXY    dw      0       ; Length of hypotenuse                      ;*/ short int dpAspectXY;      /*
  dpStyleLen    dw      0       ; Length of segment for line styles         ;*/ short int dpStyleLen;      /*
  dpMLoWin      dw      0       ; Metric  Lo res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpMLoWin;        /*
                dw      0
  dpMLoVpt      dw      0       ; Metric  Lo res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpMLoVpt;        /*
                dw      0
  dpMHiWin      dw      0       ; Metric  Hi res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpMHiWin;        /*
                dw      0
  dpMHiVpt      dw      0       ; Metric  Hi res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpMHiVpt;        /*
                dw      0
  dpELoWin      dw      0       ; English Lo res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpELoWin;        /*
                dw      0
  dpELoVpt      dw      0       ; English Lo res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpELoVpt;        /*
                dw      0
  dpEHiWin      dw      0       ; English Hi res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpEHiWin;        /*
                dw      0
  dpEHiVpt      dw      0       ; English Hi res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpEHiVpt;        /*
                dw      0
  dpTwpWin      dw      0       ; Twips          WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpTwpWin;        /*
                dw      0
  dpTwpVpt      dw      0       ; Twips          VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpTwpVpt;        /*
                dw      0
  dpLogPixelsX  dw      0       ;Logical pixels/inch in X                   ;*/ short int dpLogPixelsX;    /*
  dpLogPixelsY  dw      0       ;Logical pixels/inch in Y                   ;*/ short int dpLogPixelsY;    /*
  dpDCManage    dw      0       ;DC Management flags                        ;*/ short int dpDCManage;      /*
  dpCaps1       dw      0       ; more capability bits                      ;*/ unsigned short int dpCaps1;     /*
  dpSpotSizeX   dw      0                                                   ;*/ short int futureuse4;           /*
                dw      0                                                   ;*/ short int futureuse5;           /*
  dpSpotSizeY   dw      0                                                   ;*/ short int futureuse6;           /*
                dw      0                                                   ;*/ short int futureuse7;           /*

; start of entries in version 3.0 of this structure

  dpNumPalReg   dw      0       ; Number of entries in device's palette     ;*/ WORD dpNumPalReg;          /*
  dpPalReserved dw      0       ; Number of reserved entries palette        ;*/ WORD dpPalReserved;        /*
  dpColorRes    dw      0       ; bits of color resolution (total)          ;*/ WORD dpColorRes;           /*
GDIINFO         ends                                                        ;*/ } GDIINFO;                 /*

                endif
                endif


page
;       Font Definitions
                ifdef   incFont
                if      incFont

; flags for extended textout

ETO_GRAYED      equ     0001h
ETO_OPAQUE      equ     0002h
ETO_CLIPPED     equ     0004h
ETO_GLYPH_INDEX equ     0010h
ETO_RTL         equ     0080h
ETO_BYTE_PACKED equ     0100h
ETO_BIT_PACKED  equ     0200h
ETO_LEVEL_MODE  equ     1000h

PF_BITS_IS_ADDRESS  equ     4
PF_DEVICE_REALIZED  equ     10000000B
PF_RASTER_TYPE      equ     0
PF_VECTOR_TYPE      equ     1
PF_OTHER1_TYPE      equ     2
PF_OTHER2_TYPE      equ     3
PF_GLYPH_INDEX      equ    20h
PF_WIFE_TYPE        equ    08h


; Glyph types for EngineGetGlyphBmp
EGB_BITMAP          equ     1
EGB_OUTLINE         equ     2
EGB_GRAY2_BITMAP    equ     8
EGB_GRAY4_BITMAP    equ     9
EGB_GRAY8_BITMAP    equ    10


    if  0
*/

/* This bit in the dfType field signals that the dfBitsOffset field is an
   absolute memory address and should not be altered. */
#define PF_BITS_IS_ADDRESS  4

/* This bit in the dfType field signals that the font is device realized. */
#define PF_DEVICE_REALIZED  0x80

/* These bits in the dfType give the fonttype -
       raster, vector, other1, other2. */
#define PF_RASTER_TYPE      0
#define PF_VECTOR_TYPE      1
#define PF_OTHER1_TYPE      2
#define PF_OTHER2_TYPE      3
#define PF_GLYPH_INDEX   0x20
#define PF_WIFE_TYPE     0x08

/* Glyph types for EngineGetGlyphBmp */
#define EGB_BITMAP          1
#define EGB_OUTLINE         2
#define EGB_GRAY2_BITMAP    8
#define EGB_GRAY4_BITMAP    9
#define EGB_GRAY8_BITMAP   10


/* The size to allocate for the dfMaps field in the physical font. */
#ifndef     DF_MAPSIZE
#define     DF_MAPSIZE      1
#endif

/*
    endif


;       Font data structure passed to OEM routines.  Refer to chapters 12 and
;       13 of the OEM adaptation guide for a complete description.


FONTINFO        struc                                                       ;*/ typedef     struct  {          /*

  dfType            dw      0   ; Type field for the font.                  ;*/ short int   dfType;            /*
  dfPoints          dw      0   ; Point size of font.                       ;*/ short int   dfPoints;          /*
  dfVertRes         dw      0   ; Vertical digitization.                    ;*/ short int   dfVertRes;         /*
  dfHorizRes        dw      0   ; Horizontal digitization.                  ;*/ short int   dfHorizRes;        /*
  dfAscent          dw      0   ; Baseline offset from char cell top.       ;*/ short int   dfAscent;          /*
  dfInternalLeading dw      0   ; Internal leading included in font         ;*/ short int   dfInternalLeading; /*
  dfExternalLeading dw      0   ; Prefered extra space between lines        ;*/ short int   dfExternalLeading; /*
  dfItalic          db      0   ; Flag specifying if italic.                ;*/ BYTE        dfItalic;          /*
  dfUnderline       db      0   ; Flag specifying if underlined.            ;*/ BYTE        dfUnderline;       /*
  dfStrikeOut       db      0   ; Flag specifying if struck out.            ;*/ BYTE        dfStrikeOut;       /*
  dfWeight          dw      0   ; Weight of font.                           ;*/ short int   dfWeight;          /*
  dfCharSet         db      0   ; Character set of font.                    ;*/ BYTE        dfCharSet;         /*
  dfPixWidth        dw      0   ; Width field for the font.                 ;*/ short int   dfPixWidth;        /*
  dfPixHeight       dw      0   ; Height field for the font.                ;*/ short int   dfPixHeight;       /*
  dfPitchAndFamily  db      0   ; Flag specifying variable pitch, family.   ;*/ BYTE        dfPitchAndFamily;  /*
  dfAvgWidth        dw      0   ; Average character width.                  ;*/ short int   dfAvgWidth;        /*
  dfMaxWidth        dw      0   ; Maximum character width.                  ;*/ short int   dfMaxWidth;        /*
  dfFirstChar       db      0   ; First character in the font.              ;*/ BYTE        dfFirstChar;       /*
  dfLastChar        db      0   ; Last character in the font.               ;*/ BYTE        dfLastChar;        /*
  dfDefaultChar     db      0   ; Default character for out of range.       ;*/ BYTE        dfDefaultChar;     /*
  dfBreakChar       db      0   ; Character to define wordbreaks.           ;*/ BYTE        dfBreakChar;       /*
  dfWidthBytes      dw      0   ; Number of bytes in each row.              ;*/ short int   dfWidthBytes;      /*
  dfDevice          dd      0   ; Offset to device name.                    ;*/ unsigned long int   dfDevice;  /*
  dfFace            dd      0   ; Offset to face name.                      ;*/ unsigned long int   dfFace;    /*
  dfBitsPointer     dd      0   ; Bits pointer.                             ;*/ unsigned long int   dfBitsPointer;/*
  dfBitsOffset      dd      0   ; Offset to the begining of the bitmap.     ;*/ unsigned long int   dfBitsOffset;/*
                                ; On the disk, this is relative to the
                                ; begining of the file. In memory this is
                                ; relative to the begining of this structure.
  dfReservedByte    db      0   ; filler byte to WORD-align charoffset      ;*/ BYTE dfReservedByte;            /*
  dfCharOffset      dw      0   ; Area for storing the character offsets,   ;*/ unsigned short dfMaps[DF_MAPSIZE];/*
                                ; facename, device name (opt