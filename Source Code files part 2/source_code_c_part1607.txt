oryLock));
        InitializeListHead(&PxdMemoryList);
        PxdInitDone = TRUE;
    }

    pAllocInfo = ExAllocatePoolWithTag(NonPagedPool,
                                       Size+sizeof(PXD_ALLOCATION),
                                       Tag);

    if (pAllocInfo != NULL) {

        pBuffer = (PVOID)&(pAllocInfo->UserData);
        NdisFillMemory(pBuffer, Size, 0xAF);
        pAllocInfo->Signature = PXD_MEMORY_SIGNATURE;
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = (ULONG_PTR)pPointer;

        NdisAcquireSpinLock(&(PxdMemoryLock));

        InsertTailList(&PxdMemoryList, &pAllocInfo->Linkage);

        PxdAllocCount++;

        NdisReleaseSpinLock(&(PxdMemoryLock));
    }

    return (pBuffer);
}


VOID
PxAuditFreeMem(
    PVOID   Pointer
    )
{
    PPXD_ALLOCATION pAllocInfo;

    pAllocInfo = CONTAINING_RECORD(Pointer, PXD_ALLOCATION, UserData);

    if(pAllocInfo->Signature != PXD_MEMORY_SIGNATURE)
    {
        DbgPrint("PxAuditFreeMem: unknown buffer 0x%x!\n", Pointer);
        DbgBreakPoint();
        return;
    }

    NdisAcquireSpinLock(&(PxdMemoryLock));

    pAllocInfo->Signature = (ULONG)'DEAD';

    RemoveEntryList(&pAllocInfo->Linkage);

    PxdAllocCount--;

    NdisReleaseSpinLock(&(PxdMemoryLock));

    ExFreePool(pAllocInfo);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxco.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxdown.c

Abstract:

    The module contains the calls to NDIS for the NDIS Proxy.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/
#include "precomp.h"
#include <atm.h>
#define MODULE_NUMBER MODULE_CO
#define _FILENUMBER   'OCXP'

VOID
PxCoBindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    )
/*++

Routine Description:
    Entry point that gets called by NDIS when an adapter appears on the
    system.

Arguments:
    pStatus - place for our Return Value
    BindContext - to be used if we call NdisCompleteBindAdapter; we don't
    DeviceName - Name of the adapter to be bound to
    SystemSpecific1 - Name of the protocol-specific entry in this adapter's
            registry section
    SystemSpecific2 - Not used

Return Value:
    None. We set *pStatus to NDIS_STATUS_SUCCESS if everything goes off well,
    otherwise an NDIS error status.

--*/
{
    NDIS_STATUS         OpenError;
    UINT                SelectedIndex;
    PPX_ADAPTER         pAdapter = NULL;
    NDIS_MEDIUM         Media[NdisMediumMax];
    NDIS_REQUEST        Request;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    ULONG               InitStage = 0;

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoBindAdapter: %Z\n", DeviceName));

    //
    //  Wait for all calls to NdisRegisterProtocol to complete.
    //
    NdisWaitEvent(&DeviceExtension->NdisEvent, 0);

    //
    // Use a do..while..false loop and break on error.
    // Cleanup is at the end of the loop.
    //
    do
    {
        //
        //  Check if this is a device we have already bound to.
        //
        if (PxIsAdapterAlreadyBound(DeviceName)) {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            PXDEBUGP(PXD_WARNING, PXM_CO, ("PxCoBindAdapter: already bound to %Z\n", DeviceName));
            break;
        }

        // pAdapter gets the devicname stuck on the end -- alloc space for it
        //
        pAdapter =
            PxAllocateAdapter(DeviceName->MaximumLength);

        if(pAdapter == (PPX_ADAPTER)NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // We have memory allocated we will need to free it!
        //
        InitStage++;

        //
        // Go to the end of the string and work back until we find
        // the first "{".  Now start parsing the string converting
        // and copying from WCHAR to CHAR all digits until we hit
        // the closing "}".
        //
        {
            ULONG   i;
            for (i = DeviceName->Length/2; i > 0; i--) {
                if (DeviceName->Buffer[i] == (WCHAR)L'{') {
                    break;
                }
            }

            if (i != 0) {
                NDIS_STRING Src;
                RtlInitUnicodeString(&Src, &DeviceName->Buffer[i]);
                RtlGUIDFromString(&Src, &pAdapter->Guid);

                PXDEBUGP(PXD_INFO, PXM_CO, ("GUID %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x\n",
                         pAdapter->Guid.Data1, pAdapter->Guid.Data2, pAdapter->Guid.Data3,
                         pAdapter->Guid.Data4[0],pAdapter->Guid.Data4[1],pAdapter->Guid.Data4[2],
                         pAdapter->Guid.Data4[3],pAdapter->Guid.Data4[4],pAdapter->Guid.Data4[5],
                         pAdapter->Guid.Data4[6],pAdapter->Guid.Data4[7]));
            }
        }

        PxInitBlockStruc(&pAdapter->BindEvent);

        PxInitBlockStruc(&pAdapter->OpenEvent);  //blocks thread

        PxInitBlockStruc(&pAdapter->AfRegisterEvent);
        pAdapter->AfRegisteringCount = 0;

        //
        // We can't get away with a single open for both
        // client and call manager components without changing the wrapper.
        // Bite the bullet and do two opens.
        //

        //
        // Build the medium array
        //
        {
            ULONG i;
            for (i = 0; i < NdisMediumMax; i++) {
                Media[i] = i;
            }
        }

        //
        // Open the adapter as a client!
        //

        NdisOpenAdapter(&Status,
                        &OpenError,
                        &pAdapter->ClBindingHandle,
                        &SelectedIndex,
                        Media,
                        NdisMediumMax,
                        DeviceExtension->PxProtocolHandle,
                        (NDIS_HANDLE)pAdapter,
                        DeviceName,
                        0,
                        NULL);

        if(Status == NDIS_STATUS_PENDING) {
            Status  = PxBlock(&pAdapter->OpenEvent);
        }

        if(Status != NDIS_STATUS_SUCCESS) {
            // We had some sort of error
            PXDEBUGP(PXD_ERROR, PXM_CO, ("Cl OpenAdapter Failed %x\n", Status));
            pAdapter->ClBindingHandle = NULL;
            pAdapter->MediaType = -1;
            break;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        REF_ADAPTER(pAdapter);
        NdisReleaseSpinLock(&pAdapter->Lock);

        //
        // We have a ref on the adapter
        //
        InitStage++;

        PxInitBlockStruc(&pAdapter->OpenEvent);  //blocks thread

        //
        // Open the adapter as a call manager!
        //
        NdisOpenAdapter(&Status,
                        &OpenError,
                        &pAdapter->CmBindingHandle,
                        &SelectedIndex,
                        Media,
                        NdisMediumMax,
                        DeviceExtension->PxProtocolHandle,
                        (NDIS_HANDLE)&pAdapter->Sig,
                        DeviceName,
                        0,
                        NULL);

        if(Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pAdapter->OpenEvent);
        }

        if(Status != NDIS_STATUS_SUCCESS) {
            // We had some sort of error
            pAdapter->CmBindingHandle = NULL;
            pAdapter->MediaType = -1;
            PXDEBUGP(PXD_ERROR, PXM_CO, ("CM OpenAdapter Failed %x\n", Status));
            break;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        REF_ADAPTER(pAdapter);

        //
        // We have another ref on the adapter
        //
        InitStage++;

        pAdapter->State = PX_ADAPTER_OPEN;

        PXDEBUGP(PXD_INFO, PXM_CO, ("Bound to %Z, Adapter %p, NdisHandle %p\n",
                    DeviceName, pAdapter, pAdapter->ClBindingHandle));
        //
        // Set up media type in adapters
        //
        pAdapter->MediaType =
            Media[SelectedIndex];

        NdisReleaseSpinLock(&pAdapter->Lock);

        //
        // Set MediaTypeName/MediaSubtypeName for this adapter
        //
        {
            NDIS_WAN_MEDIUM_SUBTYPE SubType = 0;
            PX_REQUEST      ProxyRequest;
            PNDIS_REQUEST   Request;
            PWCHAR  MediaTypes[] = {
                L"GENERIC",
                L"X25",
                L"ISDN",
                L"SERIAL",
                L"FRAMERELAY",
                L"ATM",
                L"SONET",
                L"SW56",
                L"PPTP VPN",
                L"L2TP VPN",
                L"IRDA",
                L"PARALLEL"};

            switch (pAdapter->MediaType) {
                case NdisMediumWan:
                case NdisMediumCoWan:

                    PxInitBlockStruc (&ProxyRequest.Block);

                    Request = &ProxyRequest.NdisRequest;

                    Request->RequestType =
                        NdisRequestQueryInformation;

                    Request->DATA.QUERY_INFORMATION.Oid =
                        OID_WAN_MEDIUM_SUBTYPE;

                    Request->DATA.QUERY_INFORMATION.InformationBuffer =
                        &SubType;

                    Request->DATA.QUERY_INFORMATION.InformationBufferLength =
                        sizeof(NDIS_WAN_MEDIUM_SUBTYPE);

                    NdisRequest(&Status,
                                pAdapter->ClBindingHandle,
                                Request);

                    if (Status == NDIS_STATUS_PENDING) {
                        Status = PxBlock(&ProxyRequest.Block);
                    }

                    if (Status != NDIS_STATUS_SUCCESS) {
                        SubType = 0;
                    }

                    break;

                case NdisMediumAtm:
                    SubType = NdisWanMediumAtm;
                    break;

                default:
                    SubType = NdisWanMediumHub;
                    break;
            }

            if ((ULONG)SubType > 11) {
                SubType = 0;
            }

            pAdapter->MediumSubType = SubType;

            NdisMoveMemory((PUCHAR)(pAdapter->MediaName),
                           (PUCHAR)(MediaTypes[SubType]),
                           wcslen(MediaTypes[SubType]) * sizeof(WCHAR));

            pAdapter->MediaNameLength = 
                wcslen(MediaTypes[SubType]) * sizeof(WCHAR);

            Status = NDIS_STATUS_SUCCESS;
        }

        //
        // Stick the binding name string in the adapter. We use in subsequent
        // checks that we're not already bound.
        //
        pAdapter->DeviceName.MaximumLength = DeviceName->MaximumLength;
        pAdapter->DeviceName.Length = DeviceName->Length;
        pAdapter->DeviceName.Buffer =
            (PWCHAR)((PUCHAR)pAdapter + sizeof(PX_ADAPTER));

        NdisMoveMemory(pAdapter->DeviceName.Buffer,
                       DeviceName->Buffer,
                       DeviceName->Length);

    } while(FALSE); //end of do loop

    if (pAdapter != NULL) {
        PxSignal(&pAdapter->BindEvent, NDIS_STATUS_SUCCESS);
    }

    if (Status != NDIS_STATUS_SUCCESS) {

        //
        // Set the state to closing since we're going to get rid
        // of the adapter. 
        //
        if ((InitStage >= 1) && (InitStage <= 3)) {
            pAdapter->State = PX_ADAPTER_CLOSING;
        }
        
        switch (InitStage) {

            case 3:
                //
                // We have applied 2 additional refs on the adapter
                // we don't need to do the entire deref code for
                // the first one!  Fall through to the case below
                // to run the full deref code for the second ref.
                //
                
                pAdapter->RefCount--;

            case 2:

                //
                // We have added at least one ref that will need
                // the entire deref package applied!  Break out
                // so the deref code can free the memory.
                //
                PxInitBlockStruc(&pAdapter->ClCloseEvent);

                NdisCloseAdapter(&Status, pAdapter->ClBindingHandle);

                if (Status == NDIS_STATUS_PENDING) {
                    Status = PxBlock(&pAdapter->ClCloseEvent);
                }

                DEREF_ADAPTER(pAdapter);
                break;

            case 1:

                //
                // We have added no addition refs so we can
                // just free the memory here.
                //
                PxFreeAdapter(pAdapter);
                break;

            default:
                break;
        }
    }

    ASSERT(Status != NDIS_STATUS_PENDING);

    *pStatus = Status;
    
}

VOID
PxCoOpenAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status,
    NDIS_STATUS OpenErrorStatus
    )
/*++
Routine Description
    Our OpenAdapter completion . We signal whoever opened the
    adapter.

Arguments
    BindingContext      - A pointer to a PX_ADAPTER structure.
    Status              - Status of open attempt.
    OpenErrorStatus     - Additional status information.

Return Value:
    None

--*/
{
    PPX_ADAPTER     pAdapter;
    BOOLEAN         IsClient;

    PXDEBUGP(PXD_LOUD, PXM_CO, ("Open Adapter Complete %p %x\n", BindingContext, Status));

    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    PxSignal(&pAdapter->OpenEvent, Status);
}

VOID
PxCoUnbindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     ProtocolBindContext,
    IN  PNDIS_HANDLE    UnbindContext
    )
/*++

Routine Description:
    entry point called by NDIS when we need to destroy an existing
    adapter binding. This is called for the CM open.

    By now, al clients will have been called. So any clients that opend this AF will have cleaned up their
    connections with us, and we will have cleaned up with the Call Manager.

    We should have CL and related CL adapter structures to get rid of. The Client Bind, SAPs, VCs and Party structures
    should already have gone. If not, we throw them away anyway.

    Close and clean up the adapters.

Arguments:
    pStatus - where we return the status of this call
    ProtocolBindContext - actually a pointer to the Adapter structure
    UnbindContext - we should pass this value in NdisCompleteUnbindAdapter

Return Value:
    None; *pStatus contains the result code.

--*/
{
    PPX_ADAPTER     pAdapter;
    PPX_CM_AF       pCmAf;
    PPX_CL_AF       pClAf;
    NDIS_STATUS     Status;
    BOOLEAN         IsClient;

    AdapterFromBindContext(ProtocolBindContext, pAdapter, IsClient);

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoUnbindAdapter: pAdapter %p, UnbindContext %p\n",
                        pAdapter, UnbindContext));

    PxBlock(&pAdapter->BindEvent);

    NdisAcquireSpinLock(&pAdapter->Lock);

    pAdapter->UnbindContext = UnbindContext;
    pAdapter->State = PX_ADAPTER_CLOSING;

    //
    // Wait for any threads registering AFs to exit.
    //
    while (pAdapter->AfRegisteringCount != 0) {

        NdisReleaseSpinLock(&pAdapter->Lock);

        PxBlock(&pAdapter->AfRegisterEvent);

        NdisAcquireSpinLock(&pAdapter->Lock);
    }

    ASSERT((pAdapter->Flags & PX_CMAF_REGISTERING) == 0);

    //
    // Do we have any af's opend on the underlying call manager
    // and are there any saps registered on them?
    //
    while (!IsListEmpty(&pAdapter->ClAfList)) {
        PPX_TAPI_PROVIDER   TapiProvider;
        PPX_CL_AF   pClAf;

        pClAf = (PPX_CL_AF)RemoveHeadList(&pAdapter->ClAfList);

        InsertTailList(&pAdapter->ClAfClosingList, &pClAf->Linkage);

        NdisReleaseSpinLock(&pAdapter->Lock);

        NdisAcquireSpinLock(&pClAf->Lock);

        pClAf->State = PX_AF_CLOSING;

        TapiProvider = pClAf->TapiProvider;

        NdisReleaseSpinLock(&pClAf->Lock);

        //
        // Take all tapi devices associated with
        // this address family offline
        //
        if (TapiProvider != NULL) {
            NdisAcquireSpinLock(&TapiProvider->Lock);

            MarkProviderOffline(TapiProvider);

            NdisReleaseSpinLock(&TapiProvider->Lock);
        }

        //
        // Build list of Vc's that need attention
        //
        NdisAcquireSpinLock(&pClAf->Lock);

        while (!IsListEmpty(&pClAf->VcList)) {
            PLIST_ENTRY         Entry;
            PPX_VC              pActiveVc;

            Entry = RemoveHeadList(&pClAf->VcList);

            InsertHeadList(&pClAf->VcClosingList, Entry);

            pActiveVc = CONTAINING_RECORD(Entry, PX_VC, ClAfLinkage);

            NdisReleaseSpinLock(&pClAf->Lock);

            NdisAcquireSpinLock(&pActiveVc->Lock);

            pActiveVc->CloseFlags |= PX_VC_UNBIND;

            REF_VC(pActiveVc);

            PxVcCleanup(pActiveVc, 0);

            DEREF_VC_LOCKED(pActiveVc);

            NdisAcquireSpinLock(&pClAf->Lock);
        }

        //
        // get rid of any saps on this af
        //
        {
            PLIST_ENTRY pe;
            PPX_CL_SAP  pClSap;

            pe = pClAf->ClSapList.Flink;

            pClSap =
                CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);

            while ((PVOID)pClSap != (PVOID)&pClAf->ClSapList) {

                if (InterlockedCompareExchange((PLONG)&pClSap->State,
                                               PX_SAP_CLOSING,
                                               PX_SAP_OPENED)) {

                    RemoveEntryList(&pClSap->Linkage);

                    InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

                    NdisReleaseSpinLock(&pClAf->Lock);

                    ClearSapWithTapiLine(pClSap);

                    Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

                    if (Status != NDIS_STATUS_PENDING) {
                        PxClDeregisterSapComplete(Status, pClSap);
                    }

                    NdisAcquireSpinLock(&pClAf->Lock);

                    pe = pClAf->ClSapList.Flink;

                    pClSap =
                        CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                } else {
                    pe = pClSap->Linkage.Flink;

                    pClSap =
                        CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                }
            }
        }

        //
        // deref for the ref applied when we opened this af
        // and put it on the adapter's list
        //
        DEREF_CL_AF_LOCKED(pClAf);

        NdisAcquireSpinLock(&pAdapter->Lock);
    }

    //
    // Do any clients have our AF open?
    //
    while (!IsListEmpty(&pAdapter->CmAfList)) {

        PPX_CM_AF   pCmAf;
        PX_REQUEST  ProxyRequest;
        PPX_REQUEST pProxyRequest = &ProxyRequest;
        ULONG       Info = 0;
        PNDIS_REQUEST   Request;

        pCmAf = (PPX_CM_AF)RemoveHeadList(&pAdapter->CmAfList);

        InsertTailList(&pAdapter->CmAfClosingList, &pCmAf->Linkage);

        NdisReleaseSpinLock(&pAdapter->Lock);

        NdisAcquireSpinLock(&pCmAf->Lock);

        pCmAf->State = PX_AF_CLOSING;

        REF_CM_AF(pCmAf);

        NdisReleaseSpinLock(&pCmAf->Lock);

        NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

        Request = &pProxyRequest->NdisRequest;

        Request->RequestType =
            NdisRequestSetInformation;
        Request->DATA.QUERY_INFORMATION.Oid =
            OID_CO_AF_CLOSE;
        Request->DATA.QUERY_INFORMATION.InformationBuffer =
            &Info;
        Request->DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(ULONG);

        PxInitBlockStruc(&pProxyRequest->Block);

        Status = NdisCoRequest(pAdapter->CmBindingHandle,
                               pCmAf->NdisAfHandle,
                               NULL,
                               NULL,
                               Request);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        DEREF_CM_AF(pCmAf);

        NdisAcquireSpinLock(&pAdapter->Lock);
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    if (IsClient) {

        PxInitBlockStruc(&pAdapter->ClCloseEvent);

        NdisCloseAdapter(&Status, pAdapter->ClBindingHandle);

        if (Status == NDIS_STATUS_PENDING) {
            PxBlock(&pAdapter->ClCloseEvent);
        }

        PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoUnbindAdapter: CloseAdapter-Cl(%p)\n",
                    pAdapter));

    } else {

        PxInitBlockStruc(&pAdapter->CmCloseEvent);

        NdisCloseAdapter(&Status, pAdapter->CmBindingHandle);

        if (Status == NDIS_STATUS_PENDING) {
            PxBlock(&pAdapter->CmCloseEvent);
        }

        PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoUnbindAdapter: CloseAdapter-Cm(%p)\n",
                    pAdapter));

    }

    DEREF_ADAPTER(pAdapter);

    *pStatus = NDIS_STATUS_SUCCESS;
}

VOID
PxCoCloseAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status
    )
/*++
Routine Description

    Our CloseAdapter completion handler. We signal whoever closed the
    adapter.

Arguments
    BindingContext      - A pointer to a PX_ADAPTER structure.
    Status              - Status of close attempt.

Return Value:
    None
--*/
{
    PPX_ADAPTER     pAdapter;
    BOOLEAN         IsClient;

    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoCloseAdapterComp: Adapter %p\n", pAdapter));

    if (IsClient) {
        PxSignal(&pAdapter->ClCloseEvent, Status);
    } else {
        PxSignal(&pAdapter->CmCloseEvent, Status);
    }
}

VOID
PxCoRequestComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS Status
    )
{
    PPX_ADAPTER     pAdapter;
    PPX_REQUEST     pProxyRequest;
    BOOLEAN         IsClient;

    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoRequestComplete: Adapter %p\n", pAdapter));

    pProxyRequest = CONTAINING_RECORD(NdisRequest, PX_REQUEST, NdisRequest);

    PxSignal(&pProxyRequest->Block, Status);
}


VOID
PxCoNotifyAfRegistration(
     IN  NDIS_HANDLE        BindingContext,
     IN  PCO_ADDRESS_FAMILY pFamily
     )
/*++

Routine Description:

    We get called here each time a call manager registers an address family.

    This is where we open the address family, and register a proxy version if we
    fancy it.

Arguments:

    PxBindingContext       - our pointer to an adapter
    pFamily                 - The AF that's been registered

Return Value:
    None

--*/
{
    PPX_ADAPTER     pAdapter;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PPX_CL_AF       pClAf;
    BOOLEAN         IsClient;
    BOOLEAN         CmAfRegistered;
    BOOLEAN         Found;
    BOOLEAN         RegisterInProgress = FALSE;


    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxNotifyAfRegistration\n"));

    //
    // First, check we're not being called because we registered ourselves...
    //
    if(pFamily->AddressFamily == CO_ADDRESS_FAMILY_TAPI) {
        PXDEBUGP(PXD_LOUD, PXM_CO, ("PxNotifyAfRegistration: AF_TAPI registration -- do nothing\n"));
        return;
    }

    //
    // Get the adapter
    //
    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    if (!IsClient) {
       PXDEBUGP(PXD_LOUD, PXM_CO, ("PxNotifyAfRegistration: Called for CM adapter -- do nothing\n"));
       return;
    }

    //
    // We need to keep the adapter around so place a ref on it!
    //
    NdisAcquireSpinLock(&pAdapter->Lock);
    REF_ADAPTER(pAdapter);
    NdisReleaseSpinLock(&pAdapter->Lock);

    //
    // Wait until we are finished with the binding!
    //
    PxBlock(&pAdapter->BindEvent);

    NdisAcquireSpinLock(&pAdapter->Lock);

    do {

        if ((pAdapter->State == PX_ADAPTER_CLOSING ||
            pAdapter->State == PX_ADAPTER_CLOSED)) {
            PXDEBUGP(PXD_FATAL, PXM_CO, ("PxNotifyAfRegistration: Adapter: %p state: %x is invalid\n",
                pAdapter, pAdapter->State));

            break;
        }

        //
        // See if this adapter already has this type of af registered
        //
        Found = FALSE;

        pClAf = (PPX_CL_AF)pAdapter->ClAfList.Flink;

        while ((PVOID)pClAf != (PVOID)&pAdapter->ClAfList) {
            if (pClAf->Af.AddressFamily == pFamily->AddressFamily) {
                Found = TRUE;
                break;
            }

            pClAf = (PPX_CL_AF)pClAf->Linkage.Flink;
        }

        if (Found) {

            PXDEBUGP(PXD_FATAL, PXM_CO, ("PxNotifyAfRegistration: Af already registered Adapter: %p, Af: %x\n",
                pAdapter, pClAf->Af));

            break;
        }

        pClAf =
            PxAllocateClAf(pFamily, pAdapter);

        if(pClAf == NULL) {

            Status = NDIS_STATUS_RESOURCES;
            PXDEBUGP(PXD_WARNING, PXM_CO, ("NotifyAfRegistration: failed to allocate a PX_CL_AF\n"));
            break;
        }

        //
        // Make sure that we don't let an Unbind thread invalidate our Binding
        // handle.
        //
        if (pAdapter->AfRegisteringCount == 0) {
            PxInitBlockStruc(&pAdapter->AfRegisterEvent);
        }
        pAdapter->AfRegisteringCount++;

        RegisterInProgress = TRUE;

        NdisReleaseSpinLock(&pAdapter->Lock);

        //
        // Open the address family
        //
        {
            NDIS_CLIENT_CHARACTERISTICS     ClChars;
            PNDIS_CLIENT_CHARACTERISTICS    pClChars = &ClChars;

            //
            // Do the client open on the address family
            //
            NdisZeroMemory (pClChars, sizeof(NDIS_CLIENT_CHARACTERISTICS));

            pClChars->MajorVersion = NDIS_MAJOR_VERSION;
            pClChars->MinorVersion = NDIS_MINOR_VERSION;
            pClChars->Reserved = 0;

            pClChars->ClCreateVcHandler = PxClCreateVc;
            pClChars->ClDeleteVcHandler = PxClDeleteVc;
            pClChars->ClOpenAfCompleteHandler = PxClOpenAfComplete;
            pClChars->ClCloseAfCompleteHandler = PxClCloseAfComplete;
            pClChars->ClRegisterSapCompleteHandler = PxClRegisterSapComplete;
            pClChars->ClDeregisterSapCompleteHandler = PxClDeregisterSapComplete;
            pClChars->ClMakeCallCompleteHandler = PxClMakeCallComplete;
            pClChars->ClModifyCallQoSCompleteHandler = PxClModifyCallQosComplete;
            pClChars->ClCloseCallCompleteHandler = PxClCloseCallComplete;
            pClChars->ClAddPartyCompleteHandler = PxClAddPartyComplete;
            pClChars->ClDropPartyCompleteHandler = PxClDropPartyComplete;
            pClChars->ClIncomingCallHandler = PxClIncomingCall;
            pClChars->ClIncomingCallQoSChangeHandler = PxClIncomingCallQosChange;
            pClChars->ClIncomingCloseCallHandler = PxClIncomingCloseCall;
            pClChars->ClIncomingDropPartyHandler = PxClIncomingDropParty;
            pClChars->ClCallConnectedHandler = PxClCallConnected;
            pClChars->ClRequestHandler = PxClRequest;
            pClChars->ClRequestCompleteHandler = PxClRequestComplete;

            PxInitBlockStruc(&pClAf->Block);

            Status = NdisClOpenAddressFamily(pAdapter->ClBindingHandle,
                                             pFamily,
                                             (NDIS_HANDLE)pClAf,
                                             pClChars,
                                             sizeof(NDIS_CLIENT_CHARACTERISTICS),
                                             &pClAf->NdisAfHandle);

            if(Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&pClAf->Block);
            }
        }

        NdisAcquireSpinLock(&pAdapter->Lock);

        if (Status != NDIS_STATUS_SUCCESS) {

            PXDEBUGP(PXD_WARNING, PXM_CO, ("NotifyAfRegistration: Error opening Af %x, Adapter %p, Error %x!!!\n",
                pFamily->AddressFamily, pAdapter, Status));

            PxFreeClAf(pClAf);
            break;
        }

        NdisAcquireSpinLock(&pClAf->Lock);

        pClAf->State = PX_AF_OPENED;

        NdisReleaseSpinLock(&pClAf->Lock);

        //
        // Have only need to register one instance of CO_ADDRESS_FAMILY_TAPI
        // for each adapter.
        //

        InsertTailList(&pAdapter->ClAfList, &pClAf->Linkage);

        if (pAdapter->Flags & PX_CMAF_REGISTERED) {
            CmAfRegistered = TRUE;
        } else {
            CmAfRegistered = FALSE;
            pAdapter->Flags |= PX_CMAF_REGISTERING;
        }

        REF_ADAPTER(pAdapter);

        NdisReleaseSpinLock(&pAdapter->Lock);

        if (!CmAfRegistered) {
            CO_ADDRESS_FAMILY   PxFamily;
            NDIS_CALL_MANAGER_CHARACTERISTICS CmChars;
            PNDIS_CALL_MANAGER_CHARACTERISTICS pCmChars = &CmChars;

            //
            // Now register the Proxied address family. First, get the CM adapter handle.
            //
            NdisZeroMemory(pCmChars, sizeof(CmChars));

            pCmChars->MajorVersion = NDIS_MAJOR_VERSION;
            pCmChars->MinorVersion = NDIS_MINOR_VERSION;
            pCmChars->Reserved = 0;

            pCmChars->CmCreateVcHandler = PxCmCreateVc;
            pCmChars->CmDeleteVcHandler = PxCmDeleteVc;
            pCmChars->CmOpenAfHandler = PxCmOpenAf;
            pCmChars->CmCloseAfHandler = PxCmCloseAf;
            pCmChars->CmRegisterSapHandler = PxCmRegisterSap;
            pCmChars->CmDeregisterSapHandler = PxCmDeRegisterSap;
            pCmChars->CmMakeCallHandler = PxCmMakeCall;
            pCmChars->CmCloseCallHandler = PxCmCloseCall;
            pCmChars->CmIncomingCallCompleteHandler = PxCmIncomingCallComplete;
            pCmChars->CmAddPartyHandler = PxCmAddParty;
            pCmChars->CmDropPartyHandler = PxCmDropParty;
            pCmChars->CmActivateVcCompleteHandler = PxCmActivateVcComplete;
            pCmChars->CmDeactivateVcCompleteHandler = PxCmDeActivateVcComplete;
            pCmChars->CmModifyCallQoSHandler = PxCmModifyCallQos;
            pCmChars->CmRequestHandler = PxCmRequest;
            pCmChars->CmRequestCompleteHandler = PxCmRequestComplete;

            NdisMoveMemory(&PxFamily, pFamily, sizeof(PxFamily));

            PxFamily.AddressFamily = CO_ADDRESS_FAMILY_TAPI;

            PXDEBUGP(PXD_LOUD, PXM_CO, ("NotifyAfRegistration: NdisCmRegisterAddressFamily\n"));

            Status =
                NdisCmRegisterAddressFamily(pAdapter->CmBindingHandle,
                                            &PxFamily,
                                            pCmChars,
                                            sizeof(CmChars));

            NdisAcquireSpinLock(&pAdapter->Lock);

            pAdapter->Flags &= ~PX_CMAF_REGISTERING;

            if(Status != NDIS_STATUS_SUCCESS) {

                //
                // Close the CM af again
                //
                PXDEBUGP(PXD_FATAL, PXM_CO, ("NotifyAfRegistration: NdisCmRegisterAddressFamily on Bind %p bad sts = %x\n", pAdapter->CmBindingHandle, Status));

                RemoveEntryList(&pClAf->Linkage);

                InsertTailList(&pAdapter->ClAfClosingList, &pClAf->Linkage);

                NdisReleaseSpinLock(&pAdapter->Lock);

                NdisAcquireSpinLock(&pClAf->Lock);

                pClAf->State = PX_AF_CLOSING;

                NdisReleaseSpinLock(&pClAf->Lock);

                Status = NdisClCloseAddressFamily (pClAf->NdisAfHandle);

                if (Status != NDIS_STATUS_PENDING) {

                    PxClCloseAfComplete(Status, pClAf);
                }

                NdisAcquireSpinLock(&pAdapter->Lock);

                break;

            } else {

                pAdapter->Flags |= PX_CMAF_REGISTERED;

                NdisReleaseSpinLock(&pAdapter->Lock);
            }
        }

        NdisAcquireSpinLock(&pClAf->Lock);
        REF_CL_AF(pClAf);
        NdisReleaseSpinLock(&pClAf->Lock);

        Status =
            AllocateTapiResources(pAdapter, pClAf);

        DEREF_CL_AF(pClAf);

        NdisAcquireSpinLock(&pAdapter->Lock);


    } while (FALSE);

    if (RegisterInProgress) {

        pAdapter->AfRegisteringCount--;

        if (pAdapter->AfRegisteringCount == 0) {
            PxSignal(&pAdapter->AfRegisterEvent, NDIS_STATUS_SUCCESS);
        }
    }

    DEREF_ADAPTER_LOCKED(pAdapter);
}

VOID
PxCoUnloadProtocol(
    VOID
    )
/*++

Routine Description:
    Unload the entire protocol (CM and CL).

Arguments:
    None

Return Value:
    None

--*/
{
    NDIS_STATUS         Status;

    NdisDeregisterProtocol(&Status, DeviceExtension->PxProtocolHandle);

#if DBG
    NdisAcquireSpinLock(&(DeviceExtension->Lock));

    ASSERT(IsListEmpty(&DeviceExtension->AdapterList));

    NdisReleaseSpinLock(&DeviceExtension->Lock);
#endif
}

NDIS_STATUS
PxCoPnPEvent(
    IN  NDIS_HANDLE     BindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    NDIS_STATUS     Status;
    PPX_ADAPTER     pAdapter;
    BOOLEAN         IsClient;

    if (BindingContext != NULL) {
        AdapterFromBindContext(BindingContext, pAdapter, IsClient);
    }

    switch (pNetPnPEvent->NetEvent){
        case NetEventSetPower:
            Status = PxPnPSetPower(pAdapter, pNetPnPEvent);
            break;

        case NetEventQueryPower:
            Status = PxPnPQueryPower(pAdapter, pNetPnPEvent);
            break;

        case NetEventQueryRemoveDevice:
            Status = PxPnPQueryRemove(pAdapter, pNetPnPEvent);
            break;

        case NetEventCancelRemoveDevice:
            Status = PxPnPCancelRemove(pAdapter, pNetPnPEvent);
            break;

        case NetEventReconfigure:
            Status = PxPnPReconfigure(pAdapter, pNetPnPEvent);
            break;

        case NetEventBindList:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    PXDEBUGP(PXD_INFO, PXM_CO, ("PnPEvent(CM): Event %d, returning %x\n",
                pNetPnPEvent->NetEvent, Status));

    return (Status);
}

NDIS_STATUS
PxPnPSetPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    PNET_DEVICE_POWER_STATE     pPowerState;
    NDIS_STATUS                 Status;

    pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

    switch (*pPowerState) {
        case NetDeviceStateD0:
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            //
            //  We can't suspend, so we ask NDIS to unbind us
            //  by returning this status:
            //
            Status = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    return (Status);
}


NDIS_STATUS
PxPnPQueryPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxPnPQueryRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxPnPCancelRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxPnPReconfigure(
    IN  PPX_ADAPTER     pAdapter        OPTIONAL,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_NOT_SUPPORTED);
}

VOID
PxCoSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoSendComplete\n"));
}



VOID
PxCoTransferDataComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoTransferDataComplete\n"));
}


VOID
PxCoResetComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS Status
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoResetComplete\n"));
}

VOID
PxCoStatusComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoStatusComplete\n"));
}

VOID
PxCoReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoReceiveComplete\n"));
}

VOID
PxCoStatus(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  ProtocolVcContext   OPTIONAL,
    IN NDIS_STATUS  GeneralStatus,
    IN PVOID        StatusBuffer,
    IN UINT         StatusBufferSize
    )
{
    PPX_VC  pVc = NULL;

    PXDEBUGP(PXD_INFO, PXM_CO, 
             ("PxCoStatus : %p, Status %x\n", 
              ProtocolBindingContext,GeneralStatus));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {
        return;
    }

    switch (GeneralStatus) {
        case NDIS_STATUS_TAPI_RECV_DIGIT:

            PxHandleReceivedDigit(pVc,
                                  StatusBuffer,
                                  StatusBufferSize);
            break;

        case NDIS_STATUS_WAN_CO_LINKPARAMS:

            PxHandleWanLinkParams(pVc,
                                  StatusBuffer,
                                  StatusBufferSize);
            break;

        default:
            break;
    }

    DEREF_VC(pVc);
}

UINT
PxCoReceivePacket(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PNDIS_PACKET pNdisPacket
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("CoReceivePacket\n"));
    NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_SUCCESS);
    return 0;
}


ULONG
PxGetMillisecondTickCount()
{
    LARGE_INTEGER               TickCount, Milliseconds;
    ULONG                       TimeIncrement;
    
    //
    // Return the current "tick count" (number of milliseconds since Windows started).
    // TAPI wants this in its DTMF notification messages. We have to do a little math here because
    // the kernel query tick count function returns the number of timer ticks, which is some
    // multiple of 100ns.
    //

    KeQueryTickCount(&TickCount);
    TimeIncrement = KeQueryTimeIncrement();

    Milliseconds.QuadPart = (TickCount.QuadPart / 10000) * TimeIncrement;

    //
    // This might seem a bit sketchy but TAPI only gives us a 32-bit wide place to store the tick
    // count. According to the SDK, TAPI apps are supposed to be aware that this will roll over every
    // 49.7 days. (...it's amusing to think of TAPI staying up for 49.7 days, but I digress...)
    //

    return (Milliseconds.LowPart);

}


// PxTerminateDigitDetection
//
// Must be called with the VC lock held.

VOID 
PxTerminateDigitDetection(
                          IN    PPX_VC              pVc,
                          IN    PNDISTAPI_REQUEST   pNdisTapiRequest,
                          IN    ULONG               ulReason
                          )
{
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    PIRP                        Irp;
    PWCHAR                      pDigitsBuffer; 
    NDIS_STATUS                 Status;


    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxTerminateDigitDetection: Enter\n"));
    
    pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;   

    Irp = pNdisTapiRequest->Irp;
        
    pNdisTapiGatherDigits->ulTickCount = PxGetMillisecondTickCount();           

    pNdisTapiGatherDigits->ulTerminationReason = ulReason;

    //
    // Put the null character at the end of the buffer, and send it on it's way.
    //
    pDigitsBuffer = 
        (PWCHAR) (((PUCHAR)pNdisTapiGatherDigits) + pNdisTapiGatherDigits->ulDigitsBufferOffset);
        
    pDigitsBuffer[pNdisTapiGatherDigits->ulNumDigitsRead] = 
        UNICODE_NULL;

    Irp->IoStatus.Status = NDIS_STATUS_SUCCESS;
    Irp->IoStatus.Information = 
        sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);                             

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Note: we call release here even though we didn't acquire in this function.
    //       This is OK since this function MUST be called with the lock held.
    //
    NdisReleaseSpinLock(&pVc->Lock);

    Status = PxStopDigitReporting(pVc);

    NdisAcquireSpinLock(&pVc->Lock); // See comment above.

    // FIXME: If this failed (i.e. Status is some error value, 
    //        there's not much we can do about it here).

    if (Status != NDIS_STATUS_SUCCESS) {
        PXDEBUGP(PXD_ERROR, PXM_CO, 
                 ("PxTerminateDigitDetection: PxStopDigitReporting returned Status 0x%x\n",
                  Status));
        ASSERT(FALSE);
    }

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxTerminateDigitDetection: Exit\n"));
}



VOID 
PxDigitTimerRoutine(
                    IN PVOID SystemSpecific1,
                    IN PVOID FunctionContext,
                    IN PVOID SystemSpecific2,
                    IN PVOID SystemSpecific3
                    )
{
    PPX_VC                      pVc = (PPX_VC) FunctionContext;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PIRP                        Irp;
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;  
    ULONG ulReason;

    NdisAcquireSpinLock(&pVc->Lock);

    do {
        if (pVc->PendingGatherDigits == NULL) {
            //
            // The request either completed, or a digit is being processed right now, so this timeout is
            // meaningless.
            //      
            
            break;
        }

        pNdisTapiRequest = pVc->PendingGatherDigits;
        Irp = pNdisTapiRequest->Irp;

        if (!IoSetCancelRoutine(Irp, NULL))
        {
            //
            // The cancel routine is running. Let it handle the IRP.
            //
            break;
        }

        pVc->PendingGatherDigits = NULL;
        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;

        if (pNdisTapiGatherDigits->ulNumDigitsRead == 0) {
            //
            // We timed out before detecting the first digit.
            //
            ulReason = LINEGATHERTERM_FIRSTTIMEOUT;
        } else {
            ulReason = LINEGATHERTERM_INTERTIMEOUT;
        }

        PxTerminateDigitDetection(pVc, pNdisTapiRequest, ulReason);

    } while (FALSE);
    
    NdisReleaseSpinLock(&pVc->Lock);

    DEREF_VC(pVc);

}


// ++ DTMFDigitToOrdinal
//
// Turn a DTMF digit into a number between 0 and 15. The digits are assigned
// numbers in the following order: '0' - '9', 'A' - 'D', '*', '#'.
//
// This is horribly ugly now, but we'll optimize later.
//
// Arguments:
// wcDigit  - The digit, expressed as a UNICODE character.
//
// Return value:
// A number between 0 and 15, or 16 if the digit passed in was not a valid 
// DTMF digit. 
// 
ULONG
DTMFDigitToOrdinal(
                   WCHAR    wcDigit
                   )
{
    ULONG ulOrdinal;

    switch (wcDigit) {
    case L'0':
        ulOrdinal = 0;      
        break;
    case L'1':
        ulOrdinal = 1;      
        break;
    case L'2':
        ulOrdinal = 2;      
        break;
    case L'3':
        ulOrdinal = 3;      
        break;
    case L'4':
        ulOrdinal = 4;      
        break;
    case L'5':
        ulOrdinal = 5;      
        break;
    case L'6':
        ulOrdinal = 6;      
        break;
    case L'7':
        ulOrdinal = 7;      
        break;
    case L'8':
        ulOrdinal = 8;      
        break;
    case L'9':
        ulOrdinal = 9;      
        break;
    case L'A':
        ulOrdinal = 10;     
        break;
    case L'B':
        ulOrdinal = 11;     
        break;
    case L'C':
        ulOrdinal = 12;     
        break;
    case L'D':
        ulOrdinal = 13;     
        break;
    case L'*':
        ulOrdinal = 14;     
        break;
    case L'#':
        ulOrdinal = 15;     
        break;
    default:
        ulOrdinal = 16;     
        break;

    };

    return ulOrdinal;
}


NDIS_STATUS
PxStopDigitReporting(
                     PPX_VC pVc
                     )
{
    PX_REQUEST      ProxyRequest;
    PNDIS_REQUEST   NdisRequest;    
    ULONG           Unused = 0;
    NDIS_STATUS     Status;

    //        
    // Fill out our request structure to tell the miniport to stop reporting
    // digits.
    //
    NdisZeroMemory(&ProxyRequest, sizeof(ProxyRequest));

    PxInitBlockStruc(&ProxyRequest.Block);

    NdisRequest = &ProxyRequest.NdisRequest;

    NdisRequest->RequestType = NdisRequestSetInformation;

    NdisRequest->DATA.SET_INFORMATION.Oid = OID_CO_TAPI_DONT_REPORT_DIGITS;

    NdisRequest->DATA.SET_INFORMATION.InformationBuffer = (PVOID)&Unused;

    NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = sizeof(Unused);

    Status = NdisCoRequest(pVc->Adapter->ClBindingHandle, 
                           pVc->ClAf->NdisAfHandle,
                           pVc->ClVcHandle,
                           NULL,
                           NdisRequest);

    if (Status == NDIS_STATUS_PENDING) {
        Status = PxBlock(&ProxyRequest.Block);
    }

    return Status;  
}



VOID 
PxHandleReceivedDigit(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    )
{
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    PWCHAR                      pDigitsBuffer; 
    
    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxHandleReceiveDigit: Enter\n"));

    do {
        PLIST_ENTRY             Entry;
        PIRP                    Irp;
        PNDISTAPI_REQUEST       pNdisTapiRequest;
        ULONG                   ulDigitOrdinal;         
        BOOLEAN                 bTimerCancelled = FALSE;

        //
        // We need at least one WCHAR in the buffer.
        //
        if (BufferSize < sizeof(WCHAR)) {
            //
            // No useful data, get out
            //
            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        if (pVc->ulMonitorDigitsModes != 0) {
            NDIS_TAPI_EVENT Event;
            PPX_TAPI_LINE   pTapiLine;

            //
            // We're monitoring (not gathering) digits, so send up a message right away. 
            //

            pTapiLine = pVc->TapiLine;
            Event.htLine = pTapiLine->htLine;
            Event.htCall = pVc->htCall;
            Event.ulMsg = LINE_MONITORDIGITS;
            Event.ulParam1 = (ULONG_PTR) (* ((PWCHAR)Buffer));
            Event.ulParam2 = (ULONG_PTR) (pVc->ulMonitorDigitsModes); // ToDo - There could be > 1 mode here - have to get this from the driver.
            Event.ulParam3 = (ULONG_PTR) (PxGetMillisecondTickCount());
            
            NdisReleaseSpinLock(&pVc->Lock);
            
            PxIndicateStatus((PVOID) &Event, sizeof(NDIS_TAPI_EVENT));
            
            break;

        }
        
        if (pVc->PendingGatherDigits == NULL) {
            //
            // No Irp to complete, get out
            //
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        NdisCancelTimer(&pVc->DigitTimer, &bTimerCancelled); // deref of VC is at the end - makes locking code a bit cleaner.       

        pNdisTapiRequest = pVc->PendingGatherDigits;

        Irp = pNdisTapiRequest->Irp;

        if (!IoSetCancelRoutine(Irp, NULL))
        {
            //
            // The cancel routine is running. Let it handle the IRP.
            //
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        pVc->PendingGatherDigits = NULL;
        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;

        //
        // Store the current digit, and increment the count. 
        //
        pDigitsBuffer = 
            (PWCHAR) (((PUCHAR)pNdisTapiGatherDigits) + pNdisTapiGatherDigits->ulDigitsBufferOffset);

        pDigitsBuffer[pNdisTapiGatherDigits->ulNumDigitsRead] = 
            *((PWCHAR)Buffer);

        pNdisTapiGatherDigits->ulNumDigitsRead++;
        
        // 
        // Check if we read a termination digit.
        //

        ulDigitOrdinal = DTMFDigitToOrdinal(*((PWCHAR)Buffer));

        if (Irp->Cancel) {

            PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_CANCEL);

        } else if (pNdisTapiGatherDigits->ulTerminationDigitsMask & (1 << ulDigitOrdinal)) {
            
            PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_TERMDIGIT);
        
        } else if (pNdisTapiGatherDigits->ulNumDigitsRead == pNdisTapiGatherDigits->ulNumDigitsNeeded) {
            
            PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_BUFFERFULL);
        
        } else {
            pVc->PendingGatherDigits = pNdisTapiRequest;
            
            if (pNdisTapiGatherDigits->ulInterDigitTimeout) {
                REF_VC(pVc);
                NdisSetTimer(&pVc->DigitTimer, pNdisTapiGatherDigits->ulInterDigitTimeout);
            }

            IoSetCancelRoutine(Irp, PxCancelSetQuery);
        }

        NdisReleaseSpinLock(&pVc->Lock);

        if (bTimerCancelled) {
            //
            // Do this only if the timer was actually cancelled. If it wasn't, then
            // either it wasn't set and the VC wouldn't have been ref'd in the first
            // place, or it fired, in which case the timer routine would have deref'd
            // it already.
            //
            DEREF_VC(pVc);
        }

    } while (FALSE);
    
    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxHandleReceiveDigit: Exit\n"));
}

VOID 
PxHandleWanLinkParams(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxdefs.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxdefs.h

Abstract:

    Defines for ndproxy.sys

Author:

    Tony Bell    


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/04/99        Created

--*/

#ifndef _PXDEFS__H
#define _PXDEFS__H

///////////////////////////////////////////////////////////////////////////
//                      Constants
///////////////////////////////////////////////////////////////////////////

#define MODULE_INIT     0x00010000
#define MODULE_NTINIT   0x00020000
#define MODULE_CO       0x00030000
#define MODULE_CL       0x00040000
#define MODULE_DEBUG    0x00050000
#define MODULE_CM       0x00060000
#define MODULE_UTIL     0x00070000
#define MODULE_CFG      0x00080000
#define MODULE_TAPI     0x00100000

//
// Proxy's memory tags
//
#define PX_EVENT_TAG        '1XP'
#define PX_VCTABLE_TAG      '2XP'
#define PX_ADAPTER_TAG      '3XP'
#define PX_CLSAP_TAG        '4XP'
#define PX_CMSAP_TAG        '5XP'
#define PX_PARTY_TAG        '6XP'
#define PX_COCALLPARAMS_TAG '7XP'
#define PX_REQUEST_TAG      '8XP'
#define PX_PROVIDER_TAG     '9XP'
#define PX_ENUMLINE_TAG     'aXP'
#define PX_TAPILINE_TAG     'bXP'
#define PX_ENUMADDR_TAG     'cXP'
#define PX_TAPIADDR_TAG     'dXP'
#define PX_TAPICALL_TAG     'eXP'
#define PX_LINECALLINFO_TAG 'fXP'
#define PX_CMAF_TAG         'gXP'
#define PX_CLAF_TAG         'hXP'
#define PX_VC_TAG           'iXP'
#define PX_TRANSLATE_CALL   'jXP'
#define PX_TRANSLATE_SAP    'kXP'
#define PX_LINETABLE_TAG    'lXP'

#define NDIS_MAJOR_VERSION  0x05
#define NDIS_MINOR_VERSION  0x00
#define PX_MAJOR_VERSION    0x01
#define PX_MINOR_VERSION    0x00

#define DD_PROXY_DEVICE_NAME        L"\\Device\\NDProxy"
#define PX_NAME                     L"NDProxy"
#define MAX_ADSL_MEDIATYPE_STRING   48
#define MAX_STATUS_COUNT            8
#define MAX_LINE_DEVS               255
#define MAX_NUM_CONCURRENT_CALLS    1000
#define MAX_DEVCLASS_STRINGSIZE     16

#define LINE_TABLE_SIZE             500
#define VC_TABLE_SIZE               500

#define MAX_STRING_PARAM_SIZE   40

#define MAX_OUT_CALL_STATES     4

#define LINE_CALL_INFO_VAR_DATA_SIZE    (17*MAX_STRING_PARAM_SIZE)

//
// ADSL flags to indicate overriding registry values
// in device extension
//
#define ADSL_TX_RATE_FROM_REG   ((USHORT)0x0001)
#define ADSL_RX_RATE_FROM_REG   ((USHORT)0x0002)
#define ADSL_FLAGS_MASK         ((USHORT)0x0004)

//
// Status of tapi with ndproxy
//
typedef enum _NDISTAPI_STATUS {
    NDISTAPI_STATUS_CONNECTED,
    NDISTAPI_STATUS_DISCONNECTED,
    NDISTAPI_STATUS_CONNECTING,
    NDISTAPI_STATUS_DISCONNECTING
} NDISTAPI_STATUS, *PNDISTAPI_STATUS;

//
// Status of providers with ndproxy
//
typedef enum _PROVIDER_STATUS {
    PROVIDER_STATUS_ONLINE,
    PROVIDER_STATUS_OFFLINE
} PROVIDER_STATUS, *PPROVIDER_STATUS;

//
// States for PX_ADAPTER
//
typedef enum PX_ADAPTER_STATE {
    PX_ADAPTER_CLOSED,
    PX_ADAPTER_CLOSING,
    PX_ADAPTER_OPENING,
    PX_ADAPTER_OPEN
} PX_ADAPTER_STATE;

//
// States for PX_CL_AF, PX_CM_AF
//
typedef enum PX_AF_STATE{
    PX_AF_CLOSED,
    PX_AF_CLOSING,
    PX_AF_OPENING,
    PX_AF_OPENED
} PX_AF_STATE;

//
// States for PX_CL_SAP, PX_CM_SAP
//
typedef enum PX_SAP_STATE {
    PX_SAP_CLOSED,
    PX_SAP_CLOSING,
    PX_SAP_OPENING,
    PX_SAP_OPENED
} PX_SAP_STATE;

//
// States for PX_VC between ndproxy
// and the underlying call manager
//
typedef enum PX_VC_STATE {
    PX_VC_IDLE,                     // created
    PX_VC_PROCEEDING,               // outgoing
    PX_VC_OFFERING,                 // incoming
    PX_VC_DISCONNECTING,
    PX_VC_CONNECTED
} PX_VC_STATE;

//
// States for PX_VC between ndproxy
// and the client
//
typedef enum PX_VC_HANDOFF_STATE {
    PX_VC_HANDOFF_IDLE,             // created
    PX_VC_HANDOFF_OFFERING,         // incoming (always)
    PX_VC_HANDOFF_DISCONNECTING,
    PX_VC_HANDOFF_CONNECTED
} PX_VC_HANDOFF_STATE;


///////////////////////////////////////////////////////////////////////////
//                      Macros
///////////////////////////////////////////////////////////////////////////

#ifdef ROUND_UP
#undef ROUND_UP
#endif
#define ROUND_UP(_Val)  (((_Val) + 3) & ~3)


#ifndef MAX

/*++
OPAQUE
MAX(
    IN  OPAQUE      Fred,
    IN  OPAQUE      Shred
)
--*/
#define MAX(Fred, Shred)        (((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
    IN  OPAQUE      Fred,
    IN  OPAQUE      Shred
)
--*/
#define MIN(Fred, Shred)        (((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN

/*++
PVOID
PxAllocMem(
    IN  ULONG   Size
)
--*/
#if DBG

#define PxAllocMem(_p, _s, _t)  \
        _p = PxAuditAllocMem((PVOID)(&(_p)), _s, _t, _FILENUMBER, __LINE__);


#else // DBG

#define PxAllocMem(_p, _s, _t)  \
        _p = ExAllocatePoolWithTag(NonPagedPool, (ULONG)_s, (ULONG)_t)

#endif // DBG


/*++
VOID
PxFreeMem(
    IN  PVOID   Pointer
)
--*/
#if DBG

#define PxFreeMem(Pointer)  PxAuditFreeMem((PVOID)Pointer)

#else

#define PxFreeMem(Pointer)  ExFreePool((PVOID)(Pointer))

#endif // DBG

/*++
VOID
PxInitBlockStruc(
    PxBlockStruc    *pBlock
)
--*/
#define PxInitBlockStruc(pBlock)    NdisInitializeEvent(&((pBlock)->Event))

/*++
NDIS_STATUS
PxBlock(
    PxBlockStruc    *pBlock
)
--*/
#define PxBlock(pBlock)     \
            (NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)


/*++
VOID
PxSignal(
    IN  PxBlockStruc    *pBlock,
    IN  UINT            Status
)
--*/
#define PxSignal(_pbl, _s)  \
            { (_pbl)->Status = _s; NdisSetEvent(&((_pbl)->Event)); }

/*++
VOID
REF_ADAPTER(
    IN  PPX_ADAPTER _pa
    )
--*/
#define REF_ADAPTER(_pa)    \
    (_pa)->RefCount++

/*++
VOID
DEREF_ADAPTER(
    IN  PPX_ADAPTER _pa
    )
--*/
#define DEREF_ADAPTER(_pa)                              \
{                                                       \
    NdisAcquireSpinLock(&(_pa)->Lock);                  \
    if (--(_pa)->RefCount == 0) {                       \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
        PxFreeAdapter(_pa);                             \
    } else {                                            \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
    }                                                   \
}

/*++
VOID
DEREF_ADAPTER_LOCKED(
    IN  PPX_ADAPTER _pa
    )
--*/
#define DEREF_ADAPTER_LOCKED(_pa)                       \
{                                                       \
    if (--(_pa)->RefCount == 0) {                       \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
        PxFreeAdapter(_pa);                             \
    } else {                                            \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
    }                                                   \
}

/*++
REF_CM_AF(
    IN PPX_CM_AF   _paf
    )
--*/
#define REF_CM_AF(_paf)                                 \
{                                                       \
    ASSERT((LONG)(_paf)->RefCount != 0);                \
    (_paf)->RefCount++;                                 \
}                                                       

/*++
VOID
DEREF_CM_AF(
    IN PPX_CM_AF   _paf
    )
--*/
#define DEREF_CM_AF(_paf)                               \
{                                                       \
    NdisAcquireSpinLock(&(_paf)->Lock);                 \
    ASSERT((LONG)(_paf)->RefCount > 0);                 \
    if (--(_paf)->RefCount == 0) {                      \
        DoDerefCmAfWork(_paf);                          \
    } else {                                            \
        NdisReleaseSpinLock(&(_paf)->Lock);             \
    }                                                   \
}

/*++
VOID
DEREF_CM_AF_LOCKED(
    IN PPX_CM_AF   _paf
    )
--*/
#define DEREF_CM_AF_LOCKED(_paf)                        \
{                                                       \
    ASSERT((LONG)(_paf)->RefCount > 0);                 \
    if (--(_paf)->RefCount == 0) {                      \
        DoDerefCmAfWork(_paf);                          \
    } else {                                            \
        NdisReleaseSpinLock(&(_paf)->Lock);             \
    }                                                   \
}

/*++
REF_CL_AF(
    IN PPX_CL_AF   _paf
    )
--*/
#define REF_CL_AF(_paf)                                 \
{                                                       \
    ASSERT((LONG)(_paf)->RefCount != 0);                \
    (_paf)->RefCount++;                                 \
}

/*++
VOID
DEREF_CL_AF(
    IN PPX_CL_AF   _paf
    )
--*/
#define DEREF_CL_AF(_paf)                               \
{                                                       \
    if ((_paf) != NULL) {                               \
        NdisAcquireSpinLock(&(_paf)->Lock);             \
        ASSERT((LONG)(_paf)->RefCount > 0);             \
        if (--(_paf)->RefCount == 0) {                  \
            DoDerefClAfWork(_paf);                      \
        } else {                                        \
            NdisReleaseSpinLock(&(_paf)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_CL_AF_LOCKED(
    IN PPX_CL_AF   _paf
    )
--*/
#define DEREF_CL_AF_LOCKED(_paf)                        \
{                                                       \
    if ((_paf) != NULL) {                               \
    ASSERT((LONG)(_paf)->RefCount > 0);                 \
        if (--(_paf)->RefCount == 0) {                  \
            DoDerefClAfWork(_paf);                      \
        } else {                                        \
            NdisReleaseSpinLock(&(_paf)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
REF_VC(
    IN PPX_VC   _pvc
    )
--*/
#define REF_VC(_pvc)    \
    (_pvc)->RefCount++

#ifdef CODELETEVC_FIXED
/*++
VOID
DEREF_VC(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC(_pvc)                                  \
{                                                       \
    if (_pvc != NULL) {                                 \
        NdisAcquireSpinLock(&(_pvc)->Lock);             \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDerefVcWork(_pvc);                        \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_VC_LOCKED(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC_LOCKED(_pvc)                           \
{                                                       \
    if (_pvc != NULL) {                                 \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDrefVcWork(_pvc);                         \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}
#else
/*++
VOID
DEREF_VC(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC(_pvc)                                  \
{                                                       \
    if (_pvc != NULL) {                                 \
        NdisAcquireSpinLock(&(_pvc)->Lock);             \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDerefVcWork(_pvc);                        \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_VC_LOCKED(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC_LOCKED(_pvc)                           \
{                                                       \
    if (_pvc != NULL) {                                 \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDerefVcWork(_pvc);                        \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}
#endif

/*++
REF_TAPILINE
    IN PPX_TAPI_LINE   _ptl
    )
--*/
#define REF_TAPILINE(_ptl)    \
    (_ptl)->RefCount++

/*++
VOID
DEREF_TAPILINE(
    IN PPX_TAPI_LINE   _ptl
    )
--*/
#define DEREF_TAPILINE(_ptl)                            \
{                                                       \
    if (_ptl != NULL) {                                 \
        NdisAcquireSpinLock(&(_ptl)->Lock);             \
        if (--(_ptl)->RefCount == 0) {                  \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
            FreeTapiLine(_ptl);                         \
        } else {                                        \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_TAPILINE_LOCKED(
    IN PPX_TAPI_LINE   _ptl
    )
--*/
#define DEREF_TAPILINE_LOCKED(_ptl)                     \
{                                                       \
    if (_ptl != NULL) {                                 \
        if (--(_ptl)->RefCount == 0) {                  \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
            FreeTapiLine(_ptl);                         \
        } else {                                        \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
AdapterFromBindContext(
    IN  NDIS_HANDLE _ctx,
    IN  PPX_ADAPTER _pa,
    IN  BOOLENA     _bcl
    )
--*/
#define AdapterFromBindContext(_ctx, _pa, _bcl)         \
{                                                       \
    if (*(PULONG)(_ctx) == PX_ADAPTER_SIG) {            \
        (_pa) = CONTAINING_RECORD((_ctx), PX_ADAPTER, Sig);   \
        (_bcl) = FALSE;                                 \
    } else {                                            \
        (_pa) = (PPX_ADAPTER)(_ctx);                    \
        (_bcl) = TRUE;                                  \
    }                                                   \
}

/*++
VOID
AdapterFromClBindContext(
    IN  NDIS_HANDLE _ctx,
    IN  PPX_ADAPTER _pa
    )
--*/
#define AdapterFromClBindContext(_ctx, _pa) \
        (_pa) = (PPX_ADAPTER)(_ctx)

/*++
VOID
AdapterFromCmBindContext(
    IN  NDIS_HANDLE _ctx,
    IN  PPX_ADAPTER _pa
    )
--*/
#define AdapterFromCmBindContext(_ctx, _pa)                     \
{                                                               \
    ASSERT(*(PULONG)(_ctx) == PX_ADAPTER_SIG);                  \
    (_pa) = CONTAINING_RECORD((_ctx), PX_ADAPTER, Sig);         \
}

/*
VOID
SendTapiCallState(
    IN  PPX_VC      _pvc,
    IN  ULONG_PTR   _p1,
    IN  ULONG_PTR   _p2,
    IN  ULONG_PTR   _p3
    )
*/
#define SendTapiCallState(_pvc, _p1, _p2, _p3)                  \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    PPX_TAPI_LINE   _tl;                                        \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiCallState: Vc %p, CallState: %x, p2: %x, p3 %x\n",\
               _pvc, _p1, _p2, _p3));                           \
    _tl = (_pvc)->TapiLine;                                     \
    _le.htLine = _tl->htLine;                                   \
    _le.htCall = _pvc->htCall;                                  \
    _le.ulMsg = LINE_CALLSTATE;                                 \
    _le.ulParam1 = _p1;                                         \
    _le.ulParam2 = _p2;                                         \
    _le.ulParam3 = _p3;                                         \
    ASSERT((_p1) != (_pvc)->ulCallState);                       \
    (_pvc)->ulCallState = (_p1);                                \
    (_pvc)->ulCallStateMode = (_p2);                            \
    NdisReleaseSpinLock(&(_pvc)->Lock);                         \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
    NdisAcquireSpinLock(&(_pvc)->Lock);                         \
}
//    if ((_p1) == LINECALLSTATE_DISCONNECTED) {                  \
//        InterlockedDecrement((PLONG)&(_tl)->DevStatus->ulNumActiveCalls);\
//    } else if ((_p1) == LINECALLSTATE_OFFERING || (_p1) == LINECALLSTATE_PROCEEDING) {\
//        InterlockedIncrement((PLONG)&(_tl)->DevStatus->ulNumActiveCalls);\
//    }                                                           \

/*
VOID
SendTapiNewCall(
    IN  PPX_VC      _pvc,
    IN  ULONG_PTR   _p1,
    IN  ULONG_PTR   _p2,
    IN  ULONG_PTR   _p3
    )
*/
#define SendTapiNewCall(_pvc, _p1, _p2, _p3)                    \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    _le.htLine = _pvc->TapiLine->htLine;                        \
    _le.htCall = _pvc->htCall;                                  \
    _le.ulMsg = LINE_NEWCALL;                                   \
    _le.ulParam1 = _p1;                                         \
    _le.ulParam2 = _p2;                                         \
    _le.ulParam3 = _p3;                                         \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiNewCall: Vc %p, p1: %x, p2: %x, p3 %x\n",\
               _pvc, _p1, _p2, _p3));                           \
    NdisReleaseSpinLock(&(_pvc)->Lock);                         \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
    NdisAcquireSpinLock(&(_pvc)->Lock);                         \
}

/*
VOID
SendTapiLineClose(
    IN  PPX_TAPI_LINE   _ptl
    )
*/
#define SendTapiLineClose(_ptl)                                 \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    _le.htLine = (_ptl)->htLine;                                \
    _le.htCall = 0;                                             \
    _le.ulMsg = LINE_CLOSE;                                     \
    _le.ulParam1 = 0;                                           \
    _le.ulParam2 = 0;                                           \
    _le.ulParam3 = 0;                                           \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiLineClose: TapiLine %p\n",_ptl));       \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
}

/*
VOID
SendTapiLineCreate(
    IN  PPX_TAPI_LINE   _ptl
    )
*/
#define SendTapiLineCreate(_ptl)                                \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    _le.htLine = (_ptl)->htLine;                                \
    _le.htCall = 0;                                             \
    _le.ulMsg = LINE_CREATE;                                    \
    _le.ulParam1 = 0;                                           \
    _le.ulParam2 = (_ptl)->hdLine;                              \
    _le.ulParam3 = 0;                                           \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiLineCreate: TapiLine %p\n",_ptl));      \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxcm.c ===
/*++                    

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxcm.c

Abstract:

    This module contains the Call Manager (CM_) entry points listed
    in the protocol characteristics table. These entry points are called
    by the NDIS wrapper on behalf of requests made by a client.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-03-96        created
    tonybe      01-23-99        rewrite and cleanup

Notes:


--*/

#include "precomp.h"
#define MODULE_NUMBER MODULE_CM
#define _FILENUMBER   'MCXP'

NDIS_STATUS
PxCmCreateVc(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         NdisVcHandle,
    OUT PNDIS_HANDLE        pProtocolVcContext
    )
/*++

Routine Description:
    We do not allow a client of the proxy to create a Vc ever!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PXDEBUGP(PXD_FATAL, PXM_CM, 
             ("PxCmCreateVc: Should never be called!\n"));

    ASSERT(0);

    return(NDIS_STATUS_FAILURE);
}


NDIS_STATUS
PxCmDeleteVc(
    IN  NDIS_HANDLE         ProtocolVcContext
    )
/*++

Routine Description:
    We do not allow a client to delete a vc!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PXDEBUGP(PXD_FATAL, PXM_CM, 
             ("PxCmDeleteVc: Should never be called!\n"));

    ASSERT(0);

    return(NDIS_STATUS_FAILURE);
}

NDIS_STATUS
PxCmOpenAf(
    IN  NDIS_HANDLE         BindingContext,
    IN  PCO_ADDRESS_FAMILY  AddressFamily,
    IN  NDIS_HANDLE         NdisAfHandle,
    OUT PNDIS_HANDLE        CallMgrAfContext
    )
/*++

Routine Description:
    This routine creats an Af context for the client that is opening
    our address family.  The Af context is threaded up on the adapter
    block.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{

    PPX_CM_AF   pCmAf;
    PPX_ADAPTER pAdapter;

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmOpenAf: AF: %x\n",AddressFamily->AddressFamily));

    //
    // Make sure the address family being opened is ours
    //
    if(AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI) {

        PXDEBUGP(PXD_ERROR, PXM_CM,
                 ("PxCmOpenAf: not Proxy address family: %x\n",
                  AddressFamily->AddressFamily));

        return(NDIS_STATUS_BAD_VERSION);
    }

    AdapterFromCmBindContext(BindingContext, pAdapter);

    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pAdapter->State != PX_ADAPTER_OPEN) {
        NdisReleaseSpinLock(&pAdapter->Lock);
        return (NDIS_STATUS_CLOSING);
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    pCmAf =
        PxAllocateCmAf(AddressFamily);

    if (pCmAf == NULL) {
        PXDEBUGP(PXD_ERROR, PXM_CM, ("PXCmOpenAf: AfBlock memory allocation failed!\n"));
        return (NDIS_STATUS_RESOURCES);
    }

    pCmAf->NdisAfHandle = NdisAfHandle;

    pCmAf->State = PX_AF_OPENED;
    pCmAf->Adapter = pAdapter;

    NdisAcquireSpinLock(&pAdapter->Lock);

    InsertTailList(&pAdapter->CmAfList, &pCmAf->Linkage);

    REF_ADAPTER(pAdapter);

    NdisReleaseSpinLock(&pAdapter->Lock);

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmOpenAf: CmAf %p, NdisAfHandle is %p\n",
        pCmAf,NdisAfHandle));

    *CallMgrAfContext = pCmAf;

    return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxCmCloseAf(
    IN NDIS_HANDLE  CallMgrAfContext
    )
/*++

Routine Description:
    The client is closing the open of this address family.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_CM_AF       pCmAf;
    PPX_ADAPTER     pAdapter;

    pCmAf = (PPX_CM_AF)CallMgrAfContext;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmCloseAf: CmAf %p\n", pCmAf));

    //
    // There should not be any open saps on this af!
    //
    ASSERT(IsListEmpty(&pCmAf->CmSapList) == TRUE);

    //
    // There should not be any active Vc's on this af!
    //
    ASSERT(IsListEmpty(&pCmAf->VcList) == TRUE);

    pAdapter = pCmAf->Adapter;

    NdisAcquireSpinLock(&pAdapter->Lock);

    RemoveEntryList(&pCmAf->Linkage);

    DEREF_ADAPTER_LOCKED(pAdapter);

    NdisAcquireSpinLock(&pCmAf->Lock);

    pCmAf->State = PX_AF_CLOSED;

    pCmAf->Linkage.Flink =
    pCmAf->Linkage.Blink = (PLIST_ENTRY)pCmAf;

    DEREF_CM_AF_LOCKED(pCmAf);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (NDIS_STATUS_PENDING);

}


NDIS_STATUS
PxCmRegisterSap(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    )
/*++

Routine Description:

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_CM_AF   pCmAf;
    PPX_CM_SAP  pCmSap;
    PPX_ADAPTER pAdapter;

    pCmAf = (PPX_CM_AF)CallMgrAfContext;

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmRegisterSap: CmAf %p\n", pCmAf));

    NdisAcquireSpinLock(&pCmAf->Lock);

    if (pCmAf->State != PX_AF_OPENED) {
        PXDEBUGP(PXD_WARNING, PXM_CM,
            ("PxCmRegisterSap: Invalid state %x\n", pCmAf->State));

        NdisReleaseSpinLock(&pCmAf->Lock);
        return (NDIS_STATUS_FAILURE);
    }

    pAdapter = pCmAf->Adapter;

    NdisReleaseSpinLock(&pCmAf->Lock);

    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pAdapter->State != PX_ADAPTER_OPEN) {
        NdisReleaseSpinLock(&pAdapter->Lock);
        return (NDIS_STATUS_CLOSING);
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    //
    // Allocate memory for the Sap
    //
    pCmSap = PxAllocateCmSap(Sap);

    if (pCmSap == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CM,
            ("PxCmRegisterSap: Error allocating memory for sap %p\n", Sap));

        NdisReleaseSpinLock(&pCmAf->Lock);
        return (NDIS_STATUS_RESOURCES);
    }

    NdisAcquireSpinLock(&pCmAf->Lock);

    pCmSap->NdisSapHandle = NdisSapHandle;
    pCmSap->CmAf = pCmAf;

    InsertTailList(&pCmAf->CmSapList, &pCmSap->Linkage);

    REF_CM_AF(pCmAf);

    NdisReleaseSpinLock(&pCmAf->Lock);

    *CallMgrSapContext = pCmSap;

    return(STATUS_SUCCESS);
}


NDIS_STATUS
PxCmDeRegisterSap(
    IN  NDIS_HANDLE       CallMgrSapContext
    )
/*++

Routine Description:

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_CM_SAP  pCmSap;
    PPX_CM_AF   pCmAf;

    pCmSap = (PPX_CM_SAP)CallMgrSapContext;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmDeRegisterSap: CmSap %p\n", pCmSap));

    pCmAf = pCmSap->CmAf;

    InterlockedExchange((PLONG)&pCmSap->State, PX_SAP_CLOSED);

    NdisAcquireSpinLock(&pCmAf->Lock);

    RemoveEntryList(&pCmSap->Linkage);

    DEREF_CM_AF_LOCKED(pCmAf);

    PxFreeCmSap(pCmSap);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmMakeCall(
    IN  NDIS_HANDLE              CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS   pCallParameters,
    IN  NDIS_HANDLE              NdisPartyHandle         OPTIONAL,
    OUT PNDIS_HANDLE             pCallMgrPartyContext    OPTIONAL
    )
/*++

Routine Description:
    We do not allow a client to make a call!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    ASSERT(0);
    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmCloseCall(
    IN  NDIS_HANDLE     CallMgrVcContext,
    IN  NDIS_HANDLE     CallMgrPartyContext OPTIONAL,
    IN  PVOID           Buffer  OPTIONAL,
    IN  UINT            Size    OPTIONAL
    )
{
    PPX_VC      pVc;
    PPX_CM_AF   pCmAf;
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_CM, 
        ("PxCmCloseCall: VcCtx %x\n", CallMgrVcContext));

    GetVcFromCtx(CallMgrVcContext, &pVc);

    if (pVc == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CM, 
            ("PxCmCloseCall: Invalid VcCtx %x!\n", CallMgrVcContext));

        return (NDIS_STATUS_SUCCESS);
    }

    NdisAcquireSpinLock(&pVc->Lock);

    pVc->HandoffState = PX_VC_HANDOFF_IDLE;

    pVc->CloseFlags |= PX_VC_CL_CLOSE_CALL;
    NdisReleaseSpinLock(&pVc->Lock);

    NdisCmCloseCallComplete(NDIS_STATUS_SUCCESS,
                            pVc->CmVcHandle,
                            NULL);

#ifdef CODELETEVC_FIXED
    //
    // Evidently the CoCreateVc is unbalanced
    // when creating a proxy vc.  The call to 
    // NdisCoDeleteVc will fail because the
    // Vc is still active.
    // Investigate this with ndis guys!!!!!
    //
    Status =
        NdisCoDeleteVc(pVc->CmVcHandle);

    if (Status == NDIS_STATUS_SUCCESS) {
        pVc->CmVcHandle = NULL;
    }
#endif

    NdisAcquireSpinLock(&pVc->Lock);


    //
    // If the Vc is no longer connected then
    // we are waiting for this part of the vc
    // to go away before we can cleanup the
    // vc with the call manager.
    //
    if (pVc->Flags & PX_VC_CLEANUP_CM) {

        ASSERT(pVc->State == PX_VC_DISCONNECTING);

        PxCloseCallWithCm(pVc);
    }

    pCmAf = pVc->CmAf;

    //
    // Remove the reference applied when the call
    // was dispatched to the client.  We do not need
    // all of the ref code because of the ref applied
    // at entry to this function.
    //
    pVc->RefCount--;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    DEREF_CM_AF(pCmAf);

    return(NDIS_STATUS_PENDING);
}

VOID
PxCmIncomingCallComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS pCallParameters
    )
{

    PPX_VC      pVc;

    PXDEBUGP(PXD_LOUD, PXM_CM, 
        ("PxCmIncomingCallComplete: VcCtx %x\n", CallMgrVcContext));

    GetVcFromCtx(CallMgrVcContext, &pVc);

    if (pVc == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CM, 
            ("PxCmIncomingCallComplete: Invalid VcCtx %x!\n", 
             CallMgrVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    PXDEBUGP(PXD_LOUD, PXM_CM, 
        ("PxCmIncomingCallComplete: Vc %p, Status %x\n", 
         pVc, Status));

    PxSignal(&pVc->Block, Status);

    //
    // remove the ref applied when we mapped
    // the vcctx to the vc
    //
    DEREF_VC_LOCKED(pVc);
}

NDIS_STATUS
PxCmAddParty(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            pCallMgrPartyContext
    )
/*++

Routine Description:
    We do not allow a client to add a party to a vc!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{

    ASSERT(0);
    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmDropParty(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   Buffer  OPTIONAL,
    IN  UINT                    Size    OPTIONAL
    )
/*++

Routine Description:
    We do not allow a client to drop a party on a vc!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    ASSERT(0);
    return(STATUS_SUCCESS);
}

VOID
PxCmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     pCallParameters)
/*++

Routine Description:
    The vc has already been activate by the underlying
    call manager/miniport!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    ASSERT(0);
}

VOID
PxCmDeActivateVcComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext
    )
/*++

Routine Description:
    The vc is never deactivated by our call manager!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{

    ASSERT(0);
}

NDIS_STATUS
PxCmModifyCallQos(
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS pCallParameters
    )
/*++

Routine Description:
    Not sure what to do here right now!
    ToDo!!!!!!!!!!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
/*++

Routine Description:
    We will handle requests from the clients and pass them down
    to the underlying call manager/miniport if needed.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    return(STATUS_SUCCESS);
}

VOID
PxCmRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,      // Optional
    IN NDIS_HANDLE ProtocolPartyContext, // Optional
    IN PNDIS_REQUEST NdisRequest
    )
/*++

Routine Description:
    Called by the client upon completion of any requests
    that we have passed up to it.  If this request needed to
    be completed synchronously (status matters) then we will
    signal completion and let the calling routine free the
    memory.  If this could complete asynchronously then we
    just free the memory here.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_REQUEST     pProxyRequest;
    PPX_CM_AF       pCmAf;
    PPX_VC          pVc;

    pCmAf = (PPX_CM_AF)ProtocolAfContext;
    pVc = (PPX_VC)ProtocolVcContext;

    PXDEBUGP(PXD_INFO, PXM_CM, ("PxCmRequestComplete: CmAf %p, Vc %p\n", pCmAf, pVc));

    pProxyRequest = CONTAINING_RECORD(NdisRequest, PX_REQUEST, NdisRequest);

    if (pProxyRequest->Flags & PX_REQ_ASYNC) {
        pProxyRequest->Flags &= ~PX_REQ_ASYNC;
        PxFreeMem(pProxyRequest);
        DEREF_CM_AF(pCmAf);
    } else {
        PxSignal(&pProxyRequest->Block, Status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxinit.c ===
/*++

Copyright (c) 1995-1996  Micrososfft Corporation

Module Name:

    pxinit.c

Abstract:

    The module contains the init code for the NDIS Proxy.

Author:

   Richard Machin (RMachin)
Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/

#include <precomp.h>

#define MODULE_NUMBER   MODULE_INIT
#define _FILENUMBER   'TINI'

//
// Local defines...
//
NDIS_STATUS
GetConfigDword(
    NDIS_HANDLE Handle,
    PWCHAR      ParameterName,
    PULONG      Destination,
    ULONG       MinValue,
    ULONG       MaxValue
);

BOOLEAN
InitNDISProxy(
    VOID
    )
/*++
Routine Description

    The main init routine. We:

    read our configuration
    register as a protocol
    open the appropriate cards as a client (call ActivateBinding, which:
      Opens the appropriate address families
      Opens the cards as a Call Manager)

Arguments

    None

Calling Sequence:

    Called from pxntinit/DriverEntry

Return Value:

    TRUE if initalization succeeds.

--*/
{

    NDIS_PROTOCOL_CHARACTERISTICS PxProtocolCharacteristics;
    NDIS_STATUS         Status;
    NDIS_HANDLE         ConfigHandle;
    PVOID               Context;
    PVOID               BindingList;
    PNDIS_STRING        BindingNameString;

    PXDEBUGP(PXD_INFO, PXM_INIT, ("InitNdisProxy\n"));

    // Registering NDIS protocols.
    NdisZeroMemory(&PxProtocolCharacteristics,
                   sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    PxProtocolCharacteristics.MajorNdisVersion =             NDIS_MAJOR_VERSION;
    PxProtocolCharacteristics.MinorNdisVersion =             NDIS_MINOR_VERSION;
    PxProtocolCharacteristics.Filler  =                      (USHORT)0;
    PxProtocolCharacteristics.Flags  =                       NDIS_PROTOCOL_PROXY |
                                                             NDIS_PROTOCOL_BIND_ALL_CO;
    PxProtocolCharacteristics.OpenAdapterCompleteHandler  = PxCoOpenAdaperComplete;
    PxProtocolCharacteristics.CloseAdapterCompleteHandler = PxCoCloseAdaperComplete;
    PxProtocolCharacteristics.TransferDataCompleteHandler = PxCoTransferDataComplete;
    PxProtocolCharacteristics.ResetCompleteHandler =        PxCoResetComplete;
    PxProtocolCharacteristics.SendCompleteHandler   =       PxCoSendComplete;
    PxProtocolCharacteristics.RequestCompleteHandler =      PxCoRequestComplete;
    PxProtocolCharacteristics.ReceiveHandler =              NULL;
    PxProtocolCharacteristics.ReceiveCompleteHandler =      PxCoReceiveComplete;
    PxProtocolCharacteristics.ReceivePacketHandler =        NULL;
    PxProtocolCharacteristics.StatusHandler =               NULL;
    PxProtocolCharacteristics.StatusCompleteHandler =       PxCoStatusComplete;
    PxProtocolCharacteristics.BindAdapterHandler =          PxCoBindAdapter;
    PxProtocolCharacteristics.UnbindAdapterHandler =        PxCoUnbindAdapter;
    PxProtocolCharacteristics.PnPEventHandler =             PxCoPnPEvent;
    PxProtocolCharacteristics.UnloadHandler =               PxCoUnloadProtocol;
    PxProtocolCharacteristics.CoStatusHandler =             PxCoStatus;
    PxProtocolCharacteristics.CoReceivePacketHandler =      PxCoReceivePacket;
    PxProtocolCharacteristics.CoAfRegisterNotifyHandler =   PxCoNotifyAfRegistration;
    NdisInitUnicodeString(&(PxProtocolCharacteristics.Name), PX_NAME);

    //
    //  To block BindAdapter till all RegisterProtocols are done.
    //
    NdisInitializeEvent(&DeviceExtension->NdisEvent);

    //
    // Now register ourselves as a CM with NDIS.
    //
    PXDEBUGP(PXD_LOUD,PXM_INIT, ("Registering Protocol\n"));
    NdisRegisterProtocol(&Status,
                         &(DeviceExtension->PxProtocolHandle),
                         &PxProtocolCharacteristics,
                         sizeof(PxProtocolCharacteristics));

    if (Status != NDIS_STATUS_SUCCESS) {
        PXDEBUGP(PXD_INFO, PXM_INIT, ("Protocol registration failed!\n"));
        return FALSE;
    }

    //
    //  Allow BindAdapter to proceed.
    //
    NdisSetEvent(&DeviceExtension->NdisEvent);

    return TRUE;
}

VOID
GetRegistryParameters(
    IN PUNICODE_STRING  RegistryPath
    )

/*++

Routine Description:

This routine stores the configuration information for this device.

Arguments:

RegistryPath - Pointer to the null-terminated Unicode name of the
    registry path for this driver.

Return Value:

None.  As a side-effect, sets DeviceExtension->EventDataQueuLength field

--*/

{
    NDIS_STRING     ProtocolName;
    ULONG           ulDefaultData = 0;
    ULONG           ulMaxRate = -1;
    NTSTATUS        Status = STATUS_SUCCESS;
    HANDLE          hHandle, hParamsKeyHandle = NULL;
    NDIS_STRING     KeyName;
    USHORT          DefaultMediaType[] = L"Unspecfied ADSL Media";

    NdisInitUnicodeString(&ProtocolName, L"NDProxy");
    NdisInitUnicodeString(&KeyName, L"Parameters");

    //
    //    Open the Proxy's key in the registry.
    //
    NdisOpenProtocolConfiguration(&Status,
                                  &hHandle,
                                  &ProtocolName);

    if (Status != NDIS_STATUS_SUCCESS) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        NdisOpenConfigurationKeyByName(&Status,
                                       hHandle,     //"HKLM/CCS/NDProxy"
                                       &KeyName,    //"Parameters"
                                       &hParamsKeyHandle);

        if (NT_SUCCESS(Status)) {
            ULONG ulResult;
            PNDIS_CONFIGURATION_PARAMETER   pNdisConfigurationParameter;

            //
            // Gather all of the "user specified" information from
            // the registry.
            //
            Status = GetConfigDword (hParamsKeyHandle, L"TxRate", &DeviceExtension->ADSLTxRate, ulDefaultData, ulMaxRate);

            if (!NT_SUCCESS(Status)) {
                PXDEBUGP(PXD_LOUD, PXM_INIT, (
                                   "GetRegistryParameters: NdisReadConfiguration failed, err=%x\n",
                                   Status
                                   ));
            } else {
                DeviceExtension->RegistryFlags |= ADSL_TX_RATE_FROM_REG;
            }

            //
            // Next
            //
            Status = GetConfigDword (hParamsKeyHandle, L"RxRate", &DeviceExtension->ADSLRxRate, ulDefaultData, ulMaxRate);

            if (!NT_SUCCESS(Status)) {
                PXDEBUGP(PXD_LOUD, PXM_INIT, (
                                   "GetRegistryParameters: NdisReadConfiguration failed, err=%x\n",
                                   Status));
            } else {
                DeviceExtension->RegistryFlags |= ADSL_RX_RATE_FROM_REG;
            }

            //
            // Dump values
            //
            PXDEBUGP (PXD_LOUD, PXM_INIT, (
                                "GetRegistryParameters: ADSLTxRate = %x\n",
                                DeviceExtension->ADSLTxRate
                                ));
            PXDEBUGP (PXD_LOUD, PXM_INIT, (
                                "GetRegistryParameters: ADSLRxRate = %x\n",
                                DeviceExtension->ADSLRxRate
                                ));
        }
    }
}

NDIS_STATUS
GetConfigDword(
    NDIS_HANDLE Handle,
    PWCHAR      ParameterName,
    PULONG      Destination,
    ULONG       MinValue,
    ULONG       MaxValue
)
/*++

Routine Description

    A routine to read a ulong  from the registry. We're given a handle,
    the name of the key, and where to put it.

Arguments

    Handle          - Open handle to the parent key.
    ParameterName   - Pointer to name of the parameter.
    Destination     - Where to put the dword.
    MinValue        - Minimum value of the dword allowed.
    MaxValue        - Maximum allowable value.

Return Value:

    NDIS_STATUS_SUCCESS if we read in the value, error code otherwise.

--*/
{
    NDIS_STATUS                     Status;
    ULONG                           Value;
    NDIS_STRING                     ParameterNameString;
    PNDIS_CONFIGURATION_PARAMETER   pNdisConfigurationParameter;

    NdisInitUnicodeString(
                    &ParameterNameString,
                    ParameterName
                    );

    NdisReadConfiguration(
                    &Status,
                    &pNdisConfigurationParameter,
                    Handle,
                    &ParameterNameString,
                    NdisParameterInteger
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Value = pNdisConfigurationParameter->ParameterData.IntegerData;

        if ((Value >= (ULONG)MinValue) && (Value <= (ULONG)MaxValue))
        {
            *Destination = (ULONG)Value;
        }
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxcl.c ===
/*++                        

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxcl.c

Abstract:

    The module contains the calls to the proxy client from NDIS.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/
#include "precomp.h"

#define MODULE_NUMBER MODULE_CL
#define _FILENUMBER 'LCXP'


NDIS_STATUS
PxClCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPX_CL_AF   pClAf;
    PPX_VC      pVc;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCreateVc: ClAf %p\n", ProtocolAfContext));

    pClAf = (PPX_CL_AF)ProtocolAfContext;

    NdisAcquireSpinLock(&pClAf->Lock);

    if (pClAf->State != PX_AF_OPENED) {
        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCreateVc: Invalid AfState ClAf %p, State %x\n", 
             pClAf, pClAf->State));

        NdisReleaseSpinLock(&pClAf->Lock);

        return (NDIS_STATUS_FAILURE);
    }

    pVc = PxAllocateVc(pClAf);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCreateVc: Error allocating memory\n"));

        NdisReleaseSpinLock(&pClAf->Lock);

        return (NDIS_STATUS_RESOURCES);
    }

    pVc->ClVcHandle = NdisVcHandle;

    NdisReleaseSpinLock(&pClAf->Lock);

    if (!InsertVcInTable(pVc)) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCreateVc: failed to insert in vc table\n"));

        PxFreeVc(pVc);

        return (NDIS_STATUS_RESOURCES);
    }
   
    *ProtocolVcContext = (NDIS_HANDLE)pVc->hdCall;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCreateVc: Exit\n"));

    return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxClDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext
    )
{
    PPX_VC  pVc;

    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClDeleteVc: Enter\n"));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClDeleteVc: VcCtx invalid %x\n", ProtocolVcContext));

        return (NDIS_STATUS_FAILURE);
    }

    ASSERT(pVc->State == PX_VC_IDLE);

    //
    // Deref for ref applied when we allocated the Vc.
    // We do not need the full deref code as the ref
    // applied at entry will keep the vc around.
    //
    pVc->RefCount--;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC(pVc);

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClDeleteVc: Exit, Status %x\n", Status));

    return (Status);
}


NDIS_STATUS
PxClRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
/*++

Routine Description:

    This is called by an underlying cm/mp to send an ndisrequest to
    a client.  Since we might be proxying on behalf of multiple clients
    we need to broadcast this request on to all clients that have
    opened our address family for this adapter.  We are interested in
    OID_CO_AF_CLOSE so that we can cleanup our open on the Af and
    OID_GEN_CO_LINK_SPEED so that we can get changes in linkspeed
    on the adapter (and Vc if active).

Arguments:



Return Value:


--*/
{
    PPX_CL_AF       pClAf;
    PPX_CM_AF       pCmAf;
    PPX_ADAPTER     pAdapter;
    PPX_VC          pVc = NULL;
    NDIS_STATUS     Status;
    NDIS_HANDLE     VcHandle;

    //
    // The Vc returned here could be NULL as this
    // request might not be on vc.
    //
    GetVcFromCtx(ProtocolVcContext, &pVc);
    
    pClAf = (PPX_CL_AF)ProtocolAfContext;
    pAdapter = pClAf->Adapter;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClRequest: ClAf %p, Vc %p\n", pClAf, pVc));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    switch (NdisRequest->DATA.QUERY_INFORMATION.Oid) {
        case OID_CO_AF_CLOSE:
            {
            PPX_TAPI_PROVIDER   TapiProvider;

            NdisAcquireSpinLock(&pAdapter->Lock);

            RemoveEntryList(&pClAf->Linkage);

            InsertTailList(&pAdapter->ClAfClosingList, &pClAf->Linkage);

            NdisReleaseSpinLock(&pAdapter->Lock);

            //
            // We need to cleanup and close the open
            // on this af.  This would include tearing
            // down all active calls (Vc's), deregistering
            // all saps and closing the af.
            //
            NdisAcquireSpinLock(&pClAf->Lock);

            //
            // Mark the Af as closing...
            //
            pClAf->State = PX_AF_CLOSING;

            TapiProvider = pClAf->TapiProvider;

            NdisReleaseSpinLock(&pClAf->Lock);

            //
            // Take all tapi devices associated with
            // this address family offline
            //
            if (TapiProvider != NULL) {
                NdisAcquireSpinLock(&TapiProvider->Lock);

                MarkProviderOffline(TapiProvider);

                NdisReleaseSpinLock(&TapiProvider->Lock);
            }

            //
            // Build list of Vc's that need attention
            //
            NdisAcquireSpinLock(&pClAf->Lock);

            while (!IsListEmpty(&pClAf->VcList)) {
                PLIST_ENTRY         Entry;
                PPX_VC              pActiveVc;

                Entry = RemoveHeadList(&pClAf->VcList);

                InsertHeadList(&pClAf->VcClosingList, Entry);

                pActiveVc = CONTAINING_RECORD(Entry, PX_VC, ClAfLinkage);

                NdisReleaseSpinLock(&pClAf->Lock);

                NdisAcquireSpinLock(&pActiveVc->Lock);

                pActiveVc->CloseFlags |= PX_VC_CLOSE_AF;

                REF_VC(pActiveVc);

                PxVcCleanup(pActiveVc, 0);

                DEREF_VC_LOCKED(pActiveVc);

                NdisAcquireSpinLock(&pClAf->Lock);
            }

            //
            // Get rid of all of the saps
            //
            {
                PLIST_ENTRY pe;
                PPX_CL_SAP  pClSap;

                pe = pClAf->ClSapList.Flink;

                pClSap =
                    CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);

                while ((PVOID)pClSap != (PVOID)&pClAf->ClSapList) {

                    if (InterlockedCompareExchange((PLONG)&pClSap->State,
                                                   PX_SAP_CLOSING,
                                                   PX_SAP_OPENED)) {

                        RemoveEntryList(&pClSap->Linkage);

                        InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

                        NdisReleaseSpinLock(&pClAf->Lock);

                        ClearSapWithTapiLine(pClSap);

                        Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

                        if (Status != NDIS_STATUS_PENDING) {
                            PxClDeregisterSapComplete(Status, pClSap);
                        }

                        NdisAcquireSpinLock(&pClAf->Lock);

                        pe = pClAf->ClSapList.Flink;

                        pClSap =
                            CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                    } else {
                        pe = pClSap->Linkage.Flink;

                        pClSap =
                            CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                    }
                }
            }

            DEREF_CL_AF_LOCKED(pClAf);

            //
            // Now broadcast this close to all of the clients
            // we have using this adapter/af.
            //
            NdisAcquireSpinLock(&pAdapter->Lock);

            while (!IsListEmpty(&pAdapter->CmAfList)) {
                PX_REQUEST  ProxyRequest;
                PPX_REQUEST pProxyRequest = &ProxyRequest;
                ULONG       Info = 0;
                PNDIS_REQUEST   NdisRequest;

                pCmAf = (PPX_CM_AF)RemoveHeadList(&pAdapter->CmAfList);

                InsertTailList(&pAdapter->CmAfClosingList, &pCmAf->Linkage);

                NdisReleaseSpinLock(&pAdapter->Lock);

                NdisAcquireSpinLock(&pCmAf->Lock);

                pCmAf->State = PX_AF_CLOSING;

                REF_CM_AF(pCmAf);

                NdisReleaseSpinLock(&pCmAf->Lock);

                NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

                NdisRequest = &pProxyRequest->NdisRequest;

                NdisRequest->RequestType =
                    NdisRequestSetInformation;
                NdisRequest->DATA.QUERY_INFORMATION.Oid =
                    OID_CO_AF_CLOSE;
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                    &Info;
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                    sizeof(ULONG);

                PxInitBlockStruc(&pProxyRequest->Block);

                Status = NdisCoRequest(pAdapter->CmBindingHandle,
                                       pCmAf->NdisAfHandle,
                                       NULL,
                                       NULL,
                                       NdisRequest);

                if (Status == NDIS_STATUS_PENDING) {
                    Status = PxBlock(&pProxyRequest->Block);
                }

                DEREF_CM_AF(pCmAf);

                NdisAcquireSpinLock(&pAdapter->Lock);
            }

            NdisReleaseSpinLock(&pAdapter->Lock);

            }
            break;

        case OID_GEN_CO_LINK_SPEED:
            //
            // We need to record the new speed of
            // the vc.
            //
            break;

        default:
            //
            // Just pass it through
            //
            break;
    }

    VcHandle = (pVc != NULL) ? pVc->CmVcHandle : NULL;

    //
    // Now broadcast this request up to all of the Clients 
    // that have opend our af for this adapter.
    //
    NdisAcquireSpinLock(&pAdapter->Lock);

    pCmAf = (PPX_CM_AF)pAdapter->CmAfList.Flink;

    while ((PVOID)pCmAf != (PVOID)&pAdapter->CmAfList) {
        PPX_CM_AF   NextAf;
        PX_REQUEST  ProxyRequest;
        PPX_REQUEST pProxyRequest = &ProxyRequest;

        NextAf = 
            (PPX_CM_AF)pCmAf->Linkage.Flink;

        NdisAcquireSpinLock(&pCmAf->Lock);

        if (pCmAf->State != PX_AF_OPENED) {
            NdisReleaseSpinLock(&pCmAf->Lock);
            pCmAf = NextAf;
            continue;
        }

        REF_CM_AF(pCmAf);
        NdisReleaseSpinLock(&pCmAf->Lock);

        NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

        NdisMoveMemory(&pProxyRequest->NdisRequest, NdisRequest, sizeof(NDIS_REQUEST));

        NdisReleaseSpinLock(&pAdapter->Lock);

        PxInitBlockStruc(&pProxyRequest->Block);

        Status = NdisCoRequest(pAdapter->CmBindingHandle,
                               pCmAf->NdisAfHandle,
                               VcHandle,
                               NULL,
                               &pProxyRequest->NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            PxBlock(&pProxyRequest->Block);
        }

        NdisAcquireSpinLock(&pAdapter->Lock);

        //
        // deref for the ref applied before we
        // propagated this request
        //
        DEREF_CM_AF(pCmAf);

        pCmAf = NextAf;
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    //
    // Remove ref applied when we attempted to
    // map the vcctx to a vcptr at entry.
    //
    DEREF_VC(pVc);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (NDIS_STATUS_SUCCESS);
}

VOID
PxClRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,       // Optional
    IN NDIS_HANDLE ProtocolPartyContext,    // Optional
    IN PNDIS_REQUEST NdisRequest
    )
{
    PPX_REQUEST     pProxyRequest;
    PPX_CL_AF       pClAf;
    PPX_VC          pVc = NULL;

    pClAf = (PPX_CL_AF)ProtocolAfContext;

    //
    // The Vc returned here could be NULL as this
    // request might not be on vc.
    //
    GetVcFromCtx(ProtocolVcContext, &pVc);

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClRequestComplete: ClAf %p, Vc %p, Oid: %x, Status %x\n", 
         pClAf, pVc, NdisRequest->DATA.QUERY_INFORMATION.Oid, Status));

    pProxyRequest = CONTAINING_RECORD(NdisRequest, PX_REQUEST, NdisRequest);

    if (pProxyRequest->Flags & PX_REQ_ASYNC) {
        pProxyRequest->Flags &= ~PX_REQ_ASYNC;
        PxFreeMem(pProxyRequest);
    } else {
        PxSignal(&pProxyRequest->Block, Status);
    }

    //
    // Remove ref applied when we attempted to
    // map the vcctx to a vcptr at entry.
    //
    DEREF_VC(pVc);
}

VOID
PxClOpenAfComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisAfHandle
    )
{
    PPX_CL_AF   pClAf;

    pClAf = (PPX_CL_AF)ProtocolAfContext;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClOpenAfComplete: ClAf %p, Status %x\n", pClAf, Status));

    pClAf->NdisAfHandle = NdisAfHandle;

    PxSignal(&pClAf->Block, Status);
}

VOID
PxClCloseAfComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolAfContext
    )
{
    PPX_CL_AF   pClAf;
    PPX_ADAPTER pAdapter;
    PPX_TAPI_PROVIDER   TapiProvider;

    pClAf = (PPX_CL_AF)ProtocolAfContext;
    pAdapter = pClAf->Adapter;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCloseAfComplete: ClAf %p, Status %x\n", pClAf, Status));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisAcquireSpinLock(&pAdapter->Lock);

    RemoveEntryList(&pClAf->Linkage);

    DEREF_ADAPTER_LOCKED(pAdapter);

    NdisAcquireSpinLock(&pClAf->Lock);

    pClAf->State = PX_AF_CLOSED;

    TapiProvider = pClAf->TapiProvider;
    pClAf->TapiProvider = NULL;

    NdisReleaseSpinLock(&pClAf->Lock);

    if (TapiProvider != NULL) {

        NdisAcquireSpinLock(&TapiProvider->Lock);

        MarkProviderOffline(TapiProvider);

        NdisReleaseSpinLock(&TapiProvider->Lock);
    }

    PxFreeClAf(pClAf);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
}


VOID
PxClRegisterSapComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolSapContext,
    IN PCO_SAP      pSap,
    IN NDIS_HANDLE  NdisSapHandle
    )
{
    PPX_CL_SAP      pClSap;
    PPX_CL_AF       pClAf;
    PPX_TAPI_LINE   TapiLine;

    pClSap = (PPX_CL_SAP)ProtocolSapContext;
    pClAf = pClSap->ClAf;
    TapiLine = pClSap->TapiLine;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClRegisterSapComplete: ClSap %p, Status %x\n", pClSap, Status));


    if (Status != NDIS_STATUS_SUCCESS) {

        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSED);

        NdisAcquireSpinLock(&pClAf->Lock);

        RemoveEntryList(&pClSap->Linkage);

        DEREF_CL_AF_LOCKED(pClAf);

        TapiLine->ClSap = NULL;

        PxFreeClSap(pClSap);

        return;
    }

    pClSap->NdisSapHandle = NdisSapHandle;

    NdisAcquireSpinLock(&pClAf->Lock);

    if (pClAf->State != PX_AF_OPENED) {
        //
        // the af is no longer open so we to deregister
        // this sap
        //

        NdisReleaseSpinLock(&pClAf->Lock);

        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

        Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            PxClDeregisterSapComplete(Status, pClSap);
        }

        return;
    }

    NdisReleaseSpinLock(&pClAf->Lock);


    NdisAcquireSpinLock(&TapiLine->Lock);

    if (TapiLine->DevStatus->ulNumOpens == 0) {

        NdisReleaseSpinLock(&TapiLine->Lock);

        //
        // There are not any opens on the line so we
        // need to deregister the sap
        //
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

        Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            PxClDeregisterSapComplete(Status, pClSap);
        }

        return;
    }

    NdisReleaseSpinLock(&TapiLine->Lock);

    InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENED);
}

VOID
PxClDeregisterSapComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolSapContext
    )
{
    PPX_CL_SAP  pClSap;
    PPX_CL_AF   pClAf;

    pClSap = (PPX_CL_SAP)ProtocolSapContext;
    pClAf = pClSap->ClAf;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClDeregisterSapComplete: ClSap %p, Status %x\n", pClSap, Status));

    NdisAcquireSpinLock(&pClAf->Lock);

    RemoveEntryList(&pClSap->Linkage);

    DEREF_CL_AF_LOCKED(pClAf);

    InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSED);

    PxFreeClSap(pClSap);
}

VOID
PxClMakeCallComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         ProtocolVcContext,
    IN  NDIS_HANDLE         ProxyNdisPartyHandle OPTIONAL,
    IN  PCO_CALL_PARAMETERS pCallParameters
    )
{
    PPX_VC      pVc;
    PPX_CL_AF   pClAf;
    ULONG       ulCallState;
    ULONG       ulCallStateMode;
    BOOLEAN     TapiStateChange;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClMakeCallComplete: VcCtx %x, Status %x\n", ProtocolVcContext, Status));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClMakeCallComplete: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    TapiStateChange = TRUE;

    NdisAcquireSpinLock(&pVc->Lock);

    ASSERT(pVc->Flags & PX_VC_OWNER);

    do {

        if (pVc->Flags & PX_VC_OUTCALL_ABORTED) {
            //
            // This call has been aborted while
            // in the PROCEEDING state.  This means
            // that the CloseCallComplete has run 
            // and did our cleanup so just get
            // out.
            //
            break;

        } else if (pVc->Flags & PX_VC_OUTCALL_ABORTING) {
            pVc->Flags &= ~PX_VC_OUTCALL_ABORTING;
            pVc->Flags |= PX_VC_OUTCALL_ABORTED;
        }


        ASSERT((pVc->State == PX_VC_DISCONNECTING) ||
               (pVc->State == PX_VC_PROCEEDING));

        if (Status == NDIS_STATUS_SUCCESS) {

            //
            // This means that we received a drop from tapi
            // while the ClMakeCall was pending.
            //
            if (pVc->State == PX_VC_DISCONNECTING) {
                //
                // We need to drop the call with the
                // call manager/miniport
                //
                pVc->Flags &= ~PX_VC_OUTCALL_ABORTED;
                PxCloseCallWithCm(pVc);

                TapiStateChange = FALSE;

            } else {

                ulCallState = LINECALLSTATE_CONNECTED;
                ulCallStateMode = 0;
                pVc->PrevState = pVc->State;
                pVc->State = PX_VC_CONNECTED;
            }

        } else {

            ulCallState = LINECALLSTATE_DISCONNECTED;
            ulCallStateMode =
                PxMapNdisStatusToTapiDisconnectMode(Status, TRUE);

            //
            // Remove the ref applied before we
            // call NdisClMakeCall.  We don't need
            // to do the full deref code here as the
            // ref applied when we mapped the vc will
            // keep the vc around!
            //
            pVc->RefCount--;

            pVc->PrevState = pVc->State;
            pVc->State = PX_VC_IDLE;
        }

        if (TapiStateChange == TRUE) {

            SendTapiCallState(pVc, 
                              ulCallState, 
                              ulCallStateMode, 
                              pVc->CallInfo->ulMediaMode);
        }

        if (pVc->Flags & PX_VC_DROP_PENDING){
            PxTapiCompleteDropIrps(pVc, Status);
        }

    } while (FALSE);

    //
    // Deref for ref applied when mapping the context.
    // This releases the Vc lock!
    //
    DEREF_VC_LOCKED(pVc);
}

VOID
PxClModifyCallQosComplete(
    IN NDIS_STATUS          Status,
    IN NDIS_HANDLE          ProtocolVcContext,
    IN PCO_CALL_PARAMETERS  CallParameters
    )
{

}


VOID
PxClCloseCallComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolVcContext,
    IN NDIS_HANDLE  ProtocolPartyContext OPTIONAL
    )
{
    PPX_VC      pVc;
    PPX_CL_AF   pClAf;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCloseCallComplete: VcCtx %x, Status %x\n", ProtocolVcContext, Status));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCloseCallComplete: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    do {

        //
        // The closecall did not take (atm does
        // not support receiving a closecall while
        // an outgoing call is proceeding).  We 
        // need to get out and cleanup later.
        //
        if (Status != NDIS_STATUS_SUCCESS) {
            pVc->Flags |= PX_VC_CLEANUP_CM;
            pVc->CloseFlags |= PX_VC_CM_CLOSE_FAIL;
            break;
        }

        pVc->CloseFlags |= PX_VC_CM_CLOSE_COMP;

        if (pVc->Flags & PX_VC_OUTCALL_ABORTED) {

            //
            // This call has been aborted while
            // in the PROCEEDING state.  This means
            // that the MakeCallComplete has run 
            // and did our cleanup so just get
            // out.
            //
            break;

        } else if (pVc->Flags & PX_VC_OUTCALL_ABORTING) {

            pVc->Flags &= ~PX_VC_OUTCALL_ABORTING;
            pVc->Flags |= PX_VC_OUTCALL_ABORTED;
        } else if (pVc->Flags & PX_VC_INCALL_ABORTING) {
            pVc->Flags &= ~PX_VC_INCALL_ABORTING;
            pVc->Flags |= PX_VC_INCALL_ABORTED;
        }

        pVc->PrevState = pVc->State;
        pVc->State = PX_VC_IDLE;

        pClAf = pVc->ClAf;

        SendTapiCallState(pVc, 
                          LINECALLSTATE_DISCONNECTED, 
                          0, 
                          pVc->CallInfo->ulMediaMode);

        if (pVc->Flags & PX_VC_DROP_PENDING) {
            PxTapiCompleteDropIrps(pVc, Status);
        }

        //
        // Remove the ref applied when this call
        // became connected with the call manager
        // (NdisClMakeCall/PxClIncomingCall).
        // We don't need to do the full deref code 
        // here as the ref applied when we mapped 
        // the vc will keep the vc around!
        //
        pVc->RefCount--;

    } while (FALSE);

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);
}


VOID
PxClAddPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    ASSERT(0);
}

VOID
PxClDropPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext
    )
{
    ASSERT(0);
}

NDIS_STATUS
PxClIncomingCall(
    IN NDIS_HANDLE              ProtocolSapContext,
    IN NDIS_HANDLE              ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParams
    )
{
    PPX_VC      pVc;
    PPX_CL_SAP  pClSap;
    PPX_CL_AF   pClAf;
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClIncomingCall: Sap %p VcCtx %x\n", 
         ProtocolSapContext, ProtocolVcContext));

    pClSap = (PPX_CL_SAP)ProtocolSapContext;

    if (pClSap->State != PX_SAP_OPENED) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCall: Invalid SapState Sap %p State %x\n", 
             pClSap, pClSap->State));

        return (NDIS_STATUS_FAILURE);
    }

    pClAf = pClSap->ClAf;

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCall: pVc invalid %x\n", ProtocolVcContext));

        return (NDIS_STATUS_FAILURE);
    }

    Status =
        (*pClAf->AfGetTapiCallParams)(pVc, pCallParams);

    if (Status != NDIS_STATUS_SUCCESS) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCall: pVc invalid %x\n", ProtocolVcContext));

        return (Status);
    }

    NdisAcquireSpinLock(&pVc->Lock);

    // The algorithim for computing a unique "htCall" is to start
    // at the value 1, and perpetually increment by 2.  Keeping
    // the low bit set will allow the user-mode TAPI component
    // we talk to to distinguish between these incoming call handles
    // and outgoing call handles, the latter of which will always
    // have the low bit zero'd (since they're really pointers to heap).
    //
    // In <= NT 4.0, valid values used to range between 0x80000000
    // and 0xffffffff, as we relied on the fact that user-mode
    // addresses always had the low bit zero'd.  (Not a valid
    // assumption anymore!)
    //

    pVc->htCall = 
        InterlockedExchangeAdd((PLONG)&TspCB.htCall, 2);

    //
    // This ref is applied for the indication to
    // tapi of a new call.  The ref will be removed
    // when tapi closes the call in PxTapiCloseCall.
    //
    REF_VC(pVc);

    //
    // This ref is applied for the connection
    // between the proxy and the call manager.
    // The ref will be removed in either 
    // PxClCloseCallComplete or PxVcCleanup
    // in the case where the offered call is
    // dropped by the client.
    //
    REF_VC(pVc);

    SendTapiNewCall(pVc, 
                    pVc->hdCall, 
                    pVc->htCall, 
                    0);

    SendTapiCallState(pVc, 
                      LINECALLSTATE_OFFERING, 
                      0, 
                      pVc->CallInfo->ulMediaMode);

    pVc->PrevState = pVc->State;
    pVc->State = PX_VC_OFFERING;

    PxStartIncomingCallTimeout(pVc);

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (NDIS_STATUS_PENDING);
}

VOID
PxClIncomingCallQosChange(
    IN NDIS_HANDLE          ProtocolVcContext,
    IN PCO_CALL_PARAMETERS  pCallParams
    )
{

}


VOID
PxClIncomingCloseCall(
    IN NDIS_STATUS  CloseStatus,
    IN NDIS_HANDLE  ProtocolVcContext,
    IN PVOID        CloseData OPTIONAL,
    IN UINT         Size OPTIONAL
    )
{
    PPX_VC      pVc;
    PPX_CL_AF   pClAf;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClIncomingCloseCall: VcCtx %x\n", ProtocolVcContext));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCloseCall: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    pVc->CloseFlags |= PX_VC_INCOMING_CLOSE;

    PxVcCleanup(pVc, PX_VC_CLEANUP_CM);

    //
    // remove the ref applied when we
    // mapped the ctx to the vc at entry
    //
    DEREF_VC_LOCKED(pVc);

}

VOID
PxClIncomingDropParty(
    IN NDIS_STATUS  DropStatus,
    IN NDIS_HANDLE  ProtocolPartyContext,
    IN PVOID        CloseData OPTIONAL,
    IN UINT         Size OPTIONAL
    )
{
    ASSERT(0);
}

VOID
PxClCallConnected(
    IN NDIS_HANDLE ProtocolVcContext
    )
{
    PPX_VC  pVc;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCallConnected: VcCtx %x\n", ProtocolVcContext));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCallConnected: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCallConnected: pVc %p, State %x\n", pVc, pVc->State));

    if (pVc->State == PX_VC_CONNECTED) {

        SendTapiCallState(pVc, 
                          LINECALLSTATE_CONNECTED, 
                          0, 
                          pVc->CallInfo->ulMediaMode);
    }

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP(PXD_LOUD, PXM_CL, ("PxClCallConnected: Exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxntinit.c ===
/*++                    

Copyright (c) 1995  Microsoft Corporation

Module Name:

pxntinit.c

Abstract:

The module contains the NT-specific init code forthe NDIS Proxy.

Author:

Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------

    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/

#include "ntddk.h"
//#include <cxport.h>
#include <precomp.h>

#define MODULE_NUMBER MODULE_NTINIT
#define _FILENUMBER 'NITN'

PPX_DEVICE_EXTENSION    DeviceExtension;
NPAGED_LOOKASIDE_LIST   ProviderEventLookaside;
NPAGED_LOOKASIDE_LIST   VcLookaside;
TAPI_TSP_CB             TspCB;
VC_TABLE                VcTable;
TAPI_LINE_TABLE         LineTable;
TSP_EVENT_LIST          TspEventList;

//
// Local funcion prototypes
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PxIOCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PxIOClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PxIODispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PxIOCleanup(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
PxCancelGetEvents(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#endif // ALLOC_PRAGMA

//
// Tapi OIDs that the Proxy supports
//
OID_DISPATCH TapiOids[] =
{
    {OID_TAPI_ACCEPT,sizeof (NDIS_TAPI_ACCEPT), PxTapiAccept},
    {OID_TAPI_ANSWER, sizeof (NDIS_TAPI_ANSWER), PxTapiAnswer},
    {OID_TAPI_CLOSE, sizeof (NDIS_TAPI_CLOSE), PxTapiClose},
    {OID_TAPI_CLOSE_CALL, sizeof (NDIS_TAPI_CLOSE_CALL), PxTapiCloseCall},
    {OID_TAPI_CONDITIONAL_MEDIA_DETECTION, sizeof (NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION), PxTapiConditionalMediaDetection},
    {OID_TAPI_CONFIG_DIALOG, sizeof (NDIS_TAPI_CONFIG_DIALOG), PxTapiConfigDialog},
    {OID_TAPI_DEV_SPECIFIC, sizeof (NDIS_TAPI_DEV_SPECIFIC), PxTapiDevSpecific},
    {OID_TAPI_DIAL, sizeof (NDIS_TAPI_DIAL), PxTapiDial},
    {OID_TAPI_DROP, sizeof (NDIS_TAPI_DROP), PxTapiDrop},
    {OID_TAPI_GET_ADDRESS_CAPS, sizeof (NDIS_TAPI_GET_ADDRESS_CAPS), PxTapiGetAddressCaps},
    {OID_TAPI_GET_ADDRESS_ID, sizeof (NDIS_TAPI_GET_ADDRESS_ID), PxTapiGetAddressID},
    {OID_TAPI_GET_ADDRESS_STATUS, sizeof (NDIS_TAPI_GET_ADDRESS_STATUS), PxTapiGetAddressStatus},
    {OID_TAPI_GET_CALL_ADDRESS_ID, sizeof (NDIS_TAPI_GET_CALL_ADDRESS_ID), PxTapiGetCallAddressID},
    {OID_TAPI_GET_CALL_INFO, sizeof (NDIS_TAPI_GET_CALL_INFO), PxTapiGetCallInfo},
    {OID_TAPI_GET_CALL_STATUS, sizeof (NDIS_TAPI_GET_CALL_STATUS), PxTapiGetCallStatus},
    {OID_TAPI_GET_DEV_CAPS, sizeof (NDIS_TAPI_GET_DEV_CAPS), PxTapiGetDevCaps},
    {OID_TAPI_GET_DEV_CONFIG, sizeof (NDIS_TAPI_GET_DEV_CONFIG), PxTapiGetDevConfig},
    {OID_TAPI_GET_EXTENSION_ID, sizeof (NDIS_TAPI_GET_EXTENSION_ID), PxTapiGetExtensionID},
    {OID_TAPI_GET_ID, sizeof (NDIS_TAPI_GET_ID), PxTapiLineGetID},
    {OID_TAPI_GET_LINE_DEV_STATUS, sizeof (NDIS_TAPI_GET_LINE_DEV_STATUS), PxTapiGetLineDevStatus},
    {OID_TAPI_MAKE_CALL, sizeof (NDIS_TAPI_MAKE_CALL), PxTapiMakeCall},
    {OID_TAPI_NEGOTIATE_EXT_VERSION, sizeof (NDIS_TAPI_NEGOTIATE_EXT_VERSION), PxTapiNegotiateExtVersion},
    {OID_TAPI_OPEN, sizeof (NDIS_TAPI_OPEN) + sizeof(NDISTAPI_OPENDATA), PxTapiOpen},
    {OID_TAPI_PROVIDER_INITIALIZE, sizeof (NDIS_TAPI_PROVIDER_INITIALIZE), PxTapiProviderInit},
    {OID_TAPI_PROVIDER_SHUTDOWN, sizeof (NDIS_TAPI_PROVIDER_SHUTDOWN), PxTapiProviderShutdown},
    {OID_TAPI_SECURE_CALL, sizeof (NDIS_TAPI_SECURE_CALL), PxTapiSecureCall},
    {OID_TAPI_SELECT_EXT_VERSION, sizeof (NDIS_TAPI_SELECT_EXT_VERSION), PxTapiSelectExtVersion},
    {OID_TAPI_SEND_USER_USER_INFO, sizeof (NDIS_TAPI_SEND_USER_USER_INFO), PxTapiSendUserUserInfo},
    {OID_TAPI_SET_APP_SPECIFIC, sizeof (NDIS_TAPI_SET_APP_SPECIFIC), PxTapiSetAppSpecific},
    {OID_TAPI_SET_CALL_PARAMS, sizeof (NDIS_TAPI_SET_CALL_PARAMS), PxTapiSetCallParams},
    {OID_TAPI_SET_DEFAULT_MEDIA_DETECTION, sizeof (NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION), PxTapiSetDefaultMediaDetection},
    {OID_TAPI_SET_DEV_CONFIG, sizeof (NDIS_TAPI_SET_DEV_CONFIG), PxTapiSetDevConfig},
    {OID_TAPI_SET_MEDIA_MODE, sizeof (NDIS_TAPI_SET_MEDIA_MODE), PxTapiSetMediaMode},
    {OID_TAPI_SET_STATUS_MESSAGES, sizeof (NDIS_TAPI_SET_STATUS_MESSAGES), PxTapiSetStatusMessages},
    {OID_TAPI_GATHER_DIGITS, sizeof (NDIS_TAPI_GATHER_DIGITS), PxTapiGatherDigits},
    {OID_TAPI_MONITOR_DIGITS, sizeof (NDIS_TAPI_MONITOR_DIGITS), PxTapiMonitorDigits}
};

//
// TAPI OIDs that do not map to NDIS5, and are passed-through to CallManagers:
//

#define MAX_TAPI_SUPPORTED_OIDS     (sizeof(TapiOids)/sizeof(OID_DISPATCH))

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Initialization routine for the NDIS Proxy.

Arguments:

    DriverObject    - Pointer to the driver object created by the system.
    RegistryPath    - Points to global registry path

Return Value:

    The final status from the initialization operation.

--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      deviceName;
    USHORT              i;
    UINT                initStatus;
    PDEVICE_OBJECT      DeviceObject;
    ULONG               SizeNeeded;

    PXDEBUGP(PXD_INFO, PXM_INIT, ("NDIS Proxy DriverEntry; built %s, %s\n", __DATE__, __TIME__));

    ExInitializeNPagedLookasideList(&ProviderEventLookaside,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(PROVIDER_EVENT),
                                    PX_EVENT_TAG,
                                    0);

    ExInitializeNPagedLookasideList(&VcLookaside,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(PX_VC),
                                    PX_VC_TAG,
                                    0);

    NdisZeroMemory(&TspCB, sizeof(TspCB));
    NdisZeroMemory(&TspEventList, sizeof(TspEventList));
    NdisZeroMemory(&VcTable, sizeof(VcTable));
    NdisZeroMemory(&LineTable, sizeof(LineTable));

    //
    // Create the device objects. IoCreateDevice zeroes the memory
    // occupied by the object.
    //
    RtlInitUnicodeString(&deviceName, DD_PROXY_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject,
                            sizeof (PX_DEVICE_EXTENSION),
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            0,
                            FALSE,
                            &DeviceObject);

    if(!NT_SUCCESS(Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize the driver object
    //
    DeviceExtension =
        (PPX_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    NdisZeroMemory(DeviceExtension,
                  sizeof (PX_DEVICE_EXTENSION));

    DeviceExtension->pDriverObject = DriverObject;
    NdisAllocateSpinLock(&DeviceExtension->Lock);
    InitializeListHead(&DeviceExtension->AdapterList);

    GetRegistryParameters (RegistryPath);

    NdisAllocateSpinLock(&TspCB.Lock);
    TspCB.Status             = NDISTAPI_STATUS_DISCONNECTED;
    TspCB.NdisTapiNumDevices = 0;
    TspCB.htCall             = 1;
    InitializeListHead(&TspCB.ProviderList);

    NdisAllocateSpinLock(&TspEventList.Lock);
    InitializeListHead(&TspEventList.List);

    //
    // Intialize the VcTable
    //
    NdisInitializeReadWriteLock(&VcTable.Lock);
    VcTable.Size = VC_TABLE_SIZE;
    InitializeListHead(&VcTable.List);

    SizeNeeded = (VC_TABLE_SIZE * sizeof(PPX_VC));

    PxAllocMem(VcTable.Table, SizeNeeded, PX_VCTABLE_TAG);

    if (VcTable.Table == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_INIT, ("DriverEntry: ExAllocPool for VcTable\n"));

        Status = STATUS_UNSUCCESSFUL;

        goto DriverEntry_err;
    }

    NdisZeroMemory(VcTable.Table, SizeNeeded);

    //
    // Initialize the LineTable
    //
    NdisInitializeReadWriteLock(&LineTable.Lock);
    LineTable.Size = LINE_TABLE_SIZE;
    SizeNeeded = (LINE_TABLE_SIZE * sizeof(PPX_TAPI_LINE));

    PxAllocMem(LineTable.Table, SizeNeeded, PX_LINETABLE_TAG);

    if (LineTable.Table == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_INIT, ("DriverEntry: ExAllocPool for VcTable\n"));

        Status = STATUS_UNSUCCESSFUL;

        goto DriverEntry_err;
    }

    NdisZeroMemory(LineTable.Table, SizeNeeded);

    DeviceExtension->pDeviceObject  = DeviceObject;

    DriverObject->DriverUnload                          = PxUnload;
    DriverObject->FastIoDispatch                        = NULL;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = PxIOCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = PxIOClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = PxIODispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = PxIOCleanup;

    //
    // Intialize the device objects.
    //
    DeviceObject->Flags |= DO_DIRECT_IO;
    DeviceExtension->pDeviceObject = DeviceObject;

    //
    // Finally, initialize the stack.
    //
    initStatus = InitNDISProxy();

    if (initStatus == TRUE) {
        return(STATUS_SUCCESS);
    }

DriverEntry_err:

    Status = STATUS_UNSUCCESSFUL;

    while (!(IsListEmpty(&TspEventList.List))) {
        PPROVIDER_EVENT ProviderEvent;

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&TspEventList.List);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
    }

    if (VcTable.Table != NULL) {
        PxFreeMem(VcTable.Table);
        VcTable.Table = NULL;
    }

    if (LineTable.Table != NULL) {
        PxFreeMem(LineTable.Table);
        LineTable.Table = NULL;
    }

    if(DeviceObject != NULL) {
        IoDeleteDevice(DeviceObject);
        DeviceExtension->pDeviceObject = NULL;
    }

    ExDeleteNPagedLookasideList(&ProviderEventLookaside);
    ExDeleteNPagedLookasideList(&VcLookaside);

    return(Status);
}

VOID
PxUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/

{
    PXDEBUGP(PXD_LOUD, PXM_INIT, ("PxUnload: enter\n"));

    //
    // Call our unload handler
    //
    PxCoUnloadProtocol();

    NdisAcquireSpinLock(&TspEventList.Lock);

    while (!(IsListEmpty(&TspEventList.List))) {
        PPROVIDER_EVENT ProviderEvent;

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&TspEventList.List);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
    }

    NdisReleaseSpinLock(&TspEventList.Lock);

    ExDeleteNPagedLookasideList(&ProviderEventLookaside);
    ExDeleteNPagedLookasideList(&VcLookaside);

    if (DeviceExtension->pDeviceObject != NULL) {
        IoDeleteDevice (DeviceExtension->pDeviceObject);
    }

    //
    // Free Vc table memory
    //
    ASSERT(VcTable.Count == 0);
    PxFreeMem(VcTable.Table);

    //
    // Free the allocated tapi resources
    // (TapiProviders, TapiLines, TapiAddrs)
    //
    NdisAcquireSpinLock(&TspCB.Lock);

    while (!IsListEmpty(&TspCB.ProviderList)) {
        PPX_TAPI_PROVIDER    tp;

        tp = (PPX_TAPI_PROVIDER)
            RemoveHeadList(&TspCB.ProviderList);

        NdisReleaseSpinLock(&TspCB.Lock);

        FreeTapiProvider(tp);

        NdisAcquireSpinLock(&TspCB.Lock);
    }

    NdisReleaseSpinLock(&TspCB.Lock);

    NdisFreeSpinLock(&TspCB.Lock);

    //
    // Free the line table
    //
    ASSERT(LineTable.Count == 0);
    PxFreeMem(LineTable.Table);


    NdisFreeSpinLock(&(DeviceExtension->Lock));

    PXDEBUGP (PXD_LOUD, PXM_INIT, ("PxUnload: exit\n"));
}

NTSTATUS
PxIOCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PXDEBUGP(PXD_LOUD, PXM_INIT, ("IRP_MJ_CREATE, Irp=%p", Irp));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}

NTSTATUS
PxIOClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPX_TAPI_PROVIDER   Provider;

    PXDEBUGP(PXD_LOUD, PXM_INIT, ("IRP_MJ_CLOSE, Entry\n"));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}


NTSTATUS
PxIODispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the generic dispatch routine for the Proxy. Irps come from the
    usermode TSP component.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

  NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    ULONG               ioControlCode;
    ULONG               InfoSize = 0;
    NTSTATUS            ntStatus = STATUS_PENDING;
    PIO_STACK_LOCATION  IrpStack;
    ULONG               RequestId;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get the pointer to the input/output buffer and its length
    //
    ioBuffer =
        Irp->AssociatedIrp.SystemBuffer;

    inputBufferLength =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    outputBufferLength =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if ((IrpStack->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (DeviceObject != DeviceExtension->pDeviceObject)) {

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }

    ioControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

//    PxAssert((ioControlCode & (METHOD_BUFFERED | METHOD_IN_DIRECT | METHOD_OUT_DIRECT | METHOD_NEITHER)) == METHOD_BUFFERED);

    switch(ioControlCode)
    {
        case IOCTL_NDISTAPI_CONNECT:
        {
            PPX_TAPI_PROVIDER   Provider;

            PXDEBUGP(PXD_INFO, PXM_INIT, ("IOCTL_NDISTAPI_CONNECT, Irp=%p\n", Irp));

            //
            // Someone's connecting. Make sure they passed us a valid
            // info buffer.
            //
            if ((inputBufferLength < 2*sizeof(ULONG)) ||
                (outputBufferLength < sizeof(ULONG))) {
                PXDEBUGP (PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_CONNECT: buffer too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            NdisAcquireSpinLock(&TspCB.Lock);

            //
            // Return the number of line devs
            //
            PxAssert(outputBufferLength >= sizeof(ULONG));

            *((ULONG *) ioBuffer)= TspCB.NdisTapiNumDevices;

            TspCB.Status = NDISTAPI_STATUS_CONNECTED;

            Provider = (PPX_TAPI_PROVIDER)TspCB.ProviderList.Flink;

            while ((PVOID)Provider != (PVOID)&TspCB.ProviderList) {

                NdisAcquireSpinLock(&Provider->Lock);

                if (Provider->Status == PROVIDER_STATUS_ONLINE) {

                    MarkProviderConnected(Provider);
                }
                NdisReleaseSpinLock(&Provider->Lock);

                Provider = (PPX_TAPI_PROVIDER)Provider->Linkage.Flink;
            }

            ntStatus = STATUS_SUCCESS;
            InfoSize = sizeof (ULONG);

            NdisReleaseSpinLock(&TspCB.Lock);

            break;
        }

        case IOCTL_NDISTAPI_DISCONNECT:
        {
            PPX_TAPI_PROVIDER   Provider;

            NdisAcquireSpinLock(&TspCB.Lock);

            //
            // If no one is talking then set state to
            // disconnected.
            //
            TspCB.Status = NDISTAPI_STATUS_DISCONNECTING;

            Provider = (PPX_TAPI_PROVIDER)TspCB.ProviderList.Flink;

            while ((PVOID)Provider != (PVOID)&TspCB.ProviderList) {

                NdisAcquireSpinLock(&Provider->Lock);

                if (Provider->Status == PROVIDER_STATUS_ONLINE) {
                    MarkProviderDisconnected(Provider);
                }

                NdisReleaseSpinLock(&Provider->Lock);

                Provider = 
                    (PPX_TAPI_PROVIDER)Provider->Linkage.Flink;
            }

            NdisReleaseSpinLock (&TspCB.Lock);

            ntStatus = STATUS_SUCCESS;
            InfoSize = 0;

            break;
        }

        case IOCTL_NDISTAPI_QUERY_INFO:
        case IOCTL_NDISTAPI_SET_INFO:
        {
            ULONG               targetDeviceID;
            NDIS_STATUS         ndisStatus = NDIS_STATUS_SUCCESS;
            NDIS_HANDLE         providerHandle = NULL;
            PNDISTAPI_REQUEST   ndisTapiRequest;
            KIRQL               oldIrql;
            KIRQL               cancelIrql;
            PPX_TAPI_LINE       TapiLine = NULL;
            INT                 n=0;
            PKDEVICE_QUEUE_ENTRY    packet;

            //
            // All the following OIDs come in here as query/set IOCTls:
            //Init
            //Accept
            //Answer
            //Close
            //CloseCall
            //ConditionalMediaDetection
            //ConfigDialog
            //DevSpecific
            //Dial
            //Drop
            //GetAddressCaps
            //GetAddressID
            //GetAddressStatus
            //GetCallAddressID
            //GetCallInfo
            //GetCallStatus
            //GetDevCaps
            //GetDevConfig
            //GetExtensionID
            //GetID
            //GetLineDevStatus
            //MakeCall
            //NegotiateExtVersion
            //Open
            //ProviderInitialize
            //ProviderShutdown
            //SecureCall
            //SelectExtVersion
            //SendUserUserInfo
            //SetAppSpecific
            //SetCallParams
            //SetDefaultMediaDetection
            //SetDevConfig
            //SetMediaMode
            //SetStatusMessages
            //

            //
            // Verify we're connected, then check the device ID of the
            // incoming request against our list of online devices
            //

            //
            // Something other then pending was returned so complete
            // the irp
            //

            if (inputBufferLength < sizeof (NDISTAPI_REQUEST) ||
                outputBufferLength < sizeof(NDISTAPI_REQUEST)) {
                PXDEBUGP(PXD_WARNING, PXM_INIT,  ("IOCTL_SET/QUERY: Invalid BufferLength! len %d needed %d\n",
                inputBufferLength, sizeof(NDISTAPI_REQUEST)));

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            ndisTapiRequest = ioBuffer;

            targetDeviceID = ndisTapiRequest->ulDeviceID;

            InfoSize = sizeof(NDISTAPI_REQUEST);

            PXDEBUGP(PXD_LOUD, PXM_INIT, (
                           "NdisTapiRequest: Irp: %p Oid: %x, devID: %d, reqID: %x\n",
                           Irp,
                           ndisTapiRequest->Oid,
                           ndisTapiRequest->ulDeviceID,
                           *((ULONG *)ndisTapiRequest->Data)));

            n = ndisTapiRequest->Oid - OID_TAPI_ACCEPT;

            if (n > MAX_TAPI_SUPPORTED_OIDS) {
                PXDEBUGP(PXD_WARNING,PXM_INIT, ("IOCTL_SET/QUERY: Invalid OID %x index %d\n",
                ndisTapiRequest->Oid, n));

                ndisTapiRequest->ulReturnValue = NDIS_STATUS_TAPI_INVALPARAM;
                ntStatus = STATUS_SUCCESS;
                break; // out of switch
            }

            //
            // defensive check that data buffer size is not bad
            //
            if (ndisTapiRequest->ulDataSize < TapiOids[n].SizeofStruct) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_SET/QUERY: Invalid BufferLength2! len %d needed %d\n",
                    ndisTapiRequest->ulDataSize, TapiOids[n].SizeofStruct));
                ndisTapiRequest->ulReturnValue  = NDIS_STATUS_TAPI_STRUCTURETOOSMALL;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            //
            //  Make sure the IRP contained sufficient data.
            //
            if (ndisTapiRequest->ulDataSize >
                inputBufferLength - FIELD_OFFSET(NDISTAPI_REQUEST, Data[0])) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_SET/QUERY: Invalid BufferLength3! len %d needed %d\n",
                    ndisTapiRequest->ulDataSize, inputBufferLength - FIELD_OFFSET(NDISTAPI_REQUEST, Data[0])));
                ndisTapiRequest->ulReturnValue  = NDIS_STATUS_TAPI_STRUCTURETOOSMALL;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            NdisAcquireSpinLock (&TspCB.Lock);

            //
            // Are we initialized with TAPI?
            //
            if (TspCB.Status != NDISTAPI_STATUS_CONNECTED) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("TAPI not connected, returning err\n"));

                NdisReleaseSpinLock(&TspCB.Lock);

                ndisTapiRequest->ulReturnValue = NDISTAPIERR_UNINITIALIZED;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            //
            // Get a unique ID for this request -- value between 1 and fffffffe.
            // (Can't use the TAPI ID in case it's spoofed)
            //

            if (++TspCB.ulUniqueId > 0xfffffffe) {
                TspCB.ulUniqueId = 0x80000001;
            }

            RequestId =
            ndisTapiRequest->ulUniqueRequestId =
                TspCB.ulUniqueId;

            ndisTapiRequest->Irp = Irp;

            NdisReleaseSpinLock (&TspCB.Lock);

            //
            // Mark the TAPI request pending
            //
            IoMarkIrpPending(Irp);
            ntStatus = STATUS_PENDING;

            //
            // Dispatch the request
            //
            ndisStatus =
                (*TapiOids[n].FuncPtr)(ndisTapiRequest);

            if (ndisStatus == NDIS_STATUS_PENDING) {

                PXDEBUGP (PXD_LOUD, PXM_INIT, ("IOCTL_TAPI_SET/QUERY_INFO: reqProc returning PENDING\n" ));

                return (STATUS_PENDING);
            }

            //
            // Something other then pending was returned so complete
            // the irp
            //
            InfoSize = MIN (outputBufferLength,
                            sizeof(NDISTAPI_REQUEST)+ndisTapiRequest->ulDataSize);
            //
            // Set the TAPI return status
            //
            ndisTapiRequest->ulReturnValue = ndisStatus;

            IoSetCancelRoutine(Irp, NULL);

            ntStatus = STATUS_SUCCESS;

            break;
        }

        case IOCTL_NDISTAPI_GET_LINE_EVENTS:
        {
            KIRQL   oldIrql;
            KIRQL   cancelIrql;
            PNDISTAPI_EVENT_DATA    ndisTapiEventData = ioBuffer;

            PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS\n"));

            //
            // Defensive check that the input buffer is at least
            // the size of the request,
            // and that we can move at least one event
            //
            if (inputBufferLength < sizeof (NDISTAPI_EVENT_DATA)) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                InfoSize = sizeof (ULONG);
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS: buffer too small\n"));
                break;
            }

            if (outputBufferLength - sizeof(NDISTAPI_EVENT_DATA) + 1 <  ndisTapiEventData->ulTotalSize) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                InfoSize = sizeof (ULONG);
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS: buffer too small\n"));
                break;
            }

            //
            // Sync event buf access by acquiring EventSpinLock
            //
            NdisAcquireSpinLock(&TspEventList.Lock);

            //
            // Is there any data available?
            //
            if (TspEventList.Count != 0) {
                //
                // There's line event data queued in our ring buffer. Grab as
                // much as we can & complete the request.
                //
                PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, 
                         ("IOCTL_NDISTAPI_GET_LINE_EVENTS: event count = x%x, IoBuffer->TotalSize = %x\n", 
                          TspEventList.Count, ndisTapiEventData->ulTotalSize));

                ndisTapiEventData->ulUsedSize =
                    GetLineEvents(ndisTapiEventData->Data,
                                  ndisTapiEventData->ulTotalSize);

                ntStatus = STATUS_SUCCESS;
                InfoSize =
                    MIN (outputBufferLength, ((ndisTapiEventData->ulUsedSize) + sizeof(NDISTAPI_EVENT_DATA) - 1));

            } else {
                PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS: no events in queue\n"));

                //
                // Hold the request pending.  It remains in the cancelable
                // state.  When new line event input is received or generated (i.e.
                // LINEDEVSTATE_REINIT) the data will get copied & the
                // request completed.
                //

                if (NULL == TspEventList.RequestIrp) {

                    IoSetCancelRoutine (Irp, PxCancelGetEvents);

                    IoMarkIrpPending (Irp);

                    Irp->IoStatus.Status = STATUS_PENDING;

                    Irp->IoStatus.Information = 0;

                    TspEventList.RequestIrp = Irp;

                    ntStatus = STATUS_PENDING;

                } else {
                    ntStatus = STATUS_UNSUCCESSFUL;
                    InfoSize = sizeof (ULONG);
                }
            }

            NdisReleaseSpinLock(&TspEventList.Lock);

            break;
        }

        case IOCTL_NDISTAPI_SET_DEVICEID_BASE:
        {
            ULONG   BaseId;

            PXDEBUGP(PXD_INFO, PXM_INIT, ("IOCTL_NDISTAPI_SET_DEVICEID_BASE, Irp=x%x, inputBufLen = %x\n", Irp, inputBufferLength ));

            //
            // Someone's connecting. Make sure they passed us a valid
            // info buffer
            //
            if ((inputBufferLength < sizeof(ULONG))) {
                PXDEBUGP (PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_SET_DEVICEID_BASE: buffer too small\n"));

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            NdisAcquireSpinLock(&TspCB.Lock);

            if (TspCB.Status != NDISTAPI_STATUS_CONNECTED) {
                PXDEBUGP (PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_SET_DEVICEID_BASE: Disconnected\n"));
                ntStatus = STATUS_UNSUCCESSFUL;
                NdisReleaseSpinLock(&TspCB.Lock);
                break;
            }

            //
            // Set the base ID
            //
            BaseId = *((ULONG *) ioBuffer);

            PXDEBUGP(PXD_LOUD, PXM_INIT, ("BaseID %d\n", BaseId));

            NdisReleaseSpinLock(&TspCB.Lock);

            {
                LOCK_STATE      LockState;
                ULONG           i;

                //
                // Update the deviceId's for each line on the provider
                //
                NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

                for (i = 0; i < LineTable.Size; i++) {
                    PPX_TAPI_LINE   TapiLine;

                    TapiLine = LineTable.Table[i];

                    if ((TapiLine != NULL)) {

                        TapiLine->ulDeviceID = BaseId++;
                    }
                }

                NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
            }

            InfoSize = 0;
            ntStatus = STATUS_SUCCESS;
            break;
        }

        case IOCTL_NDISTAPI_CREATE:
        {
            PPX_TAPI_PROVIDER       Provider;
            PNDISTAPI_CREATE_INFO   CreateInfo;
            PPX_TAPI_LINE           TapiLine;

            InfoSize = 0;

            if (inputBufferLength < sizeof(CreateInfo)) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_CREATE: buffer too small\n"));

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            CreateInfo = (PNDISTAPI_CREATE_INFO)ioBuffer;

            if (!IsTapiLineValid(CreateInfo->TempID, &TapiLine)) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, 
                         ("IOCTL_NDISTAPI_CREATE: Failed to find Id %d\n",
                          CreateInfo->TempID));
                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            PXDEBUGP(PXD_LOUD, PXM_INIT, 
                     ("IOCTL_NDISTAPI_CREATE: Created new Line %p Id %d\n",
                      TapiLine, CreateInfo->DeviceID));

            TapiLine->ulDeviceID = CreateInfo->DeviceID;

            ntStatus = STATUS_SUCCESS;

            break;
        }

        default:

            ntStatus = STATUS_INVALID_PARAMETER;

            PXDEBUGP(PXD_WARNING, PXM_INIT, ("unknown IRP_MJ_DEVICE_CONTROL\n"));

            break;

    } // switch

    //
    // Complete this IRP synchronously if we are done.
    //
    if (ntStatus != STATUS_PENDING) {
        PIO_STACK_LOCATION  IrpSp;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = InfoSize;
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        IrpSp->Control &= ~SL_PENDING_RETURNED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, ("PxDispatch: Completing Irp %p (Status %x) synchronously\n", Irp, ntStatus));


    return ntStatus;
}

NTSTATUS
PxIOCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All requests queued are completed with STATUS_CANCELLED.

Arguments:

    DeviceObject - Pointer to device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIRP    MyIrp;

    PXDEBUGP(PXD_LOUD, PXM_INIT, ("PxIOCleanup: enter\n"));

    NdisAcquireSpinLock (&TspEventList.Lock);

    //
    // Cancel the EventRequest Irp
    //
    MyIrp = TspEventList.RequestIrp;

    if ((MyIrp != NULL) &&
        (MyIrp->Tail.Overlay.OriginalFileObject == 
         Irp->Tail.Overlay.OriginalFileObject)) {

        if (IoSetCancelRoutine(MyIrp, NULL) != NULL) {
            TspEventList.RequestIrp = NULL;
            MyIrp->IoStatus.Status = STATUS_CANCELLED;
            MyIrp->IoStatus.Information = 0;
            NdisReleaseSpinLock(&TspEventList.Lock);
            IoCompleteRequest(MyIrp, IO_NO_INCREMENT);
            NdisAcquireSpinLock(&TspEventList.Lock);
        }
    }

    //
    // Cancel any Set/Query Irp's
    //

    NdisReleaseSpinLock(&TspEventList.Lock);

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    PXDEBUGP (PXD_LOUD, PXM_INIT, ("PxIOCleanup: exit\n"));

    return(STATUS_SUCCESS);
}

VOID
PxCancelGetEvents(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIRP    MyIrp;

    PXDEBUGP(PXD_LOUD, PXM_INIT, 
             ("PxCancelGetEvents: enter. Irp = %x\n", Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the EventSpinLock & check to see if we're canceling a
    // pending get-events Irp
    //
    NdisAcquireSpinLock (&TspEventList.Lock);

    MyIrp = TspEventList.RequestIrp;
    TspEventList.RequestIrp = NULL;

    NdisReleaseSpinLock(&TspEventList.Lock);

    if (MyIrp != NULL) {

        ASSERT(MyIrp == Irp);

        //
        // Don't let it get cancelled again
        //
        IoSetCancelRoutine (MyIrp, NULL);

        MyIrp->IoStatus.Status = STATUS_CANCELLED;
        MyIrp->IoStatus.Information = 0;

        IoCompleteRequest (MyIrp, IO_NO_INCREMENT);
    }
}

VOID
PxCancelSetQuery(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    BOOLEAN Found = FALSE;
    LOCK_STATE  LockState;
    PPX_VC  pVc;
    PIRP    MyIrp;

    PXDEBUGP(PXD_LOUD, PXM_INIT, 
             ("PxCancelSetQuery: enter. Irp = %x\n", Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // We must search through the Vc's in the Vc table
    // and find the pending ndisrequest!
    //
    NdisAcquireReadWriteLock(&VcTable.Lock, FALSE, &LockState);

    pVc = (PPX_VC)VcTable.List.Flink;

    while ((PVOID)pVc != (PVOID)&VcTable.List) {
        PLIST_ENTRY         Entry;
        PNDISTAPI_REQUEST   Request;

        NdisAcquireSpinLock(&pVc->Lock);

        Entry = pVc->PendingDropReqs.Flink;

        while (Entry != &pVc->PendingDropReqs) {

            Request = 
                CONTAINING_RECORD(Entry, NDISTAPI_REQUEST, Linkage);

            MyIrp = Request->Irp;

            if (MyIrp->Cancel) {
                Found = TRUE;
                RemoveEntryList(&Request->Linkage);
                break;
            }

            Entry = Entry->Flink;
        }

        if (!Found) {
            if (pVc->PendingGatherDigits != NULL) {
                PNDISTAPI_REQUEST   Request;

                Request = pVc->PendingGatherDigits;
                MyIrp = Request->Irp;

                if (MyIrp->Cancel) {
                    Found = TRUE;
                    pVc->PendingGatherDigits = NULL;
                }
            }
        }

        NdisReleaseSpinLock(&pVc->Lock);

        if (Found) {
            break;
        }

        pVc = (PPX_VC)pVc->Linkage.Flink;
    }

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    if (Found) {

        //
        // Don't let it get cancelled again
        //
        IoSetCancelRoutine (MyIrp, NULL);
        MyIrp->IoStatus.Status = STATUS_CANCELLED;
        MyIrp->IoStatus.Information = 0;

        IoCompleteRequest (MyIrp, IO_NO_INCREMENT);
    }

    PXDEBUGP(PXD_INFO, PXM_INIT, ("PxIOCancel: completing Irp=%p\n", Irp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxtapi.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pxtapi.c

Abstract:

    The module contains the TAPI-specific code for the NDIS Proxy.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    RMachin     01-08-97    created (after Dan Knudson's NdisTapi)
    TonyBe      02-21-99    re-work/re-write

Notes:

--*/

#include <precomp.h>
#include <stdio.h>
#define MODULE_NUMBER MODULE_TAPI
#define _FILENUMBER 'IPAT'

ULONG
GetLineEvents(
    PCHAR   EventBuffer,
    ULONG   BufferSize
    )

/*++

Routine Description:

  Gets event data out of our global event queue and writes it to the buffer. Data is put into the queue
  by PxIndicateStatus (above).


Arguments:

    EventBuffer     pointer to a buffer of size BufferSize
    BufferSize      size of event buffer (expected to be 1024)

Return Value:



Note:

    Assumes TspEventList.Lock held by caller.

--*/

{
    ULONG   BytesLeft;
    ULONG   BytesMoved = 0;

    BytesLeft = BufferSize;

    while (!(IsListEmpty(&TspEventList.List))) {

        PPROVIDER_EVENT ProviderEvent;

        if (BytesLeft < sizeof(NDIS_TAPI_EVENT)) {
            break;
        }

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&TspEventList.List);

        TspEventList.Count--;

        RtlMoveMemory(EventBuffer + BytesMoved,
                      (PUCHAR)&ProviderEvent->Event,
                      sizeof(NDIS_TAPI_EVENT));

        BytesMoved += sizeof(NDIS_TAPI_EVENT);
        BytesLeft -= sizeof(NDIS_TAPI_EVENT);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside,
                                    ProviderEvent);
    }

    return (BytesMoved);
}

NDIS_STATUS
PxTapiMakeCall(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    TSPI_lineMakeCall handler.

Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_MAKE_CALL    TapiBuffer =
        (PNDIS_TAPI_MAKE_CALL)(pNdisTapiRequest->Data);

    LINE_CALL_PARAMS*       pTapiCallParams =
        (LINE_CALL_PARAMS*)(&TapiBuffer->LineCallParams);

    PPX_TAPI_LINE           TapiLine;
    PPX_TAPI_ADDR           TapiAddr;
    PPX_VC                  pVc = NULL;
    PPX_CL_AF               pClAf;
    PCO_CALL_PARAMETERS     pNdisCallParams = 0;
    NDIS_STATUS             Status  = NDIS_STATUS_SUCCESS;
    ULONG                   targetDeviceID = 0;
    LPCWSTR                 lpcwszTemp;
    PPX_ADAPTER             pAdapter;
    PPX_TAPI_PROVIDER       TapiProvider;

    lpcwszTemp = (LPWSTR)
        (((UCHAR *) TapiBuffer) + TapiBuffer->ulDestAddressOffset);

    PXDEBUGP(PXD_TAPI, PXM_TAPI, 
             ("TapiMakeCall: DialAddress in Tapi buffer %x = %ls\n",lpcwszTemp, lpcwszTemp));

    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {

        PXDEBUGP (PXD_WARNING, PXM_TAPI, 
                  ("PxTapiMakeCall: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->hdLine));

        return (NDISTAPIERR_BADDEVICEID);
    }

    do {

        NdisAcquireSpinLock(&TapiLine->Lock);

        //
        // Is this line in service? (does it have an valid af?)
        //
        if (!(TapiLine->DevStatus->ulDevStatusFlags & 
              LINEDEVSTATUSFLAGS_INSERVICE)) {
            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiMakeCall: Line not in service!\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);
            Status = NDISTAPIERR_DEVICEOFFLINE;
            break;
        }

        PXDEBUGP (PXD_TAPI, PXM_TAPI,
            ("PxTapiMakeCall: got device x%x from ID %d\n", TapiLine, TapiBuffer->hdLine));

        if (pTapiCallParams->ulAddressMode == LINEADDRESSMODE_ADDRESSID) {

            //
            // Get the specificed address from the address id
            //
            if (!IsAddressValid(TapiLine, pTapiCallParams->ulAddressID, &TapiAddr)) {
                Status = NDISTAPIERR_BADDEVICEID;
                NdisReleaseSpinLock(&TapiLine->Lock);
                break;
            }

        } else {

            //
            // Get the first available address
            //
            TapiAddr =
                GetAvailAddrFromLine(TapiLine);

            if (TapiAddr == NULL) {
                Status = NDISTAPIERR_BADDEVICEID;
                NdisReleaseSpinLock(&TapiLine->Lock);
                break;
            }
        }

        TapiProvider = TapiLine->TapiProvider;
        pAdapter = TapiProvider->Adapter;
        pClAf = TapiLine->ClAf;

        NdisReleaseSpinLock(&TapiLine->Lock);

        NdisAcquireSpinLock(&pClAf->Lock);

        //
        // Allocate a Vc block.  This will create the block
        // with refcount = 1.
        //
        pVc = PxAllocateVc(pClAf);

        if (pVc == NULL) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI, ("PxTapiMakeCall: failed to allocate a vc\n"));
            NdisReleaseSpinLock(&pClAf->Lock);
            Status = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
            break;
        }

        NdisReleaseSpinLock(&pClAf->Lock);

        Status =
            AllocateTapiCallInfo(pVc, NULL);

        if (Status != NDIS_STATUS_SUCCESS) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI, ("PxTapiMakeCall: Error allocating TapiCallInfo!\n"));
            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
            break;
        }

        pVc->TapiLine = TapiLine;
        pVc->TapiAddr = TapiAddr;
        InterlockedIncrement((PLONG)&TapiAddr->CallCount);
        InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

        pVc->htCall = TapiBuffer->htCall;

        pVc->CallInfo->ulLineDeviceID = TapiLine->CmLineID;
        pVc->CallInfo->ulAddressID = TapiAddr->AddrId;
        pVc->CallInfo->ulOrigin = LINECALLORIGIN_OUTBOUND;

        //
        // Set up intended bearer and media mode
        //
        pVc->CallInfo->ulBearerMode =
            pTapiCallParams->ulBearerMode;

        pVc->CallInfo->ulMediaMode =
            pTapiCallParams->ulMediaMode;

        if (pTapiCallParams->ulMaxRate == 0) {

            pVc->CallInfo->ulRate =
                TapiLine->DevCaps->ulMaxRate;

        } else {

            pVc->CallInfo->ulRate =
                pTapiCallParams->ulMaxRate;
        }

        if (!InsertVcInTable(pVc)) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI,
                ("PxTapiMakeCall: failed to insert in vc table\n"));

            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
            break;
        }

        //
        // Our call handle is an index into the call table
        //
        TapiBuffer->hdCall = (HDRV_CALL)pVc->hdCall;

        Status = NdisCoCreateVc(pAdapter->ClBindingHandle,
                                pClAf->NdisAfHandle,
                                (NDIS_HANDLE)pVc->hdCall,
                                &pVc->ClVcHandle);


        if (Status != NDIS_STATUS_SUCCESS) {
            RemoveVcFromTable(pVc);
            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_CALLUNAVAIL;
            break;
        }

        //
        // Move (AF-specific) call parameters into  NdisCallParams structure
        //
        Status =
            (*pClAf->AfGetNdisCallParams)(pVc,
                                          TapiLine->CmLineID,
                                          TapiAddr->AddrId,
                                          CO_TAPI_FLAG_OUTGOING_CALL,
                                          TapiBuffer,
                                          &pNdisCallParams);

        if (Status != NDIS_STATUS_SUCCESS) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI,
                ("PxTapiMakeCall: failed to move call params: Status %x\n", Status));

            NdisCoDeleteVc(pVc->ClVcHandle);
            RemoveVcFromTable(pVc);
            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_INVALCALLPARAMS;
            break;
        }

        // Store Call Params for when lineGetID dispatches an incoming call...
        //
        NdisAcquireSpinLock(&pVc->Lock);

        pVc->pCallParameters = pNdisCallParams;
        pVc->PrevState = pVc->State;
        pVc->State = PX_VC_PROCEEDING;
        pVc->Flags |= PX_VC_OWNER;

        //
        // Ref applied ndis part of the make call.  
        // This ref is removed in PxClCloseCallComplete or 
        // PxClMakeCallComplete in the case of a make call
        // failure.
        //
        REF_VC(pVc);

        //
        // Indicate call state change to TAPI
        //
        SendTapiCallState(pVc, 
                          LINECALLSTATE_PROCEEDING, 
                          0, 
                          pVc->CallInfo->ulMediaMode);

        NdisReleaseSpinLock(&pVc->Lock);

        Status =
            NdisClMakeCall(pVc->ClVcHandle,
                           pVc->pCallParameters,
                           NULL,
                           NULL);

        if (Status != NDIS_STATUS_PENDING) {

            PxClMakeCallComplete(Status,
                                 (NDIS_HANDLE)pVc->hdCall,
                                 NULL,
                                 pVc->pCallParameters);
        }

        Status = NDIS_STATUS_SUCCESS;

    } // end of do loop

    while (FALSE);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiMakeCall: exit Status %x\n", Status));

    DEREF_TAPILINE(TapiLine);

    return Status;
}

NDIS_STATUS
PxTapiGetDevCaps(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Stick the appropriate device info into the request buffer.

    Arguments:

    Request -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PPX_TAPI_LINE   TapiLine = NULL;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PNDIS_TAPI_GET_DEV_CAPS pNdisTapiGetDevCaps =
        (PNDIS_TAPI_GET_DEV_CAPS) pNdisTapiRequest->Data;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevCaps: enter\n"));

    if (!IsTapiDeviceValid(pNdisTapiGetDevCaps->ulDeviceID, &TapiLine)) {
        PXDEBUGP (PXD_WARNING, PXM_TAPI,
            ( "PxTapiGetDevCaps: NDISTAPIERR_BADDEVICEID: line = %x\n",
            pNdisTapiGetDevCaps->ulDeviceID));
        return(NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    do {

        ULONG   SizeDevCaps;
        ULONG   DevClassesSize = 0;
        USHORT  DevClassesList[512];
        WCHAR   LineName[128];
        ULONG   LineNameSize;
        WCHAR   ProviderInfo[128];
        ULONG   ProviderInfoSize;
        PLINE_DEV_CAPS  ldc;
        PPX_ADAPTER ClAdapter;
        ULONG   SizeToMove;
        LONG    SizeLeft;
        PUCHAR  dst;
        ULONG   TotalSize;

        //
        // Synchronously get dev caps for this device
        //

        ClAdapter = TapiLine->TapiProvider->Adapter;

        ldc = TapiLine->DevCaps;

        SizeDevCaps = ldc->ulUsedSize;

        //
        // Add some space for our providerinfo if needed
        //
        if (ldc->ulProviderInfoSize == 0) {

            NdisZeroMemory(ProviderInfo, sizeof(ProviderInfo));

            ProviderInfoSize = wcslen(L"NDPROXY") * sizeof(WCHAR);

            NdisMoveMemory((PUCHAR)ProviderInfo, 
                           L"NDPROXY", 
                           ProviderInfoSize);

            //
            // For NULL termination
            //
            ProviderInfoSize += sizeof(UNICODE_NULL);

            SizeDevCaps += ProviderInfoSize;
        }

        //
        // Add some space for our linename if needed
        //
        if ((ldc->ulLineNameSize == 0) &&
            (ClAdapter != NULL) &&
            (ClAdapter->MediaNameLength != 0)) {
            PUCHAR  dst;

            NdisZeroMemory(LineName, sizeof(LineName));

            dst = (PUCHAR)LineName;

            NdisMoveMemory(dst,
                           (PUCHAR)(ClAdapter->MediaName),
                           ClAdapter->MediaNameLength);

            (ULONG_PTR)dst += ClAdapter->MediaNameLength;

            //
            // ToDo! Shoud get the name of the adapter
            // and insert here!
            //

            NdisMoveMemory(dst,
                           L" - Line",
                           wcslen(L" - Line") * sizeof(WCHAR));

            (ULONG_PTR)dst += 
                wcslen(L" - Line") * sizeof(WCHAR);

            (VOID)
            IntegerToWChar(TapiLine->CmLineID,
                          -4,
                          (WCHAR *)dst);

            (ULONG_PTR)dst += 4 * sizeof(WCHAR);

            LineNameSize = (ULONG)((ULONG_PTR)dst - (ULONG_PTR)LineName);

            //
            // For NULL termination
            //
            LineNameSize += sizeof(UNICODE_NULL);

            SizeDevCaps += LineNameSize;
        }

        //
        // Add some space for our device classes
        //
        DevClassesSize = sizeof(DevClassesList);
        NdisZeroMemory((PUCHAR)DevClassesList, 
                       sizeof(DevClassesList));

        if (ClAdapter != NULL) {
            GetAllDevClasses(ClAdapter,
                             DevClassesList,
                             &DevClassesSize);
        }

        SizeDevCaps += DevClassesSize;

        ldc = &pNdisTapiGetDevCaps->LineDevCaps;

        SizeToMove = (TapiLine->DevCaps->ulUsedSize > ldc->ulTotalSize) ?
            ldc->ulTotalSize : TapiLine->DevCaps->ulUsedSize;

        SizeLeft = ldc->ulTotalSize - SizeToMove;

        //
        // Save the total size
        //
        TotalSize = ldc->ulTotalSize;

        PXDEBUGP(PXD_TAPI, PXM_TAPI,
                 ("PxTapiGetDevCaps: got device %x from ID %d: moving %d bytes\n",
                  TapiLine,
                  pNdisTapiGetDevCaps->ulDeviceID,
                  SizeToMove));

        NdisMoveMemory((PUCHAR)ldc,
                       (PUCHAR)TapiLine->DevCaps,
                       SizeToMove);

        ldc->ulNeededSize = SizeDevCaps;
        ldc->ulTotalSize = TotalSize;
        ldc->ulUsedSize = SizeToMove;

        if (SizeLeft > 0) {

            //
            // If there is no provider info fill our proxy info
            //
            if (ldc->ulProviderInfoSize == 0) {

                dst = (PUCHAR)ldc + ldc->ulUsedSize;

                SizeToMove = (SizeLeft > (LONG)ProviderInfoSize) ?
                    ProviderInfoSize : SizeLeft;

                NdisMoveMemory(dst,
                               (PUCHAR)ProviderInfo,
                               SizeToMove);

                ldc->ulProviderInfoSize = SizeToMove;
                ldc->ulProviderInfoOffset = (ULONG)((ULONG_PTR)dst-(ULONG_PTR)ldc);
                ldc->ulUsedSize += SizeToMove;

                SizeLeft -= SizeToMove;
            }
        }

        if (SizeLeft > 0) {
            //
            // If these is no line name fill in our line name
            //
            if (ldc->ulLineNameSize == 0 &&
                ClAdapter != NULL &&
                ClAdapter->MediaNameLength != 0) {

                dst = (PUCHAR)ldc + ldc->ulUsedSize;

                SizeToMove = (SizeLeft > (LONG)LineNameSize) ?
                    LineNameSize : SizeLeft;

                NdisMoveMemory(dst,
                               (PUCHAR)LineName,
                               SizeToMove);

                ldc->ulLineNameSize = SizeToMove;
                ldc->ulLineNameOffset = (ULONG)((ULONG_PTR)dst-(ULONG_PTR)ldc);
                ldc->ulUsedSize += SizeToMove;

                SizeLeft -= SizeToMove;
            }
        }

        if (SizeLeft > 0) {
            //
            // Add the devclasses to the end
            //
            if (DevClassesSize > 0) {

                dst = (PUCHAR)ldc + ldc->ulUsedSize;

                SizeToMove = (SizeLeft > (LONG)DevClassesSize) ?
                    DevClassesSize : SizeLeft;

                NdisMoveMemory(dst,
                               DevClassesList,
                               SizeToMove);

                ldc->ulDeviceClassesSize = SizeToMove;
                ldc->ulDeviceClassesOffset = (ULONG)((ULONG_PTR)dst-(ULONG_PTR)ldc);
                ldc->ulUsedSize += SizeToMove;

                SizeLeft -= SizeToMove;
            }
        }

    } while (FALSE);

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevCaps: exit: used=%d, needed=%d, total=%d\n",
        pNdisTapiGetDevCaps->LineDevCaps.ulUsedSize,
        pNdisTapiGetDevCaps->LineDevCaps.ulNeededSize,
        pNdisTapiGetDevCaps->LineDevCaps.ulTotalSize));

    return (Status);
}

NDIS_STATUS
PxTapiAccept(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiAccept: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiAccept: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiAnswer(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_ANSWER   pNdisTapiAnswer;
    PPX_VC              pVc = NULL;
    NDIS_STATUS         Status;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiAnswer: enter\n"));

    pNdisTapiAnswer =
        (PNDIS_TAPI_ANSWER)pNdisTapiRequest->Data;

    if (!IsVcValid(pNdisTapiAnswer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiAnswer: pVc invalid call handle %d\n",
                               pNdisTapiAnswer->hdCall));

        return(NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    NdisAcquireSpinLock(&pVc->Lock);

    do {

        if (pVc->State != PX_VC_OFFERING) {

            //
            // call in wrong state
            //
            PXDEBUGP(PXD_FATAL, PXM_TAPI, ("PxTapiAnswer: pVc VC %x/%x invalid state %x\n",
                        pVc, pVc->Flags,
                        pVc->ulCallState));

            NdisReleaseSpinLock(&pVc->Lock);

            Status = NDIS_STATUS_TAPI_INVALCALLSTATE;

            break;
        }

        if (pVc->Flags & PX_VC_CALLTIMER_STARTED) {
            PxStopIncomingCallTimeout(pVc);
        }

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
            ("PxTapiAnswer: calling NdisClIncomingCallComplete\n"));

        pVc->PrevState = pVc->State;
        pVc->State = PX_VC_CONNECTED;

        NdisReleaseSpinLock(&pVc->Lock);

        NdisClIncomingCallComplete (NDIS_STATUS_SUCCESS,
                                    pVc->ClVcHandle,
                                    pVc->pCallParameters);
    } while (FALSE);

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC(pVc);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiAnswer: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiLineGetID(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

Returns a handle to the client wich is returned to the tapi application.  
This handle is only meaning full to the client and will vary depending
on the deviceclass.

Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_ID   pNdisTapiGetId =
        (PNDIS_TAPI_GET_ID)pNdisTapiRequest->Data;

    PVAR_STRING         DeviceID = &pNdisTapiGetId->DeviceID;
    PPX_VC              pVc = NULL;
    NDIS_HANDLE         VcHandle = NULL;
    PPX_CM_AF           pCmAf;
    PPX_CM_SAP          pCmSap;
    NDIS_STATUS         Status;
    LPCWSTR             DevClass;
    ULONG               DevClassSize;
    PPX_ADAPTER         pAdapter;

    DevClass =
        (LPCWSTR)(((CHAR *)pNdisTapiGetId) + pNdisTapiGetId->ulDeviceClassOffset);

    DevClassSize = pNdisTapiGetId->ulDeviceClassSize;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiLineGetID: enter. CallId %x, DevClass = %ls\n", pNdisTapiGetId->hdCall, DevClass));

    if (pNdisTapiGetId->ulSelect != LINECALLSELECT_CALL) {
        return (NDIS_STATUS_FAILURE);
    }

    //
    // validate call handle and get call pointer
    //
    if (!IsVcValid(pNdisTapiGetId->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxNdisTapiGetId: pVc invalid call handle %d\n",
                               pNdisTapiGetId->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    do {
        //
        // ToDo!
        //
        // If we already are working with a client
        // we need to see if this is a mapping to the same
        // client or to a different one.  If it is to the
        // same one just return the current handle.  If it
        // is to a different one we should either fail or
        // tear the vc hand-off down from the current client
        // and then hand-off to the new client.
        //
        if (pVc->CmVcHandle != NULL) {

            Status = NDIS_STATUS_SUCCESS;

            break;
        }

        if (pVc->State != PX_VC_CONNECTED) {
            Status = NDIS_STATUS_TAPI_INVALCALLSTATE;
            break;
        }

        pAdapter = pVc->Adapter;

        //
        // Find the sap/af of the client that we need to indicate this on
        //
        if (!PxAfAndSapFromDevClass(pAdapter, 
                                    DevClass, 
                                    &pCmAf, 
                                    &pCmSap)) {

            PXDEBUGP(PXD_WARNING, PXM_TAPI,
                ("PxTapiLineGetID: SAP not found!\n"));

            Status = NDIS_STATUS_FAILURE;

            break;
        }

        pVc->HandoffState = PX_VC_HANDOFF_OFFERING;
        pVc->CmAf = pCmAf;
        pVc->CmSap = pCmSap;

        VcHandle = pVc->ClVcHandle;

        NdisReleaseSpinLock(&pVc->Lock);

        //
        // Create the Vc
        //
        Status = NdisCoCreateVc(pAdapter->CmBindingHandle,
                                pCmAf->NdisAfHandle,
                                (NDIS_HANDLE)pVc->hdCall,
                                &VcHandle);

        if (Status != NDIS_STATUS_SUCCESS) {

            PXDEBUGP(PXD_WARNING, PXM_TAPI,
                ("PxTapiLineGetID: Client refused Vc CmAf %p DevClass %ls Status %x\n",
                pCmAf, DevClass, Status));

            Status = NDIS_STATUS_FAILURE;

            //
            // remove ref that was applied when we mapped the devclass
            // to an af/sap.
            //
            DEREF_CM_AF(pCmAf);

            NdisAcquireSpinLock(&pVc->Lock);

            pVc->HandoffState = PX_VC_HANDOFF_IDLE;

            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        pVc->CmVcHandle = VcHandle;

        //
        // Apply a reference on the vc for 
        // activating this call with the client.
        // This ref is removed in PxCmCloseCall.
        //
        REF_VC(pVc);

        NdisReleaseSpinLock(&pVc->Lock);

        //
        // Dispatch the incoming call to the client
        //
        Status = 
            NdisCmDispatchIncomingCall(pCmSap->NdisSapHandle,
                                       pVc->CmVcHandle,
                                       pVc->pCallParameters);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pVc->Block);
        }

        if (Status != NDIS_STATUS_SUCCESS) {
            //
            // The client did not except the call
            // delete the vc and go away.
            //
            PXDEBUGP(PXD_WARNING, PXM_TAPI,
                ("PxTapiLineGetID: Client rejected call VC %p, Status %x\n", 
                 pVc, Status));

#ifdef CODELETEVC_FIXED
            //
            // Evidently the CoCreateVc is unbalanced
            // when creating a proxy vc.  The call to 
            // NdisCoDeleteVc will fail because the
            // Vc is still active.
            // ToDo! Investigate this with ndis
            //
            Status =
                NdisCoDeleteVc(pVc->CmVcHandle);

#endif
            //
            // remove ref that was applied when we mapped the devclass
            // to an af/sap.
            //
            DEREF_CM_AF(pCmAf);

            NdisAcquireSpinLock(&pVc->Lock);

#ifdef CODELETEVC_FIXED
            if (Status == NDIS_STATUS_SUCCESS) {
                pVc->CmVcHandle = NULL;
            }
#endif

            pVc->HandoffState = PX_VC_HANDOFF_IDLE;

            //
            // Remove the reference we applied before
            // dispatching incoming call to client.  
            // We do not need to do all of the deref code 
            // because of the ref applied at entry to 
            // this function
            //
            pVc->RefCount--;

            break;
        }

        NdisCmDispatchCallConnected(pVc->CmVcHandle);

        NdisAcquireSpinLock(&pVc->Lock);

        //
        // If we are still in the offering state
        // we can safely move to connected at this 
        // point.  We might not be in offering if
        // right after we connected the client
        // did an NdisClCloseCall before we could
        // reacquire the spinlock.
        //
        if (pVc->HandoffState == PX_VC_HANDOFF_OFFERING) {
            pVc->HandoffState = PX_VC_HANDOFF_CONNECTED;
        }

    } while (FALSE);

    //
    // If we get here and we are not in the connected
    // state something happened to tear our call
    // down with the client.  This could have been
    // an error attempting to create the call with the
    // client or we received either a
    // tapidrop from tapi
    // incomingclosecall from cm
    //
    if (pVc->State != PX_VC_CONNECTED) {

        Status =
            PxCloseCallWithCl(pVc);

        if ((Status != NDIS_STATUS_PENDING) &&
            (pVc->Flags & PX_VC_CLEANUP_CM)) {
            PxCloseCallWithCm(pVc);
        }

        Status = NDIS_STATUS_FAILURE;

    } else if (Status == NDIS_STATUS_SUCCESS) {

        Status = NdisCoGetTapiCallId(pVc->CmVcHandle,
                                     DeviceID);
        //
        // ToDo?: If status is failure here, do we need to do anything? In our
        //          case this should be OK, because the TSP ensures the size of 
        //          the VAR_STRING is right, and that's the only thing that can 
        //          cause a failure. 
        //
    }

    PXDEBUGP(PXD_LOUD, PXM_TAPI,
        ("PxTapiLineGetID: Vc %p, Status %x\n", pVc, Status));

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return Status;
}

NDIS_STATUS
PxTapiClose (
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI is closing it's handle to our device. We shouldn't see any further requests or
    send any TAPI events after completing this function.

    In the current design, we are the sole owner of all VCs (i.e. there are no 'pass-through' or monitor-only
    functions in the Proxy). TAPI should not call this func before all calls have been closed and all apps
    have disconnected.

   NOTE: this function is also called by TAPI after we send it a LINE_REMOVE message, indicating that
   the adapter has been unbound. In this case, too, we should already have closed all calls/freed VCs and
   associated structures.

    Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_CLOSE    pTapiClose =
        (PNDIS_TAPI_CLOSE)pNdisTapiRequest->Data;

    PPX_TAPI_LINE       TapiLine;
    PPX_VC              pVc;
    PPX_TAPI_PROVIDER   TapiProvider;
    PPX_CL_SAP          pClSap;
    PPX_CL_AF           pClAf;
    NDIS_STATUS         Status;


    PXDEBUGP(PXD_TAPI, PXM_TAPI, 
             ("PxTapiClose: ID: %d\n", pTapiClose->hdLine));

    //
    // validate line handle and get line pointer
    //
    if (!IsTapiLineValid((ULONG)pTapiClose->hdLine, &TapiLine)) {
        PXDEBUGP (PXD_WARNING, PXM_TAPI, ("PxTapiClose: NDISTAPIERR_BADDEVICEID: line = %x\n", pTapiClose->hdLine));
        return (NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    TapiLine->DevStatus->ulNumOpens--;

    if (TapiLine->DevStatus->ulNumOpens != 0) {
        NdisReleaseSpinLock(&TapiLine->Lock);
        return (NDIS_STATUS_SUCCESS);
    }

    pClAf = TapiLine->ClAf;
    pClSap = TapiLine->ClSap;
    TapiLine->ClSap = NULL;

    TapiLine->DevStatus->ulOpenMediaModes = 0;

    NdisReleaseSpinLock(&TapiLine->Lock);

    //
    // If we have any active Vc's on this line we need
    // tear them down.
    //
    if (pClAf != NULL) {
        NdisAcquireSpinLock(&pClAf->Lock);

        REF_CL_AF(pClAf);

#if 0
        while (!IsListEmpty(&pClAf->VcList)) {
            PLIST_ENTRY         Entry;
            PPX_VC              pActiveVc;

            Entry = RemoveHeadList(&pClAf->VcList);

            InsertHeadList(&pClAf->VcClosingList, Entry);

            pActiveVc = 
                CONTAINING_RECORD(Entry, PX_VC, ClAfLinkage);

            NdisReleaseSpinLock(&pClAf->Lock);

            NdisAcquireSpinLock(&pActiveVc->Lock);

            if (!(pActiveVc->CloseFlags & PX_VC_TAPI_CLOSE)) {

                REF_VC(pActiveVc);

                pActiveVc->CloseFlags |= PX_VC_TAPI_CLOSE;

                PxVcCleanup(pActiveVc, 0);

                PxTapiCompleteAllIrps(pActiveVc, NDIS_STATUS_SUCCESS);

                //
                // Remove the ref applied in the make call or call offering
                // indication.  We do not need the full deref code because
                // of the ref applied at entry.
                //
                pActiveVc->RefCount--;

                DEREF_VC_LOCKED(pActiveVc);
            }

            NdisAcquireSpinLock(&pClAf->Lock);
        }
#endif
        //
        // If we have a sap registered on this line we need
        // to close it.
        //
        if (pClSap != NULL) {

            // If the SAP is opened then we need to close it
            if (pClSap->State == PX_SAP_OPENED) {

                RemoveEntryList(&pClSap->Linkage);

                InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

                NdisReleaseSpinLock(&pClAf->Lock);

                InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

                Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

                if (Status != NDIS_STATUS_PENDING) {
                    PxClDeregisterSapComplete(Status, pClSap);
                }

                NdisAcquireSpinLock(&pClAf->Lock);
            }

        }

        DEREF_CL_AF_LOCKED(pClAf);
    }

    DEREF_TAPILINE(TapiLine);

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiCloseCall(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

     for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    NDIS_STATUS     Status;
    PNDIS_TAPI_CLOSE_CALL pNdisTapiCloseCall =
        (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequest->Data;

    PPX_VC              pVc;
    PPX_TAPI_LINE       TapiLine;


    if (!IsVcValid(pNdisTapiCloseCall->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiCloseCall: invalid call handle %d\n",
                               pNdisTapiCloseCall->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    PXDEBUGP (PXD_TAPI, PXM_TAPI, 
              ("PxTapiCloseCall: enter. VC = %x, State = %x\n", 
               pVc, pVc->State));

    NdisAcquireSpinLock(&pVc->Lock);

    pVc->CloseFlags |= PX_VC_TAPI_CLOSECALL;

    //
    // Check the Vc state and act accordingly
    //
    PxVcCleanup(pVc, 0);

    PxTapiCompleteAllIrps(pVc, NDIS_STATUS_SUCCESS);

    //
    // Remove the ref applied in the make call or call offering
    // indication.  We do not need the full deref code because
    // of the ref applied at entry.
    //
    pVc->RefCount--;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiCloseCall: exit.\n"));

    return (NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxTapiConditionalMediaDetection(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConditionalMediaDetection: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConditionalMediaDetection: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiConfigDialog (
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConfigDialog: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConfigDialog: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiDevSpecific(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    D for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDevSpecific: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDevSpecific: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiDial(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDial: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDial: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiDrop(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

   Drop the call without deallocating the VC.

Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PPX_VC          pVc;
    PIRP            Irp;

    PNDIS_TAPI_DROP pNdisTapiDrop =
        (PNDIS_TAPI_DROP)pNdisTapiRequest->Data;

    if (!IsVcValid(pNdisTapiDrop->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiDrop: invalid call handle %d\n",
                               pNdisTapiDrop->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    PXDEBUGP(PXD_TAPI, PXM_TAPI, 
             ("PxTapiDrop enter: Vc: %p VcState: %x CallState: %x\n", pVc, pVc->State, pVc->ulCallState ));

    NdisAcquireSpinLock(&pVc->Lock);

    Irp = pNdisTapiRequest->Irp;

    IoSetCancelRoutine(Irp, PxCancelSetQuery);

    //
    // Insert the request in the Vc's pending list
    //
    InsertTailList(&pVc->PendingDropReqs, 
                   &pNdisTapiRequest->Linkage);

    pVc->CloseFlags |= PX_VC_TAPI_DROP;

    //
    // Check the Vc state and act accordingly
    //
    Status = 
        PxVcCleanup(pVc, PX_VC_DROP_PENDING);

    if (Status != NDIS_STATUS_PENDING) {
        RemoveEntryList(&pNdisTapiRequest->Linkage);
        IoSetCancelRoutine(Irp, NULL);
    }

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (Status);
}

NDIS_STATUS
PxTapiGetAddressCaps(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_ADDRESS_CAPS pNdisTapiGetAddressCaps =
        (PNDIS_TAPI_GET_ADDRESS_CAPS) pNdisTapiRequest->Data;
    PPX_TAPI_LINE   TapiLine;
    PPX_TAPI_ADDR   TapiAddr;
    PPX_ADAPTER     ClAdapter;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    if (!IsTapiDeviceValid(pNdisTapiRequest->ulDeviceID, &TapiLine)) {
        PXDEBUGP (PXD_WARNING, PXM_TAPI, ( "PxTapiGetAddressCaps: NDISTAPIERR_BADDEVICEID: line = %x\n", pNdisTapiRequest->ulDeviceID));
        return (NDISTAPIERR_BADDEVICEID);
    }

    PXDEBUGP(PXD_TAPI, PXM_TAPI,
            ("PxTapiGetAddressCaps: got device %p from ID %d\n",
            TapiLine, pNdisTapiRequest->ulDeviceID));

    NdisAcquireSpinLock(&TapiLine->Lock);

    do {
        ULONG   DevClassesSize = 0;
        USHORT  DevClassesList[512];
        ULONG   SizeToMove;
        ULONG   TotalSize;
        ULONG   SizeLeft;
        PLINE_ADDRESS_CAPS In, Out;


        //
        // Get the tapi address that we are interested in
        //
        if (!IsAddressValid(TapiLine,
                            pNdisTapiGetAddressCaps->ulAddressID,
                            &TapiAddr)) {

            Status = NDIS_STATUS_TAPI_INVALADDRESSID;
            break;
        }

        In = TapiAddr->Caps;
        Out = &pNdisTapiGetAddressCaps->LineAddressCaps;

        //
        // Add some space for our device classes
        //
        DevClassesSize = sizeof(DevClassesList);
        NdisZeroMemory((PUCHAR)DevClassesList, 
                       sizeof(DevClassesList));

        if (TapiLine->TapiProvider->Adapter != NULL) {
            GetAllDevClasses(TapiLine->TapiProvider->Adapter,
                             DevClassesList,
                             &DevClassesSize);
        }

        //
        // Synchronously get Address caps for this device
        //
        SizeToMove = (In->ulUsedSize > Out->ulTotalSize) ?
            Out->ulTotalSize : In->ulUsedSize;

        TotalSize = Out->ulTotalSize;

        NdisMoveMemory((PUCHAR)Out, (PUCHAR)In, SizeToMove);

        SizeLeft = 
            TotalSize - SizeToMove;

        Out->ulTotalSize = TotalSize;
        Out->ulUsedSize = SizeToMove;
        Out->ulNeededSize = 
            In->ulUsedSize + DevClassesSize;

        if (SizeLeft > 0) {
            //
            // If these is room fill in our devclasses
            //
            if (DevClassesSize > 0) {
                PUCHAR  dst;

                dst = (PUCHAR)Out + Out->ulUsedSize;

                SizeToMove = (SizeLeft > DevClassesSize) ?
                    DevClassesSize : SizeLeft;

                NdisMoveMemory(dst, DevClassesList, SizeToMove);
                Out->ulDeviceClassesSize = SizeToMove;
                Out->ulDeviceClassesOffset =
                    (ULONG)((ULONG_PTR)dst - (ULONG_PTR)Out);
                Out->ulUsedSize += SizeToMove;
                SizeLeft -= SizeToMove;
            }
        }

    } while (FALSE);

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiGetAddressCaps: exit. \n"));

    return (Status);
}

NDIS_STATUS
PxTapiGetAddressID(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_ADDRESS_ID TapiBuffer =
        (PNDIS_TAPI_GET_ADDRESS_ID) pNdisTapiRequest->Data;
    PPX_TAPI_LINE   TapiLine;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressID: enter\n"));

    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetAddressID: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->hdLine));
        return(NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    //
    // ToDo!
    //
    TapiBuffer->ulAddressID = 0;

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressID: exit\n"));

    return (NDIS_STATUS_SUCCESS);

}

NDIS_STATUS
PxTapiGetAddressStatus(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressStatus: enter\n"));

    //
    // ToDo!
    //
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressStatus: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);

}

NDIS_STATUS
PxTapiGetCallAddressID(
    IN    PNDISTAPI_REQUEST       pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_CALL_ADDRESS_ID TapiBuffer =
        (PNDIS_TAPI_GET_CALL_ADDRESS_ID)pNdisTapiRequest->Data;

    PPX_VC              pVc;

    if (!IsVcValid(TapiBuffer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetCallAddressID: invalid call handle %d\n",
                               TapiBuffer->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetCallAddressID: Vc: %p\n", pVc));

    NdisAcquireSpinLock(&pVc->Lock);

    TapiBuffer->ulAddressID = pVc->TapiAddr->AddrId;

    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetCallAddressID: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiGetCallInfo(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_CALL_INFO TapiBuffer =
        (PNDIS_TAPI_GET_CALL_INFO)pNdisTapiRequest->Data;

    PPX_VC          pVc;
    PPX_TAPI_LINE   TapiLine;
    LINE_CALL_INFO* CallInfo;
    LINE_CALL_INFO* OutCallInfo = &TapiBuffer->LineCallInfo;
    ULONG           VarDataSize = 0;    // Total available
    ULONG           VarDataUsed = 0;

    if (!IsVcValid(TapiBuffer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetCallInfo: invalid call handle %d\n",
                               TapiBuffer->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    // 
    // Make sure we have enough space to copy everything over
    //
    CallInfo = pVc->CallInfo;
    TapiLine = pVc->TapiLine;

    VarDataSize = 
        pNdisTapiRequest->ulDataSize - sizeof(NDIS_TAPI_GET_CALL_INFO);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, 
              ("PxTapiGetCallInfo: enter. pVc = %p, AvailSize = %x, needed = %x\n", 
               pVc, OutCallInfo->ulTotalSize,  CallInfo->ulUsedSize));

    OutCallInfo->ulNeededSize = CallInfo->ulUsedSize;

    //
    // Patch up the Id here.  We store it in our callinfo
    // block in terms of the call managers 0 based Id.  We
    // need to give tapi the Id it is looking for which is
    // stored in the tapiline.
    //
    OutCallInfo->ulLineDeviceID = TapiLine->ulDeviceID;

    OutCallInfo->ulAddressID = CallInfo->ulAddressID;

    OutCallInfo->ulBearerMode = CallInfo->ulBearerMode;

    OutCallInfo->ulRate = CallInfo->ulRate;

    OutCallInfo->ulMediaMode = CallInfo->ulMediaMode;

    OutCallInfo->ulAppSpecific = CallInfo->ulAppSpecific;
    OutCallInfo->ulCallID = 0;
    OutCallInfo->ulRelatedCallID = 0;
    OutCallInfo->ulCallParamFlags = 0;

    OutCallInfo->DialParams.ulDialPause = 0;
    OutCallInfo->DialParams.ulDialSpeed = 0;
    OutCallInfo->DialParams.ulDigitDuration = 0;
    OutCallInfo->DialParams.ulWaitForDialtone = 0;

    OutCallInfo->ulReason = CallInfo->ulReason;
    OutCallInfo->ulCompletionID = 0;

    OutCallInfo->ulCountryCode = 0;
    OutCallInfo->ulTrunk = (ULONG)-1;

    //
    // Do the CallerID
    //
    if (CallInfo->ulCallerIDSize) {

        if (((VarDataUsed + CallInfo->ulCallerIDSize) <= VarDataSize) &&
            ((CallInfo->ulCallerIDOffset + CallInfo->ulCallerIDSize) <= CallInfo->ulUsedSize)) {

            OutCallInfo->ulCallerIDSize = CallInfo->ulCallerIDSize;
            OutCallInfo->ulCallerIDFlags = CallInfo->ulCallerIDFlags;
            OutCallInfo->ulCallerIDOffset = sizeof (LINE_CALL_INFO) + VarDataUsed;
            NdisMoveMemory ( (PUCHAR)(OutCallInfo)+OutCallInfo->ulCallerIDOffset,
                             (PUCHAR)(CallInfo)+CallInfo->ulCallerIDOffset,
                             CallInfo->ulCallerIDSize);

            VarDataUsed +=  CallInfo->ulCallerIDSize;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_CALLERID;
        }
    } else {

        OutCallInfo->ulCallerIDFlags = LINECALLPARTYID_UNAVAIL;
        OutCallInfo->ulCallerIDSize = 0;
        OutCallInfo->ulCallerIDOffset = 0;
    }

    OutCallInfo->ulCallerIDNameSize = 0;
    OutCallInfo->ulCallerIDNameOffset = 0;

    //
    // Do the CalledID
    //
    if (CallInfo->ulCalledIDSize) {
        if (((VarDataUsed + CallInfo->ulCalledIDSize) <= VarDataSize) &&
            ((CallInfo->ulCalledIDOffset + CallInfo->ulCalledIDSize) <= CallInfo->ulUsedSize)) {

            OutCallInfo->ulCalledIDFlags = CallInfo->ulCalledIDFlags;
            OutCallInfo->ulCalledIDSize = CallInfo->ulCalledIDSize;
            OutCallInfo->ulCalledIDOffset = sizeof (LINE_CALL_INFO) + VarDataUsed;

            NdisMoveMemory ( (PUCHAR)(OutCallInfo)+OutCallInfo->ulCalledIDOffset,
                             (PUCHAR)(CallInfo)+CallInfo->ulCalledIDOffset,
                             CallInfo->ulCalledIDSize);

            VarDataUsed +=  CallInfo->ulCalledIDSize;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_CALLEDID;
        }

    } else {
        OutCallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
        OutCallInfo->ulCalledIDSize = 0;
        OutCallInfo->ulCalledIDOffset = 0;
    }

    OutCallInfo->ulCalledIDNameSize = 0;
    OutCallInfo->ulCalledIDNameOffset = 0;

    OutCallInfo->ulCallStates = LINECALLSTATE_IDLE |
                                LINECALLSTATE_OFFERING |
                                LINECALLSTATE_CONNECTED |
                                LINECALLSTATE_PROCEEDING |
                                LINECALLSTATE_DISCONNECTED |
                                LINECALLSTATE_SPECIALINFO |
                                LINECALLSTATE_UNKNOWN;

    OutCallInfo->ulOrigin = (pVc->Flags & PX_VC_OWNER) ? LINECALLORIGIN_EXTERNAL : LINECALLORIGIN_OUTBOUND;
    OutCallInfo->ulReason = LINECALLREASON_UNAVAIL;
    OutCallInfo->ulCompletionID = 0;
    OutCallInfo->ulConnectedIDFlags = LINECALLPARTYID_UNAVAIL;
    OutCallInfo->ulConnectedIDSize = 0;
    OutCallInfo->ulConnectedIDOffset    =    0;
    OutCallInfo->ulConnectedIDNameSize = 0;
    OutCallInfo->ulConnectedIDNameOffset = 0;

    OutCallInfo->ulRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    OutCallInfo->ulRedirectionIDSize = 0;
    OutCallInfo->ulRedirectionIDOffset = 0;
    OutCallInfo->ulRedirectionIDNameSize = 0;
    OutCallInfo->ulRedirectionIDNameOffset = 0;

    OutCallInfo->ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    OutCallInfo->ulRedirectingIDSize = 0;
    OutCallInfo->ulRedirectingIDOffset = 0;
    OutCallInfo->ulRedirectingIDNameSize       =       0;
    OutCallInfo->ulRedirectingIDNameOffset = 0;

    OutCallInfo->ulDisplaySize = 0;
    OutCallInfo->ulDisplayOffset = 0;

    OutCallInfo->ulUserUserInfoSize = 0;
    OutCallInfo->ulUserUserInfoOffset = 0;

    OutCallInfo->ulHighLevelCompSize = 0;
    OutCallInfo->ulHighLevelCompOffset = 0;

    OutCallInfo->ulLowLevelCompSize = 0;
    OutCallInfo->ulLowLevelCompOffset = 0;

    OutCallInfo->ulChargingInfoSize = 0;
    OutCallInfo->ulChargingInfoOffset = 0;

    OutCallInfo->ulTerminalModesSize = 0;
    OutCallInfo->ulTerminalModesOffset    =    0;

    OutCallInfo->ulDevSpecificSize = 0;
    OutCallInfo->ulDevSpecificOffset = 0;

    OutCallInfo->ulNeededSize =
    OutCallInfo->ulUsedSize = sizeof(LINE_CALL_INFO) + VarDataUsed;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiGetCallStatus (
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_CALL_STATUS TapiBuffer =
        (PNDIS_TAPI_GET_CALL_STATUS)pNdisTapiRequest->Data;

    PPX_VC              pVc;
    LINE_CALL_INFO*     CallInfo;
    LINE_CALL_STATUS*   CallStatus = &TapiBuffer->LineCallStatus;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetCallStatus: enter\n"));\

    if (!IsVcValid(TapiBuffer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetCallStatus: invalid call handle %d\n",
                               TapiBuffer->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    CallInfo = pVc->CallInfo;

    CallStatus->ulUsedSize = sizeof(LINE_CALL_STATUS);

    CallStatus->ulCallState = pVc->ulCallState;

    //
    // fill the mode depending on the call state
    //
    switch (pVc->ulCallState) {
        case LINECALLSTATE_IDLE:
        default:
            CallStatus->ulCallStateMode = 0;
            CallStatus->ulCallFeatures = 0;
            break;

        case LINECALLSTATE_CONNECTED:
            CallStatus->ulCallStateMode = 0;
            CallStatus->ulCallFeatures = LINECALLFEATURE_DROP;
            break;

        case LINECALLSTATE_OFFERING:
            CallStatus->ulCallStateMode = 0;
            CallStatus->ulCallFeatures = LINECALLFEATURE_ANSWER;
            break;

        case LINECALLSTATE_DISCONNECTED:
            if (pVc->ulCallStateMode == 0x11 )
                CallStatus->ulCallStateMode = LINEDISCONNECTMODE_BUSY;
            else
                CallStatus->ulCallStateMode = LINEDISCONNECTMODE_NOANSWER;
            break;

        case LINECALLSTATE_BUSY:
            CallStatus->ulCallStateMode = LINEBUSYMODE_UNAVAIL;
            break;

        case LINECALLSTATE_SPECIALINFO:
            //      if(cm->NoActiveLine)
            //          CallStatus->ulCallStateMode = LINESPECIALINFO_NOCIRCUIT;
            CallStatus->ulCallStateMode = 0;
            break;
    }

    CallStatus->ulDevSpecificSize = 0;
    CallStatus->ulDevSpecificOffset = 0;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("GetCallStatus: VC %x/%x, CallSt %x, Mode %x, Features %x\n",
                        pVc, pVc->Flags,
                        CallStatus->ulCallState,
                        CallStatus->ulCallStateMode,
                        CallStatus->ulCallFeatures));
    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiGetDevConfig(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevConfig: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevConfig: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiGetExtensionID(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_EXTENSION_ID TapiBuffer = (PNDIS_TAPI_GET_EXTENSION_ID)pNdisTapiRequest->Data;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetExtensionID: enter\n"));

    //   TapiBuffer->LineExtensionID.ulExtensionID0 = 0;
    //  TapiBuffer->LineExtensionID.ulExtensionID1 = 0;
    //  TapiBuffer->LineExtensionID.ulExtensionID2 = 0;
    //  TapiBuffer->LineExtensionID.ulExtensionID3 = 0;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetExtensionID: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiGetLineDevStatus(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_LINE_DEV_STATUS TapiBuffer =
        (PNDIS_TAPI_GET_LINE_DEV_STATUS)pNdisTapiRequest->Data;

    PPX_TAPI_LINE   TapiLine;
    PX_ADAPTER      *pAdapter;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetLineDevStatus: enter\n"));

    //
    // validate line handle and get line pointer
    //
    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {
        PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiGetLineDevStatus: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->hdLine));
        return (NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiGetLineDevStatus: got device %p from ID %d\n", TapiLine, TapiBuffer->hdLine));

    //
    // Get MediaModes and Current Calls
    //
    TapiBuffer->LineDevStatus.ulOpenMediaModes =
        TapiLine->DevStatus->ulOpenMediaModes;

    TapiBuffer->LineDevStatus.ulNumActiveCalls =
        TapiLine->DevStatus->ulNumActiveCalls;

    TapiBuffer->LineDevStatus.ulDevStatusFlags =
        TapiLine->DevStatus->ulDevStatusFlags;

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetLineDevStatus: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiNegotiateExtVersion(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_NEGOTIATE_EXT_VERSION    pNdisTapiNegotiateExtVersion =
        (PNDIS_TAPI_NEGOTIATE_EXT_VERSION) pNdisTapiRequest->Data;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiNegotiateExtVersion: enter\n"));

    pNdisTapiNegotiateExtVersion->ulExtVersion = 0;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiNegotiateExtVersion: exit NDIS_STATUS_TAPI_OPERATIONUNAVAIL\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSendUserUserInfo(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSendUserUserInfo: enter\n"));
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSendUserUserInfo: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSetAppSpecific(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_SET_APP_SPECIFIC pNdisTapiSetAppSpecific =
        (PNDIS_TAPI_SET_APP_SPECIFIC)(pNdisTapiRequest->Data);

    PPX_VC pVc;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetAppSpecific: enter\n"));

    if (!IsVcValid(pNdisTapiSetAppSpecific->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiSetAppSpecific: pVc invalid call handle %d\n",
                               pNdisTapiSetAppSpecific->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    //
    // Get the VC, and re-set the app specific longword.
    //
    pVc->CallInfo->ulAppSpecific =
        pNdisTapiSetAppSpecific->ulAppSpecific;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetAppSpecific: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiSetCallParams(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetCallParams: enter\n"));

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetCallParams: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSetDefaultMediaDetection(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{

    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION TapiBuffer =
        (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION)pNdisTapiRequest->Data;
    PPX_CL_AF       pClAf = NULL;
    PPX_CL_SAP      pClSap = NULL;
    PCO_SAP         pCoSap;
    PPX_TAPI_LINE   TapiLine = NULL;
    NDIS_STATUS     Status;
    BOOLEAN         Found = FALSE;
    PPX_TAPI_PROVIDER   TapiProvider;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSetDefaultMediaDetection: enter\n"));

    //
    // validate line handle and get line pointer
    //
    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {
        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiSetDefaultMediaDetection: NDISTAPIERR_BADDEVICEID: line = %x\n", 
                   TapiBuffer->hdLine));
        return (NDISTAPIERR_BADDEVICEID);
    }

    PXDEBUGP(PXD_LOUD, PXM_TAPI, 
             ("PxTapiSetDefaultMediaDetection: got TapiLine %p from ID %d\n", 
              TapiLine, TapiBuffer->hdLine));

    NdisAcquireSpinLock(&TapiLine->Lock);

    do {

        //
        // Is this line in service? (does it have an valid af?)
        //
        if (!(TapiLine->DevStatus->ulDevStatusFlags & 
              LINEDEVSTATUSFLAGS_INSERVICE)) {
            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiSetDefaultMediaDetection: Line not in service!\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);
            Status = NDIS_STATUS_TAPI_INVALLINESTATE;
            break;
        }

        //
        // Make sure this line supports these media modes
        //
        if ((TapiBuffer->ulMediaModes & TapiLine->DevCaps->ulMediaModes) !=
            TapiBuffer->ulMediaModes) {

            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiSetDefaultMediaDetection: invalid media mode\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);
            Status = NDIS_STATUS_TAPI_INVALMEDIAMODE;
            break;
        }

        //
        // See if we already have these media modes open
        //
        if ((TapiBuffer->ulMediaModes & 
            ~TapiLine->DevStatus->ulOpenMediaModes) == 0) {

            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiSetDefaultMediaDetection: Already have a sap!\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);

            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        TapiLine->DevStatus->ulOpenMediaModes |= 
            TapiBuffer->ulMediaModes;

        pClAf = TapiLine->ClAf;

        pClSap = TapiLine->ClSap;
        TapiLine->ClSap = NULL;

        NdisReleaseSpinLock(&TapiLine->Lock);


        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiSetDefaultMediaDetection: TapiLine: %p, pClAf: %p, MediaModes: %x\n", 
                   TapiLine, pClAf, TapiLine->DevStatus->ulOpenMediaModes));

        NdisAcquireSpinLock(&pClAf->Lock);

        REF_CL_AF(pClAf);

        if (pClSap != NULL) {
            //
            // We already have a sap on this line.  We only need one
            // per line so let's deregister the old one before registering
            // the new one.
            //
            RemoveEntryList(&pClSap->Linkage);

            InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

            NdisReleaseSpinLock(&pClAf->Lock);

            InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

            Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

            if (Status != NDIS_STATUS_PENDING) {
                PxClDeregisterSapComplete(Status, pClSap);
            }

        } else {
            NdisReleaseSpinLock(&pClAf->Lock);
        }

        //
        // Get a SAP translation for this Media Mode setting.
        // The function is called with the Af lock held and
        // returns with the Af lock released!
        //
        pClSap = (*pClAf->AfGetNdisSap)(pClAf, TapiLine);

        if (pClSap == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock(&pClAf->Lock);

        InsertTailList(&pClAf->ClSapList, &pClSap->Linkage);

        REF_CL_AF(pClAf);

        NdisReleaseSpinLock(&pClAf->Lock);

        //
        //  Register the new sap
        //
        Status = NdisClRegisterSap(pClAf->NdisAfHandle,
                                   pClSap,
                                   pClSap->CoSap,
                                   &pClSap->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            PxClRegisterSapComplete(Status,
                                    pClSap,
                                    pClSap->CoSap,
                                    pClSap->NdisSapHandle);
        }

    } while (FALSE);

    DEREF_CL_AF(pClAf);

    DEREF_TAPILINE(TapiLine);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetDefaultMediaDetection: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiSetDevConfig(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetDevConfig: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetDevConfig: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSetMediaMode(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_SET_MEDIA_MODE    pNdisTapiSetMediaMode =
        (PNDIS_TAPI_SET_MEDIA_MODE)(pNdisTapiRequest->Data);

    PPX_VC pVc;
    PPX_TAPI_LINE   TapiLine;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetMediaMode: enter\n"));

    if (!IsVcValid(pNdisTapiSetMediaMode->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiSetMediaMode: pVc invalid call handle %d\n",
                               pNdisTapiSetMediaMode->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    TapiLine = pVc->TapiAddr->TapiLine;

    if ((TapiLine->DevCaps->ulMediaModes & pNdisTapiSetMediaMode->ulMediaMode)) {
        pVc->CallInfo->ulMediaMode = pNdisTapiSetMediaMode->ulMediaMode;
    } else {
        Status = NDIS_STATUS_TAPI_INVALMEDIAMODE;
    }

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetMediaMode: exit\n"));

    return (Status);
}

NDIS_STATUS
PxTapiSetStatusMessages(
    IN    PNDISTAPI_REQUEST       pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSeStatusMessages: enter\n"));
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSetStatusMessages: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiOpen(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{

    PNDIS_TAPI_OPEN TapiBuffer =
        (PNDIS_TAPI_OPEN)pNdisTapiRequest->Data;

    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPX_TAPI_LINE       TapiLine;
    PPX_TAPI_ADDR       TapiAddr;
    PNDISTAPI_OPENDATA  OpenData;
    PX_ADAPTER          *Adapter;
    ULONG               n;

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiOpen: enter\nn"));

    if (!IsTapiDeviceValid(TapiBuffer->ulDeviceID, &TapiLine)) {
        PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiOPEN: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->ulDeviceID));
        return(NDISTAPIERR_BADDEVICEID);
    }

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiOpen: got device %p from ID %d\n", TapiLine, TapiBuffer->ulDeviceID));

    NdisAcquireSpinLock(&TapiLine->Lock);

    if (!(TapiLine->DevStatus->ulDevStatusFlags & 
          LINEDEVSTATUSFLAGS_INSERVICE)) {

        NdisReleaseSpinLock(&TapiLine->Lock);

        return(NDISTAPIERR_DEVICEOFFLINE);
    }

    //
    // Stick TAPI's line handle into the device
    //
    TapiLine->htLine = (HTAPI_LINE)TapiBuffer->htLine;

    TapiLine->DevStatus->ulNumOpens++;

    //
    // Stick our line handle into the out param. This is the context that will be
    // passed to us in subsequent API calls on this open line device. Use the device ID.
    //
    TapiBuffer->hdLine = TapiLine->hdLine;

    //
    // Stick the miniport GUID and the mediatype into the variable data portion of the
    // TAPI Open call (req'd for NDISWAN/Tonybe)
    //
    Adapter = TapiLine->TapiProvider->Adapter;

    OpenData = (PNDISTAPI_OPENDATA)
        ((PUCHAR)pNdisTapiRequest->Data + sizeof(NDIS_TAPI_OPEN));

    RtlMoveMemory(&OpenData->Guid,
                  &Adapter->Guid,
                  sizeof(OpenData->Guid));

    OpenData->MediaType = Adapter->MediumSubType;

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiOpen: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiProviderInit(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:
fea142c4
    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderInit: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderInit: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiProviderShutdown(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:
fea142c4
    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderShutdown: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderShutdown: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxTapiSecureCall(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSecureCall: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSecureCall: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSelectExtVersion(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSelectExtVersion: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSelectExtVersion: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}



NDIS_STATUS
PxTapiGatherDigits(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
{
    NDIS_STATUS                 Status = STATUS_SUCCESS;
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits = NULL;
    NDIS_HANDLE                 NdisBindingHandle, NdisAfHandle, NdisVcHandle;
    PPX_VC                      pVc = NULL;

    PXDEBUGP(PXD_LOUD, PXM_TAPI, ("PxTapiGatherDigits: Enter\n"));

    pNdisTapiGatherDigits = 
        (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;

    do {
        PX_REQUEST      ProxyRequest;
        PNDIS_REQUEST   NdisRequest;
        PIRP            Irp;

        if (!IsVcValid(pNdisTapiGatherDigits->hdCall, &pVc)) {
            PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                     ("PxTapiGatherDigits: Invalid call - Setting "
                      "Status NDISTAPIERR_BADDEVICEID\n"));
            Status = NDISTAPIERR_BADDEVICEID;
            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        //
        // If we're monitoring digits (ala lineMonitorDigits) then we can't gather digits. 
        //
        if (pVc->ulMonitorDigitsModes != 0) {
            NdisReleaseSpinLock(&pVc->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pVc->PendingGatherDigits != NULL) {
            //
            // Check if the buffer passed to TSPI_lineGatherDigits was NULL. If so, then this 
            // is a request to cancel digit gathering that was previously initiated. If not, then
            // the app is trying to do two lineGatherDigits() operations at once and we have to 
            // fail this. 
            //
            if (pNdisTapiGatherDigits->lpsOrigDigitsBuffer == NULL) {
                
                pVc->PendingGatherDigits = NULL;
                PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_CANCEL);

                NdisReleaseSpinLock(&pVc->Lock);                
                Status = NDIS_STATUS_SUCCESS;

                break;
            } else {
            
                NdisReleaseSpinLock(&pVc->Lock);
                Status = NDIS_STATUS_FAILURE;
                break;

            }
        } else if (pNdisTapiGatherDigits->lpsOrigDigitsBuffer == NULL) {
            //
            // Trying to cancel digit detection even though it wasn't started. Fail this. 
            //

            NdisReleaseSpinLock(&pVc->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Irp = pNdisTapiRequest->Irp;

        IoSetCancelRoutine(Irp, PxCancelSetQuery);

        //
        // Store the unique request ID in the VC - this will be used later to retrieve the 
        // original IRP.
        //
        pVc->PendingGatherDigits = pNdisTapiRequest;

        NdisReleaseSpinLock(&pVc->Lock);

        //
        // Initialize the timer that will be used to implement the digit timeouts. 
        //

        NdisInitializeTimer(&pVc->DigitTimer,
                            PxDigitTimerRoutine,
                            (PVOID)pVc);

        //        
        // Fill out our request structure.
        //
        NdisZeroMemory(&ProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc(&ProxyRequest.Block);

        NdisRequest = &ProxyRequest.NdisRequest;

        NdisRequest->RequestType = 
            NdisRequestSetInformation;
        
        NdisRequest->DATA.SET_INFORMATION.Oid = 
            OID_CO_TAPI_REPORT_DIGITS;

        NdisRequest->DATA.SET_INFORMATION.InformationBuffer = 
            (PVOID)&pNdisTapiGatherDigits->ulDigitModes;   // This is the NDIS_TAPI_GATHER_DIGITS structure

        NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = 
            sizeof(pNdisTapiGatherDigits->ulDigitModes);
            
        Status = 
            NdisCoRequest(pVc->Adapter->ClBindingHandle, 
                          pVc->ClAf->NdisAfHandle,
                          pVc->ClVcHandle,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&ProxyRequest.Block);
        }

        if (Status != NDIS_STATUS_SUCCESS) {

            NdisAcquireSpinLock(&pVc->Lock);

            pVc->PendingGatherDigits = NULL;

            IoSetCancelRoutine(Irp, NULL);

            NdisReleaseSpinLock(&pVc->Lock);

            PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                     ("PxTapiGatherDigits: NdisCoRequest failed\n"));
            break;
        }

        //
        // Start the timer for the first digit timeout. Ref the VC here because otherwise it might 
        // go away before the timer fires.
        //
        if (pNdisTapiGatherDigits->ulFirstDigitTimeout) {
            
            NdisAcquireSpinLock(&pVc->Lock);
            REF_VC(pVc);
            NdisReleaseSpinLock(&pVc->Lock);

            NdisSetTimer(&pVc->DigitTimer,
                         pNdisTapiGatherDigits->ulFirstDigitTimeout);
        }

        //
        // Set status to pending because this request just initiates the gathering of digits. 
        // The IRP will complete once all the digits come in. 
        //
        Status = NDIS_STATUS_PENDING; 
                            
    } while (FALSE);

    DEREF_VC(pVc);

    PXDEBUGP(PXD_LOUD, PXM_TAPI,
             ("PxTapiGatherDigits: Exit - Returning 0x%x\n", Status));

    return (Status);
}

NDIS_STATUS
PxTapiMonitorDigits(
                     IN PNDISTAPI_REQUEST    pNdisTapiRequest
                     )  
{   
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PNDIS_TAPI_MONITOR_DIGITS   pNdisTapiMonitorDigits = NULL;
    PPX_VC                      pVc = NULL;

    PXDEBUGP(PXD_LOUD, PXM_TAPI, ("PxTapiMonitorDigits: Enter\n"));

    pNdisTapiMonitorDigits = 
        (PNDIS_TAPI_MONITOR_DIGITS)pNdisTapiRequest->Data;

    do {
        if (!IsVcValid(pNdisTapiMonitorDigits->hdCall, &pVc)) {
            PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                     ("PxTapiMonitorDigits: Invalid call - Setting "
                      "Status NDISTAPIERR_BADDEVICEID\n"));
            Status = NDISTAPIERR_BADDEVICEID;
            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        if (pVc->PendingGatherDigits != NULL) {
            //
            // Can't monitor digits while a lineGatherDigits request is in effect.
            //
            NdisReleaseSpinLock(&pVc->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (pVc->ulMonitorDigitsModes != 0) {
            
            NdisReleaseSpinLock(&pVc->Lock);
            //
            // We are already monitoring digits as a result of lineMonitorDigits request. 
            // If the digit modes in the this request are zero, then this is a request to 
            // cancel digit monitoring. 
            //
            
            if (pNdisTapiMonitorDigits->ulDigitModes == 0) {
                
                Status = PxStopDigitReporting(pVc);

                if (Status != NDIS_STATUS_SUCCESS) {
                    PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                             ("PxTapiMonitorDigits: Failed to stop digit reporting with status 0x%x\n", Status));
                    
                    break;
                }
                
                //
                // It's a shame that I have to acquire and release again since I had 
                // the lock before, but there's no way to know whether I can set this
                // to zero until I know the status that PxStopDigitReporting() returned.
                //
                NdisAcquireSpinLock(&pVc->Lock);
                pVc->ulMonitorDigitsModes = 0; 
                NdisReleaseSpinLock(&pVc->Lock);

            } else {
                //
                // We're already monitoring digits, so this request to do so must fail. 
                //
                Status = NDIS_STATUS_FAILURE;
                break;              
            }
        } else {            
            PX_REQUEST      ProxyRequest;
            PNDIS_REQUEST   NdisRequest;

            pVc->ulMonitorDigitsModes = pNdisTapiMonitorDigits->ulDigitModes; 

            NdisReleaseSpinLock(&pVc->Lock);

            if (pNdisTapiMonitorDigits->ulDigitModes == 0) {
                //
                // Someone's trying to cancel digit monitoring, but it hasn't been started yet.
                //
                Status = NDIS_STATUS_FAILURE;
                break;
            }


            //        
            // Fill out our request structure to tell the miniport to start reporting digits.
            //
            NdisZeroMemory(&ProxyRequest, sizeof(ProxyRequest));

            PxInitBlockStruc(&ProxyRequest.Block);

            NdisRequest = &ProxyRequest.NdisRequest;

            NdisRequest->RequestType = 
                NdisRequestSetInformation;
        
            NdisRequest->DATA.SET_INFORMATION.Oid = 
                OID_CO_TAPI_REPORT_DIGITS;

            NdisRequest->DATA.SET_INFORMATION.InformationBuffer = 
                (PVOID)&pNdisTapiMonitorDigits->ulDigitModes;   

            NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = 
                sizeof(pNdisTapiMonitorDigits->ulDigitModes);

            Status = 
                NdisCoRequest(pVc->Adapter->ClBindingHandle, 
                              pVc->ClAf->NdisAfHandle,
                              pVc->ClVcHandle,
                              NULL,
                              NdisRequest);
            
            if (Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&ProxyRequest.Block);
            }

            if (Status != NDIS_STATUS_SUCCESS) {

                NdisAcquireSpinLock(&pVc->Lock);

                pVc->ulMonitorDigitsModes = 0;

                NdisReleaseSpinLock(&pVc->Lock);

                PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                         ("PxTapiMonitorDigits: NdisCoRequest to start digit reporting failed with status 0x%x\n", Status));
                break;
            }

        }   
    } while (FALSE);

    DEREF_VC(pVc);
    
    PXDEBUGP(PXD_LOUD, PXM_TAPI, ("PxTapiMonitorDigits: Exit - Returning 0x%x\n", Status));

    return (Status);
} 



VOID
PxTapiCompleteDropIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    )

/*++

Routine Description:



Arguments:



Return Value:


--*/

{
    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteDropIrps: Vc %p\n", pVc));

    ASSERT(!IsListEmpty(&pVc->PendingDropReqs));
    ASSERT(pVc->Flags & PX_VC_DROP_PENDING);

    while (!IsListEmpty(&pVc->PendingDropReqs)) {

        PLIST_ENTRY             Entry;
        PIRP                    Irp;
        KIRQL                   Irql;
        PNDISTAPI_REQUEST       pNdisTapiRequest;

        Entry = 
            RemoveHeadList(&pVc->PendingDropReqs);

        NdisReleaseSpinLock(&pVc->Lock);

        pNdisTapiRequest = 
            CONTAINING_RECORD(Entry, NDISTAPI_REQUEST, Linkage);

        Irp = pNdisTapiRequest->Irp;

        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        IoSetCancelRoutine(Irp, NULL);

        Irp->IoStatus.Information = 
            sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);

        Irp->IoStatus.Status = STATUS_SUCCESS;

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiCompleteIrp: Irp %p, Oid: %x\n", Irp, pNdisTapiRequest->Oid));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        NdisAcquireSpinLock(&pVc->Lock);

    }

    pVc->Flags &= ~PX_VC_DROP_PENDING;

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteDropIrps: exit\n"));

    return;
}

VOID
PxTapiCompleteAllIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    )

/*++

Routine Description:



Arguments:



Return Value:


--*/

{
    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteAllIrps: Vc %p\n", pVc));

    while (!IsListEmpty(&pVc->PendingDropReqs)) {

        PLIST_ENTRY             Entry;
        PIRP                    Irp;
        KIRQL                   Irql;
        PNDISTAPI_REQUEST       pNdisTapiRequest;

        Entry = 
            RemoveHeadList(&pVc->PendingDropReqs);

        NdisReleaseSpinLock(&pVc->Lock);

        pNdisTapiRequest = 
            CONTAINING_RECORD(Entry, NDISTAPI_REQUEST, Linkage);

        Irp = pNdisTapiRequest->Irp;

        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        IoSetCancelRoutine(Irp, NULL);

        Irp->IoStatus.Information = 
            sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);

        Irp->IoStatus.Status = STATUS_SUCCESS;

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiCompleteIrp: Irp %p, Oid: %x\n", Irp, pNdisTapiRequest->Oid));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        NdisAcquireSpinLock(&pVc->Lock);
    }

    pVc->Flags &= ~PX_VC_DROP_PENDING;

    if (pVc->PendingGatherDigits != NULL) {

        PIRP                    Irp;
        KIRQL                   Irql;
        PNDISTAPI_REQUEST       pNdisTapiRequest;


        pNdisTapiRequest = pVc->PendingGatherDigits;
        pVc->PendingGatherDigits = NULL;

        NdisReleaseSpinLock(&pVc->Lock);

        Irp = pNdisTapiRequest->Irp;

        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        IoSetCancelRoutine(Irp, NULL);

        Irp->IoStatus.Information = 
            sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);

        Irp->IoStatus.Status = STATUS_SUCCESS;

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiCompleteIrp: Irp %p, Oid: %x\n", Irp, pNdisTapiRequest->Oid));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        NdisAcquireSpinLock(&pVc->Lock);
    }

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteAllIrps: exit\n"));

    return;
}

VOID
PxIndicateStatus(
    IN  PVOID   StatusBuffer,
    IN  UINT    StatusBufferSize
    )

/*++

Routine Description:

    Called to send any event info that may be in the device extension to TAPI in the form of an
    NDIS_TAPI_EVENT, sent in an available queued GET_EVENT IRP. If there's no outstanding IRP, stick
    the data in the queue so it will go whenver there is one.

Arguments:



Return Value:


--*/
{
    PIRP                    Irp;
    PNDIS_TAPI_EVENT        NdisTapiEvent;
    PNDISTAPI_EVENT_DATA    NdisTapiEventData;

    NdisTapiEvent = StatusBuffer;

    //
    // Sync event buf access by acquiring EventSpinLock
    //
    NdisAcquireSpinLock(&TspCB.Lock);

    //
    // Are we initialized with TAPI?
    //
    if (TspCB.Status != NDISTAPI_STATUS_CONNECTED) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                 ("PxIndicateStatus: TAPI not connected!\n"));

        NdisReleaseSpinLock(&TspCB.Lock);

        return;
    }

    NdisReleaseSpinLock(&TspCB.Lock);

    NdisAcquireSpinLock(&TspEventList.Lock);

    Irp = TspEventList.RequestIrp;
    TspEventList.RequestIrp = NULL;

    if (Irp == NULL) {
        PPROVIDER_EVENT ProviderEvent;
        
        ProviderEvent =
            ExAllocateFromNPagedLookasideList(&ProviderEventLookaside);
        
        if (ProviderEvent != NULL) {
            RtlMoveMemory(&ProviderEvent->Event,
                          StatusBuffer,
                          sizeof(NDIS_TAPI_EVENT));
        
            InsertTailList(&TspEventList.List,
                           &ProviderEvent->Linkage);
        
            TspEventList.Count++;

            if (TspEventList.Count > TspEventList.MaxCount) {
                TspEventList.MaxCount = TspEventList.Count;
            }

        }
    } else {
        ASSERT(IsListEmpty(&TspEventList.List));
    }

    NdisReleaseSpinLock(&TspEventList.Lock);

    //
    // Check of there is an outstanding request to satisfy
    //
    if (Irp != NULL) {
        KIRQL   Irql;

        //
        // Clear out the cancel routine
        //
        IoSetCancelRoutine (Irp, NULL);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information =
            sizeof(NDISTAPI_EVENT_DATA) + StatusBufferSize - 1;

        //
        // Copy as much of the input data possible from the input data
        // queue to the SystemBuffer to satisfy the read.
        //
        NdisTapiEventData = Irp->AssociatedIrp.SystemBuffer;

        ASSERT(NdisTapiEventData->ulTotalSize >= StatusBufferSize);

        RtlMoveMemory(NdisTapiEventData->Data,
                      (PCHAR) StatusBuffer,
                      StatusBufferSize);

        //
        // Set the flag so that we start the next packet and complete
        // this read request (with STATUS_SUCCESS) prior to return.
        //

        NdisTapiEventData->ulUsedSize = StatusBufferSize;

        PXDEBUGP(PXD_LOUD, PXM_TAPI, 
                 ("PxIndicateStatus: htLine: %x, htCall: %x, Msg: %x\n",
                  NdisTapiEvent->htLine, NdisTapiEvent->htCall, NdisTapiEvent->ulMsg));

        PXDEBUGP(PXD_LOUD, PXM_TAPI, 
                 ("                : p1: %x, p2: %x, p3: %x\n",
                  NdisTapiEvent->ulParam1, NdisTapiEvent->ulParam2, NdisTapiEvent->ulParam3));

        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    }
}

NDIS_STATUS
AllocateTapiResources(
    IN  PPX_ADAPTER     ClAdapter,
    IN  PPX_CL_AF       pClAf
    )
{
    NDIS_STATUS     Status;
    ULONG           SizeNeeded;
    ULONG           TapiVersion;
    PPX_TAPI_LINE   TapiLine = NULL;
    PPX_TAPI_ADDR   TapiAddr = NULL;
    UINT            i, j;
    PPX_TAPI_PROVIDER  TapiProvider;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("AllocateTapiResoures: Enter\n"));

    //
    // See if this device supports TAPI and if so
    // see how many lines it has
    //
    TapiProvider =
        AllocateTapiProvider(ClAdapter, pClAf);

    if (TapiProvider == NULL) {
        PXDEBUGP(PXD_ERROR, PXM_TAPI, ("Error allocating TapiProvider!\n"));
        return (NDIS_STATUS_FAILURE);
    }

    return (NDIS_STATUS_SUCCESS);
}

PPX_TAPI_PROVIDER
AllocateTapiProvider(
    PPX_ADAPTER     ClAdapter,
    PPX_CL_AF       pClAf
    )
{
    PNDIS_REQUEST   NdisRequest;
    NDIS_STATUS     Status;
    CO_TAPI_CM_CAPS CmCaps;
    BOOLEAN         TapiSupported = TRUE;
    ULONG           AllocSize;
    PTAPI_LINE_TABLE  LineTable;
    PPX_TAPI_PROVIDER   TapiProvider = NULL;
    ULONG           i;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("AllocateTapiProvider: Enter\n"));

    do {
        PX_REQUEST  ProxyRequest;
        PPX_REQUEST pProxyRequest = &ProxyRequest;

        NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));
        NdisZeroMemory(&CmCaps, sizeof(CmCaps));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
        NdisRequestQueryInformation;
        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_CO_TAPI_CM_CAPS;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            &CmCaps;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(CmCaps);

        Status =
            NdisCoRequest(ClAdapter->ClBindingHandle,
                          pClAf->NdisAfHandle,
                          NULL,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status != NDIS_STATUS_SUCCESS) {

            if (Status != NDIS_STATUS_NOT_SUPPORTED) {
                break;
            }

            Status = NDIS_STATUS_SUCCESS;
            //
            // Setup a default config for this device.
            // ToDo! These values should be read from
            // the registry on a per device basis!
            //
            CmCaps.ulNumLines = 1;
            CmCaps.ulFlags = 0;
            CmCaps.ulCoTapiVersion = CO_TAPI_VERSION;
            TapiSupported = FALSE;
        }

        //
        // Allocate a tapi provider block for this adapter
        // The provider block will live outside of the
        // adapter.  This allows us to continue tapi service
        // after a machine has been power managed.
        //

        AllocSize = sizeof(PX_TAPI_PROVIDER) +
                    (sizeof(PPX_TAPI_LINE) * CmCaps.ulNumLines) +
                    sizeof(PVOID);

        PxAllocMem(TapiProvider, AllocSize, PX_PROVIDER_TAG);

        if (TapiProvider == NULL) {
            break;
        }

        NdisZeroMemory(TapiProvider, AllocSize);

        NdisAllocateSpinLock(&TapiProvider->Lock);

        TapiProvider->Status = PROVIDER_STATUS_OFFLINE;

        TapiProvider->Adapter = ClAdapter;
        TapiProvider->ClAf = pClAf;
        TapiProvider->NumDevices = CmCaps.ulNumLines;
        TapiProvider->Guid = ClAdapter->Guid;
        TapiProvider->Af = pClAf->Af;
        PXDEBUGP(PXD_TAPI, PXM_TAPI, ("TapiProvider Allocated: GUID %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x\n",
                 TapiProvider->Guid.Data1, TapiProvider->Guid.Data2, TapiProvider->Guid.Data3,
                 TapiProvider->Guid.Data4[0],TapiProvider->Guid.Data4[1],TapiProvider->Guid.Data4[2],
                 TapiProvider->Guid.Data4[3],TapiProvider->Guid.Data4[4],TapiProvider->Guid.Data4[5],
                 TapiProvider->Guid.Data4[6],TapiProvider->Guid.Data4[7]));

        TapiProvider->TapiSupported = TapiSupported;

        TapiProvider->TapiFlags |= CmCaps.ulFlags;

        TapiProvider->CoTapiVersion = CmCaps.ulCoTapiVersion;

        InitializeListHead(&TapiProvider->LineList);
        InitializeListHead(&TapiProvider->CreateList);

        for (i = 0; i < TapiProvider->NumDevices; i++) {
            PPX_TAPI_LINE   TapiLine;

            TapiLine =
                AllocateTapiLine(TapiProvider, i);

            if (TapiLine == NULL) {
                FreeTapiProvider(TapiProvider);
                TapiProvider = NULL;
                break;
            }

            //
            // Put the new line on the create list
            // We will need to insert it in the line table
            // and possibly notify tapi about it
            //
            InsertTailList(&TapiProvider->CreateList, &TapiLine->Linkage);
        }

    } while ( FALSE );

    if (TapiProvider != NULL) {
        PPX_TAPI_PROVIDER   tp;
        BOOLEAN             TapiConnected;

        //
        // See if we already have a provider for this
        // GUID.  If we don't just add this provider on
        // to the tsp and do the right thing with it's
        // new lines.  If we do see if anything on the
        // provider has changed and do the right thing
        // with it's tapi lines.
        //
        NdisAcquireSpinLock(&TspCB.Lock);

        tp = (PPX_TAPI_PROVIDER)TspCB.ProviderList.Flink;

        while ((PVOID)tp != (PVOID)&TspCB.ProviderList) {

            if ((tp->Status == PROVIDER_STATUS_OFFLINE) &&
                (NdisEqualMemory(&tp->Guid, &TapiProvider->Guid, sizeof(tp->Guid))) &&
                (pClAf->Af.AddressFamily == tp->Af.AddressFamily)) {

                //
                // We have already have a provider for this 
                // adapter/address family.  See if anything has
                // changed.  
                //
                //
                // ToDo!
                // This check needs to be more complete!
                //
                if (tp->NumDevices != TapiProvider->NumDevices) {
                    //
                    // ToDo!
                    // Much work to do here!
                    //

                } else {
                    //
                    // Nothing has changed so free the new allocations
                    // and reactivate the old ones.
                    //

                    FreeTapiProvider(TapiProvider);

                    TapiProvider = tp;
                }

                PXDEBUGP(PXD_TAPI, PXM_TAPI, ("TapiProvider found: GUID %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x\n",
                         ClAdapter->Guid.Data1, ClAdapter->Guid.Data2, ClAdapter->Guid.Data3,
                         ClAdapter->Guid.Data4[0],ClAdapter->Guid.Data4[1],ClAdapter->Guid.Data4[2],
                         ClAdapter->Guid.Data4[3],ClAdapter->Guid.Data4[4],ClAdapter->Guid.Data4[5],
                         ClAdapter->Guid.Data4[6],ClAdapter->Guid.Data4[7]));
                break;

            } else {

                tp = (PPX_TAPI_PROVIDER)tp->Linkage.Flink;
            }
        }

        //
        // We did not find a provider on the list
        // so insert the new provider
        //
        if ((PVOID)tp == (PVOID)&TspCB.ProviderList) {
            InsertTailList(&TspCB.ProviderList, &TapiProvider->Linkage);
            TspCB.NdisTapiNumDevices += TapiProvider->NumDevices;
        }

        if (TspCB.Status == NDISTAPI_STATUS_CONNECTED) {
            TapiProvider->Status = PROVIDER_STATUS_ONLINE;
        }

        NdisReleaseSpinLock(&TspCB.Lock);

        NdisAcquireSpinLock(&TapiProvider->Lock);

        pClAf->TapiProvider = TapiProvider;
        TapiProvider->ClAf= pClAf;
        TapiProvider->Adapter = ClAdapter;

        while (!IsListEmpty(&TapiProvider->CreateList)) {
            PPX_TAPI_LINE   TapiLine;

            TapiLine = (PPX_TAPI_LINE)
                RemoveHeadList(&TapiProvider->CreateList);

            InsertTailList(&TapiProvider->LineList, &TapiLine->Linkage);

            //
            // Insert the line in the table
            //
            if (!InsertLineInTable(TapiLine)) {
                FreeTapiLine(TapiLine);
                continue;
            }

            NdisReleaseSpinLock(&TapiProvider->Lock);

            SendTapiLineCreate(TapiLine);

            NdisAcquireSpinLock(&TapiProvider->Lock);
        }

        MarkProviderOnline(TapiProvider);

        NdisReleaseSpinLock(&TapiProvider->Lock);
    }

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("TapiProvider: %x\n", TapiProvider));

    return (TapiProvider);
}

VOID
MarkProviderOffline(
    PPX_TAPI_PROVIDER   TapiProvider
    )
{
    LOCK_STATE      LockState;
    ULONG           i;

    TapiProvider->Status = PROVIDER_STATUS_OFFLINE;
    TapiProvider->ClAf = NULL;
    TapiProvider->Adapter = NULL;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags &=
                    ~(LINEDEVSTATUSFLAGS_INSERVICE);
    
                TapiLine->ClAf = NULL;
    
                NdisReleaseSpinLock(&TapiLine->Lock);

#if 0
                NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

                SendTapiLineClose(TapiLine);

                NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);
#endif

            } else {

                NdisReleaseSpinLock(&TapiLine->Lock);
            }
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

VOID
MarkProviderOnline(
   PPX_TAPI_PROVIDER   TapiProvider
   )
{
    LOCK_STATE      LockState;
    ULONG           i;

    TapiProvider->Status = PROVIDER_STATUS_ONLINE;

    NdisReleaseSpinLock(&TapiProvider->Lock);

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags |=
                    LINEDEVSTATUSFLAGS_INSERVICE;
    
                TapiLine->ClAf = TapiProvider->ClAf;

//#if 0
                //
                // This line was open by tapi before it was
                // marked offline.  We need to force tapi to
                // reopen the line so we will send the CLOSE_LINE
                // message in the hopes that any apps that care
                // will then turn around and reopen the line.
                //
                if (TapiLine->DevStatus->ulNumOpens != 0) {
//                    TapiLine->DevStatus->ulNumOpens = 0;

                    NdisReleaseSpinLock(&TapiLine->Lock);

                    SendTapiLineClose(TapiLine);

                    NdisAcquireSpinLock(&TapiLine->Lock);
                }
//#endif

            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

    NdisAcquireSpinLock(&TapiProvider->Lock);
}


VOID
MarkProviderConnected(
  PPX_TAPI_PROVIDER   TapiProvider
  )
{
    LOCK_STATE      LockState;
    ULONG           i;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags |=
                    LINEDEVSTATUSFLAGS_CONNECTED;
            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

VOID
MarkProviderDisconnected(
  PPX_TAPI_PROVIDER   TapiProvider
  )
{
    LOCK_STATE      LockState;
    ULONG           i;

    //
    // ToDo! If we have any active calls on this line we
    // need to disconnect them without tapi's assistance.  This
    // would only happen if tapi crashes while we have active calls
    //

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags &=
                    ~(LINEDEVSTATUSFLAGS_CONNECTED);
            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

VOID
ClearSapWithTapiLine(
    PPX_CL_SAP  pClSap
  )
{
    LOCK_STATE      LockState;
    ULONG           i;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->ClSap == pClSap) {
                TapiLine->ClSap = NULL;
            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}


VOID
FreeTapiProvider(
    PPX_TAPI_PROVIDER   TapiProvider
    )
{
    //
    // Free any lines on the create list
    //
    while (!IsListEmpty(&TapiProvider->CreateList)) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = (PPX_TAPI_LINE)
            RemoveHeadList(&TapiProvider->CreateList);

        FreeTapiLine(TapiLine);
    }

    //
    // Free the lines associated with this provider
    //
    while (!IsListEmpty(&TapiProvider->LineList)) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = (PPX_TAPI_LINE)
            RemoveHeadList(&TapiProvider->LineList);

        if (TapiLine->Flags & PX_LINE_IN_TABLE) {
            RemoveTapiLineFromTable(TapiLine);
        }

        FreeTapiLine(TapiLine);
    }

    NdisFreeSpinLock(&TapiProvider->Lock);

    PxFreeMem(TapiProvider);
}

PPX_TAPI_LINE
AllocateTapiLine(
    PPX_TAPI_PROVIDER   TapiProvider,
    ULONG               LineNumber
    )
{
    PLINE_DEV_CAPS      ldc, ldc1;
    PNDIS_REQUEST       NdisRequest;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PCO_TAPI_LINE_CAPS  LineCaps;
    PUCHAR              EnumBuffer;
#if DBG
    ULONG               EnumBufferSize = PAGE_SIZE -
                                         sizeof(PXD_ALLOCATION);
#else
    ULONG               EnumBufferSize = PAGE_SIZE;
#endif
    ULONG               SizeNeeded, SizeDevCaps;
    PPX_TAPI_LINE       TapiLine = NULL;
    PPX_ADAPTER         ClAdapter = TapiProvider->Adapter;
    PPX_CL_AF           pClAf = TapiProvider->ClAf;
    ULONG               i;
    PX_REQUEST          ProxyRequest;
    PPX_REQUEST         pProxyRequest = &ProxyRequest;

    PxAllocMem((PCO_TAPI_LINE_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMLINE_TAG);

    if (EnumBuffer == NULL) {
        return (NULL);
    }

    NdisZeroMemory(EnumBuffer, EnumBufferSize);

    LineCaps = (PCO_TAPI_LINE_CAPS)EnumBuffer;

    LineCaps->ulLineID = LineNumber;

    ldc = &LineCaps->LineDevCaps;

    ldc->ulTotalSize =
        EnumBufferSize - (sizeof(CO_TAPI_LINE_CAPS) - sizeof(LINE_DEV_CAPS));

    //
    // If this device does not support TAPI we will build
    // a default line configuration.
    // ToDo! Some of these values should be queried from
    // the registry on a per device basis!
    //
    if (!TapiProvider->TapiSupported) {
        NDIS_CO_LINK_SPEED   SpeedInfo;

        LineCaps->ulFlags = 0;

        ldc->ulTotalSize =
        ldc->ulNeededSize =
        ldc->ulUsedSize =
            sizeof(LINE_DEV_CAPS);
        ldc->ulStringFormat = STRINGFORMAT_ASCII;
        ldc->ulAddressModes = LINEADDRESSMODE_ADDRESSID;
        ldc->ulNumAddresses = 1;
        ldc->ulBearerModes = LINEBEARERMODE_VOICE |
                             LINEBEARERMODE_DATA;
        ldc->ulMediaModes = LINEMEDIAMODE_DIGITALDATA;
        ldc->ulMaxNumActiveCalls = 1000;

        NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
            NdisRequestQueryInformation;

        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_GEN_CO_LINK_SPEED;

        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            &SpeedInfo;

        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(NDIS_CO_LINK_SPEED);

        PXDEBUGP(PXD_INFO, PXM_CO, ("NDProxy: DeviceExtension->RegistryFlags = %x\n", DeviceExtension->RegistryFlags));

        PXDEBUGP(PXD_INFO, PXM_CO, ("NDProxy: using ndisrequest to get rates from adapter\n"));

        Status =
            NdisCoRequest(ClAdapter->ClBindingHandle,
                          pClAf->NdisAfHandle,
                          NULL,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status == NDIS_STATUS_SUCCESS) {
            ldc->ulMaxRate = SpeedInfo.Outbound;
        } else {
            ldc->ulMaxRate = 128000;
        }

    } else if (!(TapiProvider->TapiFlags & CO_TAPI_FLAG_PER_LINE_CAPS) &&
                (LineNumber > 0)) {

        PLINE_DEV_CAPS      ldc1;
        PCO_TAPI_LINE_CAPS  LineCaps1;
        PPX_TAPI_LINE       Line1;

        //
        // If all of the lines on this device have the same caps
        // and this is not the first line, just copy the caps
        // from the first line!
        //
        Line1 = (PPX_TAPI_LINE)
            TapiProvider->CreateList.Flink;

        ldc1 = Line1->DevCaps;

        if (ldc1->ulTotalSize > ldc->ulTotalSize) {

            //
            // We don't have enough memory allocated!
            //
            PxFreeMem(EnumBuffer);

            EnumBufferSize =
                (sizeof(CO_TAPI_LINE_CAPS) - sizeof(LINE_DEV_CAPS) +
                 ldc1->ulTotalSize);

            PxAllocMem((PCO_TAPI_LINE_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMLINE_TAG);

            if (EnumBuffer == NULL){
                return (NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            LineCaps = (PCO_TAPI_LINE_CAPS)EnumBuffer;
            LineCaps->ulLineID = LineNumber;
            LineCaps->LineDevCaps.ulTotalSize =
                EnumBufferSize - (sizeof(CO_TAPI_LINE_CAPS) -
                sizeof(LINE_DEV_CAPS));

            ldc = &LineCaps->LineDevCaps;
        }

        NdisMoveMemory(ldc, ldc1, ldc1->ulUsedSize);

    } else {

        NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
        NdisRequestQueryInformation;
        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_CO_TAPI_LINE_CAPS;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            LineCaps;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            EnumBufferSize;

        Status =
            NdisCoRequest(ClAdapter->ClBindingHandle,
                          pClAf->NdisAfHandle,
                          NULL,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status == NDIS_STATUS_INVALID_LENGTH){
            ULONG   SizeNeeded;

            //
            // Our buffer was not large enough so try again
            //
            SizeNeeded = 
            EnumBufferSize =
                MAX (LineCaps->LineDevCaps.ulNeededSize,
                     NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded);

            PxFreeMem(EnumBuffer);

            PxAllocMem((PCO_TAPI_LINE_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMLINE_TAG);

            if (EnumBuffer == NULL){
                return(NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            LineCaps = (PCO_TAPI_LINE_CAPS)EnumBuffer;
            LineCaps->ulLineID = LineNumber;

            ldc = &LineCaps->LineDevCaps;

            ldc->ulTotalSize =
                EnumBufferSize - (sizeof(CO_TAPI_LINE_CAPS) - sizeof(LINE_DEV_CAPS));

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            PxInitBlockStruc (&pProxyRequest->Block);

            NdisRequest = &pProxyRequest->NdisRequest;

            NdisRequest->RequestType =
                NdisRequestQueryInformation;
            NdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_LINE_CAPS;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                LineCaps;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                EnumBufferSize;

            Status =
                NdisCoRequest(ClAdapter->ClBindingHandle,
                              pClAf->NdisAfHandle,
                              NULL,
                              NULL,
                              NdisRequest);

            if (Status == NDIS_STATUS_PENDING){
                Status = PxBlock(&pProxyRequest->Block);
            }

            if (Status != NDIS_STATUS_SUCCESS){
                PxFreeMem(EnumBuffer);
                return(NULL);
            }

        }else if (Status != STATUS_SUCCESS){
            PxFreeMem(EnumBuffer);
            return(NULL);
        }
    }

    SizeNeeded = sizeof(PX_TAPI_LINE);
    SizeNeeded +=
        (sizeof(PPX_TAPI_ADDR) * LineCaps->LineDevCaps.ulNumAddresses);
    SizeNeeded += sizeof(LINE_DEV_STATUS);
    SizeNeeded += 3*sizeof(PVOID);

    if (LineCaps->LineDevCaps.ulUsedSize < sizeof(LINE_DEV_CAPS)) {
        LineCaps->LineDevCaps.ulUsedSize = sizeof(LINE_DEV_CAPS);
    }

    SizeDevCaps = LineCaps->LineDevCaps.ulUsedSize;

    SizeNeeded += SizeDevCaps;

    PxAllocMem(TapiLine, SizeNeeded, PX_TAPILINE_TAG);

    if (TapiLine == NULL){
        PxFreeMem(EnumBuffer);
        return(NULL);
    }

    NdisZeroMemory(TapiLine, SizeNeeded);

    TapiLine->DevCaps = (PLINE_DEV_CAPS)
        ((PUCHAR)TapiLine + sizeof(PX_TAPI_LINE) + sizeof(PVOID));

    (ULONG_PTR)TapiLine->DevCaps &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    TapiLine->DevStatus = (PLINE_DEV_STATUS)
        ((PUCHAR)TapiLine->DevCaps + SizeDevCaps + sizeof(PVOID));

    (ULONG_PTR)TapiLine->DevStatus &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    TapiLine->AddrTable.Table = (PPX_TAPI_ADDR*)
        ((PUCHAR)TapiLine->DevStatus + 
         sizeof(LINE_DEV_STATUS) + sizeof(PVOID));

    (ULONG_PTR)TapiLine->AddrTable.Table &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    NdisMoveMemory(TapiLine->DevCaps,
                   &LineCaps->LineDevCaps,
                   LineCaps->LineDevCaps.ulUsedSize);

    ldc = TapiLine->DevCaps;

    //
    // Proxy fills some fields on behalf of all cm/miniports
    //
    ldc->ulPermanentLineID = 
        TapiProvider->Guid.Data1 + LineNumber;
    ldc->ulAddressModes = LINEADDRESSMODE_ADDRESSID;
    ldc->ulAnswerMode = LINEANSWERMODE_NONE;
    ldc->ulLineStates = LINEDEVSTATE_CONNECTED |
                        LINEDEVSTATE_DISCONNECTED |
                        LINEDEVSTATE_OPEN |
                        LINEDEVSTATE_CLOSE |
                        LINEDEVSTATE_INSERVICE |
                        LINEDEVSTATE_OUTOFSERVICE |
                        LINEDEVSTATE_REMOVED;
    ldc->ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
    ldc->PermanentLineGuid = TapiProvider->Guid;

    ldc->ulTotalSize =
    ldc->ulNeededSize =
        ldc->ulUsedSize;

    TapiLine->TapiProvider = TapiProvider;
    TapiLine->CmLineID = LineNumber;
    TapiLine->Flags |= LineCaps->ulFlags;
    TapiLine->DevStatus->ulTotalSize =
    TapiLine->DevStatus->ulNeededSize =
    TapiLine->DevStatus->ulUsedSize = sizeof(LINE_DEV_STATUS);
    TapiLine->ClAf = pClAf;
    TapiLine->RefCount= 1;

    //
    // Build the address table for this line
    //
    InitializeListHead(&TapiLine->AddrTable.List);

    NdisAllocateSpinLock(&TapiLine->Lock);

    TapiLine->AddrTable.Size = TapiLine->DevCaps->ulNumAddresses;

    PXDEBUGP(PXD_TAPI, PXM_TAPI,
        ("Allocated TapiLine %p LineId %d \n", TapiLine, TapiLine->CmLineID));

    for (i = 0; i < TapiLine->DevCaps->ulNumAddresses; i++) {
        PPX_TAPI_ADDR   TapiAddr;

        TapiAddr =
            AllocateTapiAddr(TapiProvider, TapiLine, i);

        if (TapiAddr == NULL) {
            FreeTapiLine(TapiLine);
            TapiLine = NULL;
            break;
        }

        //
        // Insert the address in the line's address table
        //
        TapiLine->AddrTable.Table[i] = TapiAddr;
        InsertTailList(&TapiLine->AddrTable.List,
                       &TapiAddr->Linkage);
        TapiLine->AddrTable.Count++;
    }

    PxFreeMem(EnumBuffer);

    return (TapiLine);
}


VOID
FreeTapiLine(
    PPX_TAPI_LINE   TapiLine
    )
{
    ULONG   i;

    for (i = 0; i < TapiLine->DevCaps->ulNumAddresses; i++){
        PPX_TAPI_ADDR   TapiAddr;

        //
        // Remove the address from the line table
        //
        TapiAddr = TapiLine->AddrTable.Table[i];

        if (TapiAddr != NULL) {

            RemoveEntryList(&TapiAddr->Linkage);
            TapiLine->AddrTable.Table[i] = NULL;
            TapiLine->AddrTable.Count--;

            //
            // Free the address memory
            //
            FreeTapiAddr(TapiAddr);
        }
    }

    NdisFreeSpinLock(&TapiLine->Lock);

    //
    // Free the line memory
    //
    PxFreeMem(TapiLine);
}


PPX_TAPI_ADDR
AllocateTapiAddr(
    PPX_TAPI_PROVIDER   TapiProvider,
    PPX_TAPI_LINE       TapiLine,
    ULONG               AddrID
    )
{
    PPX_TAPI_ADDR   TapiAddr;
    PUCHAR          EnumBuffer;
#if DBG
    ULONG           EnumBufferSize = PAGE_SIZE -
                                     sizeof(PXD_ALLOCATION);
#else
    ULONG           EnumBufferSize = PAGE_SIZE;
#endif
    PNDIS_REQUEST   NdisRequest;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    ULONG           SizeNeeded;
    PPX_ADAPTER     ClAdapter = TapiProvider->Adapter;
    PPX_CL_AF       pClAf = TapiProvider->ClAf;
    PX_REQUEST      ProxyRequest;
    PPX_REQUEST     pProxyRequest = &ProxyRequest;
    PLINE_ADDRESS_CAPS      ac;
    PCO_TAPI_ADDRESS_CAPS   AddrCaps;

    PxAllocMem((PCO_TAPI_ADDRESS_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMADDR_TAG);

    if (EnumBuffer == NULL){
        return(NULL);
    }

    NdisZeroMemory(EnumBuffer, EnumBufferSize);

    AddrCaps = (PCO_TAPI_ADDRESS_CAPS)EnumBuffer;
    AddrCaps->ulLineID = TapiLine->CmLineID;
    AddrCaps->ulAddressID = AddrID;

    ac = &AddrCaps->LineAddressCaps;

    ac->ulTotalSize =
        EnumBufferSize - (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS));

    //
    // If this device does not support TAPI we will
    // build a default address.
    // ToDo! Some of these values should be queried from
    // the registry on a per device basis!
    //
    if (!TapiProvider->TapiSupported){
        ac->ulTotalSize =
        ac->ulNeededSize =
        ac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
        ac->ulMaxNumActiveCalls = 1000;

    }else if (!(TapiLine->Flags & CO_TAPI_FLAG_PER_ADDRESS_CAPS) &&
              (AddrID > 0)){

        PLINE_ADDRESS_CAPS      ac1;
        PCO_TAPI_ADDRESS_CAPS   AddrCaps1;
        PPX_TAPI_ADDR           Addr1;

        //
        // If all of the addresses on this line have the same
        // caps and this is not the first address, just copy
        // the caps from the first address!
        //
        Addr1 = (PPX_TAPI_ADDR)
            TapiLine->AddrTable.List.Flink;

        ac1 = Addr1->Caps;

        if (ac1->ulTotalSize > ac->ulTotalSize){

            //
            // We don't have enough memory allocated!
            //
            PxFreeMem(EnumBuffer);

            EnumBufferSize =
                (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS) +
                ac1->ulTotalSize);

            PxAllocMem((PCO_TAPI_ADDRESS_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMADDR_TAG);

            if (EnumBuffer == NULL){
                return (NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            AddrCaps = (PCO_TAPI_ADDRESS_CAPS)EnumBuffer;
            AddrCaps->ulLineID = TapiLine->CmLineID;
            AddrCaps->ulAddressID = AddrID;
            AddrCaps->LineAddressCaps.ulTotalSize = EnumBufferSize -
                (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS));
        }

        ac = &AddrCaps->LineAddressCaps;

        NdisMoveMemory(ac, ac1, ac1->ulUsedSize);

    }else{

        NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
            NdisRequestQueryInformation;
        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_CO_TAPI_ADDRESS_CAPS;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            AddrCaps;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            EnumBufferSize;

        Status =
        NdisCoRequest(ClAdapter->ClBindingHandle,
                      pClAf->NdisAfHandle,
                      NULL,
                      NULL,
                      NdisRequest);

        if (Status == NDIS_STATUS_PENDING){
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status == NDIS_STATUS_INVALID_LENGTH){

            //
            // Our buffer was not large enough so try again
            //
            SizeNeeded =
            EnumBufferSize =
            NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

            PxFreeMem(EnumBuffer);

            PxAllocMem((PCO_TAPI_ADDRESS_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMADDR_TAG);

            if (EnumBuffer == NULL){
                return(NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            AddrCaps = (PCO_TAPI_ADDRESS_CAPS)EnumBuffer;
            AddrCaps->ulLineID = TapiLine->CmLineID;
            AddrCaps->ulAddressID = AddrID;
            AddrCaps->LineAddressCaps.ulTotalSize = EnumBufferSize -
                (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS));

            NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

            PxInitBlockStruc (&pProxyRequest->Block);

            NdisRequest = &pProxyRequest->NdisRequest;

            NdisRequest->RequestType =
                NdisRequestQueryInformation;
            NdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_ADDRESS_CAPS;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                AddrCaps;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                EnumBufferSize;

            Status =
                NdisCoRequest(ClAdapter->ClBindingHandle,
                              pClAf->NdisAfHandle,
                              NULL,
                              NULL,
                              NdisRequest);

            if (Status == NDIS_STATUS_PENDING){
                Status = PxBlock(&pProxyRequest->Block);
            }

            if (Status != NDIS_STATUS_SUCCESS){
                PxFreeMem(EnumBuffer);
                return(NULL);
            }

        }else if (Status != STATUS_SUCCESS){
            PxFreeMem(EnumBuffer);
            return(NULL);
        }
    }

    if (AddrCaps->LineAddressCaps.ulUsedSize < sizeof(LINE_ADDRESS_CAPS)) {
        AddrCaps->LineAddressCaps.ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
    }

    SizeNeeded = sizeof(PX_TAPI_ADDR);
    SizeNeeded += AddrCaps->LineAddressCaps.ulUsedSize;
    SizeNeeded += sizeof(LINE_ADDRESS_STATUS);
    SizeNeeded += 2*sizeof(PVOID);

    PxAllocMem(TapiAddr, SizeNeeded, PX_TAPIADDR_TAG);

    if (TapiAddr == NULL){
        PxFreeMem(EnumBuffer);
        return (NULL);
    }

    NdisZeroMemory((PUCHAR)TapiAddr, SizeNeeded);

    TapiAddr->Caps = (PLINE_ADDRESS_CAPS)
        ((PUCHAR)TapiAddr + sizeof(PX_TAPI_ADDR) + sizeof(PVOID));

    (ULONG_PTR)TapiAddr->Caps &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    TapiAddr->AddrStatus = (PLINE_ADDRESS_STATUS)
        ((PUCHAR)TapiAddr->Caps + 
         AddrCaps->LineAddressCaps.ulUsedSize + sizeof(PVOID));

    (ULONG_PTR)TapiAddr->AddrStatus &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    NdisMoveMemory(TapiAddr->Caps,
                   &AddrCaps->LineAddressCaps,
                   AddrCaps->LineAddressCaps.ulUsedSize);

    //
    // Proxy fills some fields on behalf of all cm/miniports
    //
    ac = TapiAddr->Caps;

    if (ac->ulTotalSize < ac->ulUsedSize) {
        ac->ulTotalSize = ac->ulUsedSize;
    }

    if (ac->ulNeededSize < ac->ulNeededSize) {
        ac->ulNeededSize = ac->ulUsedSize;
    }

    ac->ulLineDeviceID = TapiLine->ulDeviceID;
    ac->ulAddressSharing = LINEADDRESSSHARING_PRIVATE;
    ac->ulAddressStates = LINEADDRESSSTATE_NUMCALLS;
    ac->ulCallInfoStates = LINECALLINFOSTATE_BEARERMODE |
                           LINECALLINFOSTATE_RATE |
                           LINECALLINFOSTATE_MEDIAMODE;

    ac->ulCallStates = LINECALLSTATE_IDLE |
                       LINECALLSTATE_OFFERING |
                       LINECALLSTATE_ACCEPTED |
                       LINECALLSTATE_BUSY |
                       LINECALLSTATE_CONNECTED |
                       LINECALLSTATE_PROCEEDING |
                       LINECALLSTATE_DISCONNECTED;

    ac->ulDialToneModes = 0;
    ac->ulBusyModes = LINEBUSYMODE_UNAVAIL;
    ac->ulSpecialInfo = 0;

    ac->ulDisconnectModes = LINEDISCONNECTMODE_NORMAL |
                            LINEDISCONNECTMODE_BUSY |
                            LINEDISCONNECTMODE_NOANSWER;

    TapiAddr->TapiLine = TapiLine;
    TapiAddr->AddrId = AddrID;

    PxFreeMem(EnumBuffer);

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("Allocated TapiAddr %p AddrId %d for TapiLine %p\n", TapiAddr, TapiAddr->AddrId, TapiLine));

    return (TapiAddr);
}

VOID
FreeTapiAddr(
    PPX_TAPI_ADDR   TapiAddr
    )
{
    //
    // ToDo! we need to tear down all
    // active calls on this address.
    //

    PxFreeMem(TapiAddr);
}

NDIS_STATUS
AllocateTapiCallInfo(
    PPX_VC          pVc,
    LINE_CALL_INFO  UNALIGNED *LineCallInfo
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG   SizeNeeded;

    if (pVc->CallInfo) {
        PxFreeMem(pVc->CallInfo);
    }

    if (LineCallInfo != NULL) {
        SizeNeeded = LineCallInfo->ulUsedSize;
    } else {
        SizeNeeded = sizeof(LINE_CALL_INFO) + LINE_CALL_INFO_VAR_DATA_SIZE;
    }

    PxAllocMem(pVc->CallInfo, SizeNeeded, PX_LINECALLINFO_TAG);

    if (pVc->CallInfo == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    pVc->ulCallInfoFieldsChanged = 0;

    NdisZeroMemory(pVc->CallInfo, SizeNeeded);

    if (LineCallInfo != NULL) {
        NdisMoveMemory(pVc->CallInfo,
                       LineCallInfo,
                       LineCallInfo->ulUsedSize);
    } else {
        pVc->CallInfo->ulTotalSize = SizeNeeded;
        pVc->CallInfo->ulNeededSize = SizeNeeded;
        pVc->CallInfo->ulUsedSize = sizeof(LINE_CALL_INFO);
    }

    return (Status);
}

BOOLEAN
InsertVcInTable(
    PPX_VC      pVc
    )
{
    ULONG       i;
    ULONG       index;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PUCHAR      AllocatedMemory;
    LOCK_STATE  LockState;
    PPX_CL_AF   pClAf;

    NdisAcquireReadWriteLock(&VcTable.Lock, TRUE, &LockState);

    if (VcTable.Count == VcTable.Size) {
        ULONG       SizeNeeded;
        PUCHAR      AllocatedMemory;
        PPX_VC      *NewTable;

        //
        // Grow the table
        //
        SizeNeeded =
            (VcTable.Size + VcTable.Size/2) * sizeof(PPX_VC);
        PxAllocMem(AllocatedMemory, SizeNeeded, PX_VCTABLE_TAG);

        if (AllocatedMemory == NULL) {
            NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);
            return (FALSE);
        }

        RtlZeroMemory(AllocatedMemory,SizeNeeded);

        NewTable = (PPX_VC*)AllocatedMemory;

        RtlMoveMemory((PUCHAR)NewTable,
                      (PUCHAR)VcTable.Table,
                      (sizeof(PPX_VC) * VcTable.Size));

        PxFreeMem(VcTable.Table);

        VcTable.Table = NewTable;
        VcTable.Size += VcTable.Size/2;
    }

    i = VcTable.Size;
    index = VcTable.NextSlot;

    do {

        if (VcTable.Table[index] == NULL) {

            NdisDprAcquireSpinLock(&pVc->Lock);

            pVc->hdCall = index;

            VcTable.Table[index] = pVc;
            InsertTailList(&VcTable.List,
                           &pVc->Linkage);
            VcTable.Count++;
            VcTable.NextSlot =
                (VcTable.NextSlot + 1) % VcTable.Size;

            pVc->Flags |= PX_VC_IN_TABLE;
            pClAf = pVc->ClAf;

            NdisDprReleaseSpinLock(&pVc->Lock);

            PXDEBUGP(PXD_TAPI, PXM_TAPI, ("Inserting pVc %x in VcTable hdCall %d\n", pVc, pVc->hdCall));
            break;
        }
        index = (index+1) % VcTable.Size;

    } while (--i);

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    if (i != 0) {
        NdisAcquireSpinLock(&pClAf->Lock);
        REF_CL_AF(pClAf);
        InsertTailList(&pClAf->VcList, &pVc->ClAfLinkage);
        NdisReleaseSpinLock(&pClAf->Lock);
    } else {
        PXDEBUGP(PXD_TAPI,PXM_TAPI, ("Failed to insert pVc %x in VcTable\n", pVc));
    }

    return (i != 0);
}

VOID
RemoveVcFromTable(
    PPX_VC      pVc
    )
{
    LOCK_STATE  LockState;
    PPX_CL_AF   pClAf;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("Removing pVc %x from VcTable hdCall %d\n", pVc, pVc->hdCall));

    NdisAcquireReadWriteLock(&VcTable.Lock, TRUE, &LockState);

    ASSERT(VcTable.Table[pVc->hdCall] == pVc);


    VcTable.Table[pVc->hdCall] = NULL;

    VcTable.Count--;

    NdisDprAcquireSpinLock(&pVc->Lock);

    RemoveEntryList(&pVc->Linkage);

    pVc->Flags &= ~PX_VC_IN_TABLE;
    pClAf = pVc->ClAf;

    NdisDprReleaseSpinLock(&pVc->Lock);

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    NdisAcquireSpinLock(&pClAf->Lock);

    RemoveEntryList(&pVc->ClAfLinkage);

    DEREF_CL_AF_LOCKED(pClAf);
}

BOOLEAN
IsTapiLineValid(
    ULONG           hdLine,
    PPX_TAPI_LINE   *TapiLine
    )
{
    PPX_TAPI_LINE   RetLine;
    LOCK_STATE      LockState;
    ULONG           i;

    *TapiLine = NULL;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   RetLine;

        RetLine = LineTable.Table[i];

        if ((RetLine != NULL) &&
            (RetLine->hdLine == hdLine)) {
            *TapiLine = RetLine;
            NdisDprAcquireSpinLock(&RetLine->Lock);
            REF_TAPILINE(RetLine);
            NdisDprReleaseSpinLock(&RetLine->Lock);
            break;
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

    return (*TapiLine != NULL);
}


BOOLEAN
IsTapiDeviceValid(
    ULONG           ulDeviceID,
    PPX_TAPI_LINE   *TapiLine
    )
{
    LOCK_STATE  LockState;
    ULONG       i;

    *TapiLine = NULL;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   RetLine;

        RetLine = LineTable.Table[i];

        if ((RetLine != NULL) &&
            (RetLine->ulDeviceID == ulDeviceID)) {
            *TapiLine = RetLine;
            NdisDprAcquireSpinLock(&RetLine->Lock);
            REF_TAPILINE(RetLine);
            NdisDprReleaseSpinLock(&RetLine->Lock);
            break;
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

    return (*TapiLine != NULL);
}

BOOLEAN
IsVcValid(
    ULONG_PTR   CallId,
    PPX_VC      *pVc
    )
{
    PPX_VC      RetVc = NULL;
    LOCK_STATE  LockState;
    ULONG       i;

    NdisAcquireReadWriteLock(&VcTable.Lock, FALSE, &LockState);


    if (CallId < VcTable.Size) {
        RetVc = VcTable.Table[CallId];
    }

    if (RetVc != NULL) {
        NdisDprAcquireSpinLock(&RetVc->Lock);
        REF_VC(RetVc);
        NdisDprReleaseSpinLock(&RetVc->Lock);
    }

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    *pVc = RetVc;

    return (RetVc != NULL);
}

VOID
GetVcFromCtx(
    NDIS_HANDLE VcCtx,
    PPX_VC      *pVc
    )
{
    PPX_VC      RetVc = NULL;
    ULONG_PTR   i;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&VcTable.Lock, FALSE, &LockState);

    i = (ULONG_PTR)(VcCtx);

    if (i < VcTable.Size) {
        RetVc = VcTable.Table[i];
    }

    if (RetVc != NULL) {
        NdisDprAcquireSpinLock(&RetVc->Lock);
        REF_VC(RetVc);
        NdisDprReleaseSpinLock(&RetVc->Lock);
    }

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    *pVc = RetVc;
}



//
// Function assumes that the TapiLine's spinlock is held!
//
BOOLEAN
IsAddressValid(
    PPX_TAPI_LINE   TapiLine,
    ULONG           AddressId,
    PPX_TAPI_ADDR   *TapiAddr
    )
{
    PPX_TAPI_ADDR   RetAddr = NULL;

    do {

        if (AddressId >= TapiLine->AddrTable.Count) {
            break;
        }

        RetAddr = TapiLine->AddrTable.Table[AddressId];

    } while (FALSE);

    *TapiAddr = RetAddr;

    return (RetAddr != NULL);
}

BOOLEAN
GetLineFromCmLineID(
    PPX_TAPI_PROVIDER   TapiProvider,
    ULONG               CmLineID,
    PPX_TAPI_LINE       *TapiLine
    )
{
    PPX_TAPI_LINE   RetLine;

    NdisAcquireSpinLock(&TapiProvider->Lock);

    RetLine = (PPX_TAPI_LINE)
        TapiProvider->LineList.Flink;

    while ((PVOID)RetLine != (PVOID)&TapiProvider->LineList) {

        if ((RetLine->CmLineID == CmLineID) &&
            (RetLine->DevStatus->ulNumOpens != 0)) {
            break;
        }

        RetLine = (PPX_TAPI_LINE)
            RetLine->Linkage.Flink;
    }
    
    if ((PVOID)RetLine == (PVOID)&TapiProvider->LineList) {
        RetLine = NULL;
    }

    NdisReleaseSpinLock(&TapiProvider->Lock);

    *TapiLine = RetLine;

    return (RetLine != NULL);
}

BOOLEAN
GetAvailLineFromProvider(
    PPX_TAPI_PROVIDER   TapiProvider,
    PPX_TAPI_LINE       *TapiLine,
    PPX_TAPI_ADDR       *TapiAddr
    )
{
    LOCK_STATE      LockState;
    ULONG           i;
    PPX_TAPI_LINE   tl;

    NdisAcquireSpinLock(&TapiProvider->Lock);

    tl = (PPX_TAPI_LINE)TapiProvider->LineList.Flink;

    while ((PVOID)tl != (PVOID)&TapiProvider->LineList) {
        PTAPI_ADDR_TABLE    AddrTable;
        PPX_TAPI_ADDR       ta;

        NdisDprAcquireSpinLock(&tl->Lock);

        if (tl->DevStatus->ulNumOpens != 0) {

            AddrTable = &tl->AddrTable;
            ta = (PPX_TAPI_ADDR)AddrTable->List.Flink;

            //
            // Walk the addresses on this line
            //
            while ((PVOID)ta != (PVOID)&AddrTable->List) {

                //
                // If this address has a callcount that is
                // < then the max num it supports, add another
                // call on this address!
                //
                if (ta->CallCount < ta->Caps->ulMaxNumActiveCalls) {

                    *TapiLine = tl;
                    *TapiAddr = ta;

                    NdisDprReleaseSpinLock(&tl->Lock);

                    NdisReleaseSpinLock(&TapiProvider->Lock);

                    return (TRUE);
                }

                ta = (PPX_TAPI_ADDR)ta->Linkage.Flink;
            }
        }

        NdisDprReleaseSpinLock(&tl->Lock);

        tl = (PPX_TAPI_LINE)tl->Linkage.Flink;
    }

    NdisReleaseSpinLock(&TapiProvider->Lock);

    return (FALSE);
}

//
// Function assumes that the TapiLine's spinlock is held!
//
PPX_TAPI_ADDR
GetAvailAddrFromLine(
    PPX_TAPI_LINE   TapiLine
    )
{
    PPX_TAPI_ADDR       TapiAddr;
    PTAPI_ADDR_TABLE    AddrTable;

    AddrTable = &TapiLine->AddrTable;
    TapiAddr = (PPX_TAPI_ADDR)AddrTable->List.Flink;

    //
    // Walk the addresses on this line
    //
    while ((PVOID)TapiAddr != (PVOID)&AddrTable->List) {

        //
        // If this address has a callcount that is
        // < then the max num it supports, add another
        // call on this address!
        //
        if (TapiAddr->CallCount < 
            TapiAddr->Caps->ulMaxNumActiveCalls) {

            return (TapiAddr);
        }

        TapiAddr = (PPX_TAPI_ADDR)TapiAddr->Linkage.Flink;
    }

    return (NULL);
}

BOOLEAN
InsertLineInTable(
    PPX_TAPI_LINE   TapiLine
    )
{
    ULONG       i;
    ULONG       index;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PUCHAR      AllocatedMemory;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&LineTable.Lock, TRUE, &LockState);

    if (LineTable.Count == LineTable.Size) {
        ULONG           SizeNeeded;
        PUCHAR          AllocatedMemory;
        PPX_TAPI_LINE   *NewTable;

        //
        // Grow the table
        //
        SizeNeeded =
            (LineTable.Size + LineTable.Size/2) * sizeof(PPX_TAPI_LINE);
        PxAllocMem(AllocatedMemory, SizeNeeded, PX_LINETABLE_TAG);

        if (AllocatedMemory == NULL) {
            NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
            return (FALSE);
        }

        RtlZeroMemory(AllocatedMemory,SizeNeeded);

        NewTable = (PPX_TAPI_LINE*)AllocatedMemory;

        RtlMoveMemory((PUCHAR)NewTable,
                      (PUCHAR)LineTable.Table,
                      (sizeof(PPX_TAPI_LINE) * LineTable.Size));

        PxFreeMem(LineTable.Table);

        LineTable.Table = NewTable;
        LineTable.Size += LineTable.Size/2;
    }

    i = LineTable.Size;
    index = LineTable.NextSlot;

    do {

        if (LineTable.Table[index] == NULL) {

            TapiLine->hdLine = index;
            TapiLine->Flags |= PX_LINE_IN_TABLE;
            LineTable.Table[index] = TapiLine;
            LineTable.Count++;
            LineTable.NextSlot =
                (LineTable.NextSlot + 1) % LineTable.Size;

            PXDEBUGP(PXD_TAPI, PXM_TAPI,
                ("Inserting TapiLine %p in LineTable hdCall %d\n", TapiLine, TapiLine->hdLine));
            break;
        }
        index = (index+1) % LineTable.Size;

    } while (--i);

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

#if DBG
    if (i == 0) {
        PXDEBUGP(PXD_TAPI,PXM_TAPI,
            ("Failed to insert TapiLine %p in LineTable\n", TapiLine));
    }
#endif

    return (i != 0);
}

VOID
RemoveTapiLineFromTable(
    PPX_TAPI_LINE   TapiLine
    )
{
    LOCK_STATE  LockState;

    PXDEBUGP(PXD_TAPI, PXM_TAPI,
        ("Removing TapiLine %p from LineTable hdCall %d\n", TapiLine, TapiLine->hdLine));

    NdisAcquireReadWriteLock(&LineTable.Lock, TRUE, &LockState);

    ASSERT(LineTable.Table[TapiLine->hdLine] == TapiLine);

    LineTable.Table[TapiLine->hdLine] = NULL;

    TapiLine->Flags &= ~PX_LINE_IN_TABLE;

    LineTable.Count--;

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

NDIS_STATUS
PxVcCleanup(
    PPX_VC  pVc,
    ULONG   Flags
    )
{
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_TAPI, 
             ("PxVcCleanup: Vc %p, State: %x, HandoffState: %x VcFlags: %x, NewFlags: %x\n",
              pVc, pVc->State, pVc->HandoffState, Flags, pVc->Flags, Flags));

    //
    // Terminate Digit Gathering or Monitoring.
    //

    if (pVc->ulMonitorDigitsModes != 0) {
        NdisReleaseSpinLock(&pVc->Lock);
        PxStopDigitReporting(pVc);
        NdisAcquireSpinLock(&pVc->Lock);

        pVc->ulMonitorDigitsModes = 0;        
    } else if (pVc->PendingGatherDigits != NULL) {
        PNDISTAPI_REQUEST pNdisTapiRequest = pVc->PendingGatherDigits;

        pVc->PendingGatherDigits = NULL;
        PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_CANCEL);        
    }

    switch (pVc->State) {
        case PX_VC_IDLE:
            //
            // Already idle do nothing.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        case PX_VC_PROCEEDING:
            //
            // We have an outgoing call, when it completes close
            // it down with ndis and complete the drop when
            // in PxClCloseCallComplete.
            // 
            pVc->PrevState = pVc->State;
            pVc->State = PX_VC_DISCONNECTING;

            //
            // Attempt to close the call directly
            // if this fails we will cleanup when
            // the outgoing call completes
            //
            pVc->Flags |= (PX_VC_OUTCALL_ABORTING | 
                           PX_VC_CLEANUP_CM |
                           Flags);

            PxCloseCallWithCm(pVc);

            Status = NDIS_STATUS_PENDING;
            break;

        case PX_VC_OFFERING:
            //
            // We have an incoming call offered to tapi.  Close
            // it down now by calling it's callcomplete handler
            // with a non-success value.
            //
            pVc->Flags |= (Flags | 
                           PX_VC_INCALL_ABORTING);

            pVc->PrevState = pVc->State;

            if (pVc->Flags & PX_VC_CLEANUP_CM) {
                pVc->State= PX_VC_DISCONNECTING;
            } else {
                pVc->State = PX_VC_IDLE;
            }

            if (pVc->Flags & PX_VC_CALLTIMER_STARTED) {
                PxStopIncomingCallTimeout(pVc);
            }


            NdisReleaseSpinLock(&pVc->Lock);

            NdisClIncomingCallComplete(NDIS_STATUS_FAILURE,
                                       pVc->ClVcHandle,
                                       pVc->pCallParameters);

            NdisAcquireSpinLock(&pVc->Lock);

            if (pVc->Flags & PX_VC_CLEANUP_CM) {

                PxCloseCallWithCm(pVc);

            } else {
                SendTapiCallState(pVc,
                                  LINECALLSTATE_DISCONNECTED,
                                  0,
                                  pVc->CallInfo->ulMediaMode);

                //
                // Remove the ref applied in PxClIncomingCall.
                // Don't use the full deref code here as the
                // ref applied when we mapped the vc will
                // keep the vc around.
                //
                pVc->RefCount--;
            }

            Status = NDIS_STATUS_SUCCESS;


            break;

        case PX_VC_DISCONNECTING:
            pVc->Flags |= (Flags);
            Status = NDIS_STATUS_PENDING;
            break;

        case PX_VC_CONNECTED:
            //
            // We have a call that needs to be closed with ndis.
            // This may include dropping the call with a client
            // depending on the handoff state.  Complete the drop
            // irp in PxClCloseCallComplete
            //
            if (!(pVc->Flags & PX_VC_DROP_PENDING)) {

                pVc->PrevState = pVc->State;
                pVc->State = PX_VC_DISCONNECTING;

                pVc->Flags |= (Flags | PX_VC_CLEANUP_CM);

                Status =
                    PxCloseCallWithCl(pVc);

                if (Status != NDIS_STATUS_PENDING) {
                    PxCloseCallWithCm(pVc);
                }
            }

            Status = NDIS_STATUS_PENDING;

            break;

        default:
            PXDEBUGP(PXD_FATAL, PXM_TAPI, 
                     ("PxVcCleanup: Invalid VcState! Vc: %p VcState: %x CallState: %x\n",
                      pVc, pVc->State, pVc->ulCallState ));

            Status = NDIS_STATUS_FAILURE;
            ASSERT(0);
            break;
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxtypes.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxtypes.h

Abstract:

    Structures for ndproxy.sys

Author:

    Tony Bell    


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/04/99        Created

--*/

#ifndef _PXTYPES__H
#define _PXTYPES__H

//
// Generic structs...
//
typedef struct _PxBlockStruc{
    NDIS_EVENT      Event;
    NDIS_STATUS     Status;
} PxBlockStruc, *PPxBlockStruc;

typedef struct _PX_REQUEST{
    NDIS_REQUEST    NdisRequest;
    ULONG           Flags;
#define PX_REQ_ASYNC    0x00000001
    PxBlockStruc    Block;
} PX_REQUEST, *PPX_REQUEST;

//
// Data structures to help run through the many variable length fields
// defined in the NDIS_TAPI_MAKE_CALL structure.
//
typedef struct _PXTAPI_CALL_PARAM_ENTRY {
    ULONG_PTR           SizePointer;
    ULONG_PTR           OffsetPointer;

} PXTAPI_CALL_PARAM_ENTRY, *PPXTAPI_CALL_PARAM_ENTRY;

#define PX_TCP_ENTRY(_SizeName, _OffsetName)                    \
{                                                               \
    FIELD_OFFSET(struct _LINE_CALL_PARAMS, _SizeName),          \
    FIELD_OFFSET(struct _LINE_CALL_PARAMS, _OffsetName)         \
}

//
// Data structures to help run through the many variable length fields
// defined in the LINE_CALL_INFO structure.
//
typedef struct _PXTAPI_CALL_INFO_ENTRY {
    ULONG_PTR           SizePointer;
    ULONG_PTR           OffsetPointer;

} PXTAPI_CALL_INFO_ENTRY, *PPXTAPI_CALL_INFO_ENTRY;

#define PX_TCI_ENTRY(_SizeName, _OffsetName)                    \
{                                                               \
    FIELD_OFFSET(struct _LINE_CALL_INFO, _SizeName),            \
    FIELD_OFFSET(struct _LINE_CALL_INFO, _OffsetName)           \
}

//
//
//
// Start of TAPI stuff
//
//
//
typedef struct  _OID_DISPATCH {
    ULONG       Oid;
    UINT SizeofStruct;
    NDIS_STATUS  (*FuncPtr)();
} OID_DISPATCH;


//
// This table contains all of the tapi addresses on a line.
// One of these is embedded in each tapi_line struct.
//
typedef struct _TAPI_ADDR_TABLE {
    ULONG                   Count;          // # of addresses in table
    ULONG                   Size;           // size of table (# of possible
                                            // addresses)
    LIST_ENTRY              List;
    struct _PX_TAPI_ADDR    **Table;
} TAPI_ADDR_TABLE, *PTAPI_ADDR_TABLE;

//
// This structure contains all of the information that defines
// a tapi line in tapi space.  One of these is created for
// each line that a device exposes.
//
typedef struct _PX_TAPI_LINE {
    LIST_ENTRY              Linkage;
    ULONG                   RefCount;
    struct _PX_TAPI_PROVIDER    *TapiProvider;
    ULONG                   ulDeviceID;     // Id of line in tapi space
                                            // (tapi baseid based)
    ULONG                   Flags;
#define PX_LINE_IN_TABLE    0x00000001

    HTAPI_LINE              htLine;         // tapi's line handle
    ULONG                   hdLine;         // our line handle (index into
                                            // provider's line table)
    ULONG                   CmLineID;       // call managers index (0 based)
    struct _PX_CL_AF        *ClAf;
    struct _PX_CL_SAP       *ClSap;

    PLINE_DEV_CAPS          DevCaps;
    PLINE_DEV_STATUS        DevStatus;
    TAPI_ADDR_TABLE         AddrTable;
    NDIS_SPIN_LOCK          Lock;
}PX_TAPI_LINE, *PPX_TAPI_LINE;

typedef struct _PX_TAPI_ADDR {
    LIST_ENTRY              Linkage;
    ULONG                   RefCount;
    struct _PX_TAPI_LINE    *TapiLine;
    ULONG                   AddrId;         // Id of address, same for both
                                            // tapi and adapter (0 based)
    ULONG                   CallCount;      // # of active calls on list
    PLINE_ADDRESS_CAPS      Caps;
    PLINE_ADDRESS_STATUS    AddrStatus;
}PX_TAPI_ADDR, *PPX_TAPI_ADDR;

typedef struct _TAPI_LINE_TABLE {
    ULONG                   Count;          // # of lines in table
    ULONG                   Size;           // size of table
                                            // (# of possible lines)
    ULONG                   NextSlot;       // next avail index
    struct _PX_TAPI_LINE    **Table;
    NDIS_RW_LOCK            Lock;
} TAPI_LINE_TABLE, *PTAPI_LINE_TABLE;

typedef struct _VC_TABLE {
    ULONG                   Count;          // # of calls in table
    ULONG                   Size;           // size of table (# of possible
                                            // calls)
    ULONG                   NextSlot;       // next avail index
    LIST_ENTRY              List;           // list of calls
    struct _PX_VC           **Table;
    NDIS_RW_LOCK            Lock;
} VC_TABLE, *PVC_TABLE;

typedef struct _PX_TAPI_PROVIDER {
    LIST_ENTRY          Linkage;        // Linkage into tspcb
    PROVIDER_STATUS     Status;         // provider status
    struct _PX_ADAPTER  *Adapter;       // adapter providing for
    struct _PX_CL_AF    *ClAf;          // address family
    LIST_ENTRY          LineList;       // list of lines
    LIST_ENTRY          CreateList;     // list of lines with
                                        // outstanding line creates
    ULONG               NumDevices;     // 
    ULONG_PTR           TempID;
    ULONG               CreateCount;
    ULONG               TapiFlags;
    ULONG               CoTapiVersion;
    BOOLEAN             TapiSupported;
    GUID                Guid;
    CO_ADDRESS_FAMILY   Af;
    NDIS_SPIN_LOCK      Lock;
} PX_TAPI_PROVIDER, *PPX_TAPI_PROVIDER;

typedef struct _TAPI_TSP_CB {
    NDISTAPI_STATUS Status;
    ULONG           htCall;
    LIST_ENTRY      ProviderList;
    ULONG           NdisTapiNumDevices;
    ULONG           ulUniqueId;          // to generate ID for each TAPI request
    ULONG           RefCount;
    NDIS_SPIN_LOCK  Lock;               // SpinLock for this structure
} TAPI_TSP_CB, *PTAPI_TSP_CB;

typedef struct _PROVIDER_EVENT {
    LIST_ENTRY  Linkage;                // List linkage
    NDIS_TAPI_EVENT Event;              // Event structure
}PROVIDER_EVENT, *PPROVIDER_EVENT;

typedef struct _TSP_EVENT_LIST {
    LIST_ENTRY      List;
    ULONG           Count;
    ULONG           MaxCount;
    PIRP            RequestIrp;
    NDIS_SPIN_LOCK  Lock;
} TSP_EVENT_LIST, *PTSP_EVENT_LIST;

typedef struct _PX_DEVICE_EXTENSION {
    UINT            RefCount;
    PDRIVER_OBJECT  pDriverObject;      // passed in DriverEntry
    PDEVICE_OBJECT  pDeviceObject;      // created by IoCreateDevice
    NDIS_HANDLE     PxProtocolHandle;   // Set by NdisRegisterProtocol
    LIST_ENTRY      AdapterList;
    ULONG           RegistryFlags;
    ULONG           ADSLTxRate;
    ULONG           ADSLRxRate;
    NDIS_EVENT      NdisEvent;          // sync registerprotocol/bindadapter handler
    NDIS_SPIN_LOCK  Lock;
} PX_DEVICE_EXTENSION, *PPX_DEVICE_EXTENSION;


//
//  We allocate one PX_ADAPTER structure for each adapter that
//  the Proxy opens. A pointer to this structure is passed to NdisOpenAdapter
//  as the ProtocolBindingContext.
//  The adapter is referenced for:
//      Successful bind
//      Client opening an address family on it
//      Proxy Cl part opening an address family on it
//
typedef struct _PX_ADAPTER {
    LIST_ENTRY              Linkage;
    ULONG                   Sig;
#define PX_ADAPTER_SIG      '  mC'
    PX_ADAPTER_STATE        State;
    ULONG                   RefCount;
    ULONG                   Flags;
#define PX_CMAF_REGISTERING 0x00000001
#define PX_CMAF_REGISTERED  0x00000002

    //
    // Proxy as Client stuff
    //
    NDIS_HANDLE             ClBindingHandle;    // set by NdisOpenAdapter
    LIST_ENTRY              ClAfList;
    LIST_ENTRY              ClAfClosingList;

    //
    // Proxy as Call Manager stuff
    //
    NDIS_HANDLE             CmBindingHandle;    // set by NdisOpenAdapter
    LIST_ENTRY              CmAfList;
    LIST_ENTRY              CmAfClosingList;

    NDIS_HANDLE             UnbindContext;
    NDIS_STATUS             ndisStatus;
    KEVENT                  event;
    GUID                    Guid;
    NDIS_MEDIUM             MediaType;
    NDIS_WAN_MEDIUM_SUBTYPE MediumSubType;
    NDIS_STRING             DeviceName;         // Used to check bound adapters
    ULONG                   MediaNameLength;
    WCHAR                   MediaName[128];
    PxBlockStruc            ClCloseEvent;
    PxBlockStruc            CmCloseEvent;
    PxBlockStruc            OpenEvent;
    PxBlockStruc            BindEvent;
    PxBlockStruc            AfRegisterEvent;
    ULONG                   AfRegisteringCount; // pending calls to NdisCmRegisterAF
    NDIS_SPIN_LOCK          Lock;
} PX_ADAPTER, *PPX_ADAPTER;


//
// The CM_AF is created for each AddressFamily that the
// proxy exposes to the CoNDIS clients
//
typedef struct _PX_CM_AF {
    LIST_ENTRY          Linkage;
    PX_AF_STATE         State;
    ULONG               RefCount;

    NDIS_HANDLE         NdisAfHandle;
    struct _PX_ADAPTER  *Adapter;

    LIST_ENTRY          CmSapList;
    LIST_ENTRY          VcList;

    CO_ADDRESS_FAMILY   Af;

    NDIS_SPIN_LOCK      Lock;
} PX_CM_AF, *PPX_CM_AF;

//
// Function Prototypes for function ptrs
//
typedef
NDIS_STATUS
(*AF_SPECIFIC_GET_NDIS_CALL_PARAMS)(
    IN  struct _PX_VC           *pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    TapiBuffer,
    OUT PCO_CALL_PARAMETERS     *pNdisCallParameters
    );

typedef
NDIS_STATUS
(*AF_SPECIFIC_GET_TAPI_CALL_PARAMS)(
    IN struct _PX_VC        *pProxyVc,
    IN PCO_CALL_PARAMETERS  pCallParams
    );

typedef
struct _PX_CL_SAP*
(*AF_SPECIFIC_GET_NDIS_SAP)(
    IN  struct _PX_CL_AF        *pClAf,
    IN  struct _PX_TAPI_LINE    *TapiLine
    );

//
// The CL_AF is created for each address family that the
// proxy opens.  There could be multiple address families
// per adapter.
//
typedef struct _PX_CL_AF {
    LIST_ENTRY          Linkage;
    PX_AF_STATE         State;
    ULONG               RefCount;

    NDIS_HANDLE         NdisAfHandle;
    struct _PX_ADAPTER  *Adapter;

    LIST_ENTRY          ClSapList;
    LIST_ENTRY          ClSapClosingList;

    LIST_ENTRY          VcList;
    LIST_ENTRY          VcClosingList;

    PPX_TAPI_PROVIDER   TapiProvider;

    //
    // Moves call params from NDIS to TAPI
    //
    AF_SPECIFIC_GET_NDIS_CALL_PARAMS    AfGetNdisCallParams;
    AF_SPECIFIC_GET_TAPI_CALL_PARAMS    AfGetTapiCallParams;
    AF_SPECIFIC_GET_NDIS_SAP            AfGetNdisSap;
    ULONG                               NdisCallParamSize;

    CO_ADDRESS_FAMILY   Af;
    PxBlockStruc        Block;
    NDIS_SPIN_LOCK      Lock;
} PX_CL_AF, *PPX_CL_AF;

typedef struct _PX_CL_SAP {
    LIST_ENTRY              Linkage;
    PX_SAP_STATE            State;
    ULONG                   Flags;
    ULONG                   RefCount;
    struct _PX_CL_AF        *ClAf;
    struct _PX_TAPI_LINE    *TapiLine;
    ULONG                   MediaModes;
    NDIS_HANDLE             NdisSapHandle;
    PCO_SAP                 CoSap;
} PX_CL_SAP, *PPX_CL_SAP;

typedef struct _PX_CM_SAP {
    LIST_ENTRY          Linkage;
    PX_SAP_STATE        State;
    ULONG               Flags;
    ULONG               RefCount;
    struct _PX_CM_AF   *CmAf;
    NDIS_HANDLE         NdisSapHandle;
    PCO_SAP             CoSap;
} PX_CM_SAP, *PPX_CM_SAP;

typedef struct _PX_VC {
    LIST_ENTRY              Linkage;        // Vc is linked into global table

    PX_VC_STATE             State;          // Vc's state (with call manager)
    PX_VC_STATE             PrevState;      // Vc's previous state
    PX_VC_HANDOFF_STATE     HandoffState;   // Vc's state (with client)
    ULONG                   RefCount;       // Reference Count
    ULONG                   Flags;          //
#define PX_VC_OWNER             0x00000001
#define PX_VC_IN_TABLE          0x00000002
#define PX_VC_CALLTIMER_STARTED 0x00000004
#define PX_VC_CLEANUP_CM        0x00000008
#define PX_VC_DROP_PENDING      0x00000010
#define PX_VC_INCALL_ABORTING   0x00000020
#define PX_VC_INCALL_ABORTED    0x00000040
#define PX_VC_OUTCALL_ABORTING  0x00000080
#define PX_VC_OUTCALL_ABORTED   0x00000100


    ULONG                   CloseFlags;
#define PX_VC_INCOMING_CLOSE    0x00000001
#define PX_VC_TAPI_DROP         0x00000002
#define PX_VC_TAPI_CLOSECALL    0x00000004
#define PX_VC_TAPI_CLOSE        0x00000008
#define PX_VC_UNBIND            0x00000010
#define PX_VC_CLOSE_AF          0x00000020
#define PX_VC_INCALL_TIMEOUT    0x00000040
#define PX_VC_CL_CLOSE_CALL     0x00000080
#define PX_VC_CM_CLOSE_REQ      0x00000100
#define PX_VC_CM_CLOSE_COMP     0x00000200
#define PX_VC_CM_CLOSE_FAIL     0x00000400

    //
    // Proxy as Client stuff
    //
    NDIS_HANDLE             ClVcHandle;     // Vc Handle (as Client)
    struct _PX_CL_SAP       *ClSap;         // Sap (incoming only)
    struct _PX_CL_AF        *ClAf;          // Adress family

    //
    // Proxy as Call Manager stuff
    //
    NDIS_HANDLE             CmVcHandle;     // Vc Handle (as cm)
    struct _PX_CM_SAP       *CmSap;         // Sap
    struct _PX_CM_AF        *CmAf;          // Address family

    struct _PX_ADAPTER      *Adapter;       // Adapter

    //
    // Tapi stuff
    //
    LIST_ENTRY              PendingDropReqs;   // list of pended drop requests
    
    struct _NDISTAPI_REQUEST    *PendingGatherDigits;
    NDIS_TIMER                  DigitTimer;
    ULONG                       ulMonitorDigitsModes;

    struct _PX_TAPI_LINE    *TapiLine;      // associated line
    struct _PX_TAPI_ADDR    *TapiAddr;      // associated address
    HTAPI_CALL              htCall;         // tapi's call handle
    HDRV_CALL               hdCall;         // our call handle (index into
                                            // the global vc table)

    ULONG                   ulCallInfoFieldsChanged;
    ULONG                   ulCallState;
    ULONG                   ulCallStateMode;
    PLINE_CALL_INFO         CallInfo;

    PCO_CALL_PARAMETERS     pCallParameters;

    NDIS_TIMER              InCallTimer;

    PxBlockStruc            Block;
    LIST_ENTRY              ClAfLinkage;
    LIST_ENTRY              CmAfLinkage;
    NDIS_SPIN_LOCK          Lock;               // Spinlock
} PX_VC, *PPX_VC;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]\n"
        ,"  help      - Prints short help text on all commands.\n"
         "  help -v   - Prints long help text on all commands.\n"
         "  help cmd  - Prints long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   dso
        ,"dso <struct> [field] [address]\n"
        ,"  - Dumps struct offsets and values, e.g:\n"
         "      dso PX_ADAPTER 806955b0\n"
         "      available structs:\n"
         "      PX_TAPI_LINE\n"
         "      PX_TAPI_ADDR\n"
         "      PX_TAPI_PROVIDER\n"
         "      TAPI_TSP_CB\n"
         "      TAPI_LINE_TABLE\n"
         "      TAPI_ADDR_TABLE\n"
         "      LINE_DEV_CAPS\n"
         "      LINE_ADDRESS_CAPS\n"
         "      LINE_ADDRESS_STATUS\n"
         "      LINE_DEV_STATUS\n"
         "      TSP_EVENT_LIST\n"
         "      VC_TABLE\n"
         "      PX_DEVICE_EXTENSION\n"
         "      PX_ADAPTER\n"
         "      PX_CM_AF\n"
         "      PX_CM_SAP\n"
         "      PX_CL_AF\n"
         "      PX_CL_SAP\n"
         "      PX_VC\n"
        ,""
        ,CUSTOM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <ntdbg.h>
#include <ntsdexts.h>
//#define NOEXTAPI
#include <wdbgexts.h>
#include <ntverp.h>
//#include <stdexts.h>

//
// globals
//
//EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
USHORT                 usProcessorArchitecture;
BOOL                   bDebuggingChecked;

PSZ szProcessorArchitecture[] = {
    "Intel",
    "MIPS",
    "Alpha",
    "PPC"
};
#define cArchitecture (sizeof(szProcessorArchitecture) / sizeof(PSZ))

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ULONG offKeProcessorArchitecture;
    ULONG Result;

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
    usProcessorArchitecture = (USHORT)-1;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\makefile.inc ===
pxext.c:  pxext.h

precomp.h:  pxext.h

pxext.pph:    pxext.h
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $(C_DEFINES) $** > $@

dsotable.c: pxext.pph pxext.txt dsocode.c
    @echo Creating $@
    structo -i h -p -s pxext.txt -o $@ pxext.pph

clean:
    del dsotable.c pxext.pph
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxtapi.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    Pctapi.h

Abstract:

    The module defines the TAPI data for
    the NDIS Proxy. It includes ndistapi.h (which contains data from tapi.h) and adds
	further definitions from tspi.h. We don't include tspi.h directly as it won't work for us.

Author:

	Richard Machin (RMachin)


Revision History:

    Who         When          	What
    --------    --------      	----------------------------------------------
    RMachin     01-13-97       	created (a *lot* of typing saved by Dan Knudson's
								Example Simple Pbx SP)

--*/
#ifndef _PX_TAPI_
#define _PX_TAPI_

#include "ndistapi.h"

//
// LINE stuff from tapi.h
//

#ifndef DECLARE_OPAQUE32
#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name
#endif  // DECLARE_OPAQUE32


DECLARE_OPAQUE32(HDRVCALL);
DECLARE_OPAQUE32(HDRVLINE);

typedef HDRVCALL FAR * LPHDRVCALL;
typedef HDRVLINE FAR * LPHDRVLINE;

DECLARE_OPAQUE32(HTAPICALL);
DECLARE_OPAQUE32(HTAPILINE);

typedef HTAPICALL FAR * LPHTAPICALL;
typedef HTAPILINE FAR * LPHTAPILINE;

//
// from TAPI.H
//
#define LINE_REMOVE                25L             // TAPI v2.0

#define ALL_ADDRESS_FEATURES       (LINEADDRFEATURE_FORWARD          | \
                                    LINEADDRFEATURE_MAKECALL         | \
                                    LINEADDRFEATURE_PICKUP           | \
                                    LINEADDRFEATURE_SETMEDIACONTROL  | \
                                    LINEADDRFEATURE_SETTERMINAL      | \
                                    LINEADDRFEATURE_SETUPCONF        | \
                                    LINEADDRFEATURE_UNCOMPLETECALL   | \
                                    LINEADDRFEATURE_UNPARK)
#define ALL_ADDRESS_MODES          (LINEADDRESSMODE_ADDRESSID        | \
                                    LINEADDRESSMODE_DIALABLEADDR)
#define ALL_ADDRESS_STATES         (LINEADDRESSSTATE_OTHER           | \
                                    LINEADDRESSSTATE_DEVSPECIFIC     | \
                                    LINEADDRESSSTATE_INUSEZERO       | \
                                    LINEADDRESSSTATE_INUSEONE        | \
                                    LINEADDRESSSTATE_INUSEMANY       | \
                                    LINEADDRESSSTATE_NUMCALLS        | \
                                    LINEADDRESSSTATE_FORWARD         | \
                                    LINEADDRESSSTATE_TERMINALS       | \
                                    LINEADDRESSSTATE_CAPSCHANGE)
#define ALL_BEARER_MODES           (LINEBEARERMODE_VOICE             | \
                                    LINEBEARERMODE_SPEECH            | \
                                    LINEBEARERMODE_MULTIUSE          | \
                                    LINEBEARERMODE_DATA              | \
                                    LINEBEARERMODE_ALTSPEECHDATA     | \
                                    LINEBEARERMODE_NONCALLSIGNALING  | \
                                    LINEBEARERMODE_PASSTHROUGH)
#define ALL_BUSY_MODES             (LINEBUSYMODE_STATION             | \
                                    LINEBUSYMODE_TRUNK               | \
                                    LINEBUSYMODE_UNKNOWN             | \
                                    LINEBUSYMODE_UNAVAIL)
#define ALL_CALL_FEATURES          (LINECALLFEATURE_ACCEPT           | \
                                    LINECALLFEATURE_ADDTOCONF        | \
                                    LINECALLFEATURE_ANSWER           | \
                                    LINECALLFEATURE_BLINDTRANSFER    | \
                                    LINECALLFEATURE_COMPLETECALL     | \
                                    LINECALLFEATURE_COMPLETETRANSF   | \
                                    LINECALLFEATURE_DIAL             | \
                                    LINECALLFEATURE_DROP             | \
                                    LINECALLFEATURE_GATHERDIGITS     | \
                                    LINECALLFEATURE_GENERATEDIGITS   | \
                                    LINECALLFEATURE_GENERATETONE     | \
                                    LINECALLFEATURE_HOLD             | \
                                    LINECALLFEATURE_MONITORDIGITS    | \
                                    LINECALLFEATURE_MONITORMEDIA     | \
                                    LINECALLFEATURE_MONITORTONES     | \
                                    LINECALLFEATURE_PARK             | \
                                    LINECALLFEATURE_PREPAREADDCONF   | \
                                    LINECALLFEATURE_REDIRECT         | \
                                    LINECALLFEATURE_REMOVEFROMCONF   | \
                                    LINECALLFEATURE_SECURECALL       | \
                                    LINECALLFEATURE_SENDUSERUSER     | \
                                    LINECALLFEATURE_SETCALLPARAMS    | \
                                    LINECALLFEATURE_SETMEDIACONTROL  | \
                                    LINECALLFEATURE_SETTERMINAL      | \
                                    LINECALLFEATURE_SETUPCONF        | \
                                    LINECALLFEATURE_SETUPTRANSFER    | \
                                    LINECALLFEATURE_SWAPHOLD         | \
                                    LINECALLFEATURE_UNHOLD           | \
                                    LINECALLFEATURE_RELEASEUSERUSERINFO)
#define ALL_CALL_INFO_STATES       (LINECALLINFOSTATE_OTHER          | \
                                    LINECALLINFOSTATE_DEVSPECIFIC    | \
                                    LINECALLINFOSTATE_BEARERMODE     | \
                                    LINECALLINFOSTATE_RATE           | \
                                    LINECALLINFOSTATE_MEDIAMODE      | \
                                    LINECALLINFOSTATE_APPSPECIFIC    | \
                                    LINECALLINFOSTATE_CALLID         | \
                                    LINECALLINFOSTATE_RELATEDCALLID  | \
                                    LINECALLINFOSTATE_ORIGIN         | \
                                    LINECALLINFOSTATE_REASON         | \
                                    LINECALLINFOSTATE_COMPLETIONID   | \
                                    LINECALLINFOSTATE_TRUNK          | \
                                    LINECALLINFOSTATE_CALLERID       | \
                                    LINECALLINFOSTATE_CALLEDID       | \
                                    LINECALLINFOSTATE_CONNECTEDID    | \
                                    LINECALLINFOSTATE_REDIRECTIONID  | \
                                    LINECALLINFOSTATE_REDIRECTINGID  | \
                                    LINECALLINFOSTATE_DISPLAY        | \
                                    LINECALLINFOSTATE_USERUSERINFO   | \
                                    LINECALLINFOSTATE_HIGHLEVELCOMP  | \
                                    LINECALLINFOSTATE_LOWLEVELCOMP   | \
                                    LINECALLINFOSTATE_CHARGINGINFO   | \
                                    LINECALLINFOSTATE_TERMINAL       | \
                                    LINECALLINFOSTATE_DIALPARAMS     | \
                                    LINECALLINFOSTATE_MONITORMODES)
                                    //LINECALLINFOSTATE_NUMMONITORS not SP flag
                                    //LINECALLINFOSTATE_NUMOWNERINCR not SP flag
                                    //LINECALLINFOSTATE_NUMOWNERDECR not SP flag
#define ALL_CALL_PARTY_ID_FLAGS    (LINECALLPARTYID_BLOCKED          | \
                                    LINECALLPARTYID_OUTOFAREA        | \
                                    LINECALLPARTYID_NAME             | \
                                    LINECALLPARTYID_ADDRESS          | \
                                    LINECALLPARTYID_PARTIAL          | \
                                    LINECALLPARTYID_UNKNOWN          | \
                                    LINECALLPARTYID_UNAVAIL)
#define ALL_CALL_STATES            (LINECALLSTATE_IDLE               | \
                                    LINECALLSTATE_OFFERING           | \
                                    LINECALLSTATE_ACCEPTED           | \
                                    LINECALLSTATE_DIALTONE           | \
                                    LINECALLSTATE_DIALING            | \
                                    LINECALLSTATE_RINGBACK           | \
                                    LINECALLSTATE_BUSY               | \
                                    LINECALLSTATE_SPECIALINFO        | \
                                    LINECALLSTATE_CONNECTED          | \
                                    LINECALLSTATE_PROCEEDING         | \
                                    LINECALLSTATE_ONHOLD             | \
                                    LINECALLSTATE_CONFERENCED        | \
                                    LINECALLSTATE_ONHOLDPENDCONF     | \
                                    LINECALLSTATE_ONHOLDPENDTRANSFER | \
                                    LINECALLSTATE_DISCONNECTED       | \
                                    LINECALLSTATE_UNKNOWN)
#define ALL_DIAL_TONE_MODES        (LINEDIALTONEMODE_NORMAL          | \
                                    LINEDIALTONEMODE_SPECIAL         | \
                                    LINEDIALTONEMODE_INTERNAL        | \
                                    LINEDIALTONEMODE_EXTERNAL        | \
                                    LINEDIALTONEMODE_UNKNOWN         | \
                                    LINEDIALTONEMODE_UNAVAIL)
#define ALL_DISCONNECT_MODES       (LINEDISCONNECTMODE_NORMAL        | \
                                    LINEDISCONNECTMODE_UNKNOWN       | \
                                    LINEDISCONNECTMODE_REJECT        | \
                                    LINEDISCONNECTMODE_PICKUP        | \
                                    LINEDISCONNECTMODE_FORWARDED     | \
                                    LINEDISCONNECTMODE_BUSY          | \
                                    LINEDISCONNECTMODE_NOANSWER      | \
                                    LINEDISCONNECTMODE_BADADDRESS    | \
                                    LINEDISCONNECTMODE_UNREACHABLE   | \
                                    LINEDISCONNECTMODE_CONGESTION    | \
                                    LINEDISCONNECTMODE_INCOMPATIBLE  | \
                                    LINEDISCONNECTMODE_UNAVAIL       | \
                                    LINEDISCONNECTMODE_NODIALTONE)
#define ALL_MEDIA_MODES            (LINEMEDIAMODE_UNKNOWN            | \
                                    LINEMEDIAMODE_INTERACTIVEVOICE   | \
                                    LINEMEDIAMODE_AUTOMATEDVOICE     | \
                                    LINEMEDIAMODE_DATAMODEM          | \
                                    LINEMEDIAMODE_G3FAX              | \
                                    LINEMEDIAMODE_TDD                | \
                                    LINEMEDIAMODE_G4FAX              | \
                                    LINEMEDIAMODE_DIGITALDATA        | \
                                    LINEMEDIAMODE_TELETEX            | \
                                    LINEMEDIAMODE_VIDEOTEX           | \
                                    LINEMEDIAMODE_TELEX              | \
                                    LINEMEDIAMODE_MIXED              | \
                                    LINEMEDIAMODE_ADSI               | \
                                    LINEMEDIAMODE_VOICEVIEW)
#define ALL_LINE_DEV_CAP_FLAGS     (LINEDEVCAPFLAGS_CROSSADDRCONF    | \
                                    LINEDEVCAPFLAGS_HIGHLEVCOMP      | \
                                    LINEDEVCAPFLAGS_LOWLEVCOMP       | \
                                    LINEDEVCAPFLAGS_MEDIACONTROL     | \
                                    LINEDEVCAPFLAGS_MULTIPLEADDR     | \
                                    LINEDEVCAPFLAGS_CLOSEDROP        | \
                                    LINEDEVCAPFLAGS_DIALBILLING      | \
                                    LINEDEVCAPFLAGS_DIALQUIET        | \
                                    LINEDEVCAPFLAGS_DIALDIALTONE)
#define ALL_LINE_STATES            (LINEDEVSTATE_OTHER               | \
                                    LINEDEVSTATE_RINGING             | \
                                    LINEDEVSTATE_CONNECTED           | \
                                    LINEDEVSTATE_DISCONNECTED        | \
                                    LINEDEVSTATE_MSGWAITON           | \
                                    LINEDEVSTATE_MSGWAITOFF          | \
                                    LINEDEVSTATE_INSERVICE           | \
                                    LINEDEVSTATE_OUTOFSERVICE        | \
                                    LINEDEVSTATE_MAINTENANCE         | \
                                    LINEDEVSTATE_OPEN                | \
                                    LINEDEVSTATE_CLOSE               | \
                                    LINEDEVSTATE_NUMCALLS            | \
                                    LINEDEVSTATE_NUMCOMPLETIONS      | \
                                    LINEDEVSTATE_TERMINALS           | \
                                    LINEDEVSTATE_ROAMMODE            | \
                                    LINEDEVSTATE_BATTERY             | \
                                    LINEDEVSTATE_SIGNAL              | \
                                    LINEDEVSTATE_DEVSPECIFIC         | \
                                    LINEDEVSTATE_REINIT              | \
                                    LINEDEVSTATE_LOCK                | \
                                    LINEDEVSTATE_CAPSCHANGE          | \
                                    LINEDEVSTATE_CONFIGCHANGE        | \
                                    LINEDEVSTATE_TRANSLATECHANGE     | \
                                    LINEDEVSTATE_COMPLCANCEL         | \
                                    LINEDEVSTATE_REMOVED)
#define ALL_LINE_FEATURES          (LINEFEATURE_DEVSPECIFIC          | \
                                    LINEFEATURE_DEVSPECIFICFEAT      | \
                                    LINEFEATURE_FORWARD              | \
                                    LINEFEATURE_MAKECALL             | \
                                    LINEFEATURE_SETMEDIACONTROL      | \
                                    LINEFEATURE_SETTERMINAL)
#define ALL_SPECIAL_INFO           (LINESPECIALINFO_NOCIRCUIT        | \
                                    LINESPECIALINFO_CUSTIRREG        | \
                                    LINESPECIALINFO_REORDER          | \
                                    LINESPECIALINFO_UNKNOWN          | \
                                    LINESPECIALINFO_UNAVAIL)
#define ALL_ADDRESS_CAP_FLAGS      (LINEADDRCAPFLAGS_FWDNUMRINGS     | \
                                    LINEADDRCAPFLAGS_PICKUPGROUPID   | \
                                    LINEADDRCAPFLAGS_SECURE          | \
                                    LINEADDRCAPFLAGS_BLOCKIDDEFAULT  | \
                                    LINEADDRCAPFLAGS_BLOCKIDOVERRIDE | \
                                    LINEADDRCAPFLAGS_DIALED          | \
                                    LINEADDRCAPFLAGS_ORIGOFFHOOK     | \
                                    LINEADDRCAPFLAGS_DESTOFFHOOK     | \
                                    LINEADDRCAPFLAGS_FWDCONSULT      | \
                                    LINEADDRCAPFLAGS_SETUPCONFNULL   | \
                                    LINEADDRCAPFLAGS_AUTORECONNECT   | \
                                    LINEADDRCAPFLAGS_COMPLETIONID    | \
                                    LINEADDRCAPFLAGS_TRANSFERHELD    | \
                                    LINEADDRCAPFLAGS_TRANSFERMAKE    | \
                                    LINEADDRCAPFLAGS_CONFERENCEHELD  | \
                                    LINEADDRCAPFLAGS_CONFERENCEMAKE  | \
                                    LINEADDRCAPFLAGS_PARTIALDIAL     | \
                                    LINEADDRCAPFLAGS_FWDSTATUSVALID  | \
                                    LINEADDRCAPFLAGS_FWDINTEXTADDR   | \
                                    LINEADDRCAPFLAGS_FWDBUSYNAADDR   | \
                                    LINEADDRCAPFLAGS_ACCEPTTOALERT   | \
                                    LINEADDRCAPFLAGS_CONFDROP        | \
                                    LINEADDRCAPFLAGS_PICKUPCALLWAIT)

#endif // _PX_TAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\precomp.h ===
#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#define NDIS_TAPI_CURRENT_VERSION 0x00030000

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>

#include <ndis.h>
#include <ndistapi.h>
#include <cxport.h>
#include <ip.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <ipfilter.h>
#include <tdistat.h>
#include <wanpub.h>

#define FIELDOFFSET(type, field)    ((UINT)&(((type *)0)->field))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\pxutils.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pxutils.c

Abstract:

    Utility routines called by entry point functions. Split out into
    a separate file to keep the "entry point" files clean.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm     02-15-96    Created
    arvindm     04-30-96    Port to NDIS 4.1
    rmachin     11-01-96    ATM - utils adapted for NDIS Proxy
    tonybe      01-23-98    rewrite and cleanup

Notes:

--*/

#include "precomp.h"
#include "atm.h"
#include "stdio.h"

#define MODULE_NUMBER   MODULE_UTIL
#define _FILENUMBER   'LITU'

#define MAX_SDU_SIZE        8192

PXTAPI_CALL_PARAM_ENTRY PxTapiCallParamList[] =
{
    PX_TCP_ENTRY(ulOrigAddressSize, ulOrigAddressOffset),
    PX_TCP_ENTRY(ulDisplayableAddressSize, ulDisplayableAddressOffset),
    PX_TCP_ENTRY(ulCalledPartySize, ulCalledPartyOffset),
    PX_TCP_ENTRY(ulCommentSize, ulCommentOffset),
    PX_TCP_ENTRY(ulUserUserInfoSize, ulUserUserInfoOffset),
    PX_TCP_ENTRY(ulHighLevelCompSize, ulHighLevelCompOffset),
    PX_TCP_ENTRY(ulLowLevelCompSize, ulLowLevelCompOffset),
    PX_TCP_ENTRY(ulDevSpecificSize, ulDevSpecificOffset)
};

#define PX_TCP_NUM_ENTRIES  (sizeof(PxTapiCallParamList) / sizeof(PXTAPI_CALL_PARAM_ENTRY))

PXTAPI_CALL_INFO_ENTRY PxTapiCallInfoList[] =
{
    PX_TCI_ENTRY(ulCallerIDSize, ulCallerIDOffset),
    PX_TCI_ENTRY(ulCallerIDNameSize, ulCallerIDNameOffset),
    PX_TCI_ENTRY(ulCalledIDSize, ulCalledIDOffset),
    PX_TCI_ENTRY(ulCalledIDNameSize, ulCalledIDNameOffset),
    PX_TCI_ENTRY(ulConnectedIDSize, ulConnectedIDOffset),
    PX_TCI_ENTRY(ulConnectedIDNameSize, ulConnectedIDNameOffset),
    PX_TCI_ENTRY(ulRedirectionIDSize, ulRedirectionIDOffset),
    PX_TCI_ENTRY(ulRedirectionIDNameSize, ulRedirectionIDNameOffset),
    PX_TCI_ENTRY(ulRedirectingIDSize, ulRedirectingIDOffset),
    PX_TCI_ENTRY(ulRedirectingIDNameSize, ulRedirectingIDNameOffset),
    PX_TCI_ENTRY(ulAppNameSize, ulAppNameOffset),
    PX_TCI_ENTRY(ulDisplayableAddressSize, ulDisplayableAddressOffset),
    PX_TCI_ENTRY(ulCalledPartySize, ulCalledPartyOffset),
    PX_TCI_ENTRY(ulCommentSize, ulCommentOffset),
    PX_TCI_ENTRY(ulDisplaySize, ulDisplayOffset),
    PX_TCI_ENTRY(ulUserUserInfoSize, ulUserUserInfoOffset),
    PX_TCI_ENTRY(ulHighLevelCompSize, ulHighLevelCompOffset),
    PX_TCI_ENTRY(ulLowLevelCompSize, ulLowLevelCompOffset),
    PX_TCI_ENTRY(ulChargingInfoSize, ulChargingInfoOffset),
    PX_TCI_ENTRY(ulTerminalModesSize, ulTerminalModesOffset),
    PX_TCI_ENTRY(ulDevSpecificSize, ulDevSpecificOffset)
};

#define PX_TCI_NUM_ENTRIES  (sizeof(PxTapiCallInfoList) / sizeof(PXTAPI_CALL_INFO_ENTRY))

BOOLEAN
PxIsAdapterAlreadyBound(
    PNDIS_STRING pDeviceName
    )
/*++

Routine Description:

    Check if we have already bound to a device (adapter).

Arguments:

    pDeviceName     - Points to device name to be checked.

Return Value:

    TRUE iff we already have an Adapter structure representing
    this device.

--*/
{
    PPX_ADAPTER     pAdapter;
    BOOLEAN         bFound = FALSE;
    PLIST_ENTRY     Entry;

    NdisAcquireSpinLock(&(DeviceExtension->Lock));

    Entry = DeviceExtension->AdapterList.Flink;

    pAdapter = CONTAINING_RECORD(Entry,
                                 PX_ADAPTER,
                                 Linkage);

    while ((PVOID)pAdapter != (PVOID)&DeviceExtension->AdapterList) {

        if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
            (NdisEqualMemory(pDeviceName->Buffer,
                             pAdapter->DeviceName.Buffer,
                             pDeviceName->Length) == (ULONG)1)) {
            bFound = TRUE;
            break;
        }

        Entry = pAdapter->Linkage.Flink;

        pAdapter = CONTAINING_RECORD(Entry,
                                     PX_ADAPTER,
                                     Linkage);
    }

    NdisReleaseSpinLock(&(DeviceExtension->Lock));

    return (bFound);
}

PPX_ADAPTER
PxAllocateAdapter(
    ULONG ulAdditionalLength
    )
/*++

Routine Description:
    Allocate a new Adapter structure, assign an adapter number to it, and
    chain it to the Global list of adapters. We maintain this list in
    ascending order by AdapterNo, which makes it easy to figure out the
    lowest unused AdapterNo.

Arguments:
    None

Return Value:
    Pointer to allocated adapter structure, if successful. NULL otherwise.

--*/
{
    PPX_ADAPTER     pNewAdapter;
    ULONG           SizeNeeded;

    SizeNeeded = sizeof(PX_ADAPTER) + ulAdditionalLength;

    PxAllocMem(pNewAdapter,
               SizeNeeded,
               PX_ADAPTER_TAG);

    if(pNewAdapter == (PPX_ADAPTER)NULL){
        return NULL;
    }

    NdisZeroMemory(pNewAdapter, SizeNeeded);

    //
    // Initialize the new adapter structure
    //
    pNewAdapter->State = PX_ADAPTER_OPENING;
    pNewAdapter->Sig = PX_ADAPTER_SIG;

    NdisAllocateSpinLock(&pNewAdapter->Lock);

    InitializeListHead(&pNewAdapter->CmAfList);
    InitializeListHead(&pNewAdapter->CmAfClosingList);
    InitializeListHead(&pNewAdapter->ClAfList);
    InitializeListHead(&pNewAdapter->ClAfClosingList);

    NdisAcquireSpinLock(&DeviceExtension->Lock);

    InsertTailList(&DeviceExtension->AdapterList, &pNewAdapter->Linkage);

    NdisReleaseSpinLock(&DeviceExtension->Lock);

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxAllocAdapter: new adapter %p\n", pNewAdapter));

    return (pNewAdapter);
}

VOID
PxFreeAdapter(
    PPX_ADAPTER pAdapter
    )
/*++

Routine Description:
    Remove an adapter structure from the global list of adapters and free
    its memory.

Arguments:
    pAdapter    - pointer to Adapter to be released

Return Value:
    None

--*/
{
    PPX_ADAPTER *ppNextAdapter;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeAdapter: pAdapter 0x%x\n", pAdapter));

    ASSERT(pAdapter->State == PX_ADAPTER_CLOSING);
    ASSERT(IsListEmpty(&pAdapter->CmAfList));
    ASSERT(IsListEmpty(&pAdapter->CmAfClosingList));
    ASSERT(IsListEmpty(&pAdapter->ClAfList));
    ASSERT(IsListEmpty(&pAdapter->ClAfClosingList));

    pAdapter->State = PX_ADAPTER_CLOSED;

    NdisAcquireSpinLock(&(DeviceExtension->Lock));

    RemoveEntryList(&pAdapter->Linkage);

    NdisReleaseSpinLock(&(DeviceExtension->Lock));

    NdisFreeSpinLock(&(pAdapter->Lock));

    PxFreeMem(pAdapter);
}

PPX_CM_AF
PxAllocateCmAf(
    IN  PCO_ADDRESS_FAMILY  pFamily
    )
{
    UINT        SizeNeeded;
    PPX_CM_AF   pCmAf;

    SizeNeeded = sizeof(PX_CM_AF);

    PxAllocMem(pCmAf, SizeNeeded, PX_CMAF_TAG);

    if(pCmAf == (PPX_CM_AF)NULL) {
        return NULL;
    }

    NdisZeroMemory((PUCHAR)pCmAf, SizeNeeded);

    NdisAllocateSpinLock(&(pCmAf->Lock));

    NdisMoveMemory(&pCmAf->Af, pFamily, sizeof(CO_ADDRESS_FAMILY));

    InitializeListHead(&pCmAf->CmSapList);
    InitializeListHead(&pCmAf->VcList);

    pCmAf->RefCount = 1;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxAllocCmAf: new af %p\n", pCmAf));

    return (pCmAf);
}

VOID
PxFreeCmAf(
    PPX_CM_AF    pCmAf
    )
{

    ASSERT(pCmAf->Linkage.Flink == pCmAf->Linkage.Blink);
    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeCmAf: CmAf %p\n", pCmAf));
    NdisFreeSpinLock(&pCmAf->Lock);
    PxFreeMem(pCmAf);
}

PPX_CL_AF
PxAllocateClAf(
    IN  PCO_ADDRESS_FAMILY  pFamily,
    IN  PPX_ADAPTER         pAdapter
    )
/*++

Routine Description:
    Allocate a new AF block structure and queue it off the global list.

Arguments:
    None

Return Value:
    Pointer to allocated AF block structure, if successful. NULL otherwise.

--*/
{
    PPX_CL_AF   pClAf;

    PxAllocMem(pClAf, sizeof(PX_CL_AF), PX_CLAF_TAG);

    if(pClAf == (PPX_CL_AF)NULL) {
        return NULL;
    }

    NdisZeroMemory((PUCHAR)pClAf, sizeof(PX_CL_AF));

    PxInitBlockStruc(&pClAf->Block);

    NdisAllocateSpinLock(&(pClAf->Lock));

    NdisMoveMemory(&pClAf->Af, pFamily, sizeof(CO_ADDRESS_FAMILY));

    InitializeListHead(&pClAf->ClSapList);
    InitializeListHead(&pClAf->ClSapClosingList);
    InitializeListHead(&pClAf->VcList);
    InitializeListHead(&pClAf->VcClosingList);

    //
    // Specify any AF-specific functions
    //
    switch(pFamily->AddressFamily) {
        case CO_ADDRESS_FAMILY_Q2931:
            pClAf->AfGetNdisCallParams = PxAfXyzTranslateTapiCallParams;
            pClAf->AfGetTapiCallParams = PxAfXyzTranslateNdisCallParams;
            pClAf->AfGetNdisSap = PxAfXyzTranslateTapiSap;
            break;

        case CO_ADDRESS_FAMILY_TAPI_PROXY:
            pClAf->AfGetNdisCallParams = PxAfTapiTranslateTapiCallParams;
            pClAf->AfGetTapiCallParams = PxAfTapiTranslateNdisCallParams;
            pClAf->AfGetNdisSap = PxAfTapiTranslateTapiSap;
            break;

#if 0
        case CO_ADDRESS_FAMILY_L2TP:
        case CO_ADDRESS_FAMILY_IRDA:
            pClAf->AfGetNdisCallParams = GenericGetNdisCallParams;
            pClAf->AfGetTapiCallParams = GenericGetTapiCallParams;
            pClAf->AfGetNdisSap = GenericTranslateTapiSap;
            break;
#endif

        default:
            pClAf->AfGetNdisCallParams = PxAfXyzTranslateTapiCallParams;
            pClAf->AfGetTapiCallParams = PxAfXyzTranslateNdisCallParams;
            pClAf->AfGetNdisSap = PxAfXyzTranslateTapiSap;
            break;

    }

    pClAf->State = PX_AF_OPENING;
    pClAf->RefCount = 1;
    pClAf->Adapter = pAdapter;

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("PxAllocateClAf: exit. new ClAf %p\n", pClAf));

    return (pClAf);
}


VOID
PxFreeClAf(
    PPX_CL_AF   pClAf
    )
/*++

Routine Description:
    Remove an AF block structure from the global list  and free
    its memory.

Arguments:
    pAdapter    - pointer to AF block to be released

Return Value:
    None

--*/
{
    PXDEBUGP(PXD_INFO, PXM_UTILS, ("PxFreeClAf: ClAf %p\n", pClAf));

    NdisFreeSpinLock(&(pClAf->Lock));

    PxFreeMem(pClAf);
}


PPX_CM_SAP
PxAllocateCmSap(
    PCO_SAP Sap
    )
{
    PPX_CM_SAP  pCmSap;
    ULONG       SizeNeeded;

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("PxAllocateCmSap: Sap %p\n", Sap));

    SizeNeeded = sizeof(PX_CM_SAP) + sizeof(CO_SAP) +
        Sap->SapLength + sizeof(PVOID);

    PxAllocMem((PUCHAR)pCmSap, SizeNeeded, PX_CMSAP_TAG);

    if (pCmSap == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_UTILS,
            ("PxAllocateCmSap: Allocation failed Size %d\n", SizeNeeded));
        return (NULL);
    }

    NdisZeroMemory(pCmSap, SizeNeeded);

    InterlockedExchange((PLONG)&pCmSap->State, PX_SAP_OPENED);

    pCmSap->CoSap = (PCO_SAP)
        ((PUCHAR)pCmSap + sizeof(PX_CM_SAP) + sizeof(PVOID));

    (ULONG_PTR)pCmSap->CoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    NdisMoveMemory(pCmSap->CoSap, Sap, sizeof(CO_SAP) - 1 + Sap->SapLength);

    return (pCmSap);
}

VOID
PxFreeCmSap(
    PPX_CM_SAP  pCmSap
    )
{
    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeCmSap: CmSap %p\n", pCmSap));

    pCmSap->CoSap = NULL;

    PxFreeMem(pCmSap);
}

VOID
PxFreeClSap(
    PPX_CL_SAP  pClSap
    )
{

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeClSap: ClSap %p\n", pClSap));

    pClSap->CoSap = NULL;

    PxFreeMem(pClSap);
}

PPX_VC
PxAllocateVc(
    IN PPX_CL_AF    pClAf
    )
{
    PPX_VC  pVc;

    pVc =
        ExAllocateFromNPagedLookasideList(&VcLookaside);

    if (pVc == NULL) {
        return (NULL);
    }

    NdisZeroMemory(pVc, sizeof(PX_VC));

    NdisAllocateSpinLock(&pVc->Lock);

    NdisInitializeTimer(&pVc->InCallTimer,
                        PxIncomingCallTimeout,
                       (PVOID)pVc);

    PxInitBlockStruc(&pVc->Block);

    pVc->State = PX_VC_IDLE;

    InitializeListHead(&pVc->PendingDropReqs);

    //
    // This ref is removed when all vc activity 
    // between the proxy and the client is finished.  
    // For an outgoing call this is after the proxy
    // calls NdisClDeleteVc.  For an incoming call
    // this is after the call manager has called
    // PxClDeleteVc.
    //
    pVc->RefCount = 1;
    pVc->ClAf = pClAf;
    pVc->Adapter = pClAf->Adapter;

    return (pVc);
}

VOID
PxFreeVc(
    PPX_VC  pVc
    )
{
    PPX_TAPI_ADDR   TapiAddr;
    PPX_TAPI_LINE   TapiLine;

    if (pVc->CallInfo != NULL) {
        PxFreeMem(pVc->CallInfo);
        pVc->CallInfo = NULL;
    }

    if (pVc->pCallParameters != NULL) {
        PxFreeMem(pVc->pCallParameters);
        pVc->pCallParameters = NULL;
    }
    TapiAddr = pVc->TapiAddr;
    pVc->TapiAddr = NULL;

    TapiLine = pVc->TapiLine;
    pVc->TapiLine = NULL;

    if (TapiAddr != NULL) {
        InterlockedDecrement((PLONG)&TapiAddr->CallCount);
    }

    if (TapiLine != NULL) {
        InterlockedDecrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);
    }

    NdisFreeSpinLock(&pVc->Lock);

    ExFreeToNPagedLookasideList(&VcLookaside, pVc);
}

#if 0
NDIS_STATUS
GenericGetNdisCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    TapiBuffer,
    OUT PCO_CALL_PARAMETERS *   pOutNdisCallParams
    )
/*++

Routine Description:

Copies everything we can from TAPI CallParams buffer for a generic WAN_CO call to a WAN_CO
call params buffer.


Arguments:
TapiBuffer  -- the TAPI call params buffer
pOutNdisCallParams  -- pointer to the NDIS call params buffer pointer

Return Value:

None

--*/
{

    PCO_CALL_PARAMETERS     pNdisCallParams;
    PCO_CALL_MANAGER_PARAMETERS pCallMgrParams;
    PCO_MEDIA_PARAMETERS    pMediaParams;
    PWAN_CO_CALLMGR_PARAMETERS   pWanCallMgrParams;
    PCO_MEDIA_PARAMETERS    pMediaParameters;
    LINE_CALL_PARAMS*           pTapiCallParams = (LINE_CALL_PARAMS*)&TapiBuffer->LineCallParams;
    ULONG               ulRequestSize;
    UNICODE_STRING      DialAddress;
    NDIS_STATUS         Status;
    LPCWSTR             lpcwszTemp;
    ULONG               i;

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("GenericGetNdisCallParams: enter\n"));

//
// Set up CallParameters structure.
//
    ulRequestSize = sizeof(CO_CALL_PARAMETERS) +
                    sizeof(CO_CALL_MANAGER_PARAMETERS) +
                    sizeof(WAN_CO_CALLMGR_PARAMETERS) +
                    sizeof(CO_MEDIA_PARAMETERS);

    do
    {
        PxAllocMem(pNdisCallParams, ulRequestSize, PX_COCALLPARAMS_TAG);

        if (pNdisCallParams == (PCO_CALL_PARAMETERS)NULL)
        {
            PXDEBUGP(PXD_WARNING, PXM_UTILS, ("GenericGetNdisCallParams: alloc (%d) failed\n", ulRequestSize));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pNdisCallParams, ulRequestSize);

        pCallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)((PUCHAR)pNdisCallParams + sizeof(CO_CALL_PARAMETERS));
        pMediaParams = (PCO_MEDIA_PARAMETERS)((PUCHAR)pCallMgrParams +
                                              sizeof(CO_CALL_MANAGER_PARAMETERS) +
                                              sizeof(WAN_CO_CALLMGR_PARAMETERS));

        pNdisCallParams->CallMgrParameters = pCallMgrParams;
        pNdisCallParams->MediaParameters = pMediaParams;

        pCallMgrParams->CallMgrSpecific.ParamType = WAN_CO_CALLMGR_SPECIFIC;
        pCallMgrParams->CallMgrSpecific.Length = sizeof(WAN_CO_CALLMGR_PARAMETERS);

        pWanCallMgrParams = (PWAN_CO_CALLMGR_PARAMETERS)(pCallMgrParams->CallMgrSpecific.Parameters);
        pWanCallMgrParams->BearerType = pTapiCallParams->ulBearerMode;
        pWanCallMgrParams->MediaMode = pTapiCallParams->ulMediaMode;

        pWanCallMgrParams->MinRate = pTapiCallParams->ulMinRate;
        pWanCallMgrParams->MaxRate = pTapiCallParams->ulMaxRate;

        //
        // If there's a called address (should be), stick it in the
        // WAN call params
        //
        PxAssert (0 != TapiBuffer->ulDestAddressSize);
        lpcwszTemp = (LPWSTR) ((UCHAR *)TapiBuffer + TapiBuffer->ulDestAddressOffset);
        pWanCallMgrParams->CalledAddr.AddressLength = TapiBuffer->ulDestAddressSize;

        //
        // Move the address from the tapi buffer to the ndis buffer and
        // change from wchar to uchar.
        //
        for (i = 0;
            i < pWanCallMgrParams->CalledAddr.AddressLength;
            i++)
        {
            pWanCallMgrParams->CalledAddr.Address[i] = (UCHAR)lpcwszTemp[i];
        }

        pWanCallMgrParams->CalledAddr.Address[i] = '\0';
        pWanCallMgrParams->CalledAddr.Address[i+1] ='\0';
        pWanCallMgrParams->CalledAddr.Address[i+2] ='\0';

        PXDEBUGP(PXD_INFO, PXM_UTILS, ("CalledAddr %s\n", pWanCallMgrParams->CalledAddr.Address));

        //
        // If there's an originating address, stick it in the
        // WAN call params
        //
        if (0 != pTapiCallParams->ulOrigAddressSize)
        {     // Address of call originator
            ULONG   i;

            NdisMoveMemory(pWanCallMgrParams->OriginatingAddr.Address,
                           ((UCHAR *)pTapiCallParams + pTapiCallParams->ulOrigAddressOffset),
                           pTapiCallParams->ulOrigAddressSize);

            i = pWanCallMgrParams->OriginatingAddr.AddressLength =
                pTapiCallParams->ulOrigAddressSize;

            pWanCallMgrParams->OriginatingAddr.Address[i] = '\0';
            pWanCallMgrParams->OriginatingAddr.Address[i+1] ='\0';
            pWanCallMgrParams->OriginatingAddr.Address[i+2] ='\0';

            PXDEBUGP(PXD_INFO, PXM_UTILS, ("OriginatingAddr %s\n", pWanCallMgrParams->OriginatingAddr.Address));

        }

        if (0 != pTapiCallParams->ulLowLevelCompSize)
        {
            NdisMoveMemory ((UCHAR *)&pWanCallMgrParams->LowerLayerComp,
                            &pTapiCallParams->ulLowLevelCompOffset,
                            MIN (sizeof (WAN_LLI_COMP), pTapiCallParams->ulLowLevelCompSize));
        }

        if (0 != pTapiCallParams->ulHighLevelCompSize)
        {
            NdisMoveMemory ((UCHAR *)&pWanCallMgrParams->HigherLayerComp,
                            &pTapiCallParams->ulHighLevelCompOffset,
                            MIN (sizeof (WAN_HLI_COMP), pTapiCallParams->ulHighLevelCompSize));
        }

        if (0 != pTapiCallParams->ulDevSpecificSize)
        {
            pWanCallMgrParams->DevSpecificLength = pTapiCallParams->ulDevSpecificSize;
            NdisMoveMemory ((UCHAR *)&pWanCallMgrParams->DevSpecificData[0],
                            &pTapiCallParams->ulDevSpecificOffset,
                            pTapiCallParams->ulDevSpecificSize);
        }

        //
        // Set up the flowspec.
        // TBS: Start with a default flowspec that matches the service requirements for
        // specified mediamode. Then refine it.
        //
        if (!TapiBuffer->bUseDefaultLineCallParams)
        {
            PXDEBUGP(PXD_LOUD, PXM_UTILS, ("GenericGetNdisCallParams: moving TAPI call params\n"));

            //
            // These fields are in the FLOWSPEC sub-structure
            //
            pCallMgrParams->Transmit.TokenRate = pTapiCallParams->ulMaxRate;
            pCallMgrParams->Receive.TokenRate = pTapiCallParams->ulMaxRate;
            pCallMgrParams->Transmit.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Receive.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Transmit.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Receive.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Transmit.PeakBandwidth = pTapiCallParams->ulMaxRate;
            pCallMgrParams->Receive.PeakBandwidth = pTapiCallParams->ulMaxRate;

            if ((pTapiCallParams->ulBearerMode == LINEBEARERMODE_VOICE)  ||
                (pTapiCallParams->ulBearerMode == LINEBEARERMODE_SPEECH)  ||
                (pTapiCallParams->ulBearerMode == LINEBEARERMODE_ALTSPEECHDATA)  ||
                (pTapiCallParams->ulBearerMode == LINEBEARERMODE_MULTIUSE))
            {
                pCallMgrParams->Receive.ServiceType = SERVICETYPE_BESTEFFORT;
                pCallMgrParams->Transmit.ServiceType = SERVICETYPE_BESTEFFORT;
            }

            //
            // TBS: Should MediaMode determine AAL?
            //
        }

        Status = NDIS_STATUS_SUCCESS;
    }while (FALSE);

    *pOutNdisCallParams = pNdisCallParams;
    PXDEBUGP(PXD_INFO, PXM_UTILS, ("GenericGetNdisCallParams: exit: NdisCallParams = x%x\n", pNdisCallParams));

    return (Status);
}

NDIS_STATUS
GenericGetTapiCallParams(
    IN  PPX_VC                  pVc,
    IN  PCO_CALL_PARAMETERS     pCallParams
    )
/*++

Routine Description:

    Copies everything we can from NDIS CallParams buffer for a Q2931 call into TAPI
    call params buffer.


 Arguments:
    pCallParams         -- the NDIS call params buffer
    pVc                 -- pointer to a TAPI call

Return Value:

    None

--*/
{

    PCO_CALL_MANAGER_PARAMETERS pCallMgrParams;
    PWAN_CO_CALLMGR_PARAMETERS pWanCallMgrParams;
    LINE_CALL_INFO  *CallInfo;
    INT             VarDataUsed = 0;
    NDIS_STATUS     Status;
    PPX_TAPI_PROVIDER   TapiProvider;
    PPX_TAPI_LINE       TapiLine;
    PPX_TAPI_ADDR       TapiAddr;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("GenericGetTapiCallParams: enter. Call %x\n", pVc));

    pVc->pCallParameters =
        PxCopyCallParameters(pCallParams);

    if (pVc->pCallParameters == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("GenericGetTapiCallParams: failed to allocate memory for callparams\n"));

        return (NDIS_STATUS_RESOURCES);
    }

    Status = AllocateTapiCallInfo(pVc, NULL);
    if (Status != NDIS_STATUS_SUCCESS) {
        return (Status);
    }

    pCallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)
                     ((PUCHAR)pCallParams +
                      sizeof(CO_CALL_PARAMETERS));
    pWanCallMgrParams = (PWAN_CO_CALLMGR_PARAMETERS)
                        pCallMgrParams->CallMgrSpecific.Parameters;

    TapiProvider = pVc->ClAf->TapiProvider;

    pVc->ulCallInfoFieldsChanged = 0;

    //
    // Need to find a line and an address for this puppy
    //
    if (!GetAvailLineFromProvider(TapiProvider, &TapiLine, &TapiAddr)) {

        return (NDIS_STATUS_RESOURCES);
    }

    pVc->TapiLine = TapiLine;
    pVc->TapiAddr = TapiAddr;
    InterlockedIncrement((PLONG)&TapiAddr->CallCount);
    InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

    CallInfo = pVc->CallInfo;

    CallInfo->ulLineDeviceID = TapiLine->CmLineID;
    CallInfo->ulAddressID = TapiAddr->AddrId;
    CallInfo->ulOrigin = LINECALLORIGIN_INBOUND;

    //
    // Set up structure size
    //
    CallInfo->ulNeededSize = 
    CallInfo->ulUsedSize = 
        sizeof(LINE_CALL_INFO);// + LINE_CALL_INFO_VAR_DATA_SIZE;

    CallInfo->ulBearerMode =
        (LINEBEARERMODE_VOICE | LINEBEARERMODE_SPEECH |
         LINEBEARERMODE_ALTSPEECHDATA | LINEBEARERMODE_MULTIUSE);

    CallInfo->ulRate = 
        MIN(pCallMgrParams->Receive.PeakBandwidth, pCallMgrParams->Transmit.PeakBandwidth);

    CallInfo->ulRate = CallInfo->ulRate * 8;
    pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_RATE;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("GenericGetTapiCallParams: CallInfo->ulRate %x\n", CallInfo->ulRate));

    CallInfo->ulMediaMode = pWanCallMgrParams->MediaMode |
                            LINEMEDIAMODE_DIGITALDATA;

    CallInfo->ulAppSpecific = 0;
    CallInfo->ulCallID = 0;
    CallInfo->ulRelatedCallID = 0;
    CallInfo->ulCallParamFlags = 0;
    CallInfo->ulCallStates = LINECALLSTATE_IDLE |
                             LINECALLSTATE_OFFERING |
                             LINECALLSTATE_BUSY |
                             LINECALLSTATE_CONNECTED |
                             LINECALLSTATE_DISCONNECTED |
                             LINECALLSTATE_SPECIALINFO |
                             LINECALLSTATE_UNKNOWN;


    CallInfo->DialParams.ulDialPause = 0;
    CallInfo->DialParams.ulDialSpeed = 0;
    CallInfo->DialParams.ulDigitDuration = 0;
    CallInfo->DialParams.ulWaitForDialtone = 0;

    CallInfo->ulReason = LINECALLREASON_UNAVAIL;
    CallInfo->ulCompletionID = 0;

    CallInfo->ulCountryCode = 0;
    CallInfo->ulTrunk = (ULONG)-1;

    if (pWanCallMgrParams->OriginatingAddr.AddressLength != 0) {
        if ((VarDataUsed + pWanCallMgrParams->OriginatingAddr.AddressLength)
            <= LINE_CALL_INFO_VAR_DATA_SIZE) {
            CallInfo->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;
            CallInfo->ulCallerIDSize = pWanCallMgrParams->OriginatingAddr.AddressLength;

            //
            // var data comes in the LINE_CALL_INFO_VAR_DATA_SIZE
            // space at the end of this structure.
            //
            CallInfo->ulCallerIDOffset = sizeof (LINE_CALL_INFO);

            NdisMoveMemory ( (USHORT *)(CallInfo)+CallInfo->ulCallerIDOffset,
                             &pWanCallMgrParams->OriginatingAddr.Address,
                             pWanCallMgrParams->OriginatingAddr.AddressLength);

            VarDataUsed +=  pWanCallMgrParams->OriginatingAddr.AddressLength;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_ORIGIN;
        }
    } else {
        CallInfo->ulCallerIDFlags    =    LINECALLPARTYID_UNAVAIL;
        CallInfo->ulCallerIDSize = 0;
        CallInfo->ulCallerIDOffset = 0;
    }
    CallInfo->ulCallerIDNameSize = 0;
    CallInfo->ulCallerIDNameOffset = 0;

    if (pWanCallMgrParams->CalledAddr.AddressLength != 0) {
        if ((VarDataUsed + pWanCallMgrParams->CalledAddr.AddressLength)
            <= sizeof (LINE_CALL_INFO_VAR_DATA_SIZE)) {
            CallInfo->ulCalledIDFlags = LINECALLPARTYID_ADDRESS;
            CallInfo->ulCalledIDSize    =    pWanCallMgrParams->CalledAddr.AddressLength;

            //
            // var data comes in the LINE_CALL_INFO_VAR_DATA_SIZE
            // space at the end of this structure.
            //
            CallInfo->ulCalledIDOffset = sizeof (LINE_CALL_INFO) + VarDataUsed;

            NdisMoveMemory ( (USHORT *)(CallInfo)+CallInfo->ulCalledIDOffset,
                             &pWanCallMgrParams->CalledAddr.Address,
                             pWanCallMgrParams->CalledAddr.AddressLength);

            VarDataUsed +=  pWanCallMgrParams->CalledAddr.AddressLength;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_CALLEDID;
        }
    } else {
        CallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
        CallInfo->ulCalledIDSize = 0;
        CallInfo->ulCalledIDOffset = 0;
    }

    CallInfo->ulCalledIDNameSize = 0;
    CallInfo->ulCalledIDNameOffset = 0;

    CallInfo->ulConnectedIDFlags = LINECALLPARTYID_UNAVAIL;
    CallInfo->ulConnectedIDSize          =          0;
    CallInfo->ulConnectedIDOffset = 0;
    CallInfo->ulConnectedIDNameSize = 0;
    CallInfo->ulConnectedIDNameOffset = 0;

    CallInfo->ulRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    CallInfo->ulRedirectionIDSize = 0;
    CallInfo->ulRedirectionIDOffset = 0;
    CallInfo->ulRedirectionIDNameSize    =    0;
    CallInfo->ulRedirectionIDNameOffset = 0;

    CallInfo->ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    CallInfo->ulRedirectingIDSize = 0;
    CallInfo->ulRedirectingIDOffset = 0;
    CallInfo->ulRedirectingIDNameSize = 0;
    CallInfo->ulRedirectingIDNameOffset = 0;

    CallInfo->ulDisplaySize = 0;
    CallInfo->ulDisplayOffset = 0;

    CallInfo->ulUserUserInfoSize = 0;
    CallInfo->ulUserUserInfoOffset = 0;

    CallInfo->ulHighLevelCompSize = 0;
    CallInfo->ulHighLevelCompOffset = 0;

    CallInfo->ulLowLevelCompSize = 0;
    CallInfo->ulLowLevelCompOffset = 0;

    CallInfo->ulChargingInfoSize = 0;
    CallInfo->ulChargingInfoOffset = 0;

    CallInfo->ulTerminalModesSize = 0;
    CallInfo->ulTerminalModesOffset = 0;

    CallInfo->ulDevSpecificSize = 0;
    CallInfo->ulDevSpecificOffset = 0;

    CallInfo->ulUsedSize += VarDataUsed;
    CallInfo->ulNeededSize = CallInfo->ulUsedSize;
    return (NDIS_STATUS_SUCCESS);
}

PPX_CL_SAP
GenericTranslateTapiSap(
    IN PPX_CL_AF        pClAf,
    IN PPX_TAPI_LINE    TapiLine
    )
{
    PCO_SAP             pCoSap;
    PPX_CL_SAP          pClSap;
    PWAN_CO_SAP         pWanSap;
    ULONG               SapLength;
    ULONG               MediaModes;
    ULONG               SizeNeeded;

    do {

        SapLength = sizeof(CO_SAP) + sizeof(WAN_CO_SAP);

        SizeNeeded = sizeof(PX_CL_SAP) + SapLength + sizeof(PVOID);

        PxAllocMem(pClSap, SizeNeeded, PX_CLSAP_TAG);

        if (pClSap == NULL) {
            return(NULL);
        }

        NdisZeroMemory(pClSap, SizeNeeded);

        pCoSap = (PCO_SAP)
            ((PUCHAR)pClSap + sizeof(PX_CL_SAP) + sizeof(PVOID));

        (ULONG_PTR)pCoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        MediaModes = TapiLine->DevStatus->ulOpenMediaModes;

        pCoSap->SapType = 0;
        pCoSap->SapLength = sizeof(WAN_CO_SAP);

        pWanSap = (PWAN_CO_SAP)&pCoSap->Sap[0];
        pWanSap->BearerCaps = SAP_FIELD_ANY;
        pWanSap->MediaModes  = SAP_FIELD_ANY;
        pWanSap->CalledAddr.AddressLength = 0;
        pWanSap->HigherLayerComp.HighLayerInfoLength = 0;
        pWanSap->LowerLayerComp.InfoTransferCap = SAP_FIELD_ANY;
        pWanSap->LowerLayerComp.InfoTransferMode = SAP_FIELD_ANY;
        pWanSap->LowerLayerComp.InfoTransferSymmetry = SAP_FIELD_ANY;

        pClSap->CoSap = pCoSap;
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENING);
        pClSap->ClAf = pClAf;
        pClSap->MediaModes = MediaModes;
        TapiLine->ClSap = pClSap;
        pClSap->TapiLine = TapiLine;

    } while (FALSE);

    return (pClSap);
}
#endif

NDIS_STATUS
PxAfXyzTranslateTapiCallParams(
    IN  PPX_VC                  pVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    )
/*++

Routine Description:

    Translate from TAPI-format to NDIS-format call parameters for an
    outgoing call. We request the Call Manager to do it.

    There is a lot of brute force copying in this routine. The goal is
    to get all parameters into one flat buffer to fit into an NDIS Request.

Arguments:

    pVc                 - the proxy VC to which the MakeCall will be directed
    pTapiParams         - Points to TAPI call parameters
    ppNdisCallParams    - where we return a pointer to NDIS call parameters.

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    NDIS_STATUS                             Status;
    CO_TAPI_TRANSLATE_TAPI_CALLPARAMS *     pTranslateReq = NULL;
    LINE_CALL_PARAMS *                      pInLineCallParams;
    LINE_CALL_PARAMS *                      pDstLineCallParams;
    PCO_CALL_PARAMETERS                     pNdisCallParams;
    ULONG                                   RetryCount;
    ULONG                                   RequestSize;
    ULONG                                   InputParamSize;
    ULONG                                   DestAddrBytes;
    ULONG                                   i, BytesFilled;
    PUCHAR                                  pBuffer;
    PX_REQUEST                              ProxyRequest;
    PPX_REQUEST                             pProxyRequest = &ProxyRequest;
    PNDIS_REQUEST                           pNdisRequest;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    pNdisCallParams = NULL;

    *ppNdisCallParams = NULL;
    DestAddrBytes = sizeof(WCHAR)*(pTapiParams->ulDestAddressSize);

    do {
        pInLineCallParams = (LINE_CALL_PARAMS*)&pTapiParams->LineCallParams;

        //
        //  Calculate space needed for the input parameters
        //
        InputParamSize = 
            sizeof(CO_TAPI_TRANSLATE_TAPI_CALLPARAMS) +
            DestAddrBytes + sizeof(LINE_CALL_PARAMS) + 
            sizeof(CO_CALL_PARAMETERS) + 1024 +
            3*sizeof(PVOID);

        //
        //  Add space for all var length fields in LINE_CALL_PARAMS.
        //
        for (i = 0; i < PX_TCP_NUM_ENTRIES; i++) {
            InputParamSize += 
                *(ULONG *)((PUCHAR)pInLineCallParams + PxTapiCallParamList[i].SizePointer);
            InputParamSize += sizeof(PVOID);
        }

        //
        //  We'll try this atmost twice: the second time would be
        //  if the Call Manager wants us to try again with more
        //  buffer space.
        //
        for (RetryCount = 0; RetryCount < 2; RetryCount++) {
            //
            //  Calculate total space required for the NDIS request.
            //
            RequestSize = InputParamSize + pVc->ClAf->NdisCallParamSize;

            //
            //  Allocate it.
            //
            PxAllocMem(pBuffer, RequestSize, PX_TRANSLATE_CALL);

            if (pBuffer == NULL) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            //
            //  Lay out and fill up the request.
            //
            pNdisRequest = &pProxyRequest->NdisRequest;

            pNdisRequest->RequestType = NdisRequestQueryInformation;

            pNdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                pBuffer;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                RequestSize;

            //
            //  InformationBuffer points to this:
            //
            pTranslateReq = (CO_TAPI_TRANSLATE_TAPI_CALLPARAMS *)pBuffer;

            pTranslateReq->ulLineID = ulLineID;
            pTranslateReq->ulAddressID = ulAddressID;
            pTranslateReq->ulFlags = CO_TAPI_FLAG_OUTGOING_CALL;

            pBuffer = 
                (UCHAR*)((ULONG_PTR)(pTranslateReq + 1) + sizeof(PVOID));
            (ULONG_PTR)pBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

            pTranslateReq->DestAddress.Offset =
                ((ULONG_PTR)pBuffer - 
                         (ULONG_PTR)&pTranslateReq->DestAddress);
            
            //
            //  Fill in the Destination Address.
            //
            pTranslateReq->DestAddress.MaximumLength = // same as Length below
                pTranslateReq->DestAddress.Length = (USHORT)DestAddrBytes;
            NdisMoveMemory(pBuffer,
                           (PUCHAR)((ULONG_PTR)pTapiParams + pTapiParams->ulDestAddressOffset),
                           DestAddrBytes);
            pBuffer += (DestAddrBytes + sizeof(PVOID));
            (ULONG_PTR)pBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

            pTranslateReq->LineCallParams.Offset =
                    (USHORT)((ULONG_PTR)pBuffer - (ULONG_PTR)&pTranslateReq->LineCallParams);

            pDstLineCallParams = (LINE_CALL_PARAMS *)pBuffer;

            //
            //  Copy in input parameters.
            //
            BytesFilled = PxCopyLineCallParams(pInLineCallParams,
                                               pDstLineCallParams);

            pDstLineCallParams->ulAddressMode = LINEADDRESSMODE_ADDRESSID;
            pDstLineCallParams->ulAddressID = ulAddressID;

            pTranslateReq->LineCallParams.MaximumLength = // same as Length below
            pTranslateReq->LineCallParams.Length = (USHORT)BytesFilled;

            pBuffer += (BytesFilled + sizeof(PVOID));
            (ULONG_PTR)pBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

            //
            //  Assign space for NDIS Call Parameters == remaining space.
            //
            pTranslateReq->NdisCallParams.MaximumLength = // same as Length below
            pTranslateReq->NdisCallParams.Length =
                (USHORT)(RequestSize - BytesFilled);

            pTranslateReq->NdisCallParams.Offset =
                (USHORT)((ULONG_PTR)pBuffer - (ULONG_PTR)&pTranslateReq->NdisCallParams);

            pNdisCallParams = (CO_CALL_PARAMETERS *)pBuffer;

            //
            //  Do the request.
            //
            PxInitBlockStruc(&pProxyRequest->Block);

            Status = NdisCoRequest(pVc->Adapter->ClBindingHandle,
                                   pVc->ClAf->NdisAfHandle,
                                   pVc->ClVcHandle,
                                   NULL,            // PartyHandle
                                   pNdisRequest);

            //
            //  Wait for it to complete if it pends.
            //
            if (Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&pProxyRequest->Block);
            }

            //
            //  Did the translation succeed?
            //
            if (Status == NDIS_STATUS_SUCCESS) {
                break;
            }

            //
            //  If the Call Manager needed more buffer, try again.
            //  Remember how much the Call Manager wanted so that we get
            //  smart the next time around.
            //
            if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {
                //
                //  Should happen only if the supplied space for NDIS Call parameters
                //  is not sufficient. And we expect the CM to return the length
                //  it expects in "pTranslateReq->NdisCallParams.MaximumLength".
                //

                //
                //  Remember this new length for future translates.
                //
                pVc->ClAf->NdisCallParamSize =
                    pTranslateReq->NdisCallParams.Length;

                PxFreeMem(pTranslateReq);

                pTranslateReq = NULL;

            } else {
                //
                //  Major problem (e.g. the AF is closing).
                //
                break;
            }
        }

        //
        //  Check if translation was successful.
        //
        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        //
        //  Copy the NDIS Call Parameters into a separate block.
        //
        PxAssert(pNdisCallParams != NULL);

        *ppNdisCallParams = 
            PxCopyCallParameters(pNdisCallParams);

        if (*ppNdisCallParams == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

    }
    while (FALSE);

    if (pTranslateReq != NULL) {
        PxFreeMem(pTranslateReq);
    }

    return (Status);
}

NDIS_STATUS
PxAfXyzTranslateNdisCallParams(
    IN  PPX_VC                  pVc,
    IN  PCO_CALL_PARAMETERS     pNdisCallParams
    )
/*++

Routine Description:

    Translate from NDIS-format to TAPI-format call parameters for an
    incoming call. We request the Call Manager to do it.

Arguments:

    pVc                 - the proxy VC on which the incoming call arrived.
    pNdisCallParams     - points to NDIS call parameters for the call

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    ULONG                                   NdisParamLength;
    ULONG                                   RetryCount;
    ULONG                                   RequestSize;
    PUCHAR                                  pBuffer;
    ULONG                                   CallMgrParamsLength;
    ULONG                                   MediaParamsLength;
    NDIS_STATUS                             Status;
    PNDIS_REQUEST                           pNdisRequest;
    PPX_TAPI_PROVIDER                       TapiProvider;
    PPX_TAPI_LINE                           TapiLine;
    PPX_TAPI_ADDR                           TapiAddr;
    LINE_CALL_INFO *                        pLineCallInfo;
    PCO_CALL_PARAMETERS                     pReqNdisCallParams;
    CO_TAPI_TRANSLATE_NDIS_CALLPARAMS *     pTranslateReq = NULL;
    PX_REQUEST                              ProxyRequest;
    PPX_REQUEST                             pProxyRequest = &ProxyRequest;

    //
    //  Initialize.
    //
    TapiProvider = pVc->ClAf->TapiProvider;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        pVc->pCallParameters =
            PxCopyCallParameters(pNdisCallParams);

        if (pVc->pCallParameters == NULL) {

            PXDEBUGP(PXD_WARNING, PXM_CL,
                ("PxAfXyzTranslateNdisCallParams: failed to allocate memory for callparams\n"));

            Status = NDIS_STATUS_RESOURCES;

            break;
        }

        //
        //  Calculate total length needed for NDIS parameters.
        //
        NdisParamLength = sizeof(CO_CALL_PARAMETERS);
        if (pNdisCallParams->CallMgrParameters) {
            CallMgrParamsLength = (sizeof(CO_CALL_MANAGER_PARAMETERS) +
                                ROUND_UP(pNdisCallParams->CallMgrParameters->CallMgrSpecific.Length));
            NdisParamLength += CallMgrParamsLength;
        }
            
        if (pNdisCallParams->MediaParameters) {
            MediaParamsLength = (sizeof(CO_MEDIA_PARAMETERS) +
                                ROUND_UP(pNdisCallParams->MediaParameters->MediaSpecific.Length));
            NdisParamLength += MediaParamsLength;
        }

        //
        //  Calculate total space needed for the input parameters
        //
        RequestSize =
            sizeof(CO_TAPI_TRANSLATE_NDIS_CALLPARAMS) + NdisParamLength +
            sizeof(LINE_CALL_INFO) + LINE_CALL_INFO_VAR_DATA_SIZE;

        //
        //  We'll try this atmost twice: the second time would be
        //  if the Call Manager wants us to try again with more
        //  buffer space.
        //
        for (RetryCount = 0; RetryCount < 2; RetryCount++) {

            //
            //  Allocate it.
            //
            PxAllocMem(pBuffer, RequestSize, PX_TRANSLATE_CALL);

            if (pBuffer == NULL) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            //
            //  Lay out and fill up the request.
            //
            pNdisRequest = &pProxyRequest->NdisRequest;

            pNdisRequest->RequestType = NdisRequestQueryInformation;
            pNdisRequest->DATA.QUERY_INFORMATION.Oid = OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = RequestSize;

            //
            //  InformationBuffer points to this:
            //
            pTranslateReq = (CO_TAPI_TRANSLATE_NDIS_CALLPARAMS *)pBuffer;

            pTranslateReq->ulFlags = CO_TAPI_FLAG_INCOMING_CALL;

            pBuffer += sizeof(CO_TAPI_TRANSLATE_NDIS_CALLPARAMS);
            pTranslateReq->NdisCallParams.Offset =
                                (USHORT)((ULONG_PTR)pBuffer -
                                         (ULONG_PTR)&pTranslateReq->NdisCallParams);
            pTranslateReq->NdisCallParams.MaximumLength =
            pTranslateReq->NdisCallParams.Length = (USHORT)NdisParamLength;
            
            //
            //  Copy in the NDIS call parameters.
            //
            pReqNdisCallParams = (PCO_CALL_PARAMETERS)pBuffer;
            NdisZeroMemory(pReqNdisCallParams, NdisParamLength);

            pReqNdisCallParams->Flags = pNdisCallParams->Flags;

            pBuffer = (PUCHAR)((ULONG_PTR)pReqNdisCallParams + sizeof(CO_CALL_PARAMETERS));

            if (pNdisCallParams->CallMgrParameters) {
                pReqNdisCallParams->CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)pBuffer;

                NdisMoveMemory(pReqNdisCallParams->CallMgrParameters,
                               pNdisCallParams->CallMgrParameters,
                               sizeof(*pNdisCallParams->CallMgrParameters));

                NdisMoveMemory(&pReqNdisCallParams->CallMgrParameters->CallMgrSpecific.Parameters[0],
                               &pNdisCallParams->CallMgrParameters->CallMgrSpecific.Parameters[0],
                               pNdisCallParams->CallMgrParameters->CallMgrSpecific.Length);

                pBuffer += CallMgrParamsLength;
            }

            if (pNdisCallParams->MediaParameters) {
                pReqNdisCallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)pBuffer;

                NdisMoveMemory(pReqNdisCallParams->MediaParameters,
                               pNdisCallParams->MediaParameters,
                               sizeof(*pNdisCallParams->MediaParameters));

                NdisMoveMemory(&pReqNdisCallParams->MediaParameters->MediaSpecific.Parameters[0],
                               &pNdisCallParams->MediaParameters->MediaSpecific.Parameters[0],
                               pNdisCallParams->MediaParameters->MediaSpecific.Length);
                
                pBuffer += MediaParamsLength;
            }

            //
            //  Space for LINE_CALL_INFO == all that is left.
            //
            pLineCallInfo = (LINE_CALL_INFO *)pBuffer;
            pTranslateReq->LineCallInfo.Offset =
                                (USHORT)((ULONG_PTR)pBuffer -
                                         (ULONG_PTR)&pTranslateReq->LineCallInfo);
            pTranslateReq->LineCallInfo.MaximumLength =
            pTranslateReq->LineCallInfo.Length = (USHORT)(RequestSize -
                                                     pTranslateReq->LineCallInfo.Offset);

            PxInitBlockStruc(&pProxyRequest->Block);

            //
            //  Do the request.
            //
            Status = NdisCoRequest(pVc->Adapter->ClBindingHandle,
                                   pVc->ClAf->NdisAfHandle,
                                   pVc->ClVcHandle,
                                   NULL,            // PartyHandle
                                   pNdisRequest);

            //
            // This call will always return pending (ndis behavior) even
            // though the underlying call manager can never pend it
            // so make pending look like success.
            //
            if (Status == NDIS_STATUS_PENDING) {
                Status = NDIS_STATUS_SUCCESS;
            }

            //
            //  Did the translation succeed?
            //
            if (Status == NDIS_STATUS_SUCCESS) {
                break;
            }

            //
            //  If the Call Manager needed more buffer, try again.
            //
            if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {

                //
                //  Should happen only if the supplied space for LINE_CALL_INFO
                //  is not sufficient. Get the desired length.
                //
                RequestSize =
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

                PxFreeMem(pTranslateReq);
            }
        }


        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        //
        // Now that we have the Id's that this call came in on...
        // validate and setup tapiline/tapiaddr
        //

        //
        // Validate the lineid and get the line control block
        //
        if (!GetLineFromCmLineID(TapiProvider, 
                                 pLineCallInfo->ulLineDeviceID, 
                                 &TapiLine)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, 
                      ("PxAfXyzTranslateNdisCallParams: Invalid LineID %d on Provider %p\n",
                       pLineCallInfo->ulLineDeviceID, TapiProvider));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock(&TapiLine->Lock);

        //
        // Validate the addressid and get the address control block
        //
        if (!IsAddressValid(TapiLine, 
                            pLineCallInfo->ulAddressID, 
                            &TapiAddr)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, 
                      ("PxAfXyzTranslateNdisCallParams: Invalid AddrID %d on TapiLine %p\n",
                       pLineCallInfo->ulAddressID, TapiLine));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisReleaseSpinLock(&TapiLine->Lock);

        NdisAcquireSpinLock(&pVc->Lock);

        pVc->TapiAddr = TapiAddr;
        pVc->TapiLine = TapiLine;

        InterlockedIncrement((PLONG)&TapiAddr->CallCount);
        InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

        //
        //  Allocate CallInfo and copy in the LINE_CALL_INFO structure.
        //
        Status =
            AllocateTapiCallInfo(pVc, pLineCallInfo);

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        pVc->CallInfo->ulLineDeviceID = TapiLine->CmLineID;
        pVc->CallInfo->ulAddressID = TapiAddr->AddrId;
        pVc->CallInfo->ulBearerMode = pLineCallInfo->ulBearerMode;
        pVc->CallInfo->ulMediaMode = pLineCallInfo->ulMediaMode;
        pVc->CallInfo->ulOrigin = LINECALLORIGIN_INBOUND;

        NdisReleaseSpinLock(&pVc->Lock);
    }
    while (FALSE);

    if (pTranslateReq != NULL) {
        PxFreeMem(pTranslateReq);
    }

    return (Status);
}


PPX_CL_SAP
PxAfXyzTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    )
/*++

Routine Description:

    Translate a SAP from TAPI-style (media modes) to a CO_SAP structure
    suitable for use with a Non-CO_ADDRESS_FAMILY_TAPI Call Manager.
    We actually request the call manager to do the translation. Theoretically
    the CM could return a list of SAPs for this media modes setting.

    For now, we assume the call manager returns one SAP. If this routine
    completes successfully, it would have set the pCoSap pointer within the
    AF Block to point to an appropriate SAP structure.

    TBD: Support multiple returned SAPs.

Arguments:

Return Value:

    NDIS_STATUS_SUCCESS if successful, else an appopriate NDIS error code.
--*/
{
    ULONG           SapLength;
    ULONG           RequestLength;
    ULONG           RetryCount;
    ULONG           MediaModes;
    ULONG           SizeNeeded;
    PUCHAR          pBuffer;
    PPX_CL_SAP      pClSap = NULL;
    PCO_SAP         pCoSap;
    NDIS_STATUS     Status;
    PNDIS_REQUEST   pNdisRequest;
    CO_TAPI_TRANSLATE_SAP   *pTranslateSap = NULL;
    PX_REQUEST      ProxyRequest;
    PPX_REQUEST     pProxyRequest = &ProxyRequest;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    MediaModes = TapiLine->DevStatus->ulOpenMediaModes;

    do {
        //
        //  Compute an initial request length.
        //
        RequestLength =
            sizeof(CO_TAPI_TRANSLATE_SAP) + sizeof(CO_SAP) + 100;

        //
        //  Try this atmost twice. The second time is if the Call manager
        //  asks us to retry with more buffer space.
        //
        for (RetryCount = 0; RetryCount < 2; RetryCount++) {

            //
            //  Allocate it.
            //
            PxAllocMem(pBuffer, RequestLength, PX_TRANSLATE_SAP);

            if (pBuffer == NULL) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory(pBuffer, RequestLength);

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            //
            //  InformationBuffer points to this:
            //
            pTranslateSap = (CO_TAPI_TRANSLATE_SAP *)pBuffer;

            pTranslateSap->ulLineID = TapiLine->CmLineID;
            pTranslateSap->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
            pTranslateSap->ulMediaModes = MediaModes;
            pTranslateSap->Reserved = 0;

            pNdisRequest =
                &pProxyRequest->NdisRequest;

            pNdisRequest->RequestType =
                NdisRequestQueryInformation;

            pNdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_TRANSLATE_TAPI_SAP;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                pBuffer;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                RequestLength;

            //
            //  Do the request.
            //
            PxInitBlockStruc(&pProxyRequest->Block);

            Status = NdisCoRequest(pClAf->Adapter->ClBindingHandle,
                                   pClAf->NdisAfHandle,
                                   NULL,
                                   NULL,
                                   pNdisRequest);

            //
            //  Wait for it to complete if it pends.
            //
            if (Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&pProxyRequest->Block);
            }

            //
            //  Did the translation succeed?
            //
            if (Status == NDIS_STATUS_SUCCESS) {
                break;
            }

            //
            //  If the Call Manager needed more buffer, try again.
            //
            if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {
                //
                //  Get the desired length.
                //
                RequestLength =
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;
                PxFreeMem(pTranslateSap);
            }
        }

        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        //
        //  Got the SAP information successfully. Make a copy and save it
        //  in the AF block.
        //
        PxAssert(pTranslateSap->NumberOfSaps == 1); // TBD: allow more

        SapLength = pTranslateSap->NdisSapParams[0].Length;

        SizeNeeded = sizeof(PX_CL_SAP) + SapLength + sizeof(PVOID);

        PxAllocMem(pClSap, SizeNeeded, PX_CLSAP_TAG);

        if (pClSap == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pClSap, SizeNeeded);

        pCoSap = (PCO_SAP)
            ((PUCHAR)pClSap + sizeof(PX_CL_SAP) + sizeof(PVOID));

        (ULONG_PTR)pCoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        PXDEBUGP(PXD_INFO, PXM_UTILS, ("TranslateXyzSap: New ClSap %p , Copying in from %p\n",
                    pClSap,
                    (PUCHAR)((ULONG_PTR)&pTranslateSap->NdisSapParams[0] +
                              pTranslateSap->NdisSapParams[0].Offset)));

        NdisMoveMemory(pCoSap,
                       (PUCHAR)((ULONG_PTR)&pTranslateSap->NdisSapParams[0] + pTranslateSap->NdisSapParams[0].Offset),
                       SapLength);

        pClSap->CoSap = pCoSap;
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENING);
        pClSap->ClAf = pClAf;
        pClSap->MediaModes = MediaModes;
        TapiLine->ClSap = pClSap;
        pClSap->TapiLine = TapiLine;

    } while (FALSE);

    if (pTranslateSap != NULL) {
        PxFreeMem(pTranslateSap);
    }

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("TranslateXyzSap: pClAf %p, pCoSap %p, Status %x\n",
                pClAf, pCoSap, Status));

    return (pClSap);
}


NDIS_STATUS
PxAfTapiTranslateTapiCallParams(
    IN  PPX_VC                  pVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    )
/*++

Routine Description:

    Translate from TAPI-format to NDIS-format call parameters for an
    outgoing call. This is for the CO_ADDRESS_FAMILY_TAPI address family,
    so the translation involves encapsulating the TAPI parameters directly
    into an NDIS CO_CALL_PARAMETERS structure.

Arguments:

    pVc                 - the proxy VC to which the MakeCall will be directed
    ulLineID            - Line ID on which the call will be placed
    ulAddressID         - Address ID on which the call will be placed
    ulFlags             - should be CO_TAPI_FLAG_OUTGOING_CALL
    pTapiParams         - Points to TAPI call parameters
    ppNdisCallParams    - where we return a pointer to NDIS call parameters.

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    INT i;
    NDIS_STATUS Status;
    ULONG HdrSize, MediaSpecificSize, TotalSize;
    ULONG BytesFilled;
    ULONG DestAddrBytes;
    PCO_CALL_PARAMETERS pNdisCallParams;
    PCO_CALL_MANAGER_PARAMETERS pCallMgrParams;
    PCO_MEDIA_PARAMETERS pMediaParams;
    LINE_CALL_PARAMS *pInLineCallParams;
    LINE_CALL_PARAMS *pOutLineCallParams;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED *pCoTapiCallParams;
    UCHAR *pDest;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    pNdisCallParams = NULL;
    *ppNdisCallParams = NULL;

    pInLineCallParams = (LINE_CALL_PARAMS *)&pTapiParams->LineCallParams;

    DestAddrBytes = sizeof(WCHAR)*(pTapiParams->ulDestAddressSize);

    do
    {
        //
        //  Compute the total space required.
        //  The fixed header first:
        //
        HdrSize = sizeof(CO_CALL_PARAMETERS) +
                  sizeof(CO_MEDIA_PARAMETERS) +
                  sizeof(CO_CALL_MANAGER_PARAMETERS) +
                  2*sizeof(PVOID);
        
        //
        //  Next the structure that will be overlayed on the Media-specific
        //  parameters section.
        //
        MediaSpecificSize = sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS);

        //
        //  Space for Destination address from NDIS_TAPI_MAKE_CALL:
        //
        MediaSpecificSize += DestAddrBytes;
        MediaSpecificSize += sizeof(PVOID);

        //
        //  Add space for all the LINE_CALL_PARAMS components.
        //
        MediaSpecificSize += sizeof(LINE_CALL_PARAMS);
        MediaSpecificSize += 2*sizeof(PVOID);

        for (i = 0; i < PX_TCP_NUM_ENTRIES; i++) {
            MediaSpecificSize += *(ULONG *)
                ((PUCHAR)pInLineCallParams + PxTapiCallParamList[i].SizePointer);
            MediaSpecificSize += sizeof(PVOID);
        }

        //
        //  Allocate all that we need.
        //
        TotalSize = HdrSize + MediaSpecificSize;
        PxAllocMem(pNdisCallParams, TotalSize, PX_COCALLPARAMS_TAG);

        if (pNdisCallParams == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pNdisCallParams, TotalSize);

        pCallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)
            ((ULONG_PTR)(pNdisCallParams + 1) + sizeof(PVOID));
        (ULONG_PTR)pCallMgrParams &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        pMediaParams = (PCO_MEDIA_PARAMETERS)
            ((ULONG_PTR)(pCallMgrParams + 1) + sizeof(PVOID));
        (ULONG_PTR)pMediaParams &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        //
        //  Lay out the NDIS Call parameters.
        //
        pNdisCallParams->Flags = 0;

        pNdisCallParams->CallMgrParameters = pCallMgrParams;
        pNdisCallParams->MediaParameters = pMediaParams;

        //
        // These fields are in the FLOWSPEC sub-structure
        //

        //
        // Have to convert bits per sec to Bytes per sec
        //
        pCallMgrParams->Transmit.TokenRate =
        pCallMgrParams->Receive.TokenRate =
        pCallMgrParams->Transmit.PeakBandwidth =
        pCallMgrParams->Receive.PeakBandwidth = pInLineCallParams->ulMaxRate/8;

        pCallMgrParams->Transmit.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
        pCallMgrParams->Receive.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
        pCallMgrParams->Transmit.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
        pCallMgrParams->Receive.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;

        pMediaParams->Flags = TRANSMIT_VC|RECEIVE_VC;
        pMediaParams->ReceivePriority = 0;
        pMediaParams->ReceiveSizeHint = MAX_SDU_SIZE;   // ToDo Guess!
        pMediaParams->MediaSpecific.ParamType = 0;
        pMediaParams->MediaSpecific.Length = MediaSpecificSize;

        pCoTapiCallParams = (CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED *)
                                &pMediaParams->MediaSpecific.Parameters[0];

        //
        //  Prepare the CO_TAPI Call parameters.
        //
        pCoTapiCallParams->ulLineID = ulLineID;
        pCoTapiCallParams->ulAddressID = ulAddressID;
        pCoTapiCallParams->ulFlags = ulFlags;

        //
        //  Destination Address follows the base CO_AF_TAPI_MAKE_CALL_PARAMETERS
        //  structure.
        //
        pDest = (UCHAR *)
            ((ULONG_PTR)(pCoTapiCallParams + 1) + sizeof(PVOID));
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        pCoTapiCallParams->DestAddress.Length = // Same as MaximumLength below
        pCoTapiCallParams->DestAddress.MaximumLength = (USHORT)DestAddrBytes;
        pCoTapiCallParams->DestAddress.Offset =
                    (ULONG_PTR)pDest - (ULONG_PTR)&pCoTapiCallParams->DestAddress;
        NdisMoveMemory(pDest,
                       (UCHAR*)((ULONG_PTR)pTapiParams + pTapiParams->ulDestAddressOffset),
                       DestAddrBytes);

        pDest = (UCHAR*) 
            ((ULONG_PTR)(pDest + DestAddrBytes) + sizeof(PVOID));
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        //
        //  LINE_CALL_PARAMS next. We'll fill in the lengths at the end.
        //  Remember the start of this structure.
        //
        pOutLineCallParams = (LINE_CALL_PARAMS*)pDest;

        pCoTapiCallParams->LineCallParams.Offset =
            (ULONG_PTR)pDest - (ULONG_PTR)&pCoTapiCallParams->LineCallParams;

        BytesFilled = PxCopyLineCallParams(pInLineCallParams,
                                           pOutLineCallParams);

        pOutLineCallParams->ulAddressMode = LINEADDRESSMODE_ADDRESSID;
        pOutLineCallParams->ulAddressID = ulAddressID;

        pCoTapiCallParams->LineCallParams.Length =  
        pCoTapiCallParams->LineCallParams.MaximumLength = 
            (USHORT)BytesFilled;

        //
        //  Set up the return value.
        //
        *ppNdisCallParams = pNdisCallParams;
        break;
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS) {
        //
        //  Clean up.
        //
        if (pNdisCallParams != NULL) {
            PxFreeMem(pNdisCallParams);
        }
    }

    PXDEBUGP(PXD_VERY_LOUD, PXM_UTILS, ("AfTapi: Tapi to Ndis: pCallParams: %x, Status %x\n",
                *ppNdisCallParams, Status));

    return (Status);
}

ULONG
PxCopyLineCallParams(
    IN  LINE_CALL_PARAMS *pSrcLineCallParams,
    OUT LINE_CALL_PARAMS *pDstLineCallParams
    )
/*++

Routine Description:

    Utility routine to make a copy of LINE_CALL_PARAMS.

Arguments:

    pSrcLineCallParams  - Points to the copy source
    pDstLineCallParams  - Points to the copy destination. Assumed to
                          have sufficient room.

Return Value:

    Number of bytes we copied in.

--*/
{
    PUCHAR      pDest;
    PUCHAR      pTemp;
    ULONG       BytesFilled = 0;
    INT         i;

    //
    //  First copy the base structure.
    //
    pDest = (PUCHAR)pDstLineCallParams;
    NdisMoveMemory(pDest,
                   pSrcLineCallParams,
                   sizeof(*pDstLineCallParams));

    pTemp = pDest;
    pDest = (PUCHAR)
        ((ULONG_PTR)pDest + sizeof(*pDstLineCallParams) + sizeof(PVOID));
    (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);
    
    BytesFilled += (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pTemp);

    //
    //  Move on to the variable part.
    //

    //
    //  Get all the variable-length parts in.
    //
    for (i = 0; i < PX_TCP_NUM_ENTRIES; i++)
    {
        ULONG       Length;
        ULONG       SrcOffset;

        Length = *(ULONG *)((ULONG_PTR)pSrcLineCallParams +
                            PxTapiCallParamList[i].SizePointer);

        if (Length == 0)
        {
            continue;
        }

        //
        //  Get the source offset.
        //
        SrcOffset = *(ULONG *)((ULONG_PTR)pSrcLineCallParams +
                            PxTapiCallParamList[i].OffsetPointer);

        //
        //  Fill in the destination offset.
        //
        *(ULONG *)((PUCHAR)pDstLineCallParams + PxTapiCallParamList[i].OffsetPointer) =
                (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pDstLineCallParams);

        //
        //  Copy this thing in.
        //
        NdisMoveMemory(pDest,
                       (PUCHAR)((ULONG_PTR)pSrcLineCallParams + SrcOffset),
                       Length);
        
        pTemp = pDest;

        pDest = (PUCHAR)((ULONG_PTR)pDest + Length + sizeof(PVOID));
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        BytesFilled += (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pTemp);
    }

    return (BytesFilled);
}

NDIS_STATUS
PxAfTapiTranslateNdisCallParams(
    IN  PPX_VC                  pVc,
    IN  PCO_CALL_PARAMETERS     pNdisCallParams
    )
/*++

Routine Description:

    Translate from NDIS-format to TAPI-format call parameters for an
    incoming call belonging to the CO_ADDRESS_FAMILY_TAPI AF. We expect
    the NDIS call parameters to contain TAPI style parameters, and they
    are copied directly into the DRVCALL structure.

Arguments:

    pVc                 - the proxy VC on which the incoming call arrived.
    pNdisCallParams     - points to NDIS call parameters for the call

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    NDIS_STATUS                 Status;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED * pCoTapiParams;
    LINE_CALL_INFO UNALIGNED *  pReceivedCallInfo;
    PPX_TAPI_PROVIDER           TapiProvider;
    PPX_TAPI_LINE               TapiLine;
    PPX_TAPI_ADDR               TapiAddr;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    TapiProvider = pVc->ClAf->TapiProvider;

    do
    {
        pVc->pCallParameters =
            PxCopyCallParameters(pNdisCallParams);

        if (pVc->pCallParameters == NULL) {

            PXDEBUGP(PXD_WARNING, PXM_CL,
                ("PxAfTapiTranslateNdisCallParams: failed to allocate memory for callparams\n"));

            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Some checks here. We might consider removing these and replacing them
        //  with asserts.
        //
        if ((pNdisCallParams == NULL) ||
            (pNdisCallParams->MediaParameters == NULL) ||
            (pNdisCallParams->MediaParameters->MediaSpecific.Length <
                sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)))
        {
            PXDEBUGP(PXD_FATAL, PXM_UTILS, ("AfTapiTranslateNdis: NULL/bad media params in %x\n",
                        pNdisCallParams));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pCoTapiParams = (CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED *)
                            &pNdisCallParams->MediaParameters->MediaSpecific.Parameters[0];
        if (pCoTapiParams->LineCallInfo.Length < sizeof(LINE_CALL_INFO))
        {
            PXDEBUGP(PXD_FATAL, PXM_UTILS, ("AfTapiTranslateNdis: bad length (%d) in CoTapiParams %x\n",
                    pCoTapiParams->LineCallInfo.Length,
                    pCoTapiParams));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        //
        //  Get at the received LINE_CALL_INFO structure.
        //
        pReceivedCallInfo = (LINE_CALL_INFO UNALIGNED *)
                                ((ULONG_PTR)&pCoTapiParams->LineCallInfo +
                                    pCoTapiParams->LineCallInfo.Offset);

        //
        // Now that we have the Id's that this call came in on...
        // validate and setup tapiline/tapiaddr
        //

        //
        // Validate the lineid and get the line control block
        //
        if (!GetLineFromCmLineID(TapiProvider,
                                 pReceivedCallInfo->ulLineDeviceID, 
                                 &TapiLine)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, ("PxAfTapiTranslateNdisCallParams: Invalid LineID %d on Provider %p\n",
                pReceivedCallInfo->ulLineDeviceID, TapiProvider));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock(&TapiLine->Lock);

        //
        // Validate the addressid and get the address control block
        //
        if (!IsAddressValid(TapiLine, pReceivedCallInfo->ulAddressID, &TapiAddr)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, ("PxAfTapiTranslateNdisCallParams: Invalid AddrID %d on TapiLine %p\n",
                pReceivedCallInfo->ulAddressID, TapiLine));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisReleaseSpinLock(&TapiLine->Lock);

        NdisAcquireSpinLock(&pVc->Lock);

        Status =
            AllocateTapiCallInfo(pVc, pReceivedCallInfo);

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        pVc->TapiLine = TapiLine;
        pVc->TapiAddr = TapiAddr;
        InterlockedIncrement((PLONG)&TapiAddr->CallCount);
        InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

        pVc->CallInfo->ulLineDeviceID = TapiLine->CmLineID;
        pVc->CallInfo->ulAddressID = TapiAddr->AddrId;
        //pVc->CallInfo->ulBearerMode = TapiLine->DevCaps->ulBearerModes;
        //pVc->CallInfo->ulMediaMode = TapiLine->DevCaps->ulMediaModes;
        pVc->CallInfo->ulOrigin = LINECALLORIGIN_INBOUND;

        NdisReleaseSpinLock(&pVc->Lock);

        //
        //  Done.
        //
        break;
    }
    while (FALSE);


    PXDEBUGP(PXD_VERY_LOUD, PXM_UTILS, ("AfTapi: Ndis to Tapi: Status %x\n", Status));

    return (Status);
}

PPX_CL_SAP
PxAfTapiTranslateTapiSap(
    IN PPX_CL_AF        pClAf,
    IN PPX_TAPI_LINE    TapiLine
    )
/*++

Routine Description:

    Translate a SAP from TAPI-style (media modes) to a CO_SAP structure
    suitable for use with a CO_ADDRESS_FAMILY_TAPI Call Manager. We actually
    stick the prepared CO_SAP structure's pointer into the AF Block.

Arguments:

Return Value:

    NDIS_STATUS_SUCCESS if successful, else an appopriate NDIS error code.

--*/
{
    PCO_SAP         pCoSap;
    PPX_CL_SAP      pClSap;
    PCO_AF_TAPI_SAP pAfTapiSap;
    ULONG           SapLength;
    ULONG           MediaModes;
    ULONG           SizeNeeded;

    do {
        SapLength = sizeof(CO_SAP) + sizeof(CO_AF_TAPI_SAP);

        SizeNeeded = sizeof(PX_CL_SAP) + sizeof(PVOID) + SapLength;

        PxAllocMem(pClSap, SizeNeeded, PX_CLSAP_TAG);

        if (pClSap == NULL) {
            break;
        }

        NdisZeroMemory(pClSap, SizeNeeded);

        pCoSap = (PCO_SAP)
            ((PUCHAR)pClSap + sizeof(PX_CL_SAP) + sizeof(PVOID));

        (ULONG_PTR)pCoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        MediaModes = TapiLine->DevStatus->ulOpenMediaModes;

        pCoSap->SapType = AF_TAPI_SAP_TYPE;
        pCoSap->SapLength = sizeof(CO_AF_TAPI_SAP);

        pAfTapiSap = (PCO_AF_TAPI_SAP)&pCoSap->Sap[0];
        pAfTapiSap->ulLineID = TapiLine->CmLineID;
        pAfTapiSap->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
        pAfTapiSap->ulMediaModes = MediaModes;

        pClSap->CoSap = pCoSap;
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENING);
        pClSap->ClAf = pClAf;
        pClSap->MediaModes = MediaModes;
        TapiLine->ClSap = pClSap;
        pClSap->TapiLine = TapiLine;

    } while (FALSE);

    return (pClSap);
}

VOID
PxAfTapiFreeNdisSap(
    IN PPX_CL_AF    pClAf,
    IN PCO_SAP      pCoSap
    )
{
    //
    // We need to free the sap
    //

}

PCO_CALL_PARAMETERS
PxCopyCallParameters(
    IN  PCO_CALL_PARAMETERS     pCallParameters
    )
{
    ULONG                   Length;
    ULONG                   CallMgrParamsLength = 0;
    ULONG                   MediaParamsLength = 0;
    PCO_CALL_PARAMETERS     pProxyCallParams;
    PUCHAR                  pBuf;

    Length = sizeof(CO_CALL_PARAMETERS);

    if (pCallParameters->CallMgrParameters){
        CallMgrParamsLength = sizeof(CO_CALL_MANAGER_PARAMETERS) +
                              ROUND_UP(pCallParameters->CallMgrParameters->CallMgrSpecific.Length);

        Length += CallMgrParamsLength;
    }

    if (pCallParameters->MediaParameters) {
        MediaParamsLength = sizeof(CO_MEDIA_PARAMETERS) +
                            ROUND_UP(pCallParameters->MediaParameters->MediaSpecific.Length);

        Length += MediaParamsLength;
    }

    PxAllocMem(pProxyCallParams, Length, PX_COCALLPARAMS_TAG);

    if (pProxyCallParams)
    {
        NdisZeroMemory(pProxyCallParams, Length);

        pProxyCallParams->Flags = pCallParameters->Flags;

        pBuf = (PUCHAR)pProxyCallParams + sizeof(CO_CALL_PARAMETERS);

        if (pCallParameters->CallMgrParameters)
        {
            pProxyCallParams->CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)pBuf;

            NdisMoveMemory(pProxyCallParams->CallMgrParameters,
                           pCallParameters->CallMgrParameters,
                           sizeof(*pCallParameters->CallMgrParameters));

            NdisMoveMemory(&pProxyCallParams->CallMgrParameters->CallMgrSpecific.Parameters[0],
                           &pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0],
                           pCallParameters->CallMgrParameters->CallMgrSpecific.Length);

            pBuf += CallMgrParamsLength;
        }

        if (pCallParameters->MediaParameters)
        {
            pProxyCallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)pBuf;

            NdisMoveMemory(pProxyCallParams->MediaParameters,
                           pCallParameters->MediaParameters,
                           sizeof(*pCallParameters->MediaParameters));

            NdisMoveMemory(&pProxyCallParams->MediaParameters->MediaSpecific.Parameters[0],
                           &pCallParameters->MediaParameters->MediaSpecific.Parameters[0],
                           pCallParameters->MediaParameters->MediaSpecific.Length);
        }
    }

    return (pProxyCallParams);
}

ULONG
PxMapNdisStatusToTapiDisconnectMode(
    IN  NDIS_STATUS             NdisStatus,
    IN  BOOLEAN                 bMakeCallStatus
    )
/*++

Routine Description:

   Maps an NDIS Status code passed to MakeCallComplete or IncomingCloseCall
   to its corresponding TAPI LINEDISCONNECTMODE_XXX code.

Arguments:

    NdisStatus          - the NDIS Status to be mapped
    bMakeCallStatus     - TRUE iff MakeCallComplete status. FALSE iff
                          IncomingCloseCall status.

Return Value:

    ULONG - the TAPI Disconnect Mode value.

--*/
{
    ULONG       ulDisconnectMode;

    switch (NdisStatus)
    {
        case NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL:
            ulDisconnectMode = LINEDISCONNECTMODE_NORMAL;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN:
        case NDIS_STATUS_FAILURE:
            ulDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT:
        case NDIS_STATUS_NOT_ACCEPTED:
            ulDisconnectMode = LINEDISCONNECTMODE_REJECT;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_PICKUP:
            ulDisconnectMode = LINEDISCONNECTMODE_PICKUP;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_FORWARDED:
            ulDisconnectMode = LINEDISCONNECTMODE_FORWARDED;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY:
        case NDIS_STATUS_SAP_IN_USE:
            ulDisconnectMode = LINEDISCONNECTMODE_BUSY;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER:
            ulDisconnectMode = LINEDISCONNECTMODE_NOANSWER;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS:
        case NDIS_STATUS_INVALID_ADDRESS:
            ulDisconnectMode = LINEDISCONNECTMODE_BADADDRESS;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_UNREACHABLE:
        case NDIS_STATUS_NO_ROUTE_TO_DESTINATION:
            ulDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION:
        case NDIS_STATUS_RESOURCES:
            ulDisconnectMode = LINEDISCONNECTMODE_CONGESTION;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE:
            ulDisconnectMode = LINEDISCONNECTMODE_INCOMPATIBLE;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL:
        case NDIS_STATUS_DEST_OUT_OF_ORDER:
            ulDisconnectMode = LINEDISCONNECTMODE_UNAVAIL;
            break;

        case NDIS_STATUS_SUCCESS:
            PxAssert(!bMakeCallStatus);
            ulDisconnectMode = LINEDISCONNECTMODE_NORMAL;
            break;

        default:
            ulDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
    }

    return (ulDisconnectMode);
}

NTSTATUS
IntegerToChar (
    IN ULONG Value,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR IntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    CHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length, Base;

    Shift = 0;
    Base = 10;

    s = &Result[ 32 ];
    *s = '\0';

    do {
        Digit = Value % Base;
        Value = Value / Base;

        *--s = IntegerChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG)(&Result[ 32 ] - s);

    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
        }
    }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
    } else {
        RtlMoveMemory( String, s, Length );

        if ((LONG)Length < OutputLength) {
            String[ Length ] = '\0';
        }
        return( STATUS_SUCCESS );
    }
}

NTSTATUS
IntegerToWChar (
    IN  ULONG Value,
    IN  LONG OutputLength,
    OUT PWCHAR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR IntegerWChars[] = {L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
                             L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length, Base;

    Shift = 0;
    Base = 10;

    s = &Result[ 32 ];
    *s = UNICODE_NULL;

    do {
        Digit = Value % Base;
        Value = Value / Base;

        *--s = IntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG)(&Result[ 32 ] - s);

    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
        }
    }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
    } else {
        RtlMoveMemory( (CHAR *)String, (CHAR *)s, Length * sizeof(WCHAR) );

        if ((LONG)Length < OutputLength) {
            String[ Length ] = UNICODE_NULL;
        }
        return( STATUS_SUCCESS );
    }
}



BOOLEAN
PxAfAndSapFromDevClass(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PPX_CM_AF   *pCmAf,
    PPX_CM_SAP  *pCmSap
    )
{
    PPX_CM_AF   pAf;
    PPX_CM_SAP  pSap;
    BOOLEAN     SapFound;

    NdisAcquireSpinLock(&pAdapter->Lock);

    pAf = (PPX_CM_AF)pAdapter->CmAfList.Flink;

    *pCmAf = NULL;
    *pCmSap = NULL;
    SapFound = FALSE;

    while ((PVOID)pAf != (PVOID)&pAdapter->CmAfList) {

        NdisAcquireSpinLock(&pAf->Lock);

        pSap = (PPX_CM_SAP)pAf->CmSapList.Flink;

        while ((PVOID)pSap != (PVOID)&pAf->CmSapList) {

            if (_wcsicmp((CONST LPCWSTR)pSap->CoSap->Sap, DevClass) == 0) {
                SapFound = TRUE;
                *pCmAf = pAf;
                *pCmSap = pSap;
                REF_CM_AF(pAf);
                break;
            }

            pSap = (PPX_CM_SAP)pSap->Linkage.Flink;
        }

        NdisReleaseSpinLock(&pAf->Lock);

        if (SapFound) {
            break;
        }

        pAf = (PPX_CM_AF)pAf->Linkage.Flink;
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    return (SapFound);
}

VOID
GetAllDevClasses(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PULONG      DevClassSize
    )
{
    PPX_CM_AF   pAf;
    PPX_CM_SAP  pSap;
    ULONG       SizeLeft;
    ULONG       Size = 0;

    NdisAcquireSpinLock(&pAdapter->Lock);

    pAf = (PPX_CM_AF)pAdapter->CmAfList.Flink;

    SizeLeft = *DevClassSize;

    while ((PVOID)pAf != (PVOID)&pAdapter->CmAfList) {

        NdisAcquireSpinLock(&pAf->Lock);

        pSap = (PPX_CM_SAP)pAf->CmSapList.Flink;

        while ((PVOID)pSap != (PVOID)&pAf->CmSapList) {

            if (SizeLeft < pSap->CoSap->SapLength) {
                break;
            }

            NdisMoveMemory((PUCHAR)DevClass, 
                           pSap->CoSap->Sap,
                           pSap->CoSap->SapLength);

            //
            // Add the sizeof of the WCHAR for a WCHAR NULL
            // between each class.
            //
            Size += pSap->CoSap->SapLength + sizeof(WCHAR);
            (PUCHAR)DevClass += Size;
            SizeLeft -= Size;

            pSap = (PPX_CM_SAP)pSap->Linkage.Flink;
        }

        NdisReleaseSpinLock(&pAf->Lock);

        pAf = (PPX_CM_AF)pAf->Linkage.Flink;
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    *DevClassSize = Size;
}

VOID
PxStartIncomingCallTimeout(
    IN  PPX_VC  pVc
    )
{

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxStartIcomingCallTimeout: VC %p/%x, ClVcH %x, ulCallSt %x, ulCallStMode %x\n",
              pVc, pVc->Flags,pVc->ClVcHandle,pVc->ulCallState,pVc->ulCallStateMode));

    if (!(pVc->Flags & PX_VC_CALLTIMER_STARTED)) {
        //
        // We need to ref the Vc for the timer
        // we are about to start
        //
        REF_VC(pVc);

        pVc->Flags |= PX_VC_CALLTIMER_STARTED;
        NdisSetTimer(&pVc->InCallTimer, 60000);
    }
}

VOID
PxStopIncomingCallTimeout(
    IN  PPX_VC  pVc
    )
{
    BOOLEAN     bCancelled;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxStopIcomingCallTimeout: VC %p/%x, ClVcH %x, ulCallSt %x, ulCallStMode %x\n",
              pVc, pVc->Flags,pVc->ClVcHandle,pVc->ulCallState,pVc->ulCallStateMode));

    ASSERT(pVc->Flags & PX_VC_CALLTIMER_STARTED);

    NdisCancelTimer(&pVc->InCallTimer, &bCancelled);

    pVc->Flags &= ~PX_VC_CALLTIMER_STARTED;

    if (bCancelled) {
        DEREF_VC_LOCKED(pVc);
        NdisAcquireSpinLock(&pVc->Lock);
    }

}


VOID
PxIncomingCallTimeout(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   FunctionContext,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    )
{
    PPX_VC              pVc;

    pVc = (PPX_VC)FunctionContext;

    NdisAcquireSpinLock(&pVc->Lock);

    PXDEBUGP(PXD_WARNING, PXM_UTILS, 
             ("PxIncomingCallTimeout: VC %p/%x, ClVcH %x, ulCallSt %x, ulCallStMode %x\n",
              pVc, pVc->Flags,pVc->ClVcHandle,pVc->ulCallState,pVc->ulCallStateMode));

    pVc->Flags &= ~PX_VC_CALLTIMER_STARTED;

    pVc->CloseFlags |= PX_VC_INCALL_TIMEOUT;

    PxVcCleanup(pVc, 0);

    DEREF_VC_LOCKED(pVc);
}

//
// Called with the pVc->Lock held
//
VOID
PxCloseCallWithCm(
    PPX_VC      pVc
    )
{
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxCloseCallWithCm: Vc %p, State: %x, HandoffState: %x Flags %x\n",
              pVc, pVc->State, pVc->HandoffState, pVc->Flags));

    ASSERT(pVc->State == PX_VC_DISCONNECTING);

    pVc->Flags &= ~PX_VC_CLEANUP_CM;
    pVc->CloseFlags |= PX_VC_CM_CLOSE_REQ;

    NdisReleaseSpinLock(&pVc->Lock);

    Status =
        NdisClCloseCall(pVc->ClVcHandle, NULL, NULL, 0);

    if (Status != NDIS_STATUS_PENDING) {
        PxClCloseCallComplete(Status, 
                              (NDIS_HANDLE)pVc->hdCall, 
                              NULL);
    }

    NdisAcquireSpinLock(&pVc->Lock);
}

//
// Called with the pVc->Lock held
//
NDIS_STATUS
PxCloseCallWithCl(
    PPX_VC      pVc
    )
{
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxCloseCallWithCl: Vc %p, State: %x, HandoffState: %x Flags %x\n",
              pVc, pVc->State, pVc->HandoffState, pVc->Flags));

    Status = NDIS_STATUS_PENDING;

    switch (pVc->HandoffState) {
        case PX_VC_HANDOFF_IDLE:
            //
            // We do not have a connection with a client
            // so just return.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        case PX_VC_HANDOFF_OFFERING:
        case PX_VC_HANDOFF_DISCONNECTING:
            //
            // We have a connection with a client but it
            // is in a transient state.  Cleanup will
            // occur when the transient condition completes.
            //
            break;

        case PX_VC_HANDOFF_CONNECTED:

            //
            // We have an active connection with a client
            // so we need to tear it's part of the vc down now
            //
            pVc->HandoffState = PX_VC_HANDOFF_DISCONNECTING;

            NdisReleaseSpinLock(&pVc->Lock);

            NdisCmDispatchIncomingCloseCall(NDIS_STATUS_SUCCESS, 
                                            pVc->CmVcHandle, 
                                            NULL, 
                                            0);

            NdisAcquireSpinLock(&pVc->Lock);
            break;
        default:
            break;
    }

    return (Status);
}

#ifdef CODELETEVC_FIXED
//
// Called with pVc->Lock held
//
VOID
DoDerefVcWork(
    PPX_VC  pVc
    )
{
    NDIS_HANDLE ClVcHandle;
    BOOLEAN     VcOwner;

    if (pVc->Flags & PX_VC_IN_TABLE) {

        ClVcHandle = pVc->ClVcHandle;
        pVc->ClVcHandle = NULL;
        VcOwner = (pVc->Flags & PX_VC_OWNER) ? TRUE : FALSE;

        NdisReleaseSpinLock(&pVc->Lock);

        if (VcOwner && ClVcHandle != NULL) {
            NdisCoDeleteVc(ClVcHandle);
        }
        RemoveVcFromTable(pVc);

    } else {
        NdisReleaseSpinLock(&(pVc)->Lock);
    }

    PxFreeVc(pVc);
}
#else
//
// Called with pVc->Lock held
//
VOID
DoDerefVcWork(
    PPX_VC  pVc
    )
{
    NDIS_HANDLE ClVcHandle, CmVcHandle;
    BOOLEAN     VcOwner;

    if (pVc->Flags & PX_VC_IN_TABLE) {

        CmVcHandle = pVc->CmVcHandle;
        pVc->CmVcHandle = NULL;
        ClVcHandle = pVc->ClVcHandle;
        pVc->ClVcHandle = NULL;
        VcOwner = (pVc->Flags & PX_VC_OWNER) ? TRUE : FALSE;

        NdisReleaseSpinLock(&pVc->Lock);

        if (CmVcHandle != NULL) {
            NdisCoDeleteVc(CmVcHandle);
        }
        if (VcOwner && ClVcHandle != NULL) {
            NdisCoDeleteVc(ClVcHandle);
        }
        RemoveVcFromTable(pVc);
    } else {

        NdisReleaseSpinLock(&(pVc)->Lock);
    }

    PxFreeVc(pVc);
}
#endif

//
// Called with pClAf->Lock held
//
VOID
DoDerefClAfWork(
    PPX_CL_AF   pClAf
    )
{
    NDIS_STATUS _s;

    ASSERT(pClAf->State == PX_AF_CLOSING);

    NdisReleaseSpinLock(&pClAf->Lock);

    _s = NdisClCloseAddressFamily(pClAf->NdisAfHandle);

    if (_s != NDIS_STATUS_PENDING) {
        PxClCloseAfComplete(_s, pClAf);
    }
}

//
// Called with pCmAf->lock held
//
VOID
DoDerefCmAfWork(
    PPX_CM_AF   pCmAf
    )
{
    ASSERT(pCmAf->State == PX_AF_CLOSED);

    NdisReleaseSpinLock(&pCmAf->Lock);

    NdisCmCloseAddressFamilyComplete(NDIS_STATUS_SUCCESS, 
                                     pCmAf->NdisAfHandle);

    PxFreeCmAf(pCmAf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
\***************************************************************************/
#include <stdexts.h>

/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dosGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * try an exact match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
\***************************************************************************/
BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwOptions;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * NULL terminate first argument and get a pointer to
     *  second one (presumably the field name)
     */
    /*
     * Get the options, if any
     */
    if (*pszCmdLine == '-') {
       dwOptions = GetOpts(&pszCmdLine, NULL);
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dosGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        Print("Structure not found: %s\n", pszCmdLine);
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                Print("Field not found: %s. Struct: %s\n", pszField, pst->pszName);
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }

        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);
        Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);
        Print("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset);
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        Print("Address   Value\n");

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            Print("%08lx  ", (DWORD)((PBYTE)pAddress + dwOffset + dwBytesRead));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                Print("%08lx ", *((DWORD *)pBufferOffset));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                Print("%0*lx", dwMoveSize * 2, dwValue);
            }
            Print("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = 0;


    /*
     * Loop through all fields in the table. Print one field per loop
     */
    while (psot->pszField != NULL) {
        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == 2) {
            Print("\n");
            dwFieldsPerRow = 1;
        } else {
            dwFieldsPerRow++;
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            Print("%03lx  %-34.33s", dsoGetOffset(psot), psot->pszField);
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);
            Print("(%03lx) %08lx %-24.23s", dwOffset, dwValue, psot->pszField);
        } /* if (pAddress == NULL) */


        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    Print("\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\pxext.c ===
#include "precomp.h"
#pragma hdrstop

PSTR pszExtName = "PXKD";

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\pxext.h ===
#include <proxy.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\debug.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.c
// RAS L2TP WAN mini-port/call-manager driver
// Debug utilities and globals
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

#ifdef TESTMODE
#define DEFAULTTRACELEVEL  TL_I
#define DEFAULTTRACEMASK TM_XCMsg
#else
#define DEFAULTTRACELEVEL TL_None
#define DEFAULTTRACEMASK TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "L2TP: %p: ", p );
    else
        DbgPrint( "L2TP: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "l2tpp.h"


// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoubleBufferFrees = 0;

// Debug  count of calls to NdisAllocateBuffer/NdisCopyBuffer/NdisFreeBuffer,
// where the total of Alloc and Copy should equal Free in idle state.
//
ULONG g_ulNdisAllocateBuffers = 0;
ULONG g_ulNdisCopyBuffers = 0;
ULONG g_ulNdisFreeBuffers = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    // The requested buffer size is padded, if necessary, so it alligns
    // properly when buffer blocks are layed out.  The alignment rule also
    // applies to the BUFFERBLOCKHEAD and BUFFERHEAD structures, which
    // currently align perfectly.  We will verify once here, rather than code
    // around everywhere else.
    //
    ASSERT( (ALIGN_UP( sizeof(BUFFERBLOCKHEAD), ULONGLONG )
        == sizeof(BUFFERBLOCKHEAD)) );
    ASSERT( (ALIGN_UP( sizeof(BUFFERHEAD), ULONGLONG )
        == sizeof(BUFFERHEAD)) );
    pPool->ulBufferSize = ALIGN_UP( ulBufferSize, ULONGLONG );

    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulBuffersPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitBp tag=$%08x buf=%d cnt=%d",
        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreeBp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    DBG_if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        TRACE( TL_N, TM_Pool, ( "GetBfp=$%p, %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers ) );
    }
    DBG_else
    {
        TRACE( TL_A, TM_Pool, ( "GetBfp failed?" ) );
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_I, TM_Pool, ( "FreeBtoP($%p) %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }

    // Requested by Chun Ye to catch IPSEC problem.
    //
    ASSERT( pHead->pNdisBuffer && !((MDL* )pHead->pNdisBuffer)->Next );

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreeBuffers.Flink != &pHead->linkFreeBuffers)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoubleBufferFrees;
            break;
        }

        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the
                // pool not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddBpBlock(%d+%d)",
        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Bp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                {
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
                }
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc BB?" ) );
                break;
            }

            // Zero only the block header portion.
            //
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocBp=$%x?", status ) );
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocB=$%x?", status ) );
                    ASSERT( FALSE );
                    pHead->pNdisBuffer = NULL;
                    continue;
                }
                else
                {
                    NdisInterlockedIncrement( &g_ulNdisAllocateBuffers );
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedBpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {
            ULONG i;
            BUFFERHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );
                InitializeListHead( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                    NdisInterlockedIncrement( &g_ulNdisFreeBuffers );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\bpool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;
}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );

VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\debug.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.h
// RAS L2TP WAN mini-port/call-manager driver
// Debug helper header
//
// 01/07/97 Steve Cobb


#ifndef _DEBUG_H_
#define _DEBUG_H_


//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//
#define MTAG_FREED       '0T2L'
#define MTAG_ADAPTERCB   '1T2L'
#define MTAG_TUNNELCB    '2T2L'
#define MTAG_VCCB        '3T2L'
#define MTAG_VCTABLE     '4T2L'
#define MTAG_WORKITEM    '5T2L'
#define MTAG_TIMERQ      '6T2L'
#define MTAG_TIMERQITEM  '7T2L'
#define MTAG_PACKETPOOL  '8T2L'
#define MTAG_FBUFPOOL    '9T2L'
#define MTAG_HBUFPOOL    'aT2L'
#define MTAG_TDIXRDG     'bT2L'
#define MTAG_TDIXSDG     'cT2L'
#define MTAG_CTRLRECD    'dT2L'
#define MTAG_CTRLSENT    'eT2L'
#define MTAG_PAYLRECD    'fT2L'
#define MTAG_PAYLSENT    'gT2L'
#define MTAG_INCALL      'hT2L'
#define MTAG_UTIL        'iT2L'
#define MTAG_ROUTEQUERY  'jT2L'
#define MTAG_ROUTESET    'kT2L'
#define MTAG_L2TPPARAMS  'lT2L'
#define MTAG_TUNNELWORK  'mT2L'
#define MTAG_TDIXROUTE   'nT2L'
#define MTAG_CTRLMSGINFO 'oT2L'

// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_V    0x30 // Verbose

// Trace mask bits.
//
#define TM_Cm    0x00000001 // Call manager general
#define TM_Mp    0x00000002 // Mini-port general
#define TM_Send  0x00000004 // Send path
#define TM_Recv  0x00000008 // Receive path
#define TM_Fsm   0x00000010 // Finite state machines
#define TM_Init  0x00000020 // Initialization
#define TM_Misc  0x00000040 // Miscellaneous
#define TM_CMsg  0x00000100 // Control messages and received AVPs
#define TM_Msg   0x00000200 // Verbose message, address, Ns/Nr, payload
#define TM_TWrk  0x00001000 // Tunnel work APC queuing
#define TM_Ref   0x00010000 // References
#define TM_Time  0x00020000 // Timer queue
#define TM_Tdi   0x00040000 // TDI and extensions
#define TM_Pool  0x00080000 // Buffer and packet pooling
#define TM_Stat  0x00100000 // Call statistics
#define TM_Spec  0x01000000 // Special purpose temporary traces
#define TM_MDmp  0x10000000 // Message dumps
#define TM_Dbg   0x80000000 // Debug corruption checks

#define TM_Wild  0xFFFFFFFF // Everything
#define TM_All   0x7FFFFFFF // Everything except corruption checks
#define TM_BTWrk 0x00000FFF // Base with messages and tunnel work
#define TM_BCMsg 0x000001FF // Base with control messages
#define TM_XCMsg 0x001401FF // Base with control messages extended
#define TM_Base  0x000000FF // Base only

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint( "L2TP: " );                                  \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "L2TP: !ASSERT( %s ) at line %d of %s\n", \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\l2tp.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// l2tp.h
//
// Public header for NDIS 5.0 clients and call managers wishing to make calls
// and register Service Access Points using L2TP, the Layer 2 Tunneling
// Protocol.
//
// 01/07/97 Steve Cobb
//
//
// About NdisClRegisterSap 'Sap':
//
// Clients registering an L2TP SAP via NdisClRegisterSap should pass for the
// 'Sap' argument either NULL or an CO_AF_TAPI_SAP structure.  L2TP currently
// supports only a single SAP so the CO_AF_TAPI_SAP, if passed, will be
// ignored.
//
//
// About NdisClMakeCall 'CallParameters':
//
// Clients calling NdisClMakeCall on an L2TP VC should pass
// CO_AF_TAPI_MAKE_CALL_PARAMETERS as the media specific CallParameters
// argument, i.e. CallParameters->MediaParameters->MediaSpecific.Parameters.
// An L2TP_CALL_PARAMETERS structure (below) should be passed in the
// DevSpecificData field of the LINE_CALL_PARAMS within the above structure.
// While it is recommended that caller provide L2TP_CALL_PARAMETERS, the
// driver will accept calls made with none in which case defaults will be
// used.


#ifndef _L2TP_H_
#define _L2TP_H_


// CO_AF_TAPI_MAKE_CALL_PARAMETERS.LineCallParams.ulDevSpecificOffset for L2TP
// calls.  This is passed down on NdisClMakeCall and returned to client's
// ClMakeCallCompleteHandler handler.
//
typedef struct
_L2TP_CALL_PARAMETERS
{
    // L2TPCPF_* bit flags indicating various call options.
    //
    // L2TPCPF_ExclusiveTunnel:  Set when an exclusive tunnel is to be created
    //     to the peer even if another tunnel already exists to the peer.
    //
    ULONG ulFlags;
        #define L2TPCPF_ExclusiveTunnel 0x00000001

    // The vendor-specific physical channel ID of the call reported to LNS by
    // LAC.
    //
    // To MakeCall: The ID reported to peer LNS, or 0xFFFFFFFF for none.  This
    //     has effect only if the OutgoingRole is LAC.
    //
    // From MakeCallCompleteHandler: The ID reported by the L2TP LAC or
    //     0xFFFFFFFF if none.
    //
    ULONG ulPhysicalChannelId;

    // The reasonably unique, progressively increasing call serial number
    // shared by both L2TP peers for troubleshooting.
    //
    // To MakeCall:  Must be set to 0, though ignored.
    //
    // From MakeCallCompleteHandler: The number assigned to the call.
    //
    ULONG ulCallSerialNumber;
}
L2TP_CALL_PARAMETERS;


#endif // _L2TP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\fsm.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// fsm.c
// RAS L2TP WAN mini-port/call-manager driver
// L2TP finite state machine routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
FsmInCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmInCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmInCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmInCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallBearerAnswer(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VOID
FsmOutCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelEstablished(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelIdle(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelWaitCtlConnect(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelWaitCtlReply(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
GetCcAvps(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl,
    OUT USHORT* pusResult,
    OUT USHORT* pusError );

ULONG
StatusFromResultAndError(
    IN USHORT usResult,
    IN USHORT usError );


//-----------------------------------------------------------------------------
// FSM interface routines
//-----------------------------------------------------------------------------

BOOLEAN
FsmReceive(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl )

    // Dispatches a received control message to the appropriate FSM handler.
    // 'PTunnel' and 'pVc' are the tunnel and VC control blocks.  'PControl'
    // is the exploded description of the received control message.  'PBuffer'
    // is the receieve buffer.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
    // Returns true if the message was processed, false if
    // SetupVcAsynchronously was called.
    //
{
    TRACE( TL_V, TM_Cm, ( "FsmReceive" ) );

    if (pControl->fTunnelMsg)
    {
        switch (pTunnel->state)
        {
            case CCS_Idle:
            {
                FsmTunnelIdle( pTunnel, pControl );
                break;
            }

            case CCS_WaitCtlReply:
            {
                FsmTunnelWaitCtlReply( pTunnel, pControl );
                break;
            }

            case CCS_WaitCtlConnect:
            {
                FsmTunnelWaitCtlConnect( pTunnel, pControl );
                break;
            }

            case CCS_Established:
            {
                FsmTunnelEstablished( pTunnel, pControl );
                break;
            }
        }
    }
    else
    {
        if (!pVc)
        {
            if (*(pControl->pusMsgType) == CMT_ICRQ
                || *(pControl->pusMsgType) == CMT_OCRQ)
            {
                ULONG ulIpAddress;

                // Peer wants to start a new call.  Set up a VC and dispatch
                // the received call request to the client above.  This is an
                // asynchronous operation that will eventually call
                // ReceiveControlExpected to finish processing the message.
                //
                ulIpAddress = pTunnel->address.ulIpAddress;
                NdisReleaseSpinLock( &pTunnel->lockT );
                {
                    SetupVcAsynchronously(
                        pTunnel, ulIpAddress, pBuffer, pControl );
                }
                NdisAcquireSpinLock( &pTunnel->lockT );
                return FALSE;
            }
            else
            {
                // Don't know what VC the call control message if for and it's
                // not a "create new call" request, so there's nothing useful
                // to do.  Ignore it.  Don't want to bring down the tunnel
                // because it may just be out of order.  One case is where
                // post-ICRQ packets are received before ICRQ is processed, to
                // create the VC block.
                //
                TRACE( TL_A, TM_Fsm,
                    ( "CMT %d w/o VC?", *(pControl->pusMsgType) ) );
                return TRUE;
            }
        }

        NdisAcquireSpinLock( &pVc->lockV );
        {
            if (ReadFlags( &pVc->ulFlags ) & VCBF_IncomingFsm)
            {
                // L2TP Incoming Call FSM for both LAC/LNS.
                //
                switch (pVc->state)
                {
                    case CS_Idle:
                    {
                        FsmInCallIdle( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitReply:
                    {
                        FsmInCallWaitReply( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitConnect:
                    {
                        FsmInCallWaitConnect( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_Established:
                    {
                        FsmInCallEstablished( pTunnel, pVc, pControl );
                        break;
                    }
                }
            }
            else
            {
                // L2TP Outgoing Call FSM for both LAC/LNS.
                //
                switch (pVc->state)
                {
                    case CS_Idle:
                    {
                        FsmOutCallIdle( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitReply:
                    {
                        FsmOutCallWaitReply( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitConnect:
                    {
                        FsmOutCallWaitConnect( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitCsAnswer:
                    {
                        // Because no WAN modes are supported and locks are
                        // held during the "null" WAN bearer answer, we should
                        // never be in this state on a received message.
                        //
                        ASSERT( FALSE );
                        break;
                    }

                    case CS_Established:
                    {
                        FsmOutCallEstablished( pTunnel, pVc, pControl );
                        break;
                    }
                }
            }
        }
        NdisReleaseSpinLock( &pVc->lockV );
    }

    return TRUE;
}


VOID
FsmOpenTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to handle a Control Connection (tunnel) Open
    // event.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Fsm, ( "FsmOpenTunnel" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pVc->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    status = NDIS_STATUS_SUCCESS;
    if (!(ReadFlags( &pTunnel->ulFlags ) & TCBF_TdixReferenced))
    {
        // Set up TDI for L2TP send/receive.
        //
        status = TdixOpen( &pAdapter->tdix );
        if (status == NDIS_STATUS_SUCCESS)
        {
            // Set this flag so TdixClose is called as the tunnel control
            // block is destroyed.
            //
            SetFlags( &pTunnel->ulFlags, TCBF_TdixReferenced );
        }
        else
        {
            TRACE( TL_A, TM_Fsm, ( "TdixOpen=$%08x", status ) );
        }
    }

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
            {
                // New tunnel requests cannot be linked onto closing tunnels
                // as they would not be properly cleaned up.
                //
                TRACE( TL_A, TM_Fsm, ( "FOT aborted" ) );
                status = NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN;
            }
        }

        if (status == NDIS_STATUS_SUCCESS)
        {
            if (ReadFlags( &pTunnel->ulFlags ) & TCBF_CcInTransition)
            {
                // The tunnel control channel is in the process of changing
                // states from Idle to Established or vice-versa.  Queue our
                // request to be resolved when the result is known.  See
                // TunnelTransitionComplete.
                //
                ASSERT(
                    pVc->linkRequestingVcs.Flink == &pVc->linkRequestingVcs );
                InsertTailList(
                    &pTunnel->listRequestingVcs, &pVc->linkRequestingVcs );
            }
            else
            {
                // The tunnel control channel is in the Idle or Established
                // states and no transition is underway.
                //
                if (pTunnel->state == CCS_Established)
                {
                    // The tunnel control channel is already up, so skip ahead
                    // to making a call to establish the data channel.
                    //
                    FsmOpenCall( pTunnel, pVc );
                }
                else
                {
                    // The tunnel control channel is down, so try to bring it
                    // up.
                    //
                    FsmOpenIdleTunnel( pTunnel, pVc );
                }
            }
        }
        else
        {
            // Fail the call.
            //
            NdisAcquireSpinLock( &pVc->lockV );
            {
                pVc->status = status;
                CallTransitionComplete( pTunnel, pVc, CS_Idle );
            }
            NdisReleaseSpinLock( &pVc->lockV );

            CompleteVcs( pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
FsmOpenIdleTunnel(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Initiate the tunnel connection on 'pTunnel' requested by 'pVc', i.e.
    // send the initial SCCRQ which kicks off the control connection (tunnel)
    // FSM.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    TRACE( TL_N, TM_Cm, ( "FsmOpenIdleTunnel" ) );
    ASSERT( pTunnel->state == CCS_Idle );

    SetFlags( &pTunnel->ulFlags, TCBF_CcInTransition );
    ASSERT( pVc->linkRequestingVcs.Flink == &pVc->linkRequestingVcs );
    InsertTailList( &pTunnel->listRequestingVcs, &pVc->linkRequestingVcs );

    pTunnel->state = CCS_WaitCtlReply;
    SendControl( pTunnel, NULL, CMT_SCCRQ, 0, 0, NULL, 0 );
}


VOID
FsmOpenCall(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Execute an "open" event for a call on 'pTunnel'/'pVc' playing the role
    // of the LAC/LNS indicated by the VCBF_IncomingFsm flag.  The owning
    // tunnel must be established first.
    //
{
    ULONG ulFlags;
    USHORT usMsgType;

    ulFlags = ReadFlags( &pVc->ulFlags );

    TRACE( TL_N, TM_Cm, ( "FsmCallOpen" ) );
    ASSERT( (ulFlags & VCBF_ClientOpenPending)
        || (ulFlags & VCBF_PeerOpenPending) );
    ASSERT( pVc->state == CS_Idle || pVc->state == CS_WaitTunnel );

    ActivateCallIdSlot( pVc );

    if (pVc->pAdapter->usPayloadReceiveWindow)
    {
        SetFlags( &pVc->ulFlags, VCBF_Sequencing );
    }

    usMsgType = (USHORT )((ulFlags & VCBF_IncomingFsm) ? CMT_ICRQ : CMT_OCRQ );

    pVc->state = CS_WaitReply;
    SendControl( pTunnel, pVc, usMsgType, 0, 0, NULL, 0 );
}


VOID
FsmCloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close down 'pTunnel' gracefully.  Arg0 and
    // Arg1 are the result and error codes to send in the StopCCN message.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    USHORT usResult;
    USHORT usError;

    // Unpack context information, then free the work item.
    //
    usResult = (USHORT )(punpArgs[ 0 ]);
    usError = (USHORT )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    ASSERT( usResult );

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        if (pTunnel->state == CCS_Idle
            || pTunnel->state == CCS_WaitCtlReply)
        {
            TRACE( TL_I, TM_Cm,
                ( "FsmCloseTunnel(f=$%08x,r=%d,e=%d) now",
                ReadFlags( &pTunnel->ulFlags ),
                (UINT )usResult, (UINT )usError ) );

            // The tunnel's already idle so no closing exchange is necessary.
            // We also include the other state where we've had no response
            // from peer, but have sent our SCCRQ.  This is a tad rude to the
            // remote peer as we're deciding that it's more important to
            // respond quickly to our cancelling user than it is to wait for a
            // peer who may not be responding.  However, this is the trade-off
            // we've chosen.
            //
            CloseTunnel2( pTunnel );
        }
        else
        {
            TRACE( TL_I, TM_Cm,
                ( "FsmCloseTunnel(f=$%08x,r=%d,e=%d) grace",
                ReadFlags( &pTunnel->ulFlags ),
                (UINT )usResult, (UINT )usError ) );

            // Set flags and reference the tunnel for "graceful close".  The
            // reference is removed when the tunnel reaches idle state.
            //
            SetFlags( &pTunnel->ulFlags,
                (TCBF_Closing | TCBF_FsmCloseRef | TCBF_CcInTransition) );
            ReferenceTunnel( pTunnel, FALSE );

            // Initiate the closing exchange, holding the VC until the closing
            // message is acknowledged.
            //
            pTunnel->state = CCS_Idle;
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, (ULONG )usError, NULL, CSF_TunnelIdleOnAck );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
FsmCloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close down the call on 'pVc' gracefully.  Arg0
    // and Arg1 are the result and error codes to send in the CDN message.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    BOOLEAN fCompleteVcs;
    USHORT usResult;
    USHORT usError;

    // Unpack context information, then free the work item.
    //
    usResult = (USHORT )(punpArgs[ 0 ]);
    usError = (USHORT )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    ASSERT( usResult );

    fCompleteVcs = FALSE;
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        NdisAcquireSpinLock( &pVc->lockV );
        {
            if (pVc->state == CS_Idle
                || pVc->state == CS_WaitTunnel
                || (ReadFlags( &pVc->ulFlags ) & VCBF_PeerClosePending))
            {
                TRACE( TL_I, TM_Cm,
                    ( "FsmCloseCall(f=$%08x,r=%d,e=%d) now",
                    ReadFlags( &pVc->ulFlags ),
                    (UINT )usResult, (UINT )usError ) );

                if (usResult == CRESULT_GeneralWithError)
                {
                    usResult = TRESULT_GeneralWithError;
                }
                else
                {
                    usResult = TRESULT_Shutdown;
                    usError = GERR_None;
                }

                // Slam the call closed.
                //
                fCompleteVcs = CloseCall2( pTunnel, pVc, usResult, usError );
            }
            else
            {
                TRACE( TL_I, TM_Cm,
                    ( "FsmCloseCall(f=$%08x,r=%d,e=%d) grace",
                    ReadFlags( &pVc->ulFlags ),
                    (UINT )usResult, (UINT )usError ) );

                // Initiate the closing exchange.
                //
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
                pVc->state = CS_Idle;
                SendControl(
                    pTunnel, pVc, CMT_CDN,
                    (ULONG )usResult, (ULONG )usError, NULL, CSF_CallIdleOnAck );
            }

        }
        NdisReleaseSpinLock( &pVc->lockV );

        if (fCompleteVcs)
        {
            CompleteVcs( pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
TunnelTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN L2TPCCSTATE state )

    // Sets 'pTunnel's state to it's new CCS_Idle or CCS_Established 'state'
    // and kickstarts any MakeCall's that pended on the result.  If
    // established, adds the host route directing IP traffic to the L2TP peer
    // to the LAN card rather than the WAN (tunnel) adapter.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    NDIS_STATUS status;
    LIST_ENTRY list;
    LIST_ENTRY* pLink;
    ULONG ulFlags;
    VCCB* pVc;

    pTunnel->state = state;
    ClearFlags( &pTunnel->ulFlags, TCBF_CcInTransition );
    ulFlags = ReadFlags( &pTunnel->ulFlags );

    if (state == CCS_Established)
    {
        TRACE( TL_A, TM_Fsm,
            ( "TUNNEL %d UP", (ULONG )pTunnel->usTunnelId ) );

        // The tunnel any requesting VCs wanted established was established.
        // Skip ahead to establishing the outgoing calls.
        //
        while (!IsListEmpty( &pTunnel->listRequestingVcs ))
        {
            pLink = RemoveHeadList( &pTunnel->listRequestingVcs );
            InitializeListHead( pLink );
            pVc = CONTAINING_RECORD( pLink, VCCB, linkRequestingVcs );
            FsmOpenCall( pTunnel, pVc );
        }

        // Add the host route so traffic sent to the L2TP peer goes out the
        // LAN card instead of looping on the WAN (tunnel) interface, when
        // activated.
        //
        TRACE( TL_N, TM_Recv, ( "Schedule AddHostRoute" ) );
        ASSERT( !(ulFlags & TCBF_HostRouteAdded) );
        ScheduleTunnelWork(
            pTunnel, NULL, AddHostRoute,
            0, 0, 0, 0, FALSE, FALSE );
    }
    else
    {
        ASSERT( state == CCS_Idle );
        SetFlags( &pTunnel->ulFlags, TCBF_Closing );

        TRACE( TL_A, TM_Fsm,
            ( "%s TUNNEL %d DOWN",
            ((ulFlags & TCBF_PeerInitiated) ? "PEER" : "LOCAL"),
            (ULONG )pTunnel->usTunnelId ) );

        // Any VCs associated with the tunnel are abruptly terminated.  This
        // is done by making it look like any pending operation has failed, or
        // if none is pending, that a bogus peer initiated close has
        // completed.
        //
        NdisAcquireSpinLock( &pTunnel->lockVcs );
        {
            for (pLink = pTunnel->listVcs.Flink;
                 pLink != &pTunnel->listVcs;
                 pLink = pLink->Flink)
            {
                VCCB* pVc;

                pVc = CONTAINING_RECORD( pLink, VCCB, linkVcs );

                NdisAcquireSpinLock( &pVc->lockV );
                {
                    if (pVc->status == NDIS_STATUS_SUCCESS)
                    {
                        if (ulFlags & TCBF_PeerNotResponding)
                        {
                            // Line went down because peer stopped responding
                            // (or never responded).
                            //
                            pVc->status =
                                NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER;
                        }
                        else
                        {
                            // Line went down for unknown reason.
                            //
                            pVc->status =
                                NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN;
                        }
                    }

                    CallTransitionComplete( pTunnel, pVc, CS_Idle );
                }
                NdisReleaseSpinLock( &pVc->lockV );
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockVcs );

        ASSERT( IsListEmpty( &pTunnel->listRequestingVcs ) );

        // Flush the outstanding send list.
        //
        while (!IsListEmpty( &pTunnel->listSendsOut ))
        {
            CONTROLSENT* pCs;

            pLink = RemoveHeadList( &pTunnel->listSendsOut );
            InitializeListHead( pLink );
            pCs = CONTAINING_RECORD( pLink, CONTROLSENT, linkSendsOut );

            TRACE( TL_I, TM_Recv, ( "Flush pCs=$%p", pCs ) );

            // Terminate the timer.  Doesn't matter if the terminate fails as
            // the expire handler recognizes the context is not on the "out"
            // list and does nothing.
            //
            ASSERT( pCs->pTqiSendTimeout );
            TimerQTerminateItem( pTunnel->pTimerQ, pCs->pTqiSendTimeout );

            // Remove the context reference corresponding to linkage in the
            // "out" list.  Terminate the
            //
            DereferenceControlSent( pCs );
        }

        // Flush the out of order list.
        //
        while (!IsListEmpty( &pTunnel->listOutOfOrder ))
        {
            CONTROLRECEIVED* pCr;
            ADAPTERCB* pAdapter;

            pLink = RemoveHeadList( &pTunnel->listOutOfOrder );
            InitializeListHead( pLink );
            pCr = CONTAINING_RECORD( pLink, CONTROLRECEIVED, linkOutOfOrder );

            TRACE( TL_I, TM_Recv, ( "Flush pCr=$%p", pCr ) );

            pAdapter = pTunnel->pAdapter;
            FreeBufferToPool( &pAdapter->poolFrameBuffers, pCr->pBuffer, TRUE );

            if (pCr->pVc)
            {
                DereferenceVc( pCr->pVc );
            }

            FREE_CONTROLRECEIVED( pAdapter, pCr );
        }

        // Cancel the "hello" timer if it's running.
        //
        if (pTunnel->pTqiHello)
        {
            TimerQCancelItem( pTunnel->pTimerQ, pTunnel->pTqiHello );
            pTunnel->pTqiHello = NULL;
        }

        if (ulFlags & TCBF_PeerInitRef)
        {
            // Remove the "peer initiation" tunnel reference.
            //
            ClearFlags( &pTunnel->ulFlags, TCBF_PeerInitRef );
            DereferenceTunnel( pTunnel );
        }

        if (ulFlags & TCBF_FsmCloseRef)
        {
            // Remove the "graceful close" tunnel reference.
            //
            ClearFlags( &pTunnel->ulFlags, TCBF_FsmCloseRef );
            DereferenceTunnel( pTunnel );
        }
    }
}


VOID
CallTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN L2TPCALLSTATE state )

    // Sets 'pVc's state to it's new CS_Idle or CS_Established state and sets
    // up for reporting the result to the client.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT' and 'pVc->lockV'.
    //
{
    ULONG ulFlags;

    pVc->state = state;

    ulFlags = ReadFlags( &pVc->ulFlags );
    if (!(ulFlags & VCBM_Pending))
    {
        if (ulFlags & VCBF_CallClosableByPeer)
        {
            // Nothing else was pending and the call is closable so either
            // peer initiated a close or some fatal error occurred which will
            // be cleaned up as if peer initiated a close.
            //
            ASSERT( pVc->status != NDIS_STATUS_SUCCESS );
            SetFlags( &pVc->ulFlags, VCBF_PeerClosePending );
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
        else
        {
            // Nothing was pending and the call's not closable, so there's no
            // action required for this transition.
            //
            TRACE( TL_I, TM_Fsm, ( "Call not closable" ) );
            return;
        }
    }
    else if (ulFlags & VCBF_ClientOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending client open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from both client and peer.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient | VCBF_CallClosableByPeer ));
        }
    }
    else if (ulFlags & VCBF_PeerOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending peer open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from the peer.  Client closes must be accepted because of the
            // way CoNDIS loops dispatched close calls back to the CM's close
            // handler.
            //
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
    }

    // Update some call statistics.
    //
    {
        LARGE_INTEGER lrgTime;

        NdisGetCurrentSystemTime( &lrgTime );
        if (pVc->state == CS_Idle)
        {
            if (pVc->stats.llCallUp)
            {
                pVc->stats.ulSeconds = (ULONG )
                   (((ULONGLONG )lrgTime.QuadPart - pVc->stats.llCallUp)
                       / 10000000);
            }
        }
        else
        {
            ASSERT( pVc->state == CS_Established );
            pVc->stats.llCallUp = (ULONGLONG )lrgTime.QuadPart;

            pVc->stats.ulMinSendWindow =
                pVc->stats.ulMaxSendWindow =
                    pVc->ulSendWindow;
        }
    }

    TRACE( TL_A, TM_Fsm, ( "CALL %d ON TUNNEL %d %s",
        (ULONG )pVc->usCallId, (ULONG )pTunnel->usTunnelId,
        ((state == CS_Established) ? "UP" : "DOWN") ) );

    // Move the VC onto the tunnel's completing list.  The VC may or may not
    // be on the tunnel request list, but if it is, remove it.
    //
    RemoveEntryList( &pVc->linkRequestingVcs );
    InitializeListHead( &pVc->linkRequestingVcs );
    ASSERT( pVc->linkCompletingVcs.Flink == &pVc->linkCompletingVcs );
    InsertTailList( &pTunnel->listCompletingVcs, &pVc->linkCompletingVcs );
}


//-----------------------------------------------------------------------------
// FSM utility routines (alphabetically)
//-----------------------------------------------------------------------------

VOID
FsmInCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM Established state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_CDN)
    {
        // Call is down.
        //
        pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmInCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM Idle state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (*(pControl->pusMsgType) == CMT_ICRQ)
    {
        if (!(ReadFlags( &pVc->ulFlags ) & VCBF_PeerOpenPending))
        {
            // If no open is pending, the call and/or owning tunnel has been
            // slammed, we are in the clean up phase, and no response should
            // be made.
            //
            TRACE( TL_A, TM_Fsm, ( "IC aborted" ) );
            return;
        }

        if (*pControl->pusAssignedCallId)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }

        if (pVc->usResult)
        {
            // Call is down, but must hold the VC until the closing message is
            // acknowledged.
            //
            pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
            pVc->state = CS_Idle;
            SendControl(
                pTunnel, pVc, CMT_CDN,
                (ULONG )pVc->usResult, (ULONG )pVc->usError, NULL,
                CSF_CallIdleOnAck );
        }
        else
        {
            if (pAdapter->usPayloadReceiveWindow)
            {
                SetFlags( &pVc->ulFlags, VCBF_Sequencing );
            }

            // Stash call serial number.
            //
            if (pControl->pulCallSerialNumber)
            {
                pVc->pLcParams->ulCallSerialNumber =
                    *(pControl->pulCallSerialNumber);
            }
            else
            {
                pVc->pLcParams->ulCallSerialNumber = 0;
            }

            // Stash acceptable bearer types.
            //
            pVc->pTcInfo->ulMediaMode = 0;
            if (pControl->pulBearerType)
            {
                if (*(pControl->pulBearerType) & BBM_Analog)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DATAMODEM;
                }

                if (*(pControl->pulBearerType) & BBM_Digital)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DIGITALDATA;
                }
            }

            // Stash physical channel ID.
            //
            if (pControl->pulPhysicalChannelId)
            {
                pVc->pLcParams->ulPhysicalChannelId =
                    *(pControl->pulPhysicalChannelId);
            }
            else
            {
                pVc->pLcParams->ulPhysicalChannelId = 0xFFFFFFFF;
            }

            // Note: The phone numbers of the caller and callee as well as the
            // Subaddress are available at this point.  Currently, the
            // CallerID field of the TAPI structures is used for the IP
            // address of the other end of the tunnel, which is used above for
            // the IPSEC filters.  The WAN caller information may also be
            // useful but there is no obvious way to return both the WAN and
            // tunnel endpoints in the current TAPI structures.

            // Send response.
            //
            pVc->state = CS_WaitConnect;
            SendControl( pTunnel, pVc, CMT_ICRP, 0, 0, NULL, 0 );
        }
    }
}


VOID
FsmInCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM WaitConnect state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_ICCN)
    {
        if (pControl->pulTxConnectSpeed)
        {
            pVc->ulConnectBps = *(pControl->pulTxConnectSpeed);
        }
        else
        {
            // Not supposed to happen, but go on with a least common
            // denominator if it does.
            //
            pVc->ulConnectBps = 9600;
        }

        if (pControl->pulFramingType
            && !(*(pControl->pulFramingType) & FBM_Sync))
        {
            // Uh oh, the call is not using synchronous framing, which is the
            // only one NDISWAN supports.  Peer should have noticed we don't
            // support asynchronous during tunnel setup.  Close the call.
            //
            TRACE( TL_A, TM_Fsm, ( "Sync framing?" ) );

            if (!(pVc->pAdapter->ulFlags & ACBF_IgnoreFramingMismatch))
            {
                ScheduleTunnelWork(
                    pTunnel, pVc, FsmCloseCall,
                    (ULONG_PTR )CRESULT_GeneralWithError,
                    (ULONG_PTR )GERR_None,
                    0, 0, FALSE, FALSE );
                return;
            }
        }

        if (!pControl->pusRWindowSize)
        {
            // Peer did not send a receive window AVP so we're not doing Ns/Nr
            // flow control on the session.  If we requested sequencing peer
            // is really supposed to send his window, but if he doesn't assume
            // that means he wants no sequencing.  The draft/RFC is a little
            // ambiguous on this point.
            //
            DBG_if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
                TRACE( TL_A, TM_Fsm, ( "No rw when we sent one?" ) );

            ClearFlags( &pVc->ulFlags, VCBF_Sequencing );
        }
        else
        {
            ULONG ulNew;

            if (*(pControl->pusRWindowSize) == 0)
            {
                // When peer sends a receive window of 0 it means he needs
                // sequencing to do out of order handling but doesn't want to
                // do flow control.  (Why would anyone choose this?) We fake
                // "no flow control" by setting a huge send window that should
                // never be filled.
                //
                pVc->ulMaxSendWindow = 10000;
            }
            else
            {
                pVc->ulMaxSendWindow = *(pControl->pusRWindowSize);
            }

            // Set the initial send window to 1/2 the maximum, to "slow start"
            // in case the networks congested.  If it's not the window will
            // quickly adapt to the maximum.
            //
            ulNew = pVc->ulMaxSendWindow >> 1;
            pVc->ulSendWindow = max( ulNew, 1 );
        }

        // Initialize the round trip time to the packet processing delay, if
        // any, per the draft/RFC.  The PPD is in 1/10ths of seconds.
        //
        if (pControl->pusPacketProcDelay)
        {
            pVc->ulRoundTripMs =
                ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
        }
        else if (pVc->ulRoundTripMs == 0)
        {
            pVc->ulRoundTripMs = pVc->pAdapter->ulInitialSendTimeoutMs;
        }

        // Call is up.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Established );
    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        // Call is down.
        //
        pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmInCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Incoming call creation FSM WaitReply state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (*(pControl->pusMsgType) == CMT_ICRP)
    {
        pVc->pMakeCall->Flags |= CALL_PARAMETERS_CHANGED;

        if (pControl->pusAssignedCallId && *(pControl->pusAssignedCallId) > 0)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }
        else
        {
            ASSERT( !"No assigned CID?" );
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )TRESULT_GeneralWithError,
                (ULONG_PTR )GERR_BadCallId,
                0, 0, FALSE, FALSE );
            return;
        }

        // Use the queried media speed to set the connect speed
        //
        pVc->ulConnectBps = pTunnel->ulMediaSpeed;

        if (pControl->pusRWindowSize)
        {
            ULONG ulNew;

            SetFlags( &pVc->ulFlags, VCBF_Sequencing );

            if (*(pControl->pusRWindowSize) == 0)
            {
                // When peer sends a receive window of 0 it means he needs
                // sequencing to do out of order handling but doesn't want to
                // do flow control.  (Why would anyone choose this?) We fake
                // "no flow control" by setting a huge send window that should
                // never be filled.
                //
                pVc->ulMaxSendWindow = 10000;
            }
            else
            {
                pVc->ulMaxSendWindow = (ULONG )*(pControl->pusRWindowSize);
            }

            // Set the initial send window to 1/2 the maximum, to "slow start"
            // in case the networks congested.  If it's not the window will
            // quickly adapt to the maximum.
            //
            ulNew = pVc->ulMaxSendWindow >> 1;
            pVc->ulSendWindow = max( ulNew, 1 );
        }

        // Initialize the round trip time to the packet processing delay, if
        // any, per the draft/RFC.  The PPD is in 1/10ths of seconds.  If it's
        // not here, it might show up in the InCallConn.
        //
        if (pControl->pusPacketProcDelay)
        {
            pVc->ulRoundTripMs =
                ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
        }

        // Send InCallConn and the call is up.
        //
        SendControl( pTunnel, pVc, CMT_ICCN, 0, 0, NULL, 0 );
        CallTransitionComplete( pTunnel, pVc, CS_Established );

    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        USHORT usResult;
        USHORT usError;

        if (pControl->pusResult)
        {
            usResult = *(pControl->pusResult);
            usError = *(pControl->pusError);
        }
        else
        {
            usResult = CRESULT_GeneralWithError;
            usError = GERR_BadValue;
        }

        // Map the result/error to a TAPI disconnect code.
        //
        pVc->status = StatusFromResultAndError( usResult, usError );

        // Call is down.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmOutCallBearerAnswer(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // The bearer WAN media has answered the call initiated by an outgoing
    // call request from peer.  'PVc' is the VC control block associated with
    // the outgoing call.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    ASSERT( pVc->state == CS_WaitCsAnswer );

    pAdapter = pVc->pAdapter;

    // Send OutCallConn, and the call is up.
    //
    SendControl( pTunnel, pVc, CMT_OCCN, 0, 0, NULL, 0 );
    CallTransitionComplete( pTunnel, pVc, CS_Established );
}


VOID
FsmOutCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM Established state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_CDN)
    {
        // Call is down.
        //
        pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmOutCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM Idle state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (*(pControl->pusMsgType) == CMT_OCRQ)
    {
        if (!(ReadFlags( &pVc->ulFlags ) & VCBF_PeerOpenPending))
        {
            // If no open is pending, the call and/or owning tunnel has been
            // slammed, we are in the clean up phase, and no response should
            // be made.
            //
            TRACE( TL_A, TM_Fsm, ( "OC aborted" ) );
            return;
        }

        if (pControl->pusAssignedCallId)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }

        if (pVc->usResult)
        {
            // Call is down.
            //
            pVc->status =
                StatusFromResultAndError( pVc->usResult, pVc->usError );

            pVc->state = CS_Idle;
            SendControl(
                pTunnel, pVc, CMT_CDN,
                (ULONG )pVc->usResult, (ULONG )pVc->usError, NULL,
                CSF_CallIdleOnAck );
        }
        else
        {
            // Stash the call serial number.
            //
            if (pControl->pulCallSerialNumber)
            {
                pVc->pLcParams->ulCallSerialNumber =
                    *(pControl->pulCallSerialNumber);
            }
            else
            {
                pVc->pLcParams->ulCallSerialNumber = 0;
            }

            // The minimum and maximum rates acceptable to peer must be
            // dropped on the floor here and the TAPI structures for incoming
            // calls do not have a way to report such information.
            //
            // Calculate the connect bps to report to NDISWAN and to peer.
            // Since we have no WAN link and no real way to figure the link
            // speed, it's just a guesstimate of the LAN speed or the maximum
            // acceptable to peer, whichever is smaller.
            //
            if (pControl->pulMaximumBps)
            {
                pVc->ulConnectBps = (ULONG )*(pControl->pulMaximumBps);
            }
            if (pVc->ulConnectBps > pTunnel->ulMediaSpeed)
            {
                pVc->ulConnectBps = pTunnel->ulMediaSpeed;
            }

            // Stash the requested bearer types.
            //
            pVc->pTcInfo->ulMediaMode = 0;
            if (pControl->pulBearerType)
            {
                if (*(pControl->pulBearerType) & BBM_Analog)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DATAMODEM;
                }

                if (*(pControl->pulBearerType) & BBM_Digital)
                {
                    pVc->pTcInfo->ulMediaMode |= LINEMEDIAMODE_DIGITALDATA;
                }
            }

            // Stash the maximum send window.
            //
            if (pControl->pusRWindowSize)
            {
                SetFlags( &pVc->ulFlags, VCBF_Sequencing );

                if (*(pControl->pusRWindowSize) == 0)
                {
                    // When peer sends a receive window of 0 it means he needs
                    // sequencing to do out of order handling but doesn't want
                    // to do flow control.  (Why would anyone choose this?)  We
                    // fake "no flow control" by setting a huge send window
                    // that should never be filled.
                    //
                    pVc->ulMaxSendWindow = 10000;
                }
                else
                {
                    pVc->ulMaxSendWindow = (ULONG )*(pControl->pusRWindowSize);
                }
            }

            // Initialize the round trip time to the packet processing delay,
            // if any, per the draft/RFC.  The PPD is in 1/10ths of seconds.
            //
            if (pControl->pusPacketProcDelay)
            {
                pVc->ulRoundTripMs =
                    ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
            }
            else
            {
                pVc->ulRoundTripMs = pAdapter->ulInitialSendTimeoutMs;
            }

            // Note: The phone numbers of the caller and callee as well as the
            // Subaddress are available at this point.  Currently, the
            // CallerID field of the TAPI structures is used for the IP
            // address of the other end of the tunnel, which is used above for
            // the IPSEC filters.  The WAN caller information may also be
            // useful but there is no obvious way to return both the WAN and
            // tunnel endpoints in the current TAPI structures.
            // Store the IP address of the peer.

            pVc->state = CS_WaitCsAnswer;
            SendControl( pTunnel, pVc, CMT_OCRP, 0, 0, NULL, 0 );

            // For now, with only "null" WAN call handoff supported, the
            // bearer answer event is also generated here.
            //
            FsmOutCallBearerAnswer( pTunnel, pVc );
        }
    }
}


VOID
FsmOutCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM WaitReply state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_OCRP)
    {
        pVc->pMakeCall->Flags |= CALL_PARAMETERS_CHANGED;

        // Stash the assigned Call-ID.
        //
        if (pControl->pusAssignedCallId && *(pControl->pusAssignedCallId) > 0)
        {
            pVc->usAssignedCallId = *(pControl->pusAssignedCallId);
        }
        else
        {
            // Peer ignored a MUST we can't cover up, by not sending a Call-ID
            // for call control and payload traffic headed his way.
            //
            ASSERT( !"No assigned CID?" );
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )TRESULT_GeneralWithError,
                (ULONG_PTR )GERR_None,
                0, 0, FALSE, FALSE );
            return;
        }

        // Stash the physical channel ID.
        //
        if (pControl->pulPhysicalChannelId)
        {
            pVc->pLcParams->ulPhysicalChannelId =
                *(pControl->pulPhysicalChannelId);
        }
        else
        {
            pVc->pLcParams->ulPhysicalChannelId = 0xFFFFFFFF;
        }

        pVc->state = CS_WaitConnect;
    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        USHORT usResult;
        USHORT usError;

        if (pControl->pusResult)
        {
            usResult = *(pControl->pusResult);
            usError = *(pControl->pusError);
        }
        else
        {
            usResult = CRESULT_GeneralWithError;
            usError = GERR_BadValue;
        }

        // Map the result/error to a TAPI disconnect code.
        //
        pVc->status = StatusFromResultAndError( usResult, usError );

        // Call is down.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmOutCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl )

    // Outgoing call creation FSM WaitConnect state processing for VC 'pVc'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV' and 'pTunnel->lockT'.
    //
{
    if (*(pControl->pusMsgType) == CMT_OCCN)
    {
        // Stash the connect BPS.
        //
        if (pControl->pulTxConnectSpeed)
        {
            pVc->ulConnectBps = *(pControl->pulTxConnectSpeed);
        }
        else
        {
            // Not supposed to happen, but try to go on with a least common
            // denominator if it does.
            //
            pVc->ulConnectBps = 9600;
        }

        DBG_if (pControl->pulFramingType
                && !(*(pControl->pulFramingType) & FBM_Sync))
        {
            // Should not happen since we said in our request we only want
            // synchronous framing.  If it does, go on in the hope that this
            // AVP is what peer got wrong and not the framing itself.
            //
            ASSERT( "No sync framing?" );
        }

        // Stash the maximum send window.
        //
        if (!pControl->pusRWindowSize)
        {
            // Peer did not send a receive window AVP so we're not doing Ns/Nr
            // flow control on the session.  If we requested sequencing peer
            // is really supposed to send his window, but if he doesn't assume
            // that means he wants no sequencing.  The draft/RFC is a little
            // ambiguous on this point.
            //
            DBG_if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
                TRACE( TL_A, TM_Fsm, ( "No rw when we sent one?" ) );

            ClearFlags( &pVc->ulFlags, VCBF_Sequencing );
        }
        else
        {
            ULONG ulNew;

            if (*(pControl->pusRWindowSize) == 0)
            {
                // When peer sends a receive window of 0 it means he needs
                // sequencing to do out of order handling but doesn't want to
                // do flow control.  (Why would anyone choose this?)  We fake
                // "no flow control" by setting a huge send window that should
                // never be filled.
                //
                pVc->ulMaxSendWindow = 10000;
            }
            else
            {
                pVc->ulMaxSendWindow = *(pControl->pusRWindowSize);
            }

            // Set the initial send window to 1/2 the maximum, to "slow start"
            // in case the networks congested.  If it's not the window will
            // quickly adapt to the maximum.
            //
            ulNew = pVc->ulMaxSendWindow << 1;
            pVc->ulSendWindow = max( ulNew, 1 );
        }

        // Initialize the round trip time to the packet processing delay, if
        // any, per the draft/RFC.  The PPD is in 1/10ths of seconds.
        //
        if (pControl->pusPacketProcDelay)
        {
            pVc->ulRoundTripMs =
                ((ULONG )*(pControl->pusPacketProcDelay)) * 100;
        }
        else
        {
            pVc->ulRoundTripMs = pVc->pAdapter->ulInitialSendTimeoutMs;
        }

        // Call is up.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Established );
    }
    else if (*(pControl->pusMsgType) == CMT_CDN)
    {
        USHORT usResult;
        USHORT usError;

        if (pControl->pusResult)
        {
            usResult = *(pControl->pusResult);
            usError = *(pControl->pusError);
        }
        else
        {
            usResult = CRESULT_GeneralWithError;
            usError = GERR_BadValue;
        }

        // Map the result/error to a TAPI disconnect code.
        //
        pVc->status = StatusFromResultAndError( usResult, usError );

        // Call is down.
        //
        CallTransitionComplete( pTunnel, pVc, CS_Idle );
    }
}


VOID
FsmTunnelEstablished(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM Established state processing for tunnel 'pTunnel'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_StopCCN)
    {
        // Peer taking tunnel down.
        //
        TunnelTransitionComplete( pTunnel, CCS_Idle );
    }
}


VOID
FsmTunnelIdle(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM Idle state processing for tunnel 'pTunnel'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    USHORT usResult;
    USHORT usError;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_SCCRQ)
    {
        SetFlags( &pTunnel->ulFlags, (TCBF_PeerInitiated | TCBF_PeerInitRef) );

        if (ReferenceSap( pAdapter ))
        {
            // A SAP is active.  Because SAPs can be deregistered without
            // closing active incoming tunnels, we need a reference on the
            // open TDI context for the tunnel.  We call TdixReference rather
            // than TdixOpen, because with TDI guaranteed to be open the
            // effect is the same and TdixReference can be called at DISPATCH
            // IRQL while TdixOpen cannot.  The reference on the SAP is then
            // removed since we don't want the tunnel to prevent the SAP from
            // being deregistered.
            //
            TdixReference( &pAdapter->tdix );
            SetFlags( &pTunnel->ulFlags, TCBF_TdixReferenced );
            DereferenceSap( pAdapter );
        }
        else
        {
            // No SAP is active.  The only reason peer's request got this far
            // is that an outgoing call or just-deregistered-SAP had TDI open.
            // Discard it as if TDI had not been open.
            //
            TRACE( TL_I, TM_Fsm, ( "No active SAP" ) );
            TunnelTransitionComplete( pTunnel, CCS_Idle );
            return;
        }

        GetCcAvps( pTunnel, pControl, &usResult, &usError );
        if (usResult)
        {
            // The tunnel is down, but must hold it and any VCs until the
            // closing exchange is acknowledged.
            //
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, (ULONG )usError, NULL, CSF_TunnelIdleOnAck );
        }
        else
        {
            // Tunnel creation successfully underway.  Flip the flag that
            // tells MakeCall to queue requesting VCs on the result.
            //
            SetFlags( &pTunnel->ulFlags, TCBF_CcInTransition );

            if (pControl->pchChallenge)
            {
                ADAPTERCB* pAdapter;
                CHAR* pszPassword;

                // Challenge received.  Calculate the response value, based on
                // the password from the registry.
                //
                pAdapter = pTunnel->pAdapter;
                if (pAdapter->pszPassword)
                {
                    pszPassword = pAdapter->pszPassword;
                }
                else
                {
                    pszPassword = "";
                }

                CalculateResponse(
                    pControl->pchChallenge,
                    (ULONG )pControl->usChallengeLength,
                    pszPassword,
                    CMT_SCCRP,
                    pTunnel->achResponseToSend );
            }

            pTunnel->state = CCS_WaitCtlConnect;
            SendControl(
                pTunnel, NULL, CMT_SCCRP,
                (pControl->pchChallenge != NULL), 0, NULL, 0 );
        }
    }
}


VOID
FsmTunnelWaitCtlConnect(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM WaitCtlConnect state processing for tunnel
    // 'pTunnel'.  'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_SCCCN)
    {
        USHORT usResult;

        usResult = 0;
        if (pAdapter->pszPassword)
        {
            // We sent a challenge.
            //
            if (pControl->pchResponse)
            {
                CHAR achResponseExpected[ 16 ];
                ULONG i;

                // Challenge response received.  Calculate the expected
                // response and compare to that received.
                //
                CalculateResponse(
                    pTunnel->achChallengeToSend,
                    sizeof(pTunnel->achChallengeToSend),
                    pAdapter->pszPassword,
                    CMT_SCCCN,
                    achResponseExpected );

                for (i = 0; i < 16; ++i)
                {
                    if (achResponseExpected[ i ] != pControl->pchResponse[ i ])
                    {
                        break;
                    }
                }

                if (i < 16)
                {
                    TRACE( TL_N, TM_Fsm, ( "Wrong challenge response" ) );
                    usResult = TRESULT_NotAuthorized;
                }
            }
            else
            {
                // We sent a challenge and got no challenge response.
                // 
                //
                TRACE( TL_N, TM_Fsm, ( "No challenge response" ) );
                usResult = TRESULT_FsmError;
            }
        }

        if (usResult)
        {
            // Tunnel going down.
            //
            pTunnel->state = CCS_Idle;
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, 0, NULL, CSF_TunnelIdleOnAck );
        }
        else
        {
            // Tunnel is up.
            //
            TunnelTransitionComplete( pTunnel, CCS_Established );
        }
    }
    else if (*(pControl->pusMsgType) == CMT_StopCCN)
    {
        // Peer taking tunnel down.
        //
        TunnelTransitionComplete( pTunnel, CCS_Idle );
    }
}


VOID
FsmTunnelWaitCtlReply(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl )

    // Tunnel creation FSM WaitCtlReply state processing for tunnel 'pTunnel'.
    // 'PControl' is the exploded control message information.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    USHORT usResult;
    USHORT usError;

    pAdapter = pTunnel->pAdapter;

    if (*(pControl->pusMsgType) == CMT_SCCRP)
    {
        GetCcAvps( pTunnel, pControl, &usResult, &usError );

        if (pAdapter->pszPassword)
        {
            // We sent a challenge.
            //
            if (pControl->pchResponse)
            {
                CHAR achResponseExpected[ 16 ];
                ULONG i;

                // Challenge response received.  Calculate the expected
                // response and compare to that received.
                //
                CalculateResponse(
                    pTunnel->achChallengeToSend,
                    sizeof(pTunnel->achChallengeToSend),
                    pAdapter->pszPassword,
                    CMT_SCCRP,
                    achResponseExpected );

                for (i = 0; i < 16; ++i)
                {
                    if (achResponseExpected[ i ] != pControl->pchResponse[ i ])
                    {
                        break;
                    }
                }

                if (i < 16)
                {
                    TRACE( TL_N, TM_Fsm, ( "Wrong challenge response" ) );
                    usResult = TRESULT_General;
                }
            }
            else
            {
                // We sent a challenge and got no challenge response.  Treat
                // this as if a bad response was received.
                //
                TRACE( TL_N, TM_Fsm, ( "No challenge response" ) );
                usResult = TRESULT_General;
            }
        }

        if (usResult)
        {
            // Tunnel creation failed, so shut down.
            //
            pTunnel->state = CCS_Idle;
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, (ULONG )usError, NULL, CSF_TunnelIdleOnAck );
        }
        else
        {
            if (pControl->pchChallenge)
            {
                ADAPTERCB* pAdapter;
                CHAR* pszPassword;

                // Challenge received.  Calculate the response value, based on
                // the password from the registry.
                //
                pAdapter = pTunnel->pAdapter;
                if (pAdapter->pszPassword)
                    pszPassword = pAdapter->pszPassword;
                else
                    pszPassword = "";

                CalculateResponse(
                    pControl->pchChallenge,
                    (ULONG )pControl->usChallengeLength,
                    pszPassword,
                    CMT_SCCCN,
                    pTunnel->achResponseToSend );
            }

            // Tunnel is up.
            //
            SendControl( pTunnel, NULL, CMT_SCCCN,
                (pControl->pchChallenge != NULL), 0, NULL, CSF_QueryMediaSpeed);
            TunnelTransitionComplete( pTunnel, CCS_Established );
        }
    }
    else if (*(pControl->pusMsgType) == CMT_StopCCN)
    {
        // Peer taking tunnel down.
        //
        TunnelTransitionComplete( pTunnel, CCS_Idle );
    }
}


VOID
GetCcAvps(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl,
    OUT USHORT* pusResult,
    OUT USHORT* pusError )

    // Retrieve and interpret control connection AVPs received in the SCCRQ or
    // SCCRP message in 'pControl', returning the result and error codes for
    // the response in '*pusResult' and '*pusError'.  'PTunnel' is the tunnel
    // control block.
    //
{
    ULONG ulNew;

    *pusResult = 0;
    *pusError = GERR_None;

    if (!pControl->pusProtocolVersion
        || *(pControl->pusProtocolVersion) != L2TP_ProtocolVersion)
    {
        // Peer wants to do a version of L2TP that doesn't match the only
        // one we understand.
        //
        TRACE( TL_A, TM_Recv, ( "Bad protocol version?" ) );
        *pusResult = TRESULT_BadProtocolVersion;
        return;
    }

    // Make sure the MUST fields are really there and have valid values, then
    // store them in our control blocks.
    //
    if (!pControl->pusAssignedTunnelId
        || *(pControl->pusAssignedTunnelId) == 0
        || !pControl->pulFramingCaps)
    {
        TRACE( TL_A, TM_Recv, ( "Missing MUSTs?" ) );
        *pusResult = TRESULT_GeneralWithError;
        *pusError = GERR_BadValue;
        return;
    }

    pTunnel->usAssignedTunnelId = *(pControl->pusAssignedTunnelId);
    pTunnel->ulFramingCaps = *(pControl->pulFramingCaps);

    if (pControl->pulBearerCaps)
    {
        pTunnel->ulBearerCaps = *(pControl->pulBearerCaps);
    }
    else
    {
        pTunnel->ulBearerCaps = 0;
    }

    if (pControl->pusRWindowSize && *(pControl->pusRWindowSize))
    {
        // Peer provided his receive window, which becomes our send window.
        //
        pTunnel->ulMaxSendWindow = (ULONG )*(pControl->pusRWindowSize);
    }
    else
    {
        // Peer provided no receive window, so use the default of 4 per the
        // draft/RFC.
        //
        pTunnel->ulMaxSendWindow = L2TP_DefaultReceiveWindow;
    }

    // Set the initial send window to 1/2 the maximum, to "slow start" in case
    // the network is congested.  If it's not the window will quickly adapt to
    // the maximum.
    //
    ulNew = pTunnel->ulMaxSendWindow >> 1;
    pTunnel->ulSendWindow = max( ulNew, 1 );
}


ULONG
StatusFromResultAndError(
    IN USHORT usResult,
    IN USHORT usError )

    // Map non-success L2TP result/error codes to a best-fit TAPI
    // NDIS_STATUS_TAPI_DISCONNECT_* code.
    //
{
    ULONG ulResult;

    switch (usResult)
    {
        case CRESULT_GeneralWithError:
        {
            switch (usError)
            {
                case GERR_TryAnother:
                {
                    ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY;
                    break;
                }

                case GERR_BadValue:
                case GERR_BadLength:
                case GERR_NoControlConnection:
                case GERR_NoResources:
                {
                    ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL;
                    break;
                }

                default:
                {
                    ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT;
                    break;
                }
            }
            break;
        }

        case CRESULT_Busy:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY;
            break;
        }

        case CRESULT_NoCarrier:
        case CRESULT_NoDialTone:
        case CRESULT_Timeout:
        case CRESULT_NoFacilitiesTemporary:
        case CRESULT_NoFacilitiesPermanent:
        case CRESULT_Administrative:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL;
            break;
        }

        case CRESULT_NoFraming:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE;
            break;
        }

        case CRESULT_InvalidDestination:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS;
            break;
        }

        case CRESULT_LostCarrier:
        default:
        {
            ulResult = NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION;
            break;
        }
    }

    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\cm.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// cm.c
// RAS L2TP WAN mini-port/call-manager driver
// Call Manager routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


// Debug counts of client oddities that should not be happening.
//
ULONG g_ulUnexpectedInCallCompletes = 0;
ULONG g_ulCallsNotClosable = 0;
ULONG g_ulCompletingVcCorruption = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
BuildCallParametersShell(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN ULONG ulBufferLength,
    OUT CHAR* pBuffer,
    OUT CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED** ppTiParams,
    OUT LINE_CALL_INFO** ppTcInfo,
    OUT L2TP_CALL_PARAMETERS** ppLcParams );

VOID
CallSetupComplete(
    IN VCCB* pVc );

TUNNELCB*
CreateTunnelCb(
    IN ADAPTERCB* pAdapter );

VOID
InactiveCallCleanUp(
    IN VCCB* pVc );

VOID
IncomingCallCompletePassive(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter );

VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
LockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace );

NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter );

VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
SetupVcComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VOID
TimerQTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );

VOID
TunnelTqTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );

VOID
UnlockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace );


//-----------------------------------------------------------------------------
// Call-manager handlers and completers
//-----------------------------------------------------------------------------

NDIS_STATUS
LcmCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCmOpenAfHandler' routine called by NDIS when a client
    // requests to open an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hExistingAf;

    TRACE( TL_I, TM_Cm, ( "LcmCmOpenAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrBindingContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI_PROXY
        || AddressFamily->MajorVersion != NDIS_MajorVersion
        || AddressFamily->MinorVersion != NDIS_MinorVersion)
    {
        return NDIS_STATUS_BAD_VERSION;
    }

    // Save NDIS's AF handle in the adapter control block.  Interlock just in
    // case multiple clients attempt to open the AF, though don't expect this.
    //
    hExistingAf =
        InterlockedCompareExchangePointer(
            &pAdapter->NdisAfHandle, NdisAfHandle, NULL );
    if (hExistingAf)
    {
        // Our AF has already been opened.  Don't accept another open since
        // only only one would be able to register a SAP anyway.  This way we
        // don't have to be in the business of tracking multiple AF handles.
        //
        ASSERT( !"AF exists?" );
        return NDIS_STATUS_FAILURE;
    }

    ReferenceAdapter( pAdapter );
    ReferenceAf( pAdapter );

    // Since we support only a single address family, just return the adapter
    // as the address family context.
    //
    *CallMgrAfContext = (PNDIS_HANDLE )pAdapter;

    TRACE( TL_I, TM_Cm, ( "LcmCmOpenAf OK" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LcmCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCloseAfHandler' routine called by NDIS when a client
    // requests to close an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "LcmCmCloseAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // This dereference will eventually lead to us calling
    // NdisMCmCloseAfComplete.
    //
    DereferenceAf( pAdapter );

    TRACE( TL_V, TM_Cm, ( "LcmCmCloseAf pending" ) );
    return NDIS_STATUS_PENDING;
}


NDIS_STATUS
LcmCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext )

    // Standard 'LcmCmRegisterSapHandler' routine called by NDIS when the a
    // client registers a service access point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    BOOLEAN fSapExists;
    BOOLEAN fInvalidSapData;

    TRACE( TL_I, TM_Cm, ( "LcmCmRegSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;

    // Our SAP context is just the address of the owning adapter control
    // block.  Set it now before scheduling work as NDIS doesn't handle the
    // case of SAP completion correctly otherwise (though it should).
    //
    *CallMgrSapContext = (NDIS_HANDLE )pAdapter;

    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (pAdapter->NdisSapHandle)
        {
            fSapExists = TRUE;
        }
        else
        {
            // Save NDIS's SAP handle in the adapter control block.
            //
            fSapExists = FALSE;
            pAdapter->NdisSapHandle = NdisSapHandle;

            // Extract the SAP line and address IDs and store for
            // regurgitation in incoming call dispatches.
            //
            if (Sap->SapType == AF_TAPI_SAP_TYPE
                && Sap->SapLength >= sizeof(CO_AF_TAPI_SAP))
            {
                CO_AF_TAPI_SAP* pSap;

                pSap = (CO_AF_TAPI_SAP* )(Sap->Sap);
                pAdapter->ulSapLineId = pSap->ulLineID;

                if (pSap->ulAddressID == 0xFFFFFFFF)
                {
                    // This means "any ID is OK" but when indicated back up
                    // NDPROXY doesn't recognize this code, so translate it to
                    // 0 here.
                    //
                    pAdapter->ulSapAddressId = 0;
                }
                else
                {
                    pAdapter->ulSapAddressId = pSap->ulAddressID;
                }

                fInvalidSapData = FALSE;
            }
            else
            {
                fInvalidSapData = TRUE;
            }
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (fSapExists)
    {
        TRACE( TL_A, TM_Cm, ( "SAP exists?" ) );
        return NDIS_STATUS_SAP_IN_USE;
    }

    if (fInvalidSapData)
    {
        TRACE( TL_A, TM_Cm, ( "SAP data?" ) );
        return NDIS_STATUS_INVALID_DATA;
    }

    // TDI setup must be done at PASSIVE IRQL so schedule a routine to do it.
    //
    status = ScheduleWork( pAdapter, RegisterSapPassive, pAdapter );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( FALSE );
        NdisAcquireSpinLock( &pAdapter->lockSap );
        {
            pAdapter->NdisSapHandle = NULL;
        }
        NdisReleaseSpinLock( &pAdapter->lockSap );
        return status;
    }

    TRACE( TL_V, TM_Cm, ( "LcmCmRegSap pending" ) );
    return NDIS_STATUS_PENDING;
}


VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the registering of a SAP begun in
    // LcmCmRegisterSap.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hSap;

    TRACE( TL_N, TM_Cm, ( "RegSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Open the TDI transport and start receiving datagrams.
    //
    status = TdixOpen( &pAdapter->tdix );

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        hSap = pAdapter->NdisSapHandle;

        if (status == NDIS_STATUS_SUCCESS)
        {
            // Mark the SAP active allowing references to be taken, and take
            // the initial reference for SAP registry, plus those for address
            // family and adapter.
            //
            SetFlags( &pAdapter->ulFlags, ACBF_SapActive );
            ASSERT( pAdapter->lSapRef == 0 );
            TRACE( TL_N, TM_Ref, ( "RefSap-ish to 1" ) );
            pAdapter->lSapRef = 1;
            ReferenceAdapter( pAdapter );
            ReferenceAf( pAdapter );
        }
        else
        {
            // Failed to get TDI set up, so NULL the SAP handle in the adapter
            // control block.
            //
            TRACE( TL_A, TM_Cm, ( "TdixOpen=$%08x?", status ) );
            pAdapter->NdisSapHandle = NULL;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    // Remove the reference for scheduled work.  Do this before telling NDIS
    // the SAP completed because if it failed it can call Halt and unload the
    // driver before we run again here which gives a C4 bugcheck.
    //
    DereferenceAdapter( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp" ) );
    NdisMCmRegisterSapComplete( status, hSap, (NDIS_HANDLE )pAdapter );
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp done" ) );
}


NDIS_STATUS
LcmCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext )

    // Standard 'CmDeregisterSapHandler' routine called by NDIS when the a
    // client has requested to de-register a service access point.  See DDK
    // doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "LcmCmDeregSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrSapContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            ASSERT( pAdapter->NdisSapHandle );
            ClearFlags( &pAdapter->ulFlags, ACBF_SapActive );
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            TRACE( TL_A, TM_Cm, ( "No SAP active?" ) );
            status = NDIS_STATUS_FAILURE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (status == NDIS_STATUS_PENDING)
    {
        // Remove the reference for SAP registry.  Eventually, the SAP
        // references will fall to 0 and DereferenceSap will schedule
        // DeregisterSapPassive to complete the de-registry.
        //
        DereferenceSap( pAdapter );
    }

    TRACE( TL_V, TM_Cm, ( "LcmCmDeregSap=$%08x", status ) );
    return status;
}


VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the de-registering of a SAP begun in
    // LcmCmDeregisterSap.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hOldSap;

    TRACE( TL_I, TM_Cm, ( "DeregSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Stop receiving datagrams (at least on behalf of this SAP) and
    // deregister the SAP.
    //
    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        hOldSap = pAdapter->NdisSapHandle;
        pAdapter->NdisSapHandle = NULL;
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    TdixClose( &pAdapter->tdix );

    // Remove the adapter references for the NdisSapHandle and for scheduled
    // work.  Remove the address family reference for the NdisSapHandle.  Do
    // all this before telling NDIS the deregister has completed because it
    // can call Halt and unload the driver before we run again here giving a
    // C4 bugcheck.
    //
    DereferenceAdapter( pAdapter );
    DereferenceAdapter( pAdapter );
    DereferenceAf( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp" ) );
    NdisMCmDeregisterSapComplete( NDIS_STATUS_SUCCESS, hOldSap );
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp done" ) );
}


NDIS_STATUS
LcmCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext )

    // Standard 'CmCreateVc' routine called by NDIS in response to a
    // client's request to create a virtual circuit.  This
    // call must return synchronously.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;

    pAdapter = (ADAPTERCB* )ProtocolAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory( pVc, sizeof(*pVc) );

    TRACE( TL_I, TM_Cm, ( "LcmCmCreateVc $%p", pVc ) );

    // Zero the back pointer to the tunnel control block (above) and
    // initialize the detached link since clean-up may be required before this
    // block is ever linked into a tunnel chain.
    //
    InitializeListHead( &pVc->linkVcs );
    InitializeListHead( &pVc->linkRequestingVcs );
    InitializeListHead( &pVc->linkCompletingVcs );

    // Set a marker for easier memory dump browsing.
    //
    pVc->ulTag = MTAG_VCCB;

    // Save a back pointer to the adapter for use in LcmCmDeleteVc later.
    //
    ReferenceAdapter( pAdapter );
    pVc->pAdapter = pAdapter;

    // Initialize the VC and call spinlock and send/receive lists.
    //
    NdisAllocateSpinLock( &pVc->lockV );
    NdisAllocateSpinLock( &pVc->lockCall );
    InitializeListHead( &pVc->listSendsOut );
    InitializeListHead( &pVc->listOutOfOrder );

    // Save the NDIS handle of this VC for use in indications to NDIS later.
    //
    pVc->NdisVcHandle = NdisVcHandle;

    // Initialize the estimated round trip time and send timeout per the
    // suggestions in the draft/RFC.
    //
    pVc->ulRoundTripMs = L2TP_LnsDefaultPpd * 100;
    pVc->ulSendTimeoutMs = pVc->ulRoundTripMs;

    // Initialize link capabilities to the defaults for the adapter.
    //
    {
        NDIS_WAN_CO_INFO* pwci = &pAdapter->info;
        NDIS_WAN_CO_GET_LINK_INFO* pwcgli = &pVc->linkinfo;

        NdisZeroMemory( &pVc->linkinfo, sizeof(pVc->linkinfo) );
        pwcgli->MaxSendFrameSize = pwci->MaxFrameSize;
        pwcgli->MaxRecvFrameSize = pwci->MaxFrameSize;
        pwcgli->SendFramingBits = pwci->FramingBits;
        pwcgli->RecvFramingBits = pwci->FramingBits;
        pwcgli->SendACCM = pwci->DesiredACCM;
        pwcgli->RecvACCM = pwci->DesiredACCM;
    }

    // Default send window, "slow started".  This is typically adjusted based
    // on peer's Receive Window AVP when the call is created.
    //
    pVc->ulSendWindow = pAdapter->info.MaxSendWindow >> 1;
    if (pVc->ulSendWindow == 0)
    {
        pVc->ulSendWindow = 1;
    }

    // The VC control block's address is the VC context we return to NDIS.
    //
    *ProtocolVcContext = (NDIS_HANDLE )pVc;

    // Add a reference to the control block and the associated address family
    // that is removed by LmpCoDeleteVc.
    //
    ReferenceVc( pVc );
    ReferenceAf( pAdapter );

    TRACE( TL_V, TM_Cm, ( "LcmCmCreateVc=0" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LcmCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext )

    // Standard 'CmDeleteVc' routine called by NDIS in response to a
    // client's request to delete a virtual circuit.  This
    // call must return synchronously.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "LcmCmDelVc($%p)", ProtocolVcContext ) );

    pVc = (VCCB* )ProtocolVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // This flag catches attempts by the client to delete the VC twice.
    //
    if (ReadFlags( &pVc->ulFlags ) & VCBF_VcDeleted)
    {
        TRACE( TL_A, TM_Cm, ( "VC $%p re-deleted?", pVc ) );
        return NDIS_STATUS_FAILURE;
    }

    SetFlags( &pVc->ulFlags, VCBF_VcDeleted );

    // Remove the references added by LcmCmCreateVc.
    //
    DereferenceAf( pVc->pAdapter );
    DereferenceVc( pVc );

    TRACE( TL_V, TM_Cm, ( "LcmCmDelVc=0" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LcmCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext )

    // Standard 'CmMakeCallHandler' routine called by NDIS when the a client
    // has requested to connect to a remote end-point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    CO_SPECIFIC_PARAMETERS* pMSpecifics;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;
    LINE_CALL_PARAMS* pTcParams;
    L2TP_CALL_PARAMETERS* pLcParams;
    VCCB* pVc;
    TUNNELCB* pTunnel;
    ADAPTERCB* pAdapter;
    ULONG ulIpAddress;
    BOOLEAN fDefaultLcParams;
    BOOLEAN fExclusiveTunnel;

    TRACE( TL_I, TM_Cm, ( "LcmCmMakeCall" ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( "!Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pAdapter = pVc->pAdapter;

    // L2TP has no concept of point-to-multi-point "parties".
    //
    if (CallMgrPartyContext)
    {
        *CallMgrPartyContext = NULL;
    }

    // Validate call parameters.
    //
    do
    {
        // Validate base call parameters.
        //
        {
            // L2TP provides switched VCs only.
            //
            if (CallParameters->Flags &
                    (PERMANENT_VC | BROADCAST_VC | MULTIPOINT_VC))
            {
                status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            // We're supposed to set CALL_PARAMETERS_CHANGED on return if we
            // changed the call parameters, leaving a catch-22 if caller
            // already has it set.  Also, for TAPI address family, media call
            // parameters must be present, though call manager call parameters
            // are not.
            //
            if ((CallParameters->Flags & CALL_PARAMETERS_CHANGED)
                || !CallParameters->MediaParameters)
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            pMSpecifics = &CallParameters->MediaParameters->MediaSpecific;
            if (pMSpecifics->Length < sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            pTmParams =
                (CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* )&pMSpecifics->Parameters;

            if (pTmParams->LineCallParams.Length < sizeof(LINE_CALL_PARAMS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            pTcParams = (LINE_CALL_PARAMS* )
                (((CHAR UNALIGNED* )&pTmParams->LineCallParams)
                + pTmParams->LineCallParams.Offset);
        }

        // Validate call parameters.
        //
        {
            CHAR* pszAddress;

            // Caller must provide a destination IP address.  The address is
            // ANSI as are all non-format-coded strings to/from TAPI.
            //
            pszAddress =
                StrDupNdisVarDataDescStringToA( &pTmParams->DestAddress );
            if (!pszAddress)
            {
                status = NDIS_STATUS_RESOURCES;
                break;
            }

            ulIpAddress = IpAddressFromDotted( pszAddress );
            FREE_NONPAGED( pszAddress );
            if (ulIpAddress == 0)
            {
                status = NDIS_STATUS_INVALID_ADDRESS;
                break;
            }

            // Reject if unknown WAN-type bits are set.
            //
            if (pTcParams->ulMediaMode
                & ~(LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_DIGITALDATA))
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }
        }

        // Validate L2TP call parameters.
        //
        // When caller doesn't provide L2TP-specific parameters a local block
        // with default values is substituted for the convenience of the rest
        // of the code.
        //
        {
            if (pTcParams->ulDevSpecificSize == sizeof(*pLcParams))
            {
                pLcParams = (L2TP_CALL_PARAMETERS* )
                    ((CHAR* )pTcParams) + pTcParams->ulDevSpecificOffset;
                fDefaultLcParams = FALSE;
            }
            else
            {
                pLcParams =
                    (L2TP_CALL_PARAMETERS* )ALLOC_NONPAGED(
                        sizeof(*pLcParams), MTAG_L2TPPARAMS );
                if (!pLcParams)
                {
                    status = NDIS_STATUS_RESOURCES;
                    break;
                }

                fDefaultLcParams = TRUE;
                NdisZeroMemory( pLcParams, sizeof(*pLcParams) );
                pLcParams->ulPhysicalChannelId = 0xFFFFFFFF;
            }
        }

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        return status;
    }

    // Stash the call parameters in the VC block.  Simultaneous MakeCalls on
    // the same VC is a client error, but it's easy to guard against so do
    // that here.
    //
    if (InterlockedCompareExchangePointer(
            &pVc->pMakeCall, CallParameters, NULL ))
    {
        ASSERT( !"Double MakeCall?" );
        if (fDefaultLcParams)
        {
            FREE_NONPAGED( pLcParams );
        }
        return NDIS_STATUS_CALL_ACTIVE;
    }

    pVc->pTmParams = pTmParams;
    pVc->pTcParams = pTcParams;
    pVc->pLcParams = pLcParams;

    // This VC's call is now cleanable, i.e. the base call clean up routine,
    // InactiveCallCleanUp, will now eventually be called.
    //
    do
    {
        // Convert parameter and configuration information to VC flags where
        // appropriate.
        //
        {
            ULONG ulMask = 0;

            if (CallParameters->MediaParameters->Flags
                    & RECEIVE_TIME_INDICATION)
            {
                ulMask |= VCBF_IndicateTimeReceived;
            }

            if (pAdapter->ulFlags & ACBF_OutgoingRoleLac)
            {
                ulMask |= VCBF_IncomingFsm;
            }

            if (fDefaultLcParams)
            {
                ulMask |= VCBF_DefaultLcParams;
            }

            if (ulMask)
            {
                SetFlags( &pVc->ulFlags, ulMask );
            }
        }

        // Take the next progressively increasing call serial number string.
        //
        NdisInterlockedIncrement( &pAdapter->ulCallSerialNumber );

        // Reserve a Call-ID slot in the adapter's table.
        //
        status = ReserveCallIdSlot( pVc );
        if (status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Create a new or find an existing tunnel control block for caller's
        // specified IP address in the adapter's list.  The returned block is
        // linked to the adapter and referenced.  The reference is the one for
        // linkage in the list, i.e. case (a).
        //
        fExclusiveTunnel = (BOOLEAN )
            ((fDefaultLcParams)
                ? !!(pAdapter->ulFlags & ACBF_ExclusiveTunnels)
                : !!(pLcParams->ulFlags & L2TPCPF_ExclusiveTunnel));

        pTunnel = SetupTunnel( pAdapter, ulIpAddress, 0, fExclusiveTunnel );
        if (!pTunnel)
        {
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
            {
                // This is unlikely because SetupTunnel only finds non-closing
                // tunnels, but this check and linkage must occur atomically
                // under 'lockT'.  New VCs must not be linked onto closing
                // tunnels.
                //
                status = NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN;
            }
            else
            {
                // The call has an open operation pending and can accept close
                // requests.
                //
                SetFlags( &pVc->ulFlags,
                    VCBF_ClientOpenPending
                    | VCBF_CallClosableByClient
                    | VCBF_CallClosableByPeer );

                NdisAcquireSpinLock( &pTunnel->lockVcs );
                {
                    // Set the back pointer to it's tunnel.  The associated
                    // tunnel reference was taken by SetupTunnel above.
                    //
                    pVc->pTunnel = pTunnel;

                    // Link the VC into the tunnel's list of associated VCs.
                    //
                    InsertTailList( &pTunnel->listVcs, &pVc->linkVcs );
                }
                NdisReleaseSpinLock( &pTunnel->lockVcs );
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        CallCleanUp( pVc );
        return status;
    }

    // Schedule FsmOpenTunnel to kick off the combination of tunnel and call
    // creation state machines that will eventually call NdisMakeCallComplete
    // to notify caller of the result.  A happy side effect of the scheduling
    // is that the callback will occur at PASSIVE IRQL, the level at which TDI
    // clients must run.
    //
    pVc->state = CS_WaitTunnel;
    ScheduleTunnelWork(
        pTunnel, pVc, FsmOpenTunnel,
        0, 0, 0, 0, FALSE, FALSE );

    TRACE( TL_V, TM_Cm, ( "LcmCmMakeCall pending" ) );
    return NDIS_STATUS_PENDING;
}


NDIS_STATUS
LcmCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size )

    // Standard 'CmCloseCallHandler' routine called by NDIS when the a client
    // has requested to tear down a call.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    ULONG ulFlags;
    BOOLEAN fCallClosable;

    TRACE( TL_I, TM_Cm, ( "LcmCmCloseCall($%p)", CallMgrVcContext ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockV );
    {
        ulFlags = ReadFlags( &pVc->ulFlags );

        if (ulFlags & VCBF_WaitCloseCall)
        {
            // Note that we got the close from the client we were expecting.
            // This is helpful information when debugging, but is not
            // otherwise used.
            //
            ClearFlags( &pVc->ulFlags, VCBF_WaitCloseCall );
        }

        if (ulFlags & VCBF_CallClosableByClient)
        {
            fCallClosable = TRUE;

            // Accepting this close makes the call no longer closable by
            // client or peer.  Any peer operation that was pending is
            // cleared, and a client close becomes pending.  It is possible to
            // have both a client open and close pending at the same time.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient
                 | VCBF_CallClosableByPeer
                 | VCBF_PeerClosePending
                 | VCBF_PeerOpenPending) );
            SetFlags( &pVc->ulFlags, VCBF_ClientClosePending );

            // If a client open is pending, it fails.
            //
            if (ulFlags & VCBF_ClientOpenPending)
            {
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
            }

            // Close the call, being graceful if possible.
            //
            ASSERT( pVc->pTunnel );
            ScheduleTunnelWork(
                pVc->pTunnel, pVc, FsmCloseCall,
                (ULONG_PTR )CRESULT_Administrative, (ULONG_PTR )GERR_None,
                0, 0, FALSE, FALSE );
        }
        else
        {
            TRACE( TL_I, TM_Cm, ( "Call not closable" ) );
            fCallClosable = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockV );

    if (!fCallClosable)
    {
        // The call is not in a closable state.  Just fail the request
        // immediately.  Since the docs say the call must return PENDING, this
        // is done by calling the completion routine here, in typical NDIS
        // fashion.
        //
        ++g_ulCallsNotClosable;
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp(FAIL)" ) );
        NdisMCmCloseCallComplete(
            NDIS_STATUS_FAILURE, pVc->NdisVcHandle, NULL );
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp done" ) );

        // Careful, client may have deleted the VC, so 'pVc' must not be
        // referenced hereafter.
        //
    }

    TRACE( TL_V, TM_Cm, ( "LcmCmCloseCall pending" ) );
    return NDIS_STATUS_PENDING;
}


VOID
LcmCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmIncomingCallCompleteHandler' routine called by NDIS when
    // a client has responded to the call-managers's previously dispatched
    // incoming call.  See DDK doc.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm,
        ( "LcmCmInCallComp($%p,s=$%08x)", CallMgrVcContext, Status ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"VTag" );
        return;
    }

    // The work is scheduled to avoid a possible recursive loop of completing
    // VCs that could overrun the stack.  See bug 370996.
    //
    ASSERT( pVc->pTunnel );
    ScheduleTunnelWork(
        pVc->pTunnel, pVc, IncomingCallCompletePassive,
        (ULONG )Status, 0, 0, 0, FALSE, FALSE );

    TRACE( TL_V, TM_Cm, ( "LcmCmInCallComp done" ) );
}


VOID
IncomingCallCompletePassive(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to complete an LcmCmIncomingCallComplete.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Cm, ( "InCallCompApc" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pVc->pAdapter;
    status = (NDIS_STATUS )(punpArgs[ 0 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    // Guard against a double-complete error by the client.
    //
    if (ReadFlags( &pVc->ulFlags ) & VCBF_WaitInCallComplete)
    {
        ClearFlags( &pVc->ulFlags, VCBF_WaitInCallComplete );

        if (status != NDIS_STATUS_SUCCESS)
        {
            pVc->usResult = CRESULT_Busy;
            pVc->usError = GERR_None;

            // Turn off the "call NdisMCmDispatchIncomingCloseCall if peer
            // terminates the call" flag.  It was turned on even though peer
            // pended, per JameelH.
            //
            ClearFlags( &pVc->ulFlags, VCBF_VcDispatched );
        }

        SetupVcComplete( pTunnel, pVc );
    }
    else
    {
        ASSERT( !"Not expecting InCallComp?" );
        ++g_ulUnexpectedInCallCompletes;
    }

    // Remove the VC and call references covering the dispatched incoming
    // call.
    //
    DereferenceCall( pVc );
    DereferenceVc( pVc );
}


VOID
LcmCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmActivateVcCompleteHandler' routine called by NDIS when the
    // mini-port has completed the call-manager's previous request to activate
    // a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"LcmCmActVcComp?" );
}


VOID
LcmCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext )

    // Standard 'CmDeactivateVcCompleteHandler' routine called by NDIS when
    // the mini-port has completed the call-manager's previous request to
    // de-activate a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"LcmCmDeactVcComp?" );
}


NDIS_STATUS
LcmCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmModifyQoSCallHandler' routine called by NDIS when a client
    // requests a modification in the quality of service provided by the
    // virtual circuit.  See DDK doc.
    //
{
    TRACE( TL_N, TM_Cm, ( "LcmCmModQoS" ) );

    // There is no useful concept of quality of service for IP media.
    //
    return NDIS_STATUS_NOT_SUPPORTED;
}


NDIS_STATUS
LcmCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the call manager.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_I, TM_Cm, ( "LcmCmReq" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryCmInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            TRACE( TL_A, TM_Cm,
               ( "CmSetOID=%d?", NdisRequest->DATA.SET_INFORMATION.Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Cm, ( "CmType=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    return status;
}


//-----------------------------------------------------------------------------
// Call utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
ActivateCallIdSlot(
    IN VCCB* pVc )

    // Sets the address of the VC, 'pVc', in the adapter's table of Call-IDs
    // enabling receives on the Call-ID.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (pVc->usCallId > 0 && pVc->usCallId <= pAdapter->usMaxVcs)
    {
        ASSERT( pAdapter->ppVcs[ pVc->usCallId - 1 ] == (VCCB* )-1 );

        NdisAcquireSpinLock( &pAdapter->lockVcs );
        {
            pAdapter->ppVcs[ pVc->usCallId - 1 ] = pVc;
        }
        NdisReleaseSpinLock( &pAdapter->lockVcs );
    }
}


VOID
BuildCallParametersShell(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN ULONG ulBufferLength,
    OUT CHAR* pBuffer,
    OUT CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED ** ppTiParams,
    OUT LINE_CALL_INFO** ppTcInfo,
    OUT L2TP_CALL_PARAMETERS** ppLcParams )

    // Loads caller's buffer 'pBuffer' of length 'ulBufferLength' bytes with a
    // CO_CALL_PARAMETERS structure containing default values.  Loads caller's
    // '*ppTiParams', '*ppTcInfo', and '*ppLcParams' with shortcut pointers to
    // the TAPI call and L2TP specific structures within the built
    // CO_CALL_PARAMETERS.  'PAdapter' is the adapter context.  'pUlIpAddress'
    // is the IP address of the peer in network byte order.
    //
{
    CO_CALL_PARAMETERS* pCp;
    CO_CALL_MANAGER_PARAMETERS* pCmp;
    CO_MEDIA_PARAMETERS* pMp;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED * pTip;
    LINE_CALL_INFO* pLci;
    L2TP_CALL_PARAMETERS* pLcp;
    CHAR* pszCallerId;
    ULONG ulLciTotalSize;
    ULONG ulMediaSpecificSize;
    ULONG ulBytesPerSec;
    WCHAR* pszCallerID;

    NdisZeroMemory( pBuffer, ulBufferLength );

    pCp = (CO_CALL_PARAMETERS* )pBuffer;
    
    pCmp = (PCO_CALL_MANAGER_PARAMETERS ) ( (PUCHAR)(pCp + 1) + sizeof(PVOID) );
    (ULONG_PTR) pCmp &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );
    pCp->CallMgrParameters = pCmp;
    
    pMp = (PCO_MEDIA_PARAMETERS ) ( (PUCHAR) (pCmp + 1) + sizeof(PVOID) );
    (ULONG_PTR) pMp &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );
    pCp->MediaParameters = pMp;

    // This needs to be dynamic based on speed reported by TDI.
    //
    ulBytesPerSec = L2TP_LanBps / 8;
    pCmp->Transmit.TokenRate = ulBytesPerSec;
    pCmp->Transmit.PeakBandwidth = ulBytesPerSec;
    pCmp->Transmit.MaxSduSize = L2TP_MaxFrameSize;
    pCmp->Receive.TokenRate = ulBytesPerSec;
    pCmp->Receive.PeakBandwidth = ulBytesPerSec;
    pCmp->Receive.MaxSduSize = L2TP_MaxFrameSize;

    ulLciTotalSize =
        sizeof(*pLci)
        + sizeof(PVOID)
        + sizeof(*pLcp)
        + ((L2TP_MaxDottedIpLen + 1) * sizeof(WCHAR));

    ulMediaSpecificSize = sizeof(*pTip) + sizeof(PVOID) + ulLciTotalSize;

    pTip =
        (CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED* )pMp->MediaSpecific.Parameters;

    pLci = (LINE_CALL_INFO*) ( (PUCHAR) (pTip + 1) + sizeof(PVOID) );
    (ULONG_PTR) pLci &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );

    pLcp = (L2TP_CALL_PARAMETERS*) ( (PUCHAR) (pLci + 1) + sizeof(PVOID) );
    (ULONG_PTR) pLcp &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );

    pMp->ReceiveSizeHint = L2TP_MaxFrameSize;
    pMp->MediaSpecific.Length = ulMediaSpecificSize;
        
    pTip->LineCallInfo.Length = (USHORT )ulLciTotalSize;
    pTip->LineCallInfo.MaximumLength = (USHORT )ulLciTotalSize;
    pTip->LineCallInfo.Offset = (ULONG) ((CHAR*) pLci - (CHAR*) &pTip->LineCallInfo);

    pLci->ulTotalSize = ulLciTotalSize;
    pLci->ulNeededSize = ulLciTotalSize;
    pLci->ulUsedSize = ulLciTotalSize;
    pLci->ulLineDeviceID = pAdapter->ulSapLineId;
    pLci->ulAddressID = pAdapter->ulSapAddressId;
    pLci->ulDevSpecificSize = sizeof(*pLcp);
    pLci->ulDevSpecificOffset = (ULONG) ((CHAR*) pLcp - (CHAR*) pLci);
    pLci->ulBearerMode = LINEBEARERMODE_DATA;

    pLci->ulCallerIDOffset = pLci->ulDevSpecificOffset + pLci->ulDevSpecificSize;
    
    pszCallerID = (WCHAR*)(((CHAR* )pLci) + pLci->ulCallerIDOffset);
    DottedFromIpAddress( ulIpAddress, (CHAR* )pszCallerID, TRUE );
    pLci->ulCallerIDSize = (StrLenW( pszCallerID ) + 1) * sizeof(WCHAR);
    pLci->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;

    pLcp->ulPhysicalChannelId = 0xFFFFFFFF;

    // Fill in shortcut outputs.
    //
    *ppTiParams = pTip;
    *ppTcInfo = pLci;
    *ppLcParams = pLcp;
}


VOID
CallCleanUp(
    IN VCCB* pVc )

    // De-associates the VC from the tunnel, preparing for and de-activating
    // the call.
    //
{
    NDIS_STATUS status;
    ULONG ulFlags;

    ulFlags = ReadFlags( &pVc->ulFlags );

    TRACE( TL_I, TM_Cm, ( "CallCleanUp(pV=$%p,cid=%d,act=%d)",
        pVc, (ULONG )pVc->usCallId, !!(ulFlags & VCBF_VcActivated) ) );
    ASSERT( pVc->ulTag == MTAG_VCCB );

    if (ReadFlags( &pVc->ulFlags ) & VCBF_VcActivated)
    {
        TRACE( TL_I, TM_Recv, ( "NdisMCmDeactVc" ) );
        status = NdisMCmDeactivateVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "NdisMCmDeactVc=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );

        ClearFlags( &pVc->ulFlags, VCBF_VcActivated );
        DereferenceCall( pVc );

        // The above actions lead to the call reference eventually going to 0,
        // at which time clean up resumes in DereferenceCall.
        //
    }
    else
    {
        InactiveCallCleanUp( pVc );
    }
}


VOID
CallSetupComplete(
    IN VCCB* pVc )

    // Clean up 'pVc' allocations used only at call setup, if any.
    //
{
    if (InterlockedExchangePointer( &pVc->pMakeCall, NULL ))
    {
        ASSERT( pVc->pTmParams );
        ASSERT( pVc->pTcParams );
        ASSERT( pVc->pLcParams );

        if (ReadFlags( &pVc->ulFlags ) & VCBF_DefaultLcParams)
        {
            // Caller did not provide any LcParams.  Free the 'default' version we
            // created for convenience.
            //
            FREE_NONPAGED( pVc->pLcParams );
        }

        pVc->pTmParams = NULL;
        pVc->pTcParams = NULL;
        pVc->pLcParams = NULL;
    }

    UnlockIcs( pVc, FALSE );
}


VOID
CloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close the call on 'pVc'.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    BOOLEAN fCompleteVcs;

    TRACE( TL_I, TM_Fsm, ( "CloseCall(pV=$%p)", pVc ) );

    // No context information so just free the work item.
    //
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    // Close down the call.
    //
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        NdisAcquireSpinLock( &pVc->lockV );
        {
            fCompleteVcs = CloseCall2(
                pTunnel, pVc, TRESULT_Shutdown, GERR_None );
        }
        NdisReleaseSpinLock( &pVc->lockV );

        if (fCompleteVcs)
        {
            CompleteVcs( pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


BOOLEAN
CloseCall2(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usResult,
    IN USHORT usError )

    // Close the call on VC 'pVc' of tunnel 'pTunnel'.  'UsResult' and
    // 'usError' are the TRESULT_* and GERR_* codes to be reported in the
    // StopCCN message, if applicable.
    //
    // Returns true if caller should call CompleteVcs after releasing 'lockV'
    // or false if not.
    //
    // IMPORTANT: Caller must hold 'lockT' and 'lockV'.
    //
{
    ULONG ulFlags;

    // Check if another path has completed the VC already.  If so, there's no
    // reason to continue.  Without the local tunnel cancel optimization
    // below, this check can be removed entirely and everything safely falls
    // through.  This check should include all "non-completing" conditions in
    // CallTransitionComplete.
    //
    ulFlags = ReadFlags( &pVc->ulFlags );
    if (!(ulFlags & VCBM_Pending))
    {
        if (!(ulFlags & VCBF_CallClosableByPeer))
        {
            TRACE( TL_A, TM_Cm, ( "Not closable" ) );
            return FALSE;
        }
    }

    // For locally initiated tunnels, check if this VC is the only one on the
    // tunnel, and if so, close the tunnel directly which slams this call.
    // Without this, the call closure would still bring down the tunnel.
    // However, the tunnel would complete it's transition normally, then be
    // dropped.  This speeds things up a little, giving quick response in the
    // case where user cancels an attempt to connect to a wrong address or
    // non-responsive server.
    //
    if (!(ReadFlags( &pTunnel->ulFlags) & TCBF_PeerInitiated))
    {
        BOOLEAN fMultipleVcs;

        NdisAcquireSpinLock( &pTunnel->lockVcs );
        {
            fMultipleVcs =
                (pTunnel->listVcs.Flink != pTunnel->listVcs.Blink);
        }
        NdisReleaseSpinLock( &pTunnel->lockVcs );

        if (!fMultipleVcs)
        {
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )usResult,
                (ULONG_PTR )usError,
                0, 0, FALSE, FALSE );
            return FALSE;
        }
    }

    // Slam the call closed.
    //
    CallTransitionComplete( pTunnel, pVc, CS_Idle );
    return TRUE;
}


VOID
CloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to slam closed tunnel 'pTunnel'.  See also
    // FsmCloseTunnel, which is often more appropriate.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    TRACE( TL_I, TM_Fsm, ( "CloseTunnel(pT=$%p)", pTunnel ) );

    // No context information so just free the work item.
    //
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    // Close down the tunnel.
    //
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        CloseTunnel2( pTunnel );
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
CloseTunnel2(
    IN TUNNELCB* pTunnel )

    // Close the tunnel 'pTunnel'.
    //
    // IMPORTANT: Caller must hold 'lockT'.
    //
{
    SetFlags( &pTunnel->ulFlags, TCBF_Closing );
    TunnelTransitionComplete( pTunnel, CCS_Idle );
    CompleteVcs( pTunnel );
}


VOID
CompleteVcs(
    IN TUNNELCB* pTunnel )

    // Complete the pending operation for each of the VCs on the completing
    // list of tunnel 'pTunnel'.
    //
    // IMPORTANT: Caller must hold 'lockT'.  This routine may release and
    //            re-acquire 'lockT'.
    //
{
    while (!IsListEmpty( &pTunnel->listCompletingVcs ))
    {
        LIST_ENTRY* pLink;
        VCCB* pVc;
        NDIS_STATUS status;
        LINKSTATUSINFO info;
        ULONG ulFlags;
        NDIS_STATUS statusVc;

        if (pTunnel->listCompletingVcs.Flink->Flink
            == pTunnel->listCompletingVcs.Flink)
        {
            // This is a hack to work around a rare listCompletingVcs
            // corruption problem whose cause has me baffled.  When the
            // problem occurs, a VCCB with it's link initialized appears in
            // the list.  This code removes the corrupted case hopefully
            // resulting in exactly the same state as the normal path in the
            // "else" clause.
            //
            pLink = pTunnel->listCompletingVcs.Flink;
            InitializeListHead( &pTunnel->listCompletingVcs );
            ASSERT( FALSE );
            ++g_ulCompletingVcCorruption;
        }
        else
        {
            // Pop the next completing VC from the list.
            //
            pLink = RemoveHeadList( &pTunnel->listCompletingVcs );
        }

        InitializeListHead( pLink );

        // Take a reference covering use of the VC pointer obtained from the
        // completing list.
        //
        pVc = CONTAINING_RECORD( pLink, VCCB, linkCompletingVcs );
        ReferenceVc( pVc );

        TRACE( TL_V, TM_Recv, ( "CompleteVc $%p", pVc ) );

        NdisAcquireSpinLock( &pVc->lockV );
        {
            // Note the pending flags then clear them, to ensure that all
            // pending operations are completed exactly once.  This is
            // necessary since ClientOpen and ClientClose events may be
            // pending simultaneously.  (Thanks a lot NDIS guys).
            //
            ulFlags = ReadFlags( &pVc->ulFlags );
            ClearFlags( &pVc->ulFlags, VCBM_Pending );

            // Convert client close pending to client close completion,
            // for reference later when call references reach zero.  The
            // flag determines if NdisMCmCloseCallComplete must be called.
            //
            if (ulFlags & VCBF_ClientClosePending)
            {
                SetFlags( &pVc->ulFlags, VCBF_ClientCloseCompletion );
            }

            // Before releasing the lock, make "safe" copies of any VC
            // parameters we might need.
            //
            TransferLinkStatusInfo( pVc, &info );
            statusVc = pVc->status;
        }
        NdisReleaseSpinLock( &pVc->lockV );

        NdisReleaseSpinLock( &pTunnel->lockT );
        {
            if (ulFlags & VCBF_PeerOpenPending)
            {
                TRACE( TL_N, TM_Recv,
                    ( "PeerOpen complete, s=$%x", statusVc ) );

                if (statusVc == NDIS_STATUS_SUCCESS)
                {
                    // Peer initiated call succeeded.
                    //
                    ASSERT( ulFlags & VCBF_VcDispatched );
                    TRACE( TL_I, TM_Recv, ( "NdisMCmDispCallConn" ) );
                    NdisMCmDispatchCallConnected( pVc->NdisVcHandle );
                    TRACE( TL_I, TM_Recv, ( "NdisMCmDispCallConn done" ) );

                    IndicateLinkStatus( pVc, &info );
                    CallSetupComplete( pVc );
                }
                else
                {
                    // Peer initiated call failed.
                    //
                    if (ulFlags & VCBF_VcDispatched)
                    {
                        SetFlags( &pVc->ulFlags, VCBF_WaitCloseCall );
                        TRACE( TL_I, TM_Recv,
                            ( "NdisMCmDispInCloseCall(s=$%x)", statusVc ) );
                        NdisMCmDispatchIncomingCloseCall(
                            statusVc, pVc->NdisVcHandle, NULL, 0 );
                        TRACE( TL_I, TM_Recv,
                            ( "NdisMCmDispInCloseCall done" ) );

                        // Client will call NdisClCloseCall which will get
                        // our LcmCloseCall handler called to clean up
                        // call setup, de-activate and delete the VC, as
                        // necessary.
                        //
                    }
                    else
                    {
                        // Return the VC to "just created" state.
                        //
                        CallCleanUp( pVc );
                    }
                }
            }
            else if (ulFlags & VCBF_ClientOpenPending)
            {
                TRACE( TL_N, TM_Recv,
                    ( "ClientOpen complete, s=$%x", statusVc ) );

                if (statusVc == NDIS_STATUS_SUCCESS)
                {
                    // Client initiated open, i.e. MakeCall, succeeded.
                    //
                    // Activating the VC is a CoNDIS preliminary to reporting
                    // the MakeCall complete.  For L2TP, all it does is get
                    // the NDIS state flags set correctly.
                    //
                    TRACE( TL_I, TM_Recv, ( "NdisMCmActivateVc" ) );
                    ASSERT( pVc->pMakeCall );
                    status = NdisMCmActivateVc(
                        pVc->NdisVcHandle, pVc->pMakeCall );
                    TRACE( TL_I, TM_Recv, ( "NdisMCmActivateVc=$%x", status ) );
                    ASSERT( status == NDIS_STATUS_SUCCESS );

                    {
                        BOOLEAN fCallActive;

                        SetFlags( &pVc->ulFlags, VCBF_VcActivated );
                        fCallActive = ReferenceCall( pVc );
                        ASSERT( fCallActive );
                    }
                }

                // Update the call parameters
                pVc->pMakeCall->CallMgrParameters->Transmit.PeakBandwidth = 
                pVc->pMakeCall->CallMgrParameters->Transmit.TokenRate = 
                pVc->pMakeCall->CallMgrParameters->Receive.PeakBandwidth = 
                pVc->pMakeCall->CallMgrParameters->Receive.TokenRate = pVc->ulConnectBps / 8;

                TRACE( TL_I, TM_Recv,
                    ( "NdisMCmMakeCallComp(s=$%x)", statusVc ) );
                ASSERT( pVc->pMakeCall );
                NdisMCmMakeCallComplete(
                    statusVc, pVc->NdisVcHandle, NULL, NULL, pVc->pMakeCall );
                TRACE( TL_I, TM_Recv, ( "NdisMCmMakeCallComp done" ) );

                if (statusVc == NDIS_STATUS_SUCCESS)
                {
                    IndicateLinkStatus( pVc, &info );
                    CallSetupComplete( pVc );
                }
                else
                {
                    // Return the VC to "just created" state.
                    //
                    InactiveCallCleanUp( pVc );
                }
            }
            else if (ulFlags & VCBF_PeerClosePending )
            {
                TRACE( TL_N, TM_Recv,
                    ( "PeerClose complete, s=$%x", statusVc ) );

                // Peer initiated close completed.
                //
                SetFlags( &pVc->ulFlags, VCBF_WaitCloseCall );
                TRACE( TL_I, TM_Recv, ( "NdisMCmDispInCloseCall(s=$%x)",
                    statusVc ) );
                NdisMCmDispatchIncomingCloseCall(
                    statusVc, pVc->NdisVcHandle, NULL, 0 );
                TRACE( TL_I, TM_Recv, ( "NdisMCmDispInCloseCall done" ) );

                // Client will call NdisClCloseCall while processing the above
                // which will get our LcmCloseCall handler called to
                // de-activate and delete the VC, as necessary.
                //
            }
            else if (ulFlags & VCBF_ClientClosePending)
            {
                // This section eventually runs for all successful unclosed
                // calls, whether peer or client initiated or closed.
                //
                TRACE( TL_N, TM_Recv, ( "ClientClose complete" ) );

                // Deactivate the VC and return all sent packets to the client
                // above.  These events will eventually lead to the call being
                // dereferenced to zero, at which time the close is completed,
                // and if peer initiated, the VC is deleted.
                //
                // Note: When MakeCall is cancelled by a Close request, these
                //       actions occur during the InactiveCallCleanUp in the
                //       ClientOpenPending completion code handling, rather
                //       than the CallCleanUp (which leads to
                //       InactiveCallCleanUp) here.  In this case, this block
                //       does NOT run even though the ClientClosePending flag
                //       is set.  Consider this before adding code here.
                //
                CallCleanUp( pVc );
            }
        }
        NdisAcquireSpinLock( &pTunnel->lockT );

        // Remove the reference for use of the VC pointer from the completing
        // list.
        //
        DereferenceVc( pVc );
    }
}


TUNNELCB*
CreateTunnelCb(
    IN ADAPTERCB* pAdapter )

    // Allocates and initializes a tunnel control block from the pool
    // associated with 'pAdapter'.  Tunnels are created unreferenced.
    //
    // Returns the allocated control block or NULL if allocation failed.  The
    // allocated block must eventually be freed with FREE_TUNNELCB, typically
    // via DereferenceTunnel.
    //
    // IMPORTANT: Caller must hold the 'pAdapter->lockTunnels'.
    //
{
    TUNNELCB* pTunnel;

    pTunnel = ALLOC_TUNNELCB( pAdapter );
    if (pTunnel)
    {
        NdisZeroMemory( pTunnel, sizeof(*pTunnel ) );

        InitializeListHead( &pTunnel->linkTunnels );
        InitializeListHead( &pTunnel->listRequestingVcs );
        InitializeListHead( &pTunnel->listCompletingVcs );
        InitializeListHead( &pTunnel->listSendsOut );
        InitializeListHead( &pTunnel->listOutOfOrder );
        InitializeListHead( &pTunnel->listVcs );
        InitializeListHead( &pTunnel->listWork );

        NdisAllocateSpinLock( &pTunnel->lockT );
        NdisAllocateSpinLock( &pTunnel->lockWork );

        pTunnel->ulTag = MTAG_TUNNELCB;
        pTunnel->state = CCS_Idle;

        // Choose the next non-zero sequential tunnel identifier.
        //
        pTunnel->usTunnelId = GetNextTunnelId( pAdapter );

        // Default send window, "slow started".  This is typically adjusted
        // based on peer's Receive Window AVP when the tunnel is created, but
        // if he doesn't include one this default is used.
        //
        pTunnel->ulSendWindow = pAdapter->info.MaxSendWindow >> 1;
        if (pTunnel->ulSendWindow == 0)
        {
            pTunnel->ulSendWindow = 1;
        }

        // Initialize the estimated round trip time and send timeout per the
        // suggestions in the draft/RFC.
        //
        pTunnel->ulRoundTripMs = pAdapter->ulInitialSendTimeoutMs;
        pTunnel->ulSendTimeoutMs = pTunnel->ulRoundTripMs;

        pTunnel->ulMediaSpeed = L2TP_LanBps;

        pTunnel->pTimerQ = ALLOC_TIMERQ( pAdapter );
        if (!pTunnel->pTimerQ)
        {
            pTunnel->ulTag = MTAG_FREED;
            FREE_TUNNELCB( pAdapter, pTunnel );
            return NULL;
        }

        TimerQInitialize( pTunnel->pTimerQ );
        ++pAdapter->ulTimers;

        if (pAdapter->pszPassword)
        {
            UNALIGNED ULONG* pul;

            // Password specified so peer should be authenticated.  Choose a
            // random challenge to send to peer.
            //
            pul = (UNALIGNED ULONG* )(pTunnel->achChallengeToSend);
            NdisGetCurrentSystemTime( (LARGE_INTEGER* )pul );
            pul[ 1 ] = PtrToUlong( pAdapter );
            pul[ 2 ] = PtrToUlong( pTunnel );
            pul[ 3 ] = PtrToUlong( &pul );
        }

        ReferenceAdapter( pAdapter );
        pTunnel->pAdapter = pAdapter;
        TRACE( TL_I, TM_Misc, ( "CreateTcb=$%p", pTunnel ) );
    }

    return pTunnel;
}


VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the address family of adapter control block
    // 'pAdapter', and when frees the block when the last reference is
    // removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "DerefAf to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        // Tell NDIS it's close is complete.
        //
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp" ) );
        NdisMCmCloseAddressFamilyComplete(
            NDIS_STATUS_SUCCESS, pAdapter->NdisAfHandle );
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp done" ) );

        // Remove the reference for the NdisAfHandle.
        //
        InterlockedExchangePointer( &pAdapter->NdisAfHandle, NULL );
        DereferenceAdapter( pAdapter );
    }
}


VOID
DereferenceCall(
    IN VCCB* pVc )

    // Removes a reference from the call active on 'pVc', invoking call clean
    // up when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        lRef = --pVc->lCallRef;
        TRACE( TL_N, TM_Ref, ( "DerefC to %d", pVc->lCallRef ) );
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    if (lRef == 0)
    {
        InactiveCallCleanUp( pVc );
    }
}


VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the SAP active on 'pAdapter', invoking
    // Deregiter SAP completion handling when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        lRef = --pAdapter->lSapRef;
        TRACE( TL_N, TM_Ref, ( "DerefSap to %d", pAdapter->lSapRef ) );
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (lRef == 0)
    {
        status = ScheduleWork( pAdapter, DeregisterSapPassive, pAdapter );
        ASSERT( status == NDIS_STATUS_SUCCESS );
    }
}


LONG
DereferenceTunnel(
    IN TUNNELCB* pTunnel )

    // Dereference the tunnel control block 'pTunnel'.  If no longer
    // referenced, unlink, undo any TDIX reference, and free the tunnel
    // control block.
    //
    // This routine will not try to acquire 'lockT' or any 'lockV'.
    //
    // Returns the reference count after the dereference.
    //
{
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;
    LONG lRef;

    pAdapter = pTunnel->pAdapter;

    NdisAcquireSpinLock( &pAdapter->lockTunnels );
    {
        lRef = --(pTunnel->lRef);
        TRACE( TL_N, TM_Ref, ( "DerefTcb to %d", lRef ) );
        ASSERT( lRef >= 0 );

        if (lRef == 0)
        {
            if (!(ReadFlags( &pTunnel->ulFlags )
                    & (TCBF_PeerInitiated | TCBF_Closing)))
            {
                // We initiated this tunnel and all it's calls have terminated
                // gracefully.  Initiate a graceful tunnel closing exchange.
                // We'll wind up back here with TCBF_Closing set.
                //
                ReferenceTunnel( pTunnel, TRUE );
                ScheduleTunnelWork(
                    pTunnel, NULL, FsmCloseTunnel,
                    (ULONG_PTR )TRESULT_General,
                    (ULONG_PTR )GERR_None,
                    0, 0, TRUE, FALSE );
            }
            else if (pTunnel->linkTunnels.Flink != &pTunnel->linkTunnels)
            {
                // The graceful closing exchange has completed or none is
                // indicated.  Time to stop all activity on the tunnel.
                //
                // Remove the tunnel from the adapter's list of active
                // tunnels.  Initialize the list link so it won't be done
                // again following the APCed TDIX clean up below.  Since there
                // are no VC references on the tunnel, no further receive path
                // events will touch this control block.
                //
                RemoveEntryList( &pTunnel->linkTunnels );
                InitializeListHead( &pTunnel->linkTunnels );

                if (ReadFlags( &pTunnel->ulFlags ) & TCBF_HostRouteAdded)
                {
                    // Undo the host route we added.
                    //
                    ReferenceTunnel( pTunnel, TRUE );
                    ScheduleTunnelWork(
                        pTunnel, NULL, DeleteHostRoute,
                        0, 0, 0, 0, TRUE, FALSE );
                }

                if (ReadFlags( &pTunnel->ulFlags ) & TCBF_TdixReferenced)
                {
                    // Undo our TDI extension context reference.
                    //
                    ReferenceTunnel( pTunnel, TRUE );
                    ScheduleTunnelWork(
                        pTunnel, NULL, CloseTdix,
                        0, 0, 0, 0, TRUE, FALSE );
                }
            }

            lRef = pTunnel->lRef;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockTunnels );

    if (lRef > 0)
    {
        return lRef;
    }

    TRACE( TL_N, TM_Misc, ( "Freeing TCB..." ) );

    // Stop the timer queue, which causes a TE_Terminate event for any timers
    // still running.
    //
    TimerQTerminate(
        pTunnel->pTimerQ, TunnelTqTerminateComplete, pAdapter );

    // No references and all PASSIVE IRQL termination completed.  Finish
    // cleaning up the tunnel control block.
    //
    ASSERT( !pTunnel->pTqiHello );
    ASSERT( IsListEmpty( &pTunnel->listVcs ) );
    ASSERT( IsListEmpty( &pTunnel->listRequestingVcs ) );
    ASSERT( IsListEmpty( &pTunnel->listCompletingVcs ) );
    ASSERT( IsListEmpty( &pTunnel->listWork ) );
    ASSERT( IsListEmpty( &pTunnel->listSendsOut ) );
    ASSERT( IsListEmpty( &pTunnel->listOutOfOrder ) );

    // Free the tunnel control block.
    //
    pTunnel->ulTag = MTAG_FREED;
    FREE_TUNNELCB( pAdapter, pTunnel );

    TRACE( TL_I, TM_Misc, ( "TCB freed $%p", pTunnel ) );
    DereferenceAdapter( pAdapter );
    return 0;
}


VOID
DereferenceVc(
    IN VCCB* pVc )

    // Removes a reference to the VC control block 'pVc', and when frees the
    // block when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefV to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ADAPTERCB* pAdapter;

        pAdapter = pVc->pAdapter;

        // Can make these assumptions because NDIS will not call the delete-VC
        // handler while the VC is active.  All the nasty VC clean up occurs
        // before the VC is deactivated and the call closed.
        //
        ASSERT( IsListEmpty( &pVc->listSendsOut ) );
        ASSERT( IsListEmpty( &pVc->listOutOfOrder ) );
        ASSERT( !pVc->pTqiDelayedAck );

        ASSERT( pVc->ulTag == MTAG_VCCB );
        pVc->ulTag = MTAG_FREED;

        FREE_VCCB( pAdapter, pVc );
        DereferenceAdapter( pAdapter );
        TRACE( TL_I, TM_Mp, ( "VCB freed $%p", pVc ) );
    }
}


VOID
InactiveCallCleanUp(
    IN VCCB* pVc )

    // Cleans up a deactivated call.  To clean up a call that might be active,
    // use CallCleanUp instead.  Returns the VC to "just created" state, in
    // case client decides to make another call without deleting the VC.
    //
{
    NDIS_STATUS status;
    ULONG ulFlags;
    BOOLEAN fVcCreated;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    BOOLEAN fForceGarbageCollect;

    TRACE( TL_I, TM_Cm, ( "InactiveCallCleanUp(pV=$%p)", pVc ) );

    pAdapter = pVc->pAdapter;

    // Release any call parameter allocations and the call-ID slot, if any.
    //
    CallSetupComplete( pVc );
    fForceGarbageCollect = ReleaseCallIdSlot( pVc );

    // Disassociate the VC from the tunnel.  It is possible the no tunnel is
    // associated, though only if short of memory.
    //
    pTunnel = pVc->pTunnel;
    if (!pTunnel)
    {
        TRACE( TL_A, TM_Cm, ( "Inactive VC w/o tunnel" ) );
        return;
    }

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        RemoveEntryList( &pVc->linkRequestingVcs );
        InitializeListHead( &pVc->linkRequestingVcs );

        NdisAcquireSpinLock( &pTunnel->lockVcs );
        {
            pVc->pTunnel = NULL;
            RemoveEntryList( &pVc->linkVcs );
            InitializeListHead( &pVc->linkVcs );
        }
        NdisReleaseSpinLock( &pTunnel->lockVcs );
    }
    NdisReleaseSpinLock( &pTunnel->lockT );

    // Flush queues, timers, and statistics.
    //
    NdisAcquireSpinLock( &pVc->lockV );
    {
        LIST_ENTRY* pLink;

        ulFlags = ReadFlags( &pVc->ulFlags );
        ASSERT( !(ulFlags & VCBF_VcActivated) );

        // Terminate any delayed acknowledge timer.
        //
        if (pVc->pTqiDelayedAck)
        {
            TimerQTerminateItem( pTunnel->pTimerQ, pVc->pTqiDelayedAck );
            pVc->pTqiDelayedAck = NULL;
        }

        // Flush any payloads from the "out" list.
        //
        while (!IsListEmpty( &pVc->listSendsOut ))
        {
            PAYLOADSENT* pPs;

            pLink = RemoveHeadList( &pVc->listSendsOut );
            InitializeListHead( pLink );
            pPs = CONTAINING_RECORD( pLink, PAYLOADSENT, linkSendsOut );

            TRACE( TL_I, TM_Cm, ( "Flush pPs=$%p", pPs ) );

            // Terminate the timer.  Doesn't matter if the terminate fails as
            // the expire handler will fail to get a call reference and do
            // nothing.
            //
            ASSERT( pPs->pTqiSendTimeout );
            TimerQTerminateItem( pTunnel->pTimerQ, pPs->pTqiSendTimeout );

            // Remove the context reference for linkage in the "out" queue.
            //
            pPs->status = NDIS_STATUS_FAILURE;
            DereferencePayloadSent( pPs );
        }

        // Discard any out-of-order packets.
        //
        while (!IsListEmpty( &pVc->listOutOfOrder ))
        {
            PAYLOADRECEIVED* pPr;

            pLink = RemoveHeadList( &pVc->listOutOfOrder );
            InitializeListHead( pLink );
            pPr = CONTAINING_RECORD(
                pLink, PAYLOADRECEIVED, linkOutOfOrder );

            TRACE( TL_I, TM_Cm, ( "Flush pPr=$%p", pPr ) );

            FreeBufferToPool(
                &pAdapter->poolFrameBuffers, pPr->pBuffer, TRUE );
            FREE_PAYLOADRECEIVED( pAdapter, pPr );
        }

        // Update the global statistics by adding in the values tabulated for
        // this call.  Also prints the statistics in some trace modes.
        //
        UpdateGlobalCallStats( pVc );
    }
    NdisReleaseSpinLock( &pVc->lockV );

    // Dereference the tunnel.  Careful, this makes 'pTunnel' invalid from
    // this point forward.
    //
    DereferenceTunnel( pTunnel );

    // Return the VC to "just created" state.
    //
    pVc->usAssignedCallId = 0;
    pVc->state = CS_Idle;
    ClearFlags( &pVc->ulFlags, 0xFFFFFFFF );
    pVc->usResult = 0;
    pVc->usError = 0;
    pVc->status = NDIS_STATUS_SUCCESS;
    pVc->ulConnectBps = 0;
    pVc->usNs = 0;
    pVc->ulMaxSendWindow = 0;
    pVc->ulAcksSinceSendTimeout = 0;
    pVc->lDeviationMs = 0;
    pVc->usNr = 0;
    NdisZeroMemory( &pVc->stats, sizeof(pVc->stats) );

    pVc->ulRoundTripMs = pAdapter->ulInitialSendTimeoutMs;
    pVc->ulSendTimeoutMs = pVc->ulRoundTripMs;

    pVc->ulSendWindow = pAdapter->info.MaxSendWindow >> 1;
    if (pVc->ulSendWindow == 0)
    {
        pVc->ulSendWindow = 1;
    }

    if (ulFlags & VCBF_ClientCloseCompletion)
    {
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp(OK)" ) );
        NdisMCmCloseCallComplete(
            NDIS_STATUS_SUCCESS, pVc->NdisVcHandle, NULL );
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp done" ) );

        // Careful, if this was a client created VC, client may have deleted
        // it, so 'pVc' must not be referenced hereafter in that case.
        //
    }

    // When peer initiates the call, we create the VC and so delete it
    // here.  Otherwise, client created it and we leave it to him to
    // delete it when he's ready.
    //
    if (ulFlags & VCBF_VcCreated)
    {
        NDIS_STATUS status;

        TRACE( TL_I, TM_Recv, ( "NdisMCmDelVc" ) );
        status = NdisMCmDeleteVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "NdisMCmDelVc=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );
        LcmCmDeleteVc( pVc );

        // Careful, 'pVc' has been deleted and must not be referenced
        // hereafter.
        //
    }

    // Create garbage collection events on all the pools if it was determined
    // above to be an appropriate time to do so, i.e. we just deactivated the
    // last active VC.
    //
    if (fForceGarbageCollect)
    {
        CollectBufferPoolGarbage( &pAdapter->poolFrameBuffers );
        CollectBufferPoolGarbage( &pAdapter->poolHeaderBuffers );
        CollectPacketPoolGarbage( &pAdapter->poolPackets );
    }
}


VOID
LockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace )

    // Lock the 'pVc->pInCallSetup' pointer.  If 'fGrace' is set, the "grace
    // period" reference is locked, and if not the "alloc" reference is
    // locked.  See also UnlockIcs.
    //
{
    SetFlags( &pVc->ulFlags, (fGrace) ? VCBF_IcsGrace : VCBF_IcsAlloc );
}


NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle Call Manager QueryInformation requests.  Arguments are as for
    // the standard NDIS 'MiniportQueryInformation' handler except this
    // routine does not count on being serialized with respect to other
    // requests.
    //
{
    #define L2TP_MaxLineName 64

    typedef struct
    L2TP_CO_TAPI_LINE_CAPS
    {
        CO_TAPI_LINE_CAPS caps;
        WCHAR achLineName[ L2TP_MaxLineName + 1 ];
    }
    L2TP_CO_TAPI_LINE_CAPS;

    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    ULONG extension;
    ULONG ulPortIndex;
    CO_TAPI_CM_CAPS cmcaps;
    L2TP_CO_TAPI_LINE_CAPS l2tpcaps;
    CO_TAPI_ADDRESS_CAPS addrcaps;
    CO_TAPI_CALL_DIAGNOSTICS diags;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_CO_TAPI_CM_CAPS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_CM_CAPS)" ) );

            NdisZeroMemory( &cmcaps, sizeof(cmcaps) );

            // The LINE and ADDRESS CAPS OIDs will be requested after this
            // one.
            //
            cmcaps.ulCoTapiVersion = CO_TAPI_VERSION;
            cmcaps.ulNumLines = 1;
            // caps.ulFlags = 0;
            pInfo = &cmcaps;
            ulInfoLen = sizeof(cmcaps);
            break;
        }

        case OID_CO_TAPI_LINE_CAPS:
        {
            ULONG ulLineNameLen;
            WCHAR* pszLineName;
            CO_TAPI_LINE_CAPS* pInCaps;
            LINE_DEV_CAPS* pldc;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_LINE_CAPS)" ) );

            if (InformationBufferLength < sizeof(L2TP_CO_TAPI_LINE_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_LINE_CAPS* )InformationBuffer;

            NdisZeroMemory( &l2tpcaps, sizeof(l2tpcaps) );
            pldc = &l2tpcaps.caps.LineDevCaps;

            l2tpcaps.caps.ulLineID = pInCaps->ulLineID;

            pldc->ulTotalSize = pInCaps->LineDevCaps.ulTotalSize;
            pldc->ulNeededSize =
                (ULONG )((CHAR* )(&l2tpcaps + 1)
                       - (CHAR* )(&l2tpcaps.caps.LineDevCaps));
            pldc->ulUsedSize = pldc->ulNeededSize;

            // pldc->ulProviderInfoSize = 0;
            // pldc->ulProviderInfoOffset = 0;
            // pldc->ulSwitchInfoSize = 0;
            // pldc->ulSwitchInfoOffset = 0;

            pldc->ulPermanentLineID = l2tpcaps.caps.ulLineID;

            // Pass the DriverDesc from the registry as the line name.  TAPI
            // requires that this be a localizable string.
            //
            if (pAdapter->pszDriverDesc)
            {
                pszLineName = pAdapter->pszDriverDesc;
            }
            else
            {
                pszLineName = L"L2TP";
            }

            ulLineNameLen = StrLenW( pszLineName ) + 1;
            if (ulLineNameLen > L2TP_MaxLineName)
            {
                ulLineNameLen = L2TP_MaxLineName;
            }

            NdisMoveMemory(
                l2tpcaps.achLineName, pszLineName,
                ulLineNameLen * sizeof(WCHAR) );
            l2tpcaps.achLineName[ ulLineNameLen ] = L'\0';
            pldc->ulLineNameSize = ulLineNameLen * sizeof(WCHAR);
            pldc->ulLineNameOffset = (ULONG )
                ((CHAR* )l2tpcaps.achLineName - (CHAR* )pldc);
            pldc->ulStringFormat = STRINGFORMAT_UNICODE;

            // pldc->ulAddressModes = 0;

            pldc->ulNumAddresses = 1;
            pldc->ulBearerModes = LINEBEARERMODE_DATA;
            pldc->ulMaxRate = L2TP_LanBps;
            pldc->ulMediaModes = LINEMEDIAMODE_UNKNOWN | LINEMEDIAMODE_DIGITALDATA;

            // pldc->ulGenerateToneModes = 0;
            // pldc->ulGenerateToneMaxNumFreq = 0;
            // pldc->ulGenerateDigitModes = 0;
            // pldc->ulMonitorToneMaxNumFreq = 0;
            // pldc->ulMonitorToneMaxNumEntries = 0;
            // pldc->ulMonitorDigitModes = 0;
            // pldc->ulGatherDigitsMinTimeout = 0;
            // pldc->ulGatherDigitsMaxTimeout = 0;
            // pldc->ulMedCtlDigitMaxListSize = 0;
            // pldc->ulMedCtlMediaMaxListSize = 0;
            // pldc->ulMedCtlToneMaxListSize = 0;
            // pldc->ulMedCtlCallStateMaxListSize = 0;
            // pldc->ulDevCapFlags = 0;

            pldc->ulMaxNumActiveCalls = 1;

            // pldc->ulAnswerMode = 0;
            // pldc->ulRingModes = 0;
            // pldc->ulLineStates = 0;
            // pldc->ulUUIAcceptSize = 0;
            // pldc->ulUUIAnswerSize = 0;
            // pldc->ulUUIMakeCallSize = 0;
            // pldc->ulUUIDropSize = 0;
            // pldc->ulUUISendUserUserInfoSize = 0;
            // pldc->ulUUICallInfoSize = 0;
            // pldc->MinDialParams = 0;
            // pldc->MaxDialParams = 0;
            // pldc->DefaultDialParams = 0;
            // pldc->ulNumTerminals = 0;
            // pldc->ulTerminalCapsSize = 0;
            // pldc->ulTerminalCapsOffset = 0;
            // pldc->ulTerminalTextEntrySize = 0;
            // pldc->ulTerminalTextSize = 0;
            // pldc->ulTerminalTextOffset = 0;
            // pldc->ulDevSpecificSize = 0;
            // pldc->ulDevSpecificOffset = 0;
            // pldc->ulLineFeatures;
            // pldc->ulSettableDevStatus;
            // pldc->ulDeviceClassesSize;
            // pldc->ulDeviceClassesOffset;
            // pldc->PermanentLineGuid;

            pldc->ulAddressTypes = LINEADDRESSTYPE_IPADDRESS;

            // pldc->ProtocolGuid;
            // pldc->ulAvailableTracking;

            pInfo = &l2tpcaps;
            ulInfoLen = sizeof(l2tpcaps);
            break;
        }

        case OID_CO_TAPI_ADDRESS_CAPS:
        {
            CO_TAPI_ADDRESS_CAPS* pInCaps;
            LINE_ADDRESS_CAPS* plac;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_ADDRESS_CAPS)" ) );

            if (InformationBufferLength < sizeof(CO_TAPI_ADDRESS_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_ADDRESS_CAPS* )InformationBuffer;

            NdisZeroMemory( &addrcaps, sizeof(addrcaps) );

            addrcaps.ulLineID = pInCaps->ulLineID;
            addrcaps.ulAddressID = pInCaps->ulAddressID;

            plac = &addrcaps.LineAddressCaps;

            plac->ulTotalSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulNeededSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulLineDeviceID = addrcaps.ulLineID;
            // plac->ulAddressSize = 0;
            // plac->ulAddressOffset = 0;
            // plac->ulDevSpecificSize = 0;
            // plac->ulDevSpecificOffset = 0;
            // plac->ulAddressSharing = 0;
            // plac->ulAddressStates = 0;
            // plac->ulCallInfoStates = 0;
            // plac->ulCallerIDFlags = 0;
            // plac->ulCalledIDFlags = 0;
            // plac->ulConnectedIDFlags = 0;
            // plac->ulRedirectionIDFlags = 0;
            // plac->ulRedirectingIDFlags = 0;
            // plac->ulCallStates = 0;
            // plac->ulDialToneModes = 0;
            // plac->ulBusyModes = 0;
            // plac->ulSpecialInfo = 0;
            // plac->ulDisconnectModes = 0;

            plac->ulMaxNumActiveCalls = (ULONG )pAdapter->usMaxVcs;

            // plac->ulMaxNumOnHoldCalls = 0;
            // plac->ulMaxNumOnHoldPendingCalls = 0;
            // plac->ulMaxNumConference = 0;
            // plac->ulMaxNumTransConf = 0;
            // plac->ulAddrCapFlags = 0;
            // plac->ulCallFeatures = 0;
            // plac->ulRemoveFromConfCaps = 0;
            // plac->ulRemoveFromConfState = 0;
            // plac->ulTransferModes = 0;
            // plac->ulParkModes = 0;
            // plac->ulForwardModes = 0;
            // plac->ulMaxForwardEntries = 0;
            // plac->ulMaxSpecificEntries = 0;
            // plac->ulMinFwdNumRings = 0;
            // plac->ulMaxFwdNumRings = 0;
            // plac->ulMaxCallCompletions = 0;
            // plac->ulCallCompletionConds = 0;
            // plac->ulCallCompletionModes = 0;
            // plac->ulNumCompletionMessages = 0;
            // plac->ulCompletionMsgTextEntrySize = 0;
            // plac->ulCompletionMsgTextSize = 0;
            // plac->ulCompletionMsgTextOffset = 0;

            pInfo = &addrcaps;
            ulInfoLen = sizeof(addrcaps);
            break;
        }

        case OID_CO_TAPI_GET_CALL_DIAGNOSTICS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_GET_CALL_DIAGS)" ) );

            if (!pVc)
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            NdisZeroMemory( &diags, sizeof(diags) );

            diags.ulOrigin =
                (ReadFlags( &pVc->ulFlags ) & VCBF_PeerInitiatedCall)
                    ? LINECALLORIGIN_EXTERNAL
                    : LINECALLORIGIN_OUTBOUND;
            diags.ulReason = LINECALLREASON_DIRECT;

            pInfo = &diags;
            ulInfoLen = sizeof(diags);
            break;
        }

        default:
        {
            TRACE( TL_A, TM_Cm, ( "QCm-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the address family of adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "RefAf to %d", lRef ) );
}


BOOLEAN
ReferenceCall(
    IN VCCB* pVc )

    // Returns true if a reference is added to the active call on VC control
    // block, 'pVc', or false if no reference was added because no call is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        if (ReadFlags( &pVc->ulFlags ) & VCBF_VcActivated)
        {
            fActive = TRUE;
            ++pVc->lCallRef;
            TRACE( TL_N, TM_Ref, ( "RefC to %d", pVc->lCallRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefC denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    return fActive;
}


BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter )

    // Returns true if a reference is added to the active SAP on adapter
    // 'pAdapter', or false if no reference was added because no SAP is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            fActive = TRUE;
            ++pAdapter->lSapRef;
            TRACE( TL_N, TM_Ref, ( "RefSap to %d", pAdapter->lSapRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefSap denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    return fActive;
}


LONG
ReferenceTunnel(
    IN TUNNELCB* pTunnel,
    IN BOOLEAN fHaveLockTunnels )

    // Reference the tunnel control block 'pTunnel'.  'FHaveLockTunnels' is
    // set when the caller holds 'ADAPTERCB.lockTunnels'.
    //
    // Returns the reference count after the reference.
    //
{
    LONG lRef;
    ADAPTERCB* pAdapter;

    if (!fHaveLockTunnels)
    {
        pAdapter = pTunnel->pAdapter;
        NdisAcquireSpinLock( &pAdapter->lockTunnels );
    }

    lRef = ++(pTunnel->lRef);
    TRACE( TL_N, TM_Ref, ( "RefT to %d", lRef ) );

    if (!fHaveLockTunnels)
    {
        NdisReleaseSpinLock( &pAdapter->lockTunnels );
    }

    return lRef;
}


VOID
ReferenceVc(
    IN VCCB* pVc )

    // Adds a reference to the VC control block 'pVc'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "RefV to %d", lRef ) );
}


BOOLEAN
ReleaseCallIdSlot(
    IN VCCB* pVc )

    // Releases 'pVc's reserved Call-ID slot in the adapter's VC table.
    //
    // Returns true if a release occurs and results in all slots being
    // available, false otherwise.
    //
{
    ADAPTERCB* pAdapter;
    USHORT usCallId;
    BOOLEAN fAllSlotsAvailable;

    pAdapter = pVc->pAdapter;
    usCallId = pVc->usCallId;
    pVc->usCallId = 0;
    fAllSlotsAvailable = FALSE;

    if (usCallId > 0 && usCallId <= pAdapter->usMaxVcs)
    {
        NdisAcquireSpinLock( &pAdapter->lockVcs );
        {
            pAdapter->ppVcs[ usCallId - 1 ] = NULL;
            ++(pAdapter->lAvailableVcSlots);

            if (pAdapter->lAvailableVcSlots >= (LONG )pAdapter->usMaxVcs)
            {
                fAllSlotsAvailable = TRUE;
            }
        }
        NdisReleaseSpinLock( &pAdapter->lockVcs );
    }

    return fAllSlotsAvailable;
}


NDIS_STATUS
ReserveCallIdSlot(
    IN VCCB* pVc )

    // Reserves a Call-ID slot for 'pVc' in the adapter's table.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or an error code.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB** ppVc;
    USHORT i;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pAdapter->lockVcs );
    {
        // At this point, we have a VC for the received call request that's
        // been successfully activated and dispatched to the client.  Reserve
        // a Call-ID in the adapter's look-up table.
        //
        if (pAdapter->lAvailableVcSlots > 0)
        {
            for (i = 0, ppVc = pAdapter->ppVcs;
                 i < pAdapter->usMaxVcs;
                 ++i, ++ppVc)
            {
                if (!*ppVc)
                {
                    // The -1 reserves the ID.  If/when the call negotiation
                    // completes successfully it will be changed to the
                    // address of the VCCB.  Call-IDs are 1-based because L2TP
                    // reserves Call-ID 0 to mean the tunnel itself.
                    //
                    *ppVc = (VCCB* )-1;
                    pVc->usCallId = i + 1;
                    break;
                }
            }

            ASSERT( i < pAdapter->usMaxVcs );
            --(pAdapter->lAvailableVcSlots);
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            // No Call-ID slots available.  This means the client accepted the
            // VC even though it put us over our configured limit.  Something
            // is mismatched in the configuration.  Assign a Call-ID above the
            // table size for use only in terminating the call gracefully.
            //
            TRACE( TL_N, TM_Misc, ( "No Call-ID slots?" ) );
            pVc->usCallId = GetNextTerminationCallId( pAdapter );
            status = NDIS_STATUS_NOT_ACCEPTED;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockVcs );

    return status;
}


TUNNELCB*
SetupTunnel(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usAssignedTunnelId,
    IN BOOLEAN fExclusive )

    // Sets up a tunnel to remote peer with IP address 'ulIpAddress' and
    // prepares it for sending or receiving messages.  'PAdapter' is the
    // owning adapter control block.  'UlIpAddress' is the remote peer's IP
    // address in network byte-order.  'UsAssignedTunnelId', if non-0,
    // indicates the assigned Tunnel-ID that must match in addition to the IP
    // address.  If 'FExclusive' is clear an existing tunnel to the peer is
    // acceptable.  If set, a new tunnel is created even if a matching one
    // already exists.
    //
    // Returns the address of the tunnel control block if successful, or NULL
    // if not.  If successful the block is already linked into the adapters
    // list of active tunnels and referenced, i.e. DereferenceTunnel must be
    // called during clean-up.
    //
{
    TUNNELCB* pTunnel;

    TRACE( TL_V, TM_Misc, ( "SetupTunnel" ) );

    NdisAcquireSpinLock( &pAdapter->lockTunnels );
    {
        // If an existing tunnel would be acceptable, find the first existing
        // tunnel with peer's IP address and, if non-0, assigned Tunnel-ID.
        // Typically, none will be found and we go on to create a new one
        // anyway.
        //
        pTunnel = (fExclusive)
            ? NULL
            : TunnelCbFromIpAddressAndAssignedTunnelId(
                  pAdapter, ulIpAddress, usAssignedTunnelId );

        if (!pTunnel)
        {
            pTunnel = CreateTunnelCb( pAdapter );
            if (!pTunnel)
            {
                ASSERT( !"Alloc TCB?" );
                NdisReleaseSpinLock( &pAdapter->lockTunnels );
                return NULL;
            }

            // Associate peer's IP address with the tunnel.
            //
            pTunnel->address.ulIpAddress = ulIpAddress;

            // Link the block into the adapter's list of active tunnels.
            //
            InsertHeadList(
                &pAdapter->listTunnels, &pTunnel->linkTunnels );
        }
        DBG_else
        {
            TRACE( TL_A, TM_Misc, ( "Tunnel $%p exists", pTunnel ) );
        }

        // Reference the tunnel control block.  Hereafter, clean-up must
        // include a call to DereferenceTunnel.
        //
        ReferenceTunnel( pTunnel, TRUE );
    }
    NdisReleaseSpinLock( &pAdapter->lockTunnels );

    return pTunnel;
}


VOID
SetupVcAsynchronously(
    IN TUNNELCB* pTunnel,
    IN ULONG ulIpAddress,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl )

    // Called by ReceiveControl to set up a VC for the incoming call described
    // in 'pInfo', 'pControl', and 'pBuffer' using the necessary asynchronous
    // CoNdis calls.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    INCALLSETUP* pIcs;
    NDIS_HANDLE NdisVcHandle;
    ULONG ulMask;
    BOOLEAN fTunnelClosing;
    BOOLEAN fCallActive;

    TRACE( TL_V, TM_Misc, ( "SetupVcAsync" ) );

    pAdapter = pTunnel->pAdapter;

    // Call our own CreateVc handler directly to allocate and initialize the
    // incoming call's VC.
    //
    status = LcmCmCreateVc( pAdapter, NULL, &pVc );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"CreateVc?" );
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }

    // Allocate an "incoming call setup" context and initialize it from the
    // receive buffer information arguments.
    //
    pIcs = ALLOC_INCALLSETUP( pAdapter );
    if (!pIcs)
    {
        ASSERT( !"Alloc ICS?" );
        LcmCmDeleteVc( pVc );
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }

    pIcs->pBuffer = pBuffer;
    NdisMoveMemory( &pIcs->control, pControl, sizeof(pIcs->control) );

    BuildCallParametersShell(
        pAdapter, ulIpAddress,
        sizeof(pIcs->achCallParams), pIcs->achCallParams,
        &pVc->pTiParams, &pVc->pTcInfo, &pVc->pLcParams );

    LockIcs( pVc, FALSE );
    pVc->pInCall = pIcs;

    // Default is success with errors filled in if they occur.
    //
    pVc->usResult = 0;
    pVc->usError = GERR_None;

    // Mark the call as initiated by the peer so we know which notifications
    // to give when the result is known.
    //
    ulMask = (VCBF_PeerInitiatedCall | VCBF_PeerOpenPending);
    if (*(pControl->pusMsgType) == CMT_ICRQ)
    {
        ulMask |= VCBF_IncomingFsm;
    }
    SetFlags( &pVc->ulFlags, ulMask );

    // Add a tunnel reference for this call on this VC, set the back pointer
    // to the owning tunnel, and link the VC into the tunnel's list of
    // associated VCs.
    //
    ReferenceTunnel( pTunnel, FALSE );
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
        {
            // This is unlikely because SetupTunnel only finds non-closing
            // tunnels, but this check and linkage must occur atomically under
            // 'lockT'.  New VCs must not be linked onto closing tunnels.
            //
            fTunnelClosing = TRUE;
        }
        else
        {
            fTunnelClosing = FALSE;
            NdisAcquireSpinLock( &pTunnel->lockVcs );
            {
                pVc->pTunnel = pTunnel;
                InsertTailList( &pTunnel->listVcs, &pVc->linkVcs );
            }
            NdisReleaseSpinLock( &pTunnel->lockVcs );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );

    if (fTunnelClosing)
    {
        CallSetupComplete( pVc );
        LcmCmDeleteVc( pVc );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        DereferenceTunnel( pTunnel );
        return;
    }

    // Peer MUST provide a Call-ID to pass back in the L2TP header of call
    // control and payload packets.
    //
    if (!pControl->pusAssignedCallId || *(pControl->pusAssignedCallId) == 0)
    {
        TRACE( TL_A, TM_Misc, ( "No assigned CID?" ) );
        pVc->usResult = CRESULT_GeneralWithError;
        pVc->usError = GERR_BadCallId;
        SetupVcComplete( pTunnel, pVc );
        return;
    }

    // Check if the request has a chance of succeeding before getting the
    // client involved.
    //
    if (!(ReadFlags( &pVc->ulFlags ) & VCBF_IncomingFsm))
    {
        // Fail requests to our LAC requiring asynchronous PPP framing or an
        // analog or digital WAN connection.  NDISWAN doesn't provide
        // asynchronous PPP framing, and we don't currently support non-LAN
        // WAN relays.
        //
        if (!pControl->pulFramingType
            || !(*(pControl->pulFramingType) & FBM_Sync))
        {
            TRACE( TL_A, TM_Misc, ( "Not sync framing type?" ) );

            if (!(pAdapter->ulFlags & ACBF_IgnoreFramingMismatch))
            {
                pVc->usResult = CRESULT_NoFacilitiesPermanent;
                pVc->usError = GERR_None;
                SetupVcComplete( pTunnel, pVc );
                return;
            }
        }

        if (pControl->pulBearerType
            && *(pControl->pulBearerType) != 0)
        {
            TRACE( TL_A, TM_Misc, ( "Cannot do bearer type" ) );
            pVc->usResult = CRESULT_NoFacilitiesPermanent;
            pVc->usError = GERR_None;
            SetupVcComplete( pTunnel, pVc );
            return;
        }
    }

    // Tell NDIS to notify the client of the new VC and give us it's handle.
    //
    ASSERT( pAdapter->NdisAfHandle );
    TRACE( TL_I, TM_Recv, ( "NdisMCmCreateVc" ) );
    status = NdisMCmCreateVc(
        pAdapter->MiniportAdapterHandle,
        pAdapter->NdisAfHandle,
        pVc,
        &pVc->NdisVcHandle );
    TRACE( TL_I, TM_Recv, ( "NdisMCmCreateVc=$%x,h=$%p",
        status, pVc->NdisVcHandle ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        pVc->usResult = CRESULT_GeneralWithError;
        pVc->usError = GERR_NoResources;
        SetupVcComplete( pTunnel, pVc );
        return;
    }
    SetFlags( &pVc->ulFlags, VCBF_VcCreated );

    // Tell NDIS the VC is active.
    //
    TRACE( TL_I, TM_Recv, ( "NdisMCmActivateVc" ) );
    status = NdisMCmActivateVc(
        pVc->NdisVcHandle, (PCO_CALL_PARAMETERS )pVc->pInCall->achCallParams );
    TRACE( TL_I, TM_Recv, ( "NdisMCmActivateVc=$%x", status ) );

    if (status != NDIS_STATUS_SUCCESS )
    {
        pVc->usResult = CRESULT_GeneralWithError;
        pVc->usError = GERR_NoResources;
        SetupVcComplete( pTunnel, pVc );
        return;
    }

    // Mark that the call is active, a state where both client and peer close
    // requests should be accepted.
    //
    SetFlags( &pVc->ulFlags,
        (VCBF_VcActivated
         | VCBF_CallClosableByClient
         | VCBF_CallClosableByPeer) );
    fCallActive = ReferenceCall( pVc );
    ASSERT( fCallActive );

    // Tell NDIS to tell the client about the call.  The dispatched flag is
    // set here rather in the completion because, according to JameelH, it is
    // valid to call NdisMCmDispatchIncomingCloseCall even if client pends on
    // the dispatch.  A reference on the SAP must be held during the operation
    // since it uses the NdisSapHandle.  The reference is released as soon as
    // the call returns.  A VC reference is taken to prevent the VC from being
    // deleted before the completion handler is called.  The VC reference is
    // removed by the completion handler.
    //
    if (!ReferenceSap( pAdapter ))
    {
        pVc->usResult = CRESULT_NoFacilitiesTemporary;
        pVc->usError = GERR_None;
        SetupVcComplete( pTunnel, pVc );
        return;
    }

    fCallActive = ReferenceCall( pVc );
    ReferenceVc( pVc );
    ASSERT( fCallActive );
    SetFlags( &pVc->ulFlags, VCBF_WaitInCallComplete );
    TRACE( TL_I, TM_Recv, ( "NdisMCmDispInCall" ) );
    status = NdisMCmDispatchIncomingCall(
        pAdapter->NdisSapHandle,
        pVc->NdisVcHandle,
        (CO_CALL_PARAMETERS* )pVc->pInCall->achCallParams );
    TRACE( TL_I, TM_Recv, ( "NdisMCmDispInCall=$%x", status ) );

    DereferenceSap( pAdapter );

    if (status == NDIS_STATUS_SUCCESS
        || status == NDIS_STATUS_PENDING)
    {
        SetFlags( &pVc->ulFlags, VCBF_VcDispatched );
    }

    if (status != NDIS_STATUS_PENDING)
    {
        LcmCmIncomingCallComplete( status, pVc, NULL );
    }

    // Next stop is our LcmCmIncomingCallComplete handler which will call
    // SetupVcComplete with client's reported status.
    //
}


VOID
SetupVcComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Called when the asynchronous incoming call VC setup result is known.
    // 'PVc' is the non-NULL set up VC, with 'usResult' and 'usError' fields
    // indicating the status thus far.  'PTunnel' is the associated tunnel.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    BOOLEAN fCallerFreesBuffer;
    ULONG ulcpVcs;
    VCCB** ppVcs;

    TRACE( TL_V, TM_Misc, ( "SetupVcComp,cid=%d,r=%d,e=%d",
        (ULONG )pVc->usCallId, (ULONG )pVc->usResult, (ULONG )pVc->usError ) );

    pAdapter = pVc->pAdapter;

    // Lock up 'pInCall' because as soon as the call is activated the call can
    // be torn down and 'pInCall' destroyed.  See also comments in UnlockIcs.
    //
    LockIcs( pVc, TRUE );
    {
        // OK, we're done trying to to set up the VC asynchronously.  A VCCB
        // and INCALLSETUP were successfully allocated, which is the minimum
        // required to be graceful with peer.  Reserve a Call-ID in the
        // adapter's look-up table.
        //
        status = ReserveCallIdSlot( pVc );
        if (status == NDIS_STATUS_SUCCESS)
        {
            ActivateCallIdSlot( pVc );
        }
        else
        {
            pVc->usResult = CRESULT_Busy;
            pVc->usError = GERR_None;
        }

        // Duplicate the tail of the receive path processing that would have
        // occurred if we'd not been forced to go asynchronous.
        //
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            fCallerFreesBuffer =
                ReceiveControlExpected(
                    pTunnel, pVc,
                    pVc->pInCall->pBuffer, &pVc->pInCall->control );

            CompleteVcs( pTunnel );
        }
        NdisReleaseSpinLock( &pTunnel->lockT );

        if (fCallerFreesBuffer)
        {
            FreeBufferToPool(
                &pVc->pAdapter->poolFrameBuffers,
                pVc->pInCall->pBuffer, TRUE );
        }
        DBG_else
        {
            ASSERT( FALSE );
        }
    }
    UnlockIcs( pVc, TRUE );
}


VOID
TunnelTqTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext )

    // TIMERQTERMINATECOMPLETE handler for 'TUNNELCB.pTimerQ'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = (ADAPTERCB* )pContext;
    --pAdapter->ulTimers;
    FREE_TIMERQ( pAdapter, pTimerQ );
}


VOID
UnlockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace )

    // Unlock the 'pVc->pInCallSetup' pointer.  If 'fGrace' is set, the "grace
    // period" reference is unlocked, and if not the "alloc" reference is
    // unlocked.  If both references are gone, then do the actual cleanup.
    //
    // Note: Regular reference counts don't work well here because there are
    //       several possible causes of the "alloc" unlock and they are not
    //       necessarily mutually exclusive.  However, we need to prevent the
    //       'pInCall' pointer from being freed until the incoming call
    //       response has been sent out, which in turn requires knowledge of
    //       whether the "activate for receive" succeeded.
    //
{
    INCALLSETUP *pInCall = NULL;
    ADAPTERCB *pAdapter;
    
    ClearFlags( &pVc->ulFlags, (fGrace) ? VCBF_IcsGrace : VCBF_IcsAlloc );

    if (!(ReadFlags( &pVc->ulFlags ) & (VCBF_IcsGrace | VCBF_IcsAlloc)))
    {
        NdisAcquireSpinLock(&pVc->lockV);
        if(pVc->pInCall)
        {
            pInCall = pVc->pInCall;
            pAdapter = pVc->pAdapter;
            pVc->pInCall = NULL;
            pVc->pTmParams = NULL;
            pVc->pTcParams = NULL;
            pVc->pLcParams = NULL;
        }
        NdisReleaseSpinLock(&pVc->lockV);
        
        if(pInCall != NULL)
        {
            FREE_INCALLSETUP( pAdapter, pInCall );
        }
    }
    
#if 0
    if (!(ReadFlags( &pVc->ulFlags ) & (VCBF_IcsGrace | VCBF_IcsAlloc))
        && pVc->pInCall)
    {
        FREE_INCALLSETUP( pAdapter, pInCall );
        pVc->pInCall = NULL;
        pVc->pTmParams = NULL;
        pVc->pTcParams = NULL;
        pVc->pLcParams = NULL;
    }

#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\l2tpp.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// l2tpp.h
// RAS L2TP WAN mini-port/call-manager driver
// Main private header (precompiled)
//
// 01/07/97 Steve Cobb
//
//
// About naming:
//
// This driver contains code for both the L2TP mini-port and the L2TP call
// manager.  All handler routines exported to NDIS are prefixed with either
// 'Lmp' for the mini-port handlers or 'Lcm' for the call manager handlers.
//
//
// About locks:
//
// Data structures that may change during simultaneous requests to different
// processors in a multi-processor system must be protected with spin-locks or
// accessed only with interlocked routines.  Where locking is required to
// access a data field in this header, the comment for that field indicates
// same.  A CoNDIS client is a trusted kernel mode component and presumed to
// follow the documented call sequences of CoNDIS.  Some access conflicts that
// might be caused by goofy clients are not checked, though the easy ones are.
// Cases where multiple clients might conflict are protected even though, for
// now, the TAPI proxy is expected to be the only client.
//
//
// About TDI and NDIS compliance:
//
// This driver is generally compliant with documented TDI and NDIS procedures,
// but there are two compliance issues worth mentioning.  First, it takes
// performance advantage from the fact that NDIS_BUFFERs and TDI I/O buffers
// are both defined as MDLs (see NDISBUFFERISMDL in tdix.c).  Second, it is
// built by default to take advantage of an IRP handling optimization which
// may be non-TDI-compliant though the docs are not real clear on the point
// (see ALLOCATEIRPS in tdix.c).  The driver could be made fully compliant on
// the first point in one hour and on the second by changing a #if
// option...but there would be a performance penalty.  Finally,
// InterlockedExchangePointer and InterlockedCompareExchangePointer are used,
// though there don't currently appear to be any NDIS equivalents.


#ifndef _L2TPP_H_
#define _L2TPP_H_


// If set, less commom allocations such as 1-per-call control blocks are made
// from lookaside lists.  Otherwise they are made using heap calls.  This
// option makes sense where a large number of calls are expected to be
// handled.
//
#define LLISTALL 0

// If set, ReadFlags translates into a simple assigment, otherwise it is an
// Interlocked operation.  Set this to 1 if a bus read of ULONG size is
// atomic.
//
#define READFLAGSDIRECT 1

#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <ntddndis.h>
#include <ipinfo.h>
#include <tcpinfo.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
//#include <ndisadd.h>  // Temporary
#include <md5.h>
#include <bpool.h>
#include <ppool.h>
#include <timer.h>
#include <debug.h>
#include <tdix.h>
#include <l2tp.h>
#include <l2tprfc.h>


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The NDIS version we report when registering mini-port and address family.
//
#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0

// The maximum number of bytes in a frame including the largest L2TP payload
// header, plus the 32 bytes the OID_WAN_GET_INFO documentation says should be
// reserved internally for "bridging and additional protocols".  This value is
// used for receive buffer allocations internally.  The L2TP draft/RFC
// guarantees that control messages will fit in L2TP_MaxFrameSize, so a buffer
// of this size is capable of receiving either payload or control packets.
//
#define L2TP_FrameBufferSize (L2TP_MaxFrameSize + L2TP_MaxPayloadHeader + 32)

// The maximum number of bytes in an L2TP control or payload header.  This
// value is used for buffer allocations internally.
//
#define L2TP_HeaderBufferSize L2TP_MaxHeaderSize

// Size of an IPv4 header.  Because the RawIp driver returns the IP header on
// received datagrams, this must be added onto the allocated buffer size.  We
// assume there will be no rarely used IP-option fields on L2TP traffic.
//
// Note: Suggested to PradeepB that RawIp should strip the IP header, and he
//       is considering adding an open-address option.  This can be removed if
//       said option materializes.
//
#define IpFixedHeaderSize 20

// Reported speed of a LAN tunnel in bits/second.
//
#define L2TP_LanBps 10000000

// The vendor name passed to peer during tunnel creation.
//
#define L2TP_VendorName "Microsoft"

// The firmware/software revision passed to peer during tunnel creation.  The
// value indicates "NT 5.0".
//
#define L2TP_FirmwareRevision 0x0500

// The maximum length of an IP address string of the form "a.b.c.d".
//
#define L2TP_MaxDottedIpLen 15

// Milliseconds in a Hello timer interval.  Not to be confused with the Hello
// timeout which is generally much longer than this.  See '*Hello*' fields in
// the TUNNELCB.
//
#define L2TP_HelloIntervalMs 10000


//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _VCCB VCCB;
typedef struct _INCALLSETUP INCALLSETUP;
typedef struct _TUNNELWORK TUNNELWORK;


// Adapter control block defining the state of a single L2TP mini-port
// adapter.  An adapter commonly supports multiple VPN devices.  Adapter
// blocks are allocated in MiniportInitialize and deallocated in MiniportHalt.
//
typedef struct
_ADAPTERCB
{
    // Set to MTAG_ADAPTERCB for easy identification in memory dumps and use
    // in assertions.
    //
    ULONG ulTag;

    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when the MiniportAdapterHandle field is set,
    //     i.e. when LmpInitialize succeeds and cleared when the LmpHalt
    //     handler is called.  The adapter block is actually passed to NDIS
    //     before it's known if LmpInitialize will succeed but according to
    //     ArvindM NDIS will not call halt unless it succeeds.
    //
    // (b) A reference is added when the NdisAfHandle field is set and removed
    //     when it is cleared.
    //
    // (c) A reference is added when the NdisSapHandle field is set and
    //     removed when it is cleared.
    //
    // (d) A reference is added for the VCCB's back pointer and removed when
    //     the VCCB is freed.
    //
    // (e) A reference is added for the TUNNELCB's back pointer and removed
    //     when the TUNNELCB is freed.
    //
    // (f) A reference is added when an NDIS_WORK_ITEM is scheduled and
    //     removed when it has completed.
    //
    // Access is via ReferenceAdapter and DereferenceAdapter only.
    //
    LONG lRef;

    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.  Many of these flags are set
    // permanently at initialization and so have no access limitation.
    //
    // ACBF_OutgoingRoleLac: Set when the driver is to assume the role of the
    //     L2TP Access Concentrator (LAC) as opposed to the L2TP Network
    //     Server (LNS) when making outgoing calls.  It would be simple to act
    //     either as LAC or LNS based on a CALL_PARAMETER field, if necessary,
    //     though this is not currently implemented.
    //
    // ACBF_IgnoreFramingMismatch: Set when a received framing type bit of
    //     "asynchronous" is to be ignored, rather than failing the
    //     negotiation.  This is a hedge against buggy peers as there are late
    //     draft changes to the order of the framing type bits.
    //
    // ACBF_ExclusiveTunnels: Set when an exclusive tunnel is to be created to
    //     the peer for each outgoing call even if another tunnel already
    //     exists to the peer.  This is a default and may be overridden in the
    //     L2TP specific call parameters.
    //
    // ACBF_SapActive: Set when the TDI open associated with the NdisSapHandle
    //     is successful and cleared when the corresponding TDI close is
    //     scheduled.  Access is protected by 'lockSap'.
    //
    // ACBF_UpdatePeerAddress: Set when changes in peer's source IP address
    //     and/or UDP port are to result in the destination of outbound
    //     packets changing accordingly.
    //
    ULONG ulFlags;
        #define ACBF_OutgoingRoleLac       0x00000001
        #define ACBF_IgnoreFramingMismatch 0x00000002
        #define ACBF_ExclusiveTunnels      0x00000004
        #define ACBF_SapActive             0x00000010
        #define ACBF_UpdatePeerAddress     0x00000100

    // The maximum number of out-of-order packets that may be queued on any
    // tunnel or link.  The value is read from the registry.  The value 0
    // effectively disables out-of-order handling.
    //
    SHORT sMaxOutOfOrder;

    // The maximum receive window we send to peer during tunnel setup for the
    // control session.  The value is read from the registry.  The value 0
    // means the Receive Window Size AVP should not be sent, though for
    // control this just results in peer using a default of 4.
    //
    USHORT usControlReceiveWindow;

    // The maximum receive window we send to peer during call setup for the
    // payload session.  The value is read from the registry.  The value 0
    // means the Receive Window Size AVP should not be sent, which results in
    // no sequence/acknowledge numbers being used for calls we initiate.  Note
    // that on peer originatated calls where peer specifies a window, 0 will
    // result in the default of 4 being offered.
    //
    USHORT usPayloadReceiveWindow;

    // The Hello timeout in milliseconds, i.e. the time that must elapse from
    // the last incoming packet before a "Hello" message is sent to verify the
    // media is still up.  The value is read from the registry.  A value of 0
    // effectively disables the Hello mechanism.
    //
    ULONG ulHelloMs;

    // The maximum milliseconds to wait for an acknowledge after sending a
    // control or payload packet.  The value is read from the registry.
    //
    ULONG ulMaxSendTimeoutMs;

    // The initial milliseconds to wait for an acknowledge after sending a
    // control or payload packet.  The send timeout is adaptive, so this value
    // is the seed only.  The value is read from the registry.
    //
    ULONG ulInitialSendTimeoutMs;

    // The maximum milliseconds to wait for an outgoing packet on which to
    // piggyback an acknowledge before sending a zero data acknowledge.  If
    // the value is greater than 1/4 of the current send timeout, the former
    // is used, i.e. this is the "maximum adaptive maximum".
    //
    ULONG ulMaxAckDelayMs;

    // The maximum number of times a control packet is retransmitted before
    // the owning tunnel is reset.  The value is read from the registry.
    //
    ULONG ulMaxRetransmits;

    // The randomly unique tie-breaker AVP value sent with all SCCRQ messages.
    // This field is currently unused.  After due consideration, I have
    // decided not to send tie-breaker AVPs in our SCCRQs.  The mechanism is
    // way too complicated for a rare case.  If peer really doesn't want two
    // tunnels he will simply ignore ours and let it timeout and fail anyway.
    // This is a minor, and I believe harmless, incompliance with the
    // draft/RFC.  My guess is that others will reach this same conclusion and
    // not send tie-breakers either.
    //
    CHAR achTieBreaker[ 8 ];

    // The password shared with peer for tunnel identification.  The value is
    // read from the registry.  Currently, only a single password for all
    // peers is used, though a password indexed by 'hostname' will likely be
    // added in the future.
    //
    CHAR* pszPassword;

    // The driver description read from the registry.  The value is used as
    // the L2TP line name when reporting up capabilities.
    //
    WCHAR* pszDriverDesc;

    // Our framing and bearer capablities bit masks as passed in SCCRQ.
    //
    ULONG ulFramingCaps;
    ULONG ulBearerCaps;

    // The string sent as the host name, or NULL if none.  The value is read
    // from the registry.
    //
    CHAR* pszHostName;

    // The next progressively increasing reference number likely to be unique
    // for all interconnected LACs/LNSs for a significant period of time.  It
    // is for use by administrators on either end of the tunnel to use when
    // investigating call failure problems.  Access is via Interlocked
    // routines.
    //
    ULONG ulCallSerialNumber;


    // VC TABLE --------------------------------------------------------------

    // The array of VC control block addresses allocated during adapter
    // initialization.  The VC control blocks themselves are created and hung
    // off this table dynamically.  Our Call-ID context returned to us by peer
    // in each L2TP packet is a 1-based index into this table.  (The 0 Call-ID
    // is reserved by L2TP to mean "not call specific").
    //
    // If an element is NULL, it means the Call-ID is not in use.  If an
    // element is -1, it means the Call-ID has been reserved, but messages
    // with the Call-ID are not yet acceptable.  Any other value is the
    // address of a VCCB for which messages can be accepted.  'VCCB.pTunnel'
    // is guaranteed valid while a VCCB is in the array.
    //
    // Access to the array is protected by 'lockVcs'.
    //
    VCCB** ppVcs;

    // The number of elements in the 'ppVcs' array.  This corresponds to the
    // number of configured VPN devices read from the registry during
    // initialization.
    //
    USHORT usMaxVcs;

    // Number of slots in 'usMaxVcs' that are available, i.e. NULL.  Access is
    // protected by 'lockVcs'
    //
    LONG lAvailableVcSlots;

    // Lock protecting the VC table, "available" counter, and 'listVcs'.
    //
    NDIS_SPIN_LOCK lockVcs;

    // The next Call-ID above 'usMaxVcs' for use only in terminating a call
    // gracefully.  Access is by the GetNextTerminationCallId routine only.
    //
    USHORT usNextTerminationCallId;


    // TUNNEL CHAIN ----------------------------------------------------------

    // Head of a double-linked list of active TUNNELCBs.  At no time will two
    // tunnels in the list have the same 'TUNNELCB.usTunnelId' or same
    // 'TUNNELCB.ulIpAddress'/'TUNNELCB.usAssignedTunnelId' pair.  Access to
    // the list links is protected by 'lockTunnels'.
    //
    LIST_ENTRY listTunnels;
    NDIS_SPIN_LOCK lockTunnels;

    // The tunnel identifier to assign to the next tunnel created.  Only the
    // GetNextTunnelId routine should access this field.
    //
    USHORT usNextTunnelId;


    // TDI -------------------------------------------------------------------

    // TDI extension context containing TDI state information for the adapter.
    // Access is via Tdix* interface routines, which handle all locking
    // internally.
    //
    TDIXCONTEXT tdix;


    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this mini-port adapter passed to us in
    // MiniportInitialize.  This is passed back to various NdisXxx calls.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    // NDIS's handle for our SAP as passed to our CmRegisterSapHandler or NULL
    // if none.  Only one SAP handle is supported because (a) the TAPI proxy's
    // is expected to be the only one, and (b) there are no L2TP SAP
    // properties that would ever lead us to direct a call to a second SAP
    // anyway.  Any client's attempt to register a second SAP will fail.  A
    // value of NULL indicates no SAP handle is currently registered.  Writers
    // must hold 'lockSap'.  Readers must hold 'lockSap' or a SAP reference.
    //
    NDIS_HANDLE NdisSapHandle;

    // Line and address IDs assigned by NDIS to the active SAP.
    //
    ULONG ulSapLineId;
    ULONG ulSapAddressId;

    // NDIS's handle for our Address Family as passed to our CmOpenAfHandler
    // or NULL if none.  Only one is supported.  See NdisSapHandle above.
    // Access is via Interlocked routines.
    //
    NDIS_HANDLE NdisAfHandle;

    // This adapter's capabilities as returned to callers on
    // OID_WAN_CO_GET_INFO.  These capabilities are also used as defaults for
    // the corresponding VCCB.linkinfo settings during MiniportCoCreateVc.
    //
    NDIS_WAN_CO_INFO info;

    // Reference count on the NdisAfHandle.  The reference pairs are:
    //
    // (a) A reference is added when the address family is opened and removed
    //     when it is closed.
    //
    // (b) A reference is added when a SAP is registered on the address family
    //     and removed when it is deregistered.
    //
    // (c) A reference is added when a VC is created on the address family and
    //     removed when it is deleted.
    //
    // Access is via ReferenceAf and DereferenceAf only.
    //
    LONG lAfRef;

    // Reference count on the NdisSapHandle.  The reference pairs are:
    //
    // (a) A reference is added when the SAP is registered and removed when it
    //     is de-registered.
    //
    // (b) A reference is added and immediately removed in FsmTunnelIdle to
    //     test for an active SAP in order to immediately reject requested
    //     tunnels when no SAP is active.
    //
    // (c) A reference is added when before calling
    //     NdisMCmDispatchIncomingCall and removed when the call returns.
    //
    // Access is via ReferenceSap and DereferenceSap only, excepting initial
    // reference by RegisterSapPassive.  Access is protected by 'lockSap'.
    //
    LONG lSapRef;

    // This lock protects the 'lSapRef' and 'NdisSapHandle' fields.
    //
    NDIS_SPIN_LOCK lockSap;


    // RESOURCE POOLS --------------------------------------------------------

    // Count of initialized but not yet completed timers.  We cannot allow a
    // Halt to complete until this goes to 0, because if we did our driver
    // could be unloaded with running timers in our memory which results in a
    // bugcheck.
    //
    ULONG ulTimers;

    // Pool of full frame buffers with pre-attached NDIS_BUFFER descriptors.
    // The pool is accessed via the interface defined in bpool.h, which
    // handles all locking internally.
    //
    BUFFERPOOL poolFrameBuffers;

    // Pool of L2TP header buffers with pre-attached NDIS_BUFFER descriptors.
    // The pool is accessed via the interface defined in bpool.h, which
    // handles all locking internally.
    //
    BUFFERPOOL poolHeaderBuffers;

    // Pool of NDIS_PACKET descriptors used in indication of received frames.
    // The pool is accessed via the interface defined in ppool.h, which
    // handles all locking internally.
    //
    PACKETPOOL poolPackets;

    // Lookaside list of NDIS_WORK_ITEM scheduling descriptors with extra
    // context space used by all tunnels and VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistWorkItems;

    // Lookaside list of TIMERQITEM timer event descriptors used by all
    // tunnels and VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistTimerQItems;

    // Lookaside list of CONTROLSENT sent control packet contexts used by all
    // tunnels attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistControlSents;

    // Lookaside list of PAYLOADLSENT sent payload packet contexts used by all
    // VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistPayloadSents;

    // Lookaside list of TUNNELWORK incoming VC setup contexts used for all
    // tunnels attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistTunnelWorks;

    // Lookaside list of CONTROLMSGINFO contexts used for all tunnels and VCs
    // attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistControlMsgInfos;

#if LLISTALL
    // Lookaside list of TUNNELCBs from which the 'listTunnels' control blocks
    // are allocated.
    //
    NPAGED_LOOKASIDE_LIST llistTunnels;

    // Lookaside list of VCCBs from which the control blocks dynamically
    // attached to '*ppVcs' are allocated.
    //
    NPAGED_LOOKASIDE_LIST llistVcs;

    // Lookaside list of TIMERQ descriptors used by all tunnels attached to
    // the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistTimerQs;

    // Lookaside list of CONTROLRECEIVED received control packet contexts used
    // by all tunnels attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistControlReceiveds;

    // Lookaside list of PAYLOADRECEIVED received payload packet contexts used
    // by all VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistPayloadReceiveds;

    // Lookaside list of CALLSETUP incoming VC setup contexts used for all
    // incoming VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistInCallSetups;
#endif
}
ADAPTERCB;


// Tunnel control block, describing the state of an L2TP tunnel, i.e. an L2TP
// control channel session to another L2TP LNS or LAC.  Each tunnel may have
// zero or more VCs associated with it.  Tunnel control blocks are allocated
// from 'ADAPTERCB.llistTunnels' in CmMakeCall and ReceiveControl.  Blocks are
// deallocated when the last reference is removed, e.g. when the control
// connection FSM terminates the tunnel.
//
typedef struct
_TUNNELCB
{
    // Links to the prev/next TUNNELCB in the owning adapter's tunnel list.
    // Access to the list links is protected by 'ADAPTERCB.lockTunnels'.
    //
    LIST_ENTRY linkTunnels;

    // Set to MTAG_TUNNELCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when a call on a VCCB is active or becoming
    //     active and removed when it is deactivated, i.e. during the period
    //     the VCCB is on 'listVcs'.  This covers the back pointer in the
    //     VCCB.
    //
    // (b) A reference is added when peer initiates a tunnel and removed when
    //     the tunnel transitions to idle state.  This keeps peer-initiated
    //     tunnels from terminating when there are no no calls, since by
    //     convention, it is peer who closes the tunnel in that case.
    //
    // (c) A reference is added when a graceful tunnel close is initiated and
    //     removed when the tunnel transitions to idle state.
    //
    // (d) A reference is added when the delayed control acknowledge timer is
    //     scheduled and removed by the timer event handler.
    //
    // (e) LookUpTunnelAndVcCbs adds a reference that is removed at the end of
    //     the L2tpReceive handler.  This covers the receive path.
    //
    // (f) A reference is added when a CONTROLSENT context is assigned a
    //     tunnel back pointer and removed when the context is freed.
    //
    // (g) A reference is added when a PAYLOADSENT context is assigned a
    //     tunnel back pointer and removed when the context is freed.
    //
    // (h) ScheduleTunnelWork adds a reference that is removed by TunnelWork
    //     after executing the work.  This covers the tunnel pointer passed as
    //     a context to NdisScheduleWorkItem.
    //
    // Access is via ReferenceTunnel and DereferenceTunnel only which use
    // 'ADAPTERCB.lockTunnels' for protection.
    //
    LONG lRef;

    // Back pointer to owning adapter's control block.
    //
    ADAPTERCB* pAdapter;

    // This lock protects TUNNELCB send, receive, and state fields as noted in
    // other field descriptions.
    //
    NDIS_SPIN_LOCK lockT;


    // TUNNEL SETUP ----------------------------------------------------------

    // IP address and UDP port of the remote end of the tunnel in network byte
    // order.  The IP address is pulled from the call parameters passed to
    // CmMakeCall.  It is updated with the last source IP address received
    // from a peer passing this tunnel's ID, per the L2TP draft/RFC section
    // 8.1 on "L2TP over IP/UDP media".  However, it is assumed that the
    // updated source address will not match the address of another existing
    // tunnel.  The UDP port (not used in raw IP mode) is initially the well
    // known L2TP port (1701).  It is updated with the last source UDP port
    // received from peer on this tunnel.  Access is protected by
    // 'pAdapter->lockTunnels'.
    //
    TDIXIPADDRESS address;

    // IP address and ifindex of my end of the tunnel in network byte
    // used to get the media speed and build IP header
    TDIXIPADDRESS myaddress;

    TDIXUDPCONNECTCONTEXT udpContext;

    // "Connection" cookie returned by TdixAddHostRoute.  This may be passed
    // to TdixSendDatagram to send on the connected channel (used for sent
    // payloads) as opposed to the unconnected channel (used for receives and
    // sent controls).  The address is invalid after TdixDeleteHostRoute is
    // called.
    //
    TDIXROUTE* pRoute;

    // Our unique tunnel identifier sent back to us by peer in the L2TP
    // header.  The value is chosen, using GetNextTunnelId, from a sequential
    // counter in ADAPTERCB and has no further meaning.
    //
    USHORT usTunnelId;

    // The tunnel identifier chosen by peer that we send back to him in the
    // L2TP header Tunnel-ID field for all packets on this tunnel.  A value of
    // 0 indicates no ID has been assigned.
    //
    USHORT usAssignedTunnelId;

    // TCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines only.
    //
    // TCBF_TdixReferenced: Set when the tunnel has referenced the adapter's
    //     TDI extension context by successfully calling TdixOpen.
    //     DereferenceTunnel uses this to automatically dereference the
    //     context when the tunnel is dereferenced.
    //
    // TCBF_CcInTransition: Set when the control connection FSM has begun but
    //     not finished a sequence of state changes that will end up in either
    //     Idle or Established state.  When this flag is set new requests to
    //     bring the tunnel up or down are queued on 'listRequestingVcs' for
    //     re-execution when a result is known.  Access to the bit is
    //     protected by 'lockT'.
    //
    // TCBF_PeerInitiated: Set when the tunnel was initiated by the peer,
    //     rather than a local request.  If all calls are dropped and this bit
    //     is not set, we close the tunnel gracefully.
    //
    // TCBF_PeerInitRef: Set when a reference for peer initation is taken on
    //     the tunnel and cleared when the reference is removed.
    //
    // TCBF_HostRouteAdded: Set when the host route is successfully added and
    //     referenced and removed when it is dereferenced.
    //
    // TCBF_HostRouteChanged: Set when a host route changed has been attempted
    //     on the tunnel, and never cleared.
    //
    // TCBF_PeerNotResponding: Set when the tunnel is closed due to lack of
    //     response from peer, i.e. after all retries have been exhausted.
    //
    // TCBF_Closing: Set as soon as the tunnel is known to be transitioning to
    //     idle state.  Access is protected by 'lockT'.
    //
    // TCBF_FsmCloseRef: Set when a graceful closing exchange is initiated by
    //     FsmClose and cleared when the tunnel reaches idle state.
    //
    // TCBF_InWork: Set when an APC is scheduled to execute work from the
    //     'listWork' queue.  Access is protected by 'lockWork'.
    //
    ULONG ulFlags;
        #define TCBF_TdixReferenced    0x00000001
        #define TCBF_CcInTransition    0x00000002
        #define TCBF_PeerInitiated     0x00000004
        #define TCBF_PeerInitRef       0x00000008
        #define TCBF_HostRouteAdded    0x00000010
        #define TCBF_PeerNotResponding 0x00000020
        #define TCBF_HostRouteChanged  0x00000040
        #define TCBF_Closing           0x00000100
        #define TCBF_FsmCloseRef       0x00000200
        #define TCBF_InWork            0x00001000
        #define TCBF_SendConnected     0x00002000

    // The current state of the tunnel's control connection creation FSM.  See
    // also 'VCCB.state'.
    //
    // Only one tunnel creation session may be underway even if CmMakeCall has
    // been called on multiple VCs over this tunnel.  For this reason,
    // transitions to/from the Idle or Established states must be protected by
    // 'lockT'.  See also TCBF_CcInTransition flag and 'listRequestingVcs'.
    //
    // The protocol sorts out the case of simultaneous originate and receive
    // requests ensuring that one gets dropped before it reaches Established
    // state when either provides a tie-breaker.  We always provide a
    // tie-breaker for IP media.  For QOS-enabled medias where one control
    // channel per call makes sense and no tie-breakers are passed, a lower
    // level VC ID will be used to distinguish tunnel control blocks on
    // receive.  So, a single TUNNELCB will never have both originated and
    // received control channels in Established state.
    //
    L2TPCCSTATE state;

    // Double-linked queue of all VCCBs waiting for the tunnel to open.  New
    // VCs must not be linked on closing tunnels, i.e. those with the
    // TCBF_Closing flag set.  Access is protected by 'lockT'.
    //
    LIST_ENTRY listRequestingVcs;

    // Double-linked queue of VCCBs whose VCBF_XxxPending operation has
    // completed.  'VCCB.status' is the status that will be indicated.  This
    // mechanism is necessary to avoid the spin-lock issues that results when
    // one tries to call NDIS completion APIs from the bowels of the FSMs.
    //
    LIST_ENTRY listCompletingVcs;

    // Peer's framing and bearer capablities.
    //
    ULONG ulFramingCaps;
    ULONG ulBearerCaps;

    // The challenge and challenge response sent to peer.  These are in the
    // control block for convenience, as they must be passed thru the work
    // scheduling mechanism and don't fit easily into the generic arguments.
    //
    CHAR achChallengeToSend[ 16 ];
    CHAR achResponseToSend[ 16 ];


    // SEND STATE ------------------------------------------------------------

    // Next Sent, the sequence number of next control packet transmitted on
    // this tunnel.  The field is initialized to 0 and incremented after
    // assignment to an outgoing packet, excepting retransmissions.  Access is
    // protected by 'lockT'.
    //
    USHORT usNs;

    // Double-linked list of outstanding sends, i.e. CONTROLSENTs sorted by
    // the 'usNs' field with lower values near the head.  The list contains
    // all active unacknowledged CONTROLSENT contexts, even those that may be
    // waiting for their first transmission.  Access is protected by 'lockT'.
    //
    LIST_ENTRY listSendsOut;

    // The number of control packets sent but not acknowledged or timed out.
    // Access is protected by 'lockT'.
    //
    ULONG ulSendsOut;

    // The number of sent but unacknowledged packets that may be outstanding.
    // This value is adjusted dynamically.  Per the draft/RFC, when
    // 'ulAcksSinceSendTimeout' reaches the current setting, the window is
    // increased by one.  When a send timeout expires the window is reduced by
    // half.  Access is protected by 'lockT'.
    //
    ULONG ulSendWindow;

    // The maximum value of 'ulSendWindow'.  Peer chooses this value during
    // call setup by offering a receive window.
    //
    ULONG ulMaxSendWindow;

    // The number of packets acknowledged since the last timeout.  The value
    // is reset when a timeout occurs or the send window is adjusted upward.
    // See 'ulSendWindow'.  Access is protected by 'lockT'.
    //
    ULONG ulAcksSinceSendTimeout;

    // The estimated round trip time in milliseconds.  This is the RTT value
    // from Appendix A of the draft/RFC.  The value is adjusted as each
    // acknowledge is received.  It is initialized to the Packet Processing
    // Delay reported by peer.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockT'.
    //
    ULONG ulRoundTripMs;

    // The estimated mean deviation in milliseconds, an approximation of the
    // standard deviation.  This is the DEV value from Appendix A of the
    // draft/RFC.  The value is adjusted as each acknowledge is received.  It
    // is initially 0.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockT'.
    //
    LONG lDeviationMs;

    // Milliseconds before it is assumed a sent packet will not be
    // acknowledged and needs to be retransmitted.  This is the ATO value from
    // Appendix A of the draft/RFC.  This value is adjusted as each
    // acknowledge is received, with a maximum of
    // 'ADAPTERCB.ulMaxSendTimeoutMs'.  Access is protected by 'lockT'.
    //
    ULONG ulSendTimeoutMs;

    // The timer event descriptor scheduled to occur when it is time to stop
    // waiting for an outgoing send on which to piggyback an acknowledge.
    // This will be NULL when no delayed acknowledge is pending.  Per the
    // draft/RFC, the timeout used is 1/4 of the 'ulSendTimeoutMs'.  Access is
    // protected by 'lockT'.
    //
    TIMERQITEM* pTqiDelayedAck;

    // The timer event descriptor which expires when it's time to check for
    // lack of any incoming packets.  To reduce the cost of constantly
    // resetting a Hello timer with a full timeout (which with unsequenced
    // payloads usually results in an NdisCancelTimer/NdisSetTimer on each
    // received packet), the timeout is broken into intervals of
    // L2TP_HelloIntervalMs.  If it expires and both 'ulRemainingHelloMs' and
    // 'ulHelloResetsThisInterval' are 0, a "Hello" message is sent to the
    // peer to verify that the media is still up.  Access to this field is
    // protected by 'lockT'.
    //
    TIMERQITEM* pTqiHello;

    // The milliseconds left to wait in all remaining Hello intervals and the
    // number of resets since the last Hello interval timeout.
    //
    ULONG ulRemainingHelloMs;
    ULONG ulHelloResetsThisInterval;
    
    // RECEIVE STATE ---------------------------------------------------------

    // Next Received, the sequence number one higher than that of the last
    // control packet received on this tunnel or 0 if none.  Access is
    // protected by 'lockT'.
    //
    USHORT usNr;

    // Double-linked list of out-of-order receives, i.e. CONTROLRECEIVEs
    // sorted by the 'usNs' field with lower values near the head.  The
    // maximum queue length is 'ADAPTERCB.sMaxOutOfOrder'.  Access is
    // protected by 'lockT'.
    //
    LIST_ENTRY listOutOfOrder;


    // TIMER QUEUE -----------------------------------------------------------

    // Timer queue for both the control and data channels.  The timer queue is
    // accessed via the interface defined in timer.h, which handles all
    // locking internally.
    //
    TIMERQ* pTimerQ;


    // WORK QUEUE ------------------------------------------------------------

    // Double-linked list NDIS_WORK_ITEMs queued for serialized execution at
    // PASSIVE IRQL.  The next item to be executed is at the head of the list.
    // Access is protected via the ScheduleTunnelWork routine, which protects
    // the list with 'lockWork'.  See also TCBF_InWork.
    //
    LIST_ENTRY listWork;
    NDIS_SPIN_LOCK lockWork;


    // VC CHAIN --------------------------------------------------------------

    // Head of a double-linked list of VCCBs associated with the tunnel, i.e.
    // with calls active or in the process of becoming active.  New VCs must
    // not be linked on closing tunnels, i.e. those with the TCBF_Closing flag
    // set.  Access to the links is protected by 'lockVcs'.
    //
    LIST_ENTRY listVcs;
    NDIS_SPIN_LOCK lockVcs;

    // media speed
    ULONG ulMediaSpeed;
}
TUNNELCB;


// Call statistics block.
//
typedef struct
_CALLSTATS
{
    // System time call reached established state.  When the block is being
    // used for cumulative statistics of multiple calls, this is the number of
    // calls instead.
    //
    LONGLONG llCallUp;

    // Duration in seconds of now idle call.
    //
    ULONG ulSeconds;

    // Total data bytes received and sent.
    //
    ULONG ulDataBytesRecd;
    ULONG ulDataBytesSent;

    // Number of received packets indicated up.
    //
    ULONG ulRecdDataPackets;

    // Number of received packets linked on the out-of-order queue before
    // being indicated up.
    //
    ULONG ulDataPacketsDequeued;

    // Number of received packets of zero length.  Includes packets with the
    // R-bit set.
    //
    ULONG ulRecdZlbs;

    // Number of received packets with R-bit set.
    //
    ULONG ulRecdResets;

    // Number of received packets with R-bit set that are out of date.
    //
    ULONG ulRecdResetsIgnored;

    // Number of data packets sent with and without sequence numbers.  The sum
    // of the two is the total data packets sent.
    //
    ULONG ulSentDataPacketsSeq;
    ULONG ulSentDataPacketsUnSeq;

    // Number of packets sent that were acknowledged and timed out.  If the
    // call is cancelled with packets outstanding the sum of the two may be
    // less than 'ulSentDataPacketsSeq'.
    //
    ULONG ulSentPacketsAcked;
    ULONG ulSentPacketsTimedOut;

    // Number of zero length acknowledges sent.
    //
    ULONG ulSentZAcks;

    // Number of packets sent with the R-bit set.
    //
    ULONG ulSentResets;

    // Number of times the send window was changed.
    //
    ULONG ulSendWindowChanges;

    // Total of all send window sizes, one for each 'ulSentDataPacketsSeq'.
    //
    ULONG ulSendWindowTotal;

    // Largest send window.
    //
    ULONG ulMaxSendWindow;

    // Smallest send window.
    //
    ULONG ulMinSendWindow;

    // Number of sample round trips.  (sequenced packets only)
    //
    ULONG ulRoundTrips;

    // Total of all round trips in milliseconds.  (sequenced packets only)
    //
    ULONG ulRoundTripMsTotal;

    // Longest round trip,  (sequenced packets only)
    //
    ULONG ulMaxRoundTripMs;

    // Shortest round trip.  (sequenced packets only)
    //
    ULONG ulMinRoundTripMs;
}
CALLSTATS;


// Virtual circuit control block defining the state of a single L2TP VC, i.e.
// one line device endpoint and the call, if any, active on it.  A VC is never
// used for incoming and outgoing calls simultaneously.  A single NDIS VC maps
// to one of these.
//
typedef struct
_VCCB
{
    // Links to the prev/next VCCB in the owning tunnel's active VC list.
    // Access is protected by 'TUNNELCB.lockVcs'.
    //
    LIST_ENTRY linkVcs;

    // Set to MTAG_VCCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // Reference count on this VC control block.  The reference pairs are:
    //
    // (a) LmpCoCreateVc adds a reference that is removed by LmpCoDeleteVc.
    //     This covers all clients that learn of the VCCB via NDIS.
    //
    // (b) LookUpTunnelAndVcCbs adds a reference that is removed at the end of
    //     the L2tpReceive handler.  This covers the receive path.
    //
    // (c) A reference is added when a CONTROLSENT context with 'pVc'
    //     referring to this VCCB is assigned the back pointer and removed
    //     when the context is freed.
    //
    // (d) A reference is added when a PAYLOADSENT context with 'pVc'
    //     referring to this VCCB is assigned the back pointer and removed
    //     when the context is freed.
    //
    // (e) ScheduleTunnelWork adds a reference that is removed by TunnelWork
    //     after executing the work.
    //
    // (f) A reference is added before scheduling the delayed payload
    //     acknowledge timer and removed in the timer event handler.
    //
    // (g) A reference is taken by CompleteVcs covering use of the VC popped
    //     from the tunnel's completing list, and released after use.
    //
    // (h) A reference is taken prior to calling NdisMCmDispatchIncomingCall
    //     and removed by the completion handler.
    //
    // (i) A reference is added when a CONTROLRECEIVED context with 'pVc'
    //     referring to this VCCB is assigned the back pointer and removed
    //     when the context is freed.
    //
    // The field is accessed only by the ReferenceVc and DereferenceVc
    // routines, which protect with Interlocked routines.
    //
    LONG lRef;

    // Back pointer to owning adapter's control block.
    //
    ADAPTERCB* pAdapter;

    // Back pointer to owning tunnel's control block or NULL if none.
    // Guaranteed valid whenever the VC is linked into a tunnel's 'listVcs',
    // i.e. when it holds a reference on the tunnel.  It is safe to use this
    // if you hold a reference on the call.  Otherwise, it is not.  Be very
    // careful here.
    //
    TUNNELCB* pTunnel;

    // This lock protects VCCB payload send and receive paths as noted in
    // other field descriptions.  In cases where both 'lockV' and
    // 'pTunnel->lockT' are required 'lockT' must be obtained first.
    //
    NDIS_SPIN_LOCK lockV;


    // CALL SETUP ------------------------------------------------------------

    // Our unique call identifier sent back to us by peer in the L2TP header.
    // The value is a 1-based index into the 'ADAPTERCB.ppVcs' array.
    //
    USHORT usCallId;

    // The call identifier, chosen by peer, that we send back to him in the
    // L2TP header Call-ID field for all packets on this call.  A value of 0
    // indicates no Call-ID has been assigned.
    //
    USHORT usAssignedCallId;

    // VCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines.
    //
    // VCBF_IndicateReceivedTime: Set if MakeCall caller sets the
    //     MediaParameters.Flags RECEIVE_TIME_INDICATION flag requesting the
    //     TimeReceived field of the NDIS packet be filled with a timestamp.
    //
    // VCBF_CallClosableByClient: Set when a call is in a state where
    //     LcmCmCloseCall requests to initiate clean-up should be accepted.
    //     This may be set when VCBF_CallClosableByPeer is not, which means we
    //     have indicated an incoming close to client and are waiting for him
    //     to do a client close in response (in that weird CoNDIS way).  The
    //     flag is protected by 'lockV'.
    //
    // VCBF_CallClosableByPeer: Set when the call is in a state where an idle
    //     transition without operations pending should be mapped to a
    //     PeerClose event.  This will never be set when
    //     VCBF_CallClosableByClient is not.  The flag is protected by
    //     'lockV'.
    //
    // VCBF_DefaultLcParams: Set when the 'pLcParams' field was allocated by
    //     us rather than being owned by client.
    //
    // VCBF_IncomingFsm: Set when the VC is executing the Incoming Call FSM
    //     rather than Outgoing Call FSM in the active incoming/outgoing call.
    //     For client initiated calls this will set if the adapter's
    //     ACBF_OutgoingRoleLac flag, read from the registry, is set.
    //
    // VCBF_PeerInitiatedCall: Set when an the active call was initiated by
    //     the peer, clear if it was initiated by the client.
    //
    // VCBF_Sequencing: Set unless no Receive Window AVP is provided/received
    //     during call setup, resulting in "no sequencing" mode where Ns/Nr
    //     fields are not sent in the payload header.  This also effectively
    //     disables out-of-order processing.
    //
    // VCBF_VcCreated: Set when the VC has been created successfully.  This is
    //     the "creation" that occurs with the client, not the mini-port.
    // VCBF_VcActivated: Set when the VC has been activated successfully.
    // VCBF_VcDispatched: Set when the VC has dispatched an incoming call to
    //     the client and client has returned success or pended.
    // VCBM_VcState: Bit mask including each of the above 3 NDIS state flags.
    //
    // VCBF_VcDeleted: Set when the DeleteVC handler has been called on this
    //     VC.  This guards against NDPROXY double-deleting VCs which it has
    //     been known to do.
    //
    // The pending bits below are mutually exclusive (except ClientClose which
    // may occur after but simultaneous with ClientOpen), and so require lock
    // protection by 'lockV':
    //
    // VCBF_PeerOpenPending: Set when peer attempts to establish a call, and
    //     the result is not yet known.
    // VCBF_ClientOpenPending: Set when client attempts to establish a call,
    //     and the result is not yet known.
    // VCBF_PeerClosePending: Set when peer attempts to close an established
    //     call and the result is not yet known.  Access is protected by
    //     'lockV'.
    // VCBF_ClientClosePending: Set when client attempts to close an
    //     established call and the result is not yet known.  Access is
    //     protected by 'lockV'.
    // VCBM_Pending: Bit mask that includes each of the 4 pending flags.
    //
    // VCBF_ClientCloseCompletion: Set when client close completion is in
    //     progress.
    //
    // VCBF_IcsAlloc: Set when the 'pInCall' block has been locked for
    //     allocation and cleared when the call is torn down.  Accessed only
    //     by the LockIcs/UnlockIcs routines.
    // VCBF_IcsGrace: Set when the 'pInCall' pointer has been locked for a
    //     grace period during which the response to the incoming call message
    //     is sent.  Accessed only by the LockIcs/UnlockIcs routines.
    //
    // VCBF_WaitInCallComplete: Set when the client is expected to call our
    //     call manager's IncomingCallComplete handler.  This guards against
    //     NDPROXY double completing calls which it has been known to do.
    // VCBF_WaitCloseCall: Set when the client is expected to call our call
    //     manager's CloseCall handler.  This is strictly a debug aid.
    //
    ULONG ulFlags;
        #define VCBF_IndicateTimeReceived  0x00000001
        #define VCBF_CallClosableByClient  0x00000002
        #define VCBF_CallClosableByPeer    0x00000004
        #define VCBF_DefaultLcParams       0x00000008
        #define VCBF_IncomingFsm           0x00000010
        #define VCBF_PeerInitiatedCall     0x00000020
        #define VCBF_Sequencing            0x00000040
        #define VCBF_VcCreated             0x00000100
        #define VCBF_VcActivated           0x00000200
        #define VCBF_VcDispatched          0x00000400
        #define VCBM_VcState               0x00000700
        #define VCBF_PeerOpenPending       0x00001000
        #define VCBF_ClientOpenPending     0x00002000
        #define VCBF_PeerClosePending      0x00004000
        #define VCBF_ClientClosePending    0x00008000
        #define VCBM_Pending               0x0000F000
        #define VCBF_VcDeleted             0x00010000
        #define VCBF_ClientCloseCompletion 0x00020000
        #define VCBF_IcsAlloc              0x00040000
        #define VCBF_IcsGrace              0x00080000
        #define VCBF_WaitInCallComplete    0x00100000
        #define VCBF_WaitCloseCall         0x00200000

    // Reference count on the active call.  Fields in this CALL SETUP section
    // and in the CALL STATISTICS section should not be accessed without a
    // call reference while the VC is activated.  References may only be added
    // when the VCCB_VcActivated flag is set, and this is enforced by
    // ReferenceCall.  The reference pairs are:
    //
    // (a) A reference is added when a VC is activated and removed when it is
    //     de-activated.
    //
    // (b) A reference is added when the send handler accepts a packet.  For
    //     unsequenced sends the reference is removed by the send complete
    //     routine.  For sequenced sends it it removed when the PAYLOADSENT
    //     context is destroyed.
    //
    // (c) A reference is added before scheduling a ZLB send and removed by
    //     the send completion routine.
    //
    // (d) A reference is added before entering ReceivePayload and removed on
    //     exit from same.
    //
    // (e) A reference is added before dispatching the call that is removed
    //     when the dispatch is completed.
    //
    // The field is accessed only by the ReferenceCall and DereferenceCall
    // routines, which protect the field with 'lockCall'.
    //
    LONG lCallRef;
    NDIS_SPIN_LOCK lockCall;

    // The current state of the VCs call creation, i.e. the control channel's
    // data channel setup for this VC.  Access is protected by 'lockV' once
    // the VC is set up to receive call control messages.
    //
    L2TPCALLSTATE state;

    // Links to the prev/next VCCB in the owning tunnel's requesting VC list
    // VC list.  Access is protected by 'TUNNELCB.lockT'.
    //
    LIST_ENTRY linkRequestingVcs;

    // Links to the prev/next VCCB in the owning tunnel's completing VC list.
    // Access is protected by 'TUNNELCB.lockT'.
    //
    LIST_ENTRY linkCompletingVcs;

    // This is set to the pending peer open/close or client open operation
    // result to be reported to client.
    //
    NDIS_STATUS status;

    // The received call setup message context.  When peer initiates a call,
    // we must create a VC and dispatch the incoming call to the client above.
    // This is an asynchronous operation that must occur right in the middle
    // of receive processing.  This context stores information about the
    // received message so it can be processed when it is known if client will
    // accept the call.  It also includes the CO_CALL_PARAMETERS buffer
    // dispatched to client on incoming calls.  The field is valid only until
    // LcmCmIncomingCallComplete handler is called, at which time it is set to
    // NULL.
    //
    // Shortcut addresses of the TAPI call info passed up in the
    // NdisMCmDispatchIncomingCall.  Obviously, they are valid only when
    // 'pInCall' is valid.  When invalid they are set to NULL.
    //
    INCALLSETUP* pInCall;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED * pTiParams;
    LINE_CALL_INFO* pTcInfo;

    // Reference count on the 'pInCall' context.  The reference pairs are:
    //
    // (a) A reference is added when the context is allocated and removed
    //     by CallSetupComplete.
    //
    // (b) A reference is added before passing addresses within the context to
    //     ReceiveControlExpected and removed after that routine returns.
    //
    // The field is accessed only by the ReferenceIcs and DereferenceIcs
    // routines, which protect with Interlocked routines.  An exception is
    // initializion to 1 by SetupVcAsynchronously.
    //
    LONG lInCallRef;

    // Address of the call parameters passed down in CmMakeCall.  This field
    // will only be valid until the NdisMCmMakeCallComplete notification for
    // the associated call is made, at which time it is reset to NULL.  Access
    // is via Interlocked routines.
    //
    // Shortcut addresses of the TAPI call parameters (both levels) and the
    // L2TP-specific call parameters in the 'pMakeCall' buffer.  Obviously,
    // they are valid only when 'pMakeCall' is valid.  When invalid they are
    // set to NULL.
    //
    CO_CALL_PARAMETERS* pMakeCall;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;
    LINE_CALL_PARAMS* pTcParams;

    // Shortcut address of the L2TP-specific call parameters in the
    // 'pMakeCall' or 'pInCall' buffer.  Obviously, this is only valid when
    // 'pMakeCall' or 'pInCall' is non-NULL.  When invalid this is NULL.  On
    // MakeCall, caller may not provide 'pLcParams' in which case one is
    // allocated and initialized to defaults for the convenience of the rest
    // of the code.  This temporary buffer is not reported to caller on
    // MakeCallComplete.
    //
    L2TP_CALL_PARAMETERS* pLcParams;

    // The result and error to report in the coming incoming/outgoing call
    // reply message.
    //
    USHORT usResult;
    USHORT usError;

    // The connect speed in bits/second.  This is the transmit speed value
    // reported by the peer LAC, or the value we reported to the peer LNS and
    // to NDISWAN.  Since we have no real knowledge of connect speed, we
    // report the minimum of the maximum rate acceptable to peer and
    // L2TP_LanBps.
    //
    ULONG ulConnectBps;

    // SEND STATE ------------------------------------------------------------

    // Next Sent, the sequence number of next payload packet transmitted on
    // this call.  The field is initialized to 0 and incremented after
    // assignment to an outgoing packet, excepting retransmissions.  Access is
    // protected by 'lockV'.
    //
    USHORT usNs;

    // Double-linked list of outstanding sends, i.e. PAYLOADSENTs sorted by
    // the 'usNs' field with lower values near the head.  Access is protected
    // by 'lockV'.
    //
    LIST_ENTRY listSendsOut;

    // The number of sent but unacknowledged packets that may be outstanding.
    // This value is adjusted dynamically.  Per the draft/RFC, when
    // 'ulAcksSinceSendTimeout' reaches the current setting, the window is
    // increased by one.  When a send timeout expires the window is reduced by
    // half.  The actual send window throttling is done by NDISWAN, based on
    // our indications of the changing window size.  Access is protected by
    // 'lockV'.
    //
    ULONG ulSendWindow;

    // The maximum value of 'ulSendWindow'.  Peer chooses this value during
    // call setup.
    //
    ULONG ulMaxSendWindow;

    // The number of packets acknowledged since the last timeout.  The value
    // is reset when a timeout occurs or the send window is adjusted upward.
    // See 'ulSendWindow'.  Access is protected by 'lockV'.
    //
    ULONG ulAcksSinceSendTimeout;

    // The estimated round trip time in milliseconds.  This is the RTT value
    // from Appendix A of the draft/RFC.  The value is adjusted as each
    // acknowledge is received.  It is initialized to the Packet Processing
    // Delay reported by peer.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    ULONG ulRoundTripMs;

    // The estimated mean deviation in milliseconds, an approximation of the
    // standard deviation.  This is the DEV value from Appendix A of the
    // draft/RFC.  The value is adjusted as each acknowledge is received.  It
    // is initially 0.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    LONG lDeviationMs;

    // Milliseconds before it is assumed a sent packet will never be
    // acknowledged.  This is the ATO value from Appendix A of the draft/RFC.
    // This value is adjusted as each acknowledge is received, with a maximum
    // of 'ADAPTERCB.ulMaxSendTimeoutMs'.  Access is protected by 'lockV'.
    //
    ULONG ulSendTimeoutMs;

    // The timer event descriptor scheduled to occur when it is time to stop
    // waiting for an outgoing send on which to piggyback an acknowledge.
    // This will be NULL when no delayed acknowledge is pending.  Per the
    // draft/RFC, the timeout used is 1/4 of the 'ulSendTimeoutMs'.  Access is
    // protected by 'lockV'.
    //
    TIMERQITEM* pTqiDelayedAck;


    // RECEIVE STATE ---------------------------------------------------------

    // Next Received, the sequence number one higher than that of the last
    // payload packet received on this call or 0 if none.  Access is protected
    // by 'lockV'.
    //
    USHORT usNr;

    // Double-linked list of out-of-order receives, i.e. PAYLOADRECEIVEs
    // sorted by the 'usNs' field with lower values near the head.  The
    // maximum queue length is 'ADAPTERCB.sMaxOutOfOrder'.  Access is
    // protected by 'lockV'.
    //
    LIST_ENTRY listOutOfOrder;


    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this VC passed to us in MiniportCoCreateVcHandler.
    // This is passed back to NDIS in various NdisXxx calls.
    //
    NDIS_HANDLE NdisVcHandle;

    // Configuration settings returned to callers on OID_WAN_CO_GET_INFO and
    // modified by callers on OID_WAN_CO_SET_INFO.  Older NDISWAN references to
    // "LINK" map straight to "VC" in the NDIS 5.0 world.  Access is not
    // protected because each ULONG in the structure is independent so no
    // incoherency can result from multiple access.
    //
    NDIS_WAN_CO_GET_LINK_INFO linkinfo;


    // STATISTICS ------------------------------------------------------------

    // Statistics for the current call.  Access is protected by 'lockV'.
    //
    CALLSTATS stats;
}
VCCB;


// The "exploded" description of an L2TP header, as output by
// ExplodeL2tpHeader.
//
typedef struct
_L2TPHEADERINFO
{
    // Addresses of header fields.  Some may be NULL indicating the field was
    // not present in the header.
    //
    USHORT* pusBits;
    USHORT* pusLength;
    USHORT* pusTunnelId;
    USHORT* pusCallId;
    USHORT* pusNs;
    USHORT* pusNr;

    // Length of the variable length header in bytes.
    //
    ULONG ulHeaderLength;

    // Address and length in bytes of the data following the variable length
    // header.
    //
    CHAR* pData;
    ULONG ulDataLength;
}
L2TPHEADERINFO;


// The "exploded" description of an Attribute/Value Pair (AVP), as output by
// ExplodeAvpHeader.  The "value" is located and sized but not interpreted or
// byte-ordered until a GetAvpValueXxx routine is applied.
//
typedef struct
_AVPINFO
{
    // Addresses of header fields.  All are always present.
    //
    UNALIGNED USHORT* pusBits;
    UNALIGNED USHORT* pusVendorId;
    UNALIGNED USHORT* pusAttribute;

    // The length of the entire AVP, extracted from '*pusBits'.
    //
    USHORT usOverallLength;

    // Length of the value in bytes and the address of the value.
    //
    USHORT usValueLength;
    CHAR* pValue;
}
AVPINFO;


// The "exploded" description of a control message, as output by
// ExplodeControlAvps.
//
typedef struct
_CONTROLMSGINFO
{
    // GERR_* code indicating the result of the ExplodeControlAvps operation.
    // Other fields should not be referenced unless this is GERR_None.
    //
    USHORT usXError;

    // True when the message is a tunnel setup message, false if it is a call
    // setup message.
    //
    BOOLEAN fTunnelMsg;

    // Address of message type AVP value.  The message type AVP is present in
    // all valid control messages.
    //
    UNALIGNED USHORT* pusMsgType;

    // Addresses of additional AVP values.  These may be NULL indicating the
    // AVP was not found in the message.  The length field following variable
    // length fields is valid whenever the value address is non-NULL.
    //
    USHORT* pusResult;
    USHORT* pusError;
    CHAR* pchResultMsg;
    USHORT usResultMsgLength;
    UNALIGNED USHORT* pusProtocolVersion;
    UNALIGNED ULONG* pulFramingCaps;
    UNALIGNED ULONG* pulBearerCaps;
    CHAR* pchTieBreaker;
    CHAR* pchHostName;
    USHORT usHostNameLength;
    UNALIGNED USHORT* pusAssignedTunnelId;
    UNALIGNED USHORT* pusRWindowSize;
    UNALIGNED USHORT* pusAssignedCallId;
    UNALIGNED ULONG* pulCallSerialNumber;
    UNALIGNED ULONG* pulMinimumBps;
    UNALIGNED ULONG* pulMaximumBps;
    UNALIGNED ULONG* pulBearerType;
    UNALIGNED ULONG* pulFramingType;
    UNALIGNED USHORT* pusPacketProcDelay;
    CHAR* pchDialedNumber;
    USHORT usDialedNumberLength;
    CHAR* pchDialingNumber;
    USHORT usDialingNumberLength;
    UNALIGNED ULONG* pulTxConnectSpeed;
    UNALIGNED ULONG* pulPhysicalChannelId;
    CHAR* pchSubAddress;
    USHORT usSubAddressLength;
    CHAR* pchChallenge;
    USHORT usChallengeLength;
    CHAR* pchResponse;
    UNALIGNED USHORT* pusProxyAuthType;
    CHAR* pchProxyAuthResponse;
    USHORT usProxyAuthResponseLength;
    UNALIGNED ULONG* pulCallErrors;
    UNALIGNED ULONG* pulAccm;
    BOOLEAN fSequencingRequired;
}
CONTROLMSGINFO;


// Context for a control packet received out of order which is queued rather
// than discarding in the hope that the missing packet will arrive.
//
typedef struct
_CONTROLRECEIVED
{
    // Link to the prev/next link in the 'TUNNELCB.listOutOfOrder' list.
    //
    LIST_ENTRY linkOutOfOrder;

    // 'Next Sent' sequence number received in the packet.
    //
    USHORT usNs;

    // Associated VC or NULL if none.
    //
    VCCB* pVc;

    // The received GetBufferFromPool buffer.
    //
    CHAR* pBuffer;

    // The "exploded" description of the control message.
    //
    CONTROLMSGINFO control;
}
CONTROLRECEIVED;


// Context for a control packet sent but not yet acknowledged.  This block is
// queued on the 'TUNNELCB.listSendsOut' and 'TUNNELCB.listSendsPending'
// lists, and is associated with SendControlTimerEvents.
//
typedef struct
_CONTROLSENT
{
    // Link to the prev/next link in the 'TUNNELCB.listSendsOut' list.
    //
    LIST_ENTRY linkSendsOut;

    // Reference count on this context.  The reference pairs are:
    //
    // (a) A reference is added when the context is queued into the
    //     'listSendsOut' list, and removed by the de-queuer.
    //
    // (b) A reference is added before sending (and also before
    //     'pTqiSendTimeout' is scheduled) and is removed by the send
    //     completion routine.
    //
    // (c) A reference is added before 'pTqiSendTimeout' is scheduled and
    //     removed as the timer event handler exits.
    //
    LONG lRef;

    // 'Next Sent' sequence number sent with the packet.
    //
    USHORT usNs;

    // The message type of the packet.  (debug use only)
    //
    USHORT usMsgType;

    // Timer event descriptor scheduled for the packet.
    //
    TIMERQITEM* pTqiSendTimeout;

    // Number of times the packet has been retransmitted.
    //
    ULONG ulRetransmits;

    // CSF_* flags indicating various options.
    //
    // CSF_Pending: Set when transmission or retransmission of the packet is
    //     pending.  Access is protected by 'pTunnel->lockT'.
    //
    // CSF_TunnelIdleOnAck:  Set when TunnelTransitionComplete is to be
    //     executed when the message is acknowledged, moving to CCS_Idle
    //     state.
    //
    // CSF_CallIdleOnAck:  Set when CallTransitionComplete is to be executed
    //     when the message is acknowledged, moving to CS_Idle state.
    //
    ULONG ulFlags;
        #define CSF_Pending          0x00000001
        #define CSF_TunnelIdleOnAck  0x00000010
        #define CSF_CallIdleOnAck    0x00000020
        #define CSF_QueryMediaSpeed  0x00000040   

    // The outstanding packet's buffer, as passed to TDI.
    //
    CHAR* pBuffer;

    // The length of the data to send in 'pBuffer'.
    //
    ULONG ulBufferLength;

    // Back pointer to owning tunnel.
    //
    TUNNELCB* pTunnel;

    // Back pointer to owning VC, or NULL if none.
    //
    VCCB* pVc;

    // The NDIS system time at which the packet was originally sent.
    //
    LONGLONG llTimeSent;

    // The IRP passed to TDI by the TDIX extension library, or NULL if none or
    // it's already been completed.  (for debug purposes only)
    //
    IRP* pIrp;
}
CONTROLSENT;


// Context for a payload packet received out of order which is queued for a
// time rather than discarding in the hope that the missing packet will
// arrive.
//
typedef struct
_PAYLOADRECEIVED
{
    // Link to the prev/next link in the 'VCCB.listOutOfOrder' list.
    //
    LIST_ENTRY linkOutOfOrder;

    // 'Next Sent' sequence number received in the packet.
    //
    USHORT usNs;

    // The received GetBufferFromPool buffer.
    //
    CHAR* pBuffer;

    // Offset of the payload to indicate received in 'pBuffer'.
    //
    ULONG ulPayloadOffset;

    // Length in bytes of the payload to indicate received in 'pBuffer'.
    //
    ULONG ulPayloadLength;

    // NDIS time the packet was received from the net, or 0 if caller did not
    // choose the RECEIVE_TIME_INDICATION option in his call parameters.
    //
    LONGLONG llTimeReceived;
}
PAYLOADRECEIVED;


// Context for a payload packet sent but not yet acknowledged.  This block is
// queued on the 'VCCB.listSendsOut', and is associated with
// SendPayloadTimerEvents.
//
typedef struct
_PAYLOADSENT
{
    // Link to the prev/next link in the 'VCCB.listSendsOut' list.
    //
    LIST_ENTRY linkSendsOut;

    // Link to the prev/next link in the 'g_listDebugPs' list.  The list is
    // maintained only when PSDEBUG is defined, but this is included always
    // for the convenience of KD extension users.  (for debug purposes only)
    //
    LIST_ENTRY linkDebugPs;

    // Reference count on this context.  The reference pairs are:
    //
    // (a) A reference is added when the context is queued into the
    //     'listSendsOut' list, and removed by the de-queuer.
    //
    // (b) A reference is added before sending (and also before the time is
    //     scheduled) and removed by the send completion routine.
    //
    // (c) A reference is added before scheduling the timer and removed by the
    //     timer event handler.
    //
    LONG lRef;

    // 'Next Sent' sequence number sent with the packet.
    //
    USHORT usNs;

    // Timer event descriptor scheduled to fire when it's time to give up on
    // receiving an acknowledge of the packet.
    //
    TIMERQITEM* pTqiSendTimeout;

    // The built NDIS packet.
    //
    NDIS_PACKET* pPacket;

    // The L2TP header buffer prepended to the payload buffer.
    //
    CHAR* pBuffer;

    // Back pointer to the owning tunnel control block.
    //
    TUNNELCB* pTunnel;

    // Back pointer to the owning VC control block.
    //
    VCCB* pVc;

    // Status of the completed packet.
    //
    NDIS_STATUS status;

    // The NDIS system time at which the packet was originally sent.
    //
    LONGLONG llTimeSent;

    // The IRP passed to TDI by the TDIX extension library, or NULL if none or
    // it's already been completed.  (for debug purposes only)
    //
    IRP* pIrp;
}
PAYLOADSENT;


// Tunnel work handler that executes tunnel related work at PASSIVE IRQL.
// 'PWork' is the work context that should be freed with FREE_TUNNELWORK when
// the handler is done accessing the 'punpArgs' array.  'PTunnel' is the
// owning tunnel.  'PVc' is the owning VC, or NULL if none.  'PunpArgs' is an
// array of 4 auxillary arguments as passed to ScheduleTunnelWork.
//
typedef
VOID
(*PTUNNELWORK)(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );


// Tunnel work item describing a single unit of tunnel related work to be
// executed serially at PASSIVE IRQL by the TunnelWork mechanism.
//
typedef struct
_TUNNELWORK
{
    // Link to the prev/next link in the 'TUNNELCB.listWork' queue.
    //
    LIST_ENTRY linkWork;

    // Handler that executes this work item.
    //
    PTUNNELWORK pHandler;

    // The associated VC, if any.
    //
    VCCB* pVc;

    // Auxillary arguments passed to handler.
    //
    ULONG_PTR aunpArgs[ 4 ];
}
TUNNELWORK;


// Context of call setup for an incoming call.  The information is used to
// store and later resume receive processing of an peer's call initiation
// across the asynchronous CoNdis calls, and for building the call parameter
// buffer to dispatch to client.
//
typedef struct
_INCALLSETUP
{
    // See ReceiveControl for descriptions.
    //
    CHAR* pBuffer;
    L2TPHEADERINFO info;
    CONTROLMSGINFO control;

    // Buffer in which the incoming call parameters to be dispatched to caller
    // are built.
    //
    PVOID pvDummyPointerAligner;
    
    CHAR achCallParams[ sizeof(CO_CALL_PARAMETERS)

                        + sizeof(PVOID)
                        + sizeof(CO_CALL_MANAGER_PARAMETERS)

                        + sizeof(PVOID)
                        + sizeof(CO_MEDIA_PARAMETERS)
                        + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)

                        + sizeof(PVOID)
                        + sizeof(LINE_CALL_INFO)

                        + sizeof(PVOID)
                        + sizeof(L2TP_CALL_PARAMETERS)

                        + ((L2TP_MaxDottedIpLen + 1) * sizeof(WCHAR)) ];
}
INCALLSETUP;


// The L2TP role played by an L2TP peer.  The values may be read from the
// registry, so don't change randomly.
//
typedef enum
_L2TPROLE
{
    LR_Lns = 1,
    LR_Lac = 2
}
L2TPROLE;


// The strategy employed when it is time to add a host route and that route is
// found to already exists.
//
// Note: The values currently match the those of the registry parameter
//       "UseExistingRoutes".  Check GetRegistrySettings code before changing.
//
typedef enum
_HOSTROUTEEXISTS
{
    HRE_Use = 0,
    HRE_Fail = 1,
    HRE_Reference = 2
}
HOSTROUTEEXISTS;


// Link status block for transfer across locks.  See TransferLinkStatusInfo
// and IndicateLinkStatus.
//
typedef struct
_LINKSTATUSINFO
{
    NDIS_HANDLE MiniportAdapterHandle;
    NDIS_HANDLE NdisVcHandle;
    WAN_CO_LINKPARAMS params;
}
LINKSTATUSINFO;


//-----------------------------------------------------------------------------
// Macros/inlines
//-----------------------------------------------------------------------------

#define CtrlObjFromUdpContext(_x) \
    (_x)->pCtrlAddr
    
#define PayloadObjFromUdpContext(_x) \
    (_x)->pPayloadAddr
    
// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

// Pad to the size of the given datatype.  (Borrowed from wdm.h which is not
// otherwise needed)
//
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

// Place in a TRACE argument list to correspond with a format of "%d.%d.%d.%d"
// to print network byte-ordered IP address 'x' in human readable form.
//
#define IPADDRTRACE( x ) ((x) & 0x000000FF),         \
                         (((x) >> 8) & 0x000000FF),  \
                         (((x) >> 16) & 0x000000FF), \
                         (((x) >> 24) & 0x000000FF)

// Place in a TRACE argument list to correspond with a format of "%d" to print
// a percentage of two integers, or an average of two integers, or those
// values rounded.
//
#define PCTTRACE( n, d ) ((d) ? (((n) * 100) / (d)) : 0)
#define AVGTRACE( t, c ) ((c) ? ((t) / (c)) : 0)
#define PCTRNDTRACE( n, d ) ((d) ? (((((n) * 1000) / (d)) + 5) / 10) : 0)
#define AVGRNDTRACE( t, c ) ((c) ? (((((t) * 10) / (c)) + 5) / 10) : 0)

// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = 0xC0BBC0DE;
    return pBuf + MEMORY_ALLOCATION_ALIGNMENT;
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_NDIS_WORK_ITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistWorkItems )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistWorkItems, (pNwi) )

#define ALLOC_TIMERQITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTimerQItems )
#define FREE_TIMERQITEM( pA, pTqi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTimerQItems, (pTqi) )

#define ALLOC_CONTROLSENT( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistControlSents )
#define FREE_CONTROLSENT( pA, pCs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistControlSents, (pCs) )

#define ALLOC_PAYLOADSENT( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistPayloadSents )
#define FREE_PAYLOADSENT( pA, pPs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistPayloadSents, (pPs) )

#define ALLOC_TUNNELWORK( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTunnelWorks )
#define FREE_TUNNELWORK( pA, pCs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTunnelWorks, (pCs) )

#if LLISTALL

#define ALLOC_TUNNELCB( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTunnels )
#define FREE_TUNNELCB( pA, pT ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTunnels, (pT) )

#define ALLOC_VCCB( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistVcs )
#define FREE_VCCB( pA, pV ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistVcs, (pV) )

#define ALLOC_TIMERQ( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTimerQs )
#define FREE_TIMERQ( pA, pTq ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTimerQs, (pTq) )

#define ALLOC_CONTROLRECEIVED( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistControlReceiveds )
#define FREE_CONTROLRECEIVED( pA, pCr ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistControlReceiveds, (pCr) )

#define ALLOC_PAYLOADRECEIVED( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistPayloadReceiveds )
#define FREE_PAYLOADRECEIVED( pA, pPr ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistPayloadReceiveds, (pPr) )

#define ALLOC_INCALLSETUP( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistInCallSetups )
#define FREE_INCALLSETUP( pA, pCs ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistInCallSetups, (pCs) )

#else // !LLISTALL

#define ALLOC_TUNNELCB( pA ) \
    ALLOC_NONPAGED( sizeof(TUNNELCB), MTAG_TUNNELCB )
#define FREE_TUNNELCB( pA, pT ) \
    FREE_NONPAGED( pT )

#define ALLOC_VCCB( pA ) \
    ALLOC_NONPAGED( sizeof(VCCB), MTAG_VCCB )
#define FREE_VCCB( pA, pV ) \
    FREE_NONPAGED( pV )

#define ALLOC_TIMERQ( pA ) \
    ALLOC_NONPAGED( sizeof(TIMERQ), MTAG_TIMERQ )
#define FREE_TIMERQ( pA, pTq ) \
    FREE_NONPAGED( pTq )

#define ALLOC_CONTROLRECEIVED( pA ) \
    ALLOC_NONPAGED( sizeof(CONTROLRECEIVED), MTAG_CTRLRECD )
#define FREE_CONTROLRECEIVED( pA, pCr ) \
    FREE_NONPAGED( pCr )

#define ALLOC_PAYLOADRECEIVED( pA ) \
    ALLOC_NONPAGED( sizeof(PAYLOADRECEIVED), MTAG_PAYLRECD )
#define FREE_PAYLOADRECEIVED( pA, pPr ) \
    FREE_NONPAGED( pPr )

#define ALLOC_INCALLSETUP( pA ) \
    ALLOC_NONPAGED( sizeof(INCALLSETUP), MTAG_INCALL )
#define FREE_INCALLSETUP( pA, pCs ) \
    FREE_NONPAGED( pCs )

#define ALLOC_CONTROLMSGINFO( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistControlMsgInfos )
#define FREE_CONTROLMSGINFO( pA, pCmi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistControlMsgInfos, (pCmi) )

#endif // !LLISTALL

#if READFLAGSDIRECT

#define ReadFlags( pulFlags ) \
    (*pulFlags)

#endif


//-----------------------------------------------------------------------------
// Prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
ActivateCallIdSlot(
    IN VCCB* pVc );

VOID
AddHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

BOOLEAN
AdjustSendWindowAtAckReceived(
    IN ULONG ulMaxSendWindow,
    IN OUT ULONG* pulAcksSinceSendTimeout,
    IN OUT ULONG* pulSendWindow );

VOID
AdjustTimeoutsAtAckReceived(
    IN LONGLONG llSendTime,
    IN ULONG ulMaxSendTimeoutMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT LONG* plDeviationMs );

VOID
AdjustTimeoutsAndSendWindowAtTimeout(
    IN ULONG ulMaxSendTimeoutMs,
    IN LONG lDeviationMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT ULONG* pulSendWindow,
    OUT ULONG* pulAcksSinceSendTimeout );

#if 0
VOID
BuildWanAddress(
    IN CHAR* pArg1,
    IN ULONG ulLength1,
    IN CHAR* pArg2,
    IN ULONG ulLength2,
    IN CHAR* pArg3,
    IN ULONG ulLength3,
    OUT WAN_ADDRESS* pWanAddress );
#endif

VOID
CalculateResponse(
    IN UCHAR* puchChallenge,
    IN ULONG ulChallengeLength,
    IN CHAR* pszPassword,
    IN UCHAR uchId,
    OUT UCHAR* puchResponse );

VOID
CallCleanUp(
    IN VCCB* pVc );

VOID
CallTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN L2TPCALLSTATE state );

VOID
ChangeHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
CloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

BOOLEAN
CloseCall2(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usResult,
    IN USHORT usError );

VOID
CloseTdix(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
CloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
CloseTunnel2(
    IN TUNNELCB* pTunnel );

VOID
CompleteVcs(
    IN TUNNELCB* pTunnel );

VOID
DeleteHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceCall(
    IN VCCB* pVc );

LONG
DereferenceControlSent(
    IN CONTROLSENT* pSent );

LONG
DereferencePayloadSent(
    IN PAYLOADSENT* pPs );

VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter );

LONG
DereferenceTunnel(
    IN TUNNELCB* pTunnel );

VOID
DereferenceVc(
    IN VCCB* pVc );

VOID
DottedFromIpAddress(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress,
    IN BOOLEAN fUnicode );

NDIS_STATUS
ExecuteWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN ULONG ulArg3,
    IN ULONG ulArg4 );

#if 0
VOID
ExplodeWanAddress(
    IN WAN_ADDRESS* pWanAddress,
    OUT CHAR** ppArg1,
    OUT ULONG* pulLength1,
    OUT CHAR** ppArg2,
    OUT ULONG* pulLength2,
    OUT CHAR** ppArg3,
    OUT ULONG* pulLength3 );
#endif

VOID
FsmCloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
FsmCloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
FsmOpenCall(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VOID
FsmOpenTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
FsmOpenIdleTunnel(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

BOOLEAN
FsmReceive(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl );

CHAR*
GetFullHostNameFromRegistry(
    VOID );

USHORT
GetNextTerminationCallId(
    IN ADAPTERCB* pAdapter );

USHORT
GetNextTunnelId(
    IN ADAPTERCB* pAdapter );

VOID
IndicateLinkStatus(
    IN VCCB* pVc,
    IN LINKSTATUSINFO* pInfo );

ULONG
IpAddressFromDotted(
    IN CHAR* pchIpAddress );

NDIS_STATUS
LcmCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
LcmCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
LcmCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext );

NDIS_STATUS
LcmCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext );

#ifndef OLDMCM

NDIS_STATUS
LcmCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext );

NDIS_STATUS
LcmCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext );

#endif // !OLDMCM

NDIS_STATUS
LcmCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext );

NDIS_STATUS
LcmCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size );

VOID
LcmCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
LcmCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
LcmCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext );

NDIS_STATUS
LcmCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
LcmCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest );

NDIS_STATUS
LmpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext );

VOID
LmpHalt(
    IN NDIS_HANDLE MiniportAdapterContext );

NDIS_STATUS
LmpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext );

VOID
LmpReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet );

NDIS_STATUS
LmpQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
LmpSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );

#ifdef OLDMCM

NDIS_STATUS
LmpCoCreateVc(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE NdisVcHandle,
    IN PNDIS_HANDLE MiniportVcContext );

NDIS_STATUS
LmpCoDeleteVc(
    IN NDIS_HANDLE MiniportVcContext );

#endif // OLDMCM

NDIS_STATUS
LmpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
LmpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext );

VOID
LmpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets );

NDIS_STATUS
LmpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest );

VOID
L2tpReceive(
    IN TDIXCONTEXT* pTdix,
    IN TDIXRDGINFO* pRdg,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLen );

CHAR*
MsgTypePszFromUs(
    IN USHORT usMsgType );

#if READFLAGSDIRECT == 0
ULONG
ReadFlags(
    IN ULONG* pulFlags );
#endif

BOOLEAN
ReceiveControlExpected(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl );

VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter );

BOOLEAN
ReferenceCall(
    IN VCCB* pVc );

VOID
ReferenceControlSent(
    IN CONTROLSENT* pSent );

VOID
ReferencePayloadSent(
    IN PAYLOADSENT* pPs );

BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter );

LONG
ReferenceTunnel(
    IN TUNNELCB* pTunnel,
    IN BOOLEAN fHaveLockTunnels );

VOID
ReferenceVc(
    IN VCCB* pVc );

BOOLEAN
ReleaseCallIdSlot(
    IN VCCB* pVc );

NDIS_STATUS
ReserveCallIdSlot(
    IN VCCB* pVc );

VOID
ResetHelloTimer(
    IN TUNNELCB* pTunnel );

VOID
ScheduleTunnelWork(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN PTUNNELWORK pHandler,
    IN ULONG_PTR unpArg0,
    IN ULONG_PTR unpArg1,
    IN ULONG_PTR unpArg2,
    IN ULONG_PTR unpArg3,
    IN BOOLEAN fTcbPreReferenced,
    IN BOOLEAN fHighPriority );

NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext );

VOID
SendControlAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendControl(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usMsgType,
    IN ULONG ulBuildAvpsArg1,
    IN ULONG ulBuildAvpsArg2,
    IN PVOID pvBuildAvpsArg3,
    IN ULONG ulFlags );

VOID
SendControlTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

VOID
SendPayload(
    IN VCCB* pVc,
    IN NDIS_PACKET* pPacket );

VOID
SendPayloadAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendPending(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

TUNNELCB*
SetupTunnel(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usAssignedTunnelId,
    IN BOOLEAN fExclusive );

VOID
SetupVcAsynchronously(
    IN TUNNELCB* pTunnel,
    IN ULONG ulIpAddress,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl );

VOID
StrCpyW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 );

CHAR*
StrDup(
    IN CHAR* psz );

WCHAR*
StrDupAsciiToUnicode(
    IN CHAR* psz,
    IN ULONG ulPszBytes );

WCHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString );

CHAR*
StrDupNdisVarDataDescStringA(
    IN NDIS_VAR_DATA_DESC* pDesc );

CHAR*
StrDupNdisVarDataDescStringToA(
    IN NDIS_VAR_DATA_DESC UNALIGNED* pDesc );

CHAR*
StrDupNdisStringToA(
    IN NDIS_STRING* pNdisString );

CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra );

CHAR*
StrDupUnicodeToAscii(
    IN WCHAR* pwsz,
    IN ULONG ulPwszBytes );

ULONG
StrLenW(
    IN WCHAR* psz );

VOID
TransferLinkStatusInfo(
    IN VCCB* pVc,
    OUT LINKSTATUSINFO* pInfo );

TUNNELCB*
TunnelCbFromIpAddressAndAssignedTunnelId(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usAssignedTunnelId );

VOID
TunnelTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN L2TPCCSTATE state );

VOID
UpdateGlobalCallStats(
    IN VCCB* pVc );

VCCB*
VcCbFromCallId(
    IN TUNNELCB* pTunnel,
    IN USHORT usCallId );


#endif // _L2TPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\l2tprfc.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// l2tprfc.h
// RAS L2TP WAN mini-port/call-manager driver
// L2TP RFC header
//
// 01/07/97 Steve Cobb
//
// This header contains definitions from the L2TP draft/RFC, currently
// draft-12.
//


#ifndef _L2TPRFC_H_
#define _L2TPRFC_H_


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The UDP port at which L2TP messages will arrive.
//
#define L2TP_UdpPort 1701

// The IP protocol number on which messages will arrive.  (No number has been
// assigned so this is a placeholder for now)
//
#define L2TP_IpProtocol 254

// The standard value for the Hello timer in milliseconds.
//
#define L2TP_HelloMs 60000

// The maximum number of bytes in a frame excluding all L2TP and PPP HDLC-ish
// framing overhead.
//
#define L2TP_MaxFrameSize 1500

// Maximum number of bytes in an L2TP control or payload header.
//
#define L2TP_MaxHeaderSize 14

// The maximum number of bytes in the L2TP payload packet header including
// padding.  The 14 represents all possible fields defined in the RFC.  The
// "+8" represents allowance for up to 8 bytes of padding to be specified in
// the header.  While there is theoretically no limit to the padding, there is
// no discussion in the L2TP forum indicating interest in more than 8 bytes.
//
#define L2TP_MaxPayloadHeader (14 + 8)

// The default packet processing delay in 1/10 second, i.e. 1/2 second.
//
#define L2TP_LnsDefaultPpd 5

// The default control send timeout in milliseconds, i.e. 1 second.
//
#define L2TP_DefaultSendTimeoutMs 1000

// The default control/payload piggybacking acknowledge delay in milliseconds.
//
#define L2TP_MaxAckDelay 500

// The implicit receive window offered control channels where no Receive
// Window AVP is provided.
//
#define L2TP_DefaultReceiveWindow 4

// Highest L2TP protocol version we support.
//
#define L2TP_ProtocolVersion 0x0100

// Default maximum send timeout in milliseconds.  The draft only says the cap
// must be no less than 8 seconds, so 10 seconds is selected as reasonable and
// safe.
//
#define L2TP_DefaultMaxSendTimeoutMs 10000

// Default maximum retransmissions before assuming peer is unreachable.
//
#define L2TP_DefaultMaxRetransmits 5

// Size in bytes of the fixed portion of a control message attribute/value
// pair, i.e. the size of an AVP with zero length value.
//
#define L2TP_AvpHeaderSize 6

// L2TP protocol control message types.
//
#define CMT_SCCRQ    1   // Start-Control-Connection-Request
#define CMT_SCCRP    2   // Start-Control-Connection-Reply
#define CMT_SCCCN    3   // Start-Control-Connection-Connected
#define CMT_StopCCN  4   // Stop-Control-Connection-Notify
#define CMT_StopCCRP 5   // Stop-Control-Connection-Reply (obsolete)
#define CMT_Hello    6   // Hello, i.e. keep-alive
#define CMT_OCRQ     7   // Outgoing-Call-Request
#define CMT_OCRP     8   // Outgoing-Call-Reply
#define CMT_OCCN     9   // Outgoing-Call-Connected
#define CMT_ICRQ     10  // Incoming-Call-Request
#define CMT_ICRP     11  // Incoming-Call-Reply
#define CMT_ICCN     12  // Incoming-Call-Connected
#define CMT_CCRQ     13  // Call-Clear-Request (obsolete)
#define CMT_CDN      14  // Call-Disconnect-Notify
#define CMT_WEN      15  // WAN-Error-Notify
#define CMT_SLI      16  // Set-Link-Info

// L2TP Attribute codes.
//
#define ATTR_MsgType            0
#define ATTR_Result             1
#define ATTR_ProtocolVersion    2
#define ATTR_FramingCaps        3
#define ATTR_BearerCaps         4
#define ATTR_TieBreaker         5
#define ATTR_FirmwareRevision   6
#define ATTR_HostName           7
#define ATTR_VendorName         8
#define ATTR_AssignedTunnelId   9
#define ATTR_RWindowSize        10
#define ATTR_Challenge          11
#define ATTR_Q931Cause          12
#define ATTR_ChallengeResponse  13
#define ATTR_AssignedCallId     14
#define ATTR_CallSerialNumber   15
#define ATTR_MinimumBps         16
#define ATTR_MaximumBps         17
#define ATTR_BearerType         18
#define ATTR_FramingType        19
#define ATTR_PacketProcDelay    20
#define ATTR_DialedNumber       21
#define ATTR_DialingNumber      22
#define ATTR_SubAddress         23
#define ATTR_TxConnectSpeed     24
#define ATTR_PhysicalChannelId  25
#define ATTR_InitialLcpConfig   26
#define ATTR_LastSLcpConfig     27
#define ATTR_LastRLcpConfig     28
#define ATTR_ProxyAuthType      29
#define ATTR_ProxyAuthName      30
#define ATTR_ProxyAuthChallenge 31
#define ATTR_ProxyAuthId        32
#define ATTR_ProxyAuthResponse  33
#define ATTR_CallErrors         34
#define ATTR_Accm               35
#define ATTR_RandomVector       36
#define ATTR_PrivateGroupId     37
#define ATTR_RxConnectSpeed     38
#define ATTR_SequencingRequired 39

#define ATTR_MAX 39

// L2TP protocol general error codes.
//
#define GERR_None                0
#define GERR_NoControlConnection 1
#define GERR_BadLength           2
#define GERR_BadValue            3
#define GERR_NoResources         4
#define GERR_BadCallId           5
#define GERR_VendorSpecific      6
#define GERR_TryAnother          7

// Tunnel Result Code AVP values, used in StopCCN message.
//
#define TRESULT_General            1
#define TRESULT_GeneralWithError   2
#define TRESULT_CcExists           3
#define TRESULT_NotAuthorized      4
#define TRESULT_BadProtocolVersion 5
#define TRESULT_Shutdown           6
#define TRESULT_FsmError           7

// Call Result Code values, used in CDN message.
//
#define CRESULT_LostCarrier           1
#define CRESULT_GeneralWithError      2
#define CRESULT_Administrative        3
#define CRESULT_NoFacilitiesTemporary 4
#define CRESULT_NoFacilitiesPermanent 5
#define CRESULT_InvalidDestination    6
#define CRESULT_NoCarrier             7
#define CRESULT_Busy                  8
#define CRESULT_NoDialTone            9
#define CRESULT_Timeout               10
#define CRESULT_NoFraming             11

// L2TP header bitmasks for the first 2 bytes of every L2TP message.
//
#define HBM_T       0x8000 // Control packet
#define HBM_L       0x4000 // Length field present
#define HBM_R       0x2000 // Reset Sr
#define HBM_F       0x0800 // Nr/Ns fields present
#define HBM_S       0x0200 // Offset field present
#define HBM_P       0x0100 // Preferential treatment bit
#define HBM_Bits    0xFFFC // All bits, excluding protocol version field
#define HBM_Ver     0x0003 // Protocol version (L2TP or L2F)
#define HBM_Control 0xc800 // Fixed value of bits in control message

// The defined header bits version number field values.
//
#define VER_L2f  0x0000
#define VER_L2tp 0x0002

// AVP header bitmasks for the first 2 bytes of every Attribute Value Pair.
//
#define ABM_M             0x8000 // Mandatory
#define ABM_H             0x4000 // Hidden
#define ABM_Reserved      0x3C00 // Reserved bits, must be 0
#define ABM_OverallLength 0x03FF // AVP's length including value

// Bearer capabilties AVP bitmasks.
//
#define BBM_Analog  0x00000001
#define BBM_Digital 0x00000002

// Framing capabilities/type AVP bitmasks.
//
#define FBM_Sync  0x00000001
#define FBM_Async 0x00000002

// Proxy Authentication types.
//
#define PAT_Text 1
#define PAT_Chap 2
#define PAT_Pap  3
#define PAT_None 4


//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// The "Control Connection" state of a single L2TP tunnel.
//
typedef enum
_L2TPCCSTATE
{
    CCS_Idle = 0,
    CCS_WaitCtlReply,
    CCS_WaitCtlConnect,
    CCS_Established
}
L2TPCCSTATE;


// The "LNS/LAC Outgoing/Incoming Call" state of a single L2TP VC.  Only one
// of the 4 call creation FSMs can be running or Established on a single VC at
// once, so the states are combined in a single table.
//
typedef enum
_L2TPCALLSTATE
{
    CS_Idle = 0,
    CS_WaitTunnel,
    CS_WaitReply,
    CS_WaitConnect,
    CS_WaitDisconnect,
    CS_WaitCsAnswer,
    CS_Established
}
L2TPCALLSTATE;


#endif // _L2TPRFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;

#define MD5_LEN 16

#define PROTO_LIST(list)    list


void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\main.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// main.c
// RAS L2TP WAN mini-port/call-manager driver
// Main routine (DriverEntry) and global data definitions
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath );

// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )

    // Standard 'DriverEntry' driver initialization entrypoint called by the
    // I/0 system at IRQL PASSIVE_LEVEL before any other call to the driver.
    //
    // On NT, 'DriverObject' is the driver object created by the I/0 system
    // and 'RegistryPath' specifies where driver specific parameters are
    // stored.  These arguments are opaque to this driver (and should remain
    // so for portability) which only forwards them to the NDIS wrapper.
    //
    // Returns the value returned by NdisMRegisterMiniport, per the doc on
    // "DriverEntry of NDIS Miniport Drivers".
    //
{
    NDIS_STATUS status;
    NDIS_MINIPORT_CHARACTERISTICS nmc;
    NDIS_HANDLE NdisWrapperHandle;

    TRACE( TL_N, TM_Init, ( "DriverEntry" ) );

#ifdef TESTMODE
    DbgBreakPoint();
#endif

    // Register  this driver with the NDIS wrapper.  This call must occur
    // before any other NdisXxx calls.
    //
    NdisMInitializeWrapper(
        &NdisWrapperHandle, DriverObject, RegistryPath, NULL );

    // Set up the mini-port characteristics table that tells NDIS how to call
    // our mini-port.
    //
    NdisZeroMemory( &nmc, sizeof(nmc) );

    nmc.MajorNdisVersion = NDIS_MajorVersion;
    nmc.MinorNdisVersion = NDIS_MinorVersion;
    nmc.Reserved = NDIS_USE_WAN_WRAPPER;
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    nmc.HaltHandler = LmpHalt;
    // no HandleInterruptHandler
    nmc.InitializeHandler = LmpInitialize;
    // no ISRHandler
    // no QueryInformationHandler (see CoRequestHandler)
    nmc.ResetHandler = LmpReset;
    // no SendHandler (see CoSendPacketsHandler)
    // no WanSendHandler (see CoSendPacketsHandler)
    // no SetInformationHandler (see CoRequestHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler
    nmc.ReturnPacketHandler = LmpReturnPacket;
    // no SendPacketsHandler (see CoSendPacketsHandler)
    // no AllocateCompleteHandler
    nmc.CoActivateVcHandler = LmpCoActivateVc;
    nmc.CoDeactivateVcHandler = LmpCoDeactivateVc;
    nmc.CoSendPacketsHandler = LmpCoSendPackets;
    nmc.CoRequestHandler = LmpCoRequest;

    // Register this driver as the L2TP mini-port.  This will result in NDIS
    // calling back at LmpInitialize.
    //
    TRACE( TL_V, TM_Init, ( "NdisMRegMp" ) );
    status = NdisMRegisterMiniport( NdisWrapperHandle, &nmc, sizeof(nmc) );
    TRACE( TL_A, TM_Init, ( "NdisMRegMp=$%x", status ) );

    if (status == NDIS_STATUS_SUCCESS)
    {
        {
            extern CALLSTATS g_stats;
            extern NDIS_SPIN_LOCK g_lockStats;

            NdisZeroMemory( &g_stats, sizeof(g_stats) );
            NdisAllocateSpinLock( &g_lockStats );
        }

#ifdef PSDEBUG
        {
            extern LIST_ENTRY g_listDebugPs;
            extern NDIS_SPIN_LOCK g_lockDebugPs;

            InitializeListHead( &g_listDebugPs );
            NdisAllocateSpinLock( &g_lockDebugPs );
        }
#endif
    }
    else
    {
        NdisTerminateWrapper( NdisWrapperHandle, NULL );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\mp.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// mp.c
// RAS L2TP WAN mini-port/call-manager driver
// Mini-port routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


// The adapter control block address is recorded in this global as a debugging
// aid.  This global must not be read by any code.
//
ADAPTERCB* g_pDebugAdapter;

// The number of packets indicated up to and returned from the driver above.
//
LONG g_lPacketsIndicated = 0;
LONG g_lPacketsReturned = 0;

// Call statistics totals for all calls since loading, calls and the lock
// protecting access to them.  For this global only, the 'ullCallUp' field is
// the number of calls recorded, rather than a time.
//
CALLSTATS g_stats;
NDIS_SPIN_LOCK g_lockStats;

// Default settings for the NDIS_WAN_CO_INFO capabilities of an adapter.
//
static NDIS_WAN_CO_INFO g_infoDefaults =
{
    L2TP_MaxFrameSize,                  // MaxFrameSize
    0,                                  // MaxSendWindow (placeholder)
    PPP_FRAMING                         // FramingBits
        | PPP_COMPRESS_ADDRESS_CONTROL
        | PPP_COMPRESS_PROTOCOL_FIELD,
    0,                                  // DesiredACCM
};


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter );

NDIS_STATUS
GetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    OUT USHORT* pusMaxVcs,
    OUT TDIXMEDIATYPE* pMediaType,
    OUT L2TPROLE* pOutgoingRole,
    OUT ULONG* pulMaxSendTimeoutMs,
    OUT ULONG* pulInitialSendTimeoutMs,
    OUT ULONG* pulMaxRetransmits,
    OUT ULONG* pulHelloMs,
    OUT ULONG* pulMaxAckDelayMs,
    OUT SHORT* psMaxOutOfOrder,
    OUT USHORT* pusControlReceiveWindow,
    OUT USHORT* pusPayloadReceiveWindow,
    OUT ULONG* pulPayloadSendWindow,
    OUT USHORT* pusLlistDepth,
    OUT CHAR** ppszHostName,
    OUT CHAR** ppszPassword,
    OUT BOOLEAN* pfIgnoreFramingMismatch,
    OUT BOOLEAN* pfExclusiveTunnels,
    OUT HOSTROUTEEXISTS* phre,
    OUT BOOLEAN* pfUpdatePeerAddress,
    OUT BOOLEAN* pfDisableUdpXsums,
    OUT WCHAR** ppszDriverDesc );

NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );


//-----------------------------------------------------------------------------
// Mini-port handlers
//-----------------------------------------------------------------------------

NDIS_STATUS
LmpInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext )

    // Standard 'MiniportInitialize' routine called by NDIS to initialize a
    // new WAN adapter.  See DDK doc.  The driver will receive no requests
    // until this initialization has completed.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Init, ( "LmpInit" ) );

    status = *OpenErrorStatus = NDIS_STATUS_SUCCESS;

    // Find the medium index in the array of media, looking for the only one
    // we support, 'NdisMediumCoWan'.
    //
    {
        UINT i;

        for (i = 0; i < MediumArraySize; ++i)
        {
            if (MediumArray[ i ] == NdisMediumCoWan)
            {
                break;
            }
        }

        if (i >= MediumArraySize)
        {
            TRACE( TL_A, TM_Init, ( "medium?" ) );
            return NDIS_STATUS_FAILURE;
        }

        *SelectedMediumIndex = i;
    }

    // Allocate and zero a control block for the new adapter.
    //
    pAdapter = ALLOC_NONPAGED( sizeof(*pAdapter), MTAG_ADAPTERCB );
    TRACE( TL_N, TM_Init, ( "Acb=$%p", pAdapter ) );
    if (!pAdapter)
    {
        return NDIS_STATUS_RESOURCES;
    }
    NdisZeroMemory( pAdapter, sizeof(*pAdapter) );

    // The adapter control block address is recorded in 'g_pDebugAdapter' as a
    // debugging aid only.  This global is not to be read by any code.
    //
    g_pDebugAdapter = pAdapter;

    // Set a marker for easier memory dump browsing and future assertions.
    //
    pAdapter->ulTag = MTAG_ADAPTERCB;

    // Save the NDIS handle associated with this adapter for use in future
    // NdisXxx calls.
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    // Initialize the list of active tunnels and it's lock.
    //
    InitializeListHead( &pAdapter->listTunnels );
    NdisAllocateSpinLock( &pAdapter->lockTunnels );

    // Copy default NDISWAN information.  Some of these are updated below.
    //
    NdisMoveMemory( &pAdapter->info, &g_infoDefaults, sizeof(pAdapter->info) );
    pAdapter->info.MaxFrameSize = 1400;

    do
    {
        TDIXMEDIATYPE tmt;
        L2TPROLE role;
        USHORT usLlistDepth;
        BOOLEAN fIgnoreFramingMismatch;
        BOOLEAN fExclusiveTunnels;
        HOSTROUTEEXISTS hre;
        BOOLEAN fUpdatePeerAddress;
        BOOLEAN fDisableUdpXsums;

        // Read this adapter's registry settings.
        //
        status = GetRegistrySettings(
            WrapperConfigurationContext,
            &pAdapter->usMaxVcs,
            &tmt,
            &role,
            &pAdapter->ulMaxSendTimeoutMs,
            &pAdapter->ulInitialSendTimeoutMs,
            &pAdapter->ulMaxRetransmits,
            &pAdapter->ulHelloMs,
            &pAdapter->ulMaxAckDelayMs,
            &pAdapter->sMaxOutOfOrder,
            &pAdapter->usControlReceiveWindow,
            &pAdapter->usPayloadReceiveWindow,
            &pAdapter->info.MaxSendWindow,
            &usLlistDepth,
            &pAdapter->pszHostName,
            &pAdapter->pszPassword,
            &fIgnoreFramingMismatch,
            &fExclusiveTunnels,
            &hre,
            &fUpdatePeerAddress,
            &fDisableUdpXsums,
            &pAdapter->pszDriverDesc );

        if (status != NDIS_STATUS_SUCCESS)
        {
            // Set 'usMaxVcs' to 0 as an indication to FreeAdapter that the
            // lookaside lists and pools were not initialized.
            //
            pAdapter->usMaxVcs = 0;
            break;
        }

        // Convert the outgoing call role and mismatch flags to the equivalent
        // control block flag settings.
        //
        if (role == LR_Lac)
        {
            pAdapter->ulFlags |= ACBF_OutgoingRoleLac;
        }

        if (fIgnoreFramingMismatch)
        {
            pAdapter->ulFlags |= ACBF_IgnoreFramingMismatch;
        }

        if (fExclusiveTunnels)
        {
            pAdapter->ulFlags |= ACBF_ExclusiveTunnels;
        }

        if (fUpdatePeerAddress)
        {
            pAdapter->ulFlags |= ACBF_UpdatePeerAddress;
        }

        // Initialize our framing and bearer capability bit masks.  NDISWAN
        // supports only synchronous framing.  Until we add the full LAC
        // support, we have no bearer capabilities for both the LAC and LNS
        // roles.
        //
        pAdapter->ulFramingCaps = FBM_Sync;
        pAdapter->ulBearerCaps = 0;

        // Initialize lookaside lists, buffer pools, and packet pool.  On NT,
        // lookaside depths are optimized by the system based on usage
        // regardless of the depth set, but choose something reasonable
        // anyway.
        //
        {
            if (pAdapter->usMaxVcs < usLlistDepth)
            {
                usLlistDepth = pAdapter->usMaxVcs;
            }

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistWorkItems,
                NULL, NULL, 0,
                sizeof(NDIS_WORK_ITEM),
                MTAG_WORKITEM,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTimerQItems,
                NULL, NULL, 0,
                sizeof(TIMERQITEM),
                MTAG_TIMERQITEM,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistControlSents,
                NULL, NULL, 0,
                sizeof(CONTROLSENT),
                MTAG_CTRLSENT,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistPayloadSents,
                NULL, NULL, 0,
                sizeof(PAYLOADSENT),
                MTAG_PAYLSENT,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTunnelWorks,
                NULL, NULL, 0,
                sizeof(TUNNELWORK),
                MTAG_TUNNELWORK,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistControlMsgInfos,
                NULL, NULL, 0,
                sizeof(CONTROLMSGINFO),
                MTAG_CTRLMSGINFO,
                usLlistDepth );

#if LLISTALL
            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTunnels,
                NULL, NULL, 0,
                sizeof(TUNNELCB),
                MTAG_TUNNELCB,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistVcs,
                NULL, NULL, 0,
                sizeof(VCCB),
                MTAG_VCCB,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistTimerQs,
                NULL, NULL, 0,
                sizeof(TIMERQ),
                MTAG_TIMERQ,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistControlReceiveds,
                NULL, NULL, 0,
                sizeof(CONTROLRECEIVED),
                MTAG_CTRLRECD,,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistPayloadReceiveds,
                NULL, NULL, 0,
                sizeof(PAYLOADRECEIVED),
                MTAG_PAYLRECD,
                usLlistDepth );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistInCallSetups,
                NULL, NULL, 0,
                sizeof(INCALLSETUP),
                MTAG_INCALL,
                usLlistDepth );
#endif

            InitBufferPool(
                &pAdapter->poolFrameBuffers,
                L2TP_FrameBufferSize
                    + ((tmt == TMT_RawIp) ? IpFixedHeaderSize : 0),
                0, 10, 0,
                TRUE, MTAG_FBUFPOOL );

            InitBufferPool(
                &pAdapter->poolHeaderBuffers,
                L2TP_HeaderBufferSize,
                0, 20, 0,
                TRUE, MTAG_HBUFPOOL );

            InitPacketPool(
                &pAdapter->poolPackets,
                0, 0, 30, 0,
                MTAG_PACKETPOOL );
        }

        // Initialize the TDI extension context.
        //
        TdixInitialize(
            tmt,
            hre,
            ((fDisableUdpXsums) ? TDIXF_DisableUdpXsums : 0),
            L2tpReceive,
            &pAdapter->poolFrameBuffers,
            &pAdapter->tdix );

        // Allocate and zero the VC control block address array.
        //
        {
            ULONG ulSize;

            ulSize = pAdapter->usMaxVcs * sizeof(VCCB*);
            pAdapter->ppVcs = ALLOC_NONPAGED( ulSize, MTAG_VCTABLE );
            TRACE( TL_V, TM_Init, ( "VcTable=$%p", pAdapter->ppVcs ) );
            if (!pAdapter->ppVcs)
            {
                status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory( pAdapter->ppVcs, ulSize );

            // Allocate the lock that guards the table.
            //
            NdisAllocateSpinLock( &pAdapter->lockVcs );

            // At this point, all VC slots in the table are available.
            //
            pAdapter->lAvailableVcSlots = (LONG )pAdapter->usMaxVcs;

            // Set the initial value of the termination call ID counter.  See
            // GetNextTerminationCallId.
            //
            pAdapter->usNextTerminationCallId = pAdapter->usMaxVcs + 1;

        }

        // Inform NDIS of the attributes of our adapter.  Set the
        // 'MiniportAdapterContext' returned to us by NDIS when it calls our
        // handlers to the address of our adapter control block.  Turn off
        // hardware oriented timeouts.
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE)pAdapter,
            (UINT)-1,
            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
                | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
            NdisInterfaceInternal );

        // Register the address family of our call manager with NDIS for the
        // newly bound adapter.  We use the mini-port form of
        // RegisterAddressFamily instead of the protocol form, though that
        // would also work.  With the protocol form, our internal call manager
        // would have to go thru NDIS to talk to the mini-port instead of just
        // calling directly.  Since the L2TP call manager is not likely to be
        // useful with anything but the L2TP mini-port, this would be a waste.
        // The mini-port form also causes the call manager VC context to
        // automatically map to the mini-port VC context, which is exactly
        // what we want.
        //
        // NDIS notifies all call manager clients of the new family we
        // register.  The TAPI proxy is the only client expected to be
        // interested.  NDISWAN will receive the notification, but ignore it
        // and wait for the TAPI proxy to notify it of the proxied version.
        //
        {
            NDIS_CALL_MANAGER_CHARACTERISTICS ncmc;
            CO_ADDRESS_FAMILY family;

            NdisZeroMemory( &family, sizeof(family) );
            family.MajorVersion = NDIS_MajorVersion;
            family.MinorVersion = NDIS_MinorVersion;
            family.AddressFamily = CO_ADDRESS_FAMILY_TAPI_PROXY;

            NdisZeroMemory( &ncmc, sizeof(ncmc) );
            ncmc.MajorVersion = NDIS_MajorVersion;
            ncmc.MinorVersion = NDIS_MinorVersion;
            ncmc.CmCreateVcHandler = LcmCmCreateVc;
            ncmc.CmDeleteVcHandler = LcmCmDeleteVc;
            ncmc.CmOpenAfHandler = LcmCmOpenAf;
            ncmc.CmCloseAfHandler = LcmCmCloseAf;
            ncmc.CmRegisterSapHandler = LcmCmRegisterSap;
            ncmc.CmDeregisterSapHandler = LcmCmDeregisterSap;
            ncmc.CmMakeCallHandler = LcmCmMakeCall;
            ncmc.CmCloseCallHandler = LcmCmCloseCall;
            ncmc.CmIncomingCallCompleteHandler = LcmCmIncomingCallComplete;
            // no CmAddPartyHandler
            // no CmDropPartyHandler
            ncmc.CmActivateVcCompleteHandler = LcmCmActivateVcComplete;
            ncmc.CmDeactivateVcCompleteHandler = LcmCmDeactivateVcComplete;
            ncmc.CmModifyCallQoSHandler = LcmCmModifyCallQoS;
            ncmc.CmRequestHandler = LcmCmRequest;
            // no CmRequestCompleteHandler

            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf" ) );
            status = NdisMCmRegisterAddressFamily(
                MiniportAdapterHandle, &family, &ncmc, sizeof(ncmc) );
            TRACE( TL_I, TM_Cm, ( "NdisMCmRegAf=$%x", status ) );
        }
    }
    while (FALSE);

    if (status == NDIS_STATUS_SUCCESS)
    {
        // Add a reference that will eventually be removed by an NDIS call to
        // the LmpHalt handler.
        //
        ReferenceAdapter( pAdapter );
    }
    else
    {
        // Failed, so undo whatever portion succeeded.
        //
        if (pAdapter)
        {
            FreeAdapter( pAdapter );
        }
    }

    TRACE( TL_V, TM_Init, ( "LmpInit=$%08x", status ) );
    return status;
}


VOID
LmpHalt(
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportHalt' routine called by NDIS to deallocate all
    // resources attached to the adapter.  NDIS does not make any other calls
    // for this mini-port adapter during or after this call.  NDIS will not
    // call this routine when packets indicated as received have not been
    // returned, or when any VC is created and known to NDIS.  Runs at PASSIVE
    // IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Mp, ( "LmpHalt" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (!pAdapter || pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return;
    }

    // Don't allow the halt to complete before all timers have completed as
    // this can result in a 0xC7 bugcheck if the driver is immediately
    // unloaded.  All timers should be in the process of terminating before
    // NDIS calls this handler, so this should occur very quickly.
    //
    while (pAdapter->ulTimers)
    {
        TRACE( TL_A, TM_Mp, ( "LmpHalt timers=%d", pAdapter->ulTimers ) );
        NdisMSleep( 100000 );
    }

    DereferenceAdapter( pAdapter );

    TRACE( TL_V, TM_Mp, ( "LmpHalt done" ) );
}


NDIS_STATUS
LmpReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportReset' routine called by NDIS to reset the driver's
    // software state.
    //
{
    TRACE( TL_I, TM_Mp, ( "LmpReset" ) );

    return NDIS_STATUS_NOT_RESETTABLE;
}


VOID
LmpReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet )

    // Standard 'MiniportReturnPacket' routine called by NDIS when a packet
    // used to indicate a receive has been released by the driver above.
    //
{
    VCCB* pVc;
    CHAR* pBuffer;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pTrimmedBuffer;
    PACKETHEAD* pHead;
    PACKETPOOL* pPool;

    TRACE( TL_N, TM_Mp, ( "LmpReturnPacket" ) );

    // Unpack the context information we stashed earlier.
    //
    pHead = *((PACKETHEAD** )(&Packet->MiniportReserved[ 0 ]));
    pBuffer = *((CHAR** )(&Packet->MiniportReserved[ sizeof(VOID*) ]));

    // Find the adapter from the PACKETHEAD address.
    //
    pPool = PacketPoolFromPacketHead( pHead );
    pAdapter = CONTAINING_RECORD( pPool, ADAPTERCB, poolPackets );
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );

    // Free the descriptor created by NdisCopyBuffer.
    //
    NdisUnchainBufferAtFront( Packet, &pTrimmedBuffer );
    if (pTrimmedBuffer)
    {
        extern ULONG g_ulNdisFreeBuffers;

        NdisFreeBuffer( pTrimmedBuffer );
        NdisInterlockedIncrement( &g_ulNdisFreeBuffers );
    }

    // Free the buffer and packet back to the pools.
    //
    FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
    FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );

    NdisInterlockedIncrement( &g_lPacketsReturned );

    TRACE( TL_V, TM_Mp, ( "LmpReturnPacket done" ) );
}


NDIS_STATUS
LmpCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters )

    // Standard 'MiniportCoActivateVc' routine called by NDIS in response to a
    // protocol's request to activate a virtual circuit.
    //
{
    ASSERT( !"LmpCoActVc?" );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LmpCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to de-activate a virtual circuit.
    //
{
    ASSERT( !"LmpCoDeactVc?" );
    return NDIS_STATUS_SUCCESS;
}


VOID
LmpCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to send packets on a virtual circuit.
    //
{
    UINT i;
    NDIS_STATUS status;
    NDIS_PACKET** ppPacket;
    VCCB* pVc;

    TRACE( TL_N, TM_Send, ( "LmpCoSendPackets(%d)", NumberOfPackets ) );

    pVc = (VCCB* )MiniportVcContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );

    for (i = 0, ppPacket = PacketArray;
         i < NumberOfPackets;
         ++i, ++ppPacket)
    {
        NDIS_PACKET* pPacket = *ppPacket;

        // SendPayload sends the packet and eventually calls
        // NdisMCoSendComplete to notify caller of the result.
        //
        NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_PENDING );
        SendPayload( pVc, pPacket );
    }

    TRACE( TL_V, TM_Send, ( "LmpCoSendPackets done" ) );
}


NDIS_STATUS
LmpCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'MiniportCoRequestHandler' routine called by NDIS in response
    // to a protocol's request information from the mini-port.  Unlike the
    // Query/SetInformation handlers that this routine obsoletes, requests are
    // not serialized.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Mp, ( "LmpCoReq" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )MiniportVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            status = SetInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.SET_INFORMATION.Oid,
                NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                &NdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Mp, ( "type=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_V, TM_Mp, ( "LmpCoReq=$%x", status ) );
    return status;
}


//-----------------------------------------------------------------------------
// Mini-port utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the adapter control block 'pAdapter', and when
    // frees the adapter resources when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefA to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        FreeAdapter( pAdapter );
    }
}


VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter )

    // Frees all resources allocated for adapter 'pAdapter', including
    // 'pAdapter' itself.
    //
{
    BOOLEAN fSuccess;

    ASSERT( IsListEmpty( &pAdapter->listTunnels ) );

    if (pAdapter->ppVcs)
    {
        FREE_NONPAGED( pAdapter->ppVcs );
    }

    // Setting 'usMaxVcs' to 0 is LmpInitialize's way of telling us that the
    // lookaside lists and pools were not initialized.
    //
    if (pAdapter->usMaxVcs)
    {
        NdisDeleteNPagedLookasideList( &pAdapter->llistWorkItems );
        NdisDeleteNPagedLookasideList( &pAdapter->llistTimerQItems );
        NdisDeleteNPagedLookasideList( &pAdapter->llistControlSents );
        NdisDeleteNPagedLookasideList( &pAdapter->llistPayloadSents );
        NdisDeleteNPagedLookasideList( &pAdapter->llistTunnelWorks );
        NdisDeleteNPagedLookasideList( &pAdapter->llistControlMsgInfos );

#if LLISTALL
        NdisDeleteNPagedLookasideList( &pAdapter->llistTunnels );
        NdisDeleteNPagedLookasideList( &pAdapter->llistVcs );
        NdisDeleteNPagedLookasideList( &pAdapter->llistTimerQs );
        NdisDeleteNPagedLookasideList( &pAdapter->llistControlReceiveds );
        NdisDeleteNPagedLookasideList( &pAdapter->llistPayloadReceiveds );
        NdisDeleteNPagedLookasideList( &pAdapter->llistInCallSetups );
#endif

        fSuccess = FreeBufferPool( &pAdapter->poolFrameBuffers );
        ASSERT( fSuccess );
        fSuccess = FreeBufferPool( &pAdapter->poolHeaderBuffers );
        ASSERT( fSuccess );
        fSuccess = FreePacketPool( &pAdapter->poolPackets );
        ASSERT( fSuccess );
    }

    if (pAdapter->pszPassword)
    {
        FREE_NONPAGED( pAdapter->pszPassword );
    }

    if (pAdapter->pszDriverDesc)
    {
        FREE_NONPAGED( pAdapter->pszDriverDesc );
    }

    if (pAdapter->pszHostName)
    {
        FREE_NONPAGED( pAdapter->pszHostName );
    }

    pAdapter->ulTag = MTAG_FREED;
    FREE_NONPAGED( pAdapter );
}


NDIS_STATUS
GetRegistrySettings(
    IN NDIS_HANDLE WrapperConfigurationContext,
    OUT USHORT* pusMaxVcs,
    OUT TDIXMEDIATYPE* pMediaType,
    OUT L2TPROLE* pOutgoingRole,
    OUT ULONG* pulMaxSendTimeoutMs,
    OUT ULONG* pulInitialSendTimeoutMs,
    OUT ULONG* pulMaxRetransmits,
    OUT ULONG* pulHelloMs,
    OUT ULONG* pulMaxAckDelayMs,
    OUT SHORT* psMaxOutOfOrder,
    OUT USHORT* pusControlReceiveWindow,
    OUT USHORT* pusPayloadReceiveWindow,
    OUT ULONG* pulPayloadSendWindow,
    OUT USHORT* pusLlistDepth,
    OUT CHAR** ppszHostName,
    OUT CHAR** ppszPassword,
    OUT BOOLEAN* pfIgnoreFramingMismatch,
    OUT BOOLEAN* pfExclusiveTunnels,
    OUT HOSTROUTEEXISTS* phre,
    OUT BOOLEAN* pfUpdatePeerAddress,
    OUT BOOLEAN* pfDisableUdpXsums,
    OUT WCHAR**  ppszDriverDesc )

    // Read this mini-port's registry settings into caller's output variables.
    // 'WrapperConfigurationContext' is the handle to passed to
    // MiniportInitialize.
    //
{
    NDIS_STATUS status;
    NDIS_HANDLE hCfg;
    NDIS_CONFIGURATION_PARAMETER* pncp;

    NdisOpenConfiguration( &status, &hCfg, WrapperConfigurationContext );
    if (status != NDIS_STATUS_SUCCESS)
        return status;

    do
    {
        // (recommended) The number of VCs we must be able to provide.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxWanEndpoints" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusMaxVcs = (USHORT )pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.  The implicit upper bound
                // imposed by the protocol's Tunnel-Id/Call-ID sizes is 65535.
                // Settings above 1000 are not recommended, but will work if
                // huge amounts of memory and bandwidth are available.
                //
                if (*pusMaxVcs < 1)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                *pusMaxVcs = 1000;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (recommended) The media type to run L2TP over.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "VpnMediaType" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pMediaType = (TDIXMEDIATYPE )pncp->ParameterData.IntegerData;

                // Make sure it's a valid type.
                //
                if (*pMediaType != TMT_Udp && *pMediaType != TMT_RawIp)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                // No media type in registry.  Default to UDP.
                //
                *pMediaType = TMT_Udp;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum send timeout in milliseconds.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxSendTimeoutMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulMaxSendTimeoutMs = pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.
                //
                if (*pulMaxSendTimeoutMs == 0)
                {
                    *pulMaxSendTimeoutMs = 0x7FFFFFFF;
                }
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulMaxSendTimeoutMs = L2TP_DefaultMaxSendTimeoutMs;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The initial send timeout in milliseconds.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "InitialSendTimeoutMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulInitialSendTimeoutMs = pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.
                //
                if (*pulInitialSendTimeoutMs == 0)
                {
                    *pulInitialSendTimeoutMs = 0x7FFFFFFF;
                }

                if (*pulInitialSendTimeoutMs > *pulMaxSendTimeoutMs)
                    *pulInitialSendTimeoutMs = *pulMaxSendTimeoutMs;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulInitialSendTimeoutMs = L2TP_DefaultSendTimeoutMs;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum number of control message retransmissions
        //            before the tunnel is reset.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxRetransmits" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulMaxRetransmits = pncp->ParameterData.IntegerData;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulMaxRetransmits = L2TP_DefaultMaxRetransmits;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The control Hello timeout in milliseconds.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "HelloMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulHelloMs = pncp->ParameterData.IntegerData;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulHelloMs = L2TP_HelloMs;
                status = STATUS_SUCCESS;
            }
        }

        // (optional) The maximum piggyback delay in milliseconds before
        //            sending a zero payload acknowledgement.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxAckDelayMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulMaxAckDelayMs = pncp->ParameterData.IntegerData;
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pulMaxAckDelayMs = L2TP_MaxAckDelay;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum number of out-of-order packets to queue.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxOutOfOrder" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *psMaxOutOfOrder = (SHORT )pncp->ParameterData.IntegerData;

                // Make sure it's not negative and within 1/4 of the possible
                // sequence values to avoid aliasing.  Zero effectively
                // disables out of order handling.
                //
                if (*psMaxOutOfOrder < 0 || *psMaxOutOfOrder > 0x4000)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *psMaxOutOfOrder = 100;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The role (LNS or LAC) that the adapter will play in
        //            outgoing calls.  The role played for incoming calls is
        //            determined by the role the peer plays in his call
        //            request.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "OutgoingRole" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pOutgoingRole = (L2TPROLE )pncp->ParameterData.IntegerData;

                // Make sure it's a valid role.
                //
                if (*pOutgoingRole != LR_Lac && *pOutgoingRole != LR_Lns)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                // No role in registry.  Default to LAC.
                //
                *pOutgoingRole = LR_Lac;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The control receive window sent to peer to indicate how
        //            many sent control messages peer may have outstanding.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ControlReceiveWindow" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusControlReceiveWindow =
                   (USHORT )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                *pusControlReceiveWindow = 8;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The payload receive window sent to peer to indicate how
        //            many send payloads peer may have outstanding on any one
        //            call.  A value of 0 disables all Ns/Nr sequencing on the
        //            payload channel for locally requested calls.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "PayloadReceiveWindow" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusPayloadReceiveWindow =
                   (USHORT )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                // Note: Default changed to 0 (off) from 16 due to performance
                //       study that shows significantly better results without
                //       flow control, presumably due to interference with
                //       higher level timers.
                //
                *pusPayloadReceiveWindow = 0;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The maximum payload send window size reported to
        //            NDISWAN.  Peer may set the actual send window higher or
        //            lower, but if higher this is the actual maximum.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "PayloadSendWindow" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pulPayloadSendWindow =
                   (ULONG )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                *pulPayloadSendWindow = 16;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The lookaside list depth ceiling, where higher values
        //            allow this driver to consume more non-paged pool in
        //            return for performance gain at high volumes.  Setting
        //            this value above 'MaxVcs' has no effect.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "LookasideDepth" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pusLlistDepth = (USHORT )pncp->ParameterData.IntegerData;
            }
            else
            {
                // No setting in registry.  Set a reasonable default.
                //
                *pusLlistDepth = 30;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) The host name passed to peer and used as the base of the
        //            call serial number.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "HostName" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterString );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *ppszHostName =
                    StrDupNdisStringToA( &pncp->ParameterData.StringData );
            }
            else
            {
                // No setting in registry, so use a default.
                //
                *ppszHostName = GetFullHostNameFromRegistry();
                if (!*ppszHostName)
                {
                    *ppszHostName = StrDup( "NONE" );
                }

                status = NDIS_STATUS_SUCCESS;
            }
        }


        // (optional) The single password shared with peer for use in
        //            verifying peer's identity.  If specified, authentication
        //            of peer is required, and if not, authentication is not
        //            provided.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "Password" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterString );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *ppszPassword =
                    StrDupNdisStringToA( &pncp->ParameterData.StringData );
            }
            else
            {
                // No setting in registry...and no default.
                //
                *ppszPassword = NULL;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) Buggy peer hedge flag to ignore framing mismatches.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "IgnoreFramingMismatch" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfIgnoreFramingMismatch =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {
                // No value in registry.  Set a reasonable default.
                //
                *pfIgnoreFramingMismatch = TRUE;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) Flag indicating whether, by default, separate tunnels
        //            are to be created for each outgoing call even if a
        //            tunnel already exists to the same peer.  This setting
        //            can be overridden via L2TP-specific call parameters.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ExclusiveTunnels" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfExclusiveTunnels =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {
                // No value in registry.  Set a default.
                //
                *pfExclusiveTunnels = FALSE;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (optional) Flag indicating whether routes created outside this
        //            driver may be used as L2TP host routes.  If the flag is
        //            not set, the pre-existing host routes will cause the
        //            tunnel to close.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "UseExistingRoutes" );
            BOOLEAN fDefault;

            fDefault = FALSE;

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *phre = (HOSTROUTEEXISTS )pncp->ParameterData.IntegerData;

                if (*phre != HRE_Use
                    && *phre != HRE_Fail
#if ROUTEWITHREF
                    && *phre != HRE_Reference
#endif
                   )
                {
                    // Bad value in registry.
                    //
                    fDefault = TRUE;
                }
            }
            else
            {
                // No value in registry.
                //
                status = NDIS_STATUS_SUCCESS;
                fDefault = TRUE;
            }

            if (fDefault)
            {
#if ROUTEWITHREF
                // Set default to "reference" as this allows simultaneous L2TP
                // and PPTP connections between the same two peers without
                // host route trashing.
                //
                *phre = HRE_Reference;
#else
                // Set default to "fail" to prevent L2TP from stomping on a
                // PPTP host route.
                //
                *phre = HRE_Fail;
#endif
            }
        }

        // (optional) Flag indicating whether that changes in peer's source IP
        //            address and/or UDP port are to result in the destination
        //            of outbound packets changing accordingly.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "UpdatePeerAddress" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfUpdatePeerAddress =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {
                // No value in registry.  Set a default.
                //
                *pfUpdatePeerAddress = FALSE;
                status = NDIS_STATUS_SUCCESS;
            }
        }


        // (optional) Flag indicating whether UDP checksums should be disabled
        //            on L2TP payload traffic.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "DisableUdpChecksums" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *pfDisableUdpXsums =
                    (BOOLEAN )!!(pncp->ParameterData.IntegerData);
            }
            else
            {

                // No value in registry.  Set a default.  The L2TP draft says
                // implementation MUST default to "enabled".
                //
                *pfDisableUdpXsums = TRUE;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // (required) The driver description string, which is reported to TAPI
        //            as the L2TP line name.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "DriverDesc" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterString );
            if (status == NDIS_STATUS_SUCCESS)
            {
                *ppszDriverDesc =
                    StrDupNdisString( &pncp->ParameterData.StringData );
            }
            else
            {
                // No setting in registry...and no default.
                //
                *ppszDriverDesc = NULL;
                status = NDIS_STATUS_SUCCESS;
            }
        }
    }
    while (FALSE);

    NdisCloseConfiguration( hCfg );

    TRACE( TL_N, TM_Init,
        ( "Reg: vcs=%d mt=%d or=%d lld=%d hto=%d ooo=%d mad=%d dx=%d",
        *pusMaxVcs,
        *pMediaType,
        *pOutgoingRole,
        (ULONG )*pusLlistDepth,
        *pulHelloMs,
        (INT )*psMaxOutOfOrder,
        *pulMaxAckDelayMs,
        (UINT )*pfDisableUdpXsums ) );
    TRACE( TL_N, TM_Init,
        ( "Reg: mto=%d ito=%d mrt=%d crw=%d prw=%d psw=%d ifm=%d xt=%d xr=%d ua=%d",
        *pulMaxSendTimeoutMs,
        *pulInitialSendTimeoutMs,
        *pulMaxRetransmits,
        (UINT )*pusControlReceiveWindow,
        (UINT )*pusPayloadReceiveWindow,
        (UINT )*pulPayloadSendWindow,
        (UINT )*pfIgnoreFramingMismatch,
        (UINT )*pfExclusiveTunnels,
        (UINT )*phre,
        (UINT )*pfUpdatePeerAddress ) );
    TRACE( TL_N, TM_Init,
        ( "Reg: hn=\"%s\" pw=\"%s\"",
        ((*ppszHostName) ? *ppszHostName : ""),
        ((*ppszPassword) ? *ppszPassword : "") ) );

    return status;
}


NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle QueryInformation requests.  Arguments are as for the standard
    // NDIS 'MiniportQueryInformation' handler except this routine does not
    // count on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            // Report the maximum number of bytes we can always provide as
            // lookahead data on receive indications.  We always indicate full
            // packets so this is the same as the receive block size.  And
            // since we always allocate enough for a full packet, the receive
            // block size is the same as the frame size.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
            ulInfo = L2TP_MaxFrameSize;
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAC_OPTIONS)" ) );
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                     | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            break;
        }

        case OID_WAN_MEDIUM_SUBTYPE:
        {
            // Report the media subtype we support.  NDISWAN may use this in
            // the future (doesn't now) to provide framing differences for
            // different media.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_MEDIUM_SUBTYPE)" ) );
            ulInfo = NdisWanMediumL2TP;
            break;
        }

        case OID_WAN_CO_GET_INFO:
        {
            // Report the capabilities of the adapter.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_INFO)" ) );
            pInfo = &pAdapter->info;
            ulInfoLen = sizeof(NDIS_WAN_CO_INFO);
            break;
        }

        case OID_WAN_CO_GET_LINK_INFO:
        {
            // Report the current state of the link.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_LINK_INFO)" ) );

            if (!pVc)
            {
                return NDIS_STATUS_INVALID_DATA;
            }

            pInfo = &pVc->linkinfo;
            ulInfoLen = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
            break;
        }

	    case OID_WAN_CO_GET_COMP_INFO:
        {
            // Report the type of compression we provide, which is none.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_COMP_INFO)" ) );
	    	status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
	    	break;
        }

	    case OID_WAN_CO_GET_STATS_INFO:
        {
            // Because L2TP doesn't do compression, NDISWAN will use it's own
            // statistics and not query ours.
            //
            ASSERT( !"OID_WAN_CO_GET_STATS_INFO?" );
	    	status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
	    	break;
        }

        case OID_GEN_SUPPORTED_LIST:
        {
            static ULONG aulSupportedOids[] = {
                OID_GEN_SUPPORTED_LIST,
                OID_GEN_MAXIMUM_LOOKAHEAD,
                OID_GEN_MAC_OPTIONS,
                OID_WAN_MEDIUM_SUBTYPE,
                OID_WAN_CO_GET_INFO,
                OID_WAN_CO_GET_LINK_INFO,
                OID_WAN_CO_SET_LINK_INFO,
                OID_CO_TAPI_CM_CAPS,
                OID_CO_TAPI_LINE_CAPS,
                OID_CO_TAPI_ADDRESS_CAPS,
                OID_CO_TAPI_GET_CALL_DIAGNOSTICS
            };

            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_SUPPORTED_LIST)" ) );
            pInfo = aulSupportedOids;
            ulInfoLen = sizeof(aulSupportedOids);
            break;
        }

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_VENDOR_ID:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_DRIVER_VERSION:
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MAC_OPTIONS:
        case OID_GEN_MEDIA_CONNECT_STATUS:
        case OID_GEN_MAXIMUM_SEND_PACKETS:
        case OID_WAN_PERMANENT_ADDRESS:
        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_LINE_COUNT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "Q-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "RefA to %d", lRef ) );
}


NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded )

    // Handle SetInformation requests.  Arguments are as for the standard NDIS
    // 'MiniportQueryInformation' handler except this routine does not count
    // on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;

    status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {
        case OID_WAN_CO_SET_LINK_INFO:
        {
            // Read new link state settings.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_LINK_INFO)" ) );
            if (InformationBufferLength < sizeof(NDIS_WAN_CO_SET_LINK_INFO))
            {
                status = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
            }
            else
            {
                if (!pVc)
                    return NDIS_STATUS_INVALID_DATA;

                ASSERT( sizeof(pVc->linkinfo)
                    == sizeof(NDIS_WAN_CO_SET_LINK_INFO) );

                NdisMoveMemory( &pVc->linkinfo, InformationBuffer,
                    sizeof(pVc->linkinfo) );
                DUMPB( TL_N, TM_Mp, &pVc->linkinfo, sizeof(pVc->linkinfo) );

                *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
            }

            *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        }
        break;

        case OID_WAN_CO_SET_COMP_INFO:
        {
            // L2TP doesn't provide compression.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_COMP_INFO)" ) );
	    	status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
	    	break;
        }

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_PROTOCOL_OPTIONS:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_HEADER_FORMAT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "S-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\ppool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.h
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _PPOOL_H_
#define _PPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//
typedef struct
_PACKETPOOL
{
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    ULONG ulProtocolReservedLength;

    // The optimal number of packets to allocate in each packet block.
    //
    ULONG ulPacketsPerBlock;

    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    ULONG ulMaxPackets;

    // Current number of individual packets allocated in the entire pool.
    //
    ULONG ulCurPackets;

    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of PACKETBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free PACKETHEADs.  Each PACKETHEAD in
    // the list is ready to go, i.e. it already has an NDIS_PACKET associated
    // with it.  Access to the list is prototected by 'lock' in this
    // structure.  Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    LIST_ENTRY listFreePackets;

    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    NDIS_SPIN_LOCK lock;
}
PACKETPOOL;


// Header of a single block of packets from a packet pool.  The PACKETHEAD of
// the first buffer immediately follows.
//
typedef struct
_PACKETBLOCKHEAD
{
    // Links to the prev/next packet block header in the packet pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the packet pool.
    //
    PACKETPOOL* pPool;

    // Number of individual packets in this block.
    //
    ULONG ulPackets;

    // Number of individual packets in this block on the free list.
    //
    ULONG ulFreePackets;
}
PACKETBLOCKHEAD;


// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//
typedef struct
_PACKETHEAD
{
    // Link to next packet header in the packet pool's free list.
    //
    LIST_ENTRY linkFreePackets;

    // Back link to owning packet block header.
    //
    PACKETBLOCKHEAD* pBlock;

    // NDIS packet descriptor of this buffer.
    //
    NDIS_PACKET* pNdisPacket;
}
PACKETHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag );

BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool );

NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead );

VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection );

PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead );

VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool );

__inline
PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead )

    // Returns the address of the pool, given 'pHead', the address of a
    // PACKETHEAD like the one returned from GetPacketFromPool.
    //
{
    return pHead->pBlock->pPool;
}


#endif // PPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\ppool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.c
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "l2tpp.h"


// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoublePacketFrees = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool );

VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag )

    // Initialize caller's packet pool control block 'pPool'.
    // 'UlProtocolReservedLength' is the size in bytes of the
    // 'ProtocolReserved' array of each individual packet.  'UlMaxPackets' is
    // the maximum number of packets allowed in the entire pool, or 0 for
    // unlimited.  'UlPacketsPerBlock' is the number of packets to include in
    // each block of packets.  'UlFreesPerCollection' is the number of
    // FreePacketToPool calls until the next garbage collect scan, or 0 for
    // default.  'UlTag' is the memory identification tag to use when
    // allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' packet must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulProtocolReservedLength = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock = ulPacketsPerBlock;
    pPool->ulMaxPackets = ulMaxPackets;
    pPool->ulFreesSinceCollection = 0;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulPacketsPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitPp tag=$%08x pr=%d cnt=%d",
        pPool->ulTag,
        pPool->ulProtocolReservedLength,
        pPool->ulPacketsPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreePackets );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool )

    // Free up all resources allocated in packet pool 'pPool'.  This is the
    // inverse of InitPacketPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreePp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        fSuccess = (pPool->ulCurPackets == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead )

    // Returns the address of the NDIS_PACKET descriptor allocated from the
    // pool 'pPool'.  The pool is expanded, if necessary, but caller should
    // still check for NULL return since the pool may have been at maximum
    // size.  'PpHead' is the "cookie" that is used to return the packet to
    // the pool (see FreePacketToPool).  Caller would normally stash this
    // value in the appropriate 'reserved' areas of the packet for retrieval
    // later.
    //
{
    LIST_ENTRY* pLink;
    PACKETHEAD* pHead;
    NDIS_PACKET* pPacket;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreePackets ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreePackets );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, PACKETHEAD, linkFreePackets );
            --pHead->pBlock->ulFreePackets;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!pLink)
    {
        // The free list was empty.  Try to expand the pool.
        //
        pHead = AddPacketBlockToPool( pPool );
        if (!pHead)
        {
            TRACE( TL_A, TM_Pool, ( "GetPfP failed?" ) );
            return NULL;
        }
    }

    TRACE( TL_N, TM_Pool,
        ( "GetPfP=$%p/h=$%p, %d free",
        pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );

    *ppHead = pHead;
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pPacket' to the pool of unused packets 'pPool'.  'PPacket'
    // must have been previously allocated with GetPacketFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddPacketToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool,
            ( "FreePtoP($%p,h=$%p) %d free",
            pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreePackets.Flink != &pHead->linkFreePackets)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoublePacketFrees;
            break;
        }

        InsertHeadList( &pPool->listFreePackets, &pHead->linkFreePackets );
        ++pHead->pBlock->ulFreePackets;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedPacketPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool )

    // Allocate a new packet block and add it to the packet pool 'pPool'.
    //
    // Returns the PACKETHEAD allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    PACKETBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    PACKETHEAD* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddPpBlock(%d+%d)",
        pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        do
        {
            if (pPool->ulMaxPackets
                && pPool->ulCurPackets >= pPool->ulMaxPackets)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Pp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of packets
            // it will hold.
            //
            ulCount = pPool->ulPacketsPerBlock;
            if (pPool->ulMaxPackets)
            {
                if (ulCount > pPool->ulMaxPackets - pPool->ulCurPackets)
                {
                    ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
                }
            }
            ulSize = sizeof(PACKETBLOCKHEAD) + (ulCount * sizeof(PACKETHEAD));

            // Allocate the contiguous memory block for the PACKETBLOCK header
            // and the individual PACKETHEADs.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc PB?") );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(PACKETBLOCKHEAD) );

            // Allocate a pool of NDIS_PACKET descriptors.
            //
            NdisAllocatePacketPool(
                &status,
                &pNew->hNdisPool,
                ulCount,
                pPool->ulProtocolReservedLength );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocPp=$%x?", status ) );
                break;
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the packets are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulPackets = ulCount;
            pPool->ulCurPackets += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreePacketPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    {
        ULONG i;
        PACKETHEAD* pHead;

        pReturn = NULL;

        // For each PACKETHEAD of the block...
        //
        for (i = 0, pHead = (PACKETHEAD* )(pNew + 1);
             i < ulCount;
             ++i, ++pHead)
        {
            InitializeListHead( &pHead->linkFreePackets );
            pHead->pBlock = pNew;
            pHead->pNdisPacket = NULL;

            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            NdisAllocatePacket( &status, &pHead->pNdisPacket, pNew->hNdisPool );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocP=$%x?", status ) );
                pHead->pNdisPacket = NULL;
                continue;
            }

            if (pReturn)
            {
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreePacketToPool( pPool, pHead, FALSE );
            }
            else
            {
                // The first successfully constructed packet is returned by
                // this routine.
                //
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // NOTE: The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedPpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        PACKETBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, PACKETBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreePackets >= pBlock->ulPackets)
        {
            ULONG i;
            PACKETHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            for (i = 0, pHead = (PACKETHEAD* )(pBlock + 1);
                 i < pBlock->ulPackets;
                 ++i, ++pHead)
            {
                RemoveEntryList( &pHead->linkFreePackets );
                InitializeListHead( &pHead->linkFreePackets );

                if (pHead->pNdisPacket)
                {
                    NdisFreePacket( pHead->pNdisPacket );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurPackets -= pBlock->ulPackets;

            if (pBlock->hNdisPool)
            {
                NdisFreePacketPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\receive.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// receive.c
// RAS L2TP WAN mini-port/call-manager driver
// Receive routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


extern LONG g_lPacketsIndicated;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

SHORT
CompareSequence(
    USHORT us1,
    USHORT us2 );

VOID
ControlAcknowledged(
    IN TUNNELCB* pTunnel,
    IN USHORT usReceivedNr );

VOID
ControlAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

USHORT
ExplodeAvpHeader(
    IN CHAR* pAvp,
    IN USHORT usMaxAvpLength,
    OUT AVPINFO* pInfo );

VOID
ExplodeControlAvps(
    IN CHAR* pFirstAvp,
    IN CHAR* pEndOfBuffer,
    OUT CONTROLMSGINFO* pControl );

USHORT
ExplodeL2tpHeader(
    IN CHAR* pL2tpHeader,
    IN ULONG ulBufferLength,
    IN OUT L2TPHEADERINFO* pInfo );

USHORT
GetAvpValueFixedAch(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT CHAR** ppch );

USHORT
GetAvpValueFixedAul(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT UNALIGNED ULONG** paulArray );

USHORT
GetAvpValueFlag(
    IN AVPINFO* pAvp,
    OUT UNALIGNED BOOLEAN* pf );

USHORT
GetAvpValueUl(
    IN AVPINFO* pAvp,
    OUT UNALIGNED ULONG** ppul );

USHORT
GetAvpValueUs(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus );

USHORT
GetAvpValue2UsAndVariableAch(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus1,
    OUT UNALIGNED USHORT** ppus2,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize );

USHORT
GetAvpValueVariableAch(
    IN AVPINFO* pAvp,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize );

VOID
GetCcAvps(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl,
    OUT USHORT* pusResult,
    OUT USHORT* pusError );

VOID
HelloTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

VOID
IndicateReceived(
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulLength,
    IN LONGLONG llTimeReceived );

BOOLEAN
LookUpTunnelAndVcCbs(
    IN ADAPTERCB* pAdapter,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl,
    OUT TUNNELCB** ppTunnel,
    OUT VCCB** ppVc );

VOID
PayloadAcknowledged(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usReceivedNr );

VOID
PayloadAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

BOOLEAN
ReceiveControl(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulAvpOffset,
    IN ULONG ulAvpLength,
    IN TDIXRDGINFO* pRdg,
    IN L2TPHEADERINFO* pInfo,
    IN CONTROLMSGINFO* pControl );

BOOLEAN
ReceiveFromOutOfOrder(
    IN VCCB* pVc );

BOOLEAN
ReceivePayload(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulPayloadOffset,
    IN ULONG ulPayloadLength,
    IN L2TPHEADERINFO* pInfo );

VOID
ScheduleControlAck(
    IN TUNNELCB* pTunnel,
    IN USHORT usMsgTypeToAcknowledge );

VOID
SchedulePayloadAck(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VCCB*
VcCbFromCallId(
    IN TUNNELCB* pTunnel,
    IN USHORT usCallId );

VOID
ZombieAckIfNecessary(
    IN TUNNELCB* pTunnel,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl );


//-----------------------------------------------------------------------------
// Main receive handlers
//-----------------------------------------------------------------------------

VOID
L2tpReceive(
    IN TDIXCONTEXT* pTdix,
    IN TDIXRDGINFO* pRdg,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLength )

    // TDIXRECEIVEDG handler that receives all incoming L2TP traffic.  'PTdix'
    // is our TDI extension context.  'PRdg' points to the RDGINFO context
    // 'PBuffer' is the address of the virtual buffer associated with an NDIS
    // buffer from our pool passed to TDIX during initialization.  We are
    // responsible for eventually calling FreeBufferToPool on 'pBuffer'.
    // 'UlOffset' is the offset to the first usable data in 'pBuffer'.
    // 'UlBufferLen' is the data byte count of 'pBuffer'.
    //
{
    USHORT usXError;
    NDIS_STATUS status;
    L2TPHEADERINFO info;
    CONTROLMSGINFO* pControl;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    VCCB* pVc;
    BOOLEAN fFreeBuffer;
    ULONG ulAvpOffset;
    ULONG ulAvpLength;

    TDIXIPADDRESS* pAddress = &pRdg->source; 

    TRACE( TL_A, TM_Msg,
        ( "%sRECEIVE(%d.%d.%d.%d/%d) len=%d off=%d",
        (g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: ",
        IPADDRTRACE( ((TDIXIPADDRESS* )pAddress)->ulIpAddress ),
        (ULONG )(ntohs( ((TDIXIPADDRESS* )pAddress)->sUdpPort )),
        (ULONG )ulBufferLength, ulOffset ) );
    DUMPW( TL_A, TM_MDmp, pBuffer + ulOffset, 16 );

    pAdapter = CONTAINING_RECORD( pTdix, ADAPTERCB, tdix );

    fFreeBuffer = TRUE;
    pTunnel = NULL;
    pVc = NULL;
    pControl = NULL;

    do
    {
        // Parse the packet's L2TP header into a conveniently usable form,
        // checking that it is consistent with itself and indicates a protocol
        // version we know.
        //
        usXError = ExplodeL2tpHeader(
            pBuffer + ulOffset, ulBufferLength - ulOffset, &info );

        if (usXError != GERR_None)
        {
            // Not a coherent L2TP header.  Discard the packet.
            //
            TRACE( TL_A, TM_Recv, ( "Discard: Header" ) );
            break;
        }

        ASSERT( info.ulDataLength <= L2TP_MaxFrameSize );

        if (*info.pusBits & HBM_T)
        {
            // Explode the control message into the conveniently usable
            // 'control' form, while checking it for coherency.  This must be
            // done here so the LookUp routine can peek ahead at the assigned
            // call ID in CallDisconnNotify, if necessary.  Ugly, but that's
            // the way L2TP is defined.
            //
            pControl = ALLOC_CONTROLMSGINFO( pAdapter );
            if (pControl)
            {
                ulAvpOffset = (ULONG )(info.pData - pBuffer);
                ulAvpLength = info.ulDataLength;

                if (ulAvpLength)
                {
                    ExplodeControlAvps(
                        pBuffer + ulAvpOffset,
                        pBuffer + ulAvpOffset + ulAvpLength,
                        pControl );
                }
                else
                {
                    // No AVPs.  Most likely a ZACK.
                    //
                    pControl->usXError = GERR_BadValue;
                }
            }
        }

        // Find the tunnel and VC control blocks based on the header values.
        //
        if (!LookUpTunnelAndVcCbs(
                pAdapter, info.pusTunnelId, info.pusCallId,
                &info, pControl, &pTunnel, &pVc ))
        {
            // Invalid Tunnel-ID/Call-ID combination.  Discard the packet.
            // Zombie acknowledge may have been performed if the packet was a
            // CDN.
            //
            // The draft/RFC says the tunnel should be closed and restarted on
            // receipt of a malformed Control Connection message.  Seems
            // pretty harsh.  For now, just discard such packets.
            //
            break;
        }

        if (pTunnel)
        {
            // The UpdatePeerAddress behavior is obsolete in draft-15, but is
            // left available for now as a potential aid to interop with older
            // implementations at bakeoffs.
            //
            if (ReadFlags( &pAdapter->ulFlags ) & ACBF_UpdatePeerAddress)
            {
                BOOLEAN fChangeAddress;
                ULONG ulIpAddress;

                fChangeAddress = FALSE;

                NdisAcquireSpinLock( &pAdapter->lockTunnels );
                {
                    // Per the draft/RFC, the address of the peer is updated
                    // on each received packet.
                    //
                    if (pTunnel->address.ulIpAddress !=
                           ((TDIXIPADDRESS* )pAddress)->ulIpAddress )
                    {
                        if (ReadFlags( &pTunnel->ulFlags )
                                & TCBF_HostRouteAdded)
                        {
                            fChangeAddress = TRUE;
                            ulIpAddress = pTunnel->address.ulIpAddress;
                        }
                    }

                    pTunnel->address.ulIpAddress =
                        ((TDIXIPADDRESS* )pAddress)->ulIpAddress;
                }
                NdisReleaseSpinLock( &pAdapter->lockTunnels );

                if (fChangeAddress)
                {
                    SetFlags( &pTunnel->ulFlags, TCBF_HostRouteChanged );

                    TRACE( TL_A, TM_Recv,
                        ( "Peer changed IP address from $%08x to $%08x",
                            ulIpAddress,
                            ((TDIXIPADDRESS* )pAddress)->ulIpAddress ) );

                    ScheduleTunnelWork(
                        pTunnel, NULL, ChangeHostRoute,
                        (ULONG_PTR )ulIpAddress,
                        (ULONG_PTR )(((TDIXIPADDRESS* )pAddress)->ulIpAddress),
                        0, 0,
                        FALSE, FALSE );
                }
            }
            
            // Verify this packet comes from the right source address
            if(pTunnel->address.ulIpAddress != pAddress->ulIpAddress)
            {
                // Drop this packet
                break;
            }

            // Any message received on a tunnel resets it's Hello timer.
            //
            ResetHelloTimer( pTunnel );
        }

        if (*info.pusBits & HBM_T)
        {
            // It's a tunnel or call control packet.
            //
            if (pControl)
            {
                fFreeBuffer =
                    ReceiveControl(
                        pAdapter, pTunnel, pVc,
                        pBuffer, ulAvpOffset, ulAvpLength,
                        pRdg, &info, pControl );
            }
        }
        else
        {
            // It's a VC payload packet.
            //
            if (!pVc)
            {
                TRACE( TL_A, TM_Recv, ( "Payload w/o VC?" ) );
                break;
            }

#if 0
            // !!! This is a hack to force NDISWAN into PPP framing mode.
            // Need a cleaner way to do this, or simply have NDISWAN assume it
            // for L2TP links.  (NDISWAN bug 152167)
            //
            if (pVc->usNr == 0)
            {
                CHAR* pBufferX;

                pBufferX = GetBufferFromPool( &pAdapter->poolFrameBuffers );
                if (pBufferX)
                {
                    pBufferX[ 0 ] = (CHAR )0xFF;
                    pBufferX[ 1 ] = (CHAR )0x03;
                    pBufferX[ 2 ] = (CHAR )0xC0;
                    pBufferX[ 3 ] = (CHAR )0x21;
                    pBufferX[ 4 ] = (CHAR )0x01;
                    pBufferX[ 5 ] = (CHAR )0x06;

                    IndicateReceived( pVc, pBufferX, 0, 6, (ULONGLONG )0 );
                }
            }
#endif

            if (ReferenceCall( pVc ))
            {
                fFreeBuffer =
                    ReceivePayload(
                        pAdapter, pTunnel, pVc,
                        pBuffer,
                        (ULONG )(info.pData - pBuffer),
                        info.ulDataLength,
                        &info );

                DereferenceCall( pVc );
            }
            else
            {
                TRACE( TL_A, TM_Recv,
                    ( "Discard: Call $%p not active", pVc ) );
            }
        }
    }
    while (FALSE);

    if (pControl)
    {
        FREE_CONTROLMSGINFO( pAdapter, pControl );
    }

    if (fFreeBuffer)
    {
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
    }

    if (pTunnel)
    {
        DereferenceTunnel( pTunnel );
    }

    if (pVc)
    {
        DereferenceVc( pVc );
    }
}


BOOLEAN
ReceiveControl(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulAvpOffset,
    IN ULONG ulAvpLength,
    IN TDIXRDGINFO* pRdg,
    IN L2TPHEADERINFO* pInfo,
    IN CONTROLMSGINFO* pControl )

    // Receive processing for control packet in 'pBuffer'.  The AVPs following
    // the header start at 'ulAvpOffset' and are 'ulAvpLength' bytes long.
    // 'PBuffer' is the receive buffer TDIX retrieved with
    // 'GetBufferFromPool'.  'PAdapter' is the adapter control block.
    // 'PTunnel' and 'pVc' are the tunnel and VC control blocks associated
    // with the received buffer, or NULL if none.  'pAddress' is the IP
    // address/port of the sending peer.  'PInfo' is the exploded header
    // information.  'PControl' is the control message information, which was
    // exploded earlier.
    //
    // Returns true if caller should free 'pBuffer', or false if this routine
    // has taken ownership of the buffer and will see it's freed.
    //
{
    LIST_ENTRY* pLink;
    BOOLEAN fCallerFreesBuffer;
    SHORT sDiff;
    VCCB** ppVcs;
    ULONG ulcpVcs;

    TDIXIPADDRESS* pAddress = &pRdg->source; 

    TRACE( TL_V, TM_Recv, ( "ReceiveControl" ) );

    ASSERT( !(pVc && !pTunnel) );

    if (ulAvpLength > 0)
    {
        if (pControl->usXError != GERR_None)
        {
            // The message was incoherent or contained "mandatory" AVPs we
            // don't recognize.
            //
            if (pVc && pControl->usXError == GERR_BadValue)
            {
                // "Bad values", which includes unrecognized mandatories,
                // terminate the call.
                //
                ScheduleTunnelWork(
                    pTunnel, pVc, FsmCloseCall,
                    (ULONG_PTR )CRESULT_GeneralWithError,
                    (ULONG_PTR )pControl->usXError,
                    0, 0, FALSE, FALSE );
            }
            else if (pTunnel)
            {
                // Any other corruption terminates the tunnel.
                //
                ScheduleTunnelWork(
                    pTunnel, NULL, FsmCloseTunnel,
                    (ULONG_PTR )TRESULT_GeneralWithError,
                    (ULONG_PTR )pControl->usXError,
                    0, 0, FALSE, FALSE );
            }

            return TRUE;
        }

        if (!pTunnel)
        {
            if (*(pControl->pusMsgType) == CMT_SCCRQ
                && pControl->pusAssignedTunnelId
                && *(pControl->pusAssignedTunnelId) != 0)
            {
                // Peer wants to start a new tunnel.  Find a tunnel block with
                // peer's IP address and assigned Tunnel-ID, or create, if
                // necessary.  The returned block is linked in the adapter's
                // list and and referenced.  The reference is the one for peer
                // initiation, i.e. case (b).
                //
                // If this is a retransmit SCCRQ, this is undone after the
                // sequence check below.  It must be done/undone rather than
                // never done because each message, including retransmits,
                // must have Ns/Nr processing performed and that processing
                // requires a tunnel control block.
                //
                pTunnel = SetupTunnel(
                    pAdapter, pAddress->ulIpAddress,
                    *(pControl->pusAssignedTunnelId), FALSE );

                if (!pTunnel)
                {
                    return TRUE;
                }
            }
            else
            {
                // Don't know what tunnel the message if for and it's not a
                // "create new tunnel" request, so there's nothing useful to
                // do.  Ignore it.
                //
                TRACE( TL_A, TM_Recv,
                    ( "CMT %d w/o tunnel?", *(pControl->pusMsgType) ) );
                return TRUE;
            }
        }

        if (*(pControl->pusMsgType) == CMT_SCCRQ
            || *(pControl->pusMsgType) == CMT_SCCRP)
        {
            // The source UDP port of the received message is recorded for
            // SCCRQ and SCCRP only, i.e. for the first message received
            // from peer.
            //
            pTunnel->address.sUdpPort = pAddress->sUdpPort;
            TRACE( TL_I, TM_Recv,
                ( "Peer UDP=%d", (UINT )ntohs( pAddress->sUdpPort ) ) );

            pTunnel->myaddress.ulIpAddress = pRdg->dest.ulIpAddress;
            pTunnel->myaddress.ifindex = pRdg->dest.ifindex;

            TRACE( TL_I, TM_Recv, ("L2TP-- dest %d.%d.%d.%d ifindex %d\n", 
                IPADDRTRACE(pRdg->dest.ulIpAddress), pRdg->dest.ifindex));
        }
    }
    else if (!pTunnel)
    {
        // Peer messed up and sent an ACK on tunnel ID 0, which is impossible
        // according to the protocol.
        //
        TRACE( TL_A, TM_Recv, ( "ZACK w/o tunnel?" ) );
        return TRUE;
    }

    ASSERT( pTunnel );

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        // Do "acknowledged" handling on sends acknowledged by peer in the
        // received packet.
        //
        ControlAcknowledged( pTunnel, *(pInfo->pusNr) );

        if (ulAvpLength == 0)
        {
            // There are no AVPs so this was an acknowledgement only.  We're
            // done.
            //
            NdisReleaseSpinLock( &pTunnel->lockT );
            return TRUE;
        }

        fCallerFreesBuffer = TRUE;
        do
        {
            // Further packet processing depends on where the packet's
            // sequence number falls relative to what we've already received.
            //
            sDiff = CompareSequence( *(pInfo->pusNs), pTunnel->usNr );
            if (sDiff == 0)
            {
                // It's the expected packet.  Process it, setting up the VC
                // and popping from the out-of-order list as indicated.  The
                // 'Next Received' is incremented outside, because that step
                // should not happen on a SetupVcAsynchronously restart.
                //
                ++pTunnel->usNr;
                fCallerFreesBuffer =
                    ReceiveControlExpected( pTunnel, pVc, pBuffer, pControl );
                break;
            }
            else if (sDiff < 0)
            {
                // The received 'Next Sent' is before our 'Next Receive'.
                // Peer may have retransmitted while our acknowledge was in
                // transit, or the acknowledge may have been lost.  Schedule
                // another acknowledge.
                //
                TRACE( TL_A, TM_Recv, ( "Control re-ack" ) );
                ScheduleControlAck( pTunnel, 0 );

                if (*(pControl->pusMsgType) == CMT_SCCRQ)
                {
                    // Since SCCRQ is a duplicate, the reference added by
                    // SetupTunnel above must be undone.  In this special case
                    // the TCBF_PeerInitRef flag was never set and so need not
                    // be cleared.
                    //
                    DereferenceTunnel( pTunnel );
                }
                break;
            }
            else if (sDiff < pAdapter->sMaxOutOfOrder)
            {
                CONTROLRECEIVED* pCr;
                BOOLEAN fDiscard;

                // The packet is beyond the one we expected, but within our
                // out-of-order window.
                //
                if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
                {
                    // The tunnel is closing and the out-of-order queue has
                    // been flushed, so just discard the packet.
                    //
                    TRACE( TL_A, TM_Recv,
                        ( "Control discarded: ooo but closing" ) );
                    break;
                }

                // Allocate a control-received context
                // and queue the packet on the out-of-order list.
                //
                pCr = ALLOC_CONTROLRECEIVED( pAdapter );
                if (!pCr)
                {
                    ASSERT( !"Alloc CR?" );
                    break;
                }

                // Fill in the context with the relevant packet information.
                //
                pCr->usNs = *(pInfo->pusNs);
                pCr->pVc = pVc;
                pCr->pBuffer = pBuffer;
                NdisMoveMemory(
                    &pCr->control, pControl, sizeof(pCr->control) );

                if (pCr->pVc)
                {
                    // Add a VC reference covering the reference stored in the
                    // context, which will be removed when the context is
                    // freed.
                    //
                    ReferenceVc( pCr->pVc );
                }

                // Find the first link on the out-of-order list with an 'Ns'
                // greater than that in the received message, or the head if
                // none.
                //
                fDiscard = FALSE;
                for (pLink = pTunnel->listOutOfOrder.Flink;
                     pLink != &pTunnel->listOutOfOrder;
                     pLink = pLink->Flink)
                {
                    CONTROLRECEIVED* pThisCr;
                    SHORT sThisDiff;

                    pThisCr = CONTAINING_RECORD(
                        pLink, CONTROLRECEIVED, linkOutOfOrder );

                    sThisDiff = CompareSequence( pCr->usNs, pThisCr->usNs );

                    if (sThisDiff < 0)
                    {
                        break;
                    }

                    if (sThisDiff == 0)
                    {
                        // It's a retransmit that's already on our queue.
                        //
                        if (pCr->pVc)
                        {
                            DereferenceVc( pCr->pVc );
                        }

                        FREE_CONTROLRECEIVED( pAdapter, pCr );
                        fDiscard = TRUE;
                        break;
                    }
                }

                if (fDiscard)
                {
                    break;
                }

                // Queue up the context as out-of-order.
                //
                TRACE( TL_I, TM_Recv,
                    ( "Control %d out-of-order %d",
                    *(pInfo->pusNs), (LONG )sDiff ) );
                InsertBefore( &pCr->linkOutOfOrder, pLink );
                fCallerFreesBuffer = FALSE;
                break;
            }
            DBG_else
            {
                TRACE( TL_A, TM_Recv,
                    ( "Control discarded: Beyond ooo" ) );
            }
        }
        while (FALSE);

        // Complete any VCs listed as completing.
        //
        CompleteVcs( pTunnel );
    }
    NdisReleaseSpinLock( &pTunnel->lockT );

    return fCallerFreesBuffer;
}


BOOLEAN
ReceiveControlExpected(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl )

    // Called to do packet processing when the packet received is the expected
    // 'Next Receive' packet.  'PBuffer' is the receive buffer.  'PTunnel' is
    // the valid tunnel control block.  'PVc' is the call's VC control block
    // and may be NULL, if the VC for the call has not yet been set up.
    // 'PControl' is the expoded control message information.
    //
    // Returns true if the buffer should be freed by caller, false if it was
    // queued for further processing.
    //
    // IMPORTANT: Caller must hold the 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;
    BOOLEAN fProcessed;
    SHORT sDiff;

    pAdapter = pTunnel->pAdapter;

    // Schedule an acknowledge-only packet to be sent if no outgoing traffic
    // appears to piggyback on within a reasonable time.  Note this occurs
    // even if the asynchronous VC set up was invoked.  Ns/Nr processing must
    // occur before any data processing that may cause delays.
    //
    ScheduleControlAck( pTunnel, *(pControl->pusMsgType) );

    // Pass the packet to the control FSMs.
    //
    fProcessed = FsmReceive( pTunnel, pVc, pBuffer, pControl );
    if (fProcessed)
    {
        // The VC is setup and the packet has been processed.  See if any
        // packets on the received out-of-order queue can now be processed.
        //
        for (;;)
        {
            LIST_ENTRY* pFirstLink;
            CONTROLRECEIVED* pFirstCr;
            BOOLEAN fOutOfOrderProcessed;

            pFirstLink = pTunnel->listOutOfOrder.Flink;
            if (pFirstLink == &pTunnel->listOutOfOrder)
            {
                break;
            }

            pFirstCr = CONTAINING_RECORD(
                pFirstLink, CONTROLRECEIVED, linkOutOfOrder );

            sDiff = CompareSequence( pFirstCr->usNs, pTunnel->usNr );
            if (sDiff == 0)
            {
                // Yes, it's the next expected packet.  Update 'Next Receive'
                // and pass the packet to the control FSMs.
                //
                TRACE( TL_I, TM_Recv,
                    ( "Control %d from queue", (UINT )pFirstCr->usNs ) );
                RemoveEntryList( pFirstLink );
                InitializeListHead( pFirstLink );

                ++pTunnel->usNr;
                fOutOfOrderProcessed =
                    FsmReceive(
                        pTunnel, pFirstCr->pVc,
                        pFirstCr->pBuffer, &pFirstCr->control );

                ScheduleControlAck(
                    pTunnel, *(pFirstCr->control.pusMsgType) );

                if (fOutOfOrderProcessed)
                {
                    FreeBufferToPool(
                        &pAdapter->poolFrameBuffers, pFirstCr->pBuffer, TRUE );
                }

                if (pFirstCr->pVc)
                {
                    DereferenceVc( pFirstCr->pVc );
                }

                FREE_CONTROLRECEIVED( pAdapter, pFirstCr );
            }
            else if (sDiff > 0)
            {
                // No, there's still some missing.
                //
                TRACE( TL_I, TM_Recv,
                    ( "Control %d still missing", pTunnel->usNr ) );
                break;
            }
            else
            {
                ASSERT( "Old control queued?" );
                break;
            }
        }
    }

    return fProcessed;
}


BOOLEAN
ReceivePayload(
    IN ADAPTERCB* pAdapter,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulPayloadOffset,
    IN ULONG ulPayloadLength,
    IN L2TPHEADERINFO* pInfo )

    // Receive processing for payload in 'pBuffer' of 'ulPayloadLength' bytes
    // starting at offset 'ulPayloadOffset'.  'PBuffer' is the receive buffer
    // TDIX retrieved with 'GetBufferFromPool'.  'PAdapter, 'pTunnel' and
    // 'PVc' are the adapter, tunnel, and VC control blocks associated with
    // the received buffer.  'PInfo' is the exploded header information.
    //
    // Returns true if caller should free 'pBuffer', or false if this routine
    // has taken ownership of the buffer and will see it's freed.
    //
{
    LONGLONG llTimeReceived;
    BOOLEAN fCallerFreesBuffer;

    TRACE( TL_V, TM_Recv, ( "ReceivePayload" ) );

    if (!pTunnel || !pVc)
    {
        // Both control blocks are always required to receive payload.
        //
        TRACE( TL_A, TM_Recv, ( "Discard: No CB" ) );
        return TRUE;
    }

    // Note the time if client's call parameters indicated interest in time
    // received.
    //
    if (ReadFlags( &pVc->ulFlags ) & VCBF_IndicateTimeReceived)
    {
        NdisGetCurrentSystemTime( (LARGE_INTEGER* )&llTimeReceived );
    }
    else
    {
        llTimeReceived = 0;
    }

    if (!(ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing) || !pInfo->pusNr)
    {
        DBG_if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
            TRACE( TL_A, TM_Recv, ( "No Nr field?" ) );

        if (ulPayloadLength > 0)
        {
            // Flow control was disabled during negotiation.  This should be
            // extremely rare, since a compliant peer MUST implement flow
            // control.
            //
            IndicateReceived(
                pVc, pBuffer, ulPayloadOffset,
                ulPayloadLength, llTimeReceived );
            return FALSE;
        }
        else
        {
            NdisAcquireSpinLock( &pVc->lockV );
            {
                ++pVc->stats.ulRecdZlbs;
            }
            NdisReleaseSpinLock( &pVc->lockV );
            return TRUE;
        }
    }

    fCallerFreesBuffer = TRUE;
    NdisAcquireSpinLock( &pVc->lockV );
    do
    {
        SHORT sDiff;

        // All R-bit handling occurs first.  Peer sends a packet with the
        // R-bit set to indicate that all packets expected between the last
        // packet and this packet should be assumed lost.
        //
        if (*(pInfo->pusBits) & HBM_R)
        {
            ++pVc->stats.ulRecdResets;

            sDiff = CompareSequence( *(pInfo->pusNs), pVc->usNr );
            if (sDiff > 0)
            {
                TRACE( TL_I, TM_Recv,
                    ( "Reset Nr=%d from %d",
                    (LONG )*(pInfo->pusNs), (LONG )pVc->usNr ) );

                pVc->usNr = *(pInfo->pusNs);
            }
            else
            {
                ++pVc->stats.ulRecdResetsIgnored;

                TRACE( TL_I, TM_Recv,
                    ( "Reset Nr=%d from %d ignored",
                    (LONG )*(pInfo->pusNs), (LONG )pVc->usNr ) );
            }
        }

        // Do "acknowledged" handling on sends acknowledged by peer in the
        // received packet.
        //
        PayloadAcknowledged( pTunnel, pVc, *(pInfo->pusNr) );

        // If there's no payload and the R-bit is not set, this was an
        // acknowledgement only and we're done.
        //
        if (ulPayloadLength == 0)
        {
            ++pVc->stats.ulRecdZlbs;

            if (*(pInfo->pusBits) & HBM_R)
            {
                BOOLEAN fReceivedFromOutOfOrder;

                // Indicate up any packet on the out-of-order list made
                // receivable by the R-bit reset.
                //
                fReceivedFromOutOfOrder = FALSE;
                while (ReceiveFromOutOfOrder( pVc ))
                {
                    fReceivedFromOutOfOrder = TRUE;
                }

                if (fReceivedFromOutOfOrder)
                {
                    // Schedule an acknowledge-only packet to be sent if no
                    // outgoing traffic appears to piggyback on within a
                    // reasonable time.
                    //
                    SchedulePayloadAck( pTunnel, pVc );
                }
            }

            break;
        }

        DBG_if (pInfo->pusNs && pInfo->pusNr)
        {
            TRACE( TL_N, TM_Recv, ( "len=%d Ns=%d Nr=%d",
                (ULONG )*(pInfo->pusLength),
                (ULONG )*(pInfo->pusNs),
                (ULONG )*(pInfo->pusNr) ) );
        }

        // Further packet processing depends on where the packet's sequence
        // number falls relative to what we've already received.
        //
        sDiff = CompareSequence( *(pInfo->pusNs), pVc->usNr );
        if (sDiff == 0)
        {
            // It's the next expected packet.  Update 'Next Receive' and
            // indicate the payload received to the driver above.
            //
            pVc->usNr = *(pInfo->pusNs) + 1;

            NdisReleaseSpinLock( &pVc->lockV );
            {
                IndicateReceived(
                    pVc, pBuffer, ulPayloadOffset, ulPayloadLength,
                    llTimeReceived );
            }
            NdisAcquireSpinLock( &pVc->lockV );

            // Indicate up any packets on the out-of-order list that were
            // waiting for this one.
            //
            while (ReceiveFromOutOfOrder( pVc ))
                ;

            // Schedule an acknowledge-only packet to be sent if no outgoing
            // traffic appears to piggyback on within a reasonable time.
            //
            SchedulePayloadAck( pTunnel, pVc );
        }
        else if (sDiff < 0)
        {
            // The received 'Next Sent' is before our 'Next Receive'.  Maybe
            // an out-of-order packet we didn't wait for long enough.  It's
            // useless at this point.
            //
            TRACE( TL_A, TM_Recv, ( "Payload discarded: Old Ns" ) );
            break;
        }
        else if (sDiff < pAdapter->sMaxOutOfOrder)
        {
            LIST_ENTRY* pLink;
            PAYLOADRECEIVED* pPr;
            BOOLEAN fDiscard;

            TRACE( TL_I, TM_Recv,
                ( "%d out-of-order %d", *(pInfo->pusNs), (LONG )sDiff ) );

            // The packet is beyond the one we expected, but within our
            // out-of-order window.  Allocate a payload-received context and
            // queue it up on the out-of-order list.
            //
            pPr = ALLOC_PAYLOADRECEIVED( pAdapter );
            if (!pPr)
            {
                TRACE( TL_A, TM_Recv, ( "Alloc PR?" ) );
                break;
            }

            // Fill in the context with the relevant packet information.
            //
            pPr->usNs = *(pInfo->pusNs);
            pPr->pBuffer = pBuffer;
            pPr->ulPayloadOffset = ulPayloadOffset;
            pPr->ulPayloadLength = ulPayloadLength;
            pPr->llTimeReceived = llTimeReceived;

            // Queue up the context on the out-of-order list, keeping the list
            // correctly sorted by 'Ns'.
            //
            fDiscard = FALSE;
            for (pLink = pVc->listOutOfOrder.Flink;
                 pLink != &pVc->listOutOfOrder;
                 pLink = pLink->Flink)
            {
                PAYLOADRECEIVED* pThisPr;
                SHORT sThisDiff;

                pThisPr = CONTAINING_RECORD(
                    pLink, PAYLOADRECEIVED, linkOutOfOrder );

                sThisDiff = CompareSequence( pPr->usNs, pThisPr->usNs );

                if (sThisDiff < 0)
                {
                    break;
                }

                if (sThisDiff == 0)
                {
                    // This shouldn't happen because payloads are not
                    // retransmitted, but do the right thing just in case.
                    //
                    TRACE( TL_A, TM_Recv, ( "Payload on ooo queue?" ) );
                    fDiscard = TRUE;
                    break;
                }
            }

            if (fDiscard)
            {
                FREE_PAYLOADRECEIVED( pAdapter, pPr );
                break;
            }

            InsertBefore( &pPr->linkOutOfOrder, pLink );
        }
        else
        {
            // The packet is beyond the one we expected and outside our
            // out-of-order window.  Discard it.
            //
            TRACE( TL_A, TM_Recv,
                ( "Out-of-order %d too far" , (LONG )sDiff ) );

            break;
        }

        fCallerFreesBuffer = FALSE;
    }
    while (FALSE);
    NdisReleaseSpinLock( &pVc->lockV );

    return fCallerFreesBuffer;
}


//-----------------------------------------------------------------------------
// Receive utility routines (alphabetically)
//-----------------------------------------------------------------------------

SHORT
CompareSequence(
    USHORT us1,
    USHORT us2 )

    // Returns the "logical" difference between sequence numbers 'us1' and
    // 'us2' accounting for the possibility of rollover.
    //
{
    USHORT usDiff = us1 - us2;

    if (usDiff == 0)
        return 0;

    if (usDiff < 0x4000)
        return (SHORT )usDiff;

    return -((SHORT )(0 - usDiff));
}


VOID
ControlAcknowledged(
    IN TUNNELCB* pTunnel,
    IN USHORT usReceivedNr )

    // Dequeues and cancels the timer of all control-sent contexts in the
    // tunnel's 'listSendsOut' queue with 'Next Sent' less than
    // 'usReceivedNr'.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    ADAPTERCB* pAdapter;
    BOOLEAN fFoundOne;

    pAdapter = pTunnel->pAdapter;
    fFoundOne = FALSE;

    while (!IsListEmpty( &pTunnel->listSendsOut ))
    {
        CONTROLSENT* pCs;
        LIST_ENTRY* pLink;

        pLink = pTunnel->listSendsOut.Flink;
        pCs = CONTAINING_RECORD( pLink, CONTROLSENT, linkSendsOut );

        // The list is in 'Ns' order so as soon as a non-acknowledge is hit
        // we're done.
        //
        if (CompareSequence( pCs->usNs, usReceivedNr ) >= 0)
        {
            break;
        }

        fFoundOne = TRUE;

        // Remove the context from the "outstanding send" list and cancel the
        // associated timer.  Doesn't matter if the cancel fails because the
        // expire handler will recognize that the context is not linked into
        // the "out" list and do nothing.
        //
        RemoveEntryList( pLink );
        InitializeListHead( pLink );
        TimerQCancelItem( pTunnel->pTimerQ, pCs->pTqiSendTimeout );

        // Per the draft/RFC, adjustments to the send window and send timeouts
        // are necessary.  Per Karn's Algorithm, if the packet was
        // retransmitted it is useless for timeout adjustment because it's not
        // known if peer responded to the original send or the retransmission.
        //
        if (pCs->ulRetransmits == 0)
        {
            AdjustTimeoutsAtAckReceived(
                pCs->llTimeSent,
                pAdapter->ulMaxSendTimeoutMs,
                &pTunnel->ulSendTimeoutMs,
                &pTunnel->ulRoundTripMs,
                &pTunnel->lDeviationMs );
        }

        // See if it's time to open the send window a bit further.
        //
        AdjustSendWindowAtAckReceived(
            pTunnel->ulMaxSendWindow,
            &pTunnel->ulAcksSinceSendTimeout,
            &pTunnel->ulSendWindow );

        TRACE( TL_N, TM_Send,
            ( "T%d: ACK(%d) new rtt=%d dev=%d ato=%d sw=%d",
            (ULONG )pTunnel->usTunnelId, (ULONG )pCs->usNs,
            pTunnel->ulRoundTripMs, pTunnel->lDeviationMs,
            pTunnel->ulSendTimeoutMs, pTunnel->ulSendWindow ) );

        // Execute any "on ACK" options and note that delayed action
        // processing is now required.
        //
        if (pCs->ulFlags & CSF_TunnelIdleOnAck)
        {
            TRACE( TL_N, TM_Send, ( "Tunnel idle on ACK" ) );
            ScheduleTunnelWork(
                pTunnel, NULL, CloseTunnel,
                0, 0, 0, 0, FALSE, FALSE );
        }
        else if (pCs->ulFlags & CSF_CallIdleOnAck)
        {
            TRACE( TL_N, TM_Send, ( "Call idle on ACK" ) );
            ASSERT( pCs->pVc );
            ScheduleTunnelWork(
                pTunnel, pCs->pVc, CloseCall,
                0, 0, 0, 0, FALSE, FALSE );
        }

        if (pCs->ulFlags & CSF_Pending)
        {
            // The context is queued for retransmission, so de-queue it.  In
            // this state the context has already been assumed "not
            // outstanding" so no need to adjust the counter as below.
            //
            pCs->ulFlags &= ~(CSF_Pending);
        }
        else
        {
            // The context is not queued for retranmission, so adjust the
            // counter to indicate it is no longer outstanding.
            //
            --pTunnel->ulSendsOut;
        }

        // Remove the reference corresponding to linkage in the "outstanding
        // send" list.
        //
        DereferenceControlSent( pCs );
    }

    if (fFoundOne)
    {
        // See if any sends were pending on a closed send window.
        //
        ScheduleTunnelWork(
            pTunnel, NULL, SendPending,
            0, 0, 0, 0, FALSE, FALSE );
    }
}


VOID
ControlAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler that fires when it's time to stop waiting for an
    // outgoing control packet on which to piggyback an acknowledge.
    //
{
    TUNNELCB* pTunnel;
    ADAPTERCB* pAdapter;
    BOOLEAN fSendAck;

    TRACE( TL_N, TM_Recv,
        ( "ControlAckTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.
    //
    pTunnel = (TUNNELCB* )pContext;
    pAdapter = pTunnel->pAdapter;

    if (event == TE_Expire)
    {
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (pItem == pTunnel->pTqiDelayedAck)
            {
                pTunnel->pTqiDelayedAck = NULL;
                fSendAck = TRUE;
            }
            else
            {
                fSendAck = FALSE;
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );

        if (fSendAck)
        {
            // The timer expired and was not been cancelled or terminated
            // while the expire processing was being set up, meaning it's time
            // to send a zero-AVP control packet to give peer the acknowledge
            // we were hoping to piggyback onto a random outgoing control
            // packet.
            //
            ScheduleTunnelWork(
                pTunnel, NULL, SendControlAck, 0, 0, 0, 0, FALSE, FALSE );
        }
        DBG_else
        {
            TRACE( TL_I, TM_Send, ( "CAck aborted" ) );
        }
    }

    // Free the timer event descriptor and remove the reference covering the
    // scheduled timer.
    //
    FREE_TIMERQITEM( pAdapter, pItem );
    DereferenceTunnel( pTunnel );
}


VOID
PayloadAckTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler that fires when it's time to stop waiting for an
    // outgoing payload packet on which to piggyback an acknowledge.
    //
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    BOOLEAN fSendAck;

    TRACE( TL_N, TM_Recv,
        ( "PayloadAckTimerEvent(%s)=$%p",
        TimerQPszFromEvent( event ), pItem ) );

    // Unpack context information.
    //
    pVc = (VCCB* )pContext;
    pAdapter = pVc->pAdapter;

    if (event == TE_Expire)
    {
        if (ReferenceCall( pVc ))
        {
            NdisAcquireSpinLock( &pVc->lockV );
            {
                if (pItem == pVc->pTqiDelayedAck)
                {
                    fSendAck = TRUE;
                    pVc->pTqiDelayedAck = NULL;
                    ++pVc->stats.ulSentZAcks;
                }
                else
                {
                    fSendAck = FALSE;
                }
            }
            NdisReleaseSpinLock( &pVc->lockV );

            if (fSendAck)
            {
                // The timer expired and was not been cancelled or terminated
                // while the expire processing was being set up, plus the call
                // is still up, meaning it's time to send a zero-AVP control
                // packet to give peer the acknowledge we were hoping to
                // piggyback onto a random outgoing payload packet.
                //
                ScheduleTunnelWork(
                    pVc->pTunnel, pVc, SendPayloadAck,
                    0, 0, 0, 0, FALSE, FALSE );
            }
            else
            {
                TRACE( TL_I, TM_Send, ( "PAck aborted" ) );
                DereferenceCall( pVc );
            }
        }
        else
        {
            NdisAcquireSpinLock( &pVc->lockV );
            {
                if (pItem == pVc->pTqiDelayedAck)
                {
                    pVc->pTqiDelayedAck = NULL;
                }
            }
            NdisReleaseSpinLock( &pVc->lockV );
        }
    }

    // Free the timer event descriptor and remove the reference covering the
    // scheduled timer.
    //
    FREE_TIMERQITEM( pAdapter, pItem );
    DereferenceVc( pVc );
}


USHORT
ExplodeAvpHeader(
    IN CHAR* pAvp,
    IN USHORT usMaxAvpLength,
    OUT AVPINFO* pInfo )

    // Fills caller's '*pInfo' with the addresses of the various fields in the
    // AVP header at 'pAvp'.  The byte order of the fields in 'pAvpHeader',
    // with the exception of the Value field, are flipped to host-byte-order
    // in place.  The length and value length are extracted.  'UsMaxAvpLength'
    // is the maximum size of the AVP in bytes.
    //
    // Returns GERR_None if 'pAvpHeader' is a coherent AVP header, or a
    // GERR_* failure code.
    //
{
    UNALIGNED USHORT* pusCur;
    USHORT usBits;

    if (usMaxAvpLength < L2TP_AvpHeaderSize)
    {
        TRACE( TL_A, TM_Recv, ( "Avp: Short buffer?" ) );
        return GERR_BadLength;
    }

    pusCur = (UNALIGNED USHORT* )pAvp;

    // The first 2 bytes contain bits that indicate the presence/absence of
    // the other header fields.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusBits = pusCur;
    usBits = *pusCur;
    ++pusCur;

    // As of draft-09, AVPs with reserved bits not set to zero MUST be treated
    // as unrecognized.
    //
    if ((usBits & ABM_Reserved) != 0)
    {
        return GERR_BadValue;
    }

    // Extract the Overall Length sub-field and verify that it says the AVP is
    // at least as long as the fixed portion of the header.
    //
    pInfo->usOverallLength = (usBits & ABM_OverallLength);
    if (pInfo->usOverallLength > usMaxAvpLength
        || pInfo->usOverallLength < L2TP_AvpHeaderSize)
    {
        TRACE( TL_A, TM_Recv, ( "Avp: Bad length?" ) );
        return GERR_BadLength;
    }

    // Vendor-ID field.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusVendorId = pusCur;
    ++pusCur;

    // Attribute field.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusAttribute = pusCur;
    ++pusCur;

    // Value field.
    //
    pInfo->pValue = (CHAR* )pusCur;
    pInfo->usValueLength = pInfo->usOverallLength - L2TP_AvpHeaderSize;

    return GERR_None;
}


VOID
ExplodeControlAvps(
    IN CHAR* pFirstAvp,
    IN CHAR* pEndOfBuffer,
    OUT CONTROLMSGINFO* pControl )

    // Fills caller's '*pControl' buffer with the exploded interpretation of
    // the message with AVP list starting at 'pFirstAvp'.  'PEndOfBuffer'
    // points to the first byte beyond the end of the received buffer.  The
    // AVP values are returned as addresses of the corresponding value field
    // in the AVPs.  Fields not present are returned as NULL.  The byte order
    // of the fields in 'pControl' is flipped to host-byte-order in place.
    // The values themselves are not validated, only the message format.  Sets
    // 'pControl->usXError' to GERR_None if successful, or the GERR_* failure
    // code.
    //
{
    USHORT usXError;
    AVPINFO avp;
    CHAR* pCur;

    DUMPW( TL_A, TM_MDmp, pFirstAvp, (ULONG )(pEndOfBuffer - pFirstAvp) );

    NdisZeroMemory( pControl, sizeof(*pControl) );
    pCur = pFirstAvp;

    // Read and validate the Message Type AVP, which is the first AVP of all
    // control messages.
    //
    usXError = ExplodeAvpHeader( pCur, (USHORT )(pEndOfBuffer - pCur), &avp );
    if (usXError != GERR_None)
    {
        TRACE( TL_A, TM_CMsg, ( "Bad AVP header" ) );
        pControl->usXError = usXError;
        return;
    }

    if (*(avp.pusAttribute) != ATTR_MsgType
        || *(avp.pusVendorId) != 0
        || (*(avp.pusBits) & ABM_H))
    {
        TRACE( TL_A, TM_CMsg, ( "Bad MsgType AVP" ) );
        pControl->usXError = GERR_BadValue;
        return;
    }

    usXError = GetAvpValueUs( &avp, &pControl->pusMsgType );
    if (usXError != GERR_None)
    {
        TRACE( TL_A, TM_CMsg, ( "Bad MsgType Us" ) );
        pControl->usXError = usXError;
        return;
    }

    pCur += avp.usOverallLength;

    TRACE( TL_A, TM_CMsg, ( "*MsgType=%s",
        MsgTypePszFromUs( *(pControl->pusMsgType) ) ) );

    // Make sure the message type code is valid, and if it is, explode any
    // additional AVPs in the message.
    //
    switch (*(pControl->pusMsgType))
    {
        case CMT_SCCRQ:
        case CMT_SCCRP:
        case CMT_SCCCN:
        case CMT_StopCCN:
        case CMT_Hello:
        {
            // Mark the messages above as tunnel control rather than call
            // control.
            //
            pControl->fTunnelMsg = TRUE;

            // ...fall thru...
        }

        case CMT_OCRQ:
        case CMT_OCRP:
        case CMT_OCCN:
        case CMT_ICRQ:
        case CMT_ICRP:
        case CMT_ICCN:
        case CMT_CDN:
        case CMT_WEN:
        case CMT_SLI:
        {
            // Walk the list of AVPs, exploding each AVP in turn.  Excepting
            // the Message Type, the order of the AVPs is not defined.
            //
            for ( ; pCur < pEndOfBuffer; pCur += avp.usOverallLength )
            {
                usXError = ExplodeAvpHeader(
                    pCur, (USHORT )(pEndOfBuffer - pCur), &avp );
                if (usXError != GERR_None)
                {
                    break;
                }

                if (*avp.pusVendorId != 0)
                {
                    TRACE( TL_A, TM_CMsg,
                        ( "Non-0 Vendor ID %d", *avp.pusVendorId ) );

                    // The AVP has a non-IETF vendor ID, and we don't
                    // recognize any.  If the AVP is optional, just ignore it.
                    // If it's mandatory, then fail.
                    //
                    if (*avp.pusBits & ABM_M)
                    {
                        usXError = GERR_BadValue;
                        break;
                    }
                    continue;
                }

                if (*avp.pusBits & ABM_H)
                {
                    BOOLEAN fIgnore;

                    TRACE( TL_A, TM_CMsg,
                        ( "Hidden bit on AVP %d",
                        (LONG )(*avp.pusAttribute) ) );

                    // !!! Remove this when H-bit support is added.
                    //
                    switch (*avp.pusAttribute)
                    {
                        case ATTR_ProxyAuthName:
                        case ATTR_ProxyAuthChallenge:
                        case ATTR_ProxyAuthId:
                        case ATTR_ProxyAuthResponse:
                        case ATTR_DialedNumber:
                        case ATTR_DialingNumber:
                        case ATTR_SubAddress:
                        case ATTR_InitialLcpConfig:
                        case ATTR_LastSLcpConfig:
                        case ATTR_LastRLcpConfig:
                        case ATTR_Accm:
                        case ATTR_PrivateGroupId:
                        {
                            fIgnore = TRUE;
                            break;
                        }

                        default:
                        {
                            fIgnore = FALSE;
                            break;
                        }
                    }

                    if (fIgnore)
                    {
                        TRACE( TL_A, TM_CMsg, ( "Hidden AVP ignored" ) );
                        break;
                    }

                    // The AVP has the "hidden" bit set meaning the value is
                    // hashed with MD5.  This requires a shared secret from
                    // the tunnel authentication, which we don't do.  If the
                    // AVP is optional, just ignore it.  If it's mandatory,
                    // fail.
                    //
                    if (*avp.pusBits & ABM_M)
                    {
                        usXError = GERR_BadValue;
                        break;
                    }
                    continue;
                }

                switch (*avp.pusAttribute)
                {
                    case ATTR_Result:
                    {
                        usXError = GetAvpValue2UsAndVariableAch(
                            &avp,
                            &pControl->pusResult,
                            &pControl->pusError,
                            &pControl->pchResultMsg,
                            &pControl->usResultMsgLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Result=%d,%d",
                                (ULONG )(*(pControl->pusResult)),
                                (ULONG )(*(pControl->pusError)) ) );
                        }

                        break;
                    }

                    case ATTR_HostName:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchHostName,
                            &pControl->usHostNameLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*HostName" ) );
                        }

                        break;
                    }

                    case ATTR_ProtocolVersion:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusProtocolVersion );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ProtVer=$%04x",
                                (ULONG )(*(pControl->pusProtocolVersion)) ) );
                        }

                        break;
                    }

                    case ATTR_FramingCaps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulFramingCaps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*FramingCaps=$%08x",
                                *(pControl->pulFramingCaps) ) );
                        }

                        break;
                    }

                    case ATTR_BearerCaps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulBearerCaps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*BearerCaps=$%08x",
                                *(pControl->pulBearerCaps) ) );
                        }

                        break;
                    }

                    case ATTR_TieBreaker:
                    {
                        usXError = GetAvpValueFixedAch(
                            &avp, 8, &pControl->pchTieBreaker );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Tiebreaker" ) );
                        }

                        break;
                    }

                    case ATTR_AssignedTunnelId:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusAssignedTunnelId );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*AssignTid=%d",
                                (ULONG )(*(pControl->pusAssignedTunnelId)) ) );
                        }

                        break;
                    }

                    case ATTR_RWindowSize:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusRWindowSize );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*RWindow=%d",
                                (ULONG )(*(pControl->pusRWindowSize)) ) );
                        }

                        break;
                    }

                    case ATTR_AssignedCallId:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusAssignedCallId );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*AssignCid=%d",
                                (ULONG )(*(pControl->pusAssignedCallId)) ) );
                        }

                        break;
                    }

                    case ATTR_CallSerialNumber:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulCallSerialNumber );

                        if (usXError == GERR_BadLength)
                        {
                            // Be tolerant here because the meaning in the
                            // draft has changed a few times.
                            //
                            TRACE( TL_A, TM_CMsg,
                                ( "Weird CallSerial# length ignored" ) );
                            usXError = GERR_None;
                        }

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*CallSerial#" ) );
                        }

                        break;
                    }

                    case ATTR_MinimumBps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulMinimumBps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*MinBps=%d",
                                *(pControl->pulMinimumBps) ) );
                        }

                        break;
                    }

                    case ATTR_MaximumBps:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulMaximumBps );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*MaxBps=%d",
                                *(pControl->pulMaximumBps) ) );
                        }

                        break;
                    }

                    case ATTR_BearerType:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulBearerType );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*BearerType=$%08x",
                                *(pControl->pulBearerType) ) );
                        }

                        break;
                    }

                    case ATTR_FramingType:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulFramingType );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*FramingType=$%08x",
                                *(pControl->pulFramingType) ) );
                        }

                        break;
                    }

                    case ATTR_PacketProcDelay:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusPacketProcDelay );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*PPD=%d",
                                (ULONG )(*(pControl->pusPacketProcDelay)) ) );
                        }

                        break;
                    }

                    case ATTR_DialedNumber:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchDialedNumber,
                            &pControl->usDialedNumberLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Dialed#" ) );
                        }

                        break;
                    }

                    case ATTR_DialingNumber:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchDialingNumber,
                            &pControl->usDialingNumberLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Dialing#" ) );
                        }

                        break;
                    }

                    case ATTR_SubAddress:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchSubAddress,
                            &pControl->usSubAddressLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*SubAddr" ) );
                        }

                        break;
                    }

                    case ATTR_TxConnectSpeed:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulTxConnectSpeed );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*TxSpeed=%d",
                                *(pControl->pulTxConnectSpeed) ) );
                        }

                        break;
                    }

                    case ATTR_PhysicalChannelId:
                    {
                        usXError = GetAvpValueUl(
                            &avp, &pControl->pulPhysicalChannelId );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*PhysChannelId=$%08x",
                                *(pControl->pulPhysicalChannelId) ) );
                        }

                        break;
                    }

                    case ATTR_Challenge:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchChallenge,
                            &pControl->usChallengeLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Challenge" ) );
                        }

                        break;
                    }

                    case ATTR_ChallengeResponse:
                    {
                        usXError = GetAvpValueFixedAch(
                            &avp, 16, &pControl->pchResponse );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ChallengeResp" ) );
                        }

                        break;
                    }

                    case ATTR_ProxyAuthType:
                    {
                        usXError = GetAvpValueUs(
                            &avp, &pControl->pusProxyAuthType );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ProxyAuthType=%d",
                                (ULONG )(*(pControl->pusProxyAuthType)) ) );
                        }

                        break;
                    }

                    case ATTR_ProxyAuthResponse:
                    {
                        usXError = GetAvpValueVariableAch(
                            &avp,
                            &pControl->pchProxyAuthResponse,
                            &pControl->usProxyAuthResponseLength );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*ProxyAuthResponse" ) );
                        }

                        break;
                    }

                    case ATTR_CallErrors:
                    {
                        usXError = GetAvpValueFixedAul(
                            &avp, 6, &pControl->pulCallErrors );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*CallErrors" ) );
                        }

                        break;
                    }

                    case ATTR_Accm:
                    {
                        usXError = GetAvpValueFixedAul(
                            &avp, 2, &pControl->pulAccm );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*Accm" ) );
                        }

                        break;
                    }

                    case ATTR_SequencingRequired:
                    {
                        usXError = GetAvpValueFlag(
                            &avp, &pControl->fSequencingRequired );

                        DBG_if (usXError == GERR_None)
                        {
                            TRACE( TL_A, TM_CMsg, ( "*SeqReqd" ) );
                        }
                        break;
                    }

                    default:
                    {
                        // The AVP is not one we handle.  If optional, just
                        // ignore it, but if mandatory, fail.
                        //
                        TRACE( TL_A, TM_CMsg,
                            ( "*AVP %d ignored", (ULONG )*avp.pusAttribute ) );

                        if (*avp.pusBits & ABM_M)
                        {
                            if (*avp.pusAttribute <= ATTR_MAX)
                            {
                                // This is a bug in the peer, but ignoring it
                                // is the best action.
                                //
                                TRACE( TL_A, TM_CMsg,
                                    ( "Known AVP %d marked mandatory ignored",
                                      (LONG )(*avp.pusAttribute) ) );
                            }
                            else
                            {
                                usXError = GERR_BadValue;
                            }
                        }
                        break;
                    }
                }

                if (usXError != GERR_None)
                {
                    break;
                }
            }

            ASSERT( pCur <= pEndOfBuffer );
            break;
        }

        default:
        {
            TRACE( TL_A, TM_CMsg, ( "Unknown CMT %d",
                (ULONG )*(pControl->pusMsgType) ) );
            usXError = GERR_BadValue;
            break;
        }
    }

    DBG_if (usXError != GERR_None)
        TRACE( TL_A, TM_CMsg, ( "XError=%d", (UINT )usXError ) );

    pControl->usXError = usXError;
}


USHORT
ExplodeL2tpHeader(
    IN CHAR* pL2tpHeader,
    IN ULONG ulBufferLength,
    IN OUT L2TPHEADERINFO* pInfo )

    // Fills caller's '*pInfo' with the addresses of the various fields in the
    // L2TP header at 'pL2tpHeader'.  Fields not present are returned as NULL.
    // The byte order of the fields in 'pL2tpHeader' is flipped to
    // host-byte-order in place.  'UlBufferLength' is the length in bytes from
    // 'pL2tpHeader' to the end of the buffer.
    //
    // Returns GERR_None if 'pL2tpHeader' is a coherent L2TP header, or a
    // GERR_* failure code.
    //
{
    USHORT *pusCur;
    USHORT usOffset;
    USHORT usBits;

    pusCur = (USHORT*)pL2tpHeader;

    // The first 2 bytes contain bits that indicate the presence/absence of
    // the other header fields.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusBits = pusCur;
    usBits = *pusCur;
    ++pusCur;

    // The T bit indicates a control packet, as opposed to a payload packet.
    //
    if (usBits & HBM_T)
    {
        // Verify the field-present bits guaranteed to be set/clear in a
        // control header are set correctly.
        //
        if ((usBits & HBM_Bits) != HBM_Control)
        {
            TRACE( TL_A, TM_Recv,
                ( "Header: Bad bits=$%04x?", (ULONG )usBits ) );
            return GERR_BadValue;
        }
    }

    // Verify the version indicates L2TP.  Cisco's L2F can theoretically
    // co-exist on the same media address, though we don't support that.
    //
    if ((usBits & HBM_Ver) != VER_L2tp)
    {
        TRACE( TL_A, TM_Recv,
            ( "Header: Non-L2TP Ver=%d?", (usBits & HBM_Ver )) );
        return GERR_BadValue;
    }

    // The L bit indicates a Length field is present.
    //
    if (usBits & HBM_L)
    {
        *pusCur = ntohs( *pusCur );
        pInfo->pusLength = pusCur;
        ++pusCur;
    }
    else
    {
        pInfo->pusLength = NULL;
    }

    // The Tunnel-ID field is always present.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusTunnelId = pusCur;
    ++pusCur;

    // The Call-ID field is always present.
    //
    *pusCur = ntohs( *pusCur );
    pInfo->pusCallId = pusCur;
    ++pusCur;

    // The F bit indicates the Ns and Nr fields are present.
    //
    if (usBits & HBM_F)
    {
        *pusCur = ntohs( *pusCur );
        pInfo->pusNs = pusCur;
        ++pusCur;
        *pusCur = ntohs( *pusCur );
        pInfo->pusNr = pusCur;
        ++pusCur;
    }
    else
    {
        pInfo->pusNs = NULL;
        pInfo->pusNr = NULL;
    }

    // The S bit indicates the Offset field is present.  The S bit appears in
    // the payload header only, as was verified above.
    //
    if (usBits & HBM_S)
    {
        *pusCur = ntohs( *pusCur );
        usOffset = *pusCur;
        ++pusCur;
    }
    else
    {
        usOffset = 0;
    }

    // End and length of header.
    //
    pInfo->pData = ((CHAR* )pusCur) + usOffset;
    pInfo->ulHeaderLength = (ULONG )(pInfo->pData - pL2tpHeader);

    // "Official" data length.
    //
    if (pInfo->pusLength)
    {
        // Verify any specified length is at least as long as the set header
        // bits imply and no longer than the received buffer.
        //
        if (*(pInfo->pusLength) < pInfo->ulHeaderLength
            || *(pInfo->pusLength) > ulBufferLength)
        {
            TRACE( TL_A, TM_Recv, ( "Header: Bad Length?" ) );
            return GERR_BadLength;
        }

        // Use the L2TP length as the "official" length, i.e. any strange
        // bytes received beyond what the L2TP header says it sent will be
        // ignored.
        //
        pInfo->ulDataLength = *(pInfo->pusLength) - pInfo->ulHeaderLength;

        DBG_if( *(pInfo->pusLength) != ulBufferLength )
            TRACE( TL_A, TM_Recv, ( "EOB padding ignored" ) );
    }
    else
    {
        // Verify any implied length is at least as long as the set header
        // bits imply.
        //
        if (ulBufferLength < pInfo->ulHeaderLength)
        {
            TRACE( TL_A, TM_Recv, ( "Header: Bad Length?" ) );
            return GERR_BadLength;
        }

        // No length field so the received buffer length is the "official"
        // length.
        //
        pInfo->ulDataLength = ulBufferLength - pInfo->ulHeaderLength;
    }

    return GERR_None;
}


USHORT
GetAvpValueFixedAch(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT CHAR** ppch )

    // Set callers '*ppch' to point to value field of AVP 'pAvp' containing an
    // array of 'usArraySize' bytes.  No byte ordering is done.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != usArraySize)
    {
        return GERR_BadLength;
    }

    *ppch = pAvp->pValue;
    return GERR_None;
}


USHORT
GetAvpValueFixedAul(
    IN AVPINFO* pAvp,
    IN USHORT usArraySize,
    OUT UNALIGNED ULONG** paulArray )

    // Set callers '*paulArray' to point to value field of AVP 'pAvp'
    // containing an array of 'usArraySize' ULONGs, converted to host
    // byte-order.  A 2-byte reserved field is assumed to preceed the first
    // ULONG.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    USHORT* pusCur;
    UNALIGNED ULONG* pulCur;
    ULONG i;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != sizeof(USHORT) + (usArraySize * sizeof(ULONG)))
    {
        return GERR_BadLength;
    }

    pusCur = (USHORT* )pAvp->pValue;

    // Skip over and ignore the 'Reserved' field.
    //
    ++pusCur;

    *paulArray = (UNALIGNED ULONG* )pusCur;
    for (i = 0, pulCur = *paulArray;
         i < usArraySize;
         ++i, ++pulCur)
    {
        // Convert to host byte-order.
        //
        *pulCur = ntohl( *pulCur );
    }

    return GERR_None;
}


USHORT
GetAvpValueFlag(
    IN AVPINFO* pAvp,
    OUT UNALIGNED BOOLEAN* pf )

    // Set callers '*pf' to true since with a flag AVP the existence is the
    // data, and performs the routine AVP validations.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != 0)
    {
        return GERR_BadLength;
    }

    *pf = TRUE;

    return GERR_None;
}


USHORT
GetAvpValueUs(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus )

    // Set callers '*ppus' to point to the USHORT value field of AVP 'pAvp'.
    // The field is host byte-ordered.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    UNALIGNED USHORT* pusCur;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != sizeof(USHORT))
    {
        return GERR_BadLength;
    }

    // Convert in place to host byte-order.
    //
    pusCur = (USHORT* )pAvp->pValue;
    *pusCur = ntohs( *pusCur );
    *ppus = pusCur;

    return GERR_None;
}


USHORT
GetAvpValue2UsAndVariableAch(
    IN AVPINFO* pAvp,
    OUT UNALIGNED USHORT** ppus1,
    OUT UNALIGNED USHORT** ppus2,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize )

    // Gets the data from an AVP with 2 USHORTs followed by a variable length
    // array.  Sets '*ppus1' and '*ppus2' to the two short integers and
    // '*ppus' to the variable length array.  '*PusArraySize is set to the
    // length of the '*ppch' array.  'pAvp'.  The field is host byte-ordered.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    UNALIGNED USHORT* pusCur;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength < (2 * sizeof(USHORT)))
    {
        return GERR_BadLength;
    }

    // Convert in place to host byte-order.
    //
    pusCur = (USHORT* )pAvp->pValue;
    *pusCur = ntohs( *pusCur );
    *ppus1 = pusCur;
    ++pusCur;

    *pusCur = ntohs( *pusCur );
    *ppus2 = pusCur;
    ++pusCur;

    *ppch = (CHAR* )pusCur;
    *pusArraySize = pAvp->usValueLength - (2 * sizeof(USHORT));

    return GERR_None;
}


USHORT
GetAvpValueUl(
    IN AVPINFO* pAvp,
    OUT UNALIGNED ULONG** ppul )

    // Set callers '*ppul' to point to the ULONG value field of AVP 'pAvp'.
    // The field is host byte-ordered.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    UNALIGNED ULONG* pulCur;

    // Make sure it's the right size.
    //
    if (pAvp->usValueLength != sizeof(ULONG))
    {
        return GERR_BadLength;
    }

    // Convert in place to host byte-order.
    //
    pulCur = (UNALIGNED ULONG* )pAvp->pValue;
    *pulCur = ntohl( *pulCur );
    *ppul = pulCur;

    return GERR_None;
}


USHORT
GetAvpValueVariableAch(
    IN AVPINFO* pAvp,
    OUT CHAR** ppch,
    OUT USHORT* pusArraySize )

    // Set callers '*ppch' to point to value field of AVP 'pAvp' containing an
    // array of bytes, where '*pusArraySize' is set to the length in bytes.
    // No byte ordering is done.
    //
    // Returns GERR_None if successful, or a GERR_* error code.
    //
{
    *pusArraySize = pAvp->usValueLength;
    *ppch = pAvp->pValue;

    return GERR_None;
}


VOID
HelloTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler set to expire when a "Hello" interval has expired.
    //
{
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    BOOLEAN fReusedTimerQItem;

    TRACE( TL_V, TM_Send,
        ( "HelloTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.
    //
    pTunnel = (TUNNELCB* )pContext;
    pAdapter = pTunnel->pAdapter;

    fReusedTimerQItem = FALSE;

    if (event == TE_Expire)
    {
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (pTunnel->ulHelloResetsThisInterval == 0
                && pTunnel->ulRemainingHelloMs == 0)
            {
                if (pTunnel->state != CCS_Idle && pItem == pTunnel->pTqiHello)
                {
                    // The full timeout period has expired, the tunnel's not
                    // idle, and the hello timer was not cancelled or
                    // terminated since the expire timer fired.  It's time to
                    // send a "Hello" message to make sure the media is still
                    // up.
                    //
                    SendControl( pTunnel, NULL, CMT_Hello, 0, 0, NULL, 0 );
                }
                DBG_else
                {
                    TRACE( TL_A, TM_Send, ( "Hello aborted" ) );
                }

                pTunnel->pTqiHello = NULL;
            }
            else
            {
                ULONG ulTimeoutMs;

                // Not a full timeout expiration event.  Adjust interval
                // counters and schedule next interval timeout.
                //
                if (pTunnel->ulHelloResetsThisInterval > 0)
                {
                    pTunnel->ulRemainingHelloMs = pAdapter->ulHelloMs;
                    pTunnel->ulHelloResetsThisInterval = 0;
                }

                if (pTunnel->ulRemainingHelloMs >= L2TP_HelloIntervalMs)
                {
                    ulTimeoutMs = L2TP_HelloIntervalMs;
                    pTunnel->ulRemainingHelloMs -= L2TP_HelloIntervalMs;
                }
                else
                {
                    ulTimeoutMs = pTunnel->ulRemainingHelloMs;
                    pTunnel->ulRemainingHelloMs = 0;
                }

                TimerQInitializeItem( pItem );
                TimerQScheduleItem(
                    pTunnel->pTimerQ,
                    pItem,
                    ulTimeoutMs,
                    HelloTimerEvent,
                    pTunnel );

                fReusedTimerQItem = TRUE;
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );
    }

    if (!fReusedTimerQItem)
    {
        FREE_TIMERQITEM( pAdapter, pItem );
    }
}


VOID
IndicateReceived(
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulLength,
    IN LONGLONG llTimeReceived )

    // Indicates to the client above a packet received on VC 'pVc' containing
    // 'ulLength' bytes of data from NDIS_BUFFER 'pBuffer' starting 'ulOffset'
    // bytes in.  Caller must not reference 'pBuffer' after calling this
    // routine.  'UllTimeReceived' is the time the packet was received from
    // the net, or 0 if call parameters said client doesn't care.
    //
    // IMPORTANT: Caller should not hold any spinlocks as this routine make
    //            NDIS indications.
    //
{
    NDIS_STATUS status;
    NDIS_PACKET* pPacket;
    NDIS_BUFFER* pTrimmedBuffer;
    ADAPTERCB* pAdapter;
    PACKETHEAD* pHead;
    LONG* plRef;
    LONG lRef;

    pAdapter = pVc->pAdapter;

    pPacket = GetPacketFromPool( &pAdapter->poolPackets, &pHead );
    if (!pPacket)
    {
        // Packet descriptor pool is maxed.
        //
        ASSERT( !"GetPfP?" );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }

    // Lop off the L2TP header and hook the corresponding NDIS_BUFFER to the
    // packet.  The "copy" here refers to descriptor information only.  The
    // packet data is not copied.
    //
    NdisCopyBuffer(
        &status,
        &pTrimmedBuffer,
        PoolHandleForNdisCopyBufferFromBuffer( pBuffer ),
        NdisBufferFromBuffer( pBuffer ),
        ulOffset,
        ulLength );

    if (status != STATUS_SUCCESS)
    {
        // Can't get a MDL which likely means the system is toast.
        //
        TRACE( TL_A, TM_Recv, ( "NdisCopyBuffer=%08x?", status ) );
        FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }
    else
    {
        extern ULONG g_ulNdisCopyBuffers;

        NdisInterlockedIncrement( &g_ulNdisCopyBuffers );
    }

    NdisChainBufferAtFront( pPacket, pTrimmedBuffer );

    // Stash the time the packet was received in the packet.
    //
    NDIS_SET_PACKET_TIME_RECEIVED( pPacket, llTimeReceived );

    // Pre-set the packet to success, since a random value of
    // NDIS_STATUS_RESOURCES would prevent our ReturnPackets handler from
    // getting called.
    //
    NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_SUCCESS );

    // Stash our context information with the packet for clean-up use in
    // LmpReturnPacket, then indicate the packet to NDISWAN.
    //
    *((PACKETHEAD** )(&pPacket->MiniportReserved[ 0 ])) = pHead;
    *((CHAR** )(&pPacket->MiniportReserved[ sizeof(VOID*) ])) = pBuffer;

    TRACE( TL_N, TM_Recv, ( "NdisMCoIndRecPkt(len=%d)...", ulLength ) );
    NdisMCoIndicateReceivePacket( pVc->NdisVcHandle, &pPacket, 1 );
    TRACE( TL_N, TM_Recv, ( "NdisMCoIndRecPkt done" ) );

    // Tell NDIS our "receive process" is complete.  Since we deal with one
    // packet at a time and NDISWAN does also, this doesn't accomplish
    // anything, but the consensus is it's bad form to omit it.
    //
    TRACE( TL_N, TM_Recv, ( "NdisMCoRecComp..." ) );
    NdisMCoReceiveComplete( pAdapter->MiniportAdapterHandle );
    TRACE( TL_N, TM_Recv, ( "NdisMCoRecComp done" ) );

    NdisInterlockedIncrement( &g_lPacketsIndicated );

    NdisAcquireSpinLock( &pVc->lockV );
    {
        ++pVc->stats.ulRecdDataPackets;
        pVc->stats.ulDataBytesRecd += ulLength;
    }
    NdisReleaseSpinLock( &pVc->lockV );
}


TUNNELCB*
TunnelCbFromTunnelId(
    IN ADAPTERCB* pAdapter,
    IN USHORT usTunnelId )

    // Return the tunnel control block associated with 'ulIpAddress' in
    // 'pAdapter's list of TUNNELCBs or NULL if not found.
    //
    // IMPORTANT:  Caller must hold 'pAdapter->lockTunnels'.
    //
{
    TUNNELCB* pTunnel;
    LIST_ENTRY* pLink;

    pTunnel = NULL;

    for (pLink = pAdapter->listTunnels.Flink;
         pLink != &pAdapter->listTunnels;
         pLink = pLink->Flink)
    {
        TUNNELCB* pThis;

        pThis = CONTAINING_RECORD( pLink, TUNNELCB, linkTunnels );
        if (pThis->usTunnelId == usTunnelId)
        {
            pTunnel = pThis;
            break;
        }
    }

    return pTunnel;
}


BOOLEAN
LookUpTunnelAndVcCbs(
    IN ADAPTERCB* pAdapter,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl,
    OUT TUNNELCB** ppTunnel,
    OUT VCCB** ppVc )

    // Fill caller's '*ppTunnel' and '*ppVc' with the control blocks implied
    // by the Tunnel-ID and Call-ID found in the header, if any.  'PHeader' is
    // the exploded L2TP header.  'PControl' is the exploded control message
    // info or NULL if payload.
    //
    // Returns true if a valid combination is found.  This does not
    // necessarily mean that both tunnel and VC outputs are non-NULL.
    //
    // Returns false if the combination is invalid.  In this case, the packet
    // is zombie acked if necessary.  See ZombieAckIfNecessary routine.
    //
{
    BOOLEAN fFail;

    *ppVc = NULL;
    *ppTunnel = NULL;

    // As of draft-05 Tunnel-ID and Call-ID are no longer optional.
    //
    ASSERT( pusCallId );
    ASSERT( pusTunnelId );

    if (*pusCallId)
    {
        if (*pusCallId > pAdapter->usMaxVcs)
        {
            // Non-0 Call-ID out of range of the table, i.e. it's a VC that is
            // being used for graceful termination and is not passed up.  Look
            // up tunnel and VC blocks by walking lists.
            //
            // Search the adapter's list of active tunnels for the one
            // with peer's specified Tunnel-ID.
            //
            NdisAcquireSpinLock( &pAdapter->lockTunnels );
            {
                *ppTunnel = TunnelCbFromTunnelId( pAdapter, *pusTunnelId );
                if (*ppTunnel)
                {
                    ReferenceTunnel( *ppTunnel, TRUE );
                }
            }
            NdisReleaseSpinLock( &pAdapter->lockTunnels );

            if (*ppTunnel)
            {
                // Search the tunnel's list of active VCs for the one with
                // peer's specified Call-ID.
                //
                NdisAcquireSpinLock( &((*ppTunnel)->lockVcs) );
                {
                    *ppVc = VcCbFromCallId( *ppTunnel, *pusCallId );
                    if (*ppVc)
                    {
                        ReferenceVc( *ppVc );
                    }
                }
                NdisReleaseSpinLock( &((*ppTunnel)->lockVcs) );

                if (!*ppVc)
                {
                    // Non-0 Call-ID out of range of table with no
                    // associated VC control block.
                    //
                    TRACE( TL_A, TM_Recv, ( "CBs bad: Big CID w/!pV" ) );
                    ZombieAckIfNecessary( *ppTunnel, pHeader, pControl );
                    DereferenceTunnel( *ppTunnel );
                    *ppTunnel = NULL;
                    return FALSE;
                }
            }
            else
            {
                // Non-0 Call-ID out of range of table with no tunnel
                // control block associated with the Tunnel-ID.
                //
                TRACE( TL_A, TM_Recv, ( "CBs bad: Big CID w/!pT" ) );
                return FALSE;
            }
        }
        else
        {
            // Read the VCCB* from the adapter's table.
            //
            fFail = FALSE;
            NdisDprAcquireSpinLock( &pAdapter->lockVcs );
            {
                *ppVc = pAdapter->ppVcs[ *pusCallId - 1 ];

                if (*ppVc && *ppVc != (VCCB* )-1)
                {
                    ReferenceVc( *ppVc );

                    *ppTunnel = (*ppVc)->pTunnel;
                    ASSERT( *ppTunnel );
                    ReferenceTunnel( *ppTunnel, FALSE );

                    if (*pusTunnelId
                        && (*pusTunnelId != (*ppTunnel)->usTunnelId))
                    {
                        // Non-0 Call-ID is associated with a tunnel different
                        // than the one indicated by peer in the header.
                        //
                        TRACE( TL_A, TM_Recv,
                            ( "CBs bad: TIDs=%d,%d?",
                            (ULONG )*pusTunnelId,
                            (ULONG )(*ppTunnel)->usTunnelId ) );

                        DereferenceTunnel( *ppTunnel );
                        *ppTunnel = NULL;
                        DereferenceVc( *ppVc );
                        *ppVc = NULL;
                        fFail = TRUE;
                    }
                }
                else
                {
                    // Non-0 Call-ID without an active VC.
                    //
                    TRACE( TL_A, TM_Recv,
                        ( "CBs bad: CID=%d, pV=$%p?",
                        (ULONG )*pusCallId, *ppVc ) );

                    // Search the adapter's list of active tunnels for the one
                    // with peer's specified Tunnel-ID.
                    //
                    NdisAcquireSpinLock( &pAdapter->lockTunnels );
                    {
                        *ppTunnel = TunnelCbFromTunnelId(
                            pAdapter, *pusTunnelId );
                        if (*ppTunnel)
                        {
                            ReferenceTunnel( *ppTunnel, TRUE );
                        }
                    }
                    NdisReleaseSpinLock( &pAdapter->lockTunnels );

                    *ppVc = NULL;
                    fFail = TRUE;
                }
            }
            NdisDprReleaseSpinLock( &pAdapter->lockVcs );

            if (fFail)
            {
                if (*ppTunnel)
                {
                    ZombieAckIfNecessary( *ppTunnel, pHeader, pControl );
                    DereferenceTunnel( *ppTunnel );
                    *ppTunnel = NULL;
                }

                return FALSE;
            }
        }
    }
    else if (*pusTunnelId)
    {
        // 0 Call-ID with non-0 Tunnel-ID.  Search the list of active tunnels
        // for the one with peer's specified Tunnel-ID.
        //
        NdisAcquireSpinLock( &pAdapter->lockTunnels );
        {
            *ppTunnel = TunnelCbFromTunnelId( pAdapter, *pusTunnelId );
            if (*ppTunnel)
            {
                ReferenceTunnel( *ppTunnel, TRUE );
            }
        }
        NdisReleaseSpinLock( &pAdapter->lockTunnels );

        if (!*ppTunnel)
        {
            // 0 Call-Id with bogus Tunnel-ID.
            //
            TRACE( TL_A, TM_Recv,
                ( "CBs bad: CID=0, TID=%d, pT=0?",
                (ULONG )*pusTunnelId ) );
            return FALSE;
        }

        if (pControl
            && pControl->usXError == GERR_None
            && pControl->pusMsgType
            && *(pControl->pusMsgType) == CMT_CDN
            && pControl->pusAssignedCallId)
        {
            // The CallDisconnectNotify message includes the sender's assigned
            // Call-ID as an AVP so that it may be sent before sender receives
            // peer's assigned Call-ID.  Unfortunately, this requires this
            // routine to have AVP knowledge.  Search the tunnel's list of
            // associated VCs for the one with peer's specified Assigned
            // Call-ID.
            //
            NdisDprAcquireSpinLock( &((*ppTunnel)->lockVcs) );
            {
                *ppVc = VcCbFromCallId(
                    *ppTunnel, *(pControl->pusAssignedCallId) );

                if (*ppVc)
                {
                    ReferenceVc( *ppVc );
                }
            }
            NdisDprReleaseSpinLock( &((*ppTunnel)->lockVcs) );

            if (!*ppVc)
            {
                // 0 Call-Id CDN with no associated VC.
                //
                TRACE( TL_A, TM_Recv,
                    ( "CBs bad: CDN TID=%d, !pVc?", (ULONG )*pusTunnelId ) );
                ZombieAckIfNecessary( *ppTunnel, pHeader, pControl );
                DereferenceTunnel( *ppTunnel );
                *ppTunnel = NULL;
                return FALSE;
            }
        }
    }

    // Note: 0 Call-ID with 0 Tunnel-ID should only occur on peer's SCCRQ to
    // start a tunnel, but that means it's not an error here, even though we
    // report back neither control block.

    ASSERT( !*ppTunnel || (*ppTunnel)->ulTag == MTAG_TUNNELCB );
    ASSERT( !*ppVc || (*ppVc)->ulTag == MTAG_VCCB );
    TRACE( TL_N, TM_Recv,
        ( "CBs good: pT=$%p, pV=$%p", *ppTunnel, *ppVc ) );

    return TRUE;
}


VOID
PayloadAcknowledged(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usReceivedNr )

    // Cancels the timer of all payload-sent contexts in the VCs
    // 'listSendsOut' queue with 'Next Sent' less than 'usReceivedNr'.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV', which may be released and
    //            re-acquired by this routine.  Caller must not hold any other
    //            locks.
    //
{
    while (!IsListEmpty( &pVc->listSendsOut ))
    {
        PAYLOADSENT* pPs;
        LIST_ENTRY* pLink;
        BOOLEAN fUpdateSendWindow;
        LINKSTATUSINFO info;

        pLink = pVc->listSendsOut.Flink;
        pPs = CONTAINING_RECORD( pLink, PAYLOADSENT, linkSendsOut );

        // The list is in 'Ns' order so as soon as a non-acknowledge is hit
        // we're done.
        //
        if (CompareSequence( pPs->usNs, usReceivedNr ) >= 0)
        {
            break;
        }

        // This packet has been acknowledged.
        //
        pPs->status = NDIS_STATUS_SUCCESS;

        // Remove the context from the head of the "outstanding send" list.
        // The corresponding dereference occurs below.
        //
        RemoveEntryList( &pPs->linkSendsOut );
        InitializeListHead( &pPs->linkSendsOut );

        // Doesn't matter if this cancel fails because the expire handler will
        // recognize that the context is not linked into the "out" list and do
        // nothing.
        //
        TimerQCancelItem( pTunnel->pTimerQ, pPs->pTqiSendTimeout );

        // Adjust the timeouts and, if necessary, the send window as suggested
        // in the draft/RFC.
        //
        AdjustTimeoutsAtAckReceived(
            pPs->llTimeSent,
            pTunnel->pAdapter->ulMaxSendTimeoutMs,
            &pVc->ulSendTimeoutMs,
            &pVc->ulRoundTripMs,
            &pVc->lDeviationMs );

        fUpdateSendWindow =
            AdjustSendWindowAtAckReceived(
                pVc->ulMaxSendWindow,
                &pVc->ulAcksSinceSendTimeout,
                &pVc->ulSendWindow );

        TRACE( TL_V, TM_Send,
            ( "C%d: ACK(%d) new rtt=%d dev=%d ato=%d sw=%d",
            (ULONG )pVc->usCallId, (ULONG )pPs->usNs,
            pVc->ulRoundTripMs, pVc->ulSendTimeoutMs,
            pVc->lDeviationMs, pVc->ulSendWindow ) );

        // Update the statistics the reflect the acknowledge, it's round trip
        // time, and any change in the send window.  The field
        // 'pVc->UlRoundTripMs' is really an "estimate" of the next round trip
        // rather than the actual trip time.  However, just after an
        // acknowledge has been received, the two are identical so it can be
        // used in the statistics here.
        //
        ++pVc->stats.ulSentPacketsAcked;
        ++pVc->stats.ulRoundTrips;
        pVc->stats.ulRoundTripMsTotal += pVc->ulRoundTripMs;

        if (pVc->ulRoundTripMs > pVc->stats.ulMaxRoundTripMs)
        {
            pVc->stats.ulMaxRoundTripMs = pVc->ulRoundTripMs;
        }

        if (pVc->ulRoundTripMs < pVc->stats.ulMinRoundTripMs
            || pVc->stats.ulRoundTrips == 1)
        {
            pVc->stats.ulMinRoundTripMs = pVc->ulRoundTripMs;
        }

        if (fUpdateSendWindow)
        {
            ++pVc->stats.ulSendWindowChanges;

            if (pVc->ulSendWindow > pVc->stats.ulMaxSendWindow)
            {
                pVc->stats.ulMaxSendWindow = pVc->ulSendWindow;
            }
            else if (pVc->ulSendWindow < pVc->stats.ulMinSendWindow)
            {
                pVc->stats.ulMinSendWindow = pVc->ulSendWindow;
            }

            // Indicate the send window change to NDISWAN.  The lock is
            // released first since this involves a call outside our driver.
            //
            TransferLinkStatusInfo( pVc, &info );
            NdisReleaseSpinLock( &pVc->lockV );
            {
                IndicateLinkStatus( pVc, &info );
            }
            NdisAcquireSpinLock( &pVc->lockV );
        }

        // This dereference corresponds to the removal of the context from the
        // "outstanding send" list above.
        //
        DereferencePayloadSent( pPs );
    }
}


BOOLEAN
ReceiveFromOutOfOrder(
    IN VCCB* pVc )

    // "Receives" the first buffer queued on 'pVc's out-of-order list if it is
    // the next expected packet.
    //
    // Returns true if a buffer was "received", false otherwise.  If true is
    // returned, caller should call SchedulePayloadAck.  It's not called here
    // so caller can receive multiple packets from the out-of-order queue and
    // set the timer once.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.  Also, be aware this routine
    //            may release and re-acquire the lock to make the NDIS receive
    //            indication.
    //
{
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pFirstLink;
    PAYLOADRECEIVED* pFirstPr;
    SHORT sDiff;

    TRACE( TL_N, TM_Recv, ( "ReceiveFromOutOfOrder Nr=%d", pVc->usNr ) );

    if (IsListEmpty( &pVc->listOutOfOrder ))
    {
        // No out-of-order buffers queued.
        //
        TRACE( TL_N, TM_Recv, ( "None queued" ) );
        return FALSE;
    }

    pAdapter = pVc->pAdapter;
    pFirstLink = pVc->listOutOfOrder.Flink;
    pFirstPr = CONTAINING_RECORD( pFirstLink, PAYLOADRECEIVED, linkOutOfOrder );

    // Verify the next queued buffer is in sequence first.
    //
    sDiff = CompareSequence( pFirstPr->usNs, pVc->usNr );
    if (sDiff > 0)
    {
        // No, first queued packet is still beyond the next one expected.
        //
        TRACE( TL_I, TM_Recv,
            ( "Still out-of-order, Ns=%d", pFirstPr->usNs ) );
        return FALSE;
    }

    // De-queue the first out-of-order buffer and if it's exactly the one we
    // expected, update 'Next Receive'to be the one following it's 'Next
    // Send'.  When peer sends an R-bit to set 'Next Receive' ahead, packets
    // prior to the new expected packet may be queued before the expected
    // packet.  These packets are still good and are immediately indicated up,
    // but since 'Next Receive' is already updated in that case, it is not
    // adjusted here.
    //
    RemoveEntryList( pFirstLink );
    InitializeListHead( pFirstLink );

    if (sDiff == 0)
    {
        pVc->usNr = pFirstPr->usNs + 1;
    }

    TRACE( TL_I, TM_Recv, ( "%d from queue", (UINT )pFirstPr->usNs ) );
    ++pVc->stats.ulDataPacketsDequeued;

    NdisReleaseSpinLock( &pVc->lockV );
    {
        // Indicate the buffer to the driver above, and free it's out-of-order
        // context.
        //
        IndicateReceived(
            pVc,
            pFirstPr->pBuffer,
            pFirstPr->ulPayloadOffset,
            pFirstPr->ulPayloadLength,
            pFirstPr->llTimeReceived );

        FREE_PAYLOADRECEIVED( pAdapter, pFirstPr );
    }
    NdisAcquireSpinLock( &pVc->lockV );

    return TRUE;
}


VOID
ResetHelloTimer(
    IN TUNNELCB* pTunnel )

    // Resets (logically anyway) the 'pTunnel' Hello timer.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    if (pAdapter->ulHelloMs)
    {
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (pTunnel->state != CCS_Idle)
            {
                if (pTunnel->pTqiHello)
                {
                    TRACE( TL_V, TM_Send, ( "Reset HelloTimer" ) );

                    // Timer's running so just note that a reset has occurred
                    // since it was started.
                    //
                    ++pTunnel->ulHelloResetsThisInterval;
                }
                else
                {
                    TRACE( TL_I, TM_Send, ( "Kickstart HelloTimer" ) );

                    // Timer is not running.  Kickstart it by scheduling an
                    // "instant expire" event that will reset the interval.
                    //
                    pTunnel->pTqiHello = ALLOC_TIMERQITEM( pAdapter );
                    if (pTunnel->pTqiHello)
                    {
                        pTunnel->ulHelloResetsThisInterval = 1;
                        pTunnel->ulRemainingHelloMs = 0;

                        TimerQInitializeItem( pTunnel->pTqiHello );
                        TimerQScheduleItem(
                            pTunnel->pTimerQ,
                            pTunnel->pTqiHello,
                            0,
                            HelloTimerEvent,
                            pTunnel );
                    }
                }
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );
    }
}


VOID
ScheduleControlAck(
    IN TUNNELCB* pTunnel,
    IN USHORT usMsgTypeToAcknowledge )

    // Schedule a 'ControlAckTimerEvent' to occur in 1/4 of the standard send
    // timeout.  If one's already ticking no action is taken, because any
    // packet that goes out will get it done.  Doesn't matter who requested
    // it.  'UsMsgTypeToAcknowledge' is the CMT_* code of the message to be
    // acknowledged and is used for performance tuning.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    TIMERQITEM* pTqi;
    ADAPTERCB* pAdapter;
    ULONG ulDelayMs;
    BOOLEAN fFastAck;

    if ((usMsgTypeToAcknowledge == CMT_StopCCN
            || usMsgTypeToAcknowledge == CMT_ICCN
            || usMsgTypeToAcknowledge == CMT_OCCN
            || usMsgTypeToAcknowledge == CMT_CDN)
        || (pTunnel->ulSendsOut < pTunnel->ulSendWindow))
    {
        TRACE( TL_N, TM_Recv, ( "Fast ACK" ) );

        // Certain messages where follow-on messages are unlikely are
        // acknowledged without delay, as are all messages when the send
        // window is closed.
        //
        fFastAck = TRUE;
    }
    else
    {
        fFastAck = FALSE;
    }

    if (pTunnel->pTqiDelayedAck)
    {
        if (fFastAck)
        {
            TimerQExpireItem( pTunnel->pTimerQ, pTunnel->pTqiDelayedAck );
        }
    }
    else
    {
        pAdapter = pTunnel->pAdapter;
        pTqi = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqi)
        {
            ASSERT( !"Alloc TQI?" );
            return;
        }

        pTunnel->pTqiDelayedAck = pTqi;

        if (fFastAck)
        {
            ulDelayMs = 0;
        }
        else
        {
            ulDelayMs = pTunnel->ulSendTimeoutMs >> 2;
            if (ulDelayMs > pAdapter->ulMaxAckDelayMs)
            {
                ulDelayMs = pAdapter->ulMaxAckDelayMs;
            }
        }

        TRACE( TL_N, TM_Recv, ( "SchedControlAck(%dms)", ulDelayMs ) );

        ReferenceTunnel( pTunnel, FALSE );
        TimerQInitializeItem( pTqi );
        TimerQScheduleItem(
             pTunnel->pTimerQ,
             pTqi,
             ulDelayMs,
             ControlAckTimerEvent,
             pTunnel );
    }
}


VOID
SchedulePayloadAck(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Schedule a 'PayloadAckTimerEvent' to occur in 1/4 of the standard send
    // timeout.  If one's already ticking no action is taken, because any
    // packet that goes out will get it done.  Doesn't matter who requested
    // it.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    ADAPTERCB* pAdapter;
    TIMERQITEM* pTqi;
    ULONG ulDelayMs;

    if (!pVc->pTqiDelayedAck)
    {
        pAdapter = pVc->pAdapter;
        pTqi = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqi)
        {
            ASSERT( !"Alloc TQI?" );
            return;
        }

        pVc->pTqiDelayedAck = pTqi;

        ulDelayMs = pVc->ulSendTimeoutMs >> 2;
        if (ulDelayMs > pAdapter->ulMaxAckDelayMs)
        {
            ulDelayMs = pAdapter->ulMaxAckDelayMs;
        }

        TRACE( TL_N, TM_Recv,
            ( "SchedPayloadAck(%dms)=$%p", ulDelayMs, pTqi ) );

        ReferenceVc( pVc );
        TimerQInitializeItem( pTqi );
        TimerQScheduleItem(
             pTunnel->pTimerQ,
             pTqi,
             ulDelayMs,
             PayloadAckTimerEvent,
             pVc );
    }
}


VCCB*
VcCbFromCallId(
    IN TUNNELCB* pTunnel,
    IN USHORT usCallId )

    // Return the VC control block associated with 'usCallId' in 'pTunnel's
    // list of active VCs or NULL if not found.
    //
    // IMPORTANT:  Caller must hold 'pTunnel->lockVcs'.
    //
{
    VCCB* pVc;
    LIST_ENTRY* pLink;

    pVc = NULL;

    for (pLink = pTunnel->listVcs.Flink;
         pLink != &pTunnel->listVcs;
         pLink = pLink->Flink)
    {
        VCCB* pThis;

        pThis = CONTAINING_RECORD( pLink, VCCB, linkVcs );
        if (pThis->usCallId == usCallId)
        {
            pVc = pThis;
            break;
        }
    }

    return pVc;
}


VOID
ZombieAckIfNecessary(
    IN TUNNELCB* pTunnel,
    IN L2TPHEADERINFO* pHeader,
    IN CONTROLMSGINFO* pControl )

    // Determines if a message not matched to any VC warrants a "zombie"
    // re-acknowledge, and if so, schedules one.  This situation arises when
    // our side sends an acknowledge to peer's CDN on a given call and the
    // acknowledge is lost.  Our side tears down the VC immediately, but peer
    // will eventually drop the entire tunnel if no acknowledge of his follow
    // on CDN retransmits are received, thus affecting calls beyond the one
    // dropped.  This routine acknowledges such retransmissions.
    //
    // Another simpler approach would be to take a reference on the call and
    // hold it for a full retransmission interval before dereferencing.
    // However, this would block the drop indications up and would therefore,
    // from dial-out user's point of view, cause a potentially long delay
    // whenever server disconnected a call.  This is judged undesirable enough
    // to tolerate the zombie ack messiness.
    //
    // 'PTunnel' is the associated tunnel control block.  'PHeader' is the
    // exploded L2TP header.  'PControl' is the exploded control header, or
    // NULL if not a control message.  Caller should already have determined
    // that no VC is associated with the message.
    //
{
    if (pControl
        && pControl->usXError == GERR_None
        && pControl->pusMsgType
        && *(pControl->pusMsgType) == CMT_CDN
        && pControl->pusAssignedCallId)
    {
        // It's a CDN message and a candidate for re-acknowledgement.  See if
        // it's sequence number is prior to or equal to the next expected
        // packet.  If so, schedule a zombie acknowledge.
        //
        if (CompareSequence( *(pHeader->pusNs), pTunnel->usNr ) <= 0)
        {
            TRACE( TL_A, TM_Send, ( "Zombie acking" ) );

            NdisAcquireSpinLock( &pTunnel->lockT );
            {
                // Cancel any pending delayed acknowledge timeout.
                //
                if (pTunnel->pTqiDelayedAck)
                {
                    TimerQCancelItem(
                        pTunnel->pTimerQ, pTunnel->pTqiDelayedAck );
                    pTunnel->pTqiDelayedAck = NULL;
                }
            }
            NdisReleaseSpinLock( &pTunnel->lockT );

            ScheduleTunnelWork(
                pTunnel, NULL, SendControlAck, 0, 0, 0, 0, FALSE, FALSE );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\send.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// send.c
// RAS L2TP WAN mini-port/call-manager driver
// Send routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


#ifdef PSDEBUG

// List of all allocated PAYLOADSENT contexts and the lock that protects the
// list.  (for debug purposes only)
//
NDIS_SPIN_LOCK g_lockDebugPs;
LIST_ENTRY g_listDebugPs;

#endif


// Debug counts of client oddities that should not be happening.
//
ULONG g_ulSendZlbWithoutHostRoute = 0;


// Callback to add AVPs to an outgoing control message.  'PTunnel' is the
// tunnel control block.  'PVc' is the VC control block for call control
// messages or NULL for tunnel control messages.  'ulArg1', 'ulArg2', and
// 'pvArg3' are caller's arguments as passed for SendControl.  'PAvpBuffer' is
// the address of the buffer to receive the built AVPs.  '*PulAvpLength' is
// set to the length of the built AVPs.
//
typedef
VOID
(*PBUILDAVPS)(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

USHORT
BuildAvpAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp );

USHORT
BuildAvpAul(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN UNALIGNED ULONG* pulValue,
    IN USHORT usValues,
    OUT CHAR* pAvp );

USHORT
BuildAvpFlag(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    OUT CHAR* pAvp );

USHORT
BuildAvpUl(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN ULONG ulValue,
    OUT CHAR* pAvp );

USHORT
BuildAvpUs(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue,
    OUT CHAR* pAvp );

USHORT
BuildAvp2UsAndAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue1,
    IN USHORT usValue2,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp );

VOID
BuildCdnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildHelloAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildIccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildIcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildIcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

ULONG
BuildL2tpHeader(
    IN OUT CHAR* pBuffer,
    IN BOOLEAN fControl,
    IN BOOLEAN fReset,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN USHORT* pusNs,
    IN USHORT usNr );

VOID
BuildOccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildOcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildOcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildScccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildSccrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildSccrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildStopccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
BuildWenAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength );

VOID
CompletePayloadSent(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendControlComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendHeaderComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendPayloadReset(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
SendPayloadSeq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs );

VOID
SendPayloadSeqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendPayloadUnseq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs );

VOID
SendPayloadUnseqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );

VOID
SendPayloadTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event );

VOID
SendZlb(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usNs,
    IN USHORT usNr,
    IN BOOLEAN fReset );

VOID
UpdateControlHeaderNr(
    IN CHAR* pBuffer,
    IN USHORT usNr );

VOID
UpdateHeaderLength(
    IN CHAR* pBuffer,
    IN USHORT usLength );


//-----------------------------------------------------------------------------
// Send routines
//-----------------------------------------------------------------------------

VOID
SendControl(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usMsgType,
    IN ULONG ulBuildAvpsArg1,
    IN ULONG ulBuildAvpsArg2,
    IN PVOID pvBuildAvpsArg3,
    IN ULONG ulFlags )

    // Build and send a control message.  'PTunnel' is the tunnel control
    // block, always non-NULL.  'PVc' is the VC control block, non-NULL for
    // call connection (as opposed to tunnel connection) messages.
    // 'UsMsgType' is the message type AVP value of the message to build.
    // 'UlBuildAvpsArgX' are the arguments passed to the PBUILDAVP handler
    // associated with 'usMsgType', where the meaning depends on the specific
    // handler.  'UlFlags' is the CSF_* flag options associated with the sent
    // message context, or 0 if none.
    //
    // IMPORTANT:  Caller must hold 'pTunnel->lockT'.  If 'pVc' is non-NULL
    //             caller must also hold 'pVc->lockV'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pNdisBuffer;
    PBUILDAVPS pBuildAvpsHandler;
    TIMERQITEM* pTqiSendTimeout;
    CONTROLSENT* pCs;
    USHORT usAssignedCallId;
    ULONG ulLength;
    ULONG ulAvpLength;
    CHAR* pBuffer;

    static PBUILDAVPS apBuildAvpHandlers[ 16 ] =
    {
        BuildSccrqAvps,    // CMT_SCCRQ
        BuildSccrpAvps,    // CMT_SCCRP
        BuildScccnAvps,    // CMT_SCCCN
        BuildStopccnAvps,  // CMT_StopCCN
        NULL,              // CMT_StopCCRP (obsolete)
        BuildHelloAvps,    // CMT_Hello
        BuildOcrqAvps,     // CMT_OCRQ
        BuildOcrpAvps,     // CMT_OCRP
        BuildOccnAvps,     // CMT_OCCN
        BuildIcrqAvps,     // CMT_ICRQ
        BuildIcrpAvps,     // CMT_ICRP
        BuildIccnAvps,     // CMT_ICCN
        NULL,              // CMT_CCRQ (obsolete)
        BuildCdnAvps,      // CMT_CDN
        BuildWenAvps,      // CMT_WEN
        NULL               // CMT_SLI
    };

    TRACE( TL_V, TM_Send, ( "SendControl" ) );

    pAdapter = pTunnel->pAdapter;
    pBuffer = NULL;
    pTqiSendTimeout = NULL;
    pCs = NULL;

    do
    {
        // Get an NDIS_BUFFER to hold the control message.
        //
        pBuffer = GetBufferFromPool( &pAdapter->poolFrameBuffers );
        if (!pBuffer)
        {
            ASSERT( !"GetBfP?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Get an "unacknowledged send timeout" timer event descriptor.
        //
        pTqiSendTimeout = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqiSendTimeout)
        {
            ASSERT( !"Alloc TQI?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Get a "control message sent" context.
        //
        pCs = ALLOC_CONTROLSENT( pAdapter );
        if (!pCs)
        {
            ASSERT( !"Alloc PS?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        if (pBuffer)
        {
            FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        }

        if (pTqiSendTimeout)
        {
            FREE_TIMERQITEM( pAdapter, pTqiSendTimeout );
        }

        // System is probably toast but try to be orderly.
        //
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
        return;
    }

    // Build an L2TP control header in 'pBuffer'.  The Call-ID is 0 for tunnel
    // control messages, or peer's assigned call ID for call control messages.
    //
    usAssignedCallId = (pVc) ? pVc->usAssignedCallId : 0;
    ulLength =
        BuildL2tpHeader(
            pBuffer,
            TRUE,
            FALSE,
            &pTunnel->usAssignedTunnelId,
            &usAssignedCallId,
            &pTunnel->usNs,
            pTunnel->usNr );

    // Call the message type's "build AVPs" handler to add AVPs to the buffer
    // following the header.
    //
    ASSERT( usMsgType > 0 && usMsgType <= 16 );
    pBuildAvpsHandler = apBuildAvpHandlers[ usMsgType - 1 ];
    pBuildAvpsHandler(
        pTunnel, pVc,
        ulBuildAvpsArg1, ulBuildAvpsArg2, pvBuildAvpsArg3,
        pBuffer + ulLength, &ulAvpLength );
    ulLength += ulAvpLength;
    UpdateHeaderLength( pBuffer, (USHORT )ulLength );

    // Pare down the frame buffer to the actual length used.
    //
    pNdisBuffer = NdisBufferFromBuffer( pBuffer );
    NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );

    // Set up the "control message sent" context with the information needed
    // to send the message and track it's progress through retransmissions.
    //
    pCs->lRef = 0;
    pCs->usNs = pTunnel->usNs;
    pCs->usMsgType = usMsgType;
    TimerQInitializeItem( pTqiSendTimeout );
    pCs->pTqiSendTimeout = pTqiSendTimeout;
    pCs->ulRetransmits = 0;
    pCs->pBuffer = pBuffer;
    pCs->ulBufferLength = ulLength;
    pCs->pTunnel = pTunnel;
    pCs->pVc = pVc;
    pCs->ulFlags = ulFlags | CSF_Pending;
    pCs->pIrp = NULL;

    // Bump the 'Next Send' counter since this message has been assigned the
    // current value.
    //
    ++pTunnel->usNs;

    // Take a reference that is removed when the context is removed from the
    // "outstanding send" list.  Take a VC and tunnel reference that is
    // removed when the context is freed.
    //
    ReferenceControlSent( pCs );
    ReferenceTunnel( pTunnel, FALSE );

    if (pCs->pVc)
    {
        ReferenceVc( pCs->pVc );
    }

    // Queue the context as "active" with transmission pending in 'Next Sent'
    // sort order, i.e. at the tail.
    //
    InsertTailList( &pTunnel->listSendsOut, &pCs->linkSendsOut );

    // See if the send window allows it to go now.
    //
    ScheduleTunnelWork(
        pTunnel, NULL, SendPending,
        0, 0, 0, 0, FALSE, FALSE );
}


VOID
SendPending(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to try to send pending messages from the
    // "outstanding send" list until the send window is full.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;
    CONTROLSENT* pCs;
    ULONG ulFlags;

    TRACE( TL_N, TM_Send, ( "SendPending(sout=%d,sw=%d)",
        pTunnel->ulSendsOut, pTunnel->ulSendWindow ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        for (;;)
        {
            if (pTunnel->ulSendsOut >= pTunnel->ulSendWindow)
            {
                // The send window is closed.
                //
                break;
            }

            // Scan the "outstanding send" queue for the next send context
            // pending transmission.  Can't save our place for the next
            // iteration because the lock must be released and re-acquired
            // below to send the packet.
            //
            for (pLink = pTunnel->listSendsOut.Flink;
                 pLink != &pTunnel->listSendsOut;
                 pLink = pLink->Flink)
            {
                pCs = CONTAINING_RECORD( pLink, CONTROLSENT, linkSendsOut );
                if (pCs->ulFlags & CSF_Pending)
                {
                    break;
                }
            }

            if (pLink == &pTunnel->listSendsOut)
            {
                // There is nothing pending.
                //
                break;
            }

            // The send window is open and a pending send has been found.
            // Mark the context "not pending" and close the window by one to
            // account for the coming send.
            //
            ulFlags = pCs->ulFlags;
            pCs->ulFlags &= ~(CSF_Pending | CSF_QueryMediaSpeed);
            ++pTunnel->ulSendsOut;

            // Cancel any pending delayed acknowledge timeout, because the
            // acknowledge will piggyback on this packet.
            //
            if (pTunnel->pTqiDelayedAck)
            {
                TimerQCancelItem( pTunnel->pTimerQ, pTunnel->pTqiDelayedAck );
                pTunnel->pTqiDelayedAck = NULL;
            }

            if (pCs->ulRetransmits == 0)
            {
                LARGE_INTEGER lrgTime;

                // This is the original send so note the time sent.
                //
                NdisGetCurrentSystemTime( &lrgTime );
                pCs->llTimeSent = lrgTime.QuadPart;
            }
            else
            {
                // In the retransmission, the 'Next Send' is the same as the
                // original, but the 'Next Receive' field is updated.
                //
                UpdateControlHeaderNr( pCs->pBuffer, pTunnel->usNr );
            }

            // Take a reference that will be removed in the send completion
            // routine.
            //
            ReferenceControlSent( pCs );

            TRACE( TL_A, TM_CMsg, ( "%sSEND(%d) %s, +sout=%d, to=%d",
                ((g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: "),
                pCs->ulRetransmits,
                MsgTypePszFromUs( pCs->usMsgType ),
                pTunnel->ulSendsOut,
                pTunnel->ulSendTimeoutMs ) );
            DUMPW( TL_A, TM_MDmp, pCs->pBuffer, pCs->ulBufferLength );

            NdisReleaseSpinLock( &pTunnel->lockT );

            // query media speed if necessary
            if(ulFlags & CSF_QueryMediaSpeed)
            {
                TdixGetInterfaceInfo(&pAdapter->tdix, 
                                     pTunnel->myaddress.ulIpAddress, 
                                     &pTunnel->ulMediaSpeed);
            }

            {
                FILE_OBJECT* FileObj;
                PTDIX_SEND_HANDLER SendFunc;

                // Call TDI to send the control message.
                //
                if (ReadFlags(&pTunnel->ulFlags) & TCBF_SendConnected) {

                    ASSERT(pTunnel->pRoute != NULL);

                    FileObj = 
                        CtrlObjFromUdpContext(&pTunnel->udpContext);
                    SendFunc = TdixSend;
                } else {
                    FileObj = NULL;
                    SendFunc = TdixSendDatagram;
                }

                status = SendFunc(&pAdapter->tdix,
                                  FileObj,
                                  SendControlComplete,
                                  pCs,
                                  NULL,
                                  &pTunnel->address,
                                  pCs->pBuffer,
                                  pCs->ulBufferLength,
                                  &pCs->pIrp );

                ASSERT( status == NDIS_STATUS_PENDING );
            }
            NdisAcquireSpinLock( &pTunnel->lockT );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
SendPayload(
    IN VCCB* pVc,
    IN NDIS_PACKET* pPacket )

    // Sends payload packet 'pPacket' on VC 'pVc' eventually calling
    // NdisMCoSendComplete with the result.
    //
    // IMPORTANT: Caller must not hold any locks.
    //
{
    NDIS_STATUS status;
    TUNNELCB* pTunnel;
    ADAPTERCB* pAdapter;
    CHAR* pBuffer;

    TRACE( TL_V, TM_Send, ( "SendPayload" ) );

    pAdapter = pVc->pAdapter;
    pTunnel = pVc->pTunnel;
    status = NDIS_STATUS_SUCCESS;

    if (pTunnel)
    {
        if (ReadFlags( &pTunnel->ulFlags ) & TCBF_HostRouteAdded)
        {
            // Take a reference on the call.  For unsequenced sends, this is
            // released when the TdixSendDatagram completes.  For sequenced
            // sends, it is released when the PAYLOADSENT context is freed.
            //
            if (ReferenceCall( pVc ))
            {
                // Get an NDIS_BUFFER to hold the L2TP header that will be
                // tacked onto the front of NDISWAN's PPP-framed data packet.
                //
                pBuffer = GetBufferFromPool( &pAdapter->poolHeaderBuffers );
                if (!pBuffer)
                {
                    ASSERT( !"GetBfP?" );
                    DereferenceCall( pVc );
                    status = NDIS_STATUS_RESOURCES;
                }
            }
            else
            {
                TRACE( TL_A, TM_Send, ( "Send on inactive $%p", pVc ) );
                status = NDIS_STATUS_FAILURE;
            }
        }
        else
        {
            TRACE( TL_A, TM_Send, ( "SendPayload w/o host route?" ) );
            status = NDIS_STATUS_FAILURE;
        }
    }
    else
    {
        TRACE( TL_A, TM_Send, ( "Send $%p w/o pT?", pVc ) );
        status = NDIS_STATUS_FAILURE;
    }

    if (status != NDIS_STATUS_SUCCESS)
    {
        NDIS_SET_PACKET_STATUS( pPacket, status );
        TRACE( TL_A, TM_Send, ( "NdisMCoSendComp($%x)", status ) );
        NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
        TRACE( TL_N, TM_Send, ( "NdisMCoSendComp done" ) );
        return;
    }

    if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
    {
         ScheduleTunnelWork(
             pTunnel, pVc, SendPayloadSeq,
             (ULONG_PTR )pPacket, (ULONG_PTR )pBuffer, 0, 0, FALSE, FALSE );
    }
    else
    {
         ScheduleTunnelWork(
             pTunnel, pVc, SendPayloadUnseq,
             (ULONG_PTR )pPacket, (ULONG_PTR )pBuffer, 0, 0, FALSE, FALSE );
    }
}


VOID
SendPayloadSeq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to handle sending a sequenced payload packet on a
    // VC.  Arg0 is the packet to send.  Arg1 is the header buffer to fill in.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    PAYLOADSENT* pPs;
    TIMERQITEM* pTqiSendTimeout;
    LARGE_INTEGER lrgTime;
    ULONG ulLength;
    ULONG ulFullLength;
    NDIS_PACKET* pPacket;
    CHAR* pBuffer;
    NDIS_BUFFER* pNdisBuffer;
    USHORT usNs;

    TRACE( TL_V, TM_Send, ( "SendPayloadSeq" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    pPacket = (NDIS_PACKET* )(punpArgs[ 0 ]);
    pBuffer = (CHAR* )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    pTqiSendTimeout = NULL;
    pPs = NULL;

    do
    {
        // Get an "unacknowledged send timeout" timer event descriptor.
        //
        pTqiSendTimeout = ALLOC_TIMERQITEM( pAdapter );
        if (!pTqiSendTimeout)
        {
            ASSERT( !"Alloc TQI?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Get a "payload message sent" context.
        //
        pPs = ALLOC_PAYLOADSENT( pAdapter );
        if (!pPs)
        {
            ASSERT( !"Alloc PS?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock( &pVc->lockV );
        {
            // Retrieve the 'Next Send' value to assign this packet, then
            // bump the counter for the next guy.
            //
            usNs = pVc->usNs;
            ++pVc->usNs;

            // Build an L2TP payload header with Ns/Nr fields in
            // 'pBuffer'.
            //
            ulLength =
                BuildL2tpHeader(
                    pBuffer,
                    FALSE,
                    FALSE,
                    &pTunnel->usAssignedTunnelId,
                    &pVc->usAssignedCallId,
                    &usNs,
                    pVc->usNr );

            // Pare down the header buffer to the actual length used then
            // chain it onto the PPP-framed data we got from NDISWAN.
            //
            pNdisBuffer = NdisBufferFromBuffer( pBuffer );
            NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );
            NdisChainBufferAtFront( pPacket, pNdisBuffer );
            NdisQueryPacket( pPacket, NULL, NULL, NULL, &ulFullLength );
            UpdateHeaderLength( pBuffer, (USHORT )ulFullLength );

            // Cancel any pending delayed acknowledge timeout, because the
            // acknowledge will piggyback on this packet.
            //
            if (pVc->pTqiDelayedAck)
            {
                TimerQCancelItem( pTunnel->pTimerQ, pVc->pTqiDelayedAck );
                pVc->pTqiDelayedAck = NULL;
            }

            // Fill the "payload message sent" context with the information
            // needed to track the progress of the payload's acknowledgement.
            //
            pPs->usNs = usNs;
            pPs->lRef = 0;
            TimerQInitializeItem( pTqiSendTimeout );
            pPs->pTqiSendTimeout = pTqiSendTimeout;
            pPs->pPacket = pPacket;
            pPs->pBuffer = pBuffer;

            ReferenceTunnel( pTunnel, FALSE );
            pPs->pTunnel = pTunnel;

            ReferenceVc( pVc );
            pPs->pVc = pVc;

            pPs->status = NDIS_STATUS_FAILURE;
            NdisGetCurrentSystemTime( &lrgTime );
            pPs->llTimeSent = lrgTime.QuadPart;
            pPs->pIrp = NULL;

            // Link the payload in the "outstanding" list and take a reference
            // on the context corresponding to this linkage.  Take a second
            // reference that will be removed by the send completion handler.
            // Take a third that will be removed by the timer event handler.
            //
            ReferencePayloadSent( pPs );
            InsertTailList( &pVc->listSendsOut, &pPs->linkSendsOut );
            ReferencePayloadSent( pPs );
            ReferencePayloadSent( pPs );

#ifdef PSDEBUG
            {
                extern LIST_ENTRY g_listDebugPs;
                extern NDIS_SPIN_LOCK g_lockDebugPs;

                NdisAcquireSpinLock( &g_lockDebugPs );
                {
                    InsertTailList( &g_listDebugPs, &pPs->linkDebugPs );
                }
                NdisReleaseSpinLock( &g_lockDebugPs );
            }
#endif

            TimerQScheduleItem(
                pTunnel->pTimerQ,
                pPs->pTqiSendTimeout,
                pVc->ulSendTimeoutMs,
                SendPayloadTimerEvent,
                pPs );

            TRACE( TL_A, TM_Msg,
                ( "%sSEND payload, len=%d Ns=%d Nr=%d to=%d",
                ((g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: "),
                ulFullLength, pPs->usNs, pVc->usNr, pVc->ulSendTimeoutMs ) );
            DUMPW( TL_A, TM_MDmp, pPs->pBuffer, ulLength );

            ++pVc->stats.ulSentDataPacketsSeq;
            pVc->stats.ulDataBytesSent += (ulFullLength - ulLength);
            pVc->stats.ulSendWindowTotal += pVc->ulSendWindow;
        }
        NdisReleaseSpinLock( &pVc->lockV );

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        FreeBufferToPool( &pAdapter->poolHeaderBuffers, pBuffer, TRUE );

        if (pTqiSendTimeout)
        {
            FREE_TIMERQITEM( pAdapter, pTqiSendTimeout );
        }

        ASSERT( !pPs );

        // Complete the send, indicating the failure.
        //
        NDIS_SET_PACKET_STATUS( pPacket, status );
        TRACE( TL_A, TM_Send, ( "NdisMCoSendComp($%x)", status ) );
        NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
        TRACE( TL_N, TM_Send, ( "NdisMCoSendComp done" ) );
        return;
    }

    // Call TDI to send the payload message.
    //
    {
        FILE_OBJECT* FileObj;
        PTDIX_SEND_HANDLER SendFunc;

        if (ReadFlags(&pTunnel->ulFlags) & TCBF_SendConnected) {

            ASSERT(pTunnel->pRoute != NULL);

            FileObj =  PayloadObjFromUdpContext(&pTunnel->udpContext);
            SendFunc = TdixSend;
        } else {
            FileObj = NULL;
            SendFunc = TdixSendDatagram;
        }
    
        status = SendFunc(&pAdapter->tdix,
                          FileObj,
                          SendPayloadSeqComplete,
                          pPs,
                          NULL,
                          &pTunnel->address,
                          pBuffer,
                          ulFullLength,
                          &pPs->pIrp );
    }

    ASSERT( status == NDIS_STATUS_PENDING );
}


VOID
SendPayloadUnseq(
    TUNNELWORK* pWork,
    TUNNELCB* pTunnel,
    VCCB* pVc,
    ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to handle sending an unsequenced payload packet
    // on a VC.  Arg0 is the NDIS_PACKET.  Arg1 is the header buffer to fill
    // in.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    ULONG ulLength;
    UINT unFullLength;
    NDIS_PACKET* pPacket;
    CHAR* pBuffer;
    NDIS_BUFFER* pNdisBuffer;

    TRACE( TL_V, TM_Send, ( "SendPayloadUnseq" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    pPacket = (NDIS_PACKET* )(punpArgs[ 0 ]);
    pBuffer = (CHAR* )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    NdisAcquireSpinLock( &pVc->lockV );
    {
        // Build an L2TP payload header without Ns/Nr fields in 'pBuffer'.
        //
        ulLength =
            BuildL2tpHeader(
                pBuffer,
                FALSE,
                FALSE,
                &pTunnel->usAssignedTunnelId,
                &pVc->usAssignedCallId,
                NULL,
                0 );

        // Pare down the header buffer to the actual length used then
        // chain it onto the PPP-framed data we got from NDISWAN.  Poke
        // the L2TP header to update the length field accounting for the
        // data.
        //
        pNdisBuffer = NdisBufferFromBuffer( pBuffer );
        NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );
        NdisChainBufferAtFront( pPacket, pNdisBuffer );
        NdisQueryPacket( pPacket, NULL, NULL, NULL, &unFullLength );
        UpdateHeaderLength( pBuffer, (USHORT )unFullLength );

        TRACE( TL_A, TM_Msg,
             ( "%sSEND payload(%d), len=%d",
             ((g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: "),
             ++pVc->usNs,
             unFullLength ) );
        DUMPW( TL_A, TM_MDmp, pBuffer, ulLength );

        ++pVc->stats.ulSentDataPacketsUnSeq;
        pVc->stats.ulDataBytesSent += ((ULONG )unFullLength - ulLength);
    }
    NdisReleaseSpinLock( &pVc->lockV );

    // Call TDI to send the payload message.
    //
    {
        FILE_OBJECT* FileObj;
        PTDIX_SEND_HANDLER SendFunc;

        NdisAcquireSpinLock(&pTunnel->lockT);

        if (pTunnel->pRoute != NULL) {
            FileObj = PayloadObjFromUdpContext(&pTunnel->udpContext);
            SendFunc = TdixSend;
        } else {
            FileObj = NULL;
            SendFunc = TdixSendDatagram;
        }

        NdisReleaseSpinLock(&pTunnel->lockT);

        status = SendFunc(&pAdapter->tdix,
                          FileObj,
                          SendPayloadUnseqComplete,
                          pVc,
                          pPacket,
                          &pTunnel->address,
                          pBuffer,
                          (ULONG )unFullLength,
                          NULL );
    }

    ASSERT( status == NDIS_STATUS_PENDING );
}


VOID
SendControlAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to send a control acknowledge.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Send, ( "SendControlAck" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    SendZlb( pTunnel, NULL, pTunnel->usNs, pTunnel->usNr, FALSE );
}


VOID
SendPayloadAck(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to send a payload acknowledge.
    //
    // This routine is called only at PASSIVE IRQL.
    //
    // IMPORTANT: Caller must take a call reference before calling that is
    //            removed by the send completion handler.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Send, ( "SendPayloadAck" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    ASSERT( pVc );
    ASSERT( pVc->usAssignedCallId > 0 );

    SendZlb( pTunnel, pVc, pVc->usNs, pVc->usNr, FALSE );
}


VOID
SendPayloadReset(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to send a payload reset.  Arg0 is the "Next Sent"
    // value to send in the reset message.
    //
    // This routine is called only at PASSIVE IRQL.
    //
    // IMPORTANT: Caller must take a call reference before calling that is
    //            removed by the send completion handler.
    //
{
    ADAPTERCB* pAdapter;
    USHORT usNs;

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    usNs = (USHORT )(punpArgs[ 0 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    TRACE( TL_A, TM_Send, ( "Send Reset=%d", (LONG )usNs ) );
    ASSERT( pVc );
    ASSERT( pVc->usAssignedCallId > 0 );

    SendZlb( pTunnel, pVc, usNs, pVc->usNr, TRUE );
}


VOID
ReferenceControlSent(
    IN CONTROLSENT* pCs )

    // Reference the control-sent context 'pCs'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pCs->lRef );
    TRACE( TL_N, TM_Ref, ( "RefCs to %d", lRef ) );
}


LONG
DereferenceControlSent(
    IN CONTROLSENT* pCs )

    // Reference the control-sent context 'pCs'.
    //
    // Returns the reference count of the dereferenced context.
    //
{
    LONG lRef;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pNdisBuffer;

    lRef = NdisInterlockedDecrement( &pCs->lRef );
    TRACE( TL_N, TM_Ref, ( "DerefCs to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        pAdapter = pCs->pTunnel->pAdapter;

        ASSERT( pCs->linkSendsOut.Flink == &pCs->linkSendsOut );

        pNdisBuffer = NdisBufferFromBuffer( pCs->pBuffer );
        NdisAdjustBufferLength(
            pNdisBuffer, BufferSizeFromBuffer( pCs->pBuffer ) );
        FreeBufferToPool(
            &pAdapter->poolFrameBuffers, pCs->pBuffer, TRUE );

        if (pCs->pVc)
        {
            DereferenceVc( pCs->pVc );
        }

        ASSERT( pCs->pTunnel )
        DereferenceTunnel( pCs->pTunnel );

        FREE_TIMERQITEM( pAdapter, pCs->pTqiSendTimeout );
        FREE_CONTROLSENT( pAdapter, pCs );
    }

    return lRef;
}


VOID
ReferencePayloadSent(
    IN PAYLOADSENT* pPs )

    // Reference the payload-sent context 'pPs'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pPs->lRef );
    TRACE( TL_N, TM_Ref, ( "RefPs to %d", lRef ) );
}


LONG
DereferencePayloadSent(
    IN PAYLOADSENT* pPs )

    // Reference the payload-sent context 'pPs'.
    //
    // Returns the reference count of the dereferenced context.
    //
{
    LONG lRef;
    ADAPTERCB* pAdapter;

    lRef = NdisInterlockedDecrement( &pPs->lRef );
    TRACE( TL_N, TM_Ref, ( "DerefPs to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ASSERT( pPs->linkSendsOut.Flink == &pPs->linkSendsOut );

        // The actual work is scheduled because it calls outside the driver
        // and we don't want any lock restrictions on this routine.
        //
        ScheduleTunnelWork(
            pPs->pTunnel, pPs->pVc, CompletePayloadSent,
            (ULONG_PTR )pPs, 0, 0, 0, FALSE, FALSE );
    }

    return lRef;
}


//-----------------------------------------------------------------------------
// Send utility routines (alphabetically)
//-----------------------------------------------------------------------------

USHORT
BuildAvpAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp )

    // Builds a byte-array-valued AVP in caller's buffer 'pAvp' with attribute
    // field value 'usAttribute' and value the first 'usValueLength' bytes of
    // array 'pszlValue'.  'FMandatory' indicates the M-bit should be set in
    // the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    if (usValueLength)
    {
        NdisMoveMemory( (CHAR* )pusCur, pszValue, (ULONG )usValueLength );
        ((CHAR* )pusCur) += usValueLength;
    }

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpAul(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN UNALIGNED ULONG* pulValue,
    IN USHORT usValues,
    OUT CHAR* pAvp )

    // Builds a ULONG-array-valued AVP in caller's buffer 'pAvp' with
    // attribute field value 'usAttribute' and value the first 'usValues'
    // ULONGS of array 'pszlValue'.  'FMandatory' indicates the M-bit should
    // be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;
    USHORT i;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    for (i = 0; i < usValues; ++i)
    {
        *((UNALIGNED ULONG* )pusCur) = pulValue[ i ];
        *((UNALIGNED ULONG* )pusCur) = htonl( *((UNALIGNED ULONG* )pusCur) );
        pusCur += 2;
    }

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpFlag(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    OUT CHAR* pAvp )

    // Builds an empty (no data) flag AVP in caller's buffer 'pAvp' with
    // attribute field value 'usAttribute'.  'FMandatory' indicates the M-bit
    // should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpUl(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN ULONG ulValue,
    OUT CHAR* pAvp )

    // Builds a ULONG-valued AVP in caller's buffer 'pAvp' with attribute
    // field value 'usAttribute' and value 'ulValue'.  'FMandatory' indicates
    // the M-bit should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    *((UNALIGNED ULONG* )pusCur) = htonl( ulValue );
    pusCur += 2;

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvpUs(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue,
    OUT CHAR* pAvp )

    // Builds a USHORT-valued AVP in caller's buffer 'pAvp' with attribute
    // field value 'usAttribute' and value 'usValue'.  'FMandatory' indicates
    // the M-bit should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set Value field.
    //
    *pusCur = htons( usValue );
    ++pusCur;

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


USHORT
BuildAvp2UsAndAch(
    IN USHORT usAttribute,
    IN BOOLEAN fMandatory,
    IN USHORT usValue1,
    IN USHORT usValue2,
    IN CHAR* pszValue,
    IN USHORT usValueLength,
    OUT CHAR* pAvp )

    // Builds an AVP consisting of 'usValue1' and 'usValue2' followed by
    // message 'pszValue' of length 'usValueLength' bytes in caller's buffer
    // 'pAvp' with attribute field value 'usAttribute'.  'FMandatory'
    // indicates the M-bit should be set in the AVP.
    //
    // Returns the length of the built AVP.
    //
{
    UNALIGNED USHORT* pusCur;
    UNALIGNED USHORT* pusBits;
    USHORT usLength;

    pusCur = (UNALIGNED USHORT* )pAvp;
    pusBits = pusCur;
    ++pusCur;

    // Set Vendor ID to "IETF-defined".
    //
    *pusCur = 0;
    ++pusCur;

    // Set Attribute field.
    //
    *pusCur = htons( usAttribute );
    ++pusCur;

    // Set first USHORT value field.
    //
    *pusCur = htons( usValue1 );
    ++pusCur;

    // Set second USHORT value field.
    //
    *pusCur = htons( usValue2 );
    ++pusCur;

    // Set message value field.
    //
    if (usValueLength)
    {
        NdisMoveMemory( (CHAR* )pusCur, pszValue, (ULONG )usValueLength );
        ((CHAR*)pusCur) += usValueLength;
    }

    // Now, go back and set bits/length field.
    //
    usLength = (USHORT )(((CHAR* )pusCur) - pAvp);
    *pusBits = usLength;
    if (fMandatory)
    {
        *pusBits |= ABM_M;
    }
    *pusBits = htons( *pusBits );

    return usLength;
}


VOID
BuildCdnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing CallDisconnNotify control
    // message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'ulArg1' and 'ulArg2' are the result and error codes to be returned.
    // 'pvArg3' is ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    USHORT usResult;
    USHORT usError;

    TRACE( TL_V, TM_Send, ( "BuildCdnAvps" ) );

    usResult = (USHORT )ulArg1;
    usError = (USHORT )ulArg2;

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_CDN, pCurAvp );

    pCurAvp += BuildAvp2UsAndAch(
        ATTR_Result, TRUE, usResult, usError, NULL, 0, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildHelloAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Hello control message.
    // 'PTunnel' is the tunnel control block.  'PVc', 'ulArgX' and 'pvArg3' are ignored.
    // 'PAvpBuffer' is the address of the buffer to receive the built AVPs.
    // '*PulAvpLength' is set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildHelloAvps" ) );

    pAdapter = pTunnel->pAdapter;
    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_Hello, pCurAvp );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildIccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Incoming-Call-Connected
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;
    BOOLEAN fSequencing;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildIccnAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_ICCN, pCurAvp );

    // For now, we don't support WAN link relays, so this is the estimated
    // speed of the LAN relay.  This could be totally wrong if, for instance,
    // the tunnel is itself tunneled over a PPP link.
    //
    pCurAvp += BuildAvpUl(
        ATTR_TxConnectSpeed, TRUE, pVc->ulConnectBps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingType, TRUE, FBM_Sync, pCurAvp );

    fSequencing = !!(ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing);
    if (fSequencing)
    {
        USHORT usRWindow;

        usRWindow = pAdapter->usPayloadReceiveWindow;
        if (!usRWindow)
        {
            usRWindow = L2TP_DefaultReceiveWindow;
        }

        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, usRWindow, pCurAvp );
    }

#if 0
    // Use the LNS default PPD even when we're LAC, for now.
    //
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    pCurAvp += BuildAvpUs(
        ATTR_ProxyAuthType, FALSE, PAT_None, pCurAvp );

    if (fSequencing)
    {
        pCurAvp += BuildAvpFlag(
            ATTR_SequencingRequired, TRUE, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildIcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Incoming-Call-Reply
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildIcrpAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_ICRP, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
    {
        USHORT usRWindow;

        usRWindow = pAdapter->usPayloadReceiveWindow;
        if (!usRWindow)
            usRWindow = L2TP_DefaultReceiveWindow;

        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, usRWindow, pCurAvp );
    }

#if 0
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildIcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Incoming-Call-Request
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control block.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildIcrqAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_ICRQ, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_CallSerialNumber, TRUE,
        pVc->pLcParams->ulCallSerialNumber, pCurAvp );

    {
        ULONG ulBearerType;

        ulBearerType = 0;
        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DATAMODEM)
        {
            ulBearerType |= BBM_Analog;
        }

        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DIGITALDATA)
        {
            ulBearerType |= BBM_Digital;
        }

        pCurAvp += BuildAvpUl(
            ATTR_BearerType, TRUE, ulBearerType, pCurAvp );
    }

    if (pVc->pLcParams->ulPhysicalChannelId != 0xFFFFFFFF)
    {
        pCurAvp += BuildAvpUl(
            ATTR_PhysicalChannelId, FALSE,
            pVc->pLcParams->ulPhysicalChannelId, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


ULONG
BuildL2tpHeader(
    IN OUT CHAR* pBuffer,
    IN BOOLEAN fControl,
    IN BOOLEAN fReset,
    IN USHORT* pusTunnelId,
    IN USHORT* pusCallId,
    IN USHORT* pusNs,
    IN USHORT usNr )

    // Fill in caller's 'pBuffer' with an L2TP header matching caller's
    // arguments.  'FControl' indicates to build a control header, otherwise a
    // payload header is built.  'fReset' indicates to build a reset rather
    // than a simple acknowledge.  Arguments that are not to appear in the
    // header are NULL.  Note that 'usNr' is not a pointer because it's
    // appearance in the header is tied to the appearance of 'pusNs'.
    //
    // Returns the total length of the header.
    //
{
    UNALIGNED USHORT* pusBits;
    UNALIGNED USHORT* pusLength;
    UNALIGNED USHORT* pusCur;
    ULONG ulLength;

    pusCur = (UNALIGNED USHORT* )pBuffer;
    pusBits = pusCur;
    ++pusCur;

    pusLength = pusCur;
    ++pusCur;

    // Initialize header bit mask with the version, and set the length bit
    // since the Length field is always sent.
    //
    *pusBits = HBM_L | VER_L2tp;
    if (fControl)
    {
        ASSERT( pusTunnelId && pusCallId && pusNs && !fReset );
        *pusBits |= HBM_T;
    }
    else if (fReset)
    {
        ASSERT( pusTunnelId && pusCallId && pusNs );
        *pusBits |= HBM_R;
    }

    if (pusTunnelId)
    {
        // Tunnel-ID field present.  Draft-05 removes the 'I' bit that used to
        // indicate the Tunnel-ID is present.  It is now assumed to be always
        // present.
        //
        *pusCur = htons( *pusTunnelId );
        ++pusCur;
    }

    if (pusCallId)
    {
        // Call-ID field present.  Draft-05 removes the 'C' bit that used to
        // indicate the Tunnel-ID is present.  It is now assumed to be always
        // present.
        //
        *pusCur = htons( *pusCallId );
        ++pusCur;
    }

    if (pusNs)
    {
        // Ns and Nr fields are present.
        //
        *pusBits |= HBM_F;
        *pusCur = htons( *pusNs );
        ++pusCur;
        *pusCur = htons( usNr );
        ++pusCur;
    }

    // Fill in the header and length fields with the accumulated
    // values.
    //
    *pusBits = htons( *pusBits );
    *pusLength = (USHORT )(((CHAR* )pusCur) - pBuffer);
    ulLength = (ULONG )*pusLength;
    *pusLength = htons( *pusLength );

    return ulLength;
}


VOID
BuildOccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Outgoing-Call-Connected
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;
    BOOLEAN fSequencing;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildOccnAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_OCCN, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_TxConnectSpeed, TRUE, pVc->ulConnectBps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingType, TRUE, FBM_Sync, pCurAvp );

    fSequencing = !!(ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing);
    if (fSequencing)
    {
        USHORT usRWindow;

        usRWindow = pAdapter->usPayloadReceiveWindow;
        if (!usRWindow)
        {
            usRWindow = L2TP_DefaultReceiveWindow;
        }

        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, usRWindow, pCurAvp );
    }

#if 0
    // Use the LNS default PPD even when we're LAC, for now.
    //
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    if (fSequencing)
    {
        pCurAvp += BuildAvpFlag(
            ATTR_SequencingRequired, TRUE, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildOcrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Outgoing-Call-Reply
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control blocks.
    // 'UlArgX' and 'pvArg3' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;

    TRACE( TL_V, TM_Send, ( "BuildOcrpAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_OCRP, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    ASSERT( pVc->pLcParams );
    if (pVc->pLcParams->ulPhysicalChannelId != 0xFFFFFFFF)
    {
        pCurAvp += BuildAvpUl(
            ATTR_PhysicalChannelId, FALSE,
            pVc->pLcParams->ulPhysicalChannelId, pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildOcrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Outgoing-Call-Request
    // control message.  'PTunnel' and 'pVc' are the tunnel/VC control block.
    // 'UlArgX' are ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    pAdapter = pTunnel->pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildOcrqAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_OCRQ, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedCallId, TRUE, pVc->usCallId, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_CallSerialNumber, TRUE,
        pVc->pLcParams->ulCallSerialNumber, pCurAvp );

    {
        ULONG ulBps;

        ulBps = pVc->pTcParams->ulMinRate;
        if (ulBps == 0)
        {
            ulBps = 1;
        }
        else if (ulBps > 0x7FFFFFFF)
        {
            ulBps = 0x7FFFFFFF;
        }

        pCurAvp += BuildAvpUl(
            ATTR_MinimumBps, TRUE, ulBps, pCurAvp );

        ulBps = pVc->pTcParams->ulMaxRate;
        if (ulBps == 0)
        {
            ulBps = 1;
        }
        else if (ulBps > 0x7FFFFFFF)
        {
            ulBps = 0x7FFFFFFF;
        }

        pCurAvp += BuildAvpUl(
            ATTR_MaximumBps, TRUE, ulBps, pCurAvp );
    }

    {
        ULONG ulBearerType;

        ulBearerType = 0;
        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DATAMODEM)
        {
            ulBearerType |= BBM_Analog;
        }

        if (pVc->pTcParams->ulMediaMode & LINEMEDIAMODE_DIGITALDATA)
        {
            ulBearerType |= BBM_Digital;
        }

        pCurAvp += BuildAvpUl(
            ATTR_BearerType, TRUE, ulBearerType, pCurAvp );
    }

    pCurAvp += BuildAvpUl(
        ATTR_FramingType, TRUE, FBM_Sync, pCurAvp );

    if (ReadFlags( &pVc->ulFlags ) & VCBF_Sequencing)
    {
        ASSERT( pAdapter->usPayloadReceiveWindow );
        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE,
            pAdapter->usPayloadReceiveWindow, pCurAvp );
    }

#if 0
    pCurAvp += BuildAvpUs(
        ATTR_PacketProcDelay, TRUE, L2TP_LnsDefaultPpd, pCurAvp );
#endif

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildScccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Start-Cc-Connected
    // control message.  'PTunnel' is the tunnel control block.  'PVc' is
    // ignored.  'UlArg1' is the true if a challenge response is to be sent,
    // false otherwise.  'UlArg2' and 'pvArg3' are ignored.  'PAvpBuffer' is
    // the address of the buffer to receive the built AVPs.  '*PulAvpLength'
    // is set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;

    TRACE( TL_V, TM_Send, ( "BuildScccnAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_SCCCN, pCurAvp );

    if (ulArg1)
    {
        pCurAvp += BuildAvpAch(
            ATTR_ChallengeResponse, TRUE,
            pTunnel->achResponseToSend, sizeof(pTunnel->achResponseToSend),
            pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildSccrpAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Start-Cc-Reply control
    // message.  'PTunnel' is the tunnel control block.  'PVc' is ignored.
    // 'UlArg1' is true if a challenge response is to be sent, false
    // otherwise.  'UlArg2' and 'pvArg3' are ignored.  'PAvpBuffer' is the
    // address of the buffer to receive the built AVPs.  '*PulAvpLength' is
    // set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Send, ( "BuildSccrpAvps" ) );

    pAdapter = pTunnel->pAdapter;

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_SCCRP, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_ProtocolVersion, TRUE, L2TP_ProtocolVersion, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingCaps, TRUE, pAdapter->ulFramingCaps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_BearerCaps, TRUE, pAdapter->ulBearerCaps, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_FirmwareRevision, FALSE, L2TP_FirmwareRevision, pCurAvp );

    ASSERT( pAdapter->pszHostName );
    pCurAvp += BuildAvpAch(
        ATTR_HostName, TRUE,
        pAdapter->pszHostName,
        (USHORT )strlen( pAdapter->pszHostName ),
        pCurAvp );

    pCurAvp += BuildAvpAch(
        ATTR_VendorName, FALSE,
        L2TP_VendorName, (USHORT )strlen( L2TP_VendorName ), pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedTunnelId, TRUE, pTunnel->usTunnelId, pCurAvp );

    if (pAdapter->usControlReceiveWindow)
    {
        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE,
            pAdapter->usControlReceiveWindow, pCurAvp );
    }

    if (pAdapter->pszPassword)
    {
        pCurAvp += BuildAvpAch(
            ATTR_Challenge, TRUE,
            pTunnel->achChallengeToSend,
            sizeof(pTunnel->achChallengeToSend),
            pCurAvp );
    }

    if (ulArg1)
    {
        pCurAvp += BuildAvpAch(
            ATTR_ChallengeResponse, TRUE,
            pTunnel->achResponseToSend,
            sizeof(pTunnel->achResponseToSend),
            pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildSccrqAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Start-Cc-Request control
    // message.  'PTunnel' is the tunnel control block.  'PVc', 'ulArgX' and 'pvArg3'
    // are ignored.  'PAvpBuffer' is the address of the buffer to receive the
    // built AVPs.  '*PulAvpLength' is set to the length of the built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;

    TRACE( TL_V, TM_Send, ( "BuildSccrqAvps" ) );

    pAdapter = pTunnel->pAdapter;
    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_SCCRQ, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_ProtocolVersion, TRUE, L2TP_ProtocolVersion, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_FramingCaps, TRUE, pAdapter->ulFramingCaps, pCurAvp );

    pCurAvp += BuildAvpUl(
        ATTR_BearerCaps, TRUE, pAdapter->ulBearerCaps, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_FirmwareRevision, FALSE, L2TP_FirmwareRevision, pCurAvp );

    if (pAdapter->pszHostName)
    {
        pCurAvp += BuildAvpAch(
            ATTR_HostName, TRUE,
            pAdapter->pszHostName,
            (USHORT )strlen( pAdapter->pszHostName ),
            pCurAvp );
    }

    pCurAvp += BuildAvpAch(
        ATTR_VendorName, FALSE,
        L2TP_VendorName, (USHORT )strlen( L2TP_VendorName ), pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedTunnelId, TRUE, pTunnel->usTunnelId, pCurAvp );

    if (pAdapter->usControlReceiveWindow)
    {
        pCurAvp += BuildAvpUs(
            ATTR_RWindowSize, TRUE, pAdapter->usControlReceiveWindow, pCurAvp );
    }

    if (pAdapter->pszPassword)
    {
        pCurAvp += BuildAvpAch(
            ATTR_Challenge, TRUE,
            pTunnel->achChallengeToSend,
            sizeof(pTunnel->achChallengeToSend),
            pCurAvp );
    }

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildStopccnAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Stop-Cc-Notify control
    // message.  'PTunnel' is the tunnel control block.  'PVc' is ignored.
    // 'ulArg1' and 'ulArg2' are the result and error codes to be sent.
    // 'pvArg3' is ignored.  'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    USHORT usResult;
    USHORT usError;

    TRACE( TL_V, TM_Send, ( "BuildStopCcReqAvps" ) );

    usResult = (USHORT )ulArg1;
    usError = (USHORT )ulArg2;

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_StopCCN, pCurAvp );

    pCurAvp += BuildAvpUs(
        ATTR_AssignedTunnelId, TRUE, pTunnel->usTunnelId, pCurAvp );

    pCurAvp += BuildAvp2UsAndAch(
        ATTR_Result, TRUE, usResult, usError, NULL, 0, pCurAvp );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
BuildWenAvps(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN PVOID pvArg3,
    IN OUT CHAR* pAvpBuffer,
    OUT ULONG* pulAvpLength )

    // PBUILDAVPS handler to add AVPs to an outgoing Wan-Error-Notify control
    // message.  'PTunnel' and 'pVc' are the tunnel/VC control block.
    // 'pvArg3' is the address of an array of 6 error ULONGs, i.e. CRC,
    // framing, hardware overrun, buffer overrun, timeouts, and alignment
    // errors that this routine FREE_NONPAGEDs after use. 'ulArgX' are ignored.  
    // 'PAvpBuffer' is the address of the buffer to
    // receive the built AVPs.  '*PulAvpLength' is set to the length of the
    // built AVPs.
    //
{
    CHAR* pCurAvp;
    ULONG ulAvpLength;
    ADAPTERCB* pAdapter;
    UNALIGNED ULONG* pul;

    pAdapter = pTunnel->pAdapter;
    pul = (UNALIGNED ULONG* )pvArg3;

    TRACE( TL_V, TM_Send, ( "BuildWenAvps" ) );

    pCurAvp = pAvpBuffer;

    pCurAvp += BuildAvpUs(
        ATTR_MsgType, TRUE, CMT_WEN, pCurAvp );

    pCurAvp += BuildAvpAul(
        ATTR_CallErrors, TRUE, pul, 6, pCurAvp );
    FREE_NONPAGED( pul );

    *pulAvpLength = (ULONG )(pCurAvp - pAvpBuffer);
}


VOID
CompletePayloadSent(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to complete a "sent payload".  Arg0 is the
    // PAYLOADSENT context which has already been de-queued from the
    // "outstanding send" list.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    PAYLOADSENT* pPs;
    NDIS_BUFFER* pNdisBuffer;

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    pPs = (PAYLOADSENT* )(punpArgs[ 0 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    TRACE( TL_N, TM_Send, ( "CompletePayloadSent(Ns=%d)", (UINT )pPs->usNs ) );

    // Undo the adjustments made before the send so the owner of each
    // component resource gets back what they originally provided for clean-up
    // and recycling.
    //
    NdisUnchainBufferAtFront( pPs->pPacket, &pNdisBuffer );
    NdisAdjustBufferLength(
        pNdisBuffer, BufferSizeFromBuffer( pPs->pBuffer ) );
    FreeBufferToPool( &pAdapter->poolHeaderBuffers, pPs->pBuffer, TRUE );

    // Notify sending driver of the result.
    //
    NDIS_SET_PACKET_STATUS( pPs->pPacket, pPs->status );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp(s=$%x)", pPs->status ) );
    NdisMCoSendComplete( pPs->status, pPs->pVc->NdisVcHandle, pPs->pPacket );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp done" ) );

    DereferenceCall( pVc );
    DereferenceTunnel( pPs->pTunnel );
    DereferenceVc( pPs->pVc );

#ifdef PSDEBUG
    {
        extern LIST_ENTRY g_listDebugPs;
        extern NDIS_SPIN_LOCK g_lockDebugPs;

        NdisAcquireSpinLock( &g_lockDebugPs );
        {
            RemoveEntryList( &pPs->linkDebugPs );
            InitializeListHead( &pPs->linkDebugPs );
        }
        NdisReleaseSpinLock( &g_lockDebugPs );
    }
#endif

    FREE_TIMERQITEM( pAdapter, pPs->pTqiSendTimeout );
    FREE_PAYLOADSENT( pAdapter, pPs );
}


VOID
SendControlComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for sends that send only a single buffer from
    // the 'ADAPTERCB.poolFrameBuffers' pool.
    //
{
    CONTROLSENT* pCs;
    ULONG ulSendTimeoutMs;

    TRACE( TL_V, TM_Send, ( "SendControlComp" ) );

    pCs = (CONTROLSENT* )pContext1;
    pCs->pIrp = NULL;

    // "Instant expire" the timer if the message is longer queued as an
    // outstanding send, i.e. it's been cancelled or terminated.  This is the
    // easiest way to clean up quickly yet reliably in this odd case.
    // Accessing the link and the send timeout without locks held is
    // technically not allowed, but the consequence of a misread is just a
    // very slight additional delay.  This is judged preferable to adding the
    // cost of taking and releasing a spinlock to every send.
    //
    if (pCs->linkSendsOut.Flink == &pCs->linkSendsOut)
    {
        ulSendTimeoutMs = 0;
        TRACE( TL_A, TM_Send,
            ( "Instant expire pCs=$%p pT=%p", pCs, pCs->pTunnel ) );
    }
    else
    {
        ulSendTimeoutMs = pCs->pTunnel->ulSendTimeoutMs;
    }

    // Schedule a retransmit of the packet, should it go unacknowledged.  This
    // occurs here rather than in SendPending to remove any chance of having
    // the same MDL chain outstanding in two separate calls to the IP stack.
    //
    // Note: The logical code commented out below can be omitted for
    // efficiency because the ReferenceControlSent for this scheduled timer
    // and the DereferenceControlSent for this completed send cancel each
    // other out.
    //
    // ReferenceControlSent( pCs );
    // DereferenceControlSent( pCs );
    //
    ASSERT( pCs->pTqiSendTimeout );
    TimerQScheduleItem(
        pCs->pTunnel->pTimerQ,
        pCs->pTqiSendTimeout,
        ulSendTimeoutMs,
        SendControlTimerEvent,
        pCs );
}


VOID
SendControlTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler set to expire when it's time to give up on
    // receiving an acknowledge to the sent control packet indicated by
    // 'pContext'.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    CONTROLSENT* pCs;

    TRACE( TL_N, TM_Send,
        ( "SendControlTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.  The timer item is owned by the "control
    // sent" context and freed indirectly by dereferencing below.
    //
    pCs = (CONTROLSENT* )pContext;
    pTunnel = pCs->pTunnel;
    pAdapter = pTunnel->pAdapter;

    if (event == TE_Expire)
    {
        // Timer expired, meaning it's time to give up on ever receiving an
        // acknowledge to the sent packet.  Per the draft/RFC, adjustments to
        // the send window and send timeouts are necessary.
        //
        NdisAcquireSpinLock( &pTunnel->lockT );
        do
        {
            if (pCs->linkSendsOut.Flink == &pCs->linkSendsOut)
            {
                // The context is not on the out queue, so it must have been
                // cancelled or terminated while the expire handling was being
                // set up.  Do nothing.
                //
                TRACE( TL_I, TM_Send,
                    ( "T%d: Timeout aborted", (ULONG )pTunnel->usTunnelId ) );
                break;
            }

            AdjustTimeoutsAndSendWindowAtTimeout(
                pAdapter->ulMaxSendTimeoutMs,
                pTunnel->lDeviationMs,
                &pTunnel->ulSendTimeoutMs,
                &pTunnel->ulRoundTripMs,
                &pTunnel->ulSendWindow,
                &pTunnel->ulAcksSinceSendTimeout );

            --pTunnel->ulSendsOut;
            ++pCs->ulRetransmits;

            TRACE( TL_I, TM_Send,
                ( "T%d: TIMEOUT(%d) -sout=%d +retry=%d rtt=%d ato=%d sw=%d",
                (ULONG )pTunnel->usTunnelId, (ULONG )pCs->usNs,
                pTunnel->ulSendsOut, pCs->ulRetransmits,
                pTunnel->ulRoundTripMs, pTunnel->ulSendTimeoutMs,
                pTunnel->ulSendWindow ) );

            // Retransmit the packet, or close the tunnel if retries are
            // exhausted.
            //
            if (pCs->ulRetransmits > pAdapter->ulMaxRetransmits)
            {
                // Retries are exhausted.  Give up and close the tunnel.  No
                // point in trying to be graceful since peer is not
                // responding.
                //
                SetFlags( &pTunnel->ulFlags, TCBF_PeerNotResponding );

                RemoveEntryList( &pCs->linkSendsOut );
                InitializeListHead( &pCs->linkSendsOut );
                DereferenceControlSent( pCs );

                ScheduleTunnelWork(
                    pTunnel, NULL, CloseTunnel,
                    0, 0, 0, 0, FALSE, FALSE );
            }
            else
            {
                // Retries remaining.  Mark the packet as pending
                // retransmission, then see if the send window allows the
                // retransmit to go now.
                //
                pCs->ulFlags |= CSF_Pending;
                ScheduleTunnelWork(
                    pTunnel, NULL, SendPending,
                    0, 0, 0, 0, FALSE, FALSE );
            }
        }
        while (FALSE);
        NdisReleaseSpinLock( &pTunnel->lockT );
    }

    // Remove the reference covering the scheduled timer.
    //
    DereferenceControlSent( pCs );
}


VOID
SendHeaderComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for sends that send only a single buffer from
    // the 'ADAPTERCB.poolHeaderBuffers' pool.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_BUFFER* pNdisBuffer;

    TRACE( TL_V, TM_Send, ( "SendHeaderComp" ) );

    pAdapter = (ADAPTERCB* )pContext1;
    pVc = (VCCB* )pContext2;

    // Undo the adjustments made before the send the buffer is ready for
    // re-use.
    //
    pNdisBuffer = NdisBufferFromBuffer( pBuffer );
    NdisAdjustBufferLength( pNdisBuffer, BufferSizeFromBuffer( pBuffer ) );
    FreeBufferToPool( &pAdapter->poolHeaderBuffers, pBuffer, TRUE );

    if (pVc)
    {
        DereferenceCall( pVc );
    }
}


VOID
SendPayloadSeqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for sequenced payloads.
    //
{
    PAYLOADSENT* pPs;

    TRACE( TL_V, TM_Send, ( "SendPayloadSeqComp" ) );

    pPs = (PAYLOADSENT* )pContext1;
    pPs->pIrp = NULL;
    DereferencePayloadSent( pPs );
}


VOID
SendPayloadUnseqComplete(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer )

    // PTDIXSENDCOMPLETE handler for unsequenced payloads.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_PACKET* pPacket;
    NDIS_BUFFER* pNdisBuffer;

    TRACE( TL_V, TM_Send, ( "SendPayloadUnseqComp" ) );

    pVc = (VCCB* )pContext1;
    pPacket = (NDIS_PACKET* )pContext2;
    pAdapter = pVc->pAdapter;

    // Undo the adjustments made before the send so the owner of each
    // component resource gets back what they originally provided for clean-up
    // and recycling.
    //
    NdisUnchainBufferAtFront( pPacket, &pNdisBuffer );
    NdisAdjustBufferLength( pNdisBuffer, BufferSizeFromBuffer( pBuffer ) );
    FreeBufferToPool( &pAdapter->poolHeaderBuffers, pBuffer, TRUE );

    // Notify sending driver of the result.  Without sequencing, just trying
    // to send it is enough to claim success.
    //
    NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_SUCCESS );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp($%x)", NDIS_STATUS_SUCCESS ) );
    NdisMCoSendComplete( NDIS_STATUS_SUCCESS, pVc->NdisVcHandle, pPacket );
    TRACE( TL_N, TM_Send, ("NdisMCoSendComp done" ) );

    DereferenceCall( pVc );
}


VOID
SendPayloadTimerEvent(
    IN TIMERQITEM* pItem,
    IN VOID* pContext,
    IN TIMERQEVENT event )

    // PTIMERQEVENT handler set to expire when it's time to give up on
    // receiving an acknowledge to the sent payload packet indicated in the
    // PAYLOADSENT* 'pContext'.
    //
{
    PAYLOADSENT* pPs;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    VCCB* pVc;

    TRACE( TL_N, TM_Send,
        ( "SendPayloadTimerEvent(%s)", TimerQPszFromEvent( event ) ) );

    // Unpack context information.  The timer item is owned by the "payload
    // sent" context and freed indirectly by the de-referencing of that
    // context below.
    //
    pPs = (PAYLOADSENT* )pContext;
    pVc = pPs->pVc;
    pTunnel = pPs->pTunnel;
    pAdapter = pVc->pAdapter;

    if (event == TE_Expire)
    {
        LONG lOldSendWindow;
        LONG lSwChange;
        BOOLEAN fCallActive;
        LINKSTATUSINFO info;

        // Timer expired, meaning it's time to give up on ever receiving an
        // acknowledge to the sent packet.
        //
        NdisAcquireSpinLock( &pVc->lockV );
        do
        {
            if (pPs->linkSendsOut.Flink == &pPs->linkSendsOut)
            {
                // The context is not on the "outstanding send" list, so it
                // must have been cancelled or terminated while the expire
                // handling was being set up.  Do nothing.
                //
                TRACE( TL_I, TM_Send,
                    ( "C%d: Timeout aborted", (ULONG )pVc->usCallId ) );
                fCallActive = FALSE;
                break;
            }

            // This packet was not acknowledged.
            //
            pPs->status = NDIS_STATUS_FAILURE;

            // Remove the context from the "outstanding send" list.  The
            // corresponding dereference occurs below.
            //
            RemoveEntryList( &pPs->linkSendsOut );
            InitializeListHead( &pPs->linkSendsOut );

            // The rest has to do with call related fields so get a reference
            // now.  This is removed by the "reset" send completion.
            //
            fCallActive = ReferenceCall( pVc );
            if (fCallActive)
            {
                // Per the draft/RFC, adjustments to the send window and send
                // timeouts are necessary when a send times out.
                //
                lOldSendWindow = (LONG )pVc->ulSendWindow;
                AdjustTimeoutsAndSendWindowAtTimeout(
                    pAdapter->ulMaxSendTimeoutMs,
                    pVc->lDeviationMs,
                    &pVc->ulSendTimeoutMs,
                    &pVc->ulRoundTripMs,
                    &pVc->ulSendWindow,
                    &pVc->ulAcksSinceSendTimeout );
                lSwChange = ((LONG )pVc->ulSendWindow) - lOldSendWindow;

                TRACE( TL_I, TM_Send,
                    ( "C%d: TIMEOUT(%d) new rtt=%d ato=%d sw=%d(%+d)",
                    (ULONG )pVc->usCallId, (ULONG )pPs->usNs,
                    pVc->ulRoundTripMs, pVc->ulSendTimeoutMs,
                    pVc->ulSendWindow, lSwChange ) );

                if (lSwChange != 0)
                {
                    // The send window changed, i.e. it closed some because of
                    // the timeout.  Update the statistics accordingly.
                    //
                    ++pVc->stats.ulSendWindowChanges;

                    if (pVc->ulSendWindow > pVc->stats.ulMaxSendWindow)
                    {
                        pVc->stats.ulMaxSendWindow = pVc->ulSendWindow;
                    }
                    else if (pVc->ulSendWindow < pVc->stats.ulMinSendWindow)
                    {
                        pVc->stats.ulMinSendWindow = pVc->ulSendWindow;
                    }

                    // Need to release the lock before indicating the link
                    // status change outside our driver, so make a "safe" copy
                    // of the link status information.
                    //
                    TransferLinkStatusInfo( pVc, &info );
                }

                // Send a zero length payload with the R-bit set to reset the
                // peer's Nr to the packet after this one.  The call reference
                // will be removed when the send completes.
                //
                ScheduleTunnelWork(
                    pTunnel, pVc, SendPayloadReset,
                    (ULONG_PTR )(pPs->usNs + 1), 0, 0, 0, FALSE, FALSE );

                ++pVc->stats.ulSentResets;
                ++pVc->stats.ulSentPacketsTimedOut;
            }

            // Remove the reference for linkage in the "outstanding send"
            // list.
            //
            DereferencePayloadSent( pPs );

        }
        while (FALSE);
        NdisReleaseSpinLock( &pVc->lockV );

        if (fCallActive && lSwChange != 0)
        {
            // Inform NDISWAN of the new send window since it's the component
            // that actually does the throttling.
            //
            IndicateLinkStatus( pVc, &info );
        }
    }

    // Remove the reference covering the scheduled timer event.
    //
    DereferencePayloadSent( pPs );
}


VOID
SendZlb(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usNs,
    IN USHORT usNr,
    IN BOOLEAN fReset )

    // Send a data-less packet with sequence 'usNs' and 'usNr' on 'pTunnel'.
    // 'PVc' is the associated VC, or NULL if none.  When 'pVc' is provided,
    // 'fReset' may be set to indicate a payload reset is to be built,
    // otherwise a simple acknowledge is built.
    //
    // This routine is called only at PASSIVE IRQL.
    //
    // IMPORTANT: Caller must take a call reference before calling that is
    //            removed by the send completion handler.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    CHAR* pBuffer;
    ULONG ulLength;
    USHORT usAssignedCallId;
    BOOLEAN fControl;
    NDIS_BUFFER* pNdisBuffer;

    pAdapter = pTunnel->pAdapter;

    usAssignedCallId = (pVc) ? pVc->usAssignedCallId : 0;
    fControl = (usAssignedCallId == 0);
    ASSERT( !(fReset && fControl) );

    if (!fControl && !(ReadFlags( &pTunnel->ulFlags ) & TCBF_HostRouteAdded))
    {
        TRACE( TL_A, TM_Send, ( "SendZlb w/o host route?" ) );
        ++g_ulSendZlbWithoutHostRoute;
        if (pVc)
        {
            DereferenceCall( pVc );
        }
        return;
    }

    // Get an NDIS_BUFFER to hold the L2TP header.
    //
    pBuffer = GetBufferFromPool( &pAdapter->poolHeaderBuffers );
    if (!pBuffer)
    {
        ASSERT( "GetBfP?" );
        if (pVc)
        {
            DereferenceCall( pVc );
        }
        return;
    }

    // Fill in 'pBuffer' with the L2TP header.
    //
    ulLength =
        BuildL2tpHeader(
            pBuffer,
            fControl,
            fReset,
            &pTunnel->usAssignedTunnelId,
            &usAssignedCallId,
            &usNs,
            usNr );

    // Pare down the buffer to the actual length used.
    //
    pNdisBuffer = NdisBufferFromBuffer( pBuffer );
    NdisAdjustBufferLength( pNdisBuffer, (UINT )ulLength );

    // Call TDI to send the bare L2TP header.
    //
    TRACE( TL_A, TM_Msg,
        ( "%sSEND ZLB(Nr=%d) CID=%d R=%d",
        (g_ulTraceLevel <= TL_I) ? "" : "\nL2TP: ",
        (ULONG )usNr, (ULONG )usAssignedCallId, (ULONG )fReset ) );
    DUMPW( TL_A, TM_MDmp, pBuffer, ulLength );

    {
        PTDIX_SEND_HANDLER SendFunc;
        FILE_OBJECT* FileObj;

        if (ReadFlags(&pTunnel->ulFlags) & TCBF_SendConnected) {

            ASSERT(pTunnel->pRoute != NULL);

            SendFunc = TdixSend;

            if (fControl)
            {
                FileObj = 
                    CtrlObjFromUdpContext(&pTunnel->udpContext);
            }
            else
            {
                FileObj = 
                    PayloadObjFromUdpContext(&pTunnel->udpContext);
            }

        } else {
            FileObj = NULL;
            SendFunc = TdixSendDatagram;
        }

        status = 
            SendFunc(
                &pAdapter->tdix,
                FileObj,
                SendHeaderComplete,
                pAdapter,
                pVc,
                &pTunnel->address.ulIpAddress,
                pBuffer,
                ulLength,
                NULL );
    }

    ASSERT( status == NDIS_STATUS_PENDING );
}


VOID
UpdateControlHeaderNr(
    IN CHAR* pBuffer,
    IN USHORT usNr )

    // Updates the 'Next Receive' field of control message buffer 'pBuffer'
    // with the value 'usNr'.
    //
{
    USHORT* pusNr;

    // Fortunately, the control header up to 'Next Receive' is fixed so a
    // simple offset calculation can be used.
    //
    pusNr = ((USHORT* )pBuffer) + 5;
    *pusNr = htons( usNr );
}


VOID
UpdateHeaderLength(
    IN CHAR* pBuffer,
    IN USHORT usLength )

    // Updates the 'Length' field of the L2TP message buffer 'pBuffer' to the
    // value 'usLength'.
    //
{
    USHORT* pusLength;

    // Fortunately, the control header up to 'Length' is fixed so a simple
    // offset calculation can be used.
    //
    pusLength = ((USHORT* )pBuffer) + 1;
    *pusLength = htons( usLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved


// The orginal 'includes' are 0ed out here and replaced with the component
// precompiled header because it doesn't build otherwise.  Apparently, a file
// cannot explicitly include nt.h if it is included in the module's
// precompiled header, even if that file doesn't include the precompiled
// header, but I don't fully understand why this is so.
//

#if 0
#include <nt.h>
#define UINT4   ULONG
#include <md5.h>
#endif

#include <l2tpp.h>
#define UINT4   ULONG


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\tdix.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// tdix.c
// RAS L2TP WAN mini-port/call-manager driver
// TDI extensions interface
//
// 01/07/97 Steve Cobb
//
// These routines encapsulate L2TP's usage of TDI, with the intent of
// minimalizing the change required to support other TDI transports in the
// future, e.g. Frame Relay.
//
//
// About ALLOCATEIRPS:
//
// This driver is lower level code than typical TDI client drivers.  It has
// locked MDL-mapped input buffers readily available and does not need to
// provide any mapping to user mode client requests on completion.  This
// allows a performance gain from allocating and deallocating IRPs directly,
// thus avoiding unnecessary setup in TdiBuildInternalDeviceControlIrp and
// unnecessary APC queuing in IoCompleteRequest.  Define ALLOCATEIRPs 1 (in
// sources file) to make this optimization, or define it 0 to use the strictly
// TDI-compliant TdiBuildInternalDeviceControlIrp method.
//
//
// About NDISBUFFERISMDL:
//
// Calls to TdiBuildSendDatagram assume the NDIS_BUFFER can be passed in place
// of an MDL which avoids a pointless copy.  If this is not the case, an
// explicit MDL buffer would need to be allocated and caller's buffer copied
// to the MDL buffer before sending.  Same issue for TdiBuildReceiveDatagram,
// except of course that the copy would be from the MDL buffer to caller's
// buffer after receiving.
//
//
// About ROUTEWITHREF:
//
// Calls the IP_SET_ROUTEWITHREF IOCTLs rather than the TCP_SET_INFORMATION_EX
// IOCTLs to set up the host route.  The referenced route IOCTLs prevent PPTP
// and L2TP from walking on each others routes.  This setting provided only as
// a hedge against failure of the ROUTEWITHREF IOCTL.  Assuming it works it
// should always be preferable.
//

#include "l2tpp.h"

#define IP_PKTINFO          19 // receive packet information

typedef struct in_pktinfo {
    ULONG   ipi_addr; // destination IPv4 address
    UINT    ipi_ifindex; // received interface index
} IN_PKTINFO;


// Debug count of errors that should not be happening.
//
ULONG g_ulTdixOpenFailures = 0;
ULONG g_ulTdixSendDatagramFailures = 0;
ULONG g_ulTdixAddHostRouteFailures = 0;
ULONG g_ulTdixDeleteHostRouteFailures = 0;
ULONG g_ulTdixOpenCtrlAddrFailures = 0;
ULONG g_ulTdixOpenPayloadAddrFailures = 0;
ULONG g_ulTdixSetInterfaceFailures = 0;
ULONG g_ulTdixConnectAddrFailures = 0;
ULONG g_ulTdixAddHostRouteSuccesses = 0;
ULONG g_ulTdixDeleteHostRouteSuccesses = 0;
ULONG g_ulTdixOpenCtrlAddrSuccesses = 0;
ULONG g_ulTdixOpenPayloadAddrSuccesses = 0;
ULONG g_ulTdixSetInterfaceSuccesses = 0;
ULONG g_ulTdixConnectAddrSuccesses = 0;
ULONG g_ulNoBestRoute = 0;
NTSTATUS g_statusLastAhrSetRouteFailure = 0;
NTSTATUS g_statusLastAhrTcpQueryInfoExFailure = 0;
NTSTATUS g_statusLastDhrSetRouteFailure = 0;
NTSTATUS g_statusLastDhrTcpQueryInfoExFailure = 0;


#if NDISBUFFERISMDL
#else
#error Additional code to copy NDIS_BUFFER to/from MDL NYI.
#endif


//-----------------------------------------------------------------------------
// Local datatypes
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

NTSTATUS
TdixConnectAddrInterface(
    FILE_OBJECT* pFileObj,
    HANDLE hFileHandle,
    TDIXROUTE* pTdixRoute
    );

VOID
TdixDisableUdpChecksums(
    IN FILE_OBJECT* pAddress);

VOID
TdixDoClose(
    TDIXCONTEXT* pTdix);

VOID
TdixEnableIpPktInfo(
    IN FILE_OBJECT* pAddress);

VOID
TdixExtractAddress(
    IN TDIXCONTEXT* pTdix,
    OUT TDIXRDGINFO* pRdg,
    IN VOID* pTransportAddress,
    IN LONG lTransportAddressLen,
    IN VOID* Options,
    IN LONG OptionsLength);

NTSTATUS
TdixInstallEventHandler(
    IN FILE_OBJECT* pAddress,
    IN INT nEventType,
    IN VOID* pfuncEventHandler,
    IN VOID* pEventContext );

NTSTATUS
TdixOpenIpAddress(
    IN UNICODE_STRING* puniDevice,
    IN TDIXIPADDRESS* pTdixAddr,
    OUT HANDLE* phAddress,
    OUT FILE_OBJECT** ppFileObject );

NTSTATUS
TdixReceiveDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

NTSTATUS
TdixReceiveDatagramHandler(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG* BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP* IoRequestPacket );

TDIXROUTE*
TdixRouteFromIpAddress(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress);

NTSTATUS
TdixSendComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

NTSTATUS
TdixSendDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
TdixInitialize(
    IN TDIXMEDIATYPE mediatype,
    IN HOSTROUTEEXISTS hre,
    IN ULONG ulFlags,
    IN PTDIXRECEIVE pReceiveHandler,
    IN BUFFERPOOL* pPoolNdisBuffers,
    IN OUT TDIXCONTEXT* pTdix )

    // Initialize caller's 'pTdix' buffer for future sessions using media type
    // 'mediatype', the 'hre' existing host route strategy, and TDIXF_*
    // options 'ulFlags'.  Caller's receive datagram callback
    // 'pReceiveHandler' is called with a buffer allocated from caller's
    // buffer pool 'pPoolNdisBuffers'.
    //
{
    TRACE( TL_N, TM_Tdi, ( "TdixInit" ) );

    pTdix->lRef = 0;
    pTdix->hAddress = NULL;
    pTdix->pAddress = NULL;
    pTdix->mediatype = mediatype;
    pTdix->hre = hre;
    pTdix->ulFlags |= ulFlags;
    pTdix->ulFlags = 0;
    InitializeListHead( &pTdix->listRoutes );
    NdisAllocateSpinLock( &pTdix->lock );
    pTdix->pPoolNdisBuffers = pPoolNdisBuffers;
    pTdix->pReceiveHandler = pReceiveHandler;

    // The 'llistRdg' and 'llistSdg' lookaside lists are initialized at
    // TdixOpen.
}


NDIS_STATUS
TdixOpen(
    OUT TDIXCONTEXT* pTdix )

    // Open the TDI transport address matching the selected media and register
    // to receive datagrams at the selected handler.  'PTdix' is the
    // previously intialized context.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or NDIS_STATUS_FAILURE.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    FILE_FULL_EA_INFORMATION* pEa;
    ULONG ulEaLength;
    TA_IP_ADDRESS* pTaIp;
    TDI_ADDRESS_IP* pTdiIp;
    CHAR achEa[ 100 ];
    UNICODE_STRING uniDevice;
    UNICODE_STRING uniProtocolNumber;
    WCHAR achRawIpDevice[ sizeof(DD_RAW_IP_DEVICE_NAME) + 10 ];
    WCHAR achProtocolNumber[ 10 ];
    SHORT sPort;
    LONG lRef;

    // Open the TDI extensions or notice that it's already been requested
    // and/or completed.
    //
    for (;;)
    {
        BOOLEAN fPending;
        BOOLEAN fDoOpen;

        fPending = FALSE;
        fDoOpen = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (ReadFlags( &pTdix->ulFlags) & TDIXF_Pending)
            {
                fPending = TRUE;
            }
            else
            {
                lRef = ++pTdix->lRef;
                TRACE( TL_N, TM_Tdi, ( "TdixOpen, refs=%d", lRef ) );
                if (lRef == 1)
                {
                    SetFlags( &pTdix->ulFlags, TDIXF_Pending );
                    fDoOpen = TRUE;
                }
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoOpen)
        {
            // Go on and open the transport address.
            //
            break;
        }

        if (!fPending)
        {
            // It's already open, so report success.
            //
            return NDIS_STATUS_SUCCESS;
        }

        // An operation is already in progress.  Give it some time to finish
        // then check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(open)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(open) done" ) );
    }

    do
    {
        // Set up parameters needed to open the transport address.  First, the
        // object attributes.
        //
        if (pTdix->mediatype == TMT_Udp)
        {
            TDIXIPADDRESS TdixIpAddress;

            TRACE( TL_V, TM_Tdi, ( "UDP" ) );

            // Build the UDP device name as a counted string.
            //
            uniDevice.Buffer = DD_UDP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));
            TdixIpAddress.sUdpPort = (SHORT)( htons( L2TP_UdpPort ));

            status = TdixOpenIpAddress(
                &uniDevice,
                &TdixIpAddress,
                &pTdix->hAddress,
                &pTdix->pAddress );

            if (status != STATUS_SUCCESS)
            {
                break;
            }

            TdixEnableIpPktInfo(pTdix->pAddress);
        }
        else
        {
            TDIXIPADDRESS TdixIpAddress;

            ASSERT( pTdix->mediatype == TMT_RawIp );
            TRACE( TL_A, TM_Tdi, ( "Raw IP" ) );

            // Build the raw IP device name as a counted string.  The device
            // name is followed by a path separator then the protocol number
            // of interest.
            //
            uniDevice.Buffer = achRawIpDevice;
            uniDevice.Length = 0;
            uniDevice.MaximumLength = sizeof(achRawIpDevice);
            RtlAppendUnicodeToString( &uniDevice, DD_RAW_IP_DEVICE_NAME );

            uniDevice.Buffer[ uniDevice.Length / sizeof(WCHAR) ]
                = OBJ_NAME_PATH_SEPARATOR;
            uniDevice.Length += sizeof(WCHAR);

            uniProtocolNumber.Buffer = achProtocolNumber;
            uniProtocolNumber.MaximumLength = sizeof(achProtocolNumber);
            RtlIntegerToUnicodeString(
                (ULONG )L2TP_IpProtocol, 10, &uniProtocolNumber );

            RtlAppendUnicodeStringToString( &uniDevice, &uniProtocolNumber );

            ASSERT( uniDevice.Length < sizeof(achRawIpDevice) );

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));

            status = TdixOpenIpAddress(
                &uniDevice,
                &TdixIpAddress,
                &pTdix->hAddress,
                &pTdix->pAddress );

            if (status != STATUS_SUCCESS)
            {
                break;
            }
        }

        // Initialize the lookaside lists of read/send-datagram contexts.
        //
        NdisInitializeNPagedLookasideList(
            &pTdix->llistRdg,
            NULL,
            NULL,
            0,
            sizeof(TDIXRDGINFO),
            MTAG_TDIXRDG,
            10 );

        NdisInitializeNPagedLookasideList(
            &pTdix->llistSdg,
            NULL,
            NULL,
            0,
            sizeof(TDIXSDGINFO),
            MTAG_TDIXSDG,
            10 );

        // Install our receive datagram handler.  Caller's 'pReceiveHandler' will
        // be called by our handler when a datagram arrives and TDI business is
        // out of the way.
        //
        status =
            TdixInstallEventHandler(
                pTdix->pAddress,
                TDI_EVENT_RECEIVE_DATAGRAM,
                TdixReceiveDatagramHandler,
                pTdix );

#if ROUTEWITHREF
        {
            TDIXIPADDRESS TdixIpAddress;

            // Open the IP stack address which is needed in both UDP and raw IP
            // mode for referenced route management.
            //

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));

            uniDevice.Buffer = DD_IP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_IP_DEVICE_NAME) - sizeof(WCHAR);

            status = TdixOpenIpAddress(
                &uniDevice,
                &TdixIpAddress,
                &pTdix->hIpStackAddress,
                &pTdix->pIpStackAddress );

            if (status != STATUS_SUCCESS)
            {
                break;
            }
        }
#endif
    }
    while (FALSE);

    // Report results after marking the operation complete.
    //
    {
        BOOLEAN fDoClose;

        fDoClose = FALSE;
        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (status == STATUS_SUCCESS)
            {
                ClearFlags( &pTdix->ulFlags, TDIXF_Pending );
            }
            else
            {
                ++g_ulTdixOpenFailures;
                ASSERT( pTdix->lRef == 1)
                pTdix->lRef = 0;
                fDoClose = TRUE;
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (status != STATUS_SUCCESS)
        {
            TdixDoClose( pTdix );
        }
    }

    TRACE( TL_N, TM_Tdi, ( "TdixOpen=$%08x", status ) );
    return
        (status == STATUS_SUCCESS)
            ? NDIS_STATUS_SUCCESS
            : NDIS_STATUS_FAILURE;
}


VOID
TdixReference(
    IN TDIXCONTEXT* pTdix )

    // Increments the TDI extension reference count, like TdixOpen, except
    // this routine may be called at DISPATCH IRQL.
    //
    // This call must only be made if it is known that the TDI context is
    // already fully open.
    //
{
    NdisAcquireSpinLock( &pTdix->lock );
    {
        ASSERT( pTdix->lRef > 0 );
        ++pTdix->lRef;
    }
    NdisReleaseSpinLock( &pTdix->lock );
}


VOID
TdixClose(
    IN TDIXCONTEXT* pTdix )

    // Undo TdixOpen actions for transport context 'pTdix'.
    //
    // This call must be made at PASSIVE IRQL.
    //
{
    for (;;)
    {
        LONG lRef;
        BOOLEAN fPending;
        BOOLEAN fDoClose;

        fPending = FALSE;
        fDoClose = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (ReadFlags( &pTdix->ulFlags ) & TDIXF_Pending)
            {
                fPending = TRUE;
            }
            else
            {
                lRef = --pTdix->lRef;
                ASSERT( lRef >= 0 );
                TRACE( TL_N, TM_Tdi, ( "TdixClose, refs=%d", lRef ) );
                if (lRef == 0)
                {
                    SetFlags( &pTdix->ulFlags, TDIXF_Pending );
                    fDoClose = TRUE;
                }
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoClose)
        {
            // Go on and close the transport address.
            //
            break;
        }

        if (!fPending)
        {
            // It's still got references, so just return;
            //
            return;
        }

        // An operation is already in progress.  Give it some time to finish
        // then check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(close)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(close) done" ) );
    }

    ASSERT( IsListEmpty( &pTdix->listRoutes ) );
    TdixDoClose( pTdix );
}

NDIS_STATUS
TdixSend(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* pFileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp ) 
    // Send a datagram buffer 'pBuffer', 'ulBufferLength' bytes long, to
    // remote address 'pAddress'.  The buffer must be from a BUFFERPOOL of
    // NDIS_BUFFERs.  'PTdix' is the transport context.
    // 'PSendDatagramCompleteHander' is caller's completion handler which is
    // passed 'pContext1' and 'pContext2'.  If 'ppIrp' is non-NULL '*ppIrp' is
    // set to the address of the posted IRP, this for debugging purposes.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or NDIS_STATUS_FAILURE.
    //
{
    NDIS_STATUS status;
    NTSTATUS iostatus;
    TDIXSDGINFO* pSdg;
    SHORT sPort;
    PIRP pIrp;
    TDI_ADDRESS_IP* pTdiIp;
    DEVICE_OBJECT* DeviceObj;

    TRACE( TL_N, TM_Tdi, ( "TdixSend(dst=%d.%d.%d.%d/%d,len=%d)",
        IPADDRTRACE( ((TDIXIPADDRESS* )pAddress)->ulIpAddress ),
        (ULONG )(ntohs( ((TDIXIPADDRESS* )pAddress)->sUdpPort )),
        ulBufferLength ) );

    ASSERT(pFileObj != NULL);

    do
    {
        // Allocate a context for this send-datagram from our lookaside list.
        //
        pSdg = ALLOC_TDIXSDGINFO( pTdix );
        if (pSdg)
        {
            // Fill in the send-datagram context.
            //
            pSdg->pTdix = pTdix;
            pSdg->pSendCompleteHandler = pSendCompleteHandler;
            pSdg->pContext1 = pContext1;
            pSdg->pContext2 = pContext2;
            pSdg->pBuffer = pBuffer;
        }
        else
        {
            ASSERT( !"Alloc SDG?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

#if 0
        // Put the destination IP address in the "connection" structure as TDI
        // expects.  The "connection" is part of our context as it must be
        // available to TDI until the request completes.
        //
        pSdg->taip.TAAddressCount = 1;
        pSdg->taip.Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pSdg->taip.Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

        pTdiIp = &pSdg->taip.Address[ 0 ].Address[ 0 ];

        sPort = ((TDIXIPADDRESS* )pAddress)->sUdpPort;
        if (sPort == 0 && pTdix->mediatype == TMT_Udp)
        {
            sPort = (SHORT )(htons( L2TP_UdpPort ));
        }

        pTdiIp->sin_port = sPort;
        pTdiIp->in_addr = ((TDIXIPADDRESS* )pAddress)->ulIpAddress;
        NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

        pSdg->tdiconninfo.UserDataLength = 0;
        pSdg->tdiconninfo.UserData = NULL;
        pSdg->tdiconninfo.OptionsLength = 0;
        pSdg->tdiconninfo.Options = NULL;
        pSdg->tdiconninfo.RemoteAddressLength = sizeof(pSdg->taip);
        pSdg->tdiconninfo.RemoteAddress = &pSdg->taip;
#endif

        DeviceObj = pFileObj->DeviceObject;

#if ALLOCATEIRPS
        // Allocate the IRP directly.
        //
        pIrp = IoAllocateIrp(DeviceObj->StackSize, FALSE );
#else
        // Allocate a "send datagram" IRP with base initialization.
        //
        pIrp =
            TdiBuildInternalDeviceControlIrp(
                TDI_SEND,
                DeviceObj,
                FileObj,
                NULL,
                NULL );
#endif

        if (!pIrp)
        {
            TRACE( TL_A, TM_Tdi, ( "Alloc IRP?" ) );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Complete the "send datagram" IRP initialization.
        //
        TdiBuildSend(
            pIrp,
            DeviceObj,
            pFileObj,
            TdixSendComplete,
            pSdg,
            NdisBufferFromBuffer( pBuffer ),
            0,
            ulBufferLength);

        if (ppIrp)
        {
            *ppIrp = pIrp;
        }

        // Tell the I/O manager to pass our IRP to the transport for
        // processing.
        //
        iostatus = IoCallDriver( DeviceObj, pIrp );
        ASSERT( iostatus == STATUS_PENDING );

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        // Pull a half Jameel, i.e. convert a synchronous failure to an
        // asynchronous failure from client's perspective.  However, clean up
        // context here.
        //
        ++g_ulTdixSendDatagramFailures;
        if (pSdg)
        {
            FREE_TDIXSDGINFO( pTdix, pSdg );
        }

        pSendCompleteHandler( pTdix, pContext1, pContext2, pBuffer );
    }

    return NDIS_STATUS_PENDING;
}

NDIS_STATUS
TdixSendDatagram(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* FileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp )

    // Send a datagram buffer 'pBuffer', 'ulBufferLength' bytes long, to
    // remote address 'pAddress'.  The buffer must be from a BUFFERPOOL of
    // NDIS_BUFFERs.  'PTdix' is the transport context.
    // 'PSendDatagramCompleteHander' is caller's completion handler which is
    // passed 'pContext1' and 'pContext2'.  If 'ppIrp' is non-NULL '*ppIrp' is
    // set to the address of the posted IRP, this for debugging purposes.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or NDIS_STATUS_FAILURE.
    //
{
    NDIS_STATUS status;
    NTSTATUS iostatus;
    TDIXSDGINFO* pSdg;
    SHORT sPort;
    PIRP pIrp;
    TDI_ADDRESS_IP* pTdiIp;

    TRACE( TL_N, TM_Tdi, ( "TdixSendDg(dst=%d.%d.%d.%d/%d,len=%d)",
        IPADDRTRACE( ((TDIXIPADDRESS* )pAddress)->ulIpAddress ),
        (ULONG )(ntohs( ((TDIXIPADDRESS* )pAddress)->sUdpPort )),
        ulBufferLength ) );

    // Not used in this function!
    //
    FileObj;

    do
    {
        // Allocate a context for this send-datagram from our lookaside list.
        //
        pSdg = ALLOC_TDIXSDGINFO( pTdix );
        if (pSdg)
        {
            // Fill in the send-datagram context.
            //
            pSdg->pTdix = pTdix;
            pSdg->pSendCompleteHandler = pSendCompleteHandler;
            pSdg->pContext1 = pContext1;
            pSdg->pContext2 = pContext2;
            pSdg->pBuffer = pBuffer;
        }
        else
        {
            ASSERT( !"Alloc SDG?" );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Put the destination IP address in the "connection" structure as TDI
        // expects.  The "connection" is part of our context as it must be
        // available to TDI until the request completes.
        //
        pSdg->taip.TAAddressCount = 1;
        pSdg->taip.Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
        pSdg->taip.Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

        pTdiIp = &pSdg->taip.Address[ 0 ].Address[ 0 ];

        sPort = ((TDIXIPADDRESS* )pAddress)->sUdpPort;
        if (sPort == 0 && pTdix->mediatype == TMT_Udp)
        {
            sPort = (SHORT )(htons( L2TP_UdpPort ));
        }

        pTdiIp->sin_port = sPort;
        pTdiIp->in_addr = ((TDIXIPADDRESS* )pAddress)->ulIpAddress;
        NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

        pSdg->tdiconninfo.UserDataLength = 0;
        pSdg->tdiconninfo.UserData = NULL;
        pSdg->tdiconninfo.OptionsLength = 0;
        pSdg->tdiconninfo.Options = NULL;
        pSdg->tdiconninfo.RemoteAddressLength = sizeof(pSdg->taip);
        pSdg->tdiconninfo.RemoteAddress = &pSdg->taip;

#if ALLOCATEIRPS
        // Allocate the IRP directly.
        //
        pIrp = IoAllocateIrp(
            pTdix->pAddress->DeviceObject->StackSize, FALSE );
#else
        // Allocate a "send datagram" IRP with base initialization.
        //
        pIrp =
            TdiBuildInternalDeviceControlIrp(
                TDI_SEND_DATAGRAM,
                pTdix->pAddress->DeviceObject,
                pTdix->pAddress,
                NULL,
                NULL );
#endif

        if (!pIrp)
        {
            TRACE( TL_A, TM_Tdi, ( "Alloc IRP?" ) );
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Complete the "send datagram" IRP initialization.
        //
        TdiBuildSendDatagram(
            pIrp,
            pTdix->pAddress->DeviceObject,
            pTdix->pAddress,
            TdixSendDatagramComplete,
            pSdg,
            NdisBufferFromBuffer( pBuffer ),
            ulBufferLength,
            &pSdg->tdiconninfo );

        if (ppIrp)
        {
            *ppIrp = pIrp;
        }

        // Tell the I/O manager to pass our IRP to the transport for
        // processing.
        //
        iostatus = IoCallDriver( pTdix->pAddress->DeviceObject, pIrp );
        ASSERT( iostatus == STATUS_PENDING );

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        // Pull a half Jameel, i.e. convert a synchronous failure to an
        // asynchronous failure from client's perspective.  However, clean up
        // context here.
        //
        ++g_ulTdixSendDatagramFailures;
        if (pSdg)
        {
            FREE_TDIXSDGINFO( pTdix, pSdg );
        }

        pSendCompleteHandler( pTdix, pContext1, pContext2, pBuffer );
    }

    return NDIS_STATUS_PENDING;
}

VOID
TdixDestroyConnection(
    TDIXUDPCONNECTCONTEXT *pUdpContext)
{
    if (pUdpContext->fUsePayloadAddr) {

        ASSERT(pUdpContext->hPayloadAddr != NULL);

        ObDereferenceObject( pUdpContext->pPayloadAddr );

        // Close the payload address object
        //
        ZwClose(pUdpContext->hPayloadAddr);
        pUdpContext->hPayloadAddr = NULL;
        pUdpContext->fUsePayloadAddr = FALSE;
    }

    if (pUdpContext->hCtrlAddr != NULL) {

        // Close the Ctrl address object
        //
        ObDereferenceObject( pUdpContext->pCtrlAddr );
        ZwClose (pUdpContext->hCtrlAddr);
        pUdpContext->hCtrlAddr = NULL;
    }
}


NDIS_STATUS
TdixSetupConnection(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    IN SHORT sPort,
    IN TDIXROUTE *pTdixRoute,
    IN TDIXUDPCONNECTCONTEXT* pUdpContext)
 {
    NDIS_STATUS status = STATUS_SUCCESS;
    
    ASSERT(pUdpContext != NULL);
    
    if (pTdix->mediatype == TMT_Udp) 
    {

        do {
            UNICODE_STRING uniDevice;
            UNICODE_STRING uniProtocolNumber;
            TDIXIPADDRESS TdixIpAddress;


            // Create an address object that we can send across.  If we have udp xsums
            // disabled we will need to create two address objects, one for control
            // and one for payload.  This allows payload specific features to be
            // implemented.
            //
            uniDevice.Buffer = DD_UDP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));

            if(sPort != 0)
            {
                pTdixRoute->sPort = sPort;
            }
            else
            {
                pTdixRoute->sPort = (SHORT)(htons(L2TP_UdpPort));
            }                

            TdixIpAddress.sUdpPort = (SHORT)(htons(L2TP_UdpPort));

            TRACE( TL_A, TM_Tdi, ( "sPort for $%08x set to %d", 
                        ulIpAddress, (UINT) ntohs(pTdixRoute->sPort ) ));

            // Build the UDP device name as a counted string.
            //
            status = TdixOpenIpAddress(&uniDevice, 
                                     &TdixIpAddress,
                                     &pUdpContext->hCtrlAddr, 
                                     &pUdpContext->pCtrlAddr );

            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR OpenCtrlAddr=%x?", status ) );
                break;
            }

            //
            // Associate a particular "send" IP interface index with the address
            // object, so that if that interface disappears traffic will not be
            // "re-routed" often back into the tunnel producing disastrous
            // looping.
            //
            status = TdixConnectAddrInterface(pUdpContext->pCtrlAddr,
                                           pUdpContext->hCtrlAddr,
                                           pTdixRoute);


            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR ConnectCtrlAddr=%x?", status ) );
                break;
            }

            // If udp xsums are disabled we need to create another address object.
            // We will set this object to disable udp xsums and then use it to
            // send payload data.
            //
            // If udp xsums are enabled we can use the same address object for
            // payloads that we use for contrl frames.
            //
            if (pTdix->ulFlags & TDIXF_DisableUdpXsums)
            {
                TDIXIPADDRESS TdixIpAddress;

                NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));
                TdixIpAddress.sUdpPort = (SHORT)(htons(L2TP_UdpPort));

                // Open the address object
                //
                status = TdixOpenIpAddress(&uniDevice, 
                                           &TdixIpAddress,
                                           &pUdpContext->hPayloadAddr,
                                           &pUdpContext->pPayloadAddr );

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR OpenPayloadAddr=%x?", status ) );
                    pUdpContext->hPayloadAddr = NULL;
                    break;
                }

                pUdpContext->fUsePayloadAddr = TRUE;

                TdixDisableUdpChecksums( pUdpContext->pPayloadAddr );

                // Associate a particular "send" IP interface index with the address
                // object, so that if that interface disappears traffic will not be
                // "re-routed" often back into the tunnel producing disastrous
                // looping.
                //
                status = TdixConnectAddrInterface(pUdpContext->pPayloadAddr, 
                                               pUdpContext->hPayloadAddr,
                                               pTdixRoute );

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR ConnectPayloadAddr=%x?", status ) );
                    break;
                }
            } 
            else 
            {
                pUdpContext->hPayloadAddr = pUdpContext->hCtrlAddr;
                pUdpContext->pPayloadAddr = pUdpContext->pCtrlAddr;

                TRACE( TL_I, TM_Tdi, ( "AHR Ctrl==Payload") );
            }

        } while ( FALSE );

    }

    return status;
}


VOID*
TdixAddHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    IN SHORT sPort)

    // Adds a host route for the remote peer's network byte-ordered IP address
    // 'ulIpAddress', i.e. routes packets directed to the L2TP peer to the LAN
    // card rather than back into the tunnel where it would loop infinitely.
    // 'PTdix' is the is caller's TDI extension context.
    //
    // Returns true if the route was added, false otherwise.
    //
    // Note: This routine borrows heavily from PPTP.
    //
{
    TCP_REQUEST_QUERY_INFORMATION_EX QueryBuf;
    TCP_REQUEST_SET_INFORMATION_EX* pSetBuf;
    VOID* pBuffer2;
    PIO_STACK_LOCATION pIrpSp;
    PDEVICE_OBJECT pDeviceObject;
    PDEVICE_OBJECT pIpDeviceObject;
    NTSTATUS status = STATUS_SUCCESS;
    PIRP pIrp;
    IO_STATUS_BLOCK iosb;
    IPRouteEntry* pBuffer;
    IPRouteEntry* pRouteEntry;
    IPRouteEntry* pNewRouteEntry;
    IPRouteEntry* pBestRoute;
    ULONG ulRouteCount;
    ULONG ulSize;
    ULONG i;
    ULONG ulBestMask;
    ULONG ulBestMetric;
    TDIXROUTE* pTdixRoute;
    BOOLEAN fNewRoute;
    BOOLEAN fPending;
    BOOLEAN fOpenPending;
    BOOLEAN fUsedNonL2tpRoute;
    LONG lRef;
    KEVENT  event;

    if (ulIpAddress == 0)
    {
        TRACE( TL_A, TM_Tdi, ( "IP == 0?" ) );
        return ((VOID*)NULL);
    }

    TRACE( TL_N, TM_Tdi,
        ( "TdixAddHostRoute(ip=%d.%d.%d.%d)", IPADDRTRACE( ulIpAddress ) ) );

    // Host routes are referenced since more than one tunnel to the same peer
    // (allowed by L2TP) shares the same system route.  See if this is just a
    // reference or the actual add of the system host route.
    //
    for (;;)
    {
        fPending = FALSE;
        fOpenPending = FALSE;
        pTdixRoute = NULL;
        fNewRoute = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        do
        {
            if (pTdix->lRef <= 0)
            {
                // TDIX is closed or closing, so the add route fails.
                //
                break;
            }

            if (ReadFlags( &pTdix->ulFlags ) & TDIXF_Pending)
            {
                // A TdixOpen is pending.  Wait for it to finish before
                // adding the route.
                //
                fOpenPending = TRUE;
                break;
            }

            pTdixRoute = TdixRouteFromIpAddress( pTdix, ulIpAddress );
            if (pTdixRoute)
            {
                // Found an existing route context.
                //
                fPending = pTdixRoute->fPending;
                if (!fPending)
                {
                    // No other operation is pending on the route context.
                    // Take a reference.
                    //
                    ++pTdixRoute->lRef;
                }
                break;
            }
            
            // No existing route context.  Create and link a new one.
            //
            pTdixRoute = ALLOC_TDIXROUTE( pTdix );
            if (pTdixRoute)
            {
                NdisZeroMemory(pTdixRoute, sizeof(TDIXROUTE));

                pTdixRoute->ulIpAddress = ulIpAddress;
                pTdixRoute->lRef = 1;
                pTdixRoute->fPending = TRUE;
                pTdixRoute->fUsedNonL2tpRoute = FALSE;

                InsertTailList(
                    &pTdix->listRoutes, &pTdixRoute->linkRoutes );
                lRef = ++pTdix->lRef;
                TRACE( TL_N, TM_Tdi, ( "TdixAHR, refs=%d", lRef ) );

                fPending = pTdixRoute->fPending;
                fNewRoute = TRUE;
            }
        }
        while (FALSE);
        NdisReleaseSpinLock( &pTdix->lock );

        if (!fOpenPending)
        {
            if (!pTdixRoute)
            {
                // TDIX is closed or we couldn't find an existing route
                // context or create a new one.  Report failure.
                //
                return ((VOID*)NULL);
            }

            if (fNewRoute)
            {
                // Created a new route context so go on to make the IOCTL
                // calls to add the associated system host route.
                //
                break;
            }

            if (!fPending)
            {
                // Took a reference on an existing route context.  Report
                // success.
                //
                return (pTdixRoute);
            }
        }

        // An operation is already pending.  Give it some time to finish then
        // check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(add)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(add) done" ) );
    }

    // Do the IOCTLs to add the host route.
    //
    pBuffer = NULL;
    pBuffer2 = NULL;
    fUsedNonL2tpRoute = FALSE;

    do
    {

        // Get the routing table from the IP stack.  This make take a few
        // iterations since the size of the buffer required is not known.  Set
        // up the static request information first.
        //
        QueryBuf.ID.toi_entity.tei_entity = CL_NL_ENTITY;
        QueryBuf.ID.toi_entity.tei_instance = 0;
        QueryBuf.ID.toi_class = INFO_CLASS_PROTOCOL;
        QueryBuf.ID.toi_type = INFO_TYPE_PROVIDER;
        pDeviceObject = IoGetRelatedDeviceObject( pTdix->pAddress );

        status = !STATUS_SUCCESS;
        ulRouteCount = 20;
        for (;;)
        {
            // Allocate a buffer big enough for 'ulRouteCount' routes.
            //
            ulSize = sizeof(IPRouteEntry) * ulRouteCount;
            QueryBuf.ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            NdisZeroMemory( &QueryBuf.Context, CONTEXT_SIZE );

            pBuffer = (IPRouteEntry* )ALLOC_NONPAGED( ulSize, MTAG_ROUTEQUERY );
            if (!pBuffer)
            {
                TRACE( TL_A, TM_Tdi, ( "Alloc RQ?" ) );
                break;
            }

            // Set up a request to the IP stack to fill the buffer with the
            // routing table and send it to the stack.
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_TCP_QUERY_INFORMATION_EX,
                    pDeviceObject,
                    (PVOID )&QueryBuf,
                    sizeof(QueryBuf),
                    pBuffer,
                    ulSize,
                    FALSE,
                    &event,
                    &iosb);

            if (!pIrp)
            {
                TRACE( TL_A, TM_Tdi, ( "Build Q Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pAddress;

            status = IoCallDriver( pDeviceObject, pIrp );

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                status = iosb.Status;
            }

            if (status != STATUS_BUFFER_OVERFLOW)
            {
                if (status != STATUS_SUCCESS)
                {
                    g_statusLastAhrTcpQueryInfoExFailure = status;
                }
                break;
            }

            // The buffer didn't hold the routing table.  Undo in preparation
            // for another try with twice as big a buffer.
            //
            ulRouteCount <<= 1;
            FREE_NONPAGED( pBuffer );
        }

        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Tdi, ( "AHR Q_INFO_EX=%d?", status ) );
            break;
        }

        status = !STATUS_SUCCESS;

        // Calculate how many routes were loaded into our buffer.
        //
        ulRouteCount = (ULONG )(iosb.Information / sizeof(IPRouteEntry));

        // Walk the route table looking for the "best route" that will be used
        // to route packets to the peer, i.e. the one with the highest
        // priority metric, and within that, the highest class address mask.
        //
        pBestRoute = NULL;
        ulBestMask = 0;
        ulBestMetric = (ULONG )-1;

        for (i = 0, pRouteEntry = pBuffer;
             i < ulRouteCount;
             ++i, ++pRouteEntry)
        {
            if (pRouteEntry->ire_dest == (ulIpAddress & pRouteEntry->ire_mask))
            {
                // Found a route that applies to peer's IP address.
                //
                if (!pBestRoute
                    || (ulBestMask == pRouteEntry->ire_mask)
                       && (pRouteEntry->ire_metric1 < ulBestMetric))
                {
                    // The route has a lower (higher priority) metric than
                    // anything found so far.
                    //
                    pBestRoute = pRouteEntry;
                    ulBestMask = pRouteEntry->ire_mask;
                    ulBestMetric = pRouteEntry->ire_metric1;
                    continue;
                }

                if (ntohl( pRouteEntry->ire_mask ) > ntohl( ulBestMask ))
                {
                    // The route has a higher address class mask than anything
                    // found so far.
                    //
                    pBestRoute = pRouteEntry;
                    ulBestMask = pRouteEntry->ire_mask;
                    ulBestMetric = pRouteEntry->ire_metric1;
                }
            }
        }

        if (pBestRoute)
        {
            // Found the route that will be used to route peer's address.
            //
            if (pBestRoute->ire_dest == ulIpAddress
                && pBestRoute->ire_mask == 0xFFFFFFFF)
            {
                // The host route already exists.
                //
                if (pTdix->hre == HRE_Use)
                {
                    TRACE( TL_I, TM_Tdi, ( "Route exists (use as is)" ) );
                    status = STATUS_SUCCESS;
                    fUsedNonL2tpRoute = TRUE;
                    break;
                }
                else if (pTdix->hre == HRE_Fail)
                {
                    TRACE( TL_I, TM_Tdi, ( "Route exists (fail)" ) );
                    break;
                }

                // If we reach here then we are in HRE_Reference mode, so drop
                // thru and re-add the route so it's reference in the IP stack
                // will be incremented.
            }

            pTdixRoute->InterfaceIndex = pBestRoute->ire_index;

#if ROUTEWITHREF
            // Allocate a buffer to hold our request to add a new route.
            //
            ulSize = sizeof(IPRouteEntry);
            pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
            if (!pBuffer2)
            {
                TRACE( TL_A, TM_Tdi, ( "Alloc SI?" ) );
                break;
            }

            // Fill in the request buffer with the information about the new
            // specific route.  The best route is used as a template.
            //
            pNewRouteEntry = (IPRouteEntry* )pBuffer2;
            NdisMoveMemory( pNewRouteEntry, pBestRoute, sizeof(IPRouteEntry) );

            pNewRouteEntry->ire_dest = ulIpAddress;
            pNewRouteEntry->ire_mask = 0xFFFFFFFF;

            // Check DIRECT/INDIRECT only if this is not a host route
            if(pBestRoute->ire_mask != 0xFFFFFFFF)
            {
                if ((pBestRoute->ire_nexthop & pBestRoute->ire_mask)
                     == (ulIpAddress & pBestRoute->ire_mask))
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_DIRECT;
                }
                else
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_INDIRECT;
                }
            }
            pNewRouteEntry->ire_proto = IRE_PROTO_NETMGMT;

            pIpDeviceObject =
                IoGetRelatedDeviceObject( pTdix->pIpStackAddress );

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_IP_SET_ROUTEWITHREF,
                    pIpDeviceObject,
                    pNewRouteEntry,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);
            if (!pIrp)
            {
                TRACE( TL_A, TM_Tdi, ( "Build S Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pIpStackAddress;

            // Send the request to the IP stack.
            //
            status = IoCallDriver( pIpDeviceObject, pIrp );
#else
            // Allocate a buffer to hold our request to add a new route.
            //
            ulSize =
                sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry);
            pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
            if (!pBuffer2)
            {
                TRACE( TL_A, TM_Tdi, ( "Alloc SI?" ) );
                break;
            }

            // Fill in the request buffer with the information about the new
            // specific route.  The best route is used as a template.
            //
            pSetBuf = (TCP_REQUEST_SET_INFORMATION_EX* )pBuffer2;
            NdisZeroMemory( pSetBuf, ulSize );

            pSetBuf->ID.toi_entity.tei_entity = CL_NL_ENTITY;
            pSetBuf->ID.toi_entity.tei_instance = 0;
            pSetBuf->ID.toi_class = INFO_CLASS_PROTOCOL;
            pSetBuf->ID.toi_type = INFO_TYPE_PROVIDER;
            pSetBuf->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            pSetBuf->BufferSize = sizeof(IPRouteEntry);

            pNewRouteEntry = (IPRouteEntry* )&pSetBuf->Buffer[ 0 ];
            NdisMoveMemory( pNewRouteEntry, pBestRoute, sizeof(IPRouteEntry) );

            pNewRouteEntry->ire_dest = ulIpAddress;
            pNewRouteEntry->ire_mask = 0xFFFFFFFF;

            // Check DIRECT/INDIRECT only if this is not a host route
            if(pBestRoute->ire_mask != 0xFFFFFFFF)
            {
                if ((pBestRoute->ire_nexthop & pBestRoute->ire_mask)
                     == (ulIpAddress & pBestRoute->ire_mask))
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_DIRECT;
                }
                else
                {
                    pNewRouteEntry->ire_type = IRE_TYPE_INDIRECT;
                }
            }
            pNewRouteEntry->ire_proto = IRE_PROTO_NETMGMT;

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp =
                IoBuildDeviceIoControlRequest(
                    IOCTL_TCP_SET_INFORMATION_EX,
                    pDeviceObject,
                    pSetBuf,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);

            if (!pIrp)
            {
                TRACE( TL_A, TM_Tdi, ( "Build S Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pAddress;

            // Send the request to the IP stack.
            //
            status = IoCallDriver( pDeviceObject, pIrp );
#endif
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                status = iosb.Status;
            }

            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR SET_ROUTE=$%08x?", status ) );
                g_statusLastAhrSetRouteFailure = status;
                break;
            }

            TRACE( TL_N, TM_Tdi,
                ( "Add host route %d.%d.%d.%d type %d nexthop %d.%d.%d.%d index %d",
                IPADDRTRACE( pNewRouteEntry->ire_dest ),
                pNewRouteEntry->ire_type,
                IPADDRTRACE( pNewRouteEntry->ire_nexthop ),
                pNewRouteEntry->ire_index ) );
        }
        else
        {
            ++g_ulNoBestRoute;
            TRACE( TL_A, TM_Tdi, ( "No best route for $%08x?", ulIpAddress ) );
            break;
        }
    }
    while (FALSE);

    if (pBuffer)
    {
        FREE_NONPAGED( pBuffer );
    }

    if (pBuffer2)
    {
        FREE_NONPAGED( pBuffer2 );
    }

    // Update the route context.
    //
    {
        BOOLEAN fDoClose;
        LONG lRef;

        fDoClose = FALSE;
        NdisAcquireSpinLock( &pTdix->lock );
        {
            pTdixRoute->fUsedNonL2tpRoute = fUsedNonL2tpRoute;

            if (status == STATUS_SUCCESS)
            {
                ++g_ulTdixAddHostRouteSuccesses;
                pTdixRoute->fPending = FALSE;
            }
            else
            {
                ++g_ulTdixAddHostRouteFailures;
                RemoveEntryList( &pTdixRoute->linkRoutes );
                lRef = --pTdix->lRef;
                TRACE( TL_A, TM_Tdi, ( "TdixAHR fail, refs=%d", lRef ) );
                if (lRef <= 0)
                {
                    fDoClose = TRUE;
                }
                FREE_TDIXROUTE( pTdxi, pTdixRoute );
                pTdixRoute = NULL;
            }
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoClose)
        {
            TdixDoClose( pTdix );
        }
    }

#if 0
    if ((status == STATUS_SUCCESS) &&
        (pTdix->mediatype == TMT_Udp)) {

        do {
            UNICODE_STRING uniDevice;
            UNICODE_STRING uniProtocolNumber;
            TDIXIPADDRESS TdixIpAddress;


            // Create an address object that we can send across.  If we have udp xsums
            // disabled we will need to create two address objects, one for control
            // and one for payload.  This allows payload specific features to be
            // implemented.
            //
            uniDevice.Buffer = DD_UDP_DEVICE_NAME;
            uniDevice.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);

            NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));

            if(sPort != 0)
            {
                pTdixRoute->sPort = sPort;
            }
            else
            {
                pTdixRoute->sPort = (SHORT)(htons(L2TP_UdpPort));
            }                

            TdixIpAddress.sUdpPort = (SHORT)(htons(L2TP_UdpPort));

            TRACE( TL_A, TM_Tdi, ( "sPort for $%08x set to %d", 
                        ulIpAddress, (UINT) ntohs(pTdixRoute->sPort ) ));

            // Build the UDP device name as a counted string.
            //
            status = TdixOpenIpAddress(&uniDevice, 
                                       &TdixIpAddress,
                                       &pTdixRoute->hCtrlAddr, 
                                       &pTdixRoute->pCtrlAddr );

            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR OpenCtrlAddr=%x?", status ) );
                break;
            }

            //
            // Associate a particular "send" IP interface index with the address
            // object, so that if that interface disappears traffic will not be
            // "re-routed" often back into the tunnel producing disastrous
            // looping.
            //
            status = TdixConnectAddrInterface(pTdixRoute->pCtrlAddr,
                                              pTdixRoute->hCtrlAddr,
                                              pTdixRoute);


            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Tdi, ( "AHR ConnectCtrlAddr=%x?", status ) );
                break;
            }

            // If udp xsums are disabled we need to create another address object.
            // We will set this object to disable udp xsums and then use it to
            // send payload data.
            //
            // If udp xsums are enabled we can use the same address object for
            // payloads that we use for contrl frames.
            //
            if (pTdix->ulFlags & TDIXF_DisableUdpXsums)
            {
                TDIXIPADDRESS TdixIpAddress;

                NdisZeroMemory(&TdixIpAddress, sizeof(TdixIpAddress));
                TdixIpAddress.sUdpPort = (SHORT)(htons(L2TP_UdpPort));

                // Open the address object
                //
                status = TdixOpenIpAddress(&uniDevice, 
                                           &TdixIpAddress,
                                           &pTdixRoute->hPayloadAddr,
                                           &pTdixRoute->pPayloadAddr );

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR OpenPayloadAddr=%x?", status ) );
                    pTdixRoute->hPayloadAddr = NULL;
                    break;
                }

                pTdixRoute->fUsePayloadAddr = TRUE;

                TdixDisableUdpChecksums( pTdixRoute->pPayloadAddr );

                // Associate a particular "send" IP interface index with the address
                // object, so that if that interface disappears traffic will not be
                // "re-routed" often back into the tunnel producing disastrous
                // looping.
                //
                status = TdixConnectAddrInterface(pTdixRoute->pPayloadAddr, 
                                                  pTdixRoute->hPayloadAddr,
                                                  pTdixRoute );

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "AHR ConnectPayloadAddr=%x?", status ) );
                    break;
                }
            } 
            else 
            {
                pTdixRoute->hPayloadAddr = pTdixRoute->hCtrlAddr;
                pTdixRoute->pPayloadAddr = pTdixRoute->pCtrlAddr;

                TRACE( TL_I, TM_Tdi, ( "AHR Ctrl==Payload") );
            }

        } while ( FALSE );

        if (status != STATUS_SUCCESS) {

            TdixDeleteHostRoute(pTdix, ulIpAddress);

            pTdixRoute = NULL;
        }
    }

#endif    

    return (pTdixRoute);
}


VOID
TdixDeleteHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress)

    // Deletes the host route added for network byte-ordered IP address
    // 'ulIpAddress'.  'PTdix' is caller's TDI extension context.
    //
    // Note: This routine borrows heavily from PPTP.
    //
{
    TCP_REQUEST_QUERY_INFORMATION_EX QueryBuf;
    TCP_REQUEST_SET_INFORMATION_EX *pSetBuf;
    VOID* pBuffer2;
    PIO_STACK_LOCATION pIrpSp;
    PDEVICE_OBJECT pDeviceObject;
    PDEVICE_OBJECT pIpDeviceObject;
    UCHAR context[ CONTEXT_SIZE ];
    NTSTATUS status;
    PIRP pIrp;
    IO_STATUS_BLOCK iosb;
    IPRouteEntry* pBuffer;
    IPRouteEntry* pRouteEntry;
    IPRouteEntry* pNewRouteEntry;
    ULONG ulRouteCount;
    ULONG ulSize;
    ULONG i;
    TDIXROUTE* pTdixRoute;
    BOOLEAN fPending;
    BOOLEAN fDoDelete;
    KEVENT  event;

    TRACE( TL_N, TM_Tdi, ( "TdixDeleteHostRoute(%d.%d.%d.%d)",
        IPADDRTRACE( ulIpAddress ) ) );

    if (!ulIpAddress)
    {
        TRACE( TL_A, TM_Tdi, ( "!IP?" ) );
        return;
    }

    // Host routes are referenced since more than one tunnel to the same peer
    // (allowed by L2TP) shares the same system route.  First, see if this is
    // just a dereference or the final deletion of the system host route.
    //
    for (;;)
    {
        fDoDelete = FALSE;
        fPending = FALSE;

        NdisAcquireSpinLock( &pTdix->lock );
        do
        {
            // These asserts hold because we never delete routes we didn't
            // add, and since the route we added holds a TDIX reference, TDIX
            // cannot be opening or closing.
            //
            ASSERT( pTdix->lRef > 0 );
            ASSERT( !(ReadFlags( &pTdix->ulFlags) & TDIXF_Pending) );

            pTdixRoute = TdixRouteFromIpAddress( pTdix, ulIpAddress );
            if (pTdixRoute)
            {
                // Route exists. Remove a reference.
                //
                fPending = pTdixRoute->fPending;
                if (!fPending)
                {
                    if (--pTdixRoute->lRef <= 0)
                    {
                        // Last "add" reference has been removed so call the
                        // IOCTLs to delete the system route.
                        //
                        pTdixRoute->fPending = TRUE;
                        fDoDelete = TRUE;
                    }
                }
            }
            DBG_else
            {
                ASSERT( FALSE );
            }
        }
        while (FALSE);
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoDelete)
        {
            // This is the last reference, so go on and issue the IOCTLs to
            // delete the system host route.
            //
            break;
        }

        if (!fPending)
        {
            // Just remove a reference.
            //
            return;
        }

        // An operation is already pending.  Give it some time to finish then
        // check again.
        //
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(del)" ) );
        NdisMSleep( 100000 );
        TRACE( TL_I, TM_Tdi, ( "NdisMSleep(del)" ) );
    }

    pBuffer = NULL;

    do
    {
        if (pTdixRoute->fUsedNonL2tpRoute)
        {
            // Used a route we didn't add so don't delete it either.
            //
            status = STATUS_SUCCESS;
            break;
        }

        // Get the routing table from the IP stack.  This make take a few
        // iterations since the size of the buffer required is not known.  Set
        // up the static request information first.
        //
        QueryBuf.ID.toi_entity.tei_entity = CL_NL_ENTITY;
        QueryBuf.ID.toi_entity.tei_instance = 0;
        QueryBuf.ID.toi_class = INFO_CLASS_PROTOCOL;
        QueryBuf.ID.toi_type = INFO_TYPE_PROVIDER;
        pDeviceObject = IoGetRelatedDeviceObject( pTdix->pAddress );

        status = !STATUS_SUCCESS;
        ulRouteCount = 20;
        for (;;)
        {
            // Allocate a buffer big enough for 'ulRouteCount' routes.
            //
            ulSize = sizeof(IPRouteEntry) * ulRouteCount;
            QueryBuf.ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            NdisZeroMemory( &QueryBuf.Context, CONTEXT_SIZE );

            pBuffer = (IPRouteEntry* )ALLOC_NONPAGED( ulSize, MTAG_ROUTEQUERY );
            if (!pBuffer)
            {
                TRACE( TL_A, TM_Tdi, ( "Alloc RQ?" ) );
                break;
            }

            // Set up a request to the IP stack to fill the buffer with the
            // routing table and send it to the stack.
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_TCP_QUERY_INFORMATION_EX,
                pDeviceObject,
                (PVOID )&QueryBuf,
                sizeof(QueryBuf),
                pBuffer,
                ulSize,
                FALSE,
                &event,
                &iosb );

            if (!pIrp)
            {
                TRACE( TL_A, TM_Tdi, ( "TCP_QI Irp?" ) );
                break;
            }

            pIrpSp = IoGetNextIrpStackLocation( pIrp );
            pIrpSp->FileObject = pTdix->pAddress;

            status = IoCallDriver( pDeviceObject, pIrp );

            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                status = iosb.Status;
            }

            if (status != STATUS_BUFFER_OVERFLOW)
            {
                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "DHR Q_INFO_EX=%d?", status ) );
                    g_statusLastDhrTcpQueryInfoExFailure = status;
                }
                break;
            }

            // The buffer didn't hold the routing table.  Undo in preparation for
            // another try with twice as big a buffer.
            //
            ulRouteCount <<= 1;
            FREE_NONPAGED( pBuffer );
        }

        if (status != STATUS_SUCCESS)
        {
            break;
        }

        // Calculate how many routes were loaded into our buffer.
        //
        ulRouteCount = (ULONG )(iosb.Information / sizeof(IPRouteEntry));

        // Walk the route table looking for the route we added in
        // TdixAddHostRoute.
        //
        status = !STATUS_SUCCESS;
        pBuffer2 = NULL;
        for (i = 0, pRouteEntry = pBuffer;
             i < ulRouteCount;
             ++i, ++pRouteEntry)
        {
            if (pRouteEntry->ire_dest == ulIpAddress
                && pRouteEntry->ire_proto == IRE_PROTO_NETMGMT)
            {
#if ROUTEWITHREF
                // Found the added route.  Allocate a buffer to hold our
                // request to delete the route.
                //
                ulSize = sizeof(IPRouteEntry);
                pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
                if (!pBuffer2)
                {
                    TRACE( TL_A, TM_Tdi, ( "!pBuffer2" ) );
                    break;
                }

                // Use the found route as a template for the route entry
                // marked for deletion.
                //
                pNewRouteEntry = (IPRouteEntry* )pBuffer2;
                NdisMoveMemory(
                    pNewRouteEntry, pRouteEntry, sizeof(IPRouteEntry) );
                pNewRouteEntry->ire_type = IRE_TYPE_INVALID;

                pIpDeviceObject =
                    IoGetRelatedDeviceObject( pTdix->pIpStackAddress );

                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                pIrp = IoBuildDeviceIoControlRequest(
                    IOCTL_IP_SET_ROUTEWITHREF,
                    pIpDeviceObject,
                    pNewRouteEntry,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);

                if (!pIrp)
                {
                    TRACE( TL_A, TM_Tdi, ( "TCP_SI Irp?" ) );
                    break;
                }

                pIrpSp = IoGetNextIrpStackLocation( pIrp );
                pIrpSp->FileObject = pTdix->pIpStackAddress;

                // Send the request to the IP stack.
                //
                status = IoCallDriver( pIpDeviceObject, pIrp );
#else
                // Found the added route.  Allocate a buffer to hold our
                // request to delete the route.
                //
                ulSize = sizeof(TCP_REQUEST_SET_INFORMATION_EX)
                    + sizeof(IPRouteEntry);
                pBuffer2 = ALLOC_NONPAGED( ulSize, MTAG_ROUTESET );
                if (!pBuffer2)
                {
                    TRACE( TL_A, TM_Tdi, ( "!pSetBuf" ) );
                    break;
                }

                // Fill in the request buffer with static information about
                // changing routes.
                //
                pSetBuf = (TCP_REQUEST_SET_INFORMATION_EX *)pBuffer2;
                NdisZeroMemory( pSetBuf, ulSize );

                pSetBuf->ID.toi_entity.tei_entity = CL_NL_ENTITY;
                pSetBuf->ID.toi_entity.tei_instance = 0;
                pSetBuf->ID.toi_class = INFO_CLASS_PROTOCOL;
                pSetBuf->ID.toi_type = INFO_TYPE_PROVIDER;
                pSetBuf->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
                pSetBuf->BufferSize = sizeof(IPRouteEntry);

                // Use the found route as a template for the route entry marked
                // for deletion.
                //
                pNewRouteEntry = (IPRouteEntry* )&pSetBuf->Buffer[ 0 ];
                NdisMoveMemory(
                    pNewRouteEntry, pRouteEntry, sizeof(IPRouteEntry) );
                pNewRouteEntry->ire_type = IRE_TYPE_INVALID;

                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                pIrp = IoBuildDeviceIoControlRequest(
                    IOCTL_TCP_SET_INFORMATION_EX,
                    pDeviceObject,
                    pSetBuf,
                    ulSize,
                    NULL,
                    0,
                    FALSE,
                    &event,
                    &iosb);

                if (!pIrp)
                {
                    TRACE( TL_A, TM_Tdi, ( "TCP_SI Irp?" ) );
                    break;
                }

                pIrpSp = IoGetNextIrpStackLocation( pIrp );
                pIrpSp->FileObject = pTdix->pAddress;

                // Send the request to the IP stack.
                //
                status = IoCallDriver( pDeviceObject, pIrp );
#endif
                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                    status = iosb.Status;
                }

                if (status != STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Tdi, ( "DHR SET_ROUTE=%d?", status ) );
                    g_statusLastDhrSetRouteFailure = status;
                    break;
                }

                break;
            }
        }

        if (pBuffer2)
        {
            FREE_NONPAGED( pBuffer2 );
        }

        TRACE( TL_V, TM_Tdi, ( "TdixDeleteHostRoute done" ) );
    }
    while (FALSE);

    if (pBuffer)
    {
        FREE_NONPAGED( pBuffer );
    }

    if (pTdixRoute->fUsePayloadAddr) {

        ASSERT(pTdixRoute->hPayloadAddr != NULL);

        ObDereferenceObject( pTdixRoute->pPayloadAddr );

        // Close the payload address object
        //
        ZwClose(pTdixRoute->hPayloadAddr);
        pTdixRoute->hPayloadAddr = NULL;
        pTdixRoute->fUsePayloadAddr = FALSE;
    }

    if (pTdixRoute->hCtrlAddr != NULL) {

        // Close the Ctrl address object
        //
        ObDereferenceObject( pTdixRoute->pCtrlAddr );
        ZwClose (pTdixRoute->hCtrlAddr);
        pTdixRoute->hCtrlAddr = NULL;
    }

    // Remove the route context effectively unpending the operation.
    //
    {
        BOOLEAN fDoClose;
        LONG lRef;

        fDoClose = FALSE;
        NdisAcquireSpinLock( &pTdix->lock );
        {
            if (status == STATUS_SUCCESS)
            {
                ++g_ulTdixDeleteHostRouteSuccesses;
            }
            else
            {
                ++g_ulTdixDeleteHostRouteFailures;
            }

            ASSERT( pTdixRoute->lRef == 0 );
            RemoveEntryList( &pTdixRoute->linkRoutes );

            lRef = --pTdix->lRef;
            TRACE( TL_N, TM_Tdi, ( "TdixDHR, refs=%d", lRef ) );
            if (lRef == 0)
            {
                fDoClose = TRUE;
            }

            FREE_TDIXROUTE( pTdix, pTdixRoute );
        }
        NdisReleaseSpinLock( &pTdix->lock );

        if (fDoClose)
        {
            TdixDoClose( pTdix );
        }
    }
}

NTSTATUS 
TdixGetInterfaceInfo(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    OUT PULONG pulSpeed)
{
    TCP_REQUEST_QUERY_INFORMATION_EX QueryBuf;
    PDEVICE_OBJECT pDeviceObject;
    NTSTATUS status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    UCHAR pBuffer[256];
    KEVENT event;
    IPInterfaceInfo* pInterfaceInfo;

    // Get the routing table from the IP stack.  This make take a few
    // iterations since the size of the buffer required is not known.  Set
    // up the static request information first.
    //
    QueryBuf.ID.toi_entity.tei_entity = CL_NL_ENTITY;
    QueryBuf.ID.toi_entity.tei_instance = 0;
    QueryBuf.ID.toi_class = INFO_CLASS_PROTOCOL;
    QueryBuf.ID.toi_type = INFO_TYPE_PROVIDER;
    QueryBuf.ID.toi_id = IP_INTFC_INFO_ID;
    *(ULONG *)QueryBuf.Context = ulIpAddress;

    pDeviceObject = IoGetRelatedDeviceObject( pTdix->pAddress );
    
    // Set up a request to the IP stack to fill the buffer with the
    // routing table and send it to the stack.
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    pIrp =
        IoBuildDeviceIoControlRequest(
            IOCTL_TCP_QUERY_INFORMATION_EX,
            pDeviceObject,
            (PVOID )&QueryBuf,
            sizeof(QueryBuf),
            pBuffer,
            sizeof(pBuffer),
            FALSE,
            &event,
            &iosb);

    if (!pIrp)
    {
        TRACE( TL_A, TM_Tdi, ( "Build Q Irp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pTdix->pAddress;

    status = IoCallDriver( pDeviceObject, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = iosb.Status;
    }

    if (status == STATUS_SUCCESS)
    {
        *pulSpeed = ((IPInterfaceInfo *)pBuffer)->iii_speed;
    }

    return status;
}

//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

NTSTATUS
TdixSetTdiAOOption(
    IN FILE_OBJECT* pAddress,
    IN ULONG ulOption,
    IN ULONG ulValue)

    // Turn off UDP checksums on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;
    PDEVICE_OBJECT pDeviceObject;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    PIRP pIrp;
    TCP_REQUEST_SET_INFORMATION_EX* pInfo;
    CHAR achBuf[ sizeof(*pInfo) + sizeof(ULONG) ];

    pInfo = (TCP_REQUEST_SET_INFORMATION_EX* )achBuf;
    pInfo->ID.toi_entity.tei_entity = CL_TL_ENTITY;
    pInfo->ID.toi_entity.tei_instance = 0;
    pInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    pInfo->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;
    pInfo->ID.toi_id = ulOption;

    NdisMoveMemory( pInfo->Buffer, &ulValue, sizeof(ulValue) );
    pInfo->BufferSize = sizeof(ulValue);

    pDeviceObject = IoGetRelatedDeviceObject( pAddress );

    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_TCP_WSH_SET_INFORMATION_EX,
        pDeviceObject,
        (PVOID )pInfo,
        sizeof(*pInfo) + sizeof(ulValue),
        NULL,
        0,
        FALSE,
        NULL,
        &iosb );

    if (!pIrp)
    {
        TRACE( TL_A, TM_Tdi, ( "TdixSetTdiAOOption Irp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pAddress;

    status = IoCallDriver( pDeviceObject, pIrp );

    if(NT_SUCCESS(status))
    {
        status = iosb.Status;
    }

    return status;
}


VOID
TdixDisableUdpChecksums(
    IN FILE_OBJECT* pAddress )

    // Turn off UDP checksums on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;

    status = TdixSetTdiAOOption(pAddress, AO_OPTION_XSUM, FALSE);

    TRACE( TL_I, TM_Tdi, ( "Disable XSUMs($%p)=$%08x",
        pAddress, status ) );
}

VOID
TdixEnableIpPktInfo(
    IN FILE_OBJECT* pAddress )

    // Turn on IP_PKTINFO on open UDP address object 'pAddress'.
    //
{
    NTSTATUS status;

    status = TdixSetTdiAOOption(pAddress, AO_OPTION_IP_PKTINFO, TRUE);

    TRACE( TL_I, TM_Tdi, ( "Enable IP_PKTINFO ($%p)=$%08x",
        pAddress, status ) );
}

VOID
TdixDoClose(
    TDIXCONTEXT* pTdix )

    // Called when 'pTdix->lRef' reaches 0 to close down the TDI session.
    // 'PTdix' is the transport context for the session.
    //
{
    TRACE( TL_N, TM_Tdi, ( "TdixDoClose" ) );

    if (pTdix->pAddress)
    {
        // Install a NULL handler, effectively uninstalling.
        //
        TdixInstallEventHandler( pTdix->pAddress,
            TDI_EVENT_RECEIVE_DATAGRAM, NULL, pTdix );

        ObDereferenceObject( pTdix->pAddress );
        pTdix->pAddress = NULL;

        // If have a valid transport address, the lookaside lists were also
        // initialized.
        //
        NdisDeleteNPagedLookasideList( &pTdix->llistRdg );
        NdisDeleteNPagedLookasideList( &pTdix->llistSdg );
    }

    if (pTdix->hAddress)
    {
        ZwClose( pTdix->hAddress );
        pTdix->hAddress = NULL;
    }

#if ROUTEWITHREF
    if (pTdix->hIpStackAddress)
    {
        ZwClose( pTdix->hIpStackAddress );
        pTdix->hIpStackAddress = NULL;
    }
#endif

    if (pTdix->pIpStackAddress)
    {
        ObDereferenceObject( pTdix->pIpStackAddress );
        pTdix->pIpStackAddress = NULL;
    }

    // Mark the operation complete.
    //
    NdisAcquireSpinLock( &pTdix->lock );
    {
        ASSERT( pTdix->lRef == 0 );
        ClearFlags( &pTdix->ulFlags, TDIXF_Pending );
    }
    NdisReleaseSpinLock( &pTdix->lock );
}

VOID
TdixExtractAddress(
    IN TDIXCONTEXT* pTdix,
    OUT TDIXRDGINFO* pRdg,
    IN VOID* pTransportAddress,
    IN LONG lTransportAddressLen,
    IN VOID* Options,
    IN LONG OptionsLength)
    // Fills callers '*pAddress' with the useful part of the transport address
    // 'pTransportAddress' of length 'lTransportAddressLen'.  'PTdix' is our
    // context.
    //
{
    TDIXIPADDRESS* pAddress = &pRdg->source;
    TA_IP_ADDRESS* pTAddress = (TA_IP_ADDRESS* )pTransportAddress;

    ASSERT( lTransportAddressLen == sizeof(TA_IP_ADDRESS) );
    ASSERT( pTAddress->TAAddressCount == 1 );
    ASSERT( pTAddress->Address[ 0 ].AddressType == TDI_ADDRESS_TYPE_IP );
    ASSERT( pTAddress->Address[ 0 ].AddressLength == TDI_ADDRESS_LENGTH_IP );

    // source address   
    pAddress->ulIpAddress = pTAddress->Address[ 0 ].Address[ 0 ].in_addr;
    pAddress->sUdpPort = pTAddress->Address[ 0 ].Address[ 0 ].sin_port;

    // dest address
    if(Options) 
    {
        IN_PKTINFO* pktinfo = (IN_PKTINFO*)TDI_CMSG_DATA(Options);

        ASSERT(((PTDI_CMSGHDR)Options)->cmsg_type == IP_PKTINFO);

        // Fill in the ancillary data object header information.
        pRdg->dest.ulIpAddress = pktinfo->ipi_addr;

        // Get the index of the local interface on which the packet arrived.
        pRdg->dest.ifindex = pktinfo->ipi_ifindex;
    } 
}


NTSTATUS
TdixInstallEventHandler(
    IN FILE_OBJECT* pAddress,
    IN INT nEventType,
    IN VOID* pfuncEventHandler,
    IN VOID* pEventContext )

    // Install a TDI event handler routine 'pfuncEventHandler' to be called
    // when events of type 'nEventType' occur.  'PEventContext' is passed to
    // the handler.  'PAddress' is the transport address object.
    //
    // This call must be made at PASSIVE IRQL.
    //
    // Returns 0 if successful or an error code.
    //
{
    NTSTATUS status;
    PIRP pIrp;

    TRACE( TL_N, TM_Tdi, ( "TdixInstallEventHandler" ) );

    // Allocate a "set event" IRP with base initialization.
    //
    pIrp =
        TdiBuildInternalDeviceControlIrp(
            TDI_SET_EVENT_HANDLER,
            pAddress->DeviceObject,
            pAddress,
            NULL,
            NULL );

    if (!pIrp)
    {
        TRACE( TL_A, TM_Tdi, ( "TdiBuildIDCIrp?" ) );
        return NDIS_STATUS_RESOURCES;
    }

    // Complete the "set event" IRP initialization.
    //
    TdiBuildSetEventHandler(
        pIrp,
        pAddress->DeviceObject,
        pAddress,
        NULL,
        NULL,
        nEventType,
        pfuncEventHandler,
        pEventContext );

    // Tell the I/O manager to pass our IRP to the transport for processing.
    //
    status = IoCallDriver( pAddress->DeviceObject, pIrp );
    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "IoCallDriver=$%08x?", status ) );
        return status;
    }

    TRACE( TL_V, TM_Tdi, ( "TdixInstallEventHandler=0" ) );
    return STATUS_SUCCESS;
}


NTSTATUS
TdixOpenIpAddress(
    IN UNICODE_STRING* puniDevice,
    IN TDIXIPADDRESS* pTdixAddr,
    OUT HANDLE* phAddress,
    OUT FILE_OBJECT** ppFileObject )

    // Open a transport address for the IP-based protocol with name
    // '*puniDevice' and port 'sPort'.  'SPort' may be 0 indicating "any"
    // port.  "Any" address is assumed.  Loads the open address object handle
    // into '*phAddress' and the referenced file object into '*ppFileObject'.
    //
    // Returns STATUS_SUCCESS or an error code.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    FILE_FULL_EA_INFORMATION *pEa;
    ULONG ulEaLength;
    TA_IP_ADDRESS UNALIGNED *pTaIp;
    TDI_ADDRESS_IP UNALIGNED *pTdiIp;
    CHAR achEa[ 100 ];
    HANDLE hAddress;
    FILE_OBJECT* pFileObject;

    hAddress = NULL;
    pFileObject = NULL;

    // Initialize object attributes, a parameter needed to open the device.
    //
    InitializeObjectAttributes(
        &oa, puniDevice, OBJ_CASE_INSENSITIVE, NULL, NULL );

    // Set up the extended attribute that tells the IP stack the IP
    // address/port from which we want to receive.  For raw IP we say "any
    // address and port" and for UDP we say "any address on the L2TP
    // port".  Is this an ugly structure or what?
    //
    ASSERT( sizeof(FILE_FULL_EA_INFORMATION)
        + TDI_TRANSPORT_ADDRESS_LENGTH + sizeof(TA_IP_ADDRESS) <= 100);

    pEa = (FILE_FULL_EA_INFORMATION* )achEa;
    pEa->NextEntryOffset = 0;
    pEa->Flags = 0;
    pEa->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEa->EaValueLength = sizeof(TA_IP_ADDRESS);
    NdisMoveMemory(
        pEa->EaName, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH );

    // Note: The ZwCreateFile wants the sized name to have a null
    //       terminator character (go figure), so add it and account for
    //       it with the "+ 1" below.
    //
    pEa->EaName[ TDI_TRANSPORT_ADDRESS_LENGTH ] = '\0';

    pTaIp = (TA_IP_ADDRESS UNALIGNED* )
        (pEa->EaName + TDI_TRANSPORT_ADDRESS_LENGTH + 1);
    pTaIp->TAAddressCount = 1;
    pTaIp->Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pTaIp->Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

    pTdiIp = &pTaIp->Address[ 0 ].Address[ 0 ];
    pTdiIp->sin_port = pTdixAddr->sUdpPort;
    pTdiIp->in_addr = pTdixAddr->ulIpAddress;
    NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

    ulEaLength = (ULONG )((CHAR* )(pTaIp + 1) - (CHAR* )pEa);

    // Open the transport address.
    //
    status =
        ZwCreateFile(
            &hAddress,
            FILE_READ_DATA | FILE_WRITE_DATA,
            &oa,
            &iosb,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_WRITE,
            FILE_OPEN,
            0,
            pEa,
            ulEaLength );

    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "ZwCreateFile(%S)=$%08x,ios=$%08x?",
            puniDevice->Buffer, status, iosb.Information ) );
        return status;
    }

    // Get the object address from the handle.  This also checks our
    // permissions on the object.
    //
    status =
        ObReferenceObjectByHandle(
            hAddress,
            0,
            NULL,
            KernelMode,
            &pFileObject,
            NULL );

    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi,
            ( "ObRefObjByHandle(%S)=$%08x?", puniDevice->Buffer, status ) );
        ZwClose( hAddress );
        return status;
    }

    *phAddress = hAddress;
    *ppFileObject = pFileObject;
    return STATUS_SUCCESS;
}


NTSTATUS
TdixReceiveDatagramHandler(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG* BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP* IoRequestPacket )

    // Standard TDI ClientEventReceiveDatagram indication handler.  See TDI
    // doc.  Runs at DISPATCH IRQL.
    //
{
    TDIXCONTEXT* pTdix;
    TDIXRDGINFO* pRdg;
    CHAR* pBuffer;
    NDIS_BUFFER* pNdisBuffer;
    PIRP pIrp;

    TRACE( TL_N, TM_Tdi, ( "TdixRecvDg, f=$%08x bi=%d, ba=%d",
        ReceiveDatagramFlags, BytesIndicated, BytesAvailable ) );


    if (BytesAvailable > L2TP_FrameBufferSize) {

        // We received a larger datagram then expected or can handle,
        // so we just ignore the datagram.
        //
        ASSERT( !"BytesAvailable > L2TP_FrameBufferSize?" );
        *IoRequestPacket = NULL;
        *BytesTaken = 0;
        return STATUS_SUCCESS;
    }

    pTdix = (TDIXCONTEXT* )TdiEventContext;

    // Allocate a receive pBuffer from TDIX client's pool.
    //
    pBuffer = GetBufferFromPool( pTdix->pPoolNdisBuffers );
    if (!pBuffer)
    {
        // Not a whole lot we can do with this unlikely error from inside this
        // handler, so we just ignore the datagram.
        //
        ASSERT( !"GetBfromP?" );
        return STATUS_SUCCESS;
    }

    // Allocate a context for this read-datagram from our lookaside list.
    //
    pRdg = ALLOC_TDIXRDGINFO( pTdix );
    if (pRdg)
    {
        // Fill in the read-datagram context with the information that won't
        // otherwise be available in the completion routine.
        //
        pRdg->pTdix = pTdix;
        pRdg->pBuffer = pBuffer;
        pRdg->ulBufferLen = BytesAvailable;

        // Extract the useful IP address from the more general transport
        // address information.
        //

        TdixExtractAddress(
            pTdix, pRdg, SourceAddress, SourceAddressLength, Options, OptionsLength);
    }
    else
    {
        // Not a whole lot we can do with this unlikely error from inside this
        // handler, so we just ignore the datagram.
        //
        FreeBufferToPool( pTdix->pPoolNdisBuffers, pBuffer, TRUE );
        ASSERT( !"AllocRdg?" );
        return STATUS_SUCCESS;
    }

    if (BytesIndicated < BytesAvailable)
    {
        // The less common case where all the information is not immediately
        // available.  Allocate an IRP to request the data.
        //
#if ALLOCATEIRPS
        // Allocate the IRP directly.
        //
        pIrp = IoAllocateIrp(
            pTdix->pAddress->DeviceObject->StackSize, FALSE );
#else
        // Allocate a "receive datagram" IRP with base initialization.
        //
        pIrp =
            TdiBuildInternalDeviceControlIrp(
                TDI_RECEIVE_DATAGRAM,
                pTdix->pAddress->DeviceObject,
                pTdix->pAddress,
                NULL,
                NULL );
#endif

        if (!pIrp)
        {
            // Not a whole lot we can do with this unlikely error from inside
            // this handler, so we just ignore the datagram.
            //
            FreeBufferToPool( pTdix->pPoolNdisBuffers, pBuffer, TRUE );
            FREE_TDIXRDGINFO( pTdix, pRdg );
            ASSERT( !"Alloc IRP?" );
            return STATUS_SUCCESS;
        }

        pNdisBuffer = NdisBufferFromBuffer( pBuffer );

        // Complete the "receive datagram" IRP initialization.
        //
        TdiBuildReceiveDatagram(
            pIrp,
            pTdix->pAddress->DeviceObject,
            pTdix->pAddress,
            TdixReceiveDatagramComplete,
            pRdg,
            pNdisBuffer,
            0,
            NULL,
            NULL,
            0 );

        // Adjust the IRP's stack location to make the transport's stack
        // current.  Normally IoCallDriver handles this, but this IRP doesn't
        // go thru IoCallDriver.  Seems like it would be the transport's job
        // to make this adjustment, but IP for one doesn't seem to do it.
        // There is a similar adjustment in both the redirector and PPTP.
        //
        IoSetNextIrpStackLocation( pIrp );

        *IoRequestPacket = pIrp;
        *BytesTaken = 0;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        // The common case where all the information is immediately available.
        // Copy it to from the transport buffer and call client's completion
        // handler directly.  See bug 329371.
        //
        NdisMoveMemory( pBuffer, (CHAR* )Tsdu, BytesIndicated );
        TdixReceiveDatagramComplete( NULL, NULL, pRdg );

        *IoRequestPacket = NULL;
        *BytesTaken = BytesIndicated;

        return STATUS_SUCCESS;
    }

    // Not reached.
}


NTSTATUS
TdixReceiveDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )

    // Standard NT I/O completion routine.  See DDK doc.  Called with a NULL
    // 'DeviceObject' and 'Irp' to complete the fast-past Irp-less receives.
    //
{
    TDIXRDGINFO* pRdg;
    BOOLEAN fBad;
    ULONG ulOffset;

    pRdg = (TDIXRDGINFO* )Context;

    TRACE( TL_N, TM_Tdi, ( "TdixRecvDgComp" ) );

    fBad = FALSE;
    ulOffset = 0;

    if (pRdg->pTdix->mediatype == TMT_RawIp)
    {
        UCHAR uchVersion;

        // The raw IP stack doesn't strip the IP header from the received
        // datagram for some reason, so calculate the offset to the "real"
        // data at the end of the IP header.
        //
        uchVersion = *((UCHAR* )pRdg->pBuffer) >> 4;
        if (uchVersion == 4)
        {
            // Good, it's IP version 4.  Find the length of the IP header,
            // which can vary depending on the presence of option fields.
            //
            ulOffset = (*((UCHAR* )pRdg->pBuffer) & 0x0F) * sizeof(ULONG);
        }
        else
        {
            // It's not IP version 4, the only version we handle.
            //
            TRACE( TL_A, TM_Tdi, ( "Not IPv4? v=%d?", (ULONG )uchVersion ) );
            fBad = TRUE;
        }
    }

    if (!fBad && (!Irp || Irp->IoStatus.Status == STATUS_SUCCESS))
    {
        // Pass the result to the TDIX client's handler.
        //
        pRdg->pTdix->pReceiveHandler(
            pRdg->pTdix,
            pRdg,
            pRdg->pBuffer,
            ulOffset,
            pRdg->ulBufferLen );
    }

    // Free the read-datagram context.
    //
    FREE_TDIXRDGINFO( pRdg->pTdix, pRdg );

#if ALLOCATEIRPS
    // Release the IRP resources, if any, and tell the I/O manager to forget
    // it existed in the standard way.
    //
    if (Irp)
    {
        IoFreeIrp( Irp );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
#endif

    // Let the I/O manager release the IRP resources, if any.
    //
    return STATUS_SUCCESS;
}


TDIXROUTE*
TdixRouteFromIpAddress(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress)

    // Returns the host route context associated with IP address 'ulIpAddress'
    // from the TDIX context 'pTdix's list of host routes, or NULL if none.
    // 'UlIpAddress' is in network byte order.
    //
    // IMPORTANT:  The caller must hold 'pTdix->lock'.
    //
{
    LIST_ENTRY* pLink;

    for (pLink = pTdix->listRoutes.Flink;
         pLink != &pTdix->listRoutes;
         pLink = pLink->Flink)
    {
        TDIXROUTE* pRoute;

        pRoute = CONTAINING_RECORD( pLink, TDIXROUTE, linkRoutes );
        if (pRoute->ulIpAddress == ulIpAddress)
        {
            return pRoute;
        }
    }

    return NULL;
}


NTSTATUS
TdixSendComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )

    // Standard NT I/O completion routine.  See DDK doc.
    //
{
    TDIXSDGINFO* pSdg;

    DBG_if (Irp->IoStatus.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "TdixSendComp, s=$%08x?",
            Irp->IoStatus.Status ) );
    }

    pSdg = (TDIXSDGINFO* )Context;

    // Pass the result to the TDIX client's handler.
    //
    pSdg->pSendCompleteHandler(
        pSdg->pTdix, pSdg->pContext1, pSdg->pContext2, pSdg->pBuffer );

    // Free the send-complete context.
    //
    FREE_TDIXSDGINFO( pSdg->pTdix, pSdg );

#if ALLOCATEIRPS
    // Release the IRP resources and tell the I/O manager to forget it existed
    // in the standard way.
    //
    IoFreeIrp( Irp );
    return STATUS_MORE_PROCESSING_REQUIRED;
#else
    // Let the I/O manager release the IRP resources.
    //
    return STATUS_SUCCESS;
#endif
}

NTSTATUS
TdixSendDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )

    // Standard NT I/O completion routine.  See DDK doc.
    //
{
    TDIXSDGINFO* pSdg;

    DBG_if (Irp->IoStatus.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "TdixSendDgComp, s=$%08x?",
            Irp->IoStatus.Status ) );
    }

    pSdg = (TDIXSDGINFO* )Context;

    // Pass the result to the TDIX client's handler.
    //
    pSdg->pSendCompleteHandler(
        pSdg->pTdix, pSdg->pContext1, pSdg->pContext2, pSdg->pBuffer );

    // Free the send-complete context.
    //
    FREE_TDIXSDGINFO( pSdg->pTdix, pSdg );

#if ALLOCATEIRPS
    // Release the IRP resources and tell the I/O manager to forget it existed
    // in the standard way.
    //
    IoFreeIrp( Irp );
    return STATUS_MORE_PROCESSING_REQUIRED;
#else
    // Let the I/O manager release the IRP resources.
    //
    return STATUS_SUCCESS;
#endif
}

NTSTATUS
TdixConnectAddrInterface(
    FILE_OBJECT* pFileObj,
    HANDLE hFileHandle,
    TDIXROUTE* pTdixRoute
    )
{
    NTSTATUS status;
    PDEVICE_OBJECT pDeviceObj;
    PIO_STACK_LOCATION pIrpSp;
    IO_STATUS_BLOCK iosb;
    PIRP pIrp;
    TCP_REQUEST_SET_INFORMATION_EX* pInfo;
    CHAR achBuf[ sizeof(*pInfo) + sizeof(ULONG) ];
    ULONG ulValue;
    TDI_CONNECTION_INFORMATION RequestConnInfo;
    KEVENT  Event;
    TA_IP_ADDRESS taip;
    TDI_ADDRESS_IP* pTdiIp;
    KEVENT  event;


    pDeviceObj = IoGetRelatedDeviceObject( pFileObj );

#if 0
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = TdiBuildInternalDeviceControlIrp(TDI_ASSOCIATE_ADDRESS,
                                            pDeviceObj,
                                            pFileObj,
                                            &Event,
                                            &iosb);

    if (!pIrp) {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Associate Irp?" ) );
        return !STATUS_SUCCESS;
    }

    TdiBuildAssociateAddress(pIrp, 
                             pDeviceObj, 
                             pFileObj, 
                             NULL, 
                             NULL,
                             hFileHandle);

    status = IoCallDriver( pDeviceObj, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, 0);
    }

    if (iosb.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Associate=%x?", status ) );
        return (iosb.Status);
    }
#endif

    pInfo = (TCP_REQUEST_SET_INFORMATION_EX* )achBuf;
    pInfo->ID.toi_entity.tei_entity = CL_TL_ENTITY;
    pInfo->ID.toi_entity.tei_instance = 0;
    pInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    pInfo->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;
    pInfo->ID.toi_id = AO_OPTION_IP_UCASTIF;

    ulValue = pTdixRoute->InterfaceIndex;

    NdisMoveMemory( pInfo->Buffer, &ulValue, sizeof(ulValue) );
    pInfo->BufferSize = sizeof(ulValue);

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_TCP_WSH_SET_INFORMATION_EX,
        pDeviceObj,
        (PVOID )pInfo,
        sizeof(*pInfo) + sizeof(ulValue),
        NULL,
        0,
        FALSE,
        &event,
        &iosb );

    if (!pIrp)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Irp?" ) );
        return !STATUS_SUCCESS;
    }

    pIrpSp = IoGetNextIrpStackLocation( pIrp );
    pIrpSp->FileObject = pFileObj;

    status = IoCallDriver( pDeviceObj, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = iosb.Status;
    }

    if (status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex=%x?", status ) );
        return status;
    }

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = TdiBuildInternalDeviceControlIrp(TDI_CONNECT,
                                            pDeviceObj,
                                            pFileObj,
                                            &Event,
                                            &iosb);

    if (!pIrp) {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex ConnectIrp?" ) );
        return !STATUS_SUCCESS;
    }

    // Put the destination IP address in the "connection" structure as TDI
    // expects.  
    //
    taip.TAAddressCount = 1;
    taip.Address[ 0 ].AddressLength = TDI_ADDRESS_LENGTH_IP;
    taip.Address[ 0 ].AddressType = TDI_ADDRESS_TYPE_IP;

    pTdiIp = &taip.Address[ 0 ].Address[ 0 ];
    pTdiIp->sin_port = pTdixRoute->sPort;
    pTdiIp->in_addr = pTdixRoute->ulIpAddress;
    NdisZeroMemory( pTdiIp->sin_zero, sizeof(pTdiIp->sin_zero) );

    RequestConnInfo.Options = NULL;
    RequestConnInfo.OptionsLength = 0;
    RequestConnInfo.RemoteAddress = &taip;
    RequestConnInfo.RemoteAddressLength = sizeof(taip);
    RequestConnInfo.UserData = NULL;
    RequestConnInfo.UserDataLength = 0;

    TdiBuildConnect(pIrp,
                    pDeviceObj,
                    pFileObj,
                    NULL,
                    NULL,
                    0,
                    &RequestConnInfo,
                    NULL);

    status = IoCallDriver( pDeviceObj, pIrp );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, 0);
    }

    if (iosb.Status != STATUS_SUCCESS)
    {
        TRACE( TL_A, TM_Tdi, ( "SetIfcIndex Connect=%x?", status ) );
        return (iosb.Status);
    }

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <ntdbg.h>
#include <ntsdexts.h>
//#define NOEXTAPI
#include <wdbgexts.h>
#include <ntverp.h>
//#include <stdexts.h>

//
// globals
//
//EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
USHORT                 usProcessorArchitecture;
BOOL                   bDebuggingChecked;

PSZ szProcessorArchitecture[] = {
    "Intel",
    "MIPS",
    "Alpha",
    "PPC"
};
#define cArchitecture (sizeof(szProcessorArchitecture) / sizeof(PSZ))

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ULONG offKeProcessorArchitecture;
    ULONG Result;

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
    usProcessorArchitecture = (USHORT)-1;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\timer.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.h
// RAS L2TP WAN mini-port/call-manager driver
// Timer management header
//
// 01/07/97 Steve Cobb
//
// This interface encapsulates the queuing of multiple timer events onto a
// single NDIS timer.


#ifndef _TIMER_H_
#define _TIMER_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _TIMERQ TIMERQ;
typedef struct _TIMERQITEM TIMERQITEM;
typedef enum _TIMERQEVENT TIMERQEVENT;


// Timer queue event handler.  'PTqi' and 'pContext' are the timer event
// descriptor and user context passed to TimerQScheduleItem.  'Event' is the
// timer event code indicating whether the timer expired, was cancelled, or
// the queue was terminated.
//
// The "cancel" event is never generated internally, but only by a user call
// to TimerQCancelItem, thus user may require specific locks be held for
// "cancel" events.  User cannot require than specific locks be held for
// "expire" or "terminate" events as these may be generated internally.  User
// should pay attention to the return codes of TimerQCancelItem and
// TimerQTerminateItem calls, as it will occassionally be impossible to stop
// an "expire" event that has not yet been processed from occurring.
//
typedef
VOID
(*PTIMERQEVENT)(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event );

// Timer queue termination completion handler.  'PTimerQ' is the timer queue
// descriptor.  'PContext' is user's context as passed to TimerQTerminate.
// Caller must not free or reuse the TIMERQ before this routine is called.
//
typedef
VOID
(*PTIMERQTERMINATECOMPLETE)(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );


// Timer queue descriptor.  All access should be via the TimerQ* interface.
// There is no reason user should look inside.  All necessary locking is
// handled internally.
//
typedef struct
_TIMERQ
{
    // Set to MTAG_TIMERQ when the block is valid and to MTAG_FREED when no
    // longer valid.
    //
    LONG ulTag;

    // Head of a double-linked list of "ticking" TIMERQITEMs.  The list is
    // sorted by time to expiration with the earliest expiration at the head
    // of the list.  The list is protected by 'lock'.
    //
    LIST_ENTRY listItems;

    // Caller's terminate complete handler as passed to TimerQTerminate.  This
    // is non-NULL only when our internal timer event handler must call it.
    //
    PTIMERQTERMINATECOMPLETE pHandler;

    // User's PTIMERQTERMINATECOMPLETE context passed back to 'pHandler'.
    //
    VOID* pContext;

    // Set when the timer queue is terminating.  No other requests are
    // accepted when this is the case.
    //
    BOOLEAN fTerminating;

    // Spin lock protecting the 'listItems' list.
    //
    NDIS_SPIN_LOCK lock;

    // NDIS timer object.
    //
    NDIS_TIMER timer;
}
TIMERQ;


// Timer queue event descriptor.  All access should be via the TimerQ*
// interface.  There is no reason user should look inside.  This is exposed to
// allow user to efficiently manage allocation of TIMERQITEMS for several
// timers from a large pool.
//
typedef struct
_TIMERQITEM
{
    // Links to the prev/next TIMERQITEM in the owning TIMERQ's chain of
    // pending timer events.  Access is protected by 'lock' in the TIMERQ
    // structure.
    //
    LIST_ENTRY linkItems;

    // System time at which this event should occur.
    //
    LONGLONG llExpireTime;

    // User's routine to handle the timeout event when it occurs.
    //
    PTIMERQEVENT pHandler;

    // User's PTIMERQEVENT context passed back to 'pHandler'.
    //
    VOID* pContext;
}
TIMERQITEM;


// Indicates the event which triggered user's callback to be called.
//
typedef enum
_TIMERQEVENT
{
    // The timeout interval has elapsed or user called TimerQExpireItem.
    //
    TE_Expire,

    // User called TimerQCancelItem.
    //
    TE_Cancel,

    // User called TimerQTerminateItem or called TimerQTerminate while the
    // item was queued.
    //
    TE_Terminate
}
TIMERQEVENT;


//-----------------------------------------------------------------------------
// Interface prototypes
//-----------------------------------------------------------------------------

BOOLEAN
IsTimerQItemScheduled(
    IN TIMERQITEM* pItem );

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ );

VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem );

VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext );

VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext );

BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event );

BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );


#endif // TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\util.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// util.c
// RAS L2TP WAN mini-port/call-manager driver
// General utility routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


// Debug counts of oddities that should not be happening.
//
ULONG g_ulAllocTwFailures = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber );

VOID
ReversePsz(
    IN OUT CHAR* psz );

VOID
TunnelWork(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf );


//-----------------------------------------------------------------------------
// General utility routines (alphabetically)
//-----------------------------------------------------------------------------

#if 0
ULONGLONG g_llLastTime2 = 0;
ULONGLONG g_llLastTime1 = 0;
ULONGLONG g_llLastTime = 0;
NDIS_SPIN_LOCK g_lockX;

VOID
XNdisGetCurrentSystemTime(
    IN LARGE_INTEGER* plrgTime )
{
    static BOOLEAN f = 0;

    if (!f)
    {
        NdisAllocateSpinLock( &g_lockX );
        f = 1;
    }

    NdisGetCurrentSystemTime( plrgTime );

    NdisAcquireSpinLock( &g_lockX );
    {
        LONGLONG ll;

        g_llLastTime2 = g_llLastTime1;
        g_llLastTime1 = g_llLastTime;
        g_llLastTime = plrgTime->QuadPart;
        ll = g_llLastTime - g_llLastTime1;
        TRACE( TL_I, TM_Spec, ( "Time delta=%d", *((LONG* )&ll) ) );
        ASSERT( g_llLastTime >= g_llLastTime1 );
    }
    NdisReleaseSpinLock( &g_lockX );
}
#endif


VOID
AddHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to change an existing host route.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB*  pAdapter;

    TRACE( TL_N, TM_Misc, ( "AddHostRoute" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    // Add the host route, noting success for clean-up later, or closing the
    // tunnel on failure.
    //
    pTunnel->pRoute = 
        TdixAddHostRoute( &pAdapter->tdix, pTunnel->address.ulIpAddress,
                        pTunnel->address.sUdpPort);

    if (pTunnel->pRoute != NULL)
    {
        NDIS_STATUS status;
        
        // Setup the connection to do connected udp
        // if required
        //
        status = TdixSetupConnection(
                    &pAdapter->tdix, pTunnel->address.ulIpAddress,
                    pTunnel->address.sUdpPort,
                    pTunnel->pRoute,
                    &pTunnel->udpContext);

        if(status != STATUS_SUCCESS)
        {
            TdixDestroyConnection(&pTunnel->udpContext);
            TdixDeleteHostRoute(&pAdapter->tdix, 
                pTunnel->address.ulIpAddress);

            pTunnel->pRoute = NULL;
            
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )TRESULT_GeneralWithError,
                (ULONG_PTR )GERR_NoResources,
                0, 0, FALSE, FALSE );
        }

        SetFlags( &pTunnel->ulFlags, TCBF_HostRouteAdded );

        if (pTunnel->udpContext.hCtrlAddr != NULL) {
            SetFlags (&pTunnel->ulFlags, TCBF_SendConnected);
        }
    }
    else
    {
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
    }
}


BOOLEAN
AdjustSendWindowAtAckReceived(
    IN ULONG ulMaxSendWindow,
    IN OUT ULONG* pulAcksSinceSendTimeout,
    IN OUT ULONG* pulSendWindow )

    // Adjust send window/factors for the acknowledge just received.
    //
    // Returns true if the send window was changed, false if not.
    //
{
    // Update the "ack streak" counter and, if a full windows worth has been
    // received since timing out, bump up the send window.
    //
    ++(*pulAcksSinceSendTimeout);
    if (*pulAcksSinceSendTimeout >= *pulSendWindow
        && *pulSendWindow < ulMaxSendWindow)
    {
        TRACE( TL_N, TM_Send,
            ( "SW open to %d, %d acks",
            (*pulSendWindow), *pulAcksSinceSendTimeout ) );

        *pulAcksSinceSendTimeout = 0;
        ++(*pulSendWindow);
        return TRUE;
    }

    return FALSE;
}


VOID
AdjustTimeoutsAtAckReceived(
    IN LONGLONG llSendTime,
    IN ULONG ulMaxSendTimeoutMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT LONG* plDeviationMs )

    // Adjust send timeout/factors for the acknowledge just received.
    //
{
    LARGE_INTEGER lrgTime;
    LONGLONG llSampleMs;
    ULONG ulSampleMs;
    LONG lDiff;
    LONG lDif8;
    LONG lAbsDif8;
    LONG lDev8;
    ULONG ulAto;

    // First, calculate the "sample", i.e. the time that was actually required
    // for the round trip.
    //
    NdisGetCurrentSystemTime( &lrgTime );
    if (llSendTime > lrgTime.QuadPart)
    {
        // This shouldn't happen but once it appeared that it did, so this
        // defensive conditional is included.  Maybe NdisGetCurrentSystemTime
        // has a bug?
        //
        TRACE( TL_A, TM_Misc, ( "Future send time?" ) );
        llSendTime = lrgTime.QuadPart;
    }

    llSampleMs = (lrgTime.QuadPart - llSendTime) / 10000;
    ASSERT( ((LARGE_INTEGER* )(&llSampleMs))->HighPart == 0 );
    ulSampleMs = (ULONG )(((LARGE_INTEGER* )(&llSampleMs))->LowPart);

    // The typical 'alpha' of 1/8, 'beta' of 1/4, and 'chi' of 4 are used, per
    // the suggestion in the draft/RFC.  To eliminate multiplication and
    // division, the factors are scaled by 8, calculated, and scaled back.
    //
    // Find the intermediate DIFF value, representing the difference between
    // the estimated and actual round trip times, and the scaled and absolute
    // scaled values of same.
    //
    lDiff = (LONG )ulSampleMs - (LONG )(*pulRoundTripMs);
    lDif8 = lDiff << 3;
    lAbsDif8 = (lDif8 < 0) ? -lDif8 : lDif8;

    // Calculate the scaled new DEV value, representing the approximate
    // standard deviation.
    //
    lDev8 = *plDeviationMs << 3;
    lDev8 = lDev8 + ((lAbsDif8 - lDev8) << 1);
    *plDeviationMs = lDev8 >> 3;

    // Find the scaled new RTT value, representing the estimated round trip
    // time.  The draft/RFC shows the calculation "old RTT + diff", but that's
    // just the "sample" we found earlier, i.e. the actual round trip time of
    // this packet.
    //
    *pulRoundTripMs = ulSampleMs;

    // Calculate the ATO value, representing the new send timeout.  Because of
    // clock granularity the timeout might come out 0, which is converted to
    // the more reasonable 1.
    //
    ulAto = (ULONG )(((LONG )*pulRoundTripMs) + (*plDeviationMs << 2));
    if (ulAto == 0)
    {
        ulAto = 1;
    }
    *pulSendTimeoutMs = min( ulAto, ulMaxSendTimeoutMs );
}


VOID
AdjustTimeoutsAndSendWindowAtTimeout(
    IN ULONG ulMaxSendTimeoutMs,
    IN LONG lDeviationMs,
    OUT ULONG* pulSendTimeoutMs,
    IN OUT ULONG* pulRoundTripMs,
    IN OUT ULONG* pulSendWindow,
    OUT ULONG* pulAcksSinceSendTimeout )

    // Adjust send timeout/factors and send window for the timeout that just
    // occurred.
    //
    // Returns true if the send window was changed, false if not.
    //
{
    ULONG ulNew;

    // Using the suggested 'delta' of 2, the round trip estimate is doubled.
    //
    *pulRoundTripMs <<= 1;

    // Using the typical 'chi' of 4, the send timeout is increased.  Because
    // of clock granularity the timeout might come out 0, which is converted
    // to the more reasonable 1.
    //
    ulNew = (ULONG )(((LONG )*pulRoundTripMs) + (lDeviationMs << 2));
    *pulSendTimeoutMs = min( ulNew, ulMaxSendTimeoutMs );
    if (*pulSendTimeoutMs == 0)
    {
        *pulSendTimeoutMs = 1;
    }

    // The send window is halved.
    //
    ulNew = *pulSendWindow >> 1;
    *pulSendWindow = max( ulNew, 1 );

    // Consecutive acknowledge counter is reset.
    //
    *pulAcksSinceSendTimeout = 0;
}


#if 0
VOID
BuildWanAddress(
    IN CHAR* pArg1,
    IN ULONG ulLength1,
    IN CHAR* pArg2,
    IN ULONG ulLength2,
    IN CHAR* pArg3,
    IN ULONG ulLength3,
    OUT WAN_ADDRESS* pWanAddress )

    // Builds a '\0' separated token list in WAN address 'pWanAddress',
    // consisting of the 3 arguments.  If the arguments are too long the last
    // ones are truncated.
    //
{
    CHAR* pch;
    ULONG ulLengthLeft;
    ULONG ulCopyLength;

    // Reserve room for 3 end-of-argument null characters, plus a final null.
    //
    NdisZeroMemory( &pWanAddress->Address[ MAX_WAN_ADDRESSLENGTH - 4 ], 4 );

    pch = pWanAddress->Address;
    ulLengthLeft = MAX_WAN_ADDRESSLENGTH - 4;

    ulCopyLength = min( ulLength1, ulLengthLeft );
    if (ulCopyLength)
    {
        NdisMoveMemory( pch, pArg1, ulCopyLength );
        ulLengthLeft -= ulCopyLength;
        pch += ulCopyLength;
    }

    *pch++ = '\0';

    ulCopyLength = min( ulLength2, ulLengthLeft );
    if (ulCopyLength)
    {
        NdisMoveMemory( pch, pArg2, ulCopyLength );
        ulLengthLeft -= ulCopyLength;
        pch += ulCopyLength;
    }

    *pch++ = '\0';

    ulCopyLength = min( ulLength3, ulLengthLeft );
    if (ulCopyLength)
    {
        NdisMoveMemory( pch, pArg3, ulCopyLength );
        pch += ulCopyLength;
    }

    *pch++ = '\0';
    *pch++ = '\0';

    pWanAddress->AddressLength = (ULONG )(pch - pWanAddress->Address);
}
#endif


VOID
CalculateResponse(
    IN UCHAR* puchChallenge,
    IN ULONG ulChallengeLength,
    IN CHAR* pszPassword,
    IN UCHAR uchId,
    OUT UCHAR* puchResponse )

    // Loads caller's 16-byte challenge response buffer, 'puchResponse', with
    // the CHAP-style MD5ed response based on packet ID 'uchId', the
    // 'ulChallengeLength' byte challenge 'puchChallenge', and the null
    // terminated password 'pszPassword'.
    //
{
    ULONG ul;
    MD5_CTX md5ctx;

    MD5Init( &md5ctx );
    MD5Update( &md5ctx, &uchId, 1 );
    MD5Update( &md5ctx, pszPassword, strlen( pszPassword ) );
    MD5Update( &md5ctx, puchChallenge, ulChallengeLength );
    MD5Final( &md5ctx );

    NdisMoveMemory( puchResponse, md5ctx.digest, 16 );
}


VOID
ChangeHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to change an existing host route.  Arg0 is the IP
    // address of the existing host route to be deleted.  Arg1 is the IP
    // address of the host route to add.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;
    ULONG ulOldIpAddress;
    ULONG ulNewIpAddress;

    TRACE( TL_N, TM_Misc, ( "ChangeHostRoute" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    ulOldIpAddress = (ULONG )(punpArgs[ 0 ]);
    ulNewIpAddress = (ULONG )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    // Add the new host route, then delete the old one.
    //
    if (TdixAddHostRoute( &pAdapter->tdix, ulNewIpAddress, 
        pTunnel->address.sUdpPort))
    {
        ClearFlags( &pTunnel->ulFlags, TCBF_HostRouteAdded );
        TdixDestroyConnection(&pTunnel->udpContext);
        TdixDeleteHostRoute( &pAdapter->tdix, ulOldIpAddress);
    }
    else
    {
        ScheduleTunnelWork(
            pTunnel, NULL, CloseTunnel,
            0, 0, 0, 0, FALSE, FALSE );
    }
}


VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = ReadFlags( pulFlags );
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}


VOID
CloseTdix(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close the TDIX context associated with a
    // tunnel.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Misc, ( "CloseTdix" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    // Delete the old host route, and note same in tunnel flags.
    //
    TdixClose( &pAdapter->tdix );
    ClearFlags( &pTunnel->ulFlags, TCBF_TdixReferenced );
}


VOID
DeleteHostRoute(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* pulArgs )

    // A PTUNNELWORK routine to change an existing host route.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Misc, ( "DeleteHostRoute" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pTunnel->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    // Destroy the connected udp context
    //
    TdixDestroyConnection(&pTunnel->udpContext);

    // Delete the old host route, and note same in tunnel flags.
    //
    TdixDeleteHostRoute( &pAdapter->tdix, 
                    pTunnel->address.ulIpAddress);
    ClearFlags( &pTunnel->ulFlags, TCBF_HostRouteAdded );
}


VOID
DottedFromIpAddress(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress,
    IN BOOLEAN fUnicode )

    // Converts network byte-ordered IP addresss 'ulIpAddress' to a string in
    // the a.b.c.d form and returns same in caller's 'pszIpAddress' buffer.
    // The buffer should be at least 16 characters long.  If 'fUnicode' is set
    // the returned 'pszIpAddress' is in Unicode and must be at least 16 wide
    // characters long.
    //
{
    CHAR szBuf[ 3 + 1 ];

    ULONG ulA = (ulIpAddress & 0x000000FF);
    ULONG ulB = (ulIpAddress & 0x0000FF00) >> 8;
    ULONG ulC = (ulIpAddress & 0x00FF0000) >> 16;
    ULONG ulD = (ulIpAddress & 0xFF000000) >> 24;

    ultoa( ulA, szBuf );
    strcpy( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulB, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulC, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulD, szBuf );
    strcat( pszIpAddress, szBuf );

    if (fUnicode)
    {
        WCHAR* psz;

        psz = StrDupAsciiToUnicode( pszIpAddress, strlen( pszIpAddress ) );
        if (psz)
        {
            NdisMoveMemory(
                pszIpAddress, psz, (StrLenW( psz ) + 1) * sizeof(WCHAR) );
            FREE_NONPAGED( psz );
        }
        else
        {
            *((WCHAR*)pszIpAddress) = L'\0';
        }
    }
}


#if 0
NDIS_STATUS
ExecuteWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN ULONG ulArg3,
    IN ULONG ulArg4 )

    // This provides a way to call a routine designed to be called by the
    // ScheduleWork utility when caller is already at passive IRQL.  The
    // 'pProc' routine is executed inline instead of scheduled.  The context
    // 'pContext' is passed to 'pProc' The extra context arguments 'ulArg1'
    // and 'ulArg2' are stashed in extra space allocated on the end of the
    // NDIS_WORK_ITEM.  'PAdapter' is the adapter control block from which the
    // work item is allocated.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    // TDI setup must be done at PASSIVE IRQL so schedule a routine to do it.
    //
    pWork = ALLOC_NDIS_WORK_ITEM( pAdapter );
    if (!pWork)
    {
        ASSERT( !"Alloc work" );
        return NDIS_STATUS_RESOURCES;
    }

    ((ULONG*)(pWork + 1))[ 0 ] = ulArg1;
    ((ULONG*)(pWork + 1))[ 1 ] = ulArg2;
    ((ULONG*)(pWork + 1))[ 2 ] = ulArg3;
    ((ULONG*)(pWork + 1))[ 3 ] = ulArg4;

    pProc( pWork, pContext );
}
#endif


#if 0
VOID
ExplodeWanAddress(
    IN WAN_ADDRESS* pWanAddress,
    OUT CHAR** ppArg1,
    OUT ULONG* pulLength1,
    OUT CHAR** ppArg2,
    OUT ULONG* pulLength2,
    OUT CHAR** ppArg3,
    OUT ULONG* pulLength3 )

    // Returns the '\0'-separated tokens in WAN address 'pWanAddress', and
    // their lengths.
    //
{
    CHAR* pch;

    // Make sure 3 null characters will be found before going off the end of
    // the buffer.
    //
    pch = &pWanAddress->Address[ MAX_WAN_ADDRESSLENGTH - 3 ];
    NdisZeroMemory( pch, 3 );

    *ppArg1 = pWanAddress->Address;
    *pulLength1 = (ULONG )strlen( *ppArg1 );
    *ppArg2 = *ppArg1 + *pulLength1 + 1;
    *pulLength2 = (ULONG )strlen( *ppArg2 );
    *ppArg3 = *ppArg2 + *pulLength2 + 1;
    *pulLength3 = (ULONG )strlen( *ppArg3 );
}
#endif


USHORT
GetNextTerminationCallId(
    IN ADAPTERCB* pAdapter )

    // Returns the next unused termination Call-ID.  Termination Call-IDs are
    // IDs out of the VC lookup table range that are used to gracefully
    // terminate failed incoming calls.
    //
{
    do
    {
        ++pAdapter->usNextTerminationCallId;
    }
    while (pAdapter->usNextTerminationCallId < pAdapter->usMaxVcs + 1);

    return pAdapter->usNextTerminationCallId;
}


USHORT
GetNextTunnelId(
    IN ADAPTERCB* pAdapter )

    // Returns the next tunnel ID to be assigned.
    //
    // IMPORTANT: Caller must hold 'pAdapter->lockTunnels'.
{
    while (++pAdapter->usNextTunnelId == 0)
        ;

    return pAdapter->usNextTunnelId;
}


CHAR*
GetFullHostNameFromRegistry(
    VOID )

    // Returns a heap block containing an ASCII string of the form
    // "hostname.domain", or if no domain of the form "hostname".  Returns
    // NULL if none.  Caller must eventually call FREE_NONPAGED on the
    // returned string.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING uni;
    HANDLE hParams;
    CHAR* pszResult;
    WCHAR* pszFullHostName;
    KEY_VALUE_PARTIAL_INFORMATION* pHostNameValue;
    KEY_VALUE_PARTIAL_INFORMATION* pDomainValue;
    ULONG ulSize;

    TRACE( TL_I, TM_Cm, ( "GetFullHostNameFromRegistry" ) );

    hParams = NULL;
    pszFullHostName = NULL;
    pHostNameValue = NULL;
    pDomainValue = NULL;
    pszResult = NULL;

    #define GFHNFR_BufSize 512

    do
    {
        // Get a handle to the TCPIP Parameters registry key.
        //
        RtlInitUnicodeString(
            &uni,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters" );
        InitializeObjectAttributes(
            &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = ZwOpenKey(
            &hParams, KEY_QUERY_VALUE, &objattr );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "ZwOpenKey(ipp)=$%08x?", status ) );
            break;
        }

        // Query the "Hostname" registry value.
        //
        pHostNameValue = ALLOC_NONPAGED( GFHNFR_BufSize, MTAG_UTIL );
        if (!pHostNameValue)
        {
            break;
        }

        RtlInitUnicodeString( &uni, L"Hostname" );
        status = ZwQueryValueKey(
            hParams, &uni, KeyValuePartialInformation,
            pHostNameValue, GFHNFR_BufSize, &ulSize );
        if (status != STATUS_SUCCESS || pHostNameValue->Type != REG_SZ)
        {
            TRACE( TL_A, TM_Cm, ( "ZwQValueKey=$%08x?", status ) );
            break;
        }

        // Query the "Domain" registry value.
        //
        pDomainValue = ALLOC_NONPAGED( GFHNFR_BufSize, MTAG_UTIL );
        if (pDomainValue)
        {
            RtlInitUnicodeString( &uni, L"Domain" );
            status = ZwQueryValueKey(
                hParams, &uni, KeyValuePartialInformation,
                pDomainValue, GFHNFR_BufSize, &ulSize );
        }
        else
        {
            status = !STATUS_SUCCESS;
        }

        // Build a Unicode version of the combined "hostname.domain" or
        // "hostname".
        //
        pszFullHostName = ALLOC_NONPAGED( GFHNFR_BufSize * 2, MTAG_UTIL );
        if (!pszFullHostName)
        {
            break;
        }

        StrCpyW( pszFullHostName, (WCHAR* )pHostNameValue->Data );

        if (status == STATUS_SUCCESS
            && pDomainValue->Type == REG_SZ
            && pDomainValue->DataLength > sizeof(WCHAR)
            && ((WCHAR* )pDomainValue->Data)[ 0 ] != L'\0')
        {
            WCHAR* pch;

            pch = &pszFullHostName[ StrLenW( pszFullHostName ) ];
            *pch = L'.';
            ++pch;
            StrCpyW( pch, (WCHAR* )pDomainValue->Data );
        }

        // Convert the Unicode version to ASCII.
        //
        pszResult = StrDupUnicodeToAscii(
            pszFullHostName, StrLenW( pszFullHostName ) * sizeof(WCHAR) );
    }
    while (FALSE);

    if (hParams)
    {
        ZwClose( hParams );
    }

    if (pHostNameValue)
    {
        FREE_NONPAGED( pHostNameValue );
    }

    if (pDomainValue)
    {
        FREE_NONPAGED( pDomainValue );
    }

    if (pszFullHostName)
    {
        FREE_NONPAGED( pszFullHostName );
    }

    return pszResult;
}


ULONG
IpAddressFromDotted(
    IN CHAR* pchIpAddress )

    // Convert caller's a.b.c.d IP address string to the network byte-order
    // numeric equivalent.
    //
    // Returns the numeric IP address or 0 if formatted incorrectly.
    //
{
    INT i;
    LONG lResult;
    CHAR* pch;

    lResult = 0;
    pch = pchIpAddress;

    for (i = 1; i <= 4; ++i)
    {
        LONG lField;

        lField = atoul( pch );

        if (lField > 255)
            return 0;

        lResult = (lResult << 8) + lField;

        while (*pch >= '0' && *pch <= '9')
            ++pch;

        if (i < 4 && *pch != '.')
            return 0;

        ++pch;
    }

    return htonl( lResult );
}


VOID
IndicateLinkStatus(
    IN VCCB* pVc,
    IN LINKSTATUSINFO* pInfo )

    // Indicate new WAN_CO_LINKPARAMS settings for 'pVc' to NDISWAN.  Caller
    // should not be holding locks.
    //
{
    ASSERT( pInfo->params.SendWindow > 0 );

    TRACE( TL_I, TM_Mp, ( "NdisMCoIndStatus(LINK) bps=%d sw=%d",
        pInfo->params.TransmitSpeed, pInfo->params.SendWindow ) );
    NdisMCoIndicateStatus(
        pInfo->MiniportAdapterHandle,
        pInfo->NdisVcHandle,
        NDIS_STATUS_WAN_CO_LINKPARAMS,
        &pInfo->params,
        sizeof(pInfo->params) );
    TRACE( TL_N, TM_Mp, ( "NdisMCoIndStatus done" ) );
}


#if DBG
CHAR*
MsgTypePszFromUs(
    IN USHORT usMsgType )

    // Debug utility to convert message type attribute code 'usMsgType' to a
    // corresponding display string.
    //
{
    static CHAR szBuf[ 5 + 1 ];
    static CHAR* aszMsgType[ 16 ] =
    {
        "SCCRQ",
        "SCCRP",
        "SCCCN",
        "StopCCN",
        "StopCCRP???",
        "Hello",
        "OCRQ",
        "OCRP",
        "OCCN",
        "ICRQ",
        "ICRP",
        "ICCN",
        "CCR???",
        "CDN",
        "WEN",
        "SLI"
    };

    if (usMsgType >= 1 && usMsgType <= 16)
    {
        return aszMsgType[ usMsgType - 1 ];
    }
    else
    {
        ultoa( (ULONG )usMsgType, szBuf );
        return szBuf;
    }
}
#endif


#ifndef READFLAGSDIRECT
ULONG
ReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return InterlockedExchangeAdd( pulFlags, 0 );
}
#endif


VOID
ScheduleTunnelWork(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN PTUNNELWORK pHandler,
    IN ULONG_PTR unpArg0,
    IN ULONG_PTR unpArg1,
    IN ULONG_PTR unpArg2,
    IN ULONG_PTR unpArg3,
    IN BOOLEAN fTcbPreReferenced,
    IN BOOLEAN fHighPriority )

    // Schedules caller's 'pHandler' to be executed in an APC serially with
    // other work scheduled via this routine.  'PTunnel' is the tunnel to
    // which the work is related.  'UnpArgX' are the context arguments passed
    // to caller's 'pHandler'.  'FPreRefenced' indicates caller has already
    // made the tunnel reference associated with a scheduled work item.  This
    // is a convenience if he already holds 'ADAPTERCB.lockTunnels'.
    // 'FHighPriority' causes the item to be queued at the head rather than
    // the tail of the list.
    //
{
    ADAPTERCB* pAdapter;
    TUNNELWORK* pWork;

    pAdapter = pTunnel->pAdapter;

    if (!fTcbPreReferenced)
    {
        // Each queued work item holds a tunnel reference.
        //
        ReferenceTunnel( pTunnel, FALSE );
    }

    pWork = ALLOC_TUNNELWORK( pAdapter );
    if (!pWork)
    {
        // Can't get memory to schedule an APC so there's no
        // way we'll ever get things cleaned up.
        //
        ASSERT( !"Alloc TWork?" );
        ++g_ulAllocTwFailures;
        if (!fTcbPreReferenced)
        {
            DereferenceTunnel( pTunnel );
        }
        return;
    }

    if (pVc)
    {
        // Each queued work item that refers to a VC holds a VC reference.
        //
        ReferenceVc( pVc );
    }

    pWork->pHandler = pHandler;
    pWork->pVc = pVc;
    pWork->aunpArgs[ 0 ] = unpArg0;
    pWork->aunpArgs[ 1 ] = unpArg1;
    pWork->aunpArgs[ 2 ] = unpArg2;
    pWork->aunpArgs[ 3 ] = unpArg3;

    NdisAcquireSpinLock( &pTunnel->lockWork );
    {
        if (fHighPriority)
        {
            InsertHeadList( &pTunnel->listWork, &pWork->linkWork );
            TRACE( TL_N, TM_TWrk, ( "Q-TunnelWork($%08x,HIGH)", pHandler ) );
        }
        else
        {
            InsertTailList( &pTunnel->listWork, &pWork->linkWork );
            TRACE( TL_N, TM_TWrk, ( "Q-TunnelWork($%08x)", pHandler ) );
        }

        // Kickstart the tunnel worker if it's not running already.
        //
        if (!(ReadFlags( &pTunnel->ulFlags ) & TCBF_InWork ))
        {
            SetFlags( &pTunnel->ulFlags, TCBF_InWork );
            TRACE( TL_N, TM_TWrk, ( "Schedule TunnelWork" ) );
            ScheduleWork( pAdapter, TunnelWork, pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockWork );
}


NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext )

    // Schedules a PASSIVE IRQL callback to routine 'pProc' which will be
    // passed 'pContext'.  'PAdapter' is the adapter control block from which
    // the work item is allocated.  This routine takes an adapter reference
    // that should be removed by the called 'pProc'.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    pWork = ALLOC_NDIS_WORK_ITEM( pAdapter );
    if (!pWork)
    {
        ASSERT( !"Alloc work?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisInitializeWorkItem( pWork, pProc, pContext );

    ReferenceAdapter( pAdapter );
    status = NdisScheduleWorkItem( pWork );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"SchedWork?" );
        FREE_NDIS_WORK_ITEM( pAdapter, pWork );
        DereferenceAdapter( pAdapter );
    }

    return status;
}


VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = InterlockedExchangeAdd( pulFlags, 0 );
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}


VOID
StrCpyW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 )

    // Copies 'psz2' to 'psz1'.
    //
{
    while (*psz2)
    {
        *psz1++ = *psz2++;
    }

    *psz1 = L'\0';
}


CHAR*
StrDup(
    IN CHAR* psz )

    // Return a duplicate of 'psz'.  Caller must eventually call FREE_NONPAGED
    // on the returned string.
    //
{
    return StrDupSized( psz, strlen( psz ), 0 );
}


WCHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated Unicode copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    WCHAR* pszDup;

    pszDup = ALLOC_NONPAGED( pNdisString->Length + sizeof(WCHAR), MTAG_UTIL );
    if (pszDup)
    {
        NdisZeroMemory( pszDup, pNdisString->Length + sizeof(WCHAR) );
        if (pNdisString->Length)
        {
            NdisMoveMemory( pszDup, pNdisString->Buffer, pNdisString->Length );
        }
    }

    return pszDup;
}


CHAR*
StrDupNdisStringToA(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated ASCII copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    return StrDupUnicodeToAscii( pNdisString->Buffer, pNdisString->Length );
}


#if 0
CHAR*
StrDupNdisVarDataDescStringA(
    IN NDIS_VAR_DATA_DESC* pDesc )

    // Returns null-terminated copy of the NDIS_VAR_DATA_DESC ANSI/ASCII
    // string 'pDesc'.  Caller must eventually call FREE_NON-PAGED on the
    // returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( pDesc->Length + 1, MTAG_UTIL );
    if (pszDup)
    {
        NdisZeroMemory( pszDup, pDesc->Length + 1 );
        if (pDesc->Length)
        {
            NdisMoveMemory(
                pszDup, ((CHAR* )pDesc) + pDesc->Offset, pDesc->Length );
        }
    }

    return pszDup;
}
#endif


CHAR*
StrDupNdisVarDataDescStringToA(
    IN NDIS_VAR_DATA_DESC UNALIGNED* pDesc )

    // Returns null-terminated ASCII copy of the NDIS_VAR_DATA_DESC string
    // 'pDesc'.  Caller must eventually call FREE_NON-PAGED on the returned
    // string.
    //
{
    return StrDupUnicodeToAscii(
        (WCHAR* )(((CHAR* )pDesc) + pDesc->Offset), pDesc->Length );
}


CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra )

    // Return a duplicate of the first 'ulLength' bytes of 'psz' followed by a
    // null character and 'ulExtra' extra bytes, or NULL on error.  Caller
    // must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( ulLength + 1 + ulExtra, MTAG_UTIL );
    if (pszDup)
    {
        if (ulLength)
        {
            NdisMoveMemory( pszDup, psz, ulLength );
        }
        pszDup[ ulLength ] = '\0';
    }

    return pszDup;
}


CHAR*
StrDupUnicodeToAscii(
    IN WCHAR* pwsz,
    IN ULONG ulPwszBytes )

    // Returns an ASCII duplicate of Unicode string 'pwsz', where 'pwsz' is
    // 'ulPwszBytes' in length and not necessarily null terminated.  A null
    // terminator is added to the ASCII result.  The "conversion" consists of
    // picking out every other byte, hopefully all the non-zero ones.  This is
    // not foolproof, but then Unicode doesn't convert to ASCII in any
    // foolproof way.  It is caller's responsibility to FREE_NONPAGED the
    // returned string, if non-NULL.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( ulPwszBytes + 1, MTAG_UTIL );
    if (pszDup)
    {
        *((WCHAR* )pszDup) = L'\0';

        if (ulPwszBytes)
        {
            NdisMoveMemory( pszDup, pwsz, ulPwszBytes );
        }

        if (ulPwszBytes > 1 && pszDup[ 1 ] == '\0')
        {
            ULONG i;

            for (i = 0; i * 2 < ulPwszBytes; ++i)
            {
                pszDup[ i ] = pszDup[ i * 2 ];
            }

            pszDup[ i ] = '\0';
        }
    }

    return pszDup;
}


WCHAR*
StrDupAsciiToUnicode(
    IN CHAR* psz,
    IN ULONG ulPszBytes )

    // Returns a Unicode duplicate of ASCII string 'psz', where 'psz' is
    // 'ulPszBytes' in length and not necessarily null terminated.  A null
    // terminator is added to the Unicode result.  The "conversion" consists
    // of adding zero characters every other byte.  This is not foolproof, but
    // is OK for numericals like IP address strings, avoiding the change to
    // PASSIVE IRQL required to use the real RTL conversions.  It is caller's
    // responsibility to FREE_NONPAGED the returned string, if non-NULL.
    //
{
    WCHAR* pszDup;

    pszDup = (WCHAR* )ALLOC_NONPAGED(
        (ulPszBytes + 1) * sizeof(WCHAR), MTAG_UTIL );
    if (pszDup)
    {
        CHAR* pszDupA;
        ULONG i;

        pszDupA = (CHAR* )pszDup;
        for (i = 0; i < ulPszBytes; ++i)
        {
            pszDup[ i ] = (WCHAR )(psz[ i ]);
        }

        pszDup[ i ] = L'\0';
    }

    return pszDup;
}


ULONG
StrLenW(
    IN WCHAR* psz )

    // Return the length in characters of null terminated wide string 'psz'.
    //
{
    ULONG ulLen;

    ulLen = 0;

    if (psz)
    {
        while (*psz++ != L'\0')
        {
            ++ulLen;
        }
    }

    return ulLen;
}


TUNNELCB*
TunnelCbFromIpAddressAndAssignedTunnelId(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usAssignedTunnelId )

    // Return the tunnel control block associated with 'ulIpAddress' in
    // 'pAdapter's list of TUNNELCBs or NULL if not found.  If
    // 'usAssignedTunnelId' is non-zero, that must match as well, otherwise it
    // is ignored.  Tunnels in the process of closing are not returned.
    //
    // IMPORTANT:  Caller must hold 'pAdapter->lockTunnels'.
    //
{
    TUNNELCB* pTunnel;
    LIST_ENTRY* pLink;

    pTunnel = NULL;

    for (pLink = pAdapter->listTunnels.Flink;
         pLink != &pAdapter->listTunnels;
         pLink = pLink->Flink)
    {
        TUNNELCB* pThis;

        pThis = CONTAINING_RECORD( pLink, TUNNELCB, linkTunnels );
        if (pThis->address.ulIpAddress == ulIpAddress
            && (!usAssignedTunnelId
                || usAssignedTunnelId == pThis->usAssignedTunnelId))
        {
            BOOLEAN fClosing;

            fClosing = !!(ReadFlags( &pThis->ulFlags ) & TCBF_Closing);
            if (fClosing)
            {
                TRACE( TL_A, TM_Misc, ( "Closing pT=$%p skipped", pThis ) );
            }
            else
            {
                pTunnel = pThis;
                break;
            }
        }
    }

    return pTunnel;
}


VOID
TransferLinkStatusInfo(
    IN VCCB* pVc,
    OUT LINKSTATUSINFO* pInfo )

    // Transfer information from 'pVc' to callers 'pInfo' block in preparation
    // for a call to IndicateLinkStatus after 'lockV' has been released.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    pInfo->MiniportAdapterHandle = pAdapter->MiniportAdapterHandle;
    pInfo->NdisVcHandle = pVc->NdisVcHandle;

    //
    // Convert to bytes per second
    //
    pInfo->params.TransmitSpeed = pVc->ulConnectBps/8;
    pInfo->params.ReceiveSpeed = pInfo->params.TransmitSpeed/8;

    pInfo->params.SendWindow =
        min( pVc->ulSendWindow, pAdapter->info.MaxSendWindow );
}


VOID
TunnelWork(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to execute work from a tunnel work queue.  The
    // context passed is the TUNNELCB, which has been referenced for this
    // operation.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    LIST_ENTRY* pLink;
    LONG lDerefTunnels;

    // Unpack context information then free the work item.
    //
    pTunnel = (TUNNELCB* )pContext;
    pAdapter = pTunnel->pAdapter;
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Execute all work queued on the tunnel serially.
    //
    lDerefTunnels = 0;
    NdisAcquireSpinLock( &pTunnel->lockWork );
    {
        ASSERT( ReadFlags( &pTunnel->ulFlags ) & TCBF_InWork );

        while (!IsListEmpty( &pTunnel->listWork ))
        {
            TUNNELWORK* pWork;

            pLink = RemoveHeadList( &pTunnel->listWork );
            InitializeListHead( pLink );
            pWork = CONTAINING_RECORD( pLink, TUNNELWORK, linkWork );

            TRACE( TL_N, TM_TWrk,
                ( "\nL2TP: TUNNELWORK=$%08x", pWork->pHandler ) );

            NdisReleaseSpinLock( &pTunnel->lockWork );
            {
                VCCB* pVc;

                pVc = pWork->pVc;
                pWork->pHandler( pWork, pTunnel, pVc, pWork->aunpArgs );

                if (pVc)
                {
                    DereferenceVc( pVc );
                }

                ++lDerefTunnels;
            }
            NdisAcquireSpinLock( &pTunnel->lockWork );
        }

        ClearFlags( &pTunnel->ulFlags, TCBF_InWork );
    }
    NdisReleaseSpinLock( &pTunnel->lockWork );

    while (lDerefTunnels--)
    {
        DereferenceTunnel( pTunnel );
    }

    // Remove the reference for scheduled work.
    //
    DereferenceAdapter( pAdapter );
}


VOID
UpdateGlobalCallStats(
    IN VCCB* pVc )

    // Add the call statistics in 'pVc' to the global call statistics.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    extern CALLSTATS g_stats;
    extern NDIS_SPIN_LOCK g_lockStats;
    CALLSTATS* pStats;

    pStats = &pVc->stats;

    if (pStats->ulSeconds == 0)
    {
        return;
    }

    NdisAcquireSpinLock( &g_lockStats );
    {
        ++g_stats.llCallUp;
        g_stats.ulSeconds += pStats->ulSeconds;
        g_stats.ulDataBytesRecd += pStats->ulDataBytesRecd;
        g_stats.ulDataBytesSent += pStats->ulDataBytesSent;
        g_stats.ulRecdDataPackets += pStats->ulRecdDataPackets;
        g_stats.ulDataPacketsDequeued += pStats->ulDataPacketsDequeued;
        g_stats.ulRecdZlbs += pStats->ulRecdZlbs;
        g_stats.ulRecdResets += pStats->ulRecdResets;
        g_stats.ulRecdResetsIgnored += pStats->ulRecdResetsIgnored;
        g_stats.ulSentDataPacketsSeq += pStats->ulSentDataPacketsSeq;
        g_stats.ulSentDataPacketsUnSeq += pStats->ulSentDataPacketsUnSeq;
        g_stats.ulSentPacketsAcked += pStats->ulSentPacketsAcked;
        g_stats.ulSentPacketsTimedOut += pStats->ulSentPacketsTimedOut;
        g_stats.ulSentZAcks += pStats->ulSentZAcks;
        g_stats.ulSentResets += pStats->ulSentResets;
        g_stats.ulSendWindowChanges += pStats->ulSendWindowChanges;
        g_stats.ulSendWindowTotal += pStats->ulSendWindowTotal;
        g_stats.ulMaxSendWindow += pStats->ulMaxSendWindow;
        g_stats.ulMinSendWindow += pStats->ulMinSendWindow;
        g_stats.ulRoundTrips += pStats->ulRoundTrips;
        g_stats.ulRoundTripMsTotal += pStats->ulRoundTripMsTotal;
        g_stats.ulMaxRoundTripMs += pStats->ulMaxRoundTripMs;
        g_stats.ulMinRoundTripMs += pStats->ulMinRoundTripMs;
    }
    NdisReleaseSpinLock( &g_lockStats );

    TRACE( TL_I, TM_Stat,
        ( ".--- CALL STATISTICS -------------------------" ) );
    TRACE( TL_I, TM_Stat,
        ( "| Duration:    %d minutes, %d seconds",
            pStats->ulSeconds / 60,
            pStats->ulSeconds % 60 ) );
    TRACE( TL_I, TM_Stat,
        ( "| Data out:    %d bytes, %d/sec, %d/pkt",
            pStats->ulDataBytesSent,
            AVGTRACE(
                pStats->ulDataBytesSent,
                pStats->ulSeconds ),
            AVGTRACE(
                pStats->ulDataBytesSent,
                pStats->ulRecdDataPackets ) ) );
    TRACE( TL_I, TM_Stat,
        ( "| Data in:     %d bytes, %d/sec, %d/pkt",
            pStats->ulDataBytesRecd,
            AVGTRACE( pStats->ulDataBytesRecd, pStats->ulSeconds ),
            AVGTRACE(
                pStats->ulDataBytesRecd,
                pStats->ulSentDataPacketsSeq
                    + pStats->ulSentDataPacketsUnSeq ) ) );
    TRACE( TL_I, TM_Stat,
        ( "| Acks in:     %d/%d (%d%%) %d flushed",
            pStats->ulSentPacketsAcked,
            pStats->ulSentDataPacketsSeq,
            PCTTRACE(
                pStats->ulSentPacketsAcked,
                pStats->ulSentPacketsAcked
                    + pStats->ulSentPacketsTimedOut ),
                pStats->ulSentDataPacketsSeq
                    + pStats->ulSentDataPacketsUnSeq
                    - pStats->ulSentPacketsAcked
                    - pStats->ulSentPacketsTimedOut ) );
    TRACE( TL_I, TM_Stat,
        ( "| Misordered:  %d (%d%%)",
            pStats->ulDataPacketsDequeued,
            PCTTRACE(
                pStats->ulDataPacketsDequeued,
                pStats->ulRecdDataPackets ) ) );
    TRACE( TL_I, TM_Stat,
        ( "| Out:         Resets=%d ZAcks=%d UnSeqs=%d",
            pStats->ulSentResets,
            pStats->ulSentZAcks,
            pStats->ulSentDataPacketsUnSeq ) );
    TRACE( TL_I, TM_Stat,
        ( "| In:          Resets=%d (%d%% old) Zlbs=%d",
            pStats->ulRecdResets,
            PCTTRACE(
                pStats->ulRecdResetsIgnored,
                pStats->ulRecdResets ),
            pStats->ulRecdZlbs ) );
    TRACE( TL_I, TM_Stat,
        ( "| Send window: Min=%d Avg=%d Max=%d Changes=%d",
            pStats->ulMinSendWindow,
            AVGTRACE(
                pStats->ulSendWindowTotal,
                pStats->ulSentDataPacketsSeq ),
            pStats->ulMaxSendWindow,
            pStats->ulSendWindowChanges ) );
    TRACE( TL_I, TM_Stat,
        ( "| Trip in ms:  Min=%d Avg=%d Max=%d",
            pStats->ulMinRoundTripMs,
            AVGTRACE(
                pStats->ulRoundTripMsTotal,
                pStats->ulRoundTrips ),
            pStats->ulMaxRoundTripMs ) );
    TRACE( TL_I, TM_Stat,
        ( "'---------------------------------------------" ) );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber )

    // Convert string of digits 'pszNumber' to it's ULONG value.
    //
{
    ULONG ulResult;

    ulResult = 0;
    while (*pszNumber && *pszNumber >= '0' && *pszNumber <= '9')
    {
        ulResult *= 10;
        ulResult += *pszNumber - '0';
        ++pszNumber;
    }

    return ulResult;
}


VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft = *pchRight;
        *pchRight = ch;

        ++pchLeft;
        --pchRight;
    }
}


VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.  It's
    // caller job to make sure 'pszBuf' is long enough to hold the returned
    // string.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);

    *pch = '\0';
    ReversePsz( pszBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\tdix.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// tdix.h
// RAS L2TP WAN mini-port/call-manager driver
// TDI extensions header
//
// 01/07/97 Steve Cobb


#ifndef _TDIX_H_
#define _TDIX_H_


//-----------------------------------------------------------------------------
// Datatypes
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _TDIXCONTEXT TDIXCONTEXT;
typedef struct _TDIXROUTE TDIXROUTE;
typedef enum _HOSTROUTEEXISTS HOSTROUTEEXISTS;

// 'UDP' and 'RawIp' media type address descriptor.
//
typedef struct
_TDIXIPADDRESS
{
    // IP address in network byte order.
    //
    ULONG ulIpAddress;

    // UDP port in network byte order.  Always 0 for 'RawIp' media.
    //
    SHORT sUdpPort;

    // interface index
    uint ifindex; 

}
TDIXIPADDRESS;


// Read datagram information context used to pass context information from the
// ReadDatagram event handler to the RECEIVE_DATAGRAM completion routine.
//
typedef struct
_TDIXRDGINFO
{
    // The associated TDIX context;
    //
    TDIXCONTEXT* pTdix;

    // The source IP address of the received datagram in network byte order.
    //
    TDIXIPADDRESS source;

    // The buffer, allocated from caller's buffer pool, containing the
    // datagram information.
    //
    CHAR* pBuffer;

    // The length of the information copied to caller's buffer.
    //
    ULONG ulBufferLen;

    TDIXIPADDRESS dest;
}
TDIXRDGINFO;

// TDIX client's send-complete handler prototype.  'PTdix' is the TDI
// extension context.  'PContext1' and 'pContext2' are the contexts passed to
// TdixSenddagram.  'PBuffer' is the buffer passed to TdiSendDatagram.
//
typedef
VOID
(*PTDIXSENDCOMPLETE)(
    IN TDIXCONTEXT* pTdix,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN CHAR* pBuffer );


// Send datagram information context used to pass context information from
// TdixSendDatagram to the send datagram completion handler.
//
typedef struct
_TDIXSDGINFO
{
    // The associated TDIX context;
    //
    TDIXCONTEXT* pTdix;

    // The buffer passed by caller to TdixSendDatagram.
    //
    CHAR* pBuffer;

    // Caller's send-complete handler.
    //
    PTDIXSENDCOMPLETE pSendCompleteHandler;

    // Caller's contexts to be returned to his send-complete handler.
    //
    VOID* pContext1;
    VOID* pContext2;

    // TDI request information.
    //
    TDI_CONNECTION_INFORMATION tdiconninfo;
    TA_IP_ADDRESS taip;
}
TDIXSDGINFO;


#define ALLOC_TDIXRDGINFO( pTdix ) \
    NdisAllocateFromNPagedLookasideList( &(pTdix)->llistRdg )
#define FREE_TDIXRDGINFO( pTdix, pRdg ) \
    NdisFreeToNPagedLookasideList( &(pTdix)->llistRdg, (pRdg) )

#define ALLOC_TDIXSDGINFO( pTdix ) \
    NdisAllocateFromNPagedLookasideList( &(pTdix)->llistSdg )
#define FREE_TDIXSDGINFO( pTdix, pSdg ) \
    NdisFreeToNPagedLookasideList( &(pTdix)->llistSdg, (pSdg) )

#define ALLOC_TDIXROUTE( pTdix ) \
    ALLOC_NONPAGED( sizeof(TDIXROUTE), MTAG_TDIXROUTE )
#define FREE_TDIXROUTE( pTdix, pR ) \
    FREE_NONPAGED( pR )
    

// TDIX client's receive handler prototype.  'PTdix' is the TDI extension
// context.  'PAddress' is the source address of the received datagram, which
// for IP is a network byte-order IP address.  'PBuffer' is the receive buffer
// of 'ulBytesLength' bytes where the first "real" data is at offset
// 'ulOffset'.  It is caller's responsibility to call FreeBufferToPool with
// the same pool passed to TdixInitialize.
//
typedef
VOID
(*PTDIXRECEIVE)(
    IN TDIXCONTEXT* pTdix,
    IN TDIXRDGINFO* pRdg,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLength );

//
//
typedef
NDIS_STATUS
(*PTDIX_SEND_HANDLER)(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* FileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp );

// The TDI media types that L2TP can run on.  The values are read from the
// registry, so don't change randomly.
//
typedef enum
_TDIXMEDIATYPE
{
    TMT_RawIp = 1,
    TMT_Udp = 2
}
TDIXMEDIATYPE;



// Context of a TDI extension session.  Code outside the TdixXxx routines
// should avoid referring to fields in this structure.
//
typedef struct
_TDIXCONTEXT
{
    // Reference count on this TDI session.  The reference pairs are:
    //
    // (a) TdixOpen adds a reference that TdixClose removes.
    //
    // (b) TdixAddHostRoute adds a reference when it links a new route into
    //     the TDIXCONTEXT.listRoutes and TdixDeleteHostRoute removes it.
    //
    // The field is accessed only by the ReferenceTdix and DereferenceTdix
    // routines which protect access via 'lock'.
    //
    LONG lRef;

    // Handle of the transport address object returned from ZwCreateFile, and
    // the object address of same.
    //
    HANDLE hAddress;
    FILE_OBJECT* pAddress;

    // The media type in use on this context.
    //
    TDIXMEDIATYPE mediatype;

    // Handle of the IP stack address object returned from ZwCreateFile, and
    // the object address of same.  The IP stack address is needed to use the
    // referenced route IOCTLs supported in IP, but not in UDP, i.e. IP route
    // management calls are used in both UDP and raw IP modes.
    //
    HANDLE hIpStackAddress;
    FILE_OBJECT* pIpStackAddress;

    // TDIXF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines only.
    //
    // TDIXF_Pending: Set when an open or close operation is pending, clear
    //     otherwise.  Access is protected by 'lock'.
    //
    // TDIXF_DisableUdpXsums: Set when UDP checksums should be disabled.
    //
    ULONG ulFlags;
        #define TDIXF_Pending         0x00000001
        #define TDIXF_DisableUdpXsums 0x00000002

    // The strategy employed when it is time to add a host route and that
    // route is found to already exists.
    //
    HOSTROUTEEXISTS hre;

    // The NDIS buffer pool from which buffers for received datagrams are
    // allocated.
    //
    BUFFERPOOL* pPoolNdisBuffers;

    // Client's receive handler called when packets are received.
    //
    PTDIXRECEIVE pReceiveHandler;

    // Double-linked list of TDIXROUTEs.  Access is protected by 'lock'.
    //
    LIST_ENTRY listRoutes;

    // Lookaside list of TDIXRDGINFO blocks, used to pass context information
    // from the ReadDatagram event handler to the RECEIVE_DATAGRAM completion
    // routine.
    //
    NPAGED_LOOKASIDE_LIST llistRdg;

    // Lookaside list of TDIXSDGINFO blocks, used to pass context information
    // from TdixSendDatagram to the SEND_DATAGRAM completion routine.
    //
    NPAGED_LOOKASIDE_LIST llistSdg;

    // Spinlock protecting access to TDIXCONTENT fields as noted in the field
    // descriptions.
    //
    NDIS_SPIN_LOCK lock;
}
TDIXCONTEXT;


typedef struct
_TDIXUDPCONNECTCONTEXT
{
    // Set if we are using different address objects for 
    // control and payload packets.
    //
    BOOLEAN fUsePayloadAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp control messages on this route.
    //
    HANDLE hCtrlAddr;
    FILE_OBJECT* pCtrlAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp payloads on this route.
    //
    HANDLE hPayloadAddr;
    FILE_OBJECT* pPayloadAddr;
}
TDIXUDPCONNECTCONTEXT;


// Context information for a single host route.  The contexts are linked into
// the TDIXCONTEXT's list of host routes.  Access to all fields is protected
// by 'TDIXCONTEXT.lockHostRoutes'.
//
typedef struct
_TDIXROUTE
{
    // Double-linked link of 'TDIXCONTEXT.listRoutes'.  The block is linked
    // whenever there is an L2TP host route context for a given route.
    //
    LIST_ENTRY linkRoutes;


    // Host IP address of the route in network byte order.
    //
    ULONG ulIpAddress;

    // Host port in network byte order.
    //
    SHORT sPort;

    // Interface index of added route.
    //
    ULONG InterfaceIndex;

    // Number of references on the route.  A block may be linked with the
    // reference count at zero during deletion but never without the pending
    // flag set.
    //
    LONG lRef;

    // Set when an add or delete of this route is pending.  References should
    // not be taken when either operation is pending.
    //
    BOOLEAN fPending;

    // Set if the route was not actually added because it already exists, i.e.
    // we are in HRE_Use mode and someone besides L2TP added it.
    //
    BOOLEAN fUsedNonL2tpRoute;

    // Set if we are using different address objects for 
    // control and payload packets.
    //
    BOOLEAN fUsePayloadAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp control messages on this route.
    //
    HANDLE hCtrlAddr;
    FILE_OBJECT* pCtrlAddr;

    // Handle and address of the transport address object returned from 
    // ZwCreateFile for sending l2tp payloads on this route.
    //
    HANDLE hPayloadAddr;
    FILE_OBJECT* pPayloadAddr;
}
TDIXROUTE;

//-----------------------------------------------------------------------------
// Interface prototypes
//-----------------------------------------------------------------------------

VOID
TdixInitialize(
    IN TDIXMEDIATYPE mediatype,
    IN HOSTROUTEEXISTS hre,
    IN ULONG ulFlags,
    IN PTDIXRECEIVE pReceiveHandler,
    IN BUFFERPOOL* pPoolNdisBuffers,
    IN OUT TDIXCONTEXT* pTdix );

NDIS_STATUS
TdixOpen(
    OUT TDIXCONTEXT* pTdix );

VOID
TdixClose(
    IN TDIXCONTEXT* pTdix );

VOID
TdixReference(
    IN TDIXCONTEXT* pTdix );

NDIS_STATUS
TdixSend(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* pFileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp ) ;

NDIS_STATUS
TdixSendDatagram(
    IN TDIXCONTEXT* pTdix,
    IN FILE_OBJECT* pFileObj,
    IN PTDIXSENDCOMPLETE pSendCompleteHandler,
    IN VOID* pContext1,
    IN VOID* pContext2,
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulBufferLength,
    OUT IRP** ppIrp );

VOID
TdixDestroyConnection(
    TDIXUDPCONNECTCONTEXT *pUdpContext);
    

NDIS_STATUS
TdixSetupConnection(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    IN SHORT sPort,
    IN TDIXROUTE *pTdixRoute,
    IN TDIXUDPCONNECTCONTEXT* pUdpContext);
    

VOID*
TdixAddHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    IN SHORT sPort);

VOID
TdixDeleteHostRoute(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress);

NTSTATUS 
TdixGetInterfaceInfo(
    IN TDIXCONTEXT* pTdix,
    IN ULONG ulIpAddress,
    OUT PULONG pulSpeed);

#endif // _TDIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\timer.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.c
// RAS L2TP WAN mini-port/call-manager driver
// Timer management routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event );

VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime );

VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ )

    // Initializes caller's timer queue context 'pTimerQ'.
    //
{
    TRACE( TL_N, TM_Time, ( "TqInit" ) );

    InitializeListHead( &pTimerQ->listItems );
    NdisAllocateSpinLock( &pTimerQ->lock );
    NdisInitializeTimer( &pTimerQ->timer, TimerEvent, pTimerQ );
    pTimerQ->pHandler = NULL;
    pTimerQ->fTerminating = FALSE;
    pTimerQ->ulTag = MTAG_TIMERQ;
}


VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem )

    // Initializes caller's timer queue item, 'pItem'.  This should be called
    // before passing 'pItem' to any other TimerQ routine.
    //
{
    InitializeListHead( &pItem->linkItems );
}


VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext )

    // Terminates timer queue 'pTimerQ'.  Each scheduled item is called back
    // with TE_Terminate.  Caller's 'pHandler' is called with 'pTimerQ' and
    // 'pContext' so the 'pTimerQ' can be freed, if necessary.  Caller's
    // 'pTimerQ' must remain accessible until the 'pHandler' callback occurs,
    // which might be after this routine returns.
    //
{
    BOOLEAN fCancelled;
    LIST_ENTRY list;
    LIST_ENTRY* pLink;

    TRACE( TL_N, TM_Time, ( "TqTerm" ) );

    InitializeListHead( &list );

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pTimerQ->fTerminating = TRUE;

        // Stop the timer.
        //
        NdisCancelTimer( &pTimerQ->timer, &fCancelled );
        TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

        if (!fCancelled && !IsListEmpty( &pTimerQ->listItems ))
        {
            // No event was cancelled but the list of events is not empty.
            // This means the timer has fired, but our internal handler has
            // not yet been called to process it, though it eventually will
            // be.  The internal handler must be the one to call the terminate
            // complete in this case, because there is no way for it to know
            // it cannot reference 'pTimerQ'.  Indicate this to the handler by
            // filling in the termination handler.
            //
            TRACE( TL_A, TM_Time, ( "Mid-expire Q" ) );
            pTimerQ->pHandler = pHandler;
            pTimerQ->pContext = pContext;
            pHandler = NULL;
        }

        // Move the scheduled events to a temporary list, marking them all
        // "not on queue" so any attempt by user to cancel the item will be
        // ignored.
        //
        while (!IsListEmpty( &pTimerQ->listItems ))
        {
            pLink = RemoveHeadList( &pTimerQ->listItems );
            InsertTailList( &list, pLink );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    // Must be careful here.  If 'pHandler' was set NULL above, 'pTimerQ' must
    // not be referenced in the rest of this routine.
    //
    // Call user's "terminate" event handler for each removed item.
    //
    while (!IsListEmpty( &list ))
    {
        TIMERQITEM* pItem;

        pLink = RemoveHeadList( &list );
        InitializeListHead( pLink );
        pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
        TRACE( TL_I, TM_Time,
            ( "Flush TQI=$%p, handler=$%p", pItem, pItem->pHandler ) );
        pItem->pHandler( pItem, pItem->pContext, TE_Terminate );
    }

    // Call user's "terminate complete" handler, if it's still our job.
    //
    if (pHandler)
    {
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pContext );
    }
}


VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext )

    // Schedule new timer event 'pNewItem' on timer queue 'pTimerQ'.  When the
    // event occurs in 'ulTimeoutMs' milliseconds, the 'pHandler' routine is
    // called with arguments 'pNewItem', 'pContext', and TE_Expired.  If the
    // item is cancelled or the queue terminated 'pHandler' is called as above
    // but with TE_Cancel or TE_Terminate as appropriate.
    //
{
    TRACE( TL_N, TM_Time, ( "TqSchedItem(ms=%d)", ulTimeoutMs ) );

    pNewItem->pHandler = pHandler;
    pNewItem->pContext = pContext;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        LIST_ENTRY* pLink;
        LARGE_INTEGER lrgTime;

        ASSERT( pNewItem->linkItems.Flink == &pNewItem->linkItems );

        // The system time at which the timeout will occur is stored.
        //
        NdisGetCurrentSystemTime( &lrgTime );
        pNewItem->llExpireTime =
            lrgTime.QuadPart + (((LONGLONG )ulTimeoutMs) * 10000);

        // Walk the list of timer items looking for the first item that will
        // expire before the new item.  Do it backwards so the likely case of
        // many timeouts with roughly the same interval is handled
        // efficiently.
        //
        for (pLink = pTimerQ->listItems.Blink;
             pLink != &pTimerQ->listItems;
             pLink = pLink->Blink )
        {
            TIMERQITEM* pItem;

            pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );

            if (pItem->llExpireTime < pNewItem->llExpireTime)
            {
                break;
            }
        }

        // Link the new item into the timer queue after the found item (or
        // after the head if none was found).
        //
        InsertAfter( &pNewItem->linkItems, pLink );

        if (pTimerQ->listItems.Flink == &pNewItem->linkItems)
        {
            // The new item expires before all other items so need to re-set
            // the NDIS timer.
            //
            SetTimer( pTimerQ, lrgTime.QuadPart );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );
}


BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Cancel', or nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was cancelled, false if it not, i.e. it was
    // not on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqCancelItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Cancel );
}


BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Expire', or do nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was expired, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqExpireItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Expire );
}


BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ', or do
    // nothing if 'pItem' is NULL.
    //
    // Returns true if the timer was terminated, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqTermItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Terminate );
}


#if DBG
CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event )

    // Debug utility to convert timer event coode 'event' to a corresponding
    // display string.
    //
{
    static CHAR* aszEvent[ 3 ] =
    {
        "expire",
        "cancel",
        "terminate"
    };

    return aszEvent[ (ULONG )event ];
}
#endif


//-----------------------------------------------------------------------------
// Timer utility routines (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'event'.  The 'TE_Expire' event handler
    // is not called directly, but rescheduled with a 0 timeout so it occurs
    // immediately, but at DPC when no locks are held just like the original
    // timer had fired..
    //
    // Returns true if the item was on the queue, false otherwise.
    //
{
    BOOLEAN fFirst;
    LIST_ENTRY* pLink;

    if (!pItem)
    {
        TRACE( TL_N, TM_Time, ( "NULL pTqi" ) );
        return FALSE;
    }

    pLink = &pItem->linkItems;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        if (pItem->linkItems.Flink == &pItem->linkItems
            || pTimerQ->fTerminating)
        {
            // The item is not on the queue.  Another operation may have
            // already dequeued it, but may not yet have called user's
            // handler.
            //
            TRACE( TL_N, TM_Time, ( "Not scheduled" ) );
            NdisReleaseSpinLock( &pTimerQ->lock );
            return FALSE;
        }

        fFirst = (pLink == pTimerQ->listItems.Flink);
        if (fFirst)
        {
            BOOLEAN fCancelled;

            // Cancelling first item on list, so cancel the NDIS timer.
            //
            NdisCancelTimer( &pTimerQ->timer, &fCancelled );
            TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

            if (!fCancelled)
            {
                // Too late.  The item has expired already but has not yet
                // been removed from the list by the internal handler.
                //
                TRACE( TL_A, TM_Time, ( "Mid-expire e=%d $%p($%p)",
                    event, pItem->pHandler, pItem->pContext ) );
                NdisReleaseSpinLock( &pTimerQ->lock );
                return FALSE;
            }
        }

        // Un-schedule the event and mark the item descriptor "off queue", so
        // any later attempt to cancel will do nothing.
        //
        RemoveEntryList( pLink );
        InitializeListHead( pLink );

        if (fFirst)
        {
            // Re-set the NDIS timer to reflect the timeout of the new first
            // item, if any.
            //
            SetTimer( pTimerQ, 0 );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (event == TE_Expire)
    {
        TimerQScheduleItem(
            pTimerQ, pItem, 0, pItem->pHandler, pItem->pContext );
    }
    else
    {
        // Call user's event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, event );
    }

    return TRUE;
}


VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime )

    // Sets the NDIS timer to expire when the timeout of the first link, if
    // any, in the timer queue 'pTimerQ' occurs.  Any previously set timeout
    // is "overwritten".  'LlCurrentTime' is the current system time, if
    // known, or 0 if not.
    //
    // IMPORTANT: Caller must hold the TIMERQ lock.
    //
{
    LIST_ENTRY* pFirstLink;
    TIMERQITEM* pFirstItem;
    LONGLONG llTimeoutMs;
    ULONG ulTimeoutMs;

    if (IsListEmpty( &pTimerQ->listItems ))
    {
        return;
    }

    pFirstLink = pTimerQ->listItems.Flink;
    pFirstItem = CONTAINING_RECORD( pFirstLink, TIMERQITEM, linkItems );

    if (llCurrentTime == 0)
    {
        LARGE_INTEGER lrgTime;

        NdisGetCurrentSystemTime( &lrgTime );
        llCurrentTime = lrgTime.QuadPart;
    }

    llTimeoutMs = (pFirstItem->llExpireTime - llCurrentTime) / 10000;
    if (llTimeoutMs <= 0)
    {
        // The timeout interval is negative, i.e. it's already passed.  Set it
        // to zero so it is triggered immediately.
        //
        ulTimeoutMs = 0;
    }
    else
    {
        // The timeout interval is in the future.
        //
        ASSERT( ((LARGE_INTEGER* )&llTimeoutMs)->HighPart == 0 );
        ulTimeoutMs = ((LARGE_INTEGER* )&llTimeoutMs)->LowPart;
    }

    NdisSetTimer( &pTimerQ->timer, ulTimeoutMs );
    TRACE( TL_N, TM_Time, ( "NdisSetTimer(%dms)", ulTimeoutMs ) );
}


VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 )

    // NDIS_TIMER_FUNCTION called when a timer expires.
    //
{
    TIMERQ* pTimerQ;
    LIST_ENTRY* pLink;
    TIMERQITEM* pItem;
    PTIMERQTERMINATECOMPLETE pHandler;

    TRACE( TL_N, TM_Time, ( "TimerEvent" ) );

    pTimerQ = (TIMERQ* )FunctionContext;
    if (!pTimerQ || pTimerQ->ulTag != MTAG_TIMERQ)
    {
        // Should not happen.
        //
        TRACE( TL_A, TM_Time, ( "Not TIMERQ?" ) );
        return;
    }

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pHandler = pTimerQ->pHandler;
        if (!pHandler)
        {
            // The termination handler is not set, so proceed normally.
            // Remove the first event item, make it un-cancel-able, and re-set
            // the timer for the next event.
            //
            if (IsListEmpty( &pTimerQ->listItems ))
            {
                // Should not happen (but does sometimes on MP Alpha?).
                //
                TRACE( TL_A, TM_Time, ( "No item queued?" ) );
                pItem = NULL;
            }
            else
            {
                pLink = RemoveHeadList( &pTimerQ->listItems );
                InitializeListHead( pLink );
                pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
                SetTimer( pTimerQ, 0 );
            }
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (pHandler)
    {
        // The termination handler was set meaning the timer queue has been
        // terminated between this event firing and this handler being called.
        // That means we are the one who calls user's termination handler.
        // 'pTimerQ' must not be referenced after that call.
        //
        TRACE( TL_A, TM_Time, ( "Mid-event case handled" ) );
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pTimerQ->pContext );
        return;
    }

    if (pItem)
    {
        // Call user's "expire" event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, TE_Expire );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]\n"
        ,"  help      - Prints short help text on all commands.\n"
         "  help -v   - Prints long help text on all commands.\n"
         "  help cmd  - Prints long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   dso
        ,"dso <struct> [field] [address]\n"
        ,"  - Dumps struct offsets and values, e.g:\n"
         "      dso ADAPTERCB 806955b0\n"
        ,""
        ,CUSTOM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\l2tpext.c ===
#include "precomp.h"
#pragma hdrstop

PSTR pszExtName = "L2TP";

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\bpool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;
}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );

VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
\***************************************************************************/
#include <stdexts.h>

/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dosGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * try an exact match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
\***************************************************************************/
BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwOptions;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * NULL terminate first argument and get a pointer to
     *  second one (presumably the field name)
     */
    /*
     * Get the options, if any
     */
    if (*pszCmdLine == '-') {
       dwOptions = GetOpts(&pszCmdLine, NULL);
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dosGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        Print("Structure not found: %s\n", pszCmdLine);
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                Print("Field not found: %s. Struct: %s\n", pszField, pst->pszName);
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }

        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);
        Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);
        Print("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset);
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        Print("Address   Value\n");

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            Print("%08lx  ", (DWORD)((PBYTE)pAddress + dwOffset + dwBytesRead));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                Print("%08lx ", *((DWORD *)pBufferOffset));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                Print("%0*lx", dwMoveSize * 2, dwValue);
            }
            Print("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = 0;


    /*
     * Loop through all fields in the table. Print one field per loop
     */
    while (psot->pszField != NULL) {
        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == 2) {
            Print("\n");
            dwFieldsPerRow = 1;
        } else {
            dwFieldsPerRow++;
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            Print("%03lx  %-34.33s", dsoGetOffset(psot), psot->pszField);
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);
            Print("(%03lx) %08lx %-24.23s", dwOffset, dwValue, psot->pszField);
        } /* if (pAddress == NULL) */


        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    Print("\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\l2tpext.h ===
#include <l2tpp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"


// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoubleBufferFrees = 0;

// Debug  count of calls to NdisAllocateBuffer/NdisCopyBuffer/NdisFreeBuffer,
// where the total of Alloc and Copy should equal Free in idle state.
//
ULONG g_ulNdisAllocateBuffers = 0;
ULONG g_ulNdisCopyBuffers = 0;
ULONG g_ulNdisFreeBuffers = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    // The requested buffer size is padded, if necessary, so it alligns
    // properly when buffer blocks are layed out.  The alignment rule also
    // applies to the BUFFERBLOCKHEAD and BUFFERHEAD structures, which
    // currently align perfectly.  We will verify once here, rather than code
    // around everywhere else.
    //
    ASSERT( (ALIGN_UP( sizeof(BUFFERBLOCKHEAD), ULONGLONG )
        == sizeof(BUFFERBLOCKHEAD)) );
    ASSERT( (ALIGN_UP( sizeof(BUFFERHEAD), ULONGLONG )
        == sizeof(BUFFERHEAD)) );
    pPool->ulBufferSize = ALIGN_UP( ulBufferSize, ULONGLONG );

    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulBuffersPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitBp tag=$%08x buf=%d cnt=%d",
        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreeBp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    DBG_if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        TRACE( TL_N, TM_Pool, ( "GetBfp=$%p, %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers ) );
    }
    DBG_else
    {
        TRACE( TL_A, TM_Pool, ( "GetBfp failed?" ) );
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_I, TM_Pool, ( "FreeBtoP($%p) %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }

    // Requested by Chun Ye to catch IPSEC problem.
    //
    ASSERT( pHead->pNdisBuffer && !((MDL* )pHead->pNdisBuffer)->Next );

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreeBuffers.Flink != &pHead->linkFreeBuffers)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoubleBufferFrees;
            break;
        }

        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the
                // pool not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddBpBlock(%d+%d)",
        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Bp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                {
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
                }
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc BB?" ) );
                break;
            }

            // Zero only the block header portion.
            //
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocBp=$%x?", status ) );
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocB=$%x?", status ) );
                    ASSERT( FALSE );
                    pHead->pNdisBuffer = NULL;
                    continue;
                }
                else
                {
                    NdisInterlockedIncrement( &g_ulNdisAllocateBuffers );
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedBpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {
            ULONG i;
            BUFFERHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );
                InitializeListHead( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                    NdisInterlockedIncrement( &g_ulNdisFreeBuffers );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\precomp.h ===
#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>

#include <ndis.h>
#include <cxport.h>
#include <ip.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <ipfilter.h>
#include <tdistat.h>
#include <wanpub.h>

#define FIELDOFFSET(type, field)    ((UINT)&(((type *)0)->field))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\makefile.inc ===
l2tpext.c:  l2tpext.h

precomp.h:  l2tpext.h

l2tpext.pph:    l2tpext.h
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $(C_DEFINES) $** > $@

dsotable.c: l2tpext.pph l2tpext.txt dsocode.c
    @echo Creating $@
    structo -i h -p -s l2tpext.txt -o $@ l2tpext.pph

clean:
    del dsotable.c l2tpext.pph
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\fsm.h ===
#ifndef _FSM_H_
#define _FSM_H_

VOID
FsmMakeCall(
	IN CALL* pCall
	);

VOID
FsmReceiveCall(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pPacket
	);

NDIS_STATUS
FsmAnswerCall(
	IN CALL* pCall
	);
	
VOID 
FsmRun(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pRecvPacket,
	IN NDIS_STATUS* pStatus
	);

VOID
FsmSendPADITimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    );

VOID
FsmSendPADRTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    );    


VOID
FsmOfferingTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    );

  
#endif // _FSM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\debug.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.h
// RAS L2TP WAN mini-port/call-manager driver
// Debug helper header
//
// 01/07/97 Steve Cobb


#ifndef _DEBUG_H_
#define _DEBUG_H_


//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//

#define MTAG_ADAPTER                        'PoEa'
#define MTAG_BINDING                        'PoEb'
#define MTAG_BUFFERPOOL                     'PoEc'
#define MTAG_PACKETPOOL                     'PoEd'
#define MTAG_PPPOEPACKET                    'PoEe'
#define MTAG_TAPIPROV                       'PoEf'
#define MTAG_LINE                           'PoEg'
#define MTAG_CALL                           'PoEh'
#define MTAG_HANDLETABLE                    'PoEi'
#define MTAG_HANDLECB                       'PoEj'
#define MTAG_TIMERQ                         'PoEk'
#define MTAG_FREED                          'PoEl'
#define MTAG_LLIST_WORKITEMS                'PoEm'

#if 0
#define MTAG_FREED       '0T2L'
#define MTAG_ADAPTERCB   '1T2L'
#define MTAG_TUNNELCB    '2T2L'
#define MTAG_VCCB        '3T2L'
#define MTAG_VCTABLE     '4T2L'
#define MTAG_WORKITEM    '5T2L'
#define MTAG_TIMERQ      '6T2L'
#define MTAG_TIMERQITEM  '7T2L'
#define MTAG_PACKETPOOL  '8T2L'
#define MTAG_FBUFPOOL    '9T2L'
#define MTAG_HBUFPOOL    'aT2L'
#define MTAG_TDIXRDG     'bT2L'
#define MTAG_TDIXSDG     'cT2L'
#define MTAG_CTRLRECD    'dT2L'
#define MTAG_CTRLSENT    'eT2L'
#define MTAG_PAYLRECD    'fT2L'
#define MTAG_PAYLSENT    'gT2L'
#define MTAG_INCALL      'hT2L'
#define MTAG_UTIL        'iT2L'
#define MTAG_ROUTEQUERY  'jT2L'
#define MTAG_ROUTESET    'kT2L'
#define MTAG_L2TPPARAMS  'lT2L'
#define MTAG_TUNNELWORK  'mT2L'
#define MTAG_TDIXROUTE   'nT2L'
#define MTAG_CTRLMSGINFO 'oT2L'
#endif

// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_V    0x30 // Verbose

// Trace mask bits.
//
#define TM_Mp    0x00000001 // Mini-port general
#define TM_Tp    0x00000002 // Tapi general
#define TM_Pr    0x00000004 // Protocol general
#define TM_Fsm   0x00000010 // Finite state machines
#define TM_Mn    0x00000020 // Main module
#define TM_Pk    0x00000040 // Packet general

#define TM_Init  0x00000020 // Initialization
#define TM_Misc  0x00000040 // Miscellaneous
#define TM_TWrk  0x00001000 // Tunnel work APC queuing
#define TM_Ref   0x00010000 // References
#define TM_Time  0x00020000 // Timer queue
#define TM_Pool  0x00080000 // Buffer and packet pooling
#define TM_Stat  0x00100000 // Call statistics
#define TM_Spec  0x01000000 // Special purpose temporary traces
#define TM_MDmp  0x10000000 // Message dumps
#define TM_Dbg   0x80000000 // Debug corruption checks

#define TM_Wild  0xFFFFFFFF // Everything
#define TM_All   0x7FFFFFFF // Everything except corruption checks
#define TM_BTWrk 0x00000FFF // Base with messages and tunnel work
#define TM_BCMsg 0x000001FF // Base with control messages
#define TM_XCMsg 0x001401FF // Base with control messages extended
#define TM_Base  0x000000FF // Base only

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint( "PPPoE: " );                                  \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "PPPoE: !ASSERT( %s ) at line %d of %s\n", \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\debug.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.c
// RAS L2TP WAN mini-port/call-manager driver
// Debug utilities and globals
//
// 01/07/97 Steve Cobb


#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>

#include "debug.h"


//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

#ifdef TESTMODE
#define DEFAULTTRACELEVEL  TL_N
#define DEFAULTTRACEMASK   TM_Wild & ~( TM_Time | TM_Pool )
#else
#define DEFAULTTRACELEVEL  TL_None
#define DEFAULTTRACEMASK   TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "L2TP: %p: ", p );
    else
        DbgPrint( "L2TP: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\main.c ===
// Copyright (c) 2000, Microsoft Corporation, all rights reserved
//
// main.c
// RAS PPPoE mini-port/call-manager driver
// Main routine (DriverEntry) and global data definitions
//
// 01/26/2000 Hakan BERK
//


#include <ntddk.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "packet.h"

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

NDIS_HANDLE gl_NdisWrapperHandle = NULL;
NDIS_HANDLE gl_NdisProtocolHandle = NULL;

//
// Lookaside list for work items
//
NPAGED_LOOKASIDE_LIST gl_llistWorkItems;

//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath );

//
// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The DriverEntry routine is the main entry point for the driver.
    It is responsible for the initializing the Miniport wrapper and
    registering the driver with the Miniport wrapper.

Parameters:

    DriverObject _ Pointer to driver object created by the system.

    RegistryPath _ Pointer to registery path name used to read registry
                   parameters.

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL

---------------------------------------------------------------------------*/
{
    NTSTATUS ntStatus;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Mn, ( "+DriverEntry" ) );

    do
    {

        //
        // Register miniport
        //
        status = MpRegisterMiniport( DriverObject, RegistryPath, &gl_NdisWrapperHandle );

        if (status != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Mn, ( "MpRegisterMiniport=$%x", status ) );
            break;
        }

        //
        // Register protocol
        //
        status = PrRegisterProtocol( DriverObject, RegistryPath, &gl_NdisProtocolHandle );

        if (status != NDIS_STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Mn, ( "PrRegisterProtocol=$%x", status ) );
            break;
        }

        //
        // Set driver object's unload function
        //
        NdisMRegisterUnloadHandler( gl_NdisWrapperHandle, DriverUnload );
        
        //
        // Initialize the lookaside list for bindings
        //
        InitializeWorkItemLookasideList( &gl_llistWorkItems,
                                         MTAG_LLIST_WORKITEMS );

    } while ( FALSE );
    
    if ( status == NDIS_STATUS_SUCCESS )
    {
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    TRACE( TL_N, TM_Mn, ( "-DriverEntry=$%x",ntStatus ) );

    return ntStatus;
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    NDIS_STATUS Status;
    
    TRACE( TL_N, TM_Mn, ( "+DriverUnload" ) );

    //
    // First deregister the protocol
    //
    NdisDeregisterProtocol( &Status, gl_NdisProtocolHandle );

    //
    // Clean up the protocol resources before driver unloads
    //
    PrUnload();

    NdisDeleteNPagedLookasideList( &gl_llistWorkItems );

    TRACE( TL_N, TM_Mn, ( "-DriverUnload" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\fsm.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    fsm.c

Abstract:

    This module contains the routines for the PPPoE finite state machine.

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"
#include "fsm.h"

extern TIMERQ gl_TimerQ;

VOID
FsmMakeCall(
	IN CALL* pCall
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function kicks the PPPoE FSM for an outbound call.

	It is called at IRQL_PASSIVE level as a scheduled operation.

	When this function is entered, the call has 3 references on it:
		1. One for scheduling this function.
		2. One for dropping the call.
		3. One for closing the call.

	The removal of the reference will be handled by the caller.
	
	The call will be in stateIdle when this function is entered.
	
Parameters:

	pCall _ A pointer to our call information structure.

Return Values:

	None
	
---------------------------------------------------------------------------*/		
{
	ASSERT( VALIDATE_CALL( pCall ) );

	TRACE( TL_N, TM_Fsm, ("+FsmMakeCall") );
	
	//
	// Notify TAPI that our call is in dialing state
	//
	TpCallStateChangeHandler( pCall, LINECALLSTATE_DIALING, 0 );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmMakeCall: Call already dropped or close pending") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmMakeCall") );
		
		return;
	}

	pCall->stateCall = CL_stateSendPadi;

	NdisReleaseSpinLock( &pCall->lockCall );
	
	FsmRun( pCall, NULL, NULL, NULL );

	TRACE( TL_N, TM_Fsm, ("-FsmMakeCall") );
	
}

VOID
FsmReceiveCall(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pPacket
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function kicks the PPPoE FSM for an inbound call.

	It is called at IRQL_DISPATCH level.

	When this function is entered, the call has 3 references on it:
		1. One for running this function.
		2. One for dropping the call.
		3. One for closing the call.

	The removal of the reference will be handled by the caller.

	The call will be in stateIdle when this function is entered.

	This function will be called when a valid PADR packet is received and 
	a new call context is created. It will initialize the state of call context
	to CL_stateRecvdPadr, and call FsmRun() to run the state machine.
		
Parameters:

	pCall _ A pointer to our call information structure.

	pBinding _ Binding over which the packet is received.

	pPacket _ A PADR packet received.

Return Values:

	None
	
---------------------------------------------------------------------------*/		
{
	ASSERT( VALIDATE_CALL( pCall ) );
	
	TRACE( TL_N, TM_Fsm, ("+FsmReceiveCall") );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmReceiveCall: Call already dropped or close pending") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmReceiveCall") );

		return;
	}
	
	pCall->stateCall = CL_stateRecvdPadr;

	NdisReleaseSpinLock( &pCall->lockCall );

	FsmRun( pCall, pBinding, pPacket, NULL );

	TRACE( TL_N, TM_Fsm, ("-FsmReceiveCall") );

}

NDIS_STATUS
FsmAnswerCall(
	IN CALL* pCall
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function will be called when a call indicated to TAPI in 
	LINECALLSTATE_OFFERING state is accepted by TAPI with an OID_TAPI_ANSWER.

	It will change the state of the call to CL_stateSendPads, and run FSM.
	
Parameters:

	pCall _ A pointer to our call information structure.

Return Values:

	NDIS_STATUS_SUCCESS
	NDIS_STATUS_FAILURE
	NDIS_STATUS_XXXXXXX
	
---------------------------------------------------------------------------*/		
{
	NDIS_STATUS status = NDIS_STATUS_FAILURE;
	
	ASSERT( VALIDATE_CALL( pCall ) );
	
	TRACE( TL_N, TM_Fsm, ("+FsmAnswerCall") );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmAnswerCall: Call already dropped or close pending") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmAnswerCall=$%x",status) );	

		return status;
	}

	if ( pCall->stateCall != CL_stateOffering )
	{
		TRACE( TL_A, TM_Fsm, ("FsmAnswerCall: Call state changed unexpectedly from CL_stateOffering") );
		
		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmAnswerCall=$%x",status) );	

		return status;
	}

	pCall->stateCall = CL_stateSendPads;
	
	NdisReleaseSpinLock( &pCall->lockCall );

	FsmRun( pCall, NULL, NULL, &status );

	TRACE( TL_N, TM_Fsm, ("-FsmAnswerCall=$%x",status) );	

	return status;
}


VOID 
FsmRun(
	IN CALL* pCall,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pRecvPacket,
	IN NDIS_STATUS* pStatus
	)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the heart of the FSM. It looks at the call context's information
	and takes necesarry actions.

	It will be called at both IRQL_PASSIVE and IRQL_DISPATCH level.

	If this function is entered, then the call must have a reference on it just for 
	running this function.

	The removal of the reference must be handled by the caller.
	
Parameters:

	pCall _ A pointer to our call information structure.

	pBinding _ A pointer to the binding context over which a packet was received.
	           Must be NULL if no packets were received.

	pRecvPacket _ A pointer to a received packet context.
	              Must be NULL if no packets were received.

	pStatus _ An optional parameter when the caller requests status about the
	          operations performed.

Return Values:

	None
	
---------------------------------------------------------------------------*/	
{
	BOOLEAN fLockReleased = FALSE;
	BOOLEAN fDropCall = FALSE;
	BOOLEAN fCloseCall = FALSE;
	BOOLEAN fFallThru = FALSE;
	ULONG ulLineDisconnectMode = 0;

	TRACE( TL_N, TM_Fsm, ("+FsmRun") );

	NdisAcquireSpinLock( &pCall->lockCall );

	//
	// If call is already dropped or close is pending,
	// do not proceed; just remove the reference for FSM and return.
	//
	if ( pCall->ulClFlags & CLBF_CallClosePending ||
		 pCall->ulClFlags & CLBF_CallDropped )
	{
		TRACE( TL_N, TM_Fsm, ("FsmRun: Call already dropped or close pending") );

		NdisReleaseSpinLock( &pCall->lockCall );

		TRACE( TL_N, TM_Fsm, ("-FsmRun") );

		return;
	}

	switch ( pCall->stateCall )
	{

		case CL_stateSendPadi:

			//
			// In this state, we are making a new outbound call, and we should broadcast
			// a PADI packet
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				CHAR tagHostUniqueValue[16];
				USHORT tagHostUniqueLength;


				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateSendPadi") );

				if ( pRecvPacket != NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Can not process packets in this state") );

					break;
				}
				
				CreateUniqueValue( pCall->hdCall,
								   tagHostUniqueValue,
								   &tagHostUniqueLength );

				//
				// Create a PADI packet to send
				//
				status = PacketInitializePADIToSend( &pPacket,
													 pCall->nServiceNameLength,
													 pCall->ServiceName,
													 tagHostUniqueLength,
													 tagHostUniqueValue );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to initialize PADI to send") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;

					break;
				}

				//
				// Attach packet to call context
				//
				pCall->pSendPacket = pPacket;

				ReferencePacket( pPacket );
				
				//
				// Initialize and schedule the timeout handler
				//
				pCall->nNumTimeouts = 0;
				
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADITimeout,
									(PVOID) pCall );

				//
				// Reference call for the timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Advance the state to next
				//
				pCall->stateCall = CL_stateWaitPado;

				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				//
				// Packet is ready, so broadcast it
				//
				status = PrBroadcast( pPacket );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					//
					// Broadcast unsuccesfull, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to broadcast PADI") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;

				}

				DereferencePacket( pPacket );

			}

			break;

		case CL_stateWaitPado:

			//
			// In this state, we are waiting for a PADO packet, and it seems like we have 
			// received a packet to process
			//

			{
				PPPOE_PACKET* pPacket;

				USHORT usRecvHostUniqueLength;
				USHORT usSendHostUniqueLength;
				CHAR*  pRecvHostUniqueValue = NULL;
				CHAR*  pSendHostUniqueValue = NULL;

				USHORT usRecvACNameLength;
				CHAR*  pRecvACNameValue = NULL;

				USHORT usRecvServiceNameLength;
				USHORT usSendServiceNameLength;
				CHAR*  pRecvServiceNameValue = NULL;
				CHAR*  pSendServiceNameValue = NULL;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateWaitPado") );

				//
				// Make sure that we received a packet
				//
				if ( pRecvPacket == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No packets received") );
					
					break;
				}

				//
				// Make sure that we received a PADO packet
				//
				if ( PacketGetCode( pRecvPacket ) != PACKET_CODE_PADO )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Packet not PADO") );
					
					break;
				}

				//
				// Check for errors
				//
				if ( PacketAnyErrorTagsReceived( pRecvPacket ) )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Error tag received in the packet") );

					//
					// We do not need to drop the call since we might receive other
					// PADO packets from different servers.
					//
					
					break;
				}

				//
				// Verify the host unique tag
				//
				if ( pCall->pSendPacket == NULL )
				{	
					//
					// Something is wrong, the last send packet is freed, just return
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Last sent packet is freed") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
					
					break;
				}

				pPacket = pCall->pSendPacket;

				PacketRetrieveHostUniqueTag( pPacket,
											 &usSendHostUniqueLength,
											 &pSendHostUniqueValue );
											
				PacketRetrieveHostUniqueTag( pRecvPacket,
											 &usRecvHostUniqueLength,
											 &pRecvHostUniqueValue );

				if ( usSendHostUniqueLength != usRecvHostUniqueLength )
				{
					//
					// Lengths of host unique tags mismatch, drop the packet
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag lengths mismatch") );
					
					break;
				}

				if ( !NdisEqualMemory( pSendHostUniqueValue, pRecvHostUniqueValue, usSendHostUniqueLength ) )
				{
					//
					// Host unique tag values mismatch, drop the packet
					// 
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag values mismatch") );
					
					break;
				}

				//
				// Host unique id is validated, retrieve the AC-name tag
				//
				PacketRetrieveACNameTag( pRecvPacket,
										 &usRecvACNameLength,
										 &pRecvACNameValue );

				if ( usRecvACNameLength == 0 )
				{
					//
					// AC name is invalid, drop the packet
					// 
					TRACE( TL_A, TM_Fsm, ("FsmRun: Invalid AC-Name tag") );
					
					break;
				}

            if ( pCall->fACNameSpecified )
            {
               //
               // Caller specified an AC Name, so validate it
               //
               if ( pCall->nACNameLength != usRecvACNameLength )
               {
   					//
	   				// Received AC name does not match the specified one, drop the packet
		   			//
			   		TRACE( TL_A, TM_Fsm, ("FsmRun: AC Name Length mismatch") );
				   	
					   break;
               }

               if ( !NdisEqualMemory( pRecvACNameValue, pCall->ACName, usRecvACNameLength ) )
         		{
				   	//
			   		// Host unique tag values mismatch, drop the packet
   					// 
	   				TRACE( TL_A, TM_Fsm, ("FsmRun: AC Name mismatch") );
		   			
			   		break;
				   }
               
            }
            else
            {
               //
               // No AC Name was specified so copy the AC Name from the received packet
               //
   				pCall->nACNameLength = ( MAX_AC_NAME_LENGTH < usRecvACNameLength ) ?
	          								    MAX_AC_NAME_LENGTH : usRecvACNameLength;
									   
   				NdisMoveMemory( pCall->ACName, pRecvACNameValue, pCall->nACNameLength );
            }

				//
				// AC-Name is validated, verify the service-name tag
				//
				PacketRetrieveServiceNameTag( pPacket,
											  &usSendServiceNameLength,
											  &pSendServiceNameValue,
											  0,
											  NULL );
											
				PacketRetrieveServiceNameTag( pRecvPacket,
											  &usRecvServiceNameLength,
											  &pRecvServiceNameValue,
											  0,
											  NULL );
											  
				//
				// Make sure we have received a service-name at least
				//
				if ( pRecvServiceNameValue == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No service-name tag in a received PADO") );
					
					break;
				}

                //
                // If fAcceptAnyService is FALSE, then make sure the requested service is in the PADO 
                // received, otherwise if we have requested an empty service name, then try to find it 
                // in the PADO, if not use the first service name from it.
                //
                {
					BOOLEAN fFound = FALSE;
					CHAR*  pFirstRecvServiceNameValue = NULL;
					USHORT usFirstRecvServiceNameLength = 0;
                    BOOLEAN fAcceptAnyService = pCall->pLine->pAdapter->fAcceptAnyService;
					//
					// We have asked for a specific service name, so let's
					// see if the server responded with it
					//
					while ( usRecvServiceNameLength >= 0 && pRecvServiceNameValue != NULL )
					{
                        if ( pFirstRecvServiceNameValue == NULL )
                        {
                            pFirstRecvServiceNameValue = pRecvServiceNameValue;
                            usFirstRecvServiceNameLength = usRecvServiceNameLength;
                        }
						
						if ( usRecvServiceNameLength == usSendServiceNameLength )
						{

							if ( NdisEqualMemory( pSendServiceNameValue, 
												  pRecvServiceNameValue, 
												  usSendServiceNameLength ) )
							{
								fFound = TRUE;
			
								break;
							}
						}

						PacketRetrieveServiceNameTag( pRecvPacket,
													  &usRecvServiceNameLength,
													  &pRecvServiceNameValue,
													  usRecvServiceNameLength,
													  pRecvServiceNameValue );
						
					}

					if ( !fFound )
					{
                        if ( fAcceptAnyService )
                        {
                            //
                            // Use the first service in the PADO, if we have requested an
                            // empty service-name
                            //
                            if ( usSendServiceNameLength == 0 )
                            {
                                pCall->nServiceNameLength = ( MAX_SERVICE_NAME_LENGTH < usFirstRecvServiceNameLength ) ?
                                                              MAX_SERVICE_NAME_LENGTH : usFirstRecvServiceNameLength;

                                if ( pCall->nServiceNameLength > 0 )
                                {
                                    NdisMoveMemory( pCall->ServiceName, 
                                                    pFirstRecvServiceNameValue, 
                                                    pCall->nServiceNameLength );
                                    
                                    fFound = TRUE;
                                }
                            }
                        }

                        if ( !fFound )
                        {
                            //
                            // We could not find a matching service name tag, so drop the packet
                            //
                            TRACE( TL_A, TM_Fsm, ("FsmRun: PADO does not contain the service-name tag we requested") );
                            
                            break;
                        }
                    }
                }

				//
				// Received packet is validated, so set the dest addr in the call.
				// The source address will be copied on the call in PrAddCallToBinding() below.
				//
				NdisMoveMemory( pCall->DestAddr, PacketGetSrcAddr( pRecvPacket ), 6 * sizeof( CHAR ) );
				
				//
				// Received packet is validated, so proceed to next state
				//
				pCall->stateCall = CL_stateSendPadr;
				fFallThru = TRUE;

				//
				// As we are done with the last sent packet, free it
				//
				pCall->pSendPacket = NULL;
				
				PacketFree( pPacket );

				//
				// Cancel the timeout handler and attach call to binding
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );

				PrAddCallToBinding( pBinding, pCall );

				//
				// Notify TAPI that our call is in proceeding state
				//
				TpCallStateChangeHandler( pCall, LINECALLSTATE_PROCEEDING, 0 );
				
				NdisAcquireSpinLock( &pCall->lockCall );

				//
				// Make sure state was not changed when we released the lock to cancel the timer queue item
				//
				if ( pCall->stateCall != CL_stateSendPadr )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: State changed unexpectedly from CL_stateSendPadr") );
					
					break;
				}

				//
				// Fall thru to case CL_stateSendPadr
				//
			}

		case CL_stateSendPadr:

			//
			// In this state, we have received a valid PADO packet, and we need to respond to it
			// with a PADR packet
			//
			{
				
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				CHAR tagHostUniqueValue[16];
				USHORT tagHostUniqueLength;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateSendPadr") );

				if ( !fFallThru )
				{
					TRACE( TL_N, TM_Fsm, ("FsmRun: Non fall thru entry into a fall thru state") );

					break;
				}

				CreateUniqueValue( pCall->hdCall,
								   tagHostUniqueValue,
								   &tagHostUniqueLength );

				//
				// Create a PADR packet to send
				//
				status = PacketInitializePADRToSend( pRecvPacket,
													 &pPacket,
													 pCall->nServiceNameLength,
													 pCall->ServiceName,
													 tagHostUniqueLength,
													 tagHostUniqueValue );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to initialize PADR to send") );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;

					break;
				}

				//
				// Attach packet to call context
				//
				pCall->pSendPacket = pPacket;

				ReferencePacket( pPacket );

				//
				// Reference binding for PrSend()
				//
				ReferenceBinding( pBinding, TRUE );
				
				//
				// Initialize and schedule the timeout handler
				//
				pCall->nNumTimeouts = 0;
				
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADRTimeout,
									(PVOID) pCall );

				//
				// Reference call for the timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Advance the state to next
				//
				pCall->stateCall = CL_stateWaitPads;

				//
				// Release the lock to send the packet
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				//
				// Packet is ready, so send it
				//
				status = PrSend( pBinding, pPacket );

				if ( status != NDIS_STATUS_PENDING )
				{
					if ( status != NDIS_STATUS_SUCCESS )
					{
						//
						// Send operation was not succesful, so drop the call
						//
						TRACE( TL_A, TM_Fsm, ("FsmRun: PrSend() failed to send PADR") );
						
						fDropCall = TRUE;

						ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
					}
					
				}

			}

			break;

		case CL_stateWaitPads:

			//
			// In this state, we have sent a PADR packet and waiting for a PADS packet to establish
			// a session
			//
			
			{
				PPPOE_PACKET* pPacket;

				USHORT usRecvHostUniqueLength;
				USHORT usSendHostUniqueLength;
				CHAR*  pRecvHostUniqueValue = NULL;
				CHAR*  pSendHostUniqueValue = NULL;

				USHORT usRecvServiceNameLength;
				USHORT usSendServiceNameLength;
				CHAR*  pRecvServiceNameValue = NULL;
				CHAR*  pSendServiceNameValue = NULL;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateWaitPads") );

				//
				// Make sure that we received a packet
				//
				if ( pRecvPacket == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No packets received") );
					
					break;
				}

				//
				// Make sure that we received a PADO packet
				//
				if ( PacketGetCode( pRecvPacket ) != PACKET_CODE_PADS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Packet not PADS") );
					
					break;
				}

				//
				// Check for errors
				//
				if ( PacketAnyErrorTagsReceived( pRecvPacket ) )
				{
					PACKET_TAGS tagType;
					USHORT tagLength;
					CHAR* tagValue = NULL;
					
					TRACE( TL_A, TM_Fsm, ("FsmRun: Error tag received in the packet") );
					
					fDropCall = TRUE;

					//
					// Set the line disconnect mode looking at the error tag
					//
					PacketRetrieveErrorTag( pRecvPacket,
											&tagType,
											&tagLength,
											&tagValue );

					switch( tagType ) {

						case tagServiceNameError:
						
									ulLineDisconnectMode = LINEDISCONNECTMODE_BADADDRESS;
									
									break;

						case tagACSystemError:

									ulLineDisconnectMode = LINEDISCONNECTMODE_INCOMPATIBLE;

									break;

						case tagGenericError:

									ulLineDisconnectMode = LINEDISCONNECTMODE_REJECT;

									break;
					}

					break;
				}

				//
				// Verify the host unique tag
				//
				if ( pCall->pSendPacket == NULL )
				{	
					//
					// Something is wrong, the last send packet is freed, just return
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Last sent packet is freed") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
					
					break;
				}

				pPacket = pCall->pSendPacket;

				PacketRetrieveHostUniqueTag( pPacket,
											 &usSendHostUniqueLength,
											 &pSendHostUniqueValue );
											
				PacketRetrieveHostUniqueTag( pRecvPacket,
											 &usRecvHostUniqueLength,
											 &pRecvHostUniqueValue );

				if ( usSendHostUniqueLength != usRecvHostUniqueLength )
				{
					//
					// Lengths of host unique tags mismatch, drop the packet
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag lengths mismatch") );
					
					break;
				}

				if ( !NdisEqualMemory( pSendHostUniqueValue, pRecvHostUniqueValue, usSendHostUniqueLength ) )
				{
					//
					// Host unique tag values mismatch, drop the packet
					// 
					TRACE( TL_A, TM_Fsm, ("FsmRun: Host Unique tag values mismatch") );
					
					break;
				}

				//
				// Host unique id is validated, verify the service name
				//
				PacketRetrieveServiceNameTag( pPacket,
											  &usSendServiceNameLength,
											  &pSendServiceNameValue,
											  0,
											  NULL );
											
				PacketRetrieveServiceNameTag( pRecvPacket,
											  &usRecvServiceNameLength,
											  &pRecvServiceNameValue,
											  0,
											  NULL );

				//
				// Make sure we have received a service-name at least
				//
				if ( pRecvServiceNameValue == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No service-name tag in a received PADS") );
					
					break;
				}

				//
				// Search for the specific service-name we requested
				//
				{
					BOOLEAN fFound = FALSE;

					//
					// We have asked for a specific service name, so let's
					// see if the server responded with it
					//
					while ( usRecvServiceNameLength >= 0 && pRecvServiceNameValue != NULL )
					{
						
						if ( usRecvServiceNameLength == usSendServiceNameLength )
						{

							if ( NdisEqualMemory( pSendServiceNameValue, 
												  pRecvServiceNameValue, 
												  usSendServiceNameLength ) )
							{
								fFound = TRUE;
			
								break;
							}
						}

						PacketRetrieveServiceNameTag( pRecvPacket,
													  &usRecvServiceNameLength,
													  &pRecvServiceNameValue,
													  usRecvServiceNameLength,
													  pRecvServiceNameValue );
						
					}

					if ( !fFound )
					{
						//
						// We could not find a matching service name tag, so drop the packet
						//
						TRACE( TL_A, TM_Fsm, ("FsmRun: PADS does not contain the service-name tag we requested") );
						
						break;
					}
				}

				//
				// Set the session id on the call context
				//
				pCall->usSessionId = PacketGetSessionId( pRecvPacket );

				//
				// As we are done with the last sent packet, free it
				//
				pCall->pSendPacket = NULL;
				
				PacketFree( pPacket );

				//
				// Cancel the timeout handler and attach call to binding
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );

				//
				// Notify call connect event
				//
				TpCallStateChangeHandler( pCall, LINECALLSTATE_CONNECTED, 0 );

			}

			break;

		case CL_stateRecvdPadr:

			//
			// In this state, we have been received a PADR packet.
			// We will indicate the call to Tapi, and change the state to CL_stateOffering 
			// and wait for the application to answer the call.
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket;

				USHORT usRecvServiceNameLength;
				CHAR*  pRecvServiceNameValue = NULL;

				USHORT usSessionId;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateWaitPadr") );
				
				//
				// Make sure that we received a packet
				//
				if ( pRecvPacket == NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: No packets received") );
					
					break;
				}
				
				//
				// Make sure that we received a PADR packet
				//
				if ( PacketGetCode( pRecvPacket ) != PACKET_CODE_PADR )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Packet not PADR") );
				
					break;
				}

				//
				// Set the dest addr in the call.
				// The source address will be copied on to the call in PrAddCallToBinding() below.
				//
				NdisMoveMemory( pCall->DestAddr, PacketGetSrcAddr( pRecvPacket ), 6 * sizeof( CHAR ) );

				//
				// Retrieve the service name and copy it onto the call context
				//
				PacketRetrieveServiceNameTag( pRecvPacket,
											  &usRecvServiceNameLength,
											  &pRecvServiceNameValue,
											  0,
											  NULL );
				
				pCall->nServiceNameLength = ( MAX_SERVICE_NAME_LENGTH < usRecvServiceNameLength ) ?
											  MAX_SERVICE_NAME_LENGTH : usRecvServiceNameLength;
											  
				NdisMoveMemory( pCall->ServiceName, 
								pRecvServiceNameValue, 
								pCall->nServiceNameLength );

				//
				// Copy the AC-Name onto call context, before connection is established
				//
				pCall->nACNameLength = pCall->pLine->pAdapter->nACNameLength;
				
				NdisMoveMemory( pCall->ACName, 
								pCall->pLine->pAdapter->ACName, 
								pCall->nACNameLength );

				//
				// Retrieve the session id from the call handle and create a PADS packet to send
				//
				usSessionId = RetrieveSessionIdFromHandle( (NDIS_HANDLE) pCall->hdCall );

				status = PacketInitializePADSToSend( pRecvPacket,
													 &pPacket,
													 usSessionId );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Failed to initialize PADS to send") );
					
					fCloseCall = TRUE;

					break;
				}

				//
				// This PADS packet will be sent if application answers the call
				//
				pCall->pSendPacket = pPacket;

				//
				// Proceed to next state
				//
				pCall->stateCall = CL_stateOffering;

				//
				// Initialize and schedule the timeout handler
				//
				pCall->nNumTimeouts = 0;

				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulRecvTimeout,
									FsmOfferingTimeout,
									(PVOID) pCall );

				//
				// Reference call for the timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Release the lock
				//
				NdisReleaseSpinLock( &pCall->lockCall );
				
				fLockReleased = TRUE;
				
				//
				// Notify TAPI about the state change
				//
				if ( TpIndicateNewCall( pCall ) )
				{
					//
					// Add call to binding
					//
					PrAddCallToBinding( pBinding, pCall );

					TpCallStateChangeHandler( pCall, LINECALLSTATE_OFFERING, 0 );
				
				}

			}

			break;

		case CL_stateSendPads:

			//
			// In this state, TAPI has accepted the call, so we should send the PADS packet and create 
			// the session.
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;

				TRACE( TL_N, TM_Fsm, ("FsmRun: CL_stateSendPads") );

				if ( pRecvPacket != NULL )
				{
					TRACE( TL_A, TM_Fsm, ("FsmRun: Can not process packets in this state") );

					break;
				}

				//
				// Make sure we still have the PADS packet to send
				//
				if ( pCall->pSendPacket == NULL )
				{	
					//
					// Something is wrong, the last send packet is freed, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: Last sent packet is freed") );

					fDropCall = TRUE;

					*pStatus = NDIS_STATUS_FAILURE;
					
					break;
				}

				pPacket = pCall->pSendPacket;

				if ( pCall->pBinding == NULL )
				{
					//
					// Binding is gone, we should drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmRun: No binding found") );

					fDropCall = TRUE;

					*pStatus = NDIS_STATUS_FAILURE;					
					
					break;
				}
				
				pBinding = pCall->pBinding;
				
				//
				// Reference packet and binding for PrSend()
				//
				ReferencePacket( pPacket );

				ReferenceBinding( pBinding, TRUE );

				//
				// Set the session id on the call context
				//
				pCall->usSessionId = RetrieveSessionIdFromHandle( (NDIS_HANDLE) pCall->hdCall );

				//
				// Release the lock and send the packet
				//
				NdisReleaseSpinLock( &pCall->lockCall );

				fLockReleased = TRUE;

				//
				// Cancel the timeout handler
				//
				TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );
				
				//
				// Packet is ready, so send it
				//
				status = PrSend( pBinding, pPacket );

				if ( status != NDIS_STATUS_PENDING )
				{
					if ( status != NDIS_STATUS_SUCCESS )
					{
						//
						// Send operation was not succesful, so drop the call
						//
						TRACE( TL_A, TM_Fsm, ("FsmRun: PrSend() failed to send PADS") );
						
						fDropCall = TRUE;

						*pStatus = NDIS_STATUS_FAILURE;
						
						break;
						
					}
				}

				//
				// Notify call connect event, since we sent the PADS packet
				//
				TpCallStateChangeHandler( pCall, LINECALLSTATE_CONNECTED, 0 );

				*pStatus = NDIS_STATUS_SUCCESS;

			}

			break;
			
		default:

			TRACE( TL_A, TM_Fsm, ("FsmRun: Ignoring irrelevant state notification") );

			break;
	}

	if ( !fLockReleased )
	{
		NdisReleaseSpinLock( &pCall->lockCall );
	}

	if ( fCloseCall )
	{
		NDIS_TAPI_CLOSE_CALL DummyRequest;

		TRACE( TL_N, TM_Fsm, ("FsmRun: Closing call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Close will take care of unbinding and cancelling the timer
		//
		TpCloseCall( pCall->pLine->pAdapter, &DummyRequest, FALSE );
	
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;
				
		TRACE( TL_N, TM_Fsm, ("FsmRun: Dropping call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, ulLineDisconnectMode );

	}

	TRACE( TL_N, TM_Fsm, ("-FsmRun") );
	
}

VOID
FsmSendPADITimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the timeout handler for a sent PADI packet.

	If the timeout period expires before a valid PADO packet is received,
	this function will be called with TE_Expire. In this case we check for 
	a few conditions, and schedule another timeout event if necesarry.
	
	If it was cancelled -because a PADO packet was received - or timer queue 
	is terminating then	it will be called with TE_Cancel and TE_Terminate codes
	respectively. In this case, we do not do anything, just remove the reference
	and return.
	
Parameters:

	pTqi _ A pointer to our timer queue item information structure.

	pContext _ A pointer to a our call information structure.

	event _ Indicates the type of event: TE_Expire, TE_Cancel or TE_Terminate.
	
Return Values:

	None
	
---------------------------------------------------------------------------*/    
{
	CALL* pCall = (CALL*) pContext;
	BOOLEAN fDropCall = FALSE;
	ULONG ulLineDisconnectMode = 0;

	TRACE( TL_N, TM_Fsm, ("+FsmSendPADITimeout") );
	
	switch ( event )
	{

		case TE_Expire:

			//
			// Timeout period expired, take necesarry actions
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				
				TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Timer expired") );

				NdisAcquireSpinLock( &pCall->lockCall );

				if ( pCall->stateCall != CL_stateWaitPado )
				{
					//
					// State has changed, no need further processing of this event
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADITimeout: State already changed") );

					NdisReleaseSpinLock( &pCall->lockCall );

					break;
					
				}

				//
				// Check if we have reached the max number of time outs
				//
				if ( pCall->nNumTimeouts == pCall->pLine->pAdapter->nMaxTimeouts )
				{
					//
					// We did not receive any answers, drop the call
					//
					TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Max number of timeouts reached") );

					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_NOANSWER;

					break;
				}

				pPacket = pCall->pSendPacket;

				if ( pPacket == NULL )
				{
					//
					// We are probably in a ver small timing window where FsmRun() is also
					// working on the same call, and has just freed the packet, so it probably
					// cancelled the timer, but we did not get the cancel, and instead we were 
					// called with TE_Expire, so let's just act like we were cancelled.
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADITimeout: Can not find last sent packet for re-send") );

					NdisReleaseSpinLock( &pCall->lockCall );

					break;
				}

				ReferencePacket( pPacket );

				//
				// Schedule another timeout event
				//
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADITimeout,
									(PVOID) pCall );

				//
				// Reference call for the new timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Increment the timeout counter
				//
				pCall->nNumTimeouts++;

				NdisReleaseSpinLock( &pCall->lockCall );

				//
				// Packet is ready, so broadcast it
				//
				status = PrBroadcast( pPacket );

				if ( status != NDIS_STATUS_SUCCESS )
				{
					//
					// Broadcast unsuccesfull, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADITimeout: Broadcast failed") );

					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
				}

				DereferencePacket( pPacket );
				
			}

			break;

		case TE_Cancel:
		case TE_Terminate:

			{
				//
				// Reset the timeout counter and reference will be removed below
				//
				TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Timer cancelled or terminated") );
				
				NdisAcquireSpinLock( &pCall->lockCall );
	
				pCall->nNumTimeouts = 0;
	
				NdisReleaseSpinLock( &pCall->lockCall );

			}
			
			break;
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;
				
		TRACE( TL_N, TM_Fsm, ("FsmSendPADITimeout: Dropping call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, ulLineDisconnectMode );

	}

	DereferenceCall( pCall );

	TRACE( TL_N, TM_Fsm, ("-FsmSendPADITimeout") );
	

}

VOID
FsmSendPADRTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the timeout handler for a sent PADR packet.

	If the timeout period expires before a valid PADS packet is received,
	this function will be called with TE_Expire. In this case we check for 
	a few conditions, and schedule another timeout event if necesarry.
	
	If it was cancelled - because a PADS packet was received - or timer queue 
	is terminating then	it will be called with TE_Cancel and TE_Terminate codes
	respectively. In this case, we do not do anything, just remove the reference
	and return.
	
Parameters:

	pTqi _ A pointer to our timer queue item information structure.

	pContext _ A pointer to a our call information structure.

	event _ Indicates the type of event: TE_Expire, TE_Cancel or TE_Terminate.
	
Return Values:

	None
	
---------------------------------------------------------------------------*/    
{
	CALL* pCall = (CALL*) pContext;
	BOOLEAN fDropCall = FALSE;
	ULONG ulLineDisconnectMode = 0;

	TRACE( TL_N, TM_Fsm, ("+FsmSendPADRTimeout") );
	
	switch ( event )
	{

		case TE_Expire:

			//
			// Timeout period expired, take necesarry actions
			//
			{
				NDIS_STATUS status;
				PPPOE_PACKET* pPacket = NULL;
				BINDING* pBinding = NULL;
				
				TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Timer expired") );

				NdisAcquireSpinLock( &pCall->lockCall );

				if ( pCall->stateCall != CL_stateWaitPads )
				{
					//
					// State has changed, no need further processing of this event
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: State already changed") );

					NdisReleaseSpinLock( &pCall->lockCall );

					break;
					
				}

				//
				// Check if we have reached the max number of time outs
				//
				if ( pCall->nNumTimeouts == pCall->pLine->pAdapter->nMaxTimeouts )
				{
					//
					// We did not receive any answers, drop the call
					//
					TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Max number of timeouts reached") );

					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_BUSY;

					break;
				}

				//
				// Save the binding for send operation
				//
				pBinding = pCall->pBinding;

				if ( pBinding == NULL )
				{
					//
					// The binding was removed, drop the call
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: Binding not found") );

					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;

					break;
				}

				//
				// Save the packet for send operation
				//
				pPacket = pCall->pSendPacket;
				
				if ( pPacket == NULL )
				{
					//
					// We are probably in a ver small timing window where FsmRun() is also
					// working on the same call, and has just freed the packet, so it probably
					// cancelled the timer, but we did not get the cancel, and instead we were 
					// called with TE_Expire, so let's just act like we were cancelled.
					//
					TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: Can not find last sent packet for re-send") );
					
					NdisReleaseSpinLock( &pCall->lockCall );

					break;
				}

				//
				// Reference both binding and the packet as PrSend() might pend, in which case
				// PrSendComplete() will remove these references
				//
				ReferenceBinding ( pBinding, TRUE );

				ReferencePacket( pPacket );

				//
				// Schedule another timeout event
				//
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulSendTimeout,
									FsmSendPADRTimeout,
									(PVOID) pCall );

				//
				// Reference call for the new timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Increment the timeout counter
				//
				pCall->nNumTimeouts++;

				NdisReleaseSpinLock( &pCall->lockCall );

				//
				// Send the packet once more
				//
				status = PrSend( pBinding, pPacket );

				if ( status != NDIS_STATUS_PENDING )
				{
					if ( status != NDIS_STATUS_SUCCESS )
					{
						//
						// Send operation was not succesful, so drop the call
						//
						TRACE( TL_A, TM_Fsm, ("FsmSendPADRTimeout: PrSend() failed to send PADR") );

						fDropCall = TRUE;

						ulLineDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
					}
					
				}

				
			}

			break;

		case TE_Cancel:
		case TE_Terminate:

			{
				//
				// Reset the timeout counter and reference will be removed below
				//
				TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Timer cancelled or terminated") );
					
				NdisAcquireSpinLock( &pCall->lockCall );
	
				pCall->nNumTimeouts = 0;
	
				NdisReleaseSpinLock( &pCall->lockCall );

			}
			
			break;
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;
				
		TRACE( TL_N, TM_Fsm, ("FsmSendPADRTimeout: Dropping call") );

		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, ulLineDisconnectMode );

	}

	DereferenceCall( pCall );

	TRACE( TL_N, TM_Fsm, ("-FsmSendPADRTimeout") );
}

VOID
FsmOfferingTimeout(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

	This function is the timeout handler for a received PADI packet.

	The call is in LINECALLSTATE_OFFERING according to TAPI, and we are
	waiting for an OID_TAPI_ACCEPT on the call.

	If the timeout period expires before a TAPI request is received,
	this function will be called with TE_Expire. In this case we check for 
	a few conditions, and schedule another timeout event if necesarry.
	
	If it was cancelled - because a TAPI request was received - or timer queue 
	is terminating then	it will be called with TE_Cancel and TE_Terminate codes
	respectively. In this case, we do not do anything, just remove the reference
	and return.
	
Parameters:

	pTqi _ A pointer to our timer queue item information structure.

	pContext _ A pointer to a our call information structure.

	event _ Indicates the type of event: TE_Expire, TE_Cancel or TE_Terminate.
	
Return Values:

	None
	
---------------------------------------------------------------------------*/    
{
	CALL* pCall = (CALL*) pContext;
	
	BOOLEAN fDropCall = FALSE;

	TRACE( TL_N, TM_Fsm, ("+FsmOfferingTimeout") );
	
	switch ( event )
	{

		case TE_Expire:

			//
			// Timeout period expired, take necesarry actions
			//
			{
				TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Timer expired") );
				
				NdisAcquireSpinLock( &pCall->lockCall );

				if ( pCall->stateCall != CL_stateOffering )
				{
					//
					// State has changed, no need further processing of this event
					//
					TRACE( TL_A, TM_Fsm, ("FsmOfferingTimeout: State already changed") );
					
					NdisReleaseSpinLock( &pCall->lockCall );

					break;
					
				}

				//
				// Check if we have reached the max number of time outs
				//
				if ( pCall->nNumTimeouts == pCall->pLine->pAdapter->nMaxTimeouts )
				{
					//
					// We did not receive any answers, drop the call
					//
					TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Max number of timeouts reached") );
					
					NdisReleaseSpinLock( &pCall->lockCall );
					
					fDropCall = TRUE;

					break;
				}

				//
				// Schedule another timeout event
				//
				TimerQInitializeItem( &pCall->timerTimeout );

				TimerQScheduleItem( &gl_TimerQ,
									&pCall->timerTimeout,
									pCall->pLine->pAdapter->ulRecvTimeout,
									FsmOfferingTimeout,
									(PVOID) pCall );

				//
				// Reference call for the new timeout handler
				//
				ReferenceCall( pCall, FALSE );

				//
				// Increment the timeout counter
				//
				pCall->nNumTimeouts++;

				NdisReleaseSpinLock( &pCall->lockCall );

			}

			break;

		case TE_Cancel:
		case TE_Terminate:

			{
				//
				// Reset the timeout counter and reference will be removed below
				//
				TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Timer cancelled or terminated") );

				NdisAcquireSpinLock( &pCall->lockCall );
	
				pCall->nNumTimeouts = 0;
	
				NdisReleaseSpinLock( &pCall->lockCall );

			}
			
			break;
	}

	if ( fDropCall )
	{
		NDIS_TAPI_DROP DummyRequest;

		TRACE( TL_N, TM_Fsm, ("FsmOfferingTimeout: Dropping call") );
				
		DummyRequest.hdCall = pCall->hdCall;
						
		//
		// Drop will take care of unbinding and cancelling the timer
		//
		TpDropCall( pCall->pLine->pAdapter, &DummyRequest, 0 );

	}

	DereferenceCall( pCall );

	TRACE( TL_N, TM_Fsm, ("-FsmOfferingTimeout") );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\miniport.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    miniport.c

Abstract:

    This module contains all the Miniport interface processing routines.  

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/
#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"
#include "fsm.h"

//
// This is our global adapter context
//
ADAPTER* gl_pAdapter = NULL;

//
// Lock that controls access to gl_pAdapter.
// This lock is necesarry for requests submitted from the bindings as
// they will not know if the adapter is halted or not.
//
NDIS_SPIN_LOCK gl_lockAdapter;

//
// We need a flag to indicate if lock is allocated or not
//
BOOLEAN gl_fLockAllocated = FALSE;

//
// The timer queue that handles the scheduled timer events.
//
TIMERQ gl_TimerQ;

//
// This is used to create a unique identifier in packets
//
ULONG gl_UniqueCounter = 0;

VOID
CreateUniqueValue( 
    IN HDRV_CALL hdCall,
    OUT CHAR* pUniqueValue,
    OUT USHORT* pSize
    )
{
    CHAR* pBuf = pUniqueValue;
    ULONG usUniqueValue = InterlockedIncrement( &gl_UniqueCounter );
    
    NdisMoveMemory( pBuf, (CHAR*) &hdCall, sizeof( HDRV_CALL ) );

    pBuf += sizeof( HDRV_CALL );

    NdisMoveMemory( pBuf, (CHAR*) &usUniqueValue, sizeof( ULONG ) );
    
    *pSize = sizeof( HDRV_CALL ) + sizeof( ULONG );

}

HDRV_CALL
RetrieveHdCallFromUniqueValue(
    IN CHAR* pUniqueValue,
    IN USHORT Size
    )
{
    
    if ( Size != sizeof( HDRV_CALL ) + sizeof( ULONG ) )
        return (HDRV_CALL) NULL;

    return ( * (UNALIGNED HDRV_CALL*) pUniqueValue );
}
    

////////////////////////////////////
//
// Local function prototypes
//
////////////////////////////////////

VOID 
ReferenceAdapter(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    );

VOID DereferenceAdapter(
    IN ADAPTER* pAdapter
    );

ADAPTER* AllocAdapter();

VOID FreeAdapter( 
    ADAPTER* pAdapter
    );

NDIS_STATUS MpInitialize(
    OUT PNDIS_STATUS  OpenErrorStatus,
    OUT PUINT  SelectedMediumIndex,
    IN PNDIS_MEDIUM  MediumArray,
    IN UINT  MediumArraySize,
    IN NDIS_HANDLE  MiniportAdapterHandle,
    IN NDIS_HANDLE  WrapperConfigurationContext
    );

VOID MpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS MpReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS MpWanSend(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_HANDLE  NdisLinkHandle,
    IN PNDIS_WAN_PACKET  WanPacket
    );

NDIS_STATUS MpQueryInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    );

NDIS_STATUS MpSetInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    );

////////////////////////////////////
//
// Interface functions definitions
//
////////////////////////////////////

NDIS_STATUS 
MpRegisterMiniport(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath,
    OUT NDIS_HANDLE* pNdisWrapperHandle
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called from DriverEntry() to register the miniport
    and create an instance of the adapter.
    
Parameters:

    DriverObject _ Pointer to driver object created by the system.

    RegistryPath _ Pointer to registery path name used to read registry
                   parameters.
    
Return Values:

    NDIS_STATUS_SUCCESFUL: Miniport registered succesfully.

    NDIS_STATUS_FAILURE: Miniport failed to register succesfully.
---------------------------------------------------------------------------*/
{
    NDIS_HANDLE NdisWrapperHandle;
    NDIS_STATUS status;
    NDIS_MINIPORT_CHARACTERISTICS nmc;

    TRACE( TL_I, TM_Mp, ("+MpRegisterMiniport") );

    NdisMInitializeWrapper( &NdisWrapperHandle,
                            pDriverObject,
                            pRegistryPath,
                            NULL );

    //
    // Fill in the miniport characteristics
    //
    NdisZeroMemory( &nmc, sizeof( NDIS_MINIPORT_CHARACTERISTICS ) );

    nmc.MajorNdisVersion = MP_NDIS_MajorVersion;
    nmc.MinorNdisVersion = MP_NDIS_MinorVersion;
    nmc.Reserved = NDIS_USE_WAN_WRAPPER;

    nmc.InitializeHandler = MpInitialize;
    nmc.ResetHandler = MpReset;
    nmc.HaltHandler = MpHalt;
    nmc.QueryInformationHandler = MpQueryInformation;
    nmc.SetInformationHandler = MpSetInformation;
    nmc.WanSendHandler = MpWanSend;
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    // no HandleInterruptHandler
    // no ISRHandler
    // no SendHandler (see WanSendHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler
    // no ReturnPacketHandler
    // no SendPacketsHandler (see WanSendHandler)
    // no AllocateCompleteHandler
    // no CoActivateVcHandler
    // no CoDeactivateVcHandler
    // no CoSendPacketsHandler 
    // no CoRequestHandler
        
    //
    // Set the characteristics registering the miniport
    //
    status = NdisMRegisterMiniport( NdisWrapperHandle,
                                    &nmc,
                                    sizeof( NDIS_MINIPORT_CHARACTERISTICS ) );

    //
    // If registeration of miniport was not successful,
    // undo the initialization of wrapper
    //
    if ( status != NDIS_STATUS_SUCCESS )
    {
        NdisTerminateWrapper( NdisWrapperHandle, NULL );
    }
    else
    {
        *pNdisWrapperHandle = NdisWrapperHandle;
    }

    TRACE( TL_I, TM_Mp, ("-MpRegisterMiniport=$%x",status) );
        
    return status;
}



////////////////////////////////////
//
// Local function definitions
//
////////////////////////////////////

VOID 
ReferenceAdapter(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the adapter object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             call, otherwise it will assume the caller owns the lock.
    
Parameters:

    pAdapter _ A pointer to our call information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_V, TM_Mp, ("+ReferenceAdapter") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = ++pAdapter->lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_V, TM_Mp, ("-ReferenceAdapter=$%d",lRef) );
}

VOID 
DereferenceAdapter(
    IN ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the adapter object

    If the ref count drops to 0 (which means the adapter has been halted),
    it will set fire pAdapter->eventAdapterHalted. 

Parameters:

    pAdapter _ A pointer ot our call information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    LONG lRef;
    BOOLEAN fSignalAdapterHaltedEvent = FALSE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_V, TM_Mp, ("+DereferenceAdapter") );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = --pAdapter->lRef;
    
    if ( lRef == 0 )
    {

        pAdapter->ulMpFlags &= ~MPBF_MiniportInitialized;
        pAdapter->ulMpFlags &= ~MPBF_MiniportHaltPending;
        pAdapter->ulMpFlags |= MPBF_MiniportHalted;
                    
        fSignalAdapterHaltedEvent = TRUE;
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );


    //
    // Signal the halting of the adapter if we need to
    //
    if ( fSignalAdapterHaltedEvent )
        NdisSetEvent( &pAdapter->eventAdapterHalted );

    TRACE( TL_V, TM_Mp, ("-DereferenceAdapter=$%x",lRef) );
}

ADAPTER* 
AllocAdapter()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will allocate the resources for the adapter object and return
    a pointer to it.
    
Parameters:

    None
    
Return Values:

    pAdapter: A pointer to the newly allocated adapter object.
    
    NULL: Resources were not available to create the adapter.
    
---------------------------------------------------------------------------*/
{
    ADAPTER* pAdapter = NULL;

    TRACE( TL_N, TM_Mp, ("+AllocAdapter") );

    if ( ALLOC_ADAPTER( &pAdapter ) != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Mp, ("AllocAdapter: Could not allocate context") );

        TRACE( TL_N, TM_Mp, ("-AllocAdapter") );

        return NULL;
    }

    //
    // Clear the memory 
    //
    NdisZeroMemory( pAdapter, sizeof( ADAPTER ) );

    //
    // Initialize adapter tag
    //
    pAdapter->tagAdapter = MTAG_ADAPTER;
        
    //
    // Allocate the lock that controls access to the adapter
    //
    NdisAllocateSpinLock( &pAdapter->lockAdapter );

    //
    // Initialize the state
    //
    pAdapter->ulMpFlags = MPBF_MiniportIdle;

    TRACE( TL_N, TM_Mp, ("-AllocAdapter") );

    return pAdapter;
}

NDIS_STATUS
ReadRegistrySettings(
    IN OUT ADAPTER* pAdapter,
    IN     NDIS_HANDLE WrapperConfigurationContext
    )
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    NDIS_HANDLE hCfg = 0;
    NDIS_CONFIGURATION_PARAMETER* pncp = 0;
    BOOLEAN fMaxLinesDefinedInRegistry = FALSE;

    TRACE( TL_N, TM_Mp, ("+ReadRegistrySettings") );

    do
    {
        //
        // Open the Ndis configuration, it will be closed at the end of the
        // while loop before we exit it. 
        //
        NdisOpenConfiguration( &status, 
                               &hCfg, 
                               WrapperConfigurationContext );

        if ( status != NDIS_STATUS_SUCCESS )
        {
            TRACE( TL_A, TM_Mp, ("ReadRegistrySettings: NdisOpenConfiguration() failed") );

            break;
        }

        //
        // Read fClientRole value from the registry
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "fClientRole" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read fClientRole from registry") );

                pAdapter->fClientRole = ( pncp->ParameterData.IntegerData > 0 ) ? TRUE : FALSE;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read fClientRole from registry, using default value") );

                pAdapter->fClientRole = TRUE;

                status = NDIS_STATUS_SUCCESS;
            }

        }

        //
        // Read ServiceName and ServiceNameLength values from the registry.
        // These are server side only values.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ServiceName" );


            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterString );

            if (status == NDIS_STATUS_SUCCESS)
            {
                ANSI_STRING AnsiString;

                NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                
                status = RtlUnicodeStringToAnsiString( &AnsiString, &pncp->ParameterData.StringData, TRUE );

                if ( status == STATUS_SUCCESS )
                {
                    TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read ServiceName from registry") );

                    pAdapter->nServiceNameLength = ( MAX_SERVICE_NAME_LENGTH < AnsiString.Length ) ? 
                                                     MAX_SERVICE_NAME_LENGTH : AnsiString.Length;

                    NdisMoveMemory( pAdapter->ServiceName, AnsiString.Buffer, pAdapter->nServiceNameLength ) ;

                    RtlFreeAnsiString( &AnsiString );
                }
                
            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                PWSTR wszKeyName = L"ComputerName";
                PWSTR wszPath = L"ComputerName\\ComputerName";
                RTL_QUERY_REGISTRY_TABLE QueryTable[2];
                UNICODE_STRING UnicodeStr;
                WCHAR wszName[ MAX_COMPUTERNAME_LENGTH + 1];
    
                NdisZeroMemory( QueryTable, 2 * sizeof( RTL_QUERY_REGISTRY_TABLE ) );
                
                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].Name = wszKeyName;
                QueryTable[0].EntryContext = (PVOID) &UnicodeStr;
                
                NdisZeroMemory( &UnicodeStr, sizeof( UNICODE_STRING ) );
    
                UnicodeStr.Length = 0;
                UnicodeStr.MaximumLength = MAX_COMPUTERNAME_LENGTH + 1;
                UnicodeStr.Buffer = wszName;
    
                status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, 
                                                 wszPath,
                                                 QueryTable,
                                                 NULL,
                                                 NULL );
    
                if ( status == STATUS_SUCCESS )
                {
                    ANSI_STRING AnsiString;
    
                    NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                    
                    status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeStr, TRUE );
    
                    if ( status == STATUS_SUCCESS )
                    {
                        TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using Machine Name as ServiceName") );
    
                        NdisMoveMemory( pAdapter->ServiceName, AnsiString.Buffer, AnsiString.Length );
    
                        NdisMoveMemory( pAdapter->ServiceName + AnsiString.Length, 
                                        SERVICE_NAME_EXTENSION, 
                                        sizeof( SERVICE_NAME_EXTENSION ) );
    
                        //
                        // -1 is to ignore the terminating NULL character
                        //
                        pAdapter->nServiceNameLength = AnsiString.Length + sizeof( SERVICE_NAME_EXTENSION ) - 1;
    
                        RtlFreeAnsiString( &AnsiString );
    
                        status = NDIS_STATUS_SUCCESS;
                    }
                }

            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using default hardcoded service name") );

                NdisMoveMemory( pAdapter->ServiceName, "MS-RAS PPPoE", sizeof( "MS-RAS PPPoE" ) );

                pAdapter->nServiceNameLength = ( sizeof( "MS-RAS PPPoE" ) / sizeof( CHAR ) ) - 1;

                status = NDIS_STATUS_SUCCESS;
            }

            //
            // Future: Convert service name to UTF-8
            //         It turns out that we can not do this conversion from a kernel module,
            //         so the value read from the registry must be in UTF-8 format itself.
            //
            
        }

        //
        // Read AC-Name and AC-NameLength values from the registry.
        // These are server side only values.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ACName" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterString );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                ANSI_STRING AnsiString;

                NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                
                status = RtlUnicodeStringToAnsiString( &AnsiString, &pncp->ParameterData.StringData, TRUE );

                if ( status == STATUS_SUCCESS )
                {
                    TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read AC-Name from registry") );
                    
                    pAdapter->nACNameLength = ( MAX_AC_NAME_LENGTH < AnsiString.Length ) ? 
                                                MAX_AC_NAME_LENGTH : AnsiString.Length;
                                                     
                    NdisMoveMemory( pAdapter->ACName, AnsiString.Buffer, pAdapter->nACNameLength ) ;
                
                    RtlFreeAnsiString( &AnsiString );

                }
                
            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                PWSTR wszKeyName = L"ComputerName";
                PWSTR wszPath = L"ComputerName\\ComputerName";
                RTL_QUERY_REGISTRY_TABLE QueryTable[2];
                UNICODE_STRING UnicodeStr;
                WCHAR wszName[ MAX_COMPUTERNAME_LENGTH + 1];
    
                NdisZeroMemory( QueryTable, 2 * sizeof( RTL_QUERY_REGISTRY_TABLE ) );
                
                QueryTable[0].QueryRoutine = NULL;
                QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_DIRECT;
                QueryTable[0].Name = wszKeyName;
                QueryTable[0].EntryContext = (PVOID) &UnicodeStr;
                
                NdisZeroMemory( &UnicodeStr, sizeof( UNICODE_STRING ) );
    
                UnicodeStr.Length = 0;
                UnicodeStr.MaximumLength = MAX_COMPUTERNAME_LENGTH + 1;
                UnicodeStr.Buffer = wszName;
    
                status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, 
                                                 wszPath,
                                                 QueryTable,
                                                 NULL,
                                                 NULL );
    
                if ( status == STATUS_SUCCESS )
                {
                    ANSI_STRING AnsiString;
    
                    NdisZeroMemory( &AnsiString, sizeof( ANSI_STRING ) );
                    
                    status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeStr, TRUE );
    
                    if ( status == STATUS_SUCCESS )
                    {
                        TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using Machine Name as AC-Name") );
    
                        NdisMoveMemory( pAdapter->ACName, AnsiString.Buffer, AnsiString.Length );
    
                        pAdapter->nACNameLength = AnsiString.Length;
    
                        RtlFreeAnsiString( &AnsiString );
    
                        status = NDIS_STATUS_SUCCESS;
                    }
                }

            }

            if ( status != NDIS_STATUS_SUCCESS )
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Using default hardcoded value for AC-Name") );

                NdisMoveMemory( pAdapter->ACName, "MS-RAS Access Concentrator", sizeof( "MS-RAS Access Concentrator" ) );

                pAdapter->nACNameLength = ( sizeof( "MS-RAS Access Concentrator" ) / sizeof( CHAR ) ) - 1;

                status = NDIS_STATUS_SUCCESS;
            }

            //
            // Future: Convert AC name to UTF-8
            //         It turns out that we can not do this conversion from a kernel module,
            //         so the value read from the registry must be in UTF-8 format itself.
            //
            
        }

        //
        // Read nClientQuota value
        // These is a server side only value.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ClientQuota" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read ClientQuota from registry") );

                pAdapter->nClientQuota = (UINT) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read ClientQuota from registry, using default value") );
                
                pAdapter->nClientQuota = 3;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read MaxLines value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxLines" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read MaxLines from registry") );

                pAdapter->nMaxLines = (UINT) pncp->ParameterData.IntegerData;

                fMaxLinesDefinedInRegistry = TRUE;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read MaxLines from registry, using default value") );
                
                pAdapter->nMaxLines = 1;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read CallsPerLine value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "CallsPerLine" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read CallsPerLine from registry") );

                pAdapter->nCallsPerLine = (UINT) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read CallsPerLine from registry, using default value") );
                
                pAdapter->nCallsPerLine = 1;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read WanEndPoints if MaxLines was not defined in registry
        //
        if ( !fMaxLinesDefinedInRegistry )
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "WanEndPoints" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read WanEndPoints from registry") );

                pAdapter->nMaxLines = 1;

                pAdapter->nCallsPerLine = (UINT) pncp->ParameterData.IntegerData;
            }

            status = NDIS_STATUS_SUCCESS;
        }

        //
        // Read MaxTimeouts value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxTimeouts" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read MaxTimeouts from registry") );

                pAdapter->nMaxTimeouts = (UINT) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read MaxTimeouts from registry, using default value") );

                pAdapter->nMaxTimeouts = 3;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read SendTimeout value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "SendTimeout" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read SendTimeout from registry") );

                pAdapter->ulSendTimeout = (ULONG) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read SendTimeout from registry, using default value") );
                
                pAdapter->ulSendTimeout = 5000;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read RecvTimeout value
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "RecvTimeout" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read RecvTimeout from registry") );

                pAdapter->ulRecvTimeout = (ULONG) pncp->ParameterData.IntegerData;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read RecvTimeout from registry, using default value") );
                
                pAdapter->ulRecvTimeout = 5000;

                status = NDIS_STATUS_SUCCESS;
            }
        }

        //
        // Read fAcceptAnyService value from the registry
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "fAcceptAnyService" );

            NdisReadConfiguration( &status, 
                                   &pncp, 
                                   hCfg, 
                                   &nstr, 
                                   NdisParameterInteger );
                                   
            if (status == NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Read fAcceptAnyService from registry") );

                pAdapter->fAcceptAnyService = ( pncp->ParameterData.IntegerData > 0 ) ? TRUE : FALSE;
            }
            else
            {
                TRACE( TL_N, TM_Mp, ("ReadRegistrySettings: Could not read fAcceptAnyService from registry, using default value") );

                pAdapter->fAcceptAnyService = TRUE;

                status = NDIS_STATUS_SUCCESS;
            }

        }

        //
        // Close the Ndis configuration
        //
        NdisCloseConfiguration( hCfg );
        
    } while ( FALSE );

    TRACE( TL_N, TM_Mp, ("-ReadRegistrySettings=$%x",status) );

    return status;
}

NDIS_STATUS 
InitializeAdapter(
    IN ADAPTER* pAdapter,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will initialize the contents of the adapter object.

    It will be called from inside MpInitialize() and it will read the necesarry
    values from the registry to initialize the adapter context.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Mp, ("+InitializeAdapter") );

    //
    // Initialize and reset the adapter halted event
    //
    NdisInitializeEvent( &pAdapter->eventAdapterHalted );

    NdisResetEvent( &pAdapter->eventAdapterHalted );

    //
    // Set the state
    //
    pAdapter->ulMpFlags = MPBF_MiniportInitialized;

    //
    // Set NDIS's corresponding handle 
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    //
    // Read values from registry
    //
    status = ReadRegistrySettings( pAdapter, WrapperConfigurationContext );
    
    pAdapter->nMaxSendPackets = 1;

    //
    // Initialize the NdisWanInfo structure
    //
    pAdapter->NdisWanInfo.MaxFrameSize     = PACKET_PPP_PAYLOAD_MAX_LENGTH;
    pAdapter->NdisWanInfo.MaxTransmit      = 1;
    pAdapter->NdisWanInfo.HeaderPadding    = PPPOE_PACKET_HEADER_LENGTH;
    pAdapter->NdisWanInfo.TailPadding      = 0;
    pAdapter->NdisWanInfo.Endpoints        = pAdapter->nCallsPerLine * pAdapter->nMaxLines;
    pAdapter->NdisWanInfo.MemoryFlags      = 0;
    pAdapter->NdisWanInfo.HighestAcceptableAddress = HighestAcceptableAddress;
    pAdapter->NdisWanInfo.FramingBits      = PPP_FRAMING |
                                             // PPP_COMPRESS_ADDRESS_CONTROL |
                                             // PPP_COMPRESS_PROTOCOL_FIELD |
                                             TAPI_PROVIDER;
    pAdapter->NdisWanInfo.DesiredACCM      = 0;
    
    TRACE( TL_N, TM_Mp, ("-InitializeAdapter=$%x",status) );

    return status;
}

VOID 
FreeAdapter( 
    ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will deallocate the resources for the adapter object.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Mp, ("+FreeAdapter") );

    NdisFreeSpinLock( &pAdapter->lockAdapter );

    FREE_ADAPTER( pAdapter );

    TRACE( TL_N, TM_Mp, ("-FreeAdapter") );

}

NDIS_STATUS 
MpInitialize(
    OUT PNDIS_STATUS  OpenErrorStatus,
    OUT PUINT  SelectedMediumIndex,
    IN PNDIS_MEDIUM  MediumArray,
    IN UINT  MediumArraySize,
    IN NDIS_HANDLE  MiniportAdapterHandle,
    IN NDIS_HANDLE  WrapperConfigurationContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportInitialize request is called to have the Miniport driver
    initialize the adapter.

    No other request will be outstanding on the Miniport when this routine
    is called.  No other request will be submitted to the Miniport until
    the operation is completed.

    The wrapper will supply an array containing a list of the media types
    that it supports.  The Miniport driver reads this array and returns
    the index of the media type that the wrapper should treat her as.
    If the Miniport driver is impersonating a media type that is different
    from the true media type, this must be done completely transparently to
    the wrapper.

    If the Miniport driver cannot find a media type supported by both it
    and the wrapper, it returns NDIS_STATUS_UNSUPPORTED_MEDIA.

    The status value NDIS_STATUS_OPEN_ERROR has a special meaning.  It
    indicates that the OpenErrorStatus parameter has returned a valid status
    which the wrapper can examine to obtain more information about the error.

    This routine is called with interrupts enabled, and a call to MiniportISR
    will occur if the adapter generates any interrupts.  During this routine
    MiniportDisableInterrupt and MiniportEnableInterrupt will not be called,
    so it is the responsibility of the Miniport driver to acknowledge and
    clear any interrupts generated.

    This routine will be called from the context of MpRegisterMiniport().

Parameters:

    OpenErrorStatus _ Returns more information about the reason for the
                      failure. Currently, the only values defined match those
                      specified as Open Error Codes in Appendix B of the IBM
                      Local Area Network Technical Reference.

    SelectedMediumIndex _ Returns the index in MediumArray of the medium type
                          that the Miniport driver wishes to be viewed as.
                          Note that even though the NDIS interface may complete
                          this request asynchronously, it must return this
                          index on completion of this function.

    MediumArray _ An array of medium types which the wrapper supports.

    MediumArraySize _ The number of elements in MediumArray.

    MiniportAdapterHandle _ A handle identifying the Miniport. The Miniport
                            driver must supply this handle in future requests
                            that refer to the Miniport.

    WrapperConfigurationContext _ The handle used for calls to NdisOpenConfiguration.

Return Values:

    NDIS_STATUS_ADAPTER_NOT_FOUND
    NDIS_STATUS_FAILURE
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_OPEN_ERROR
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_UNSUPPORTED_MEDIA

---------------------------------------------------------------------------*/    
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    ADAPTER* pAdapter = NULL;
    UINT i;

    TRACE( TL_I, TM_Mp, ("+MpInitialize") );

    do
    {
        //
        // Select the medium
        //
        for (i=0; i<MediumArraySize; i++)
        {
            if ( MediumArray[i] == NdisMediumWan )
                break;
        }

        //
        // Check if we have found a medium supported
        //
        if ( i < MediumArraySize )
        {
            *SelectedMediumIndex = i;
        }
        else
        {
            TRACE( TL_A, TM_Mp, ("MpInitialize: Unsupported Media") );

            status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            
            break;
        }
    
        //
        // Allocate the adapter block
        //
        pAdapter = AllocAdapter();
        
        if ( pAdapter == NULL )
        {
            TRACE( TL_A, TM_Mp, ("MpInitialize: Resources unavailable") );

            status = NDIS_STATUS_FAILURE;
            
            break;
        }

        //
        // Initialize the adapter
        //
        status = InitializeAdapter( pAdapter, 
                                    MiniportAdapterHandle, 
                                    WrapperConfigurationContext );

        if ( status != NDIS_STATUS_SUCCESS )
        {
            TRACE( TL_A, TM_Mp, ("MpInitialize: InitializeAdapter() failed") );
            
            break;
        }
            
        //
        // Inform NDIS about our miniport adapter context
        //
        NdisMSetAttributesEx(MiniportAdapterHandle,
                             pAdapter,
                             0,
                             NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                             NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                             NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND |
                             NDIS_ATTRIBUTE_DESERIALIZE,
                             NdisInterfaceInternal );

        //
        // Do the global initialization
        //
        gl_pAdapter = pAdapter;

        //
        // Allocate the packet pools
        //
        PacketPoolInit();

        //
        // Do one-time only initialization of global members
        //
        if ( !gl_fLockAllocated )
        {
            //
            // Allocate the spin lock
            //
            NdisAllocateSpinLock( &gl_lockAdapter );

            //
            // Initialize the timer queue
            //
            TimerQInitialize( &gl_TimerQ );

            //
            // Finally set lock allocated flag, and start giving access
            // to the adapter context for requests from the protocol
            //
            gl_fLockAllocated = TRUE;
        }
            
        //
        // Reference the adapter for initialization.
        // This reference will be removed in MpHalt().
        //
        ReferenceAdapter( pAdapter, TRUE );

    } while ( FALSE );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        if ( pAdapter != NULL )
        {
            FreeAdapter( pAdapter );
        }
    }

    TRACE( TL_I, TM_Mp, ("-MpInitialize=$%x",status) );

    return status;
}

VOID 
MpHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportHalt request is used to halt the adapter such that it is
    no longer functioning.  The Miniport driver should stop the adapter
    and deregister all of its resources before returning from this routine.

    It is not necessary for the Miniport to complete all outstanding
    requests and no other requests will be submitted to the Miniport
    until the operation is completed.

    Interrupts are enabled during the call to this routine.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

Return Values:

    None.

---------------------------------------------------------------------------*/   
{
    ADAPTER* pAdapter = MiniportAdapterContext;

    TRACE( TL_I, TM_Mp, ("+MpHalt") );

    //
    // Make sure adapter context is a valid one
    //
    if ( !VALIDATE_ADAPTER( pAdapter ) )
    {
        TRACE( TL_I, TM_Mp, ("-MpHalt") );

        return;
    }

    //
    // Lock the adapter and set halt pending bit
    //
    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    pAdapter->ulMpFlags |= MPBF_MiniportHaltPending;

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    //
    // Shutdown the tapi provider
    //
    {
        NDIS_TAPI_PROVIDER_SHUTDOWN DummyRequest;

        NdisZeroMemory( &DummyRequest, sizeof( NDIS_TAPI_PROVIDER_SHUTDOWN ) );

        TpProviderShutdown( pAdapter, &DummyRequest, FALSE);

    }

    //
    // Remove the reference added in MpInitialize()
    //
    DereferenceAdapter( pAdapter );

    //
    // Wait for all references to be removed
    //
    NdisWaitEvent( &pAdapter->eventAdapterHalted, 0 );

    //
    // All references have been removed, now wait for all packets owned by NDIS
    // to be returned.
    //
    // Note that no synchronization is necesarry for reading the value of NumPacketsOwnedByNdis
    // at this point since it can only be incremented when there is at least 1 reference on the 
    // binding - at this point ref count is 0 -, and because it can not be incremented, it can 
    // only reach 0 once.
    //
    while ( pAdapter->NumPacketsOwnedByNdiswan )
    {
        NdisMSleep( 10000 );
    }

    //
    // Do deallocation of global resources first
    //
    NdisAcquireSpinLock( &gl_lockAdapter );

    gl_pAdapter = NULL;

    PacketPoolUninit();

    NdisReleaseSpinLock( &gl_lockAdapter );

    //
    // Now we can clean up the adapter context
    //
    FreeAdapter( pAdapter );
    
    TRACE( TL_I, TM_Mp, ("-MpHalt") );
}

NDIS_STATUS 
MpReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportReset request instructs the Miniport driver to issue a
    hardware reset to the network adapter.  The Miniport driver also
    resets its software state.

    The MiniportReset request may also reset the parameters of the adapter.
    If a hardware reset of the adapter resets the current station address
    to a value other than what it is currently configured to, the Miniport
    driver automatically restores the current station address following the
    reset.  Any multicast or functional addressing masks reset by the
    hardware do not have to be reprogrammed by the Miniport.
    NOTE: This is change from the NDIS 3.0 driver specification.  If the
    multicast or functional addressing information, the packet filter, the
    lookahead size, and so on, needs to be restored, the Miniport indicates
    this with setting the flag AddressingReset to TRUE.

    It is not necessary for the Miniport to complete all outstanding requests
    and no other requests will be submitted to the Miniport until the
    operation is completed.  Also, the Miniport does not have to signal
    the beginning and ending of the reset with NdisMIndicateStatus.
    NOTE: These are different than the NDIS 3.0 driver specification.

    The Miniport driver must complete the original request, if the orginal
    call to MiniportReset return NDIS_STATUS_PENDING, by calling
    NdisMResetComplete.

    If the underlying hardware does not provide a reset function under
    software control, then this request completes abnormally with
    NDIS_STATUS_NOT_RESETTABLE.  If the underlying hardware attempts a
    reset and finds recoverable errors, the request completes successfully
    with NDIS_STATUS_SOFT_ERRORS.  If the underlying hardware resets and,
    in the process, finds nonrecoverable errors, the request completes
    successfully with the status NDIS_STATUS_HARD_ERRORS.  If the
    underlying  hardware reset is accomplished without any errors,
    the request completes successfully with the status NDIS_STATUS_SUCCESS.

    Interrupts are in any state during this call.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

    AddressingReset _ The Miniport indicates if the wrapper needs to call
                      MiniportSetInformation to restore the addressing
                      information to the current values by setting this
                      value to TRUE.

Return Values:

    NDIS_STATUS_HARD_ERRORS
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_RESETTABLE
    NDIS_STATUS_PENDING
    NDIS_STATUS_SOFT_ERRORS
    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/    
{
    TRACE( TL_I, TM_Mp, ("+MpReset") );

    TRACE( TL_I, TM_Mp, ("-MpReset") );

    return NDIS_STATUS_NOT_RESETTABLE;
}

NDIS_STATUS 
MpWanSend(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_HANDLE  NdisLinkHandle,
    IN PNDIS_WAN_PACKET  WanPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The Ndis(M)WanSend instructs a WAN driver to transmit a packet through the
    adapter onto the medium.

    Ownership of both the packet descriptor and the packet data is transferred
    to the WAN driver until the request is completed, either synchronously or
    asynchronously.  If the WAN driver returns a status other than
    NDIS_STATUS_PENDING, then the request is complete, and ownership of the
    packet immediately reverts to the protocol.  If the WAN driver returns
    NDIS_STATUS_PENDING, then the WAN driver must later indicate completion
    of the request by calling Ndis(M)WanSendComplete.

    The WAN driver should NOT return a status of NDIS_STATUS_RESOURCES to
    indicate that there are not enough resources available to process the
    transmit.  Instead, the miniport should queue the send for a later time
    or lower the MaxTransmits value.

    The WAN miniport can NOT call NdisMSendResourcesAvailable.

    The packet passed in Ndis(M)WanSend will contain simple HDLC PPP framing
    if PPP framing is set.  For SLIP or RAS framing, the packet contains only
    the data portion with no framing whatsoever.

    A WAN driver must NOT provide software loopback or promiscuous mode
    loopback.  Both of these are fully provided for in the WAN wrapper.

    NOTE: The MacReservedx section as well as the WanPacketQueue section of
          the NDIS_WAN_PACKET is fully available for use by the WAN driver.

    Interrupts are in any state during this routine.

Parameters:

    MacBindingHandle _ The handle to be passed to NdisMWanSendComplete().

    NdisLinkHandle _ The Miniport link handle passed to NDIS_LINE_UP

    WanPacket _ A pointer to the NDIS_WAN_PACKET strucutre.  The structure
                contains a pointer to a contiguous buffer with guaranteed
                padding at the beginning and end.  The driver may manipulate
                the buffer in any way.

    typedef struct _NDIS_WAN_PACKET
    {
        LIST_ENTRY          WanPacketQueue;
        PUCHAR              CurrentBuffer;
        ULONG               CurrentLength;
        PUCHAR              StartBuffer;
        PUCHAR              EndBuffer;
        PVOID               ProtocolReserved1;
        PVOID               ProtocolReserved2;
        PVOID               ProtocolReserved3;
        PVOID               ProtocolReserved4;
        PVOID               MacReserved1;       // Link
        PVOID               MacReserved2;       // MacBindingHandle
        PVOID               MacReserved3;
        PVOID               MacReserved4;

    } NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;

    The available header padding is simply CurrentBuffer-StartBuffer.
    The available tail padding is EndBuffer-(CurrentBuffer+CurrentLength).

Return Values:

    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE

---------------------------------------------------------------------------*/    
{
    ADAPTER* pAdapter = MiniportAdapterContext;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;
    BINDING* pBinding = NULL;
    PPPOE_PACKET* pPacket = NULL;
    BOOLEAN fTapiProvReferenced = FALSE;

    TRACE( TL_V, TM_Mp, ("+MpWanSend($%x,$%x,$%x)",MiniportAdapterContext,NdisLinkHandle,WanPacket) );

    do
    {
        //
        // Make sure adapter context is a valid one
        //
        if ( !VALIDATE_ADAPTER( pAdapter ) )
        {
            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Invalid adapter handle supplied",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   
        
            break;
        }

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        //
        // Make sure the handle table will not be freed as long as we need it 
        // in this function
        //
        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
              ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            fTapiProvReferenced = TRUE;

            ReferenceTapiProv( pAdapter, FALSE );
        }
        else
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Tapi provider not initialized, or shutting down",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   
            break;
        }

        //
        // Map the handle to the pointer for the call context
        //
        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, NdisLinkHandle );

        if ( pCall == NULL )
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Invalid call handle supplied",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   

            break;
        }

        NdisAcquireSpinLock( &pCall->lockCall );

        if ( pCall->pBinding == NULL )
        {
            NdisReleaseSpinLock( &pCall->lockCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
            
            TRACE( TL_A, TM_Tp, ("MpWanSend($%x,$%x,$%x): Binding not found",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   

            break;
        }

        status = PacketInitializePAYLOADToSend( &pPacket,
                                                pCall->SrcAddr,
                                                pCall->DestAddr,
                                                pCall->usSessionId,
                                                WanPacket,
                                                pCall->pLine->pAdapter );

        if ( status != NDIS_STATUS_SUCCESS )
        {
            NdisReleaseSpinLock( &pCall->lockCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
            
            TRACE( TL_N, TM_Tp, ("MpWanSend($%x,$%x,$%x): Could not init payload packet to send",
                                MiniportAdapterContext,
                                NdisLinkHandle,
                                WanPacket) );   

            break;
        }

        pBinding = pCall->pBinding;
        
        ReferenceBinding( pBinding, TRUE );
        
        //
        // Reference the packet so that if PrSend() pends,
        // packet still exists around
        //
        ReferencePacket( pPacket );                                                 

        //
        // Release the locks to send the packet
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Packet is ready, so send it
        //
        status = PrSend( pBinding, pPacket );

        //
        // Since the result of send will always be completed by a call to NdisMWanSendComplete(),
        // we have to return NDIS_STATUS_PENDING from this function.
        //
        status = NDIS_STATUS_PENDING;

        //
        // We can free the packet as we have a reference on the packet
        //
        PacketFree( pPacket );

    } while ( FALSE );

    //
    // If a reference is added on the tapi provider, remove it
    //
    if ( fTapiProvReferenced )
    {
        DereferenceTapiProv( pAdapter );
    }
    
    TRACE( TL_V, TM_Mp, ("-MpWanSend($%x,$%x,$%x)=$%x",MiniportAdapterContext,NdisLinkHandle,WanPacket,status) );

    return status;

}

typedef struct
_SUPPORTED_OIDS
{
    NDIS_OID ndisOid;
    CHAR szOidName[64];
}
SUPPORTED_OIDS;

SUPPORTED_OIDS
SupportedOidsArray[] = {

    {   OID_GEN_CURRENT_LOOKAHEAD,      "OID_GEN_CURRENT_LOOKAHEAD"     }, 
    {   OID_GEN_DRIVER_VERSION,         "OID_GEN_DRIVER_VERSION"        },
    {   OID_GEN_HARDWARE_STATUS,        "OID_GEN_HARDWARE_STATUS"       },
    {   OID_GEN_LINK_SPEED,             "OID_GEN_LINK_SPEED"            },
    {   OID_GEN_MAC_OPTIONS,            "OID_GEN_MAC_OPTIONS"           },
    {   OID_GEN_MAXIMUM_LOOKAHEAD,      "OID_GEN_MAXIMUM_LOOKAHEAD"     },
    {   OID_GEN_MAXIMUM_FRAME_SIZE,     "OID_GEN_MAXIMUM_FRAME_SIZE"    },
    {   OID_GEN_MAXIMUM_TOTAL_SIZE,     "OID_GEN_MAXIMUM_TOTAL_SIZE"    },
    {   OID_GEN_MEDIA_SUPPORTED,        "OID_GEN_MEDIA_SUPPORTED"       },
    {   OID_GEN_MEDIA_IN_USE,           "OID_GEN_MEDIA_IN_USE"          },
    {   OID_GEN_RCV_ERROR,              "OID_GEN_RCV_ERROR"             },
    {   OID_GEN_RCV_OK,                 "OID_GEN_RCV_OK"                },
    {   OID_GEN_RECEIVE_BLOCK_SIZE,     "OID_GEN_RECEIVE_BLOCK_SIZE"    },
    {   OID_GEN_RECEIVE_BUFFER_SPACE,   "OID_GEN_RECEIVE_BUFFER_SPACE"  },
    {   OID_GEN_SUPPORTED_LIST,         "OID_GEN_SUPPORTED_LIST"        },
    {   OID_GEN_TRANSMIT_BLOCK_SIZE,    "OID_GEN_TRANSMIT_BLOCK_SIZE"   },
    {   OID_GEN_TRANSMIT_BUFFER_SPACE,  "OID_GEN_TRANSMIT_BUFFER_SPACE" },
    {   OID_GEN_VENDOR_DESCRIPTION,     "OID_GEN_VENDOR_DESCRIPTION"    },
    {   OID_GEN_VENDOR_ID,              "OID_GEN_VENDOR_ID"             },
    {   OID_GEN_XMIT_ERROR,             "OID_GEN_XMIT_ERROR"            },
    {   OID_GEN_XMIT_OK,                "OID_GEN_XMIT_OK"               },

    {   OID_PNP_CAPABILITIES,           "OID_PNP_CAPABILITIES"          },
    {   OID_PNP_SET_POWER,              "OID_PNP_SET_POWER"             },
    {   OID_PNP_QUERY_POWER,            "OID_PNP_QUERY_POWER"           },
    {   OID_PNP_ENABLE_WAKE_UP,         "OID_PNP_ENABLE_WAKE_UP"        },

    {   OID_TAPI_CLOSE,                 "OID_TAPI_CLOSE"                },
    {   OID_TAPI_DROP,                  "OID_TAPI_DROP"                 },
    {   OID_TAPI_GET_ADDRESS_CAPS,      "OID_TAPI_GET_ADDRESS_CAPS"     },
    {   OID_TAPI_GET_ADDRESS_STATUS,    "OID_TAPI_GET_ADDRESS_STATUS"   },
    {   OID_TAPI_GET_CALL_INFO,         "OID_TAPI_GET_CALL_INFO"        },
    {   OID_TAPI_GET_CALL_STATUS,       "OID_TAPI_GET_CALL_STATUS"      },
    {   OID_TAPI_GET_DEV_CAPS,          "OID_TAPI_GET_DEV_CAPS"         },
    {   OID_TAPI_GET_EXTENSION_ID,      "OID_TAPI_GET_EXTENSION_ID"     },
    {   OID_TAPI_MAKE_CALL,             "OID_TAPI_MAKE_CALL"            },
    {   OID_TAPI_CLOSE_CALL,            "OID_TAPI_CLOSE_CALL"           },
    {   OID_TAPI_NEGOTIATE_EXT_VERSION, "OID_TAPI_NEGOTIATE_EXT_VERSION"},
    {   OID_TAPI_OPEN,                  "OID_TAPI_OPEN"                 },
    {   OID_TAPI_ANSWER,                "OID_TAPI_ANSWER"               },
    {   OID_TAPI_PROVIDER_INITIALIZE,   "OID_TAPI_PROVIDER_INITIALIZE"  },
    {   OID_TAPI_PROVIDER_SHUTDOWN,     "OID_TAPI_PROVIDER_SHUTDOWN"    },
    {   OID_TAPI_SET_STATUS_MESSAGES,   "OID_TAPI_SET_STATUS_MESSAGES"  },
    {   OID_TAPI_SET_DEFAULT_MEDIA_DETECTION, "OID_TAPI_SET_DEFAULT_MEDIA_DETECTION"    },

    {   OID_WAN_CURRENT_ADDRESS,        "OID_WAN_CURRENT_ADDRESS"       },
    {   OID_WAN_GET_BRIDGE_INFO,        "OID_WAN_GET_BRIDGE_INFO"       },
    {   OID_WAN_GET_COMP_INFO,          "OID_WAN_GET_COMP_INFO"         },
    {   OID_WAN_GET_INFO,               "OID_WAN_GET_INFO"              },
    {   OID_WAN_GET_LINK_INFO,          "OID_WAN_GET_LINK_INFO"         },
    {   OID_WAN_GET_STATS_INFO,         "OID_WAN_GET_STATS_INFO"        },
    {   OID_WAN_HEADER_FORMAT,          "OID_WAN_HEADER_FORMAT"         },
    {   OID_WAN_LINE_COUNT,             "OID_WAN_LINE_COUNT"            },
    {   OID_WAN_MEDIUM_SUBTYPE,         "OID_WAN_MEDIUM_SUBTYPE"        },
    {   OID_WAN_PERMANENT_ADDRESS,      "OID_WAN_PERMANENT_ADDRESS"     },
    {   OID_WAN_PROTOCOL_TYPE,          "OID_WAN_PERMANENT_ADDRESS"     },
    {   OID_WAN_QUALITY_OF_SERVICE,     "OID_WAN_QUALITY_OF_SERVICE"    },
    {   OID_WAN_SET_BRIDGE_INFO,        "OID_WAN_SET_BRIDGE_INFO"       },
    {   OID_WAN_SET_COMP_INFO,          "OID_WAN_SET_COMP_INFO"         },
    {   OID_WAN_SET_LINK_INFO,          "OID_WAN_SET_LINK_INFO"         },
    {   (NDIS_OID) 0,                   "UNKNOWN OID"                   }
};

CHAR* GetOidName(
    NDIS_OID Oid
    )
{
    //
    // Calculate the number of oids we support.
    // (Subtract one for unknown oid)
    //
    UINT nNumOids = ( sizeof( SupportedOidsArray ) / sizeof( SUPPORTED_OIDS ) ) - 1;
    UINT i;
    
    for ( i = 0; i < nNumOids; i++ )
    {
        if ( Oid == SupportedOidsArray[i].ndisOid )
            break;
    }

    return SupportedOidsArray[i].szOidName;
}

#define ENFORCE_SAFE_TOTAL_SIZE(mainStruct, embeddedStruct)                                                            \
   ((mainStruct*) InformationBuffer)->embeddedStruct.ulTotalSize = InformationBufferLength - FIELD_OFFSET(mainStruct, embeddedStruct)

#define RETRIEVE_NEEDED_AND_USED_LENGTH(mainStruct, embeddedStruct) \
   {                                                                                                                             \
      NeededLength = ((mainStruct*) InformationBuffer)->embeddedStruct.ulNeededSize + FIELD_OFFSET(mainStruct, embeddedStruct);  \
      UsedLength = ((mainStruct*) InformationBuffer)->embeddedStruct.ulUsedSize + FIELD_OFFSET(mainStruct, embeddedStruct);      \
   } 

NDIS_STATUS 
MpQueryInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportQueryInformation request allows the inspection of the
    Miniport driver's capabilities and current status.

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests of the following kind will be submitted to the Miniport 
    driver until this request has been completed:
       1. MiniportQueryInformation()
       2. MiniportSetInformation()
       3. MiniportHalt()

    Note that the wrapper will intercept all queries of the following OIDs:
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_802_5_CURRENT_FUNCTIONAL,
        OID_802_3_MULTICAST_LIST,
        OID_FDDI_LONG_MULTICAST_LIST,
        OID_FDDI_SHORT_MULTICAST_LIST.

    Interrupts are in any state during this call.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

    Oid _ The OID.  (See section 7.4 of the NDIS 3.0 specification for a
          complete description of OIDs.)

    InformationBuffer _ The buffer that will receive the information.
                        (See section 7.4 of the NDIS 3.0 specification
                        for a description of the length required for each
                        OID.)

    InformationBufferLength _ The length in bytes of InformationBuffer.

    BytesWritten _ Returns the number of bytes written into
                   InformationBuffer.

    BytesNeeded _ This parameter returns the number of additional bytes
                  needed to satisfy the OID.

Return Values:

    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_FAILURE
    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/    
{

    ADAPTER* pAdapter = (ADAPTER*) MiniportAdapterContext;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    ULONG GenericUlong;
    PVOID SourceBuffer = NULL;

    ULONG NeededLength = 0;
    ULONG UsedLength = 0;

    //
    // This can be any string that represents PPPoE as a MAC address, but
    // it must be up to 6 chars long.
    //
    UCHAR PPPoEWanAddress[6] = { '3', 'P', 'o', 'E', '0', '0' };
    
    TRACE( TL_I, TM_Mp, ("+MpQueryInformation($%x):%s",(ULONG) Oid, GetOidName( Oid ) ) );

    //
    // Make sure adapter context is a valid one
    //
    if ( !VALIDATE_ADAPTER( pAdapter ) )
        return status;

    switch ( Oid )
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            NeededLength = sizeof( GenericUlong );
            GenericUlong = pAdapter->NdisWanInfo.MaxFrameSize;

            SourceBuffer = &GenericUlong;
            
            status = NDIS_STATUS_SUCCESS;
            
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            NeededLength = sizeof( GenericUlong );
            GenericUlong = NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;

            SourceBuffer = &GenericUlong;
            
            status = NDIS_STATUS_SUCCESS;
            
            break;
        }
        
        case OID_GEN_SUPPORTED_LIST:
        {
            //
            // Calculate the number of oids we support.
            // (Subtract one for unknown oid)
            //
            UINT nNumOids = ( sizeof( SupportedOidsArray ) / sizeof( SUPPORTED_OIDS ) ) - 1;

            NeededLength = nNumOids * sizeof( NDIS_OID );

            if ( InformationBufferLength >= NeededLength )
            {
                NDIS_OID* NdisOidArray = (NDIS_OID*) InformationBuffer;
                UINT i;

                for ( i = 0; i < nNumOids; i++ )
                {
                    NdisOidArray[i] = SupportedOidsArray[i].ndisOid;
                }
            
                status = NDIS_STATUS_SUCCESS;
            }
            
            break;
        }

        case OID_GEN_RCV_ERROR:
        case OID_GEN_RCV_OK:   
        case OID_GEN_XMIT_ERROR:
        case OID_GEN_XMIT_OK:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_ID:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;

            break;
        }

        case OID_TAPI_GET_ADDRESS_CAPS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_ADDRESS_CAPS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_ADDRESS_CAPS,
                           LineAddressCaps
                           );
                           
            status = TpGetAddressCaps( pAdapter, 
                                       (PNDIS_TAPI_GET_ADDRESS_CAPS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                    NDIS_TAPI_GET_ADDRESS_CAPS, 
                    LineAddressCaps
                    );
            break;
        }

        case OID_TAPI_GET_CALL_INFO:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_CALL_INFO );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_CALL_INFO,
                           LineCallInfo
                           );
            
            status = TpGetCallInfo( pAdapter, 
                                    (PNDIS_TAPI_GET_CALL_INFO) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_CALL_INFO,
                           LineCallInfo
                           );

            break;
        }

        case OID_TAPI_GET_CALL_STATUS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_CALL_STATUS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_CALL_STATUS,
                           LineCallStatus
                           );

            status = TpGetCallStatus( pAdapter, 
                                      (PNDIS_TAPI_GET_CALL_STATUS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_CALL_STATUS,
                           LineCallStatus
                           );

            break;

        }

        case OID_TAPI_GET_DEV_CAPS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_DEV_CAPS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_DEV_CAPS,
                           LineDevCaps
                           );
            
            status = TpGetDevCaps( pAdapter, 
                                  (PNDIS_TAPI_GET_DEV_CAPS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_DEV_CAPS,
                           LineDevCaps
                           );
            
            break;

        }

        case OID_TAPI_GET_ID:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_ID );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_ID,
                           DeviceID
                           );

            status = TpGetId( pAdapter, 
                              (PNDIS_TAPI_GET_ID) InformationBuffer,
                              InformationBufferLength );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_ID,
                           DeviceID
                           );

            break;
        }

        case OID_TAPI_GET_ADDRESS_STATUS:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_ADDRESS_STATUS );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_GET_ADDRESS_STATUS,
                           LineAddressStatus
                           );

            status = TpGetAddressStatus( pAdapter, 
                                         (PNDIS_TAPI_GET_ADDRESS_STATUS) InformationBuffer );

            RETRIEVE_NEEDED_AND_USED_LENGTH(
                           NDIS_TAPI_GET_ADDRESS_STATUS,
                           LineAddressStatus
                           );

            break;
        }

        case OID_TAPI_GET_EXTENSION_ID:
        {
            NeededLength = sizeof( NDIS_TAPI_GET_EXTENSION_ID );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpGetExtensionId( pAdapter, 
                                      (PNDIS_TAPI_GET_EXTENSION_ID) InformationBuffer );
            break;
        }

        case OID_TAPI_MAKE_CALL:        
        {
            NeededLength = sizeof( NDIS_TAPI_MAKE_CALL );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            ENFORCE_SAFE_TOTAL_SIZE(
                           NDIS_TAPI_MAKE_CALL,
                           LineCallParams
                           );
            
            status = TpMakeCall( pAdapter, 
                                 (PNDIS_TAPI_MAKE_CALL) InformationBuffer,
                                 InformationBufferLength );
            break;
        }

        case OID_TAPI_NEGOTIATE_EXT_VERSION:
        {
            NeededLength = sizeof( NDIS_TAPI_NEGOTIATE_EXT_VERSION );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpNegotiateExtVersion( pAdapter, 
                                            (PNDIS_TAPI_NEGOTIATE_EXT_VERSION) InformationBuffer );
            break;
        }

        case OID_TAPI_OPEN:
        {
            NeededLength = sizeof( NDIS_TAPI_OPEN );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpOpenLine( pAdapter, 
                                 (PNDIS_TAPI_OPEN) InformationBuffer );
            break;
        }

        case OID_TAPI_PROVIDER_INITIALIZE:
        {
            NeededLength = sizeof( NDIS_TAPI_PROVIDER_INITIALIZE );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpProviderInitialize( pAdapter, 
                                           (PNDIS_TAPI_PROVIDER_INITIALIZE) InformationBuffer );
            break;
        }        

        case OID_WAN_GET_INFO:
        {
            NeededLength = sizeof( NDIS_WAN_INFO );

            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = MpWanGetInfo( pAdapter,
                                   (PNDIS_WAN_INFO) InformationBuffer );

            break;
        }
        
        case OID_WAN_MEDIUM_SUBTYPE:
        {
            NeededLength = sizeof( GenericUlong );
            GenericUlong = NdisWanMediumPppoe;

            SourceBuffer = &GenericUlong;

            status = NDIS_STATUS_SUCCESS;
            
            break;
        }

        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_PERMANENT_ADDRESS:
        {
            NeededLength = sizeof( PPPoEWanAddress );
            SourceBuffer = PPPoEWanAddress;

            status = NDIS_STATUS_SUCCESS;
            
            break;
        }

        case OID_WAN_GET_LINK_INFO:
        {
            NeededLength = sizeof( NDIS_WAN_GET_LINK_INFO );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = MpWanGetLinkInfo( pAdapter, 
                                       (PNDIS_WAN_GET_LINK_INFO) InformationBuffer );

            break;
        }
        
        case OID_WAN_GET_BRIDGE_INFO:
        case OID_WAN_GET_STATS_INFO:
        case OID_WAN_HEADER_FORMAT:
        case OID_WAN_LINE_COUNT:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_SET_BRIDGE_INFO:
        case OID_WAN_SET_COMP_INFO:
        case OID_WAN_SET_LINK_INFO:
        case OID_WAN_GET_COMP_INFO: 
        {
            status = NDIS_STATUS_NOT_SUPPORTED;

            break;
        }

        case OID_PNP_CAPABILITIES:
        {
            NDIS_PNP_CAPABILITIES UNALIGNED * pPnpCaps = (NDIS_PNP_CAPABILITIES UNALIGNED *) InformationBuffer;
            
            NeededLength = sizeof( NDIS_PNP_CAPABILITIES );

            if ( InformationBufferLength < NeededLength )
            {
                break;
            }

            pPnpCaps->Flags = 0;
            pPnpCaps->WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
            pPnpCaps->WakeUpCapabilities.MinPatternWakeUp     = NdisDeviceStateUnspecified;
            pPnpCaps->WakeUpCapabilities.MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;

            status = NDIS_STATUS_SUCCESS;
            
            break;
        }
        
        case OID_PNP_QUERY_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
        {
            NeededLength = 0;
            
            status = NDIS_STATUS_SUCCESS;

            break;
        }

        default:
        {
            //
            // Unknown OID
            //
            status = NDIS_STATUS_INVALID_OID;
            
            break;      
        }
    }

    if ( status != NDIS_STATUS_NOT_SUPPORTED && 
         status != NDIS_STATUS_INVALID_OID )
    {

        if ( InformationBufferLength >= NeededLength )
        {
            if ( status == NDIS_STATUS_SUCCESS )
            {

               if ( SourceBuffer )
               {
                   NdisMoveMemory( InformationBuffer, SourceBuffer, NeededLength );
               }
               
               *BytesWritten = NeededLength;
            }  
            else if ( status == NDIS_STATUS_INVALID_LENGTH )
            {
               *BytesWritten = 0;
               *BytesNeeded = NeededLength;
            }

        }
        else
        {
            *BytesWritten = 0;
            *BytesNeeded = NeededLength;
    
            status = NDIS_STATUS_INVALID_LENGTH;
        }

    }
    
    TRACE( TL_I, TM_Mp, ("-MpQueryInformation()=$%x",status) );

    return status;

}

NDIS_STATUS 
MpSetInformation(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN NDIS_OID  Oid,
    IN PVOID  InformationBuffer,
    IN ULONG  InformationBufferLength,
    OUT PULONG  BytesWritten,
    OUT PULONG  BytesNeeded
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    The MiniportSetInformation request allows for control of the Miniport
    by changing information maintained by the Miniport driver.

    Any of the settable NDIS Global Oids may be used. (see section 7.4 of
    the NDIS 3.0 specification for a complete description of the NDIS Oids.)

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMSetInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesRead, and BytesNeeded until the request completes.

    Interrupts are in any state during the call, and no other requests will
    be submitted to the Miniport until this request is completed.

Parameters:

    MiniportAdapterContext _ The adapter handle passed to NdisMSetAttributes
                             during MiniportInitialize.

    Oid _ The OID.  (See section 7.4 of the NDIS 3.0 specification for
          a complete description of OIDs.)

    InformationBuffer _ The buffer that will receive the information.
                        (See section 7.4 of the NDIS 3.0 specification for
                        a description of the length required for each OID.)

    InformationBufferLength _ The length in bytes of InformationBuffer.

    BytesRead_ Returns the number of bytes read from InformationBuffer.

    BytesNeeded _ This parameter returns the number of additional bytes
                  expected to satisfy the OID.

Return Values:

    NDIS_STATUS_INVALID_DATA
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_PENDING
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/    
{
    ADAPTER* pAdapter = MiniportAdapterContext;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    PVOID SourceBuffer = NULL;

    ULONG NeededLength = 0;
    ULONG GenericUlong;

    TRACE( TL_I, TM_Mp, ("+MpSetInformation($%x):%s",(ULONG) Oid, GetOidName( Oid ) ) );

    //
    // Make sure adapter context is a valid one
    //
    if ( !VALIDATE_ADAPTER( pAdapter ) )
        return status;

    switch ( Oid )
    {

        case OID_TAPI_ANSWER:
        {
            NeededLength = sizeof( NDIS_TAPI_ANSWER );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpAnswerCall( pAdapter, 
                                   (PNDIS_TAPI_ANSWER) InformationBuffer );
            break;
        }

        case OID_TAPI_CLOSE:
        {
            NeededLength = sizeof( NDIS_TAPI_CLOSE );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpCloseLine( pAdapter, 
                                  (PNDIS_TAPI_CLOSE) InformationBuffer,
                                  TRUE);
            break;
        }

        case OID_TAPI_CLOSE_CALL:
        {
            NeededLength = sizeof( NDIS_TAPI_CLOSE_CALL );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpCloseCall( pAdapter, 
                                  (PNDIS_TAPI_CLOSE_CALL) InformationBuffer,
                                  TRUE );
            break;
        }

        case OID_TAPI_DROP:     
        {
            NeededLength = sizeof( NDIS_TAPI_DROP );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpDropCall( pAdapter, 
                                 (PNDIS_TAPI_DROP) InformationBuffer,
                                 0 );
            break;
        }

        case OID_TAPI_PROVIDER_SHUTDOWN:
        {
            NeededLength = sizeof( NDIS_TAPI_PROVIDER_SHUTDOWN );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpProviderShutdown( pAdapter, 
                                         (PNDIS_TAPI_PROVIDER_SHUTDOWN) InformationBuffer,
                                         TRUE );
            break;
        }

        case OID_TAPI_SET_DEFAULT_MEDIA_DETECTION:
        {
            NeededLength = sizeof( NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpSetDefaultMediaDetection( pAdapter, 
                                                 (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) InformationBuffer );
            break;
        }

        case OID_TAPI_SET_STATUS_MESSAGES:
        {
            NeededLength = sizeof( NDIS_TAPI_SET_STATUS_MESSAGES );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = TpSetStatusMessages( pAdapter, 
                                          (PNDIS_TAPI_SET_STATUS_MESSAGES) InformationBuffer );
            break;
        }

        case OID_WAN_SET_LINK_INFO:
        {
            NeededLength = sizeof( NDIS_WAN_SET_LINK_INFO );
            
            if ( InformationBufferLength < NeededLength )
            {
                break;
            }
            
            status = MpWanSetLinkInfo( pAdapter, 
                                       (PNDIS_WAN_SET_LINK_INFO) InformationBuffer );

            break;
        }

        case OID_PNP_SET_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
        {
            NeededLength = 0;
            
            status = NDIS_STATUS_SUCCESS;

            break;
        }        

        default:
        {
            //
            // Unknown OID
            //
            status = NDIS_STATUS_INVALID_OID;
            
            break;      
        }

    }

    if ( status != NDIS_STATUS_NOT_SUPPORTED && 
         status != NDIS_STATUS_INVALID_OID )
    {

        if ( InformationBufferLength >= NeededLength )
        {
            if ( SourceBuffer )
                NdisMoveMemory( InformationBuffer, SourceBuffer, NeededLength );
                
            *BytesWritten = NeededLength;

        }
        else
        {
            *BytesWritten = 0;
            *BytesNeeded = NeededLength;
    
            status = NDIS_STATUS_INVALID_LENGTH;
        }

    }
    
    TRACE( TL_I, TM_Mp, ("-MpSetInformation()=$%x",status) );

    return status;

}

VOID 
MpNotifyBindingRemoval( 
    BINDING* pBinding 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by the protocol module to notify the miniport 
    about the removal of a binding.

    Miniport identifies and drops the calls over the binding..
    
Parameters:

    pBinding _ A pointer to our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ADAPTER* pAdapter = NULL;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Mp, ("+MpNotifyBindingRemoval($%x)",pBinding) );

    if ( !gl_fLockAllocated )
    {
        TRACE( TL_A, TM_Mp, ("MpNotifyBindingRemoval($%x): Global lock not allocated yet",pBinding) );

        TRACE( TL_N, TM_Mp, ("-MpNotifyBindingRemoval($%x)",pBinding) );

        return;
    }

    NdisAcquireSpinLock( &gl_lockAdapter );

    if (  gl_pAdapter && 
         !( gl_pAdapter->ulMpFlags & MPBF_MiniportHaltPending ) &&
          ( gl_pAdapter->ulMpFlags & MPBF_MiniportInitialized ) )
    {

        pAdapter = gl_pAdapter;

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
              ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            ReferenceTapiProv( pAdapter, FALSE );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }
        else
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            pAdapter = NULL;
        }
    }

    NdisReleaseSpinLock( &gl_lockAdapter );

    if ( pAdapter == NULL )
    {
        TRACE( TL_A, TM_Mp, ("MpNotifyBindingRemoval($%x): Tapi provider not initialized or no adapters found",pBinding) );

        TRACE( TL_N, TM_Mp, ("-MpNotifyBindingRemoval($%x)",pBinding) );

        return;
    }

    //
    // Complete any queued received packets in case PrReceiveComplete()
    // is not called
    //
    PrReceiveComplete( pBinding );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    do
    {
        HANDLE_TABLE hCallTable = NULL;
        UINT hCallTableSize = 0;
        UINT i = 0;
        CALL* pCall;
        HDRV_CALL hdCall;
        
        //
        // Traverse the call handle table and drop calls over
        // the removed binding
        //
        hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
        
        hCallTable = pAdapter->TapiProv.hCallTable;

        for ( i = 0; i < hCallTableSize; i++ )
        {
            NDIS_TAPI_DROP DummyRequest;
            BOOLEAN fDropCall = FALSE;
            
            pCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );

            if ( pCall == NULL )
                continue;

            NdisAcquireSpinLock( &pCall->lockCall );

            if ( pCall->pBinding == pBinding )
            {
                //
                // This call is over the removed binding,
                // so it should be dropped
                //
                ReferenceCall( pCall, FALSE );

                fDropCall = TRUE;
            }

            NdisReleaseSpinLock( &pCall->lockCall );

            if ( !fDropCall )
            {
                pCall = NULL;
                
                continue;
            }

            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            //
            // Initialize the request, and drop the call
            //
            DummyRequest.hdCall = pCall->hdCall;

            TpDropCall( pAdapter, &DummyRequest, LINEDISCONNECTMODE_UNREACHABLE );

            //
            // Remove the reference added above
            //
            DereferenceCall( pCall );

            //
            // Re-acquire the adapter's lock
            //
            NdisAcquireSpinLock( &pAdapter->lockAdapter );
            
        }

    } while ( FALSE );

    NdisReleaseSpinLock( &pAdapter->lockAdapter );
    
    //
    // Remove the reference added above
    //
    DereferenceTapiProv( pAdapter );

    TRACE( TL_N, TM_Mp, ("-MpNotifyBindingRemoval($%x)",pBinding) );
}

CALL*
MpMapPacketWithSessionIdToCall(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to map an in session packet to a call in 
    call handle table.

    If such a call is identified, it will be referenced and a pointer to 
    it will be returned. It is the caller's responsibility to remove the
    added reference.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.
    
    pPacket _ A PPPoE packet received over the wire.

Return Values:

    A pointer to the call context that the packet must be dispatched to.
    NULL if no such calls could be identified.
    
---------------------------------------------------------------------------*/   
{
    CALL* pCall = NULL;
    CALL* pReturnCall = NULL;

    TRACE( TL_V, TM_Mp, ("+MpMapPacketWithSessionIdToCall($%x)",pPacket) );
    
    NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
    if ( pAdapter->fClientRole )
    {
        HANDLE_TABLE hCallTable = NULL;
        UINT hCallTableSize = 0;
        UINT i = 0;

        CHAR* pSrcAddr = PacketGetSrcAddr( pPacket );
        CHAR* pDestAddr = PacketGetDestAddr( pPacket );
        USHORT usSessionId = PacketGetSessionId( pPacket );

        //
        // Miniport acting as a client:
        // Our algorithm is to search for the call handle table
        // to find the matching call
        //
        hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
            
        hCallTable = pAdapter->TapiProv.hCallTable;
    
        for ( i = 0; i < hCallTableSize ; i++ )
        {
        
            pCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );

            if ( pCall == NULL )
                continue;

            if ( ( pCall->usSessionId == usSessionId ) &&
                 ( NdisEqualMemory( pCall->SrcAddr, pDestAddr, 6 * sizeof( CHAR ) ) ) &&
                 ( NdisEqualMemory( pCall->DestAddr, pSrcAddr, 6 * sizeof( CHAR ) ) ) )
            {
                //
                // The packet is intended for this call
                //
                ReferenceCall( pCall, TRUE );

                pReturnCall = pCall;

                break;
            }

        }

    }
    else
    {
        
        HANDLE_TABLE hCallTable = NULL;
        CHAR* pSrcAddr = PacketGetSrcAddr( pPacket );
        CHAR* pDestAddr = PacketGetDestAddr( pPacket );
        USHORT usSessionId = PacketGetSessionId( pPacket );

        //
        // Miniport acting as a server:
        // Our algorithm is to use the session id directly as the index 
        // to the call handle table
        //
        hCallTable = pAdapter->TapiProv.hCallTable;

        pCall = RetrieveFromHandleTableBySessionId( hCallTable, usSessionId );

        if ( pCall )
        {

            if ( ( pCall->usSessionId == usSessionId ) &&
                 ( NdisEqualMemory( pCall->SrcAddr, pDestAddr, 6 * sizeof( CHAR ) ) ) &&
                 ( NdisEqualMemory( pCall->DestAddr, pSrcAddr, 6 * sizeof( CHAR ) ) ) )
            {

                ReferenceCall( pCall, TRUE );

                pReturnCall = pCall;

            }
            
        }

    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_V, TM_Mp, ("-MpMapPacketWithSessionIdToCall($%x)=$%x",pPacket,pReturnCall) );

    return pReturnCall;
}

CALL*
MpMapPacketWithoutSessionIdToCall(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to map an out of session packet to a call that
    is in connecting state.

    If such a call is identified, it will be referenced and a pointer to 
    it will be returned. It is the caller's responsibility to remove the
    added reference.

    This function will only be called for PADO or PADS packets.

    We use the HostUnique tags to save the handle to the call, and
    use them to map the returned packet back to the related call. This provides a 
    very efficient mapping for these control packets.

    Our HostUnique tags are prepared in this way. We append hdCall,
    which is unique for a call, to a uniquely generated ULONG value to come up with
    a longer unique value. And when we receive the packet we decode the unique value to reach 
    hdCall and use that to retrieve the call pointer.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pPacket _ A PPPoE packet received over the wire.

Return Values:

    A pointer to the call context that the packet must be dispatched to.
    NULL if no such calls could be identified.
    
---------------------------------------------------------------------------*/   
{
    USHORT usCode = PacketGetCode( pPacket );
    CHAR* pUniqueValue = NULL;
    USHORT UniqueValueSize = 0;
    HDRV_CALL hdCall = (HDRV_CALL) NULL;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpMapPacketWithoutSessionIdToCall($%x)",pPacket) );
    
    PacketRetrieveHostUniqueTag( pPacket,
                                 &UniqueValueSize,
                                 &pUniqueValue );

    if ( pUniqueValue == NULL )
    {
        TRACE( TL_A, TM_Mp, ("MpMapPacketWithoutSessionIdToCall($%x): Could not retrieve HostUnique tag",pPacket) );
    
        TRACE( TL_N, TM_Mp, ("-MpMapPacketWithoutSessionIdToCall($%x)",pPacket) );

        return NULL;
    }

    //
    // Decode the unique value and retrieve the call handle
    //
    hdCall = RetrieveHdCallFromUniqueValue( pUniqueValue, UniqueValueSize );

    if ( hdCall == (HDRV_CALL) NULL )
    {
        TRACE( TL_A, TM_Mp, ("MpMapPacketWithoutSessionIdToCall($%x): Could not retrieve call handle from unique value",pPacket) );
    
        TRACE( TL_N, TM_Mp, ("-MpMapPacketWithoutSessionIdToCall($%x)",pPacket) );

        return NULL;
    }

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    //
    // Retrieve the call pointer using the call handle
    //
    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) hdCall );

    if ( pCall )
    {
        if ( !( pCall->ulClFlags & CLBF_CallDropped ||
                pCall->ulClFlags & CLBF_CallClosePending ) )
        {
            ReferenceCall( pCall, TRUE );
        }
        else
        {
            pCall = NULL;
        }
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_N, TM_Mp, ("-MpMapPacketWithoutSessionIdToCall($%x)=$%x",pPacket,pCall) );
    
    return pCall;
}

BOOLEAN
MpVerifyServiceName(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket,
    IN BOOLEAN fAcceptEmptyServiceNameTag
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to verify that a requested service name is 
    supported by our server.

    CAUTION: Do not attempt to lock anything inside this function, and make sure
             not to call any function that may do it because it must be lock free
             (caller might be holding locks).

Parameters:

    pAdapter  _ Pointer to the adapter structure that received the packet.
    
    pPacket _ A PADI or PADR packet received.

    fAcceptEmptyServiceNameTag _ An empty service name tag is valid in a PADI
                                 packet but not in a PADR packet. This flag 
                                 indicates this behavior.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    BOOLEAN fRet = FALSE;
    USHORT tagServiceNameLength = 0;
    CHAR* tagServiceNameValue = NULL;
    
    TRACE( TL_V, TM_Mp, ("+MpVerifyServiceName($%x)",pPacket) );

    RetrieveTag( pPacket,
                 tagServiceName,
                 &tagServiceNameLength,
                 &tagServiceNameValue,
                 0,
                 NULL,
                 FALSE );
    do
    {
        if ( fAcceptEmptyServiceNameTag )
        {
            if ( tagServiceNameLength == 0 && tagServiceNameValue != NULL )
            {
                fRet = TRUE;

                break;
            }
        }

        if ( tagServiceNameLength == pAdapter->nServiceNameLength && 
             NdisEqualMemory( tagServiceNameValue, pAdapter->ServiceName, tagServiceNameLength) )
        {
            fRet = TRUE;
        }
        
    } while ( FALSE );

                
    TRACE( TL_V, TM_Mp, ("-MpVerifyServiceName($%x)=$%x",pPacket,fRet) );

    return fRet;

}

VOID
MpReplyToPADI(
    IN ADAPTER* pAdapter,
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPADI
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when a PADI packet is received.

    It will look at the services we offer and reply to the PADI packet with a 
    PADO packet informing the client of our services.
    
Parameters:

    pAdapter  _ Pointer to the adapter structure that received the packet.

    pBinding _ Pointer to the binding that the packet is received over.

    pPacket _ A received PADI packet.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Mp, ("+MpReplyToPADI") );

    //
    // Verify the requested service name and 
    //
    if ( MpVerifyServiceName( pAdapter, pPADI, TRUE ) )
    {
        NDIS_STATUS status;
        PPPOE_PACKET* pPADO = NULL;

        status = PacketInitializePADOToSend( pPADI,
                                             &pPADO,
                                             pBinding->LocalAddress,
                                             pAdapter->nServiceNameLength,
                                             pAdapter->ServiceName,
                                             pAdapter->nACNameLength,
                                             pAdapter->ACName,
                                             TRUE );

        if ( status == NDIS_STATUS_SUCCESS )
        {
            //
            // Insert the empty generic service name tag
            //
            status = PacketInsertTag( pPADO,
                                      tagServiceName,
                                      0,
                                      NULL,
                                      NULL );
    
            if ( status == NDIS_STATUS_SUCCESS )
            {
                UINT i;
                
                ReferencePacket( pPADO );
                        
                ReferenceBinding( pBinding, TRUE );
    
                PrSend( pBinding, pPADO );
    
                PacketFree( pPADO );
            }
        }

    }

    TRACE( TL_N, TM_Mp, ("-MpReplyToPADI") );
}

BOOLEAN 
MpCheckClientQuota(
    IN ADAPTER* pAdapter,
    IN PPPOE_PACKET* pPacket
    )
{
    BOOLEAN fRet = FALSE;
    HANDLE_TABLE hCallTable = NULL;
    UINT hCallTableSize = 0;
    CALL* pCall;
    CHAR *pSrcAddr = NULL;
    UINT nNumCurrentConn = 0;
    UINT i;
    
    TRACE( TL_N, TM_Mp, ("+MpCheckClientQuota") );

    pSrcAddr = PacketGetSrcAddr( pPacket );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
            
    hCallTable = pAdapter->TapiProv.hCallTable;
    
    for ( i = 0; i < hCallTableSize; i++ )
    {
        pCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );

        if ( pCall == NULL )
            continue;

        if ( NdisEqualMemory( pCall->DestAddr, pSrcAddr, 6 * sizeof( CHAR ) ) )
        {
            nNumCurrentConn++;

            continue;
        }
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    if ( nNumCurrentConn < pAdapter->nClientQuota )
    {
        fRet = TRUE;
    }

    TRACE( TL_N, TM_Mp, ("-MpCheckClientQuota=$%d",(UINT) fRet) );

    return fRet;

}

VOID
MpSendPADSWithError(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPADR,
    IN ULONG ulErrorCode
    )
{
    NDIS_STATUS status;
    PPPOE_PACKET* pPADS = NULL;
    
    TRACE( TL_N, TM_Mp, ("+MpSendPADSWithError") );

    status = PacketInitializePADSToSend( pPADR,
                                         &pPADS,
                                         (USHORT) 0 );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        switch (ulErrorCode)
        {
            case PPPOE_ERROR_SERVICE_NOT_SUPPORTED:

                status = PacketInsertTag( pPADS,
                                          tagServiceNameError,
                                          PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG_SIZE,
                                          PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG,
                                          NULL );

                break;
                                 
            case PPPOE_ERROR_INVALID_AC_COOKIE_TAG:

                status = PacketInsertTag( pPADS,
                                          tagGenericError,
                                          PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG_SIZE,
                                          PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG,
                                          NULL );

                break;

            case PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED:

                status = PacketInsertTag( pPADS,
                                          tagACSystemError,
                                          PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG_SIZE,
                                          PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG,
                                          NULL );

                break;
                
        }

    }

    if ( status == NDIS_STATUS_SUCCESS )
    {
        ReferencePacket( pPADS );
        
        ReferenceBinding( pBinding, TRUE );

        PrSend( pBinding, pPADS );

    }

    if ( pPADS )
    {
        PacketFree( pPADS );
    }

    TRACE( TL_N, TM_Mp, ("-MpSendPADSWithError") );

}


VOID
MpRecvCtrlPacket(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by MpRecvPacket() when the packet received
    is a control packet. 

    Caller (MpRecPacket()) will make sure that in the context of this function 
    gl_pAdapter, gl_pAdapter->TapiProv.hCallTable and gl_pAdapter->TapiProv.hLineTable 
    are valid. It will also reference and dereference TapiProv correctly.

    This function will identify the call the packet is for and dispatch the 
    packet to it.
    
Parameters:

    pBinding _ Pointer to the binding structure that packet was received over.
    
    pPacket _ A PPPoE packet received over the wire.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ADAPTER* pAdapter = NULL;
    BOOLEAN fIndicateReceive = FALSE;
    USHORT usCode;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpRecvCtrlPacket($%x)",pPacket) );

    pAdapter = gl_pAdapter;

    usCode = PacketGetCode( pPacket );

    switch( usCode )
    {
        case PACKET_CODE_PADI:

                //
                // Ignore the received PADI packets unless we act as a server and we have open lines.
                //
                if ( !pAdapter->fClientRole && ( pAdapter->TapiProv.nActiveLines > 0 ) )
                {
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADI received",pPacket) );

                    MpReplyToPADI( pAdapter, pBinding, pPacket );
                }

                break;

        case PACKET_CODE_PADR:

                //
                // Ignore the received PADR packets unless we act as a server.
                //
                if ( !pAdapter->fClientRole )
                {
                    ULONG ulErrorCode = PPPOE_NO_ERROR;

                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADR received",pPacket) );
                    
                    //
                    // Verify the requested service name and validate the AC Cookie
                    // tag, and if they look OK, then start receiving the call.
                    //
                    if ( !MpVerifyServiceName( pAdapter, pPacket, TRUE ) )
                    {
                        ulErrorCode = PPPOE_ERROR_SERVICE_NOT_SUPPORTED;
                    }
                    else if ( !PacketValidateACCookieTagInPADR( pPacket ) )
                    {
                        ulErrorCode = PPPOE_ERROR_INVALID_AC_COOKIE_TAG;
                    }
                    else if ( !MpCheckClientQuota( pAdapter, pPacket ) )
                    {
                        ulErrorCode = PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED;
                    }

                    if ( ulErrorCode == PPPOE_NO_ERROR )
                    {
                        TpReceiveCall( pAdapter, pBinding, pPacket );
                    }
                    else
                    {
                        MpSendPADSWithError( pBinding, pPacket, ulErrorCode );
                    }
                
                }

                break;
                
        case PACKET_CODE_PADO:

                if ( pAdapter->fClientRole )
                {
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADO received",pPacket) );

                    //
                    // Retrieve the call handle from the PADO packet
                    //
                    pCall = MpMapPacketWithoutSessionIdToCall( pAdapter, pPacket );

                    if ( pCall )
                    {
                        //
                        // Dispatch the packet to related call
                        //
                        FsmRun( pCall, pBinding, pPacket, NULL );
                                
                        //
                        // Remove the reference added in MpMapPacketWithoutSessionIdToCall()
                        //
                        DereferenceCall( pCall );
                    }

                }

                break;
                
        case PACKET_CODE_PADS:

                if ( pAdapter->fClientRole )
                {                   
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADS received",pPacket) );

                    //
                    // Retrieve the call handle from the PADS packet
                    //
                    pCall = MpMapPacketWithoutSessionIdToCall( pAdapter, pPacket );

                    if ( pCall )
                    {
                        //
                        // For PADS packet, we must make sure that no other calls 
                        // between the same 2 machines already have the same session id.
                        //  
                        {
                            HANDLE_TABLE hCallTable = NULL; 
                            UINT hCallTableSize     = 0;
                            UINT i                  = 0;
                    
                            USHORT usSessionId = PacketGetSessionId( pPacket );
                            CHAR* pSrcAddr     = PacketGetSrcAddr( pPacket );
                            CHAR* pDestAddr    = PacketGetDestAddr( pPacket );
    
                            BOOLEAN fDuplicateFound = FALSE;
                            CALL* pTempCall         = NULL;

                            TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): Checking for duplicate session",pPacket) );

                            NdisAcquireSpinLock( &pAdapter->lockAdapter );
                
                            hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
                    
                            hCallTable = pAdapter->TapiProv.hCallTable;
            
                            for ( i = 0; i < hCallTableSize ; i++ )
                            {
                
                                pTempCall = RetrieveFromHandleTableByIndex( hCallTable, (USHORT) i );
            
                                if ( pTempCall == NULL )
                                    continue;
        
                                if ( ( pTempCall->usSessionId == usSessionId ) &&
                                     ( NdisEqualMemory( pTempCall->SrcAddr, pSrcAddr, 6 * sizeof( CHAR ) ) ) &&
                                     ( NdisEqualMemory( pTempCall->DestAddr, pDestAddr, 6 * sizeof( CHAR ) ) ) )
                                {
                                    //
                                    // Another call has been detected between the 2 machines with the same
                                    // session id, so do not accept this session
                                    //
                                    fDuplicateFound = TRUE;
                                    
                                    break;
                                }
                            }
    
                            NdisReleaseSpinLock( &pAdapter->lockAdapter );
    
                            if ( fDuplicateFound )
                            {
                                //
                                // We have found another session with the same machine that has the
                                // same session id, so we can not accept this new session.
                                //
                                // Remove the reference added in MpMapPacketWithoutSessionId() and 
                                // drop the packet
                                //
                                TRACE( TL_A, TM_Mp, ("MpRecvCtrlPacket($%x): Packet dropped - Duplicate session found",pPacket) );
                                
                                DereferenceCall( pCall );
                                
                                break;
                            }
    
                        }

                        TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): No duplicate sessions found",pPacket) );

                        //
                        // Dispatch the packet to related call
                        //
                        FsmRun( pCall, pBinding, pPacket, NULL );
                                
                        //
                        // Remove the reference added in MpMapPacketWithoutSessionIdToCall()
                        //
                        DereferenceCall( pCall );
    
                    } // if ( pCall ) ...
    
                }   // if ( fClientRole ) ...

                break;
                
        case PACKET_CODE_PADT:

                TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): PADT received",pPacket) );

                //
                // PADT packet must have a session id.
                // Identify the session and drop the call.
                //
                pCall = MpMapPacketWithSessionIdToCall( pAdapter, pPacket );

                if ( pCall )
                {
                    NDIS_TAPI_DROP DummyRequest;
                    
                    TRACE( TL_N, TM_Mp, ("MpRecvCtrlPacket($%x): Call being dropped - PADT received",pPacket) );

                    //
                    // Initialize the request, and drop the call
                    //
                    DummyRequest.hdCall = pCall->hdCall;

                    TpDropCall( pAdapter, &DummyRequest, LINEDISCONNECTMODE_NORMAL );

                    //
                    // Remove the reference added in MpMapPacketWithSessionIdToCall()
                    //
                    DereferenceCall( pCall );

                }

                break;

        default:

                break;
    }

    TRACE( TL_N, TM_Mp, ("-MpRecvCtrlPacket($%x)",pPacket) );

}

VOID
MpRecvPacket(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by the protocol module to notify the miniport 
    when a packet is received.

    If packet is a control packet, it will call MpRecvCtrlPacket(), otherwise
    it will identify the call and notify NDISWAN about the packet received.
    
Parameters:

    pBinding _ Pointer to the binding structure that packet was received over.
    
    pPacket _ A PPPoE packet received over the wire.

Return Values:

    None
---------------------------------------------------------------------------*/   
{

    ADAPTER* pAdapter = NULL;
    CALL* pCall = NULL;

    TRACE( TL_V, TM_Mp, ("+MpReceivePacket($%x)",pPacket) );

    if ( !gl_fLockAllocated )
    {
        TRACE( TL_V, TM_Mp, ("-MpReceivePacket($%x): Lock not allocated",pPacket) );

        return;
    }

    NdisAcquireSpinLock( &gl_lockAdapter );

    if (  gl_pAdapter && 
         !( gl_pAdapter->ulMpFlags & MPBF_MiniportHaltPending ) &&
          ( gl_pAdapter->ulMpFlags & MPBF_MiniportInitialized ) )
    {

        pAdapter = gl_pAdapter;

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
              ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            ReferenceTapiProv( pAdapter, FALSE );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }
        else
        {
            NdisReleaseSpinLock( &pAdapter->lockAdapter );

            pAdapter = NULL;
        }
    }

    NdisReleaseSpinLock( &gl_lockAdapter );

    if ( pAdapter == NULL )
    {
        TRACE( TL_V, TM_Mp, ("-MpReceivePacket($%x): Adapter not found",pPacket) );

        return;
    }

    if ( PacketGetCode( pPacket ) == PACKET_CODE_PAYLOAD )
    {
        //
        // Payload packet is received
        //
    
        pCall = MpMapPacketWithSessionIdToCall( pAdapter, pPacket );

        if ( pCall )
        {
            NdisAcquireSpinLock( &pCall->lockCall );

            //
            // Make sure call is not dropped, closed or closing, and receive window is still open
            //
            if ( !( pCall->ulClFlags & ( CLBF_CallDropped | CLBF_CallClosePending | CLBF_CallClosed ) ) && 
                  ( pCall->nReceivedPackets < MAX_RECEIVED_PACKETS ) )
            {
                // 
                // Reference the packet. It will be dereferenced when indicated to NDISWAN, or
                // when the queue is destroyed because the call is getting cleaned up.
                //
                ReferencePacket( pPacket );

                //
                // Insert into the receive queue and bump up the received packet count
                //
                InsertTailList( &pCall->linkReceivedPackets, &pPacket->linkPackets );

                pCall->nReceivedPackets++;

                //
                // Try to schedule an IndicateReceivedPackets handler
                //
                MpScheduleIndicateReceivedPacketsHandler( pCall );

            }

            NdisReleaseSpinLock( &pCall->lockCall );

            //
            // Remove the reference added by MpMapPacketWithSessionIdToCall()
            //
            DereferenceCall( pCall );                             
        }

    }
    else
    {
        //
        // Control packet is received, process it
        //

        MpRecvCtrlPacket( pBinding, pPacket );
    }

    //
    // Remove the reference added above
    //
    DereferenceTapiProv( pAdapter );
    
    TRACE( TL_V, TM_Mp, ("-MpReceivePacket($%x)",pPacket) );
}

VOID
MpIndicateReceivedPackets(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event
    )
{
    ULONG ulPacketsToIndicate = MAX_INDICATE_RECEIVED_PACKETS;
    CALL* pCall = (CALL*) pContext;

    PPPOE_PACKET* pPacket = NULL;
    LIST_ENTRY* pLink = NULL;

    ASSERT( VALIDATE_CALL( pCall ) );

    NdisAcquireSpinLock( &pCall->lockCall );

    while ( ulPacketsToIndicate > 0 && 
            pCall->stateCall == CL_stateSessionUp &&
            pCall->nReceivedPackets > 0)
    {
        ulPacketsToIndicate--;
        
        pLink = RemoveHeadList( &pCall->linkReceivedPackets );

        pCall->nReceivedPackets--;

        NdisReleaseSpinLock( &pCall->lockCall );

        {
            NDIS_STATUS status;
            CHAR* pPayload = NULL;
            USHORT usSize = 0;

            pPacket = (PPPOE_PACKET*) CONTAINING_RECORD( pLink, PPPOE_PACKET, linkPackets );

            PacketRetrievePayload( pPacket,
                                   &pPayload,
                                   &usSize );

            //
            // Future: Make sure the size of the packet is less than the max of what NDISWAN expects 
            //
            // if ( usSize > pCall->NdisWanLinkInfo.MaxRecvFrameSize )
            // {
            //  TRACE( TL_A, TM_Mp, ("MpReceivePacket($%x): PAYLOAD too large to be indicated to NDISWAN",pPacket) );
            // }
            // else

            TRACE( TL_V, TM_Mp, ("MpReceivePacket($%x): PAYLOAD is being indicated to NDISWAN",pPacket) );
    
            NdisMWanIndicateReceive( &status,
                                     pCall->pLine->pAdapter->MiniportAdapterHandle,
                                     pCall->NdisLinkContext,
                                     pPayload,
                                     (UINT) usSize );

            DereferencePacket( pPacket );

        }

        NdisAcquireSpinLock( &pCall->lockCall );
    }

    //
    // Check if there are more packets to indicate
    //
    if ( pCall->stateCall == CL_stateSessionUp &&
         pCall->nReceivedPackets > 0)
    {
        //
        // More packets to indicate, so schedule another timer manually.
        // We can not use MpScheduleIndicateReceivedPacketsHandler() function here
        // because of performance reasons, so we do it manually.
        //
        // Since we are scheduling another handler, we do not dereference and reference 
        // the call context.
        //
        TimerQInitializeItem( &pCall->timerReceivedPackets );

        TimerQScheduleItem( &gl_TimerQ,
                            &pCall->timerReceivedPackets,
                            (ULONG) RECEIVED_PACKETS_TIMEOUT,
                            MpIndicateReceivedPackets,
                            (PVOID) pCall );

        NdisReleaseSpinLock( &pCall->lockCall );
                            
    }
    else
    {
        //
        // We are done, so let's remove the reference on the call context, and
        // reset the CLBF_CallReceivePacketHandlerScheduled flag
        //
        pCall->ulClFlags &= ~CLBF_CallReceivePacketHandlerScheduled;

        NdisReleaseSpinLock( &pCall->lockCall );

        DereferenceCall( pCall );
        
    }

}

VOID 
MpScheduleIndicateReceivedPacketsHandler(
    CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to schedule MpIndicateReceivedPackets() handler.

    It will check if we are allowed to schedule it first, and if we are, then it
    will schedule it and reference the call context.

    CAUTION :Caller MUST be holding pCall->lockCall.
    
Parameters:

    pCall _ Pointer to our call context.
    
Return Values:

    NONE
    
---------------------------------------------------------------------------*/   
{

    if ( !( pCall->ulClFlags & CLBF_CallReceivePacketHandlerScheduled ) &&
            pCall->stateCall == CL_stateSessionUp &&
            pCall->nReceivedPackets > 0 )
    {

        pCall->ulClFlags |= CLBF_CallReceivePacketHandlerScheduled;
        
        TimerQInitializeItem( &pCall->timerReceivedPackets );

        TimerQScheduleItem( &gl_TimerQ,
                            &pCall->timerReceivedPackets,
                            (ULONG) RECEIVED_PACKETS_TIMEOUT,
                            MpIndicateReceivedPackets,
                            (PVOID) pCall );

        ReferenceCall( pCall, FALSE );

    }

}

NDIS_STATUS
MpWanGetInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_INFO pWanInfo
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when miniport receives an OID_WAN_GET_INFO
    query from NDISWAN. It will acquire the necesarry information and return it
    back to NDISWAN.

    All the info is initialized when the adapter is initialized except for
    MaxFrameSize which depends on the active bindings. That's why we query 
    the protocol to get the current MaxFrameSize, and pass it back.
    
Parameters:

    pAdapter _ Pointer to our adapter context.
    
    pWanInfo _ Pointer to the NDIS_WAN_INFO structure to be filled in.

Return Values:

    NDIS_STATUS_SUCCESS
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    TRACE( TL_N, TM_Mp, ("+MpWanGetInfo") );

    //
    // Retrieve the current MaxFrameSize from protocol
    //
    pAdapter->NdisWanInfo.MaxFrameSize = PrQueryMaxFrameSize();

    //
    // Pass data back to NDISWAN
    //
    *pWanInfo = pAdapter->NdisWanInfo;

    TRACE( TL_N, TM_Mp, ("-MpWanGetInfo()=$%x",status) );

    return status;
}

NDIS_STATUS
MpWanGetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_GET_LINK_INFO pWanLinkInfo
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when miniport receives an OID_WAN_GET_LINK_INFO
    query from NDISWAN. It will acquire the necesarry information and return it
    back to NDISWAN.

    All the info is initialized in TpCallStateChangeHandler() when TAPI is signaled 
    to LINECALLSTATE_CONNECTED state.

Parameters:

    pAdapter _ Pointer to our adapter context.
    
    pWanLinkInfo _ Pointer to the NDIS_WAN_GET_LINK_INFO structure to be filled in.

Return Values:

    NDIS_STATUS_FAILURE
    NDIS_STATUS_SUCCESS
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpWanGetLinkInfo") );

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable,
                                     pWanLinkInfo->NdisLinkHandle );

    if ( pCall )
    {
        *pWanLinkInfo = pCall->NdisWanLinkInfo;

        status = NDIS_STATUS_SUCCESS;
    }

    TRACE( TL_N, TM_Mp, ("-MpWanGetLinkInfo()=$%x",status) );

    return status;
}

NDIS_STATUS
MpWanSetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pWanLinkInfo
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when miniport receives an OID_WAN_SET_LINK_INFO
    request from NDISWAN. It will do some checks on the passed in params, and if
    the values are acceptiable it will copy them onto the call context.

Parameters:

    pAdapter _ Pointer to our adapter context.
    
    pWanLinkInfo _ Pointer to the NDIS_WAN_SET_LINK_INFO structure.

Return Values:

    NDIS_STATUS_FAILURE
    NDIS_STATUS_SUCCESS
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;

    TRACE( TL_N, TM_Mp, ("+MpWanSetLinkInfo") );

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable,
                                     pWanLinkInfo->NdisLinkHandle );

    if ( pCall )
    {
        do
        {
            if ( pWanLinkInfo->MaxSendFrameSize > pCall->ulMaxFrameSize )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Requested MaxSendFrameSize is larger than NIC's") );
            }

            if ( pWanLinkInfo->MaxRecvFrameSize < pCall->ulMaxFrameSize )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Requested MaxRecvFrameSize is smaller than NIC's") );
            }

            if ( pWanLinkInfo->HeaderPadding != pAdapter->NdisWanInfo.HeaderPadding )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Requested HeaderPadding is different than what we asked for") );
            }

            if ( pWanLinkInfo->SendFramingBits & ~pAdapter->NdisWanInfo.FramingBits )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Unknown send framing bits requested") );

                break;
            }
            
            if ( pWanLinkInfo->RecvFramingBits & ~pAdapter->NdisWanInfo.FramingBits )
            {
                TRACE( TL_A, TM_Mp, ("MpWanSetLinkInfo: Unknown recv framing bits requested") );

                break;
            }
            
            pCall->NdisWanLinkInfo = * ( (PNDIS_WAN_GET_LINK_INFO) pWanLinkInfo );
    
            status = NDIS_STATUS_SUCCESS;
        
        } while ( FALSE );
    }

    TRACE( TL_N, TM_Mp, ("-MpWanSetLinkInfo()=$%x",status) );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\miniport.h ===
#ifndef _MINIPORT_H_
#define _MINIPORT_H_

#define MP_NDIS_MajorVersion    4
#define MP_NDIS_MinorVersion    0

typedef struct _LINE* PLINE;
typedef struct _CALL* PCALL;

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
   These macros will be called by MpWanSend() and PrSendComplete() 
   functions when a PPPOE_PACKET with references to a packet owned by NDIS is
   created and freed, respectively.
   
---------------------------------------------------------------------------*/   
#define MpPacketOwnedByNdiswanReceived( pM ) \
        NdisInterlockedIncrement( &(pM)->NumPacketsOwnedByNdiswan )

#define MpPacketOwnedByNdiswanReturned( pM ) \
        NdisInterlockedDecrement( &(pM)->NumPacketsOwnedByNdiswan )


typedef struct 
_ADAPTER
{
    //
    // Tag for the adapter control block (used for debugging).
    //
    ULONG tagAdapter;

    //
    // Keeps the number of references on this adapter.
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added when the adapter is initialized and removed when 
    //     it is halted.
    //
    // (b) A reference is added when tapi provider is open, and removed when it is shutdown.
    //
    LONG lRef;

    //
    // Spin lock to synchronize access to shared members.
    //
    NDIS_SPIN_LOCK lockAdapter;

    //
    // This event will be triggered if MPBF_MiniportHaltPending is set and ref count drops to 0.
    //
    NDIS_EVENT eventAdapterHalted;

    //
    // These are the various bit flags to indicate other state information for the adapter:
    // 
    // (a) MPBF_MiniportIdle: Indicates that the miniport is in idle state. 
    //
    // (b) MPBF_MiniportInitialized: Indicates that the miniport is initialized.
    //                               The following pending flags can be set additionally.
    //                               MPBF_MiniportHaltPending
    //
    // (c) MPBF_MiniportHaltPending: Indicates that a miniport halt operation is pending
    //                               on the adappter.
    //
    // (d) MPBF_MiniportHalted: Indicates that miniport has halted completely.
    //                          No other flags can be set at this time.
    //
    ULONG ulMpFlags;
        #define MPBF_MiniportIdle                   0x00000000
        #define MPBF_MiniportInitialized            0x00000001
        #define MPBF_MiniportHaltPending            0x00000002
        #define MPBF_MiniportHalted                 0x00000004
    
    //
    // Handle passed to us in MiniportInitialize(). 
    // We should keep it around and pass it back to NDISWAN
    // in some functions.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    //
    // Number of packets owned by NDISWAN, passed to us and will be returned
    // to Ndiswan
    //
    LONG NumPacketsOwnedByNdiswan;

    //
    // This is the built-in Tapi Provider context.
    // It keeps the tables for lines and calls.
    //
    struct
    {
        //
        // Keeps references on the tapi provider
        // References are added and deleted for the following operations:
        //
        // (a) A reference is added when TapiProvider is initialized and removed when 
        //     it is shutdown.
        //
        // (b) A reference is added when a line open, and removed when line is closed.
        //
        LONG lRef;
    
        //
        // Tapi Provider context flags.
        //
        // (a) TPBF_TapiProvIdle: Indicates that the line is in idle state.
        //
        // (b) TPBF_TapiProvInitialized: Indicates that TAPI provider is initialized.
        //
        // (c) TPBF_TapiProvShutdownPending: Indicates that a TAPI provider shutdown operation
        //                                   is pending.
        //
        // (d) TPBF_TapiProvShutdown: Indicates that TAPI provider is shutdown.
        //
        // (e) LNBF_NotifyNDIS: This flag indicates that an asynchronous completion of a Tapi Provider 
        //                      shutdown request must be communicated to NDIS using NdisMSetInformationComplete().
        //
        ULONG ulTpFlags;
            #define TPBF_TapiProvIdle                   0x00000000
            #define TPBF_TapiProvInitialized            0x00000001
            #define TPBF_TapiProvShutdownPending        0x00000002
            #define TPBF_TapiProvShutdown               0x00000004
            #define TPBF_NotifyNDIS                     0x00000008
    
        //
        // This is supplied by Tapi. 
        // It is the base index for enumeration of line devices on this tapi provider.
        //
        ULONG ulDeviceIDBase;

        //
        // This is the table that holds pointers to active line contexts.
        // (pLine->hdLine is holds the index to this table)
        //
        PLINE* LineTable;
    
        //
        // Current active number of lines
        //
        UINT nActiveLines;

        //
        // This table holds the handles to calls.
        // It's size is pAdapter->nMaxLines * pAdapter->nCallsPerLine.
        // 
        HANDLE_TABLE hCallTable;

    } TapiProv;

    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
        typedef struct _NDIS_WAN_INFO {
            ULONG                  MaxFrameSize; 
            ULONG                  MaxTransmit; 
            ULONG                  HeaderPadding; 
            ULONG                  TailPadding; 
            ULONG                  Endpoints; 
            UINT                   MemoryFlags; 
            NDIS_PHYSICAL_ADDRESS  HighestAcceptableAddress; 
            ULONG                  FramingBits; 
            ULONG                  DesiredACCM; 
        } NDIS_WAN_INFO, *PNDIS_WAN_INFO; 

    -------------------------------------------------------*/
    NDIS_WAN_INFO NdisWanInfo;
    
    /////////////////////////////////////////////////////////
    //
    // Config values read from registry
    //
    /////////////////////////////////////////////////////////

    //
    // Indicates the role of the machine:
    //  - fClientRole is TRUE: Machine acts as a client. 
    //                         Only outgoing calls are connected, and no calls are received.
    //
    //  - fClientRole is FALSE: Machine acts as a server. 
    //                          Only incoming calls are accepted, and no outgoing calls are allowed.
    //
    BOOLEAN fClientRole;

    //
    // This is the string that holds the Service-name this server offers.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // It is only used for incoming calls.
    //
    #define MAX_COMPUTERNAME_LENGTH             200
    #define SERVICE_NAME_EXTENSION              " PPPoE"
    #define MAX_SERVICE_NAME_LENGTH             256

    CHAR ServiceName[MAX_SERVICE_NAME_LENGTH];

    //
    // Indicates the length of the Service name string 
    //
    USHORT nServiceNameLength;
    
    //
    // This is the string that holds the AC-name for this server.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // It is only used for incoming calls.
    //
    #define MAX_AC_NAME_LENGTH              256

    CHAR ACName[MAX_AC_NAME_LENGTH];

    //
    // Indicates the length of the AC name string 
    //
    USHORT nACNameLength;

    //
    // Max number of simultaneous calls that can be established between the same
    // client and server
    //
    UINT nClientQuota;

    //
    // Indicates the number of line contexts that will be created.
    //
    UINT nMaxLines;

    //
    // Indicates the number of calls that each individual line will support.
    //
    UINT nCallsPerLine;

    //
    // Indicates the maximum number of timeouts for the PPPoE FSM.
    // When the current number of timeouts , reach this number call will be dropped.
    //
    UINT nMaxTimeouts;

    //
    // This is the timeout period for client side operations (in ms)
    //
    ULONG ulSendTimeout;

    //
    // This is the timeout period for server side operations (in ms)
    //
    ULONG ulRecvTimeout;

    //
    // This shows the maximum number of packets that NDISWAN can pass to us simultaneously.
    // This does not make any sense for us as we do not queue the packets, but send them to
    // peer directly when we receive them from NDISWAN.
    //
    UINT nMaxSendPackets;

    //
    // This is related to the problem where the server does not support the empty service-name.
    // In this case, there is no way for clients to discover the services supported by the server,
    // since the server sends back a PADO packet without the empty service-name attribute, and we drop
    // it (per RFC). So if this value is TRUE, then we break the RFC and do the following:
    // If client asks for the empty service name, then we do not ignore the PADO that does not contain
    // the empty service-name. Instead we try to find the empty service-name field, and request it if its 
    // available. If not, then we request the first service available in the PADO.
    //
    BOOLEAN fAcceptAnyService;
    
}
ADAPTER;

//
// This is our call line context.
// All information pertinent to a line is kept in this context.
//
typedef struct 
_LINE
{
    
    //
    // Tag for the line control block (used for debugging).
    //
    ULONG tagLine;

    //
    // Keeps reference count on the line control block.
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added when a line is opened and removed when 
    //     line is closed.
    //
    // (b) A reference is added when a call context is created on the line,
    //     and removed when call context is cleaned up.
    //
    LONG lRef;

    //
    // Spin lock to synchronize access to shared members
    //
    NDIS_SPIN_LOCK lockLine;

    //
    // These are the various bit flags to indicate other state information for the line:
    //
    // (a) LNBF_LineIdle: Indicates that the line is in idle state. 
    //
    // (b) LNBF_LineOpen: Indicates that the line is in open state. Whan this flag is set,
    //                    only the following pending flags may be set additionally:
    //                    LNBF_LineClosePending
    //
    // (c) LNBF_LineClosePending: This pending flag can be only set only if LNBF_LineOpen is set, 
    //                            and indicates that there is a pending line close operation.
    //
    // (d) LNBF_LineClosed: Indicates that the line is in closed state. When this flag is set,
    //                      no other pending flags can be set.
    //
    // (e) LNBF_NotifyNDIS: This flag indicates that an asynchronous completion of a close line request
    //                      must be communicated to NDIS using NdisMSetInformationComplete().
    //
    // (f) LNBF_MakeOutgoingCalls: This flag is set if line is allowed to make outgoing calls.
    //                             It will be set in TpMakeCall() if machine is acting as a client
    //                             (pAdapter->fClientRole is TRUE).
    //
    // (g) LNBF_AcceptIncomingCalls: This flag is set if TAPI is able to take calls over this line.
    //                               It will be set in TpSetDefaultMediaDetection() if machine is acting as 
    //                               a server (pAdapter->fClientRole is FALSE).
    //
    ULONG ulLnFlags;
        #define LNBF_LineIdle                       0x00000000
        #define LNBF_LineOpen                       0x00000001
        #define LNBF_LineClosed                     0x00000002
        #define LNBF_LineClosePending               0x00000004
        #define LNBF_NotifyNDIS                     0x00000008
        #define LNBF_MakeOutgoingCalls              0x00000010
        #define LNBF_AcceptIncomingCalls            0x00000020

    //
    // Back pointer to owning adapter context
    //
    ADAPTER* pAdapter;

    //
    // Indicates the maximum number of calls that is permitted on this line.
    // Copy of pAdapter->nCallsPerLine.
    //
    UINT nMaxCalls;

    //
    // Indicates the number of current call contexts attached to the line.
    // 
    // It will be incremented when a call context is created and attached to a line,
    // and decremented when such a call context is destroyed.
    //
    UINT nActiveCalls;

    //
    // Link list of calls
    //
    LIST_ENTRY linkCalls;

    //
    // This is the handle assigned by TAPI to the line.
    // We obtain it in TpOpenLine() from TAPI.
    //
    HTAPI_LINE htLine;

    //
    // This is the handle assigned by us to the line.
    // We pass it to TAPI TpOpenLine().
    //
    // It is basically the index of the entry that points 
    // to the line context in pAdapter->TapiProv.LineTable
    //
    HDRV_LINE hdLine;

}
LINE;

typedef enum
_CALLSTATES
{
    //
    // Initial state
    //
    CL_stateIdle = 0,

    //
    // CLIENT states
    //
    CL_stateSendPadi,       // Prepare a PADI packet and broadcast it
    CL_stateWaitPado,       // Wait for a PADO packet; timeout and broadcast PADI again if necesarry
    CL_stateSendPadr,       // PADO packet received and processed, prepare a PADR packet and send it to the peer
    CL_stateWaitPads,       // Wait for a PADS packet; timeout and resend the PADR packet if necesarry

    //
    // SERVER states
    //
    CL_stateRecvdPadr,      // Received a PADR packet from the peer, and processing it.
                            // Once it is processed TAPI will be informed about the call.
                            //
                            
    CL_stateOffering,       // TAPI is informaed about the call and call is waiting for an OID_TAPI_ANSWER
                            // from TAPI. If we do not get a an OID_TAPI_ANSWER in a timely manner, we time out
                            // and drop the call
                            //
                            
    CL_stateSendPads,       // Call received a OID_TAPI_ANSWER from TAPI, so prepare a PADS packet and send it to
                            // the peer.
                            //
    //
    // CLIENT or SERVER states
    //
    CL_stateSessionUp,      // Either sent or received a PADS packet and session is established
    CL_stateDisconnected    // Call is disconnected. Call may proceed to this state from any of the 
                            // above states, it does not need to be connected first.
}
CALLSTATES;

//
// These identify the types of scheduled works:
//
//  - CWT_workFsmMakeCall: This item is scheduled from TpMakeCall() to start making a call.
//
typedef enum
_CALL_WORKTYPE
{
    CWT_workUnknown = 0,
    CWT_workFsmMakeCall
}
CALL_WORKTYPE;

//
// This is our call call context.
// All information pertinent to a call is kept in this context.
//
typedef struct
_CALL
{
    //
    // Points to the next and previous call contexts in a double linked list
    //
    LIST_ENTRY linkCalls;
    
    //
    // Tag for the call control block (used for debugging).
    //
    ULONG tagCall;

    //
    // Keeps reference count on the call control block.
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added for running the initial FSM function for the call.
    //
    // (b) A reference is added for dropping the call, and removed when drop call
    //     is called.
    // 
    // (c) A reference is added for closing the call, and removed when close call
    //     is called.
    //
    // (d) A reference is added when timers are set, and removed if timer expires,
    //     is cancelled or terminated.
    //
    // (e) When a packet is received to be dispatched, adapter context is locked,
    //     call context is found and referenced, adapter is unlocked and FSM function 
    //     is called.
    //
    // (f) For any other operation not listed here, programmer should do as in (e).
    //
    LONG lRef;

    //
    // Spin lock to synchronize access to shared members
    //
    NDIS_SPIN_LOCK lockCall;

    //
    // Indicates the calls PPPoE state
    //
    CALLSTATES stateCall;

    //
    // Indicates that the call is initiated from another machine, and this machine is acting as 
    // a server.
    //
    BOOLEAN fIncoming;

    //
    // These are the various bit flags to indicate other state information for the call:
    //
    // (a) CLBF_CallIdle: This is the initial state of the call.
    //
    // (b) CLBF_CallOpen: This flag is indicates that the call context is opened.
    //                    When a call context is created it is always created with CLBF_CallOpen
    //                    and CLBF_CallConnectPending flags set, then if call connects succesfully,
    //                    CLBF_CallConnectPending flag is reset, and only CLBF_CallOpen is left.
    //
    //                    The following pending flags might be set additionally:
    //                    CLBF_CallConnectPending : If this flag is set the call is still connecting.
    //                                              Otherwise it means that the call is connected, and 
    //                                              can make data over the link.
    //
    // (c) CLBF_CallConnectPending: This flag may be set only if CLBF_CallOpen is set. It means that
    //                              the call is still in connect pending state. You can look at pCall->stateCall
    //                              variable to retrieve the actual state of the call.
    //
    // (d) CLBF_CallDropped: This flag is set when call is dropped (disconnected).
    //                       The following pending flags might be set additionally:
    //                       CLBF_CallClosePending
    //
    // (e) CLBF_CallClosePending: This flag is set after the call is dropped and context is being cleared to 
    //                            be freed.
    //
    // (f) CLBF_CallClosed: This flag is set when call is closed (resources ready to be freed).
    //                      No pending flags might be set when this bit is set.
    //
    //
    //
    // (g) CLBF_NotifyNDIS: This flag indicates that an asynchronous completion of a close call request
    //                      must be communicated to NDIS using NdisMSetInformationComplete().
    //
    // (h) CLBF_CallReceivePacketHandlerScheduled: This flag indicates that the MpIndicateReceivedPackets()
    //                                             is scheduled to indicate packets in the receive queue.
    //
    ULONG ulClFlags;
        #define CLBF_CallIdle                           0x00000000
        #define CLBF_CallOpen                           0x00000001
        #define CLBF_CallConnectPending                 0x00000002
        #define CLBF_CallDropped                        0x00000004
        #define CLBF_CallClosePending                   0x00000008
        #define CLBF_CallClosed                         0x00000010
        #define CLBF_NotifyNDIS                         0x00000020
        #define CLBF_CallReceivePacketHandlerScheduled  0x00000040

    //
    // Back pointer to the owning line context
    //
    LINE* pLine;

    //
    // This is the handle assigned by TAPI to the call.
    // We obtain it in TpMakeCall() or TpAnswerCall() from TAPI.
    //
    HTAPI_CALL htCall;

    //
    // This is the handle assigned by us to the call.
    // We obtain this when we create the call context and pass it back to TAPI
    // either in return from TpMakeCall() or TpReceiveCall().
    //
    // This handle forms of 2 USHORT values appended.
    // The higher 16 bits represent the index to the pAdapter->TapiProv.hCallTable, and
    // the lower 16 bits is just a unique number generated everytime a call handle is created.
    //
    // This ensures the uniqueness of handles to avoid pitfalls that could result due to some weird
    // timing conditions.
    //
    HDRV_CALL hdCall;

    //
    // This gives the link speed. It is obtained from the underlying binding context when 
    // call is attached to the binding.
    //
    ULONG ulSpeed;

    //
    // This is the max frame size for the underlying binding context.
    // Passed to the call context in PrAddCallToBinding().
    //
    ULONG ulMaxFrameSize;

    //
    // This keeps TAPI's states. Its values are from LINECALLSTATE_ constants in SDK.
    //
    // States supported by us are:
    //  - LINECALLSTATE_IDLE
    //  - LINECALLSTATE_OFFERING
    //  - LINECALLSTATE_DIALING
    //  - LINECALLSTATE_PROCEEDING
    //  - LINECALLSTATE_CONNECTED
    //  - LINECALLSTATE_DISCONNECTED
    //
    ULONG ulTapiCallState;
        #define TAPI_LINECALLSTATES_SUPPORTED   ( LINECALLSTATE_IDLE        | \
                                                  LINECALLSTATE_OFFERING    | \
                                                  LINECALLSTATE_DIALING     | \
                                                  LINECALLSTATE_PROCEEDING  | \
                                                  LINECALLSTATE_CONNECTED   | \
                                                  LINECALLSTATE_DISCONNECTED ) 

    /*++++++++++++++++++++++++++++++++++++++++++++++++++++++

        Link info needed by NDISWAN
    
        typedef struct _NDIS_WAN_GET_LINK_INFO { 
            IN  NDIS_HANDLE     NdisLinkHandle; 
            OUT ULONG           MaxSendFrameSize; 
            OUT ULONG           MaxRecvFrameSize; 
            OUT ULONG           HeaderPadding; 
            OUT ULONG           TailPadding; 
            OUT ULONG           SendFramingBits; 
            OUT ULONG           RecvFramingBits; 
            OUT ULONG           SendCompressionBits; 
            OUT ULONG           RecvCompressionBits; 
            OUT ULONG           SendACCM; 
            OUT ULONG           RecvACCM; 
        } NDIS_WAN_GET_LINK_INFO, *PNDIS_WAN_GET_LINK_INFO; 

        typedef struct _NDIS_WAN_SET_LINK_INFO { 
            IN NDIS_HANDLE     NdisLinkHandle; 
            IN ULONG           MaxSendFrameSize; 
            IN ULONG           MaxRecvFrameSize; 
               ULONG           HeaderPadding; 
               ULONG           TailPadding; 
            IN ULONG           SendFramingBits; 
            IN ULONG           RecvFramingBits; 
            IN ULONG           SendCompressionBits; 
            IN ULONG           RecvCompressionBits; 
            IN ULONG           SendACCM; 
            IN ULONG           RecvACCM; 
        } NDIS_WAN_SET_LINK_INFO, *PNDIS_WAN_SET_LINK_INFO; 
 
    -------------------------------------------------------*/
    NDIS_WAN_GET_LINK_INFO NdisWanLinkInfo; 
    
    //
    // This is the string that holds the service-name for the call.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // We either obtain it in TpMakeCall() as the phone-number to dial, or
    // receive it from the peer for an incoming call.
    //
    CHAR ServiceName[MAX_SERVICE_NAME_LENGTH];

    //
    // Indicates the length of the service name string 
    //
    USHORT nServiceNameLength;

    //
    // This is the string that holds the AC-name for this call.
    // It must be an UTF-8 string per PPPoE RFC.
    //
    // For an outgoing call, we obtain it from the adapter's context,
    // for an incoming call we get it from PADO packet server sends.
    //
    CHAR ACName[MAX_AC_NAME_LENGTH];

    //
    // Indicates the length of the AC name string 
    //
    USHORT nACNameLength;

    //
    // Indicates if ACName was specified by the caller or not
    //
    BOOLEAN fACNameSpecified;

    //
    // Peer's MAC address, obtained either when we receive or send a PADO packet
    //
    CHAR DestAddr[6];

    //
    // Our MAC address, obtained from binding in PrAddCallToBinding()
    //
    CHAR SrcAddr[6];

    //
    // Indicates the session id for the call.
    //
    // As per PPPoE RFC, a call is identified uniquely by the peer's MAC addresses plus a session id.
    // In this implementation, we do not really care about the peer's MAC addresses, so we always
    // make a unique session id. This is partly why we do not support both client and server functionality
    // on the same box at the same time.
    //
    // For an incoming call, session id is selected as the index into pAdapter->TapiProv.hCallTable, and
    // for an outgoing call it is assigned by the peer so we just traverse active calls to identify the
    // correct call (which is very inefficient by the way, but this was a design decision that was discussed
    // and approved by the PMs - the main scenario is that most people will not have many outgoing calls -
    // anyway ).
    //
    USHORT usSessionId;

    //
    // Pointer to the binding context that the call is running over
    //
    BINDING* pBinding;

    //
    // Handle assigned to this peer-to-peer link by NDISWAN.
    // 
    // This value is passed to us in NDIS_MAC_LINE_UP. 
    // We indicate anything to NDISWAN using this handle.
    // 
    NDIS_HANDLE NdisLinkContext;

    //
    // This points to the last PPPoE control packet sent to the peer.
    //
    // This is necesarry for resending the packet on a timeout condition 
    // when we do not get a reply.
    //
    PPPOE_PACKET* pSendPacket;

    //
    // This is a special queue added to fix bug 172298 in Windows Bugs database.
    // The problem is that the payload packets received right after a PADS but before contexts are exchanged
    // with NDISWAN are dropped, and this causes a disturbing user experience.
    //
    // So I decided to change the packet receive mechanism. Instead I will queue up the packets and
    // use a timer to indicate them to NDISWAN. I prefered timers instead of scheduling a work item because
    // timers are more reliable than work items in terms of when to run.
    //
    LIST_ENTRY linkReceivedPackets;

        //
        // The maximum length of the queue
        //
        #define MAX_RECEIVED_PACKETS    100

    //
    // Number of packets in the received packet queue.
    // The value can not exceed MAX_RECEIVED_PACKETS
    //
    ULONG nReceivedPackets;
    
    //
    // This will be used to indicate the packets in the receive queue to NDISWAN
    //
    TIMERQITEM timerReceivedPackets;

        //
        // The maximum number of packets to be indicated from the queue in one function call.
        // If there are more items in the queue, we should schedule another timer.
        //
        #define MAX_INDICATE_RECEIVED_PACKETS   100
        #define RECEIVED_PACKETS_TIMEOUT        1

    //
    // This is the timer queue item we use for this call.
    //
    TIMERQITEM timerTimeout;

    //
    // Indicates the number of timeouts occured.
    // Max number of time outs is kept in pAdapter->nMaxTimeouts and is read from registry.
    //
    UINT nNumTimeouts;

}
CALL;

////////////////////////////////////
//
// Local macros
//
////////////////////////////////////

#define ALLOC_ADAPTER( ppA ) NdisAllocateMemoryWithTag( (PVOID*) ppA, sizeof( ADAPTER ), MTAG_ADAPTER )

#define FREE_ADAPTER( pA )  NdisFreeMemory( (PVOID) pA, sizeof( ADAPTER ), 0 );

#define VALIDATE_ADAPTER( pA ) ( (pA) && (pA->tagAdapter == MTAG_ADAPTER) )

VOID
CreateUniqueValue( 
    IN HDRV_CALL hdCall,
    OUT CHAR* pUniqueValue,
    OUT USHORT* pSize
    );

VOID 
ReferenceAdapter(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    );

VOID DereferenceAdapter(
    IN ADAPTER* pAdapter
    );

VOID 
MpNotifyBindingRemoval( 
    BINDING* pBinding 
    );

VOID
MpRecvPacket(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    );  

VOID
MpIndicateReceivedPackets(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event
    );

VOID 
MpScheduleIndicateReceivedPacketsHandler(
    CALL* pCall
    );

NDIS_STATUS
MpWanGetInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_INFO pWanInfo
    );
    
NDIS_STATUS
MpWanGetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_GET_LINK_INFO pWanLinkInfo
    );

NDIS_STATUS
MpWanSetLinkInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pWanLinkInfo
    );
    
//////////////////////////////////////////////////////////////
//
// Interface prototypes: Functions exposed from this module
//
//////////////////////////////////////////////////////////////
NDIS_STATUS
MpRegisterMiniport(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath,
    OUT NDIS_HANDLE* pNdisWrapperHandle
    );

// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

// Pad to the size of the given datatype.  (Borrowed from wdm.h which is not
// otherwise needed)
//
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

// Place in a TRACE argument list to correspond with a format of "%d" to print
// a percentage of two integers, or an average of two integers, or those
// values rounded.
//
#define PCTTRACE( n, d ) ((d) ? (((n) * 100) / (d)) : 0)
#define AVGTRACE( t, c ) ((c) ? ((t) / (c)) : 0)
#define PCTRNDTRACE( n, d ) ((d) ? (((((n) * 1000) / (d)) + 5) / 10) : 0)
#define AVGRNDTRACE( t, c ) ((c) ? (((((t) * 10) / (c)) + 5) / 10) : 0)

// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = 0xC0BBC0DE;
    return pBuf + MEMORY_ALLOCATION_ALIGNMENT;
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_NDIS_WORK_ITEM( pWorkItemLookasideList ) \
    NdisAllocateFromNPagedLookasideList( pWorkItemLookasideList )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( pWorkItemLookasideList, (pNwi) )



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\packet.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    packet.c

Abstract:

    This module contains all the necesarry routines for encapsulating PPPoE
    packets and their related NDIS and NDISWAN packets.

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

//////////////////////////////////////////////////////////////////////////
//
// Variables local to packet.c
// They are defined global only for debugging purposes.
//
///////////////////////////////////////////////////////////////////////////

//
// Flag that indicates if gl_lockPools is allocated or not
//
BOOLEAN gl_fPoolLockAllocated = FALSE;

//
// Spin lock to synchronize access to gl_ulNumPackets
//
NDIS_SPIN_LOCK gl_lockPools;

//
// Our pool of PPPoE buffer descriptors
//
BUFFERPOOL gl_poolBuffers;

//
// Our pool of PPPoE packet descriptors
//
PACKETPOOL gl_poolPackets;

//
// Ndis pool of buffer descriptors
//
NDIS_HANDLE gl_hNdisBufferPool;

//
// Non-paged lookaside list for PppoePacket structures
//
NPAGED_LOOKASIDE_LIST gl_llistPppoePackets;

//
// This is for debugging purposes. Shows the number of active packets
//
ULONG gl_ulNumPackets = 0;

//
// This defines the broadcast destination address
//
CHAR EthernetBroadcastAddress[6] = { (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff, 
                                     (CHAR) 0xff };

VOID 
ReferencePacket(
    IN PPPOE_PACKET* pPacket 
    )           
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the packet object.
    
Parameters:

    pPacket _ A pointer to the packet context.

Return Values:

    None
---------------------------------------------------------------------------*/
{                       
    LONG lRef;
    
    TRACE( TL_V, TM_Pk, ("+ReferencePacket") );

    lRef = NdisInterlockedIncrement( &pPacket->lRef );  

    TRACE( TL_V, TM_Pk, ("-ReferencePacket=$%x",lRef) );
}                                               


VOID 
DereferencePacket(
    IN PPPOE_PACKET* pPacket 
    )                   
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the packet object.

    When ref count reaches 0, packet is cleaned up.
    
Parameters:

    pPacket _ A pointer to the packet context.

Return Values:

    None
---------------------------------------------------------------------------*/
{       
    LONG lRef;
    
    TRACE( TL_V, TM_Pk, ("+DereferencePacket") );

    lRef = NdisInterlockedDecrement( &pPacket->lRef );

    if ( lRef == 0 )    
    {                                               

        if ( pPacket->ulFlags & PCBF_BufferChainedToPacket )
        {
            //
            // Unchain the buffer before freeing any packets
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Buffer unchained from packet") );
            
            NdisUnchainBufferAtFront( pPacket->pNdisPacket, &pPacket->pNdisBuffer );
        }
        
        if ( pPacket->ulFlags & PCBF_BufferAllocatedFromOurBufferPool )
        {
            //
            // Skipping check for pBuffer == NULL as this should never happen
            // But call NdisAdjustBufferLength() to set the buffer length to original value
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Buffer returned to our pool") );

            NdisAdjustBufferLength( pPacket->pNdisBuffer, PPPOE_PACKET_BUFFER_SIZE );
            
            FreeBufferToPool( &gl_poolBuffers, pPacket->pHeader, TRUE );
        }

        if ( pPacket->ulFlags & PCBF_BufferAllocatedFromNdisBufferPool )
        {
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Buffer returned to ndis pool") );
            
            NdisFreeBuffer( pPacket->pNdisBuffer );
        }
        
        if ( pPacket->ulFlags & PCBF_CallNdisMWanSendComplete )
        {
            //
            // Return packet back to NDISWAN
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Returning packet back to NDISWAN") );

            NdisMWanSendComplete(   PacketGetMiniportAdapter( pPacket )->MiniportAdapterHandle,
                                    PacketGetRelatedNdiswanPacket( pPacket ),
                                    PacketGetSendCompletionStatus( pPacket ) );

            //
            // Indicate to miniport that the packet is returned to NDISWAN
            //
            MpPacketOwnedByNdiswanReturned( PacketGetMiniportAdapter( pPacket ) );

        }

        if ( pPacket->ulFlags & PCBF_PacketAllocatedFromOurPacketPool )
        {
            //
            // Skipping check for pPacketHead == NULL as this should never happen
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Packet returned to our pool") );
            
            NdisReinitializePacket( pPacket->pNdisPacket );
        
            FreePacketToPool( &gl_poolPackets, pPacket->pPacketHead, TRUE );
        }

        if ( pPacket->ulFlags & PCBF_CallNdisReturnPackets )
        {
            //
            // Return packet back to NDIS
            //
            TRACE( TL_V, TM_Pk, ("DereferencePacket: Returning packet back to NDIS") );

            NdisReturnPackets( &pPacket->pNdisPacket, 1 );

            //
            // Indicate to protocol that the packet is returned to NDIS.
            //
            PrPacketOwnedByNdisReturned( pPacket->pBinding );

        }

        //
        // Finally return PppoePacket to the lookaside list
        //
        NdisFreeToNPagedLookasideList( &gl_llistPppoePackets, (PVOID) pPacket );

        NdisAcquireSpinLock( &gl_lockPools );
        
        gl_ulNumPackets--;

        TRACE( TL_V, TM_Pk, ("DereferencePacket: gl_ulNumPacket=$%x", gl_ulNumPackets) );

        NdisReleaseSpinLock( &gl_lockPools );

    }       

    TRACE( TL_V, TM_Pk, ("-DereferencePacket=$%x",lRef) );
}                                                   

VOID 
RetrieveTag(
    IN OUT PPPOE_PACKET*    pPacket,
    IN PACKET_TAGS          tagType,
    OUT USHORT *            pTagLength,
    OUT CHAR**              pTagValue,
    IN USHORT               prevTagLength,
    IN CHAR *               prevTagValue,
    IN BOOLEAN              fSetTagInPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    You can call this function on a received packet processed with one of the 
    PacketInitialize*FromReceived() functions.

    It will not operate on a PAYLOAD packet, although you can call it safely.

    It will retrieve and return the next length - value pair for a specific tag.
    To retrieve the 1st one, pass 0 and NULL for prevTag* parameters.

    If you pass fSetTagInPacket as TRUE, and if the next tag is found and the tag is known 
    to PppoePacket struct, then the fields for the tag in the packet are updated to point
    to the found tag.

    If there are no next tags, then *pTagValue will point to NULL, and *pTagLength 
    will point to '0'.
    
Parameters:

    pPacket _ Pointer to a packet context prepared by a PacketInitializeXXXToSend() 
              function, or PacketInitializeFromReceived().

    tagType _ Type of the tag being searched for.

    pTagLength _ A pointer to a USHORT var that will keep the length of the returned tag.

    pTagValue _ A pointer to the value of the tag which is basically a blob of 
                length *pTagLength.

    prevTagLength _ The length of the value of the previous tag.

    prevTagValue _ Points to the beginning of the value of the previous tag.

    fSetTagInPacket _ Indicates that if a tag is found and is native to PPPoE packet context,
                      then PPPoE packet context must be updated to point to this new tag.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    CHAR*   pBuf = NULL;
    CHAR*   pBufEnd = NULL;

    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    TRACE( TL_V, TM_Pk, ("+RetrieveTag") );

    //
    // Initialize the output parameters
    //
    *pTagLength = (USHORT) 0;
    *pTagValue = NULL;

    //
    // If this is a payload packet, then do not search for any tags
    //
    if ( PacketGetCode( pPacket ) == PACKET_CODE_PAYLOAD )
    {
        TRACE( TL_V, TM_Pk, ("-RetrieveTag: No tags. Payload packet") );

        return;
    }

    //
    // Find the start point to search for the tag
    //
    if ( prevTagValue != NULL )
    {
        //
        // Caller wants the next tag, so make pBuf point to end of the prev tag value
        //
        pBuf = prevTagValue + prevTagLength;
    }
    else
    {
        //
        // Caller wants the first tag in the packet
        //
        pBuf = pPacket->pPayload;
    }
        
    //
    // Find the end point of the tag payload area
    //
    pBufEnd = pPacket->pPayload + PacketGetLength( pPacket );

    //
    // Search for the tag until we step outside the boundaries
    //
    while ( pBuf + PPPOE_TAG_HEADER_LENGTH <= pBufEnd )
    {

        USHORT usTagLength;
        USHORT usTagType;

        usTagType = ntohs( *((USHORT UNALIGNED *) pBuf) ) ;
        ((USHORT*) pBuf)++;

        usTagLength = ntohs( *((USHORT UNALIGNED *) pBuf) ) ;
        ((USHORT*) pBuf)++;
        
        if ( usTagType == tagType )
        {
            //
            // Tag found, retrieve length and values
            //
            TRACE( TL_N, TM_Pk, ("RetrieveTag: Tag found:$%x", *pTagLength) );

            *pTagLength = usTagLength;
            *pTagValue = pBuf;

            break;
        }

        pBuf += usTagLength;

    } 

    //
    // Check if tag was found
    //
    if ( *pTagValue != NULL )
    {
    
        //
        // Tag found. Check if the caller wants to set it in the PppoePacket
        //
        if ( fSetTagInPacket )
        {
            TRACE( TL_V, TM_Pk, ("RetrieveTag: Setting tag in packet") );
            
            switch ( tagType )
            {
    
                case tagEndOfList:

                        break;
                        
                case tagServiceName:

                        pPacket->tagServiceNameLength = *pTagLength;
                        pPacket->tagServiceNameValue  = *pTagValue;
            
                        break;
                        
                case tagACName:

                        pPacket->tagACNameLength = *pTagLength;
                        pPacket->tagACNameValue  = *pTagValue;

                        break;
                        
                case tagHostUnique:

                        pPacket->tagHostUniqueLength = *pTagLength;
                        pPacket->tagHostUniqueValue  = *pTagValue;

                        break;
                        
                case tagACCookie:

                        pPacket->tagACCookieLength = *pTagLength;
                        pPacket->tagACCookieValue  = *pTagValue;

                        break;
                        
                case tagRelaySessionId:

                        pPacket->tagRelaySessionIdLength = *pTagLength;
                        pPacket->tagRelaySessionIdValue  = *pTagValue;
                        
                        break;
        
                case tagServiceNameError:

                        pPacket->tagErrorType   = tagServiceNameError;
                        pPacket->tagErrorTagLength = *pTagLength;
                        pPacket->tagErrorTagValue  = *pTagValue;

                        break;
                        
                case tagACSystemError:

                        pPacket->tagErrorType   = tagACSystemError;
                        pPacket->tagErrorTagLength = *pTagLength;
                        pPacket->tagErrorTagValue  = *pTagValue;

                        break;
                        
                case tagGenericError:

                        pPacket->tagErrorType   = tagGenericError;
                        pPacket->tagErrorTagLength = *pTagLength;
                        pPacket->tagErrorTagValue  = *pTagValue;

                        break;

                default:

                        break;
            }

        }
    }

    TRACE( TL_V, TM_Pk, ("-RetrieveTag") );
}

NDIS_STATUS 
PreparePacketForWire(
    IN OUT PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function prepares the packet for wire.

    It must be called inside a PacketInitializeXXXToSend() function after all
    processing is done with the packet to prepare it to be transmitted over the wire.

    It basically creates and writes the tags into the payload area of the packet,
    and finally adjusts the length of the buffer to let Ndis know the extents of the
    valid data blob.
    
Parameters:

    pPacket _ Pointer to a packet context prepared by a PacketInitializeXXXToSend() 
              function.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    
---------------------------------------------------------------------------*/       
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    CHAR* pBuf;
    
    ASSERT( pPacket != NULL );

    TRACE( TL_V, TM_Pk, ("+PreparePacketForWire") );

    //
    // Now insert the tags if packet is a Discovery Ethernet packet
    //
    switch ( PacketGetCode( pPacket ) ) 
    {
        case PACKET_CODE_PADI:

                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue);

                        if ( pPacket->tagHostUniqueLength > 0 ) 
                        {

                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }
                        
                        break;
        
        case PACKET_CODE_PADO:

                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue );
                                         
                        if ( pPacket->tagHostUniqueLength > 0 )     
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                        
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }

                        if ( pPacket->tagRelaySessionIdLength > 0 )                                      
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting relay sesion id tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagRelaySessionId, 
                                             pPacket->tagRelaySessionIdLength,
                                             pPacket->tagRelaySessionIdValue,
                                             &pPacket->tagRelaySessionIdValue );
                        }
                        
                        PacketInsertTag( pPacket, 
                                         tagACName, 
                                         pPacket->tagACNameLength,
                                         pPacket->tagACNameValue,
                                         &pPacket->tagACNameValue );

                        PacketInsertTag( pPacket, 
                                         tagACCookie, 
                                         pPacket->tagACCookieLength,
                                         pPacket->tagACCookieValue,
                                         &pPacket->tagACCookieValue );
                        break;
        
        case PACKET_CODE_PADR:
        
                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue );
                                         
                        if ( pPacket->tagHostUniqueLength > 0 ) 
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                        
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }

                        if ( pPacket->tagRelaySessionIdLength > 0 )                                      
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting relay sesion id tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagRelaySessionId, 
                                             pPacket->tagRelaySessionIdLength,
                                             pPacket->tagRelaySessionIdValue,
                                             &pPacket->tagRelaySessionIdValue );
                        }
                                             
                        if ( pPacket->tagACCookieLength > 0 )                                        
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting ac-ccokie tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagACCookie, 
                                             pPacket->tagACCookieLength,
                                             pPacket->tagACCookieValue,
                                             &pPacket->tagACCookieValue );
                        }
                        
                        break;
        
        case PACKET_CODE_PADS:

                        PacketInsertTag( pPacket, 
                                         tagServiceName, 
                                         pPacket->tagServiceNameLength,
                                         pPacket->tagServiceNameValue,
                                         &pPacket->tagServiceNameValue );
                                         
                        if ( pPacket->tagHostUniqueLength > 0 ) 
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting host unique tag") );
                        
                            PacketInsertTag( pPacket, 
                                             tagHostUnique, 
                                             pPacket->tagHostUniqueLength,
                                             pPacket->tagHostUniqueValue,
                                             &pPacket->tagHostUniqueValue );
                        }

                        if ( pPacket->tagRelaySessionIdLength > 0 )     
                        {
                            TRACE( TL_N, TM_Pk, ("PreparePacketForWire: Inserting relay sesion id tag") );
                            
                            PacketInsertTag( pPacket, 
                                             tagRelaySessionId, 
                                             pPacket->tagRelaySessionIdLength,
                                             pPacket->tagRelaySessionIdValue,
                                             &pPacket->tagRelaySessionIdValue );
                        }
                                             
                        break;
                        
        case PACKET_CODE_PADT:

                        break;
                        
        case PACKET_CODE_PAYLOAD:

                        break;
        
        default:
            status = NDIS_STATUS_INVALID_PACKET;
    }

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // Adjust buffer length
        //
        NdisAdjustBufferLength( pPacket->pNdisBuffer, 
                                (UINT) ( PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH ) );
    }

    TRACE( TL_V, TM_Pk, ("-PreparePacketForWire=$%x",status) );

    return status;
}

PPPOE_PACKET* 
PacketCreateSimple()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function allocates and initializes a simple packet.

    A simple packet is mainly used for control packets to be sent.
    Its buffer, and packet is allocated from our pools, buffer is chained to
    packet.

    On return all following values point to valid places and are safe for use:
    pHeader
    pPayload
    pNdisBuffer
    pNdisPacket
    
Parameters:

    None

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    TRACE( TL_V, TM_Pk, ("+PacketCreateSimple") );
    
    //
    // Allocate a packet
    //
    pPacket = PacketAlloc();
    if ( pPacket == NULL )
    {
        TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",NULL) );

        return NULL;
    }

    //
    // Allocate NdisBuffer from our pool
    //
    pPacket->pHeader = GetBufferFromPool( &gl_poolBuffers );
    
    if ( pPacket->pHeader == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketCreateSimple: Could not get buffer from our pool") );

        TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",NULL) );
        
        PacketFree( pPacket );

        return NULL;
    }

    pPacket->ulFlags |= PCBF_BufferAllocatedFromOurBufferPool;

    //
    // Clean up the buffer area
    //
    NdisZeroMemory( pPacket->pHeader, PPPOE_PACKET_BUFFER_SIZE * sizeof( CHAR ) );

    //
    // Point built-in NDIS buffer pointer to NDIS buffer of buffer from pool
    //
    pPacket->pNdisBuffer = NdisBufferFromBuffer( pPacket->pHeader );

    //
    // Allocate an NDIS packet from our pool
    //
    pPacket->pNdisPacket = GetPacketFromPool( &gl_poolPackets, &pPacket->pPacketHead );

    if ( pPacket->pNdisPacket == NULL ) 
    {
        
        TRACE( TL_A, TM_Pk, ("PacketCreateSimple: Could not get packet from our pool") );

        TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",NULL) );

        PacketFree( pPacket );

        return NULL;
    }

    pPacket->ulFlags |= PCBF_PacketAllocatedFromOurPacketPool;

    //
    // Chain buffer to packet
    //
    NdisChainBufferAtFront( pPacket->pNdisPacket, pPacket->pNdisBuffer );

    pPacket->ulFlags |= PCBF_BufferChainedToPacket;

    //
    // Set the payload and payload length
    //
    pPacket->pPayload = pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH; 

    //
    // Set the input NDIS_PACKET to the reserved area so that we can reach it
    // when we have to return this packet back to the upper layer.
    //
    *((PPPOE_PACKET UNALIGNED **)(&pPacket->pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)])) = pPacket;

    TRACE( TL_V, TM_Pk, ("-PacketCreateSimple=$%x",pPacket) );

    return pPacket;
}


PPPOE_PACKET* 
PacketCreateForReceived(
    PBINDING pBinding,
    PNDIS_PACKET pNdisPacket,
    PNDIS_BUFFER pNdisBuffer,
    PUCHAR pContents
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function allocates and initializes a packet from a received packet.

    This function is used for perf optimization. When the received packet has 
    a single buffer that we can pass to the miniport.

    On return all following values point to valid places and are safe for use:
    pHeader
    pPayload
    pNdisBuffer
    pNdisPacket
    
Parameters:

    pBinding _ The binding over which this packet is received. 
    
    pNdisPacket _ Ndis Packet descriptor from the received packet.

    pNdisBuffer _ Ndis Buffer descriptor from the received packet.

    pContents _ Pointer to the contents of the buffer.

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    TRACE( TL_V, TM_Pk, ("+PacketCreateForReceived") );
    
    //
    // Allocate a packet
    //
    pPacket = PacketAlloc();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_V, TM_Pk, ("-PacketCreateForReceived=$%x",NULL) );

        return NULL;
    }

    //
    // Mark the packet so we return it to NDIS when it is freed
    //
    pPacket->ulFlags |= PCBF_CallNdisReturnPackets;

    //
    // Save the binding and indicate to protocol such a packet is created using
    // PrPacketOwnedByNdisReceived()
    //
    pPacket->pBinding = pBinding;

    PrPacketOwnedByNdisReceived( pBinding );
    
    //
    // Set the pointers 
    //
    pPacket->pHeader = pContents;
    
    pPacket->pNdisBuffer = pNdisBuffer;

    pPacket->pNdisPacket = pNdisPacket;

    pPacket->pPayload = pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH; 

    TRACE( TL_V, TM_Pk, ("-PacketCreateForReceived=$%x",pPacket) );

    return pPacket;
}


PPPOE_PACKET*
PacketNdis2Pppoe(
    IN PBINDING pBinding,
    IN PNDIS_PACKET pNdisPacket,
    OUT PINT pRefCount
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to convert only NDIS packets indicated by PrReceivePacket().

    If packet is received by PrReceive() then you should not be using this function.

    We look at the Ndis buffer, and if it has a single flat buffer, then we exploit it
    and use the original Ndis packets buffer descriptors so we do not do any copy,
    otherwise we create our own copy of it as PPPoE packet, and operate on it. 
    ( AliD says, 99% of the time the single flat buffer case will be true. )

    If we use the original Ndis packet, then we return 1 in the pRefCount parameter, 
    otherwise we return 0.
    
    On return all following values point to valid places and are safe for use:
    pHeader
    pPayload
    pNdisBuffer
    pNdisPacket
    
Parameters:

    pBinding _ The binding over which this packet is received. 
    
    pNdisPacket _ Original, unprocessed Ndis packet. 
                  This must be indicated by ProtocolReceivePacket().

    pRefCount _ Reference count to be returned to Ndis from ProtocolReceivePacket().
                We return 1 if we can use the Ndis packet and buffer descriptors, otherwise
                we make our own copy so we won't need the original Ndis packet, so we return 0.

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    NDIS_BUFFER* pNdisBuffer = NULL;
    UINT nBufferCount = 0;
    UINT nTotalLength = 0;

    PVOID pBufferContents = NULL;
    UINT nBufferLength;

    UINT nCopiedBufferLength = 0;

    BOOLEAN fReturnPacket = FALSE;

    TRACE( TL_V, TM_Pk, ("+PacketNdis2Pppoe") );

    do
    {
        //
        // Query the packet and get the total length and the pointer to first buffer
        //
        NdisQueryPacket( pNdisPacket,
                         NULL,
                         &nBufferCount,
                         &pNdisBuffer,
                         &nTotalLength );

        //
        // Make sure indicated packet is not larger than expected
        //
        if ( nTotalLength > (UINT) PPPOE_PACKET_BUFFER_SIZE )
        {
            TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Packet larger than expected") );
            
            break;
        }
                         
        if ( nBufferCount == 1 &&
             NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES)
        {
            //
            // We can handle this case efficiently
            //

            //
            // Since we will be using the original Ndis packet and buffers, make sure
            // length specified in the PPPoE packet does not exceed the total length
            // of the Ndis packet
            //

            USHORT usPppoePacketLength;
            
            NdisQueryBufferSafe( pNdisBuffer,
                                 &pBufferContents,
                                 &nBufferLength,
                                 NormalPagePriority );
    
            if ( pBufferContents == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: System resources low, dropping packet") );

                break;
            }

            if ( nBufferLength < ETHERNET_HEADER_LENGTH )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Packet header smaller than expected") );

                break;
            }

            if ( !PacketFastIsPPPoE( pBufferContents, ETHERNET_HEADER_LENGTH ) ) 
            {
                TRACE( TL_V, TM_Pk, ("PacketNdis2Pppoe: Packet is not PPPoE") );
    
                break;
            }

            usPppoePacketLength = ntohs( * ( USHORT UNALIGNED * ) ( (PUCHAR) pBufferContents + PPPOE_PACKET_LENGTH_OFFSET ) );

            if ( (UINT) usPppoePacketLength > nTotalLength )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: PPPoE Packet length larger than Ndis packet length") );

                break;
            }

            //
            // Let's create our PPPoE packet to keep the copy of the received packet
            //
            pPacket = PacketCreateForReceived( pBinding,
                                               pNdisPacket,
                                               pNdisBuffer,
                                               pBufferContents );
        
            if ( pPacket == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Could not allocate context to copy the packet") );
        
                break;
            }

            fReturnPacket = TRUE;
            
            *pRefCount = 1;                         

        }
        else
        {

            //
            // Since Ndis packet contains multiple buffers, we can not handle this case efficiently.
            // We need to allocate a PPPoE packet, copy the contents of the Ndis packet as a flat
            // buffer to this packet, and then operate on it.
            //

            //
            // Let's create our PPPoE packet to keep the copy of the received packet
            //
            pPacket = PacketCreateSimple();
        
            if ( pPacket == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Could not allocate context to copy the packet") );
        
                break;
            }
    
            //
            // Retrieve the header and check if the packet is a PPPoE frame or not
            //
            do
            {
                NdisQueryBufferSafe( pNdisBuffer,
                                     &pBufferContents,
                                     &nBufferLength,
                                     NormalPagePriority );
    
                if ( pBufferContents == NULL )
                {
                    TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: System resources low, dropping packet") );
    
                    break;
                }
    
                NdisMoveMemory( pPacket->pHeader + nCopiedBufferLength,
                                pBufferContents,
                                nBufferLength );
    
                nCopiedBufferLength += nBufferLength;                                
    
            } while ( nCopiedBufferLength < ETHERNET_HEADER_LENGTH );
    
            if ( nCopiedBufferLength < ETHERNET_HEADER_LENGTH )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Header could not be retrieved") );
    
                break;
            }
            
            if ( !PacketFastIsPPPoE( pPacket->pHeader, ETHERNET_HEADER_LENGTH ) ) 
            {
                TRACE( TL_V, TM_Pk, ("PacketNdis2Pppoe: Packet is not PPPoE") );
    
                break;
            }
    
            //
            // Since we know that the packet is PPPoE, copy the rest of the data to our 
            // own copy of the packet
            //
            NdisGetNextBuffer( pNdisBuffer,
                               &pNdisBuffer );
            
            while ( pNdisBuffer != NULL )
            {
    
                NdisQueryBufferSafe( pNdisBuffer,
                                     &pBufferContents,
                                     &nBufferLength,
                                     NormalPagePriority );
    
                if ( pBufferContents == NULL )
                {
                    TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: System resources low, dropping packet") );
    
                    break;
                }
    
                NdisMoveMemory( pPacket->pHeader + nCopiedBufferLength,
                                pBufferContents,
                                nBufferLength );
    
                nCopiedBufferLength += nBufferLength;                                
    
                NdisGetNextBuffer( pNdisBuffer,
                                   &pNdisBuffer );
            } 
    
            //
            // Check if we could copy the whole chain of buffers
            //
            if ( nCopiedBufferLength < nTotalLength )
            {
                TRACE( TL_A, TM_Pk, ("PacketNdis2Pppoe: Failed to copy the whole data from all buffers") );
    
                break;
            }

            fReturnPacket = TRUE;
            
            *pRefCount = 0;                         
        }

    } while ( FALSE );

    if ( !fReturnPacket )
    {
        if ( pPacket )
        {
            PacketFree( pPacket );

            pPacket = NULL;
        }
    }

    TRACE( TL_V, TM_Pk, ("-PacketNdis2Pppoe=$%x", pPacket) );

    return pPacket;

}



BOOLEAN 
PacketIsPPPoE(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to understand if the received packet is a PPPoE
    packet or not. If it is then, it should be further processed, otherwise it 
    should be dropped.
             
Parameters:

    pPacket _ Pointer to a packet context prepared.

Return Values:

    Pointer to an initialized PPPoE packet context.
    
---------------------------------------------------------------------------*/   
{
    BOOLEAN fReturn = FALSE;

    TRACE( TL_V, TM_Pk, ("+PacketIsPPPoE") );

    do
    {

        //
        // Check packet ether type
        //
        if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY &&
             PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_PAYLOAD ) 
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Unknown ether type") );

            break;
        }

        //
        // Check packet version
        //
        if ( PacketGetVersion( pPacket ) != PACKET_VERSION )
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Unknown packet version") );

            break;
        }
            
        //
        // Check packet type
        //
        if ( PacketGetType( pPacket ) != PACKET_TYPE )
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Unknown packet type") );

            break;
        }
    
        //
        // Make sure length does not exceed PACKET_GEN_MAX_LENGTH 
        //
        if ( PacketGetLength( pPacket ) > PACKET_GEN_MAX_LENGTH )
        {
            TRACE( TL_A, TM_Pk, ("PacketIsPPPoE: Packet larger than expected") );

            break;
        }

        fReturn = TRUE;
        
    } while ( FALSE );
    
    TRACE( TL_V, TM_Pk, ("-PacketIsPPPoE=$%d",fReturn) );

    return fReturn;
}

BOOLEAN
PacketFastIsPPPoE(
    IN CHAR* HeaderBuffer,
    IN UINT HeaderBufferSize
    )
{
    BOOLEAN fRet = FALSE;
    USHORT usEtherType;
    
    TRACE( TL_V, TM_Pk, ("+PacketFastIsPPPoE") );

    do
    {
    
        if ( HeaderBufferSize != ETHERNET_HEADER_LENGTH )
        {
            //
            // Header is not ethernet, so drop the packet
            //
            TRACE( TL_A, TM_Pk, ("PacketFastIsPPPoE: Bad packet header") );
        
            break;
        }

        //
        // Retrieve the ether type and see if packet of any interest to us
        //
        usEtherType = ntohs( * ( USHORT UNALIGNED * ) (HeaderBuffer + PPPOE_PACKET_ETHER_TYPE_OFFSET ) );

        if ( usEtherType == PACKET_ETHERTYPE_DISCOVERY ||
             usEtherType == PACKET_ETHERTYPE_PAYLOAD )
        {
            //
            // Valid ethertype, so accept the packet
            //
            fRet = TRUE;
        }

    } while ( FALSE );
    
    TRACE( TL_V, TM_Pk, ("-PacketFastIsPPPoE") );

    return fRet;
}
    
VOID
RetrieveErrorTags(
    IN PPPOE_PACKET* pPacket
    )
{
    USHORT tagLength = 0;
    CHAR* tagValue = NULL;


    TRACE( TL_V, TM_Pk, ("+RetrieveErrorTags") );

    RetrieveTag(    pPacket,
                    tagServiceNameError,
                    &tagLength,
                    &tagValue,
                    0,
                    NULL,
                    TRUE );

    if ( tagValue != NULL )
    {
        TRACE( TL_V, TM_Pk, ("RetrieveErrorTags: ServiceNameError tag received") );

        pPacket->ulFlags |= PCBF_ErrorTagReceived;
    }

    if ( !( pPacket->ulFlags & PCBF_ErrorTagReceived ) )
    {

        RetrieveTag(    pPacket,
                        tagACSystemError,
                        &tagLength,
                        &tagValue,
                        0,
                        NULL,
                        TRUE );

        if ( tagValue != NULL )
        {
            TRACE( TL_V, TM_Pk, ("RetrieveErrorTags: ACSystemError tag received") );
    
            pPacket->ulFlags |= PCBF_ErrorTagReceived;
        }

    }

    if ( !( pPacket->ulFlags & PCBF_ErrorTagReceived ) )
    {

        RetrieveTag(    pPacket,
                        tagGenericError,
                        &tagLength,
                        &tagValue,
                        0,
                        NULL,
                        TRUE );
    
        if ( tagValue != NULL )
        {
            TRACE( TL_V, TM_Pk, ("RetrieveErrorTags: GenericError tag received") );
    
            pPacket->ulFlags |= PCBF_ErrorTagReceived;
        }

    }


    TRACE( TL_V, TM_Pk, ("-RetrieveErrorTags") );

}

///////////////////////////////////////////////////////////////////////////
//
// Interface functions  (exposed outside)
//
///////////////////////////////////////////////////////////////////////////

VOID 
PacketPoolInit()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function initializes or incements the ref count on the this module.

    Both miniport and protocol will call this function in their register routines
    to allocate packet pools. Only then they can call functions from this module.

    We create the packet pools if gl_ulNumPackets is 0, otherwise we just increment
    gl_ulNumPackets, and that reference will be removed when the caller calls
    PacketPoolUninit() later.

Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Pk, ("+PacketPoolInit") );

    //
    // Make sure global lock is allocated 
    //
    if ( !gl_fPoolLockAllocated ) 
    {       
        TRACE( TL_N, TM_Pk, ("PacketPoolInit: First call, allocating global lock") );
        
        //
        // If global lock is not allocated, then this is the first call,
        // so allocate the spin lock
        //
        NdisAllocateSpinLock( &gl_lockPools );

        gl_fPoolLockAllocated = TRUE;
    }

    NdisAcquireSpinLock( &gl_lockPools );
        
    if ( gl_ulNumPackets == 0 )
    {
        PacketPoolAlloc();
    }

    gl_ulNumPackets++;
        
    NdisReleaseSpinLock( &gl_lockPools );

    TRACE( TL_N, TM_Pk, ("-PacketPoolInit") );

}

VOID 
PacketPoolUninit()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function uninitializes or decrements the ref count on the this module.

    Both miniport and protocol will call this function when they are done with
    this module, and if ref count has dropped to 0, this function will deallocate
    the alloated pools.

Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Pk, ("+PacketPoolUninit") );

    //
    // Make sure global lock is allocated 
    //
    if ( !gl_fPoolLockAllocated ) 
    {
        TRACE( TL_A, TM_Pk, ("PacketPoolUninit: Global not allocated yet") );

        TRACE( TL_N, TM_Pk, ("-PacketPoolUninit") );

        return;
    }

    NdisAcquireSpinLock( &gl_lockPools );

    gl_ulNumPackets--;
    
    if ( gl_ulNumPackets == 0 )
    {
        PacketPoolFree();
    }

    NdisReleaseSpinLock( &gl_lockPools );

    TRACE( TL_N, TM_Pk, ("-PacketPoolUninit") );

}

VOID 
PacketPoolAlloc()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function wraps the initialization of buffers and packet pools.

    It is called from PacketPoolInit().
    
Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketPoolAlloc") );

    //
    // Initialize our header pool
    //
    InitBufferPool( &gl_poolBuffers,
                    PPPOE_PACKET_BUFFER_SIZE,
                    0, 10, 0,
                    TRUE,
                    MTAG_BUFFERPOOL );

    //
    // Initialize our packet pool
    //
    InitPacketPool( &gl_poolPackets,
                    3 * sizeof( PVOID ), 0, 30, 0,
                    MTAG_PACKETPOOL );

    //
    // Initialize the Ndis Buffer Pool
    // No need to check for status, as DDK says, 
    // it always returns NDIS_STATUS_SUCCESS
    //
    NdisAllocateBufferPool( &status,
                            &gl_hNdisBufferPool,
                            30 );

    //
    // Initialize the control msg lookaside list
    //
    NdisInitializeNPagedLookasideList(
            &gl_llistPppoePackets,      // IN PNPAGED_LOOKASIDE_LIST  Lookaside,
            NULL,                       // IN PALLOCATE_FUNCTION  Allocate  OPTIONAL,
            NULL,                       // IN PFREE_FUNCTION  Free  OPTIONAL,
            0,                          // IN ULONG  Flags,
            sizeof(PPPOE_PACKET),       // IN ULONG  Size,
            MTAG_PPPOEPACKET,           // IN ULONG  Tag,
            0,                          // IN USHORT  Depth
            );

    TRACE( TL_N, TM_Pk, ("-PacketPoolAlloc") );

 }

VOID 
PacketPoolFree()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function wraps the clean up of buffers and packet pools.

    It is called from PacketPoolUninit() when gl_ulNumPackets reaches 0.
    
Parameters:

    None

Return Values:

    None
    
---------------------------------------------------------------------------*/
{

    TRACE( TL_N, TM_Pk, ("+PacketPoolFree") );

    FreeBufferPool( &gl_poolBuffers );

    FreePacketPool( &gl_poolPackets );

    NdisFreeBufferPool( &gl_hNdisBufferPool );

    NdisDeleteNPagedLookasideList( &gl_llistPppoePackets );

    TRACE( TL_N, TM_Pk, ("-PacketPoolFree") );

}
    
PPPOE_PACKET* 
PacketAlloc()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function allocates a PPPoE packet context, but it does not create 
    the packet and buffer descriptors.
    
Parameters:

    None

Return Values:

    NULL or a pointer to a new PPPoE packet context.
    
---------------------------------------------------------------------------*/
{
    PPPOE_PACKET* pPacket = NULL;

    TRACE( TL_V, TM_Pk, ("+PacketAlloc") );

    do
    {
        //
        // Allocate a PppoePacket struct from the lookaside list
        //
        pPacket = (PPPOE_PACKET*) NdisAllocateFromNPagedLookasideList( &gl_llistPppoePackets );

        if ( pPacket == NULL )
            break;

        NdisAcquireSpinLock( &gl_lockPools );
        
        gl_ulNumPackets++;

        NdisReleaseSpinLock( &gl_lockPools );

        //
        // Initialize the contents of the PppoePacket that will be returned
        //
        NdisZeroMemory( pPacket, sizeof( PPPOE_PACKET ) );

        InitializeListHead( &pPacket->linkPackets );

        ReferencePacket( pPacket );

    } while ( FALSE );

    TRACE( TL_V, TM_Pk, ("-PacketAlloc=$%x",pPacket) );

    return pPacket;
}

VOID 
PacketFree(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to free a packet, but the effect is just decrementing 
    the ref count on the object.
    
Parameters:

    pPacket _ A pointer to the packet to be freed.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{

    TRACE( TL_V, TM_Pk, ("+PacketFree") );

    ASSERT( pPacket != NULL );

    DereferencePacket( pPacket );

    TRACE( TL_V, TM_Pk, ("-PacketFree") );
}

NDIS_STATUS 
PacketInsertTag(
    IN  PPPOE_PACKET*   pPacket,
    IN  PACKET_TAGS     tagType,
    IN  USHORT          tagLength,
    IN  CHAR*           tagValue,
    OUT CHAR**          pNewTagValue    
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to insert additional tags into a PPPoE packet.
    
Parameters:

    pPacket _ pPacket must be pointing to a packet that was processed using 
              one of the PacketInitialize*ToSend() functions.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    
---------------------------------------------------------------------------*/   
{
    CHAR *pBuf = NULL;
    USHORT usMaxLength = PACKET_GEN_MAX_LENGTH;

    ASSERT( pPacket != NULL );

    TRACE( TL_V, TM_Pk, ("+PacketInsertTag") );

    //
    // Check for length restrictions
    //
    if ( PacketGetCode( pPacket ) == (USHORT) PACKET_CODE_PADI )
        usMaxLength = PACKET_PADI_MAX_LENGTH;

    if ( PacketGetLength( pPacket ) + PPPOE_TAG_HEADER_LENGTH + tagLength > usMaxLength )
    {
        TRACE( TL_A, TM_Pk, ("PacketInsertTag: Can not insert tag, exceeding max packet length") );

        TRACE( TL_V, TM_Pk, ("-PacketInsertTag") );

        return NDIS_STATUS_INVALID_PACKET;
    }

    //
    // Find the end of the payload
    //
    pBuf = pPacket->pPayload + PacketGetLength( pPacket );

    //
    // Insert the length - type - value triplet into the packet
    //
    *((USHORT UNALIGNED *) pBuf) = htons( tagType );
    ((USHORT*) pBuf)++;
    
    *((USHORT UNALIGNED *) pBuf) = htons( tagLength );
    ((USHORT*) pBuf)++;

    if ( tagLength > 0)
        NdisMoveMemory( pBuf, tagValue, tagLength );

    if ( pNewTagValue )
    {
        *pNewTagValue = pBuf;
    }

    //
    // Update the Length field
    //
    PacketSetLength( pPacket, ( PacketGetLength( pPacket ) + PPPOE_TAG_HEADER_LENGTH + tagLength ) ); 

    //
    // Adjust payload buffer length
    //
    NdisAdjustBufferLength( pPacket->pNdisBuffer, 
                            (UINT) PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH );

    TRACE( TL_V, TM_Pk, ("-PacketInsertTag") );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS 
PacketInitializePADIToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN USHORT        tagServiceNameLength,
    IN CHAR*         tagServiceNameValue,
    IN USHORT        tagHostUniqueLength,
    IN CHAR*         tagHostUniqueValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADI packet to send.

    MANDATORY TAGS:
    ===============
    tagServiceName:
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique:
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL
    
Parameters:

    ppPacket _ A pointer to a PPPoE packet context pointer.

    tagServiceNameLength _ Length of tagServiceNameValue blob.

    tagServiceNameValue _ A blob that holds a UTF-8 service name string.

    tagHostUniqueLength _ Length of tagHostUniqueValue blob.

    tagHostUniqueValue _ A blob that contains a unique value to identify a packet. 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADIToSend") );

    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  tagServiceNameLength + 
                PPPOE_TAG_HEADER_LENGTH +
         
                tagHostUniqueLength + 
                ( (tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) ;

    if ( usLength > PACKET_PADI_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADIToSend: Can not init PADI to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADIToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();

    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADIToSend: Can not init PADI to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADIToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }
        
    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetDestAddr( pPacket, EthernetBroadcastAddress );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADI );

    PacketSetSessionId( pPacket, PACKET_NULL_SESSION );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = tagServiceNameLength;
    pPacket->tagServiceNameValue  = tagServiceNameValue;

    pPacket->tagHostUniqueLength = tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = tagHostUniqueValue;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADIToSend: PreparePacketForWire() failed:%x",status) );

        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;

    TRACE( TL_N, TM_Pk, ("-PacketInitializePADIToSend=$%x",status) );
    
    return status;
}

NDIS_STATUS 
PacketInitializePADOToSend(
    IN  PPPOE_PACKET*   pPADI,
    OUT PPPOE_PACKET**  ppPacket,
    IN CHAR*            pSrcAddr,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagACNameLength,
    IN CHAR*            tagACNameValue,
    IN BOOLEAN          fInsertACCookieTag
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADO packet to send as a reply to a received
    PADI packet.

    Note that a PADI packet does not contain the source address information as PADI
    is a broadcast packet. 

    MANDATORY TAGS:
    ===============
    tagServiceName: ()
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    tagACName: 
        tagACNameNameLength MUST be non-zero
        tagACNameNameValue  MUST be non-NULL

    tagACCookie: (This is optional for RFC)
        tagACCookieLength can be zero
        tagACCookieValue can be NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique: (Obtained from PADI packet)
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagRelaySessionId: (Obtained from PADI packet)
        tagRelaySessionIdLength can be zero
        tagRelaySessionIdValue can be zero      
    
Parameters:

    pPADI _ Pointer to a PPPoE packet context holding a PADI packet.
    
    ppPacket _ A pointer to a PPPoE packet context pointer.

    pSrcAddr _ Source address for the PADO packet since we can not
               get it from the PADI packet.

    tagServiceNameLength _ Length of tagServiceNameValue blob.

    tagServiceNameValue _ A blob that holds a UTF-8 Service name string.

    tagACNameLength _ Length of tagACNameValue blob.

    tagACNameValue _ A blob that holds a UTF-8 AC name string.

    fInsertACCookieTag _ Indicates we we should also insert an AC Cookie
                         tag into the PADO packet.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    NDIS_STATUS status;
    CHAR tagACCookieValue[PPPOE_AC_COOKIE_TAG_LENGTH];
    BOOLEAN fCopyServiceNameTag = FALSE;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADOToSend") );

    ASSERT( pPADI != NULL );
    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  tagServiceNameLength +
                PPPOE_TAG_HEADER_LENGTH +

                pPADI->tagHostUniqueLength + 
                ( (pPADI->tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                pPADI->tagRelaySessionIdLength + 
                ( (pPADI->tagRelaySessionIdLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                tagACNameLength + 
                PPPOE_TAG_HEADER_LENGTH +

                ( fInsertACCookieTag ? ( PPPOE_AC_COOKIE_TAG_LENGTH + PPPOE_TAG_HEADER_LENGTH ) : 0 );

    if ( usLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADOToSend: Can not init PADO to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADOToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADOToSend: Can not init PADO to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADOToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }
        
    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetDestAddr( pPacket, PacketGetSrcAddr( pPADI ) );

    PacketSetSrcAddr( pPacket, pSrcAddr );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADO );

    PacketSetSessionId( pPacket, PACKET_NULL_SESSION );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = tagServiceNameLength;
    pPacket->tagServiceNameValue  = tagServiceNameValue;

    pPacket->tagHostUniqueLength = pPADI->tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = pPADI->tagHostUniqueValue;

    pPacket->tagRelaySessionIdLength = pPADI->tagRelaySessionIdLength;
    pPacket->tagRelaySessionIdValue  = pPADI->tagRelaySessionIdValue;

    pPacket->tagACNameLength = tagACNameLength;
    pPacket->tagACNameValue  = tagACNameValue;

    if ( fInsertACCookieTag )
    {
        PacketGenerateACCookieTag( pPADI, tagACCookieValue );
        
        pPacket->tagACCookieLength = PPPOE_AC_COOKIE_TAG_LENGTH;
        pPacket->tagACCookieValue  = tagACCookieValue;
    }
    
    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADOToSend: PreparePacketForWire() failed:%x",status) );

        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;

    TRACE( TL_N, TM_Pk, ("-PacketInitializePADOToSend=$%x",status) );
    
    return status;
}

NDIS_STATUS 
PacketInitializePADRToSend(
    IN PPPOE_PACKET*    pPADO,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagHostUniqueLength,
    IN CHAR*            tagHostUniqueValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADR packet to send as a reply to a received
    PADO packet.

    MANDATORY TAGS:
    ===============
    tagServiceName: 
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique: 
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagACCookie: (Obtained from PADI packet)
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagRelaySessionId: (Obtained from PADI packet)
        tagRelaySessionIdLength can be zero
        tagRelaySessionIdValue can be NULL      
    
Parameters:

    pPADO _ Pointer to a PPPoE packet context holding a PADO packet.
    
    ppPacket _ A pointer to a PPPoE packet context pointer.

    tagServiceNameLength _ Length of tagServiceNameValue blob.

    tagServiceNameValue _ A blob that holds a UTF-8 service name string.

    tagHostUniqueLength _ Length of tagHostUniqueValue blob.

    tagHostUniqueValue _ A blob that contains a unique value to identify a packet. 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADRToSend") );

    ASSERT( pPADO != NULL );
    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  tagServiceNameLength + 
                PPPOE_TAG_HEADER_LENGTH +

                tagHostUniqueLength + 
                ( (tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                pPADO->tagRelaySessionIdLength + 
                ( (pPADO->tagRelaySessionIdLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) +

                pPADO->tagACCookieLength + 
                ( (pPADO->tagACCookieLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ) ;


    if ( usLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADRToSend: Can not init PADR to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADRToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADRToSend: Can not init PADR to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADRToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetSrcAddr( pPacket, PacketGetDestAddr( pPADO ) );
    
    PacketSetDestAddr( pPacket, PacketGetSrcAddr( pPADO ) );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADR );

    PacketSetSessionId( pPacket, PACKET_NULL_SESSION );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = tagServiceNameLength;
    pPacket->tagServiceNameValue  = tagServiceNameValue;

    pPacket->tagHostUniqueLength = tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = tagHostUniqueValue;

    pPacket->tagRelaySessionIdLength = pPADO->tagRelaySessionIdLength;
    pPacket->tagRelaySessionIdValue  = pPADO->tagRelaySessionIdValue;

    pPacket->tagACCookieLength = pPADO->tagACCookieLength;
    pPacket->tagACCookieValue  = pPADO->tagACCookieValue;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADRToSend: PreparePacketForWire() failed:%x",status) );
        
        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;
    
    TRACE( TL_N, TM_Pk, ("-PacketInitializePADRToSend=$%x",status) );

    return status;
}

//
// This function is used to prepare a PADS packet for a received PADR packet.
// 
// The PADR packet must be processed using PREPARE_PACKET_FROM_WIRE() macro
// before feeding into this function.
//
// The PADS packet should just be a packet without and associated VCs or linked lists.
//
// If you want to insert other tags to a PADI, PADO, or PADS packet, use specific 
// PacketInsertTag() function after calling this function.
//
// MANDATORY TAGS:
// ===============
//  tagServiceName:
//      tagServiceNameLength MUST be non-zero
//      tagServiceNameValue  MUST be non-NULL
//
// OPTIONAL TAGS:
// ==============
//  tagHostUnique: 
//      tagHostUniqueLength can be zero
//      tagHostUniqueValue can be zero
//
//  tagRelaySessionId: (Obtained from PADI packet)
//      tagRelaySessionIdLength can be zero
//      tagRelaySessionIdValue can be zero
//
NDIS_STATUS 
PacketInitializePADSToSend(
    IN PPPOE_PACKET*    pPADR,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           usSessionId
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADR packet to send as a reply to a received
    PADO packet.

    MANDATORY TAGS:
    ===============
    tagServiceName: (Obtained from PADR packet)
        tagServiceNameLength MUST be non-zero
        tagServiceNameValue  MUST be non-NULL

    OPTIONAL TAGS:
    ==============
    tagHostUnique: (Obtained from PADR packet)
        tagHostUniqueLength can be zero
        tagHostUniqueValue can be NULL

    tagRelaySessionId: (Obtained from PADR packet)
        tagRelaySessionIdLength can be zero
        tagRelaySessionIdValue can be NULL      
    
Parameters:

    pPADR _ Pointer to a PPPoE packet context holding a PADR packet.
    
    ppPacket _ A pointer to a PPPoE packet context pointer.

    usSessionId _ Session id assigned to this session
    
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;

    USHORT usLength;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADSToSend") );

    ASSERT( pPADR != NULL );
    ASSERT( ppPacket != NULL );

    //
    // Check if we are safe with length restrictions
    //
    usLength =  pPADR->tagServiceNameLength + 
                PPPOE_TAG_HEADER_LENGTH +

                pPADR->tagHostUniqueLength + 
                ( (pPADR->tagHostUniqueLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH )+

                pPADR->tagRelaySessionIdLength + 
                ( (pPADR->tagRelaySessionIdLength == 0) ? 0 : PPPOE_TAG_HEADER_LENGTH ); 

    if ( usLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADSToSend: Can not init PADS to send, exceeding max length") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADSToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADSToSend: Can not init PADS to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADSToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetSrcAddr( pPacket, PacketGetDestAddr( pPADR ) );

    PacketSetDestAddr( pPacket, PacketGetSrcAddr( pPADR ) );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADS );

    PacketSetSessionId( pPacket, usSessionId );

    PacketSetLength( pPacket, 0 );

    pPacket->tagServiceNameLength = pPADR->tagServiceNameLength;
    pPacket->tagServiceNameValue  = pPADR->tagServiceNameValue;

    pPacket->tagHostUniqueLength = pPADR->tagHostUniqueLength;
    pPacket->tagHostUniqueValue  = pPADR->tagHostUniqueValue;

    pPacket->tagRelaySessionIdLength = pPADR->tagRelaySessionIdLength;
    pPacket->tagRelaySessionIdValue  = pPADR->tagRelaySessionIdValue;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADSToSend: PreparePacketForWire() failed:%x",status) );
        
        PacketFree( pPacket );
        
        pPacket = NULL;
    }

    *ppPacket = pPacket;
    
    TRACE( TL_N, TM_Pk, ("-PacketInitializePADSToSend=$%x",status) );

    return status;
}

NDIS_STATUS 
PacketInitializePADTToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr, 
    IN CHAR* pDestAddr,
    IN USHORT usSessionId
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PADT packet to send to disconnect a session.

    If you want to send additional tags (like error tags), use the PacketInsertTag() 
    function.   

    MANDATORY TAGS:
    ===============
        None
        
    OPTIONAL TAGS:
    ==============
        None
    
Parameters:

    ppPacket _ A pointer to a PPPoE packet context pointer.

    pSrcAddr _ Buffer pointing to the source MAC addr of length 6

    pDestAddr _ Buffer pointing to the dest MAC addr of length 6
    
    usSessionId _ Session id assigned to this session
    
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Pk, ("+PacketInitializePADTToSend") );

    ASSERT( ppPacket != NULL );
    ASSERT( pDestAddr != NULL );

    pPacket = PacketCreateSimple();
    
    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADTToSend: Can not init PADT to send, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketInitializePADTToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetSrcAddr( pPacket, pSrcAddr );

    PacketSetDestAddr( pPacket, pDestAddr );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_DISCOVERY );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PADT );

    PacketSetSessionId( pPacket, usSessionId );

    PacketSetLength( pPacket, 0 );


    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePADTToSend: PreparePacketForWire() failed:%x",status) );

        PacketFree( pPacket );

        pPacket = NULL;
    }

    *ppPacket = pPacket;

    TRACE( TL_N, TM_Pk, ("-PacketInitializePADTToSend=$%x",status) );
    
    return status;
}

NDIS_STATUS 
PacketInitializePAYLOADToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr,
    IN CHAR* pDestAddr,
    IN USHORT usSessionId,
    IN NDIS_WAN_PACKET* pWanPacket,
    IN PADAPTER MiniportAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to create a PAYLOAD packet to send.

    If you want to send additional tags (like error tags), use the PacketInsertTag() 
    function.   

    MANDATORY TAGS:
    ===============
        None
        
    OPTIONAL TAGS:
    ==============
        None
    
Parameters:

    ppPacket _ A pointer to a PPPoE packet context pointer.

    pSrcAddr _ Buffer pointing to the source MAC addr of length 6

    pDestAddr _ Buffer pointing to the dest MAC addr of length 6
    
    usSessionId _ Session id assigned to this session

    pWanPacket _ Pointer to an NDISWAN packet

    MiniportAdapter _ This is the pointer to the miniport adapter.
                      It is used to indicate the completion of async sends back
                      to Ndiswan.
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_PACKET
    NDIS_STATUS_RESOURCES
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    PPPOE_PACKET* pPacket = NULL;
    USHORT usLength = 0;
    UINT Length;

    TRACE( TL_V, TM_Pk, ("+PacketInitializePAYLOADToSend") );

    ASSERT( ppPacket != NULL );
    ASSERT( pDestAddr != NULL );
    ASSERT( pWanPacket != NULL );

    //
    // Validate NDISWAN packet
    //
    if ( pWanPacket->CurrentLength > PACKET_GEN_MAX_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: Can not init PAYLOAD to send, exceeding max length") );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    if ( ( pWanPacket->CurrentBuffer - pWanPacket->StartBuffer ) < PPPOE_PACKET_HEADER_LENGTH )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: Can not init PAYLOAD to send, not enough front padding") );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",NDIS_STATUS_INVALID_PACKET) );

        return NDIS_STATUS_INVALID_PACKET;
    }

    //
    // Allocate a packet
    //
    pPacket = PacketAlloc();

    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: Can not init PAYLOAD to send, resources unavailable") );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",NDIS_STATUS_RESOURCES) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // Allocate NdisBuffer
    //
    //
    // NOTE : Using (pWanPacket->CurrentBuffer - PPPOE_PACKET_HEADER_LENGTH) instead of
    //        pWanPacket->StartBuffer directly gives us the flexibility of handling packets
    //        with different header padding values.
    //
    NdisAllocateBuffer( &status,
                        &pPacket->pNdisBuffer,
                        gl_hNdisBufferPool,
                        pWanPacket->CurrentBuffer - PPPOE_PACKET_HEADER_LENGTH,
                        (UINT) ( PPPOE_PACKET_HEADER_LENGTH + pWanPacket->CurrentLength ) );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: NdisAllocateBuffer() failed") );

        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

        return status;
    }

    pPacket->ulFlags |= PCBF_BufferAllocatedFromNdisBufferPool;

    //
    // Query new buffer descriptor to get hold of the real memory pointer
    //
    pPacket->pHeader = NULL;
    
    NdisQueryBufferSafe( pPacket->pNdisBuffer,
                         &pPacket->pHeader,
                         &Length,
                         NormalPagePriority );

    if ( pPacket->pHeader == NULL )
    {
        
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: NdisQueryBufferSafe() failed") );

        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

        return NDIS_STATUS_RESOURCES;
    }

    //
    // Allocate an NDIS packet from our pool
    //
    pPacket->pNdisPacket = GetPacketFromPool( &gl_poolPackets, &pPacket->pPacketHead );

    if ( pPacket->pNdisPacket == NULL ) 
    {
        
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: GetPacketFromPool() failed") );
        
        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

        return NDIS_STATUS_RESOURCES;
    }

    pPacket->ulFlags |= PCBF_PacketAllocatedFromOurPacketPool;

    //
    // Chain buffer to packet
    //
    NdisChainBufferAtFront( pPacket->pNdisPacket, pPacket->pNdisBuffer );

    pPacket->ulFlags |= PCBF_BufferChainedToPacket;

    //
    // Set the payload and payload length
    //
    pPacket->pPayload = pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH; 

    usLength = (USHORT) pWanPacket->CurrentLength;

    //
    // General initialization that applies to all packet codes
    //
    InitializeListHead( &pPacket->linkPackets );

    PacketSetDestAddr( pPacket, pDestAddr );

    PacketSetSrcAddr( pPacket, pSrcAddr );
    
    PacketSetEtherType( pPacket, PACKET_ETHERTYPE_PAYLOAD );

    PacketSetVersion( pPacket, PACKET_VERSION );

    PacketSetType( pPacket, PACKET_TYPE );

    PacketSetCode( pPacket, PACKET_CODE_PAYLOAD );

    PacketSetSessionId( pPacket, usSessionId );

    PacketSetLength( pPacket, usLength );

    //
    // Set the input NDIS_PACKET to the reserved area so that we can reach it
    // when we have to return this packet back to the upper layer.
    //
    *((PPPOE_PACKET UNALIGNED**)(&pPacket->pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)])) = pPacket;
    *((NDIS_WAN_PACKET UNALIGNED**)(&pPacket->pNdisPacket->ProtocolReserved[1 * sizeof(PVOID)])) = pWanPacket;
    *((ADAPTER UNALIGNED **)(&pPacket->pNdisPacket->ProtocolReserved[2 * sizeof(PVOID)])) = MiniportAdapter;

    status = PreparePacketForWire( pPacket );
    
    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializePAYLOADToSend: PreparePacketForWire() failed") );

        PacketFree( pPacket );

        TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );
        
        return status;
    }

    //
    // This must be done here as we do not want to call NdisMWanSendComplete() in PacketFree() if the 
    // PreparePacketForWire() fails.
    //
    pPacket->ulFlags |= PCBF_CallNdisMWanSendComplete;

    MpPacketOwnedByNdiswanReceived( MiniportAdapter );

    *ppPacket = pPacket;
    
    TRACE( TL_V, TM_Pk, ("-PacketInitializePAYLOADToSend=$%x",status) );

    return status;
}

NDIS_STATUS 
PacketInitializeFromReceived(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function prepares a PPPoE packet by using the Ndis packet from wire.

    This function will make sure that the packet is a PPPoE packet, and convert
    it to a PPPoE packet context. It tries to do this as efficiently as possible
    by trying to use the buffers of the received packet if possible.

    It will also do all the validation in the packet to make sure it is 
    compliant with the RFC. However, it can not perform the checks that need data 
    from a sent packet. Caller must use various PacketRetrieve*() functions to 
    retrieve the necesarry data and use it to match and validate to a sent packet.
    
Parameters:

    pPacket _ Pointer to a PPPoE packet context. 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_INVALID_PACKET
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status;

    ASSERT( pPacket != NULL );

    TRACE( TL_V, TM_Pk, ("+PacketInitializeFromReceived") );
    
    if ( !PacketIsPPPoE( pPacket ) )
    {
        status = NDIS_STATUS_INVALID_PACKET;
        
        TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );
        
        return status;
    }

    do 
    {
        status = NDIS_STATUS_INVALID_PACKET;
        
        //
        // Validate the tag lenghts inside the packet so that we do not 
        // step outside buffer boundaries further processing the packet.
        // Do this only if the packet is not a payload packet!
        //
        if ( PacketGetCode( pPacket ) != PACKET_CODE_PAYLOAD )
        {
            CHAR* pBufStart;
            CHAR* pBufEnd;
            USHORT tagLength;
    
            pBufStart = pPacket->pPayload;
            pBufEnd = pPacket->pPayload + PacketGetLength( pPacket );
        
            while ( pBufStart + PPPOE_TAG_HEADER_LENGTH <= pBufEnd )
            {
                //
                // Skip the tag type field
                //
                ((USHORT*) pBufStart)++;
        
                //
                // Retrieve the tag length, and look at the next tag
                //
                tagLength = ntohs( *((USHORT UNALIGNED *) pBufStart) ) ;
                ((USHORT*) pBufStart)++;
                
                pBufStart += tagLength;
        
            } 
    
            if ( pBufStart != pBufEnd )
                break;          
        }

        status = NDIS_STATUS_SUCCESS;
        
    } while ( FALSE );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Corrupt packet - invalid tags") );
        
        TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );
        
        return status;
    }
    
    switch ( PacketGetCode( pPacket ) )
    {
        USHORT tagLength;
        CHAR*  tagValue;    
    
        status = NDIS_STATUS_INVALID_PACKET;

        case PACKET_CODE_PADI:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADI") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) != PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }

            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }

            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            //
            // Extract the relay session id tag if it exists
            //
            RetrieveTag(    pPacket,
                            tagRelaySessionId,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADI succesfully") );

            status = NDIS_STATUS_SUCCESS;

            break;
                                
        case PACKET_CODE_PADO:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADO") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) != PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }

            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }
            
            RetrieveTag(    pPacket,
                            tagACName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: AC-Name tag not found") );
                
                break;
            }
            
            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            RetrieveTag(    pPacket,
                            tagACCookie,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );
                                
            //
            // Extract the relay session id tag if it exists
            //
            RetrieveTag(    pPacket,
                            tagRelaySessionId,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADO succesfully") );
            
            status = NDIS_STATUS_SUCCESS;
            
            break;

        case PACKET_CODE_PADR:
        
            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADR") );
            
            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }
            
            //
            // Make sure session id is PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) != PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }
            
            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }
        
            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            RetrieveTag(    pPacket,
                            tagACCookie,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            //
            // Extract the relay session id tag if it exists
            //
            RetrieveTag(    pPacket,
                            tagRelaySessionId,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADR succesfully") );

            status = NDIS_STATUS_SUCCESS;
            
            break;

        case PACKET_CODE_PADS:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADS") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }
            
            //
            // Make sure session id is NOT PACKET_NULL_SESSION.
            // However, if session id is PACKET_NULL_SESSION, then make sure we have
            // a an Error tag received as per RFC 2156.
            //
            if ( PacketGetSessionId( pPacket ) == PACKET_NULL_SESSION )
            {
                RetrieveErrorTags( pPacket );

                if ( !PacketAnyErrorTagsReceived( pPacket ) )
                {
                    TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                    
                    break;
                }
            }

            //
            // Extract mandatory tags first
            //
            RetrieveTag(    pPacket,
                            tagServiceName,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            if ( tagValue == NULL )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Service name tag not found") );
                
                break;
            }

            //
            // Extract optional tags
            //
            RetrieveTag(    pPacket,
                            tagHostUnique,
                            &tagLength,
                            &tagValue,
                            0,
                            NULL,
                            TRUE );

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADS succesfully") );

            status = NDIS_STATUS_SUCCESS;

            break;

        case PACKET_CODE_PADT:

            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processing PADT") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_DISCOVERY )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is not PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) == PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }
                
            TRACE( TL_N, TM_Pk, ("PacketInitializeFromReceived: Processed PADT succesfully") );

            status = NDIS_STATUS_SUCCESS;
            
            break;

        case PACKET_CODE_PAYLOAD:

            TRACE( TL_V, TM_Pk, ("PacketInitializeFromReceived: Processing PAYLOAD") );

            //
            // Make sure we have received the correct ethertype
            //
            if ( PacketGetEtherType( pPacket ) != PACKET_ETHERTYPE_PAYLOAD )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid ether type") );

                break;
            }

            //
            // Make sure session id is not PACKET_NULL_SESSION
            //
            if ( PacketGetSessionId( pPacket ) == PACKET_NULL_SESSION )
            {
                TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Invalid session id") );
                
                break;
            }

            TRACE( TL_V, TM_Pk, ("PacketInitializeFromReceived: Processed PAYLOAD succesfully") );

            status = NDIS_STATUS_SUCCESS;

            break;
            
        default:
            //
            // Unknown packet code
            //
            TRACE( TL_A, TM_Pk, ("PacketInitializeFromReceived: Ignoring unknown packet") );
            
            break;
        
    }

    if ( status != NDIS_STATUS_SUCCESS )
    {

        TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );

        return status;
    }

    //
    // The packet was processed succesfuly, now check if we received any error tags
    //
    RetrieveErrorTags( pPacket );

    TRACE( TL_V, TM_Pk, ("-PacketInitializeFromReceived=$%x",status) );

    return status;

}

BOOLEAN 
PacketAnyErrorTagsReceived(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitialize*FromReceived() 
    function, one should call this function to understand if an error tag was 
    noticed in the packet.

    If this function yields TRUE, then the caller should call PacketRetrieveErrorTag() 
    get the error type and value.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context.
    
Return Values:

    TRUE
    FALSE
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );

    return( pPacket->ulFlags & PCBF_ErrorTagReceived ) ? TRUE : FALSE;
}   



VOID 
PacketRetrievePayload(
    IN  PPPOE_PACKET*   pPacket,
    OUT CHAR**          ppPayload,
    OUT USHORT*         pusLength
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the payload portion of the 
    packet if the packet is a PAYLOAD packet.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a PAYLOAD packet.
    
Return Values:

    None
    
---------------------------------------------------------------------------*/   
{

    ASSERT( pPacket != NULL );
    ASSERT( pusLength != NULL );
    ASSERT( ppPayload != NULL );

    *pusLength = PacketGetLength( pPacket );
    *ppPayload = pPacket->pPayload;

}

VOID 
PacketRetrieveServiceNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue,
    IN USHORT        prevTagLength,
    IN CHAR*         prevTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the service name tag from 
    the packet.

    If prevTagValue and prevTagLength are given, then next service name tag will
    be returned, otherwise the first service name tag will be returned.

    If no such service name tags are found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that a service name tag of length 0 is valid, and one should
             check the value of pTagValue to understand if service name tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the service name tag found.

    pTagValue _ On return, points to the buffer holding the service name.
                Will be NULL, if no service name tags could be found.

    prevTagLength _ Length of the previously returned service name tag.

    prevTagValue _ Points to the buffer holding the previous service name tag.
    
Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    if ( prevTagLength == 0 &&
         prevTagValue == NULL )
    {
        //
        // Caller asks for the first Service Name Tag, and it should be ready in
        // the reserved field of the PPPOE_PACKET
        //
        *pTagLength = pPacket->tagServiceNameLength;
        *pTagValue  = pPacket->tagServiceNameValue;
    }
    else
    {
        //
        // Caller asks for the next Service Name Tag, so try to find and return it
        //
        RetrieveTag(    pPacket,
                        tagServiceName,
                        pTagLength,
                        pTagValue,
                        prevTagLength,
                        prevTagValue,
                        FALSE );

    }
}

VOID 
PacketRetrieveHostUniqueTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the host unique tag from 
    the packet.

    If no host unique tag is found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that a host unique tag of length 0 is valid, and one should
             check the value of pTagValue to understand if host unique tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the host unique tag found.

    pTagValue _ On return, points to the buffer holding the host unique value.
                Will be NULL, if no host unique tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the HostUnique, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    *pTagLength = pPacket->tagHostUniqueLength;
    *pTagValue  = pPacket->tagHostUniqueValue;
}

VOID 
PacketRetrieveACNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the AC name tag from 
    the packet.

    If no AC name tag is found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that an AC name tag of length 0 is valid, and one should
             check the value of pTagValue to understand if AC name tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the AC name tag found.

    pTagValue _ On return, points to the buffer holding the AC name.
                Will be NULL, if no AC name tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the AC Name, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    *pTagLength = pPacket->tagACNameLength;
    *pTagValue  = pPacket->tagACNameValue;
}


VOID 
PacketRetrieveACCookieTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the AC cookie tag from 
    the packet.

    If no AC cookie tag is found, then 0 and NULL will be returned for
    length and value parameters.

    CAUTION: Note that an AC cookie tag of length 0 is valid, and one should
             check the value of pTagValue to understand if AC cookie tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagLength _ On return, holds the length of the AC cookie tag found.

    pTagValue _ On return, points to the buffer holding the AC cookie.
                Will be NULL, if no AC cookie tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
    
{
    ASSERT( pPacket != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the AC Cookie, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    *pTagLength = pPacket->tagACCookieLength;
    *pTagValue  = pPacket->tagACCookieValue;
}

VOID 
PacketRetrieveErrorTag(
    IN PPPOE_PACKET* pPacket,
    OUT PACKET_TAGS* pTagType,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    After a received packet is first processed by a PacketInitializeFromReceived() 
    function, one should call this function to retrieve the error information from 
    the packet.

    If no errors were found, then 0 and NULL will be returned for length and value 
    parameters.

    CAUTION: Note that an error tag of length 0 is valid, and one should
             check the value of pTagValue to understand if an error tag was
             found in the packet or not.
    
Parameters:

    pPacket _ A pointer to a PPPoE packet context holding a control packet.

    pTagType _ On return, holds the type of the error tag found.
    
    pTagLength _ On return, holds the length of the error tag found.

    pTagValue _ On return, points to the buffer holding the error.
                Will be NULL, if no error tags could be found.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
    
{

    ASSERT( pPacket != NULL );
    ASSERT( pTagType != NULL );
    ASSERT( pTagLength != NULL );
    ASSERT( pTagValue != NULL );

    //
    // Caller asks for the received error, and it should be ready in
    // the reserved field of the PPPOE_PACKET
    //
    if ( pPacket->ulFlags & PCBF_ErrorTagReceived )
    {
        *pTagType   = pPacket->tagErrorType;
        *pTagLength = pPacket->tagErrorTagLength;
        *pTagValue  = pPacket->tagErrorTagValue;
    }
    else
    {
        *pTagLength = 0;
        *pTagValue  = NULL;
    }
    
}

PPPOE_PACKET* 
PacketMakeClone(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to make a clone of a packet for sending it
    over multiple bindings.

    CAUTION: This function only clones the NDIS_PACKET portion of PPPOE_PACKET 
             and leaves other fields untouched, so the clone packets should only 
             be used with NdisSend(), and disposed there after.
        
Parameters:

    pPacket _ A pointer to a PPPoE packet context that will be cloned.

Return Values:

    Pointer to the clone packet if succesfull, NULL otherwise.
    
---------------------------------------------------------------------------*/   
{
    PPPOE_PACKET* pClone = NULL;

    TRACE( TL_N, TM_Pk, ("+PacketMakeClone") );

    //
    // Allocate the clone
    //
    pClone = PacketCreateSimple();

    if ( pClone == NULL )
    {
        TRACE( TL_A, TM_Pk, ("PacketMakeClone: Can not make clone, resources unavailable") );

        TRACE( TL_N, TM_Pk, ("-PacketMakeClone=$%x",pClone) );

        return pClone;
    }

    //
    // Copy the clone
    //
    NdisMoveMemory( pClone->pHeader, pPacket->pHeader, PPPOE_PACKET_HEADER_LENGTH );

    NdisMoveMemory( pClone->pPayload, pPacket->pPayload, PACKET_GEN_MAX_LENGTH );

    NdisAdjustBufferLength( pClone->pNdisBuffer, 
                            (UINT) ( PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH ) );

    TRACE( TL_N, TM_Pk, ("-PacketMakeClone=$%x",pClone) );

    return pClone;
}

PPPOE_PACKET* 
PacketGetRelatedPppoePacket(
    IN NDIS_PACKET* pNdisPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to get the owning PPPoE packet context from an
    Ndis packet.

Parameters:

    pNdisPacket _ A pointer to an Ndis packet that belongs to a PPPoE packet.

Return Values:

    A pointer to the owning PPPoE packet.
    
---------------------------------------------------------------------------*/   
{
    return (*(PPPOE_PACKET**)(&pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)]));
}

NDIS_WAN_PACKET* 
PacketGetRelatedNdiswanPacket(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to get related NDISWAN packet from a PPPoE 
    payload packet that was perpared and sent.

Parameters:

    pPacket _ A pointer to a PPPoE payload packet that was sent.

Return Values:

    A pointer to the related NDISWAN packet.
    
---------------------------------------------------------------------------*/   
{
    return (*(NDIS_WAN_PACKET**)(&pPacket->pNdisPacket->ProtocolReserved[1 * sizeof(PVOID)])) ;
}

PADAPTER
PacketGetMiniportAdapter(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be used to get miniport adapter set in 
    PacketInitializePAYLOADToSend() function.

Parameters:

    pPacket _ A pointer to a PPPoE payload packet that was sent.

Return Values:

    Miniport adapter 
    
---------------------------------------------------------------------------*/   
{
    return  (*(ADAPTER**)(&pPacket->pNdisPacket->ProtocolReserved[2 * sizeof(PVOID)]));
}

VOID
PacketGenerateACCookieTag(
    IN PPPOE_PACKET* pPacket,
    IN CHAR tagACCookieValue[ PPPOE_AC_COOKIE_TAG_LENGTH ]
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to generate the AC Cookie tag based on the PADI
    packets sources address.

Parameters:

    pPacket _ A pointer to a PADI packet that was received.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    NdisMoveMemory( tagACCookieValue, PacketGetSrcAddr( pPacket ), 6 );
}

BOOLEAN
PacketValidateACCookieTagInPADR(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to validate the AC Cookie tag in a received PADR 
    packet.

    It basically uses the source address from the PADR packet to generate the
    original AC Cookie tag and compares them. If they are equal TRUE is returned,
    otherwise FALSE is returned.

Parameters:

    pPacket _ A pointer to a PADR packet that was received.

Return Values:

    None
    
---------------------------------------------------------------------------*/
{
    BOOLEAN fRet = FALSE;
    CHAR tagACCookie[ PPPOE_AC_COOKIE_TAG_LENGTH ];
    CHAR* tagACCookieValue = NULL;
    USHORT tagACCookieLength = 0;

    PacketRetrieveACCookieTag( pPacket,
                               &tagACCookieLength,
                               &tagACCookieValue );

    PacketGenerateACCookieTag( pPacket, tagACCookie );

    if ( NdisEqualMemory( tagACCookie, tagACCookieValue, PPPOE_AC_COOKIE_TAG_LENGTH ) )
    {
        fRet = TRUE;
    }
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\packet.h ===
#ifndef _PACKET_H_
#define _PACKET_H_

#ifndef _PPPOE_VERSION
#define _PPPOE_VERSION 1
#endif

typedef struct _ADAPTER* PADAPTER;
typedef struct _BINDING* PBINDING;

//
// Network-to-Host and vice versa conversion macros
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

//
// Constants related to packet lengths
//
#define PPPOE_PACKET_BUFFER_SIZE    1514

#define ETHERNET_HEADER_LENGTH      14
#define PPPOE_PACKET_HEADER_LENGTH  20          // Per RFC2156
#define PPPOE_TAG_HEADER_LENGTH     4           // Per RFC2156
#define PPP_MAX_HEADER_LENGTH       14          // maximum possible header length for ppp

#define PPPOE_AC_COOKIE_TAG_LENGTH  6

//
// Offsets for the header members
//
#define PPPOE_PACKET_DEST_ADDR_OFFSET   0           // Per RFC2156
#define PPPOE_PACKET_SRC_ADDR_OFFSET    6           // Per RFC2156
#define PPPOE_PACKET_ETHER_TYPE_OFFSET  12          // Per RFC2156
#define PPPOE_PACKET_VERSION_OFFSET     14          // Per RFC2156
#define PPPOE_PACKET_TYPE_OFFSET        14          // Per RFC2156
#define PPPOE_PACKET_CODE_OFFSET        15          // Per RFC2156
#define PPPOE_PACKET_SESSION_ID_OFFSET  16          // Per RFC2156
#define PPPOE_PACKET_LENGTH_OFFSET      18          // Per RFC2156

//
// Macros to set information in the header of the packet
//
#define PacketSetDestAddr( pP, addr ) \
    NdisMoveMemory( ( pP->pHeader + PPPOE_PACKET_DEST_ADDR_OFFSET ), addr, 6 )

#define PacketSetSrcAddr( pP, addr ) \
    NdisMoveMemory( ( pP->pHeader + PPPOE_PACKET_SRC_ADDR_OFFSET ), addr, 6 )

#define PacketSetEtherType( pP, type ) \
    * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_ETHER_TYPE_OFFSET ) = htons( (USHORT) type )

#define PacketSetVersion( pP, ver ) \
    * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_VERSION_OFFSET ) |= ( ( ( (UCHAR) ver ) << 4 ) & PACKET_VERSION_MASK )

#define PacketSetType( pP, type ) \
    * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_TYPE_OFFSET ) |= ( ( (UCHAR) type ) & PACKET_TYPE_MASK )

#define PacketSetCode( pP, code ) \
    * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_CODE_OFFSET ) = ( (UCHAR) code )

#define PacketSetSessionId( pP, ses_id ) \
    * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_SESSION_ID_OFFSET ) = htons( (USHORT) ses_id )

#define PacketSetLength( pP, len) \
    * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_LENGTH_OFFSET ) = htons( (USHORT) len )

#define PacketSetSendCompletionStatus( pP, s ) \
   ( pP->SendCompletionStatus = s )

//
// Macros to get information from the header of the packet
//
#define PacketGetDestAddr( pP ) \
    ( pP->pHeader + PPPOE_PACKET_DEST_ADDR_OFFSET )

#define PacketGetSrcAddr( pP ) \
    ( pP->pHeader + PPPOE_PACKET_SRC_ADDR_OFFSET )

#define PacketGetEtherType( pP ) \
    ntohs( * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_ETHER_TYPE_OFFSET ) )

#define PacketGetVersion( pP ) \
    ( ( ( * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_VERSION_OFFSET ) ) & PACKET_VERSION_MASK ) >> 4 )

#define PacketGetType( pP ) \
    ( ( * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_TYPE_OFFSET ) ) & PACKET_TYPE_MASK ) 

#define PacketGetCode( pP ) \
    ( * ( UCHAR UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_CODE_OFFSET ) )

#define PacketGetSessionId( pP ) \
    ntohs( * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_SESSION_ID_OFFSET ) )

#define PacketGetLength( pP ) \
    ntohs( * ( USHORT UNALIGNED * ) ( pP->pHeader + PPPOE_PACKET_LENGTH_OFFSET ) )

#define PacketGetSendCompletionStatus( pP ) \
   ( pP->SendCompletionStatus )

//
// Macro that returns the Ndis Packet for a PPPoE packet
//
#define PacketGetNdisPacket( pP ) \
    ( pP->pNdisPacket )

//
// This structure is just a map, and it is not actually used in the code
//
typedef struct
_PPPOE_HEADER
{

    CHAR DestAddr[6];
    CHAR SrcAddr[6];
        #define PACKET_BROADCAST_ADDRESS    EthernetBroadcastAddress

    USHORT usEtherType;
        #define PACKET_ETHERTYPE_DISCOVERY  0x8863
        #define PACKET_ETHERTYPE_PAYLOAD    0x8864  

    union 
    {
        //
        // Version field is 4 bits and MUST be set to 0x1 for this version
        //
        CHAR usVersion;
            #define PACKET_VERSION_MASK             0xf0
            #define PACKET_VERSION          (USHORT)0x1
    
        //
        // Type field is 4 bits and MUST be set to 0x1 for this version
        //
        CHAR usType;
            #define PACKET_TYPE_MASK                0x0f
            #define PACKET_TYPE             (USHORT)0x1

    } uVerType;
    
    //
    // Code field is 8 bits and is defined as follows for Version 1
    // Values selected from enumerated type PACKET_CODES (see below)
    //
    CHAR usCode;
        
    //
    // Session Id field is 16 bits and define a unique session combined with
    // the source and destination addresses
    //
    USHORT usSessionId;
        #define PACKET_NULL_SESSION 0x0000
        
    //
    // Length field is 16 bits and indicates the length of the payload field only.
    // The length field excludes the PPPoE header block.
    //
    USHORT usLength;
        //
        // Subtract Header size from Max PADI and MAX payload lengths per RFC2156
        //
        #define PACKET_PADI_MAX_LENGTH          1478        // (1514 - 20 - 16)
        #define PACKET_GEN_MAX_LENGTH           1494        // (1514 - 20)
        #define PACKET_PPP_PAYLOAD_MAX_LENGTH   1480        // (1514 - 20)

}
PPPOE_HEADER;

//
// PACKET CODES defined by RFC2156
//
typedef enum
_PACKET_CODES
{
    PACKET_CODE_PADI = 0x09,
    PACKET_CODE_PADO = 0x07,
    PACKET_CODE_PADR = 0x19,
    PACKET_CODE_PADS = 0x65,
    PACKET_CODE_PADT = 0xa7,
    PACKET_CODE_PAYLOAD = 0x00
}
PACKET_CODES;

//
// TAGS defined by RFC2156
//
typedef enum
_PACKET_TAGS
{
    tagEndOfList        = 0x0000,
    tagServiceName      = 0x0101,
    tagACName           = 0x0102,
    tagHostUnique       = 0x0103,
    tagACCookie         = 0x0104,
    tagVendorSpecific   = 0x0105,

    tagRelaySessionId   = 0x0110,

    tagServiceNameError = 0x0201,
    tagACSystemError    = 0x0202,
    tagGenericError     = 0x0204
}
PACKET_TAGS;

//
// This is the packet context.
//
// CAUTION: Packets are not protected by their own locks, however they must be accessed carefully
//          by using their owner's locks.
//
typedef struct
_PPPOE_PACKET
{
    //
    // Points to the previous and next packet contexts when in a doubly linked list
    //
    LIST_ENTRY linkPackets;

    //
    // Keeps references on the packet
    // References added and removed for the following operations:
    //
    // (a) A reference is added when a packet is created and removed when it is freed.
    //
    // (b) A reference must be added before sending the packet and must be removed when
    //     send operation is completed.
    // 
    LONG lRef;

    //
    // Quick look-up for tags.
    //
    // The value pointers mark the beginning of the tag value in the pPacket->pPayload section.
    // The length values show the lengths of the values (not including the tag header)
    //
    USHORT tagServiceNameLength;
    CHAR*  tagServiceNameValue;

    USHORT tagACNameLength;
    CHAR*  tagACNameValue;

    USHORT tagHostUniqueLength;
    CHAR*  tagHostUniqueValue;

    USHORT tagACCookieLength;
    CHAR*  tagACCookieValue;

    USHORT tagRelaySessionIdLength;
    CHAR*  tagRelaySessionIdValue;

    PACKET_TAGS tagErrorType;
    USHORT tagErrorTagLength;
    CHAR*  tagErrorTagValue;

    //
    // Points to the buffer that holds the header portion of a PPPoE packet in wire format.
    // This points to the buffer portion of pNdisBuffer (see below)
    //
    CHAR* pHeader;

    //
    // Points to the payload portion of a PPPoE packet in wire format.
    // This is calculated and is set as : pPacket->pHeader + PPPOE_PACKET_HEADER_LENGTH
    // 
    CHAR* pPayload;

    //
    // Bit flags that identifies the nature of the buffer and packet
    //
    // (a) PCBF_BufferAllocatedFromNdisBufferPool: Indicates that pNdisBuffer points to a buffer allocated
    //                                             from gl_hNdisBufferpool, and it must be freed to that pool.
    //
    // (b) PCBF_BufferAllocatedFromOurBufferPool: Indicates that pNdisBuffer points to a buffer allocated
    //                                            from gl_poolBuffers, and it must be freed to that pool.
    // 
    // (c) PCBF_PacketAllocatedFromOurPacketPool: Indicates that pNdisPacket points to a packet allocated
    //                                            from gl_poolPackets, and it must be freed to that pool. 
    //
    // (d) PCBF_BufferChainedToPacket: Indicates that the buffer pointed to by pNdisBuffer is chained to
    //                                 the packet pointed to by pNdisPacket, and must be unchained before
    //                                 returning them back to their pools.
    //
    // (e) PCBF_CallNdisReturnPackets: Indicates that the packet was created using PacketCreateFromReceived()
    //                                 and we should call NdisReturnPackets() when we are done with it to
    //                                 return it back to NDIS.
    //
    //
    // (f) PCBF_ErrorTagReceived: This flag is valid only for received packets.
    //                            It indicates that when the packet was processed and a PPPoE packet was created
    //                            some error tags were noticed in the packet.
    //
    ULONG ulFlags;
        #define PCBF_BufferAllocatedFromNdisBufferPool          0x00000001
        #define PCBF_BufferAllocatedFromOurBufferPool           0x00000002
        #define PCBF_PacketAllocatedFromOurPacketPool           0x00000004
        #define PCBF_BufferChainedToPacket                      0x00000008
        #define PCBF_CallNdisReturnPackets                      0x00000010
        #define PCBF_CallNdisMWanSendComplete                   0x00000020
        #define PCBF_ErrorTagReceived                           0x00000040
        #define PCBF_PacketIndicatedIncomplete                  0x00000080

    //
    // Pointer to the NdisBuffer
    //
    NDIS_BUFFER* pNdisBuffer;

    //
    // Points directly to the NDIS_PACKET
    //
    NDIS_PACKET* pNdisPacket;
    //
    // pPacket->pNdisPacket->ProtocolReserved[0 * sizeof(PVOID)] = (PVOID) pPPPoEPacket;
    // pPacket->pNdisPacket->ProtocolReserved[1 * sizeof(PVOID)] = (PVOID) pNdiswanPacket;
    // pPacket->pNdisPacket->ProtocolReserved[2 * sizeof(PVOID)] = (PVOID) miniportAdapter;
    //

    //
    // Points to the PACKETHEAD struct in ppool.h. It contains the pointer to NDIS_PACKET
    //
    PACKETHEAD* pPacketHead;

    //
    // This is needed to dereference the binding when PCBF_CallNdisReturnPackets flag is set. 
    //
    PBINDING pBinding;

    //
    // Send completion status for the packet
    //
    NDIS_STATUS SendCompletionStatus;

}
PPPOE_PACKET;

VOID PacketPoolInit();

VOID PacketPoolUninit();

VOID PacketPoolAlloc();

VOID PacketPoolFree();

PPPOE_PACKET* PacketAlloc();

VOID PacketFree(
    IN PPPOE_PACKET* pPacket
    );
    
VOID ReferencePacket(
    IN PPPOE_PACKET* pPacket 
    );

VOID DereferencePacket(
    IN PPPOE_PACKET* pPacket 
    );

PPPOE_PACKET* 
PacketCreateSimple();

PPPOE_PACKET* 
PacketCreateForReceived(
    PBINDING pBinding,
    PNDIS_PACKET pNdisPacket,
    PNDIS_BUFFER pNdisBuffer,
    PUCHAR pContents
    );

PPPOE_PACKET*
PacketNdis2Pppoe(
    IN PBINDING pBinding,
    IN PNDIS_PACKET pNdisPacket,
    OUT PINT pRefCount
    );

BOOLEAN
PacketFastIsPPPoE(
    IN CHAR* HeaderBuffer,
    IN UINT HeaderBufferSize
    );
    
VOID 
RetrieveTag(
    IN OUT PPPOE_PACKET*    pPacket,
    IN PACKET_TAGS          tagType,
    OUT USHORT*             pTagLength,
    OUT CHAR**              pTagValue,
    IN USHORT               prevTagLength,
    IN CHAR*                prevTagValue,
    IN BOOLEAN              fSetTagInPacket
    );

NDIS_STATUS PacketInsertTag(
    IN  PPPOE_PACKET*   pPacket,
    IN  PACKET_TAGS     tagType,
    IN  USHORT          tagLength,
    IN  CHAR*           tagValue,
    OUT CHAR**          pNewTagValue    
    );

NDIS_STATUS PacketInitializePADIToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN USHORT        tagServiceNameLength,
    IN CHAR*         tagServiceNameValue,
    IN USHORT        tagHostUniqueLength,
    IN CHAR*         tagHostUniqueValue
    );

NDIS_STATUS 
PacketInitializePADOToSend(
    IN  PPPOE_PACKET*   pPADI,
    OUT PPPOE_PACKET**  ppPacket,
    IN CHAR*            pSrcAddr,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagACNameLength,
    IN CHAR*            tagACNameValue,
    IN BOOLEAN          fInsertACCookieTag
    );
    
NDIS_STATUS PacketInitializePADRToSend(
    IN PPPOE_PACKET*    pPADO,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           tagServiceNameLength,
    IN CHAR*            tagServiceNameValue,
    IN USHORT           tagHostUniqueLength,
    IN CHAR*            tagHostUniqueValue
    );

NDIS_STATUS PacketInitializePADSToSend(
    IN PPPOE_PACKET*    pPADR,
    OUT PPPOE_PACKET**  ppPacket,
    IN USHORT           usSessionId
    );

NDIS_STATUS PacketInitializePADTToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr, 
    IN CHAR* pDestAddr,
    IN USHORT usSessionId
    );
    
NDIS_STATUS PacketInitializePAYLOADToSend(
    OUT PPPOE_PACKET** ppPacket,
    IN CHAR* pSrcAddr,
    IN CHAR* pDestAddr,
    IN USHORT usSessionId,
    IN NDIS_WAN_PACKET* pWanPacket,
    IN PADAPTER MiniportAdapter
    );  

NDIS_STATUS PacketInitializeFromReceived(
    IN PPPOE_PACKET* pPacket
    );

BOOLEAN PacketAnyErrorTagsReceived(
    IN PPPOE_PACKET* pPacket
    );

VOID PacketRetrievePayload(
    IN  PPPOE_PACKET*   pPacket,
    OUT CHAR**          ppPayload,
    OUT USHORT*         pusLength
    );

VOID PacketRetrieveServiceNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue,
    IN USHORT        prevTagLength,
    IN CHAR*         prevTagValue
    );
    
VOID PacketRetrieveHostUniqueTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );  

VOID PacketRetrieveACNameTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );  

VOID PacketRetrieveACCookieTag(
    IN PPPOE_PACKET* pPacket,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );

VOID PacketRetrieveErrorTag(
    IN PPPOE_PACKET* pPacket,
    OUT PACKET_TAGS* pTagType,
    OUT USHORT*      pTagLength,
    OUT CHAR**       pTagValue
    );
    
PPPOE_PACKET* PacketGetRelatedPppoePacket(
    IN NDIS_PACKET* pNdisPacket
    );

NDIS_WAN_PACKET* PacketGetRelatedNdiswanPacket(
    IN PPPOE_PACKET* pPacket
    );

PADAPTER PacketGetMiniportAdapter(
    IN PPPOE_PACKET* pPacket
    );

PPPOE_PACKET* PacketMakeClone(
    IN PPPOE_PACKET* pPacket
    );

VOID
PacketGenerateACCookieTag(
    IN PPPOE_PACKET* pPacket,
    IN CHAR tagACCookieValue[ PPPOE_AC_COOKIE_TAG_LENGTH ]
    );

BOOLEAN
PacketValidateACCookieTagInPADR(
    IN PPPOE_PACKET* pPacket
    );  

//////////////////////////////////////////////////////////
//
// Error codes and messages
//
//////////////////////////////////////////////////////////

#define PPPOE_ERROR_BASE                                    0

#define PPPOE_NO_ERROR                                      PPPOE_ERROR_BASE

#define PPPOE_ERROR_SERVICE_NOT_SUPPORTED                   PPPOE_ERROR_BASE + 1
#define PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG               "Service not supported"
#define PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG_SIZE          ( sizeof( PPPOE_ERROR_SERVICE_NOT_SUPPORTED_MSG ) / sizeof( CHAR ) )

#define PPPOE_ERROR_INVALID_AC_COOKIE_TAG                   PPPOE_ERROR_BASE + 2
#define PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG               "AC-Cookie tag is invalid"
#define PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG_SIZE          ( sizeof( PPPOE_ERROR_INVALID_AC_COOKIE_TAG_MSG ) / sizeof( CHAR ) )            

#define PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED                   PPPOE_ERROR_BASE + 3
#define PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG               "Can not accept any more connections from this machine"
#define PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG_SIZE          ( sizeof( PPPOE_ERROR_CLIENT_QUOTA_EXCEEDED_MSG ) / sizeof( CHAR ) )            


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\ppool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.h
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _PPOOL_H_
#define _PPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//
typedef struct
_PACKETPOOL
{
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    ULONG ulProtocolReservedLength;

    // The optimal number of packets to allocate in each packet block.
    //
    ULONG ulPacketsPerBlock;

    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    ULONG ulMaxPackets;

    // Current number of individual packets allocated in the entire pool.
    //
    ULONG ulCurPackets;

    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of PACKETBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free PACKETHEADs.  Each PACKETHEAD in
    // the list is ready to go, i.e. it already has an NDIS_PACKET associated
    // with it.  Access to the list is prototected by 'lock' in this
    // structure.  Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    LIST_ENTRY listFreePackets;

    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    NDIS_SPIN_LOCK lock;
}
PACKETPOOL;


// Header of a single block of packets from a packet pool.  The PACKETHEAD of
// the first buffer immediately follows.
//
typedef struct
_PACKETBLOCKHEAD
{
    // Links to the prev/next packet block header in the packet pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the packet pool.
    //
    PACKETPOOL* pPool;

    // Number of individual packets in this block.
    //
    ULONG ulPackets;

    // Number of individual packets in this block on the free list.
    //
    ULONG ulFreePackets;
}
PACKETBLOCKHEAD;


// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//
typedef struct
_PACKETHEAD
{
    // Link to next packet header in the packet pool's free list.
    //
    LIST_ENTRY linkFreePackets;

    // Back link to owning packet block header.
    //
    PACKETBLOCKHEAD* pBlock;

    // NDIS packet descriptor of this buffer.
    //
    NDIS_PACKET* pNdisPacket;
}
PACKETHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag );

BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool );

NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead );
	
VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection );

PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead );

VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool );

__inline
PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead )

    // Returns the address of the pool, given 'pHead', the address of a
    // PACKETHEAD like the one returned from GetPacketFromPool.
    //
{
    return pHead->pBlock->pPool;
}


#endif // PPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\ppool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.c
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoublePacketFrees = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool );

VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag )

    // Initialize caller's packet pool control block 'pPool'.
    // 'UlProtocolReservedLength' is the size in bytes of the
    // 'ProtocolReserved' array of each individual packet.  'UlMaxPackets' is
    // the maximum number of packets allowed in the entire pool, or 0 for
    // unlimited.  'UlPacketsPerBlock' is the number of packets to include in
    // each block of packets.  'UlFreesPerCollection' is the number of
    // FreePacketToPool calls until the next garbage collect scan, or 0 for
    // default.  'UlTag' is the memory identification tag to use when
    // allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' packet must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulProtocolReservedLength = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock = ulPacketsPerBlock;
    pPool->ulMaxPackets = ulMaxPackets;
    pPool->ulFreesSinceCollection = 0;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulPacketsPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitPp tag=$%08x pr=%d cnt=%d",
        pPool->ulTag,
        pPool->ulProtocolReservedLength,
        pPool->ulPacketsPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreePackets );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool )

    // Free up all resources allocated in packet pool 'pPool'.  This is the
    // inverse of InitPacketPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreePp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        fSuccess = (pPool->ulCurPackets == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead
    )

    // Returns the address of the NDIS_PACKET descriptor allocated from the
    // pool 'pPool'.  The pool is expanded, if necessary, but caller should
    // still check for NULL return since the pool may have been at maximum
    // size.
    //
{
    LIST_ENTRY* pLink;
    PACKETHEAD* pHead;
    NDIS_PACKET* pPacket;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreePackets ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreePackets );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, PACKETHEAD, linkFreePackets );
            --pHead->pBlock->ulFreePackets;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!pLink)
    {
        // The free list was empty.  Try to expand the pool.
        //
        pHead = AddPacketBlockToPool( pPool );
        if (!pHead)
        {
            TRACE( TL_A, TM_Pool, ( "GetPfP failed?" ) );
            return NULL;
        }
    }

    TRACE( TL_N, TM_Pool,
        ( "GetPfP=$%p/h=$%p, %d free",
        pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );

	*ppHead = pHead;
	
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection 
    )

    // Returns 'pPacket' to the pool of unused packets 'pPool'.  'PPacket'
    // must have been previously allocated with GetPacketFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddPacketToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool,
            ( "FreePtoP($%p,h=$%p) %d free",
            pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreePackets.Flink != &pHead->linkFreePackets)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoublePacketFrees;
            break;
        }

        InsertHeadList( &pPool->listFreePackets, &pHead->linkFreePackets );
        ++pHead->pBlock->ulFreePackets;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedPacketPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


VOID
CollectPacketPoolGarbage(
    PACKETPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool )

    // Allocate a new packet block and add it to the packet pool 'pPool'.
    //
    // Returns the PACKETHEAD allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    PACKETBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    PACKETHEAD* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddPpBlock(%d+%d)",
        pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        do
        {
            if (pPool->ulMaxPackets
                && pPool->ulCurPackets >= pPool->ulMaxPackets)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Pp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of packets
            // it will hold.
            //
            ulCount = pPool->ulPacketsPerBlock;
            if (pPool->ulMaxPackets)
            {
                if (ulCount > pPool->ulMaxPackets - pPool->ulCurPackets)
                {
                    ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
                }
            }
            ulSize = sizeof(PACKETBLOCKHEAD) + (ulCount * sizeof(PACKETHEAD));

            // Allocate the contiguous memory block for the PACKETBLOCK header
            // and the individual PACKETHEADs.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc PB?") );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(PACKETBLOCKHEAD) );

            // Allocate a pool of NDIS_PACKET descriptors.
            //
            NdisAllocatePacketPool(
                &status,
                &pNew->hNdisPool,
                ulCount,
                pPool->ulProtocolReservedLength );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocPp=$%x?", status ) );
                break;
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the packets are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulPackets = ulCount;
            pPool->ulCurPackets += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreePacketPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    {
        ULONG i;
        PACKETHEAD* pHead;

        pReturn = NULL;

        // For each PACKETHEAD of the block...
        //
        for (i = 0, pHead = (PACKETHEAD* )(pNew + 1);
             i < ulCount;
             ++i, ++pHead)
        {
            InitializeListHead( &pHead->linkFreePackets );
            pHead->pBlock = pNew;
            pHead->pNdisPacket = NULL;

            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            NdisAllocatePacket( &status, &pHead->pNdisPacket, pNew->hNdisPool );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocP=$%x?", status ) );
                pHead->pNdisPacket = NULL;
                continue;
            }

            if (pReturn)
            {
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreePacketToPool( pPool, pHead, FALSE );
            }
            else
            {
                // The first successfully constructed packet is returned by
                // this routine.
                //
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // NOTE: The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedPpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        PACKETBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, PACKETBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreePackets >= pBlock->ulPackets)
        {
            ULONG i;
            PACKETHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            for (i = 0, pHead = (PACKETHEAD* )(pBlock + 1);
                 i < pBlock->ulPackets;
                 ++i, ++pHead)
            {
                RemoveEntryList( &pHead->linkFreePackets );
                InitializeListHead( &pHead->linkFreePackets );

                if (pHead->pNdisPacket)
                {
                    NdisFreePacket( pHead->pNdisPacket );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurPackets -= pBlock->ulPackets;

            if (pBlock->hNdisPool)
            {
                NdisFreePacketPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\protocol.h ===
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#define PR_NDIS_MajorVersion    4
#define PR_NDIS_MinorVersion    0

#define PR_CHARACTERISTIC_NAME  "RasPppoe"

typedef struct _CALL* PCALL;

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
   These macros will be called by PacketCreateForReceived() and DereferencePacket() 
   functions when a PPPOE_PACKET with references to a packet owned by NDIS is
   created and freed, respectively.
   
---------------------------------------------------------------------------*/   
#define PrPacketOwnedByNdisReceived( pB ) \
        NdisInterlockedIncrement( &(pB)->NumPacketsOwnedByNdis )

#define PrPacketOwnedByNdisReturned( pB ) \
        NdisInterlockedDecrement( &(pB)->NumPacketsOwnedByNdis )

//
// Constants 
//
#define BN_SetFiltersForMediaDetection 0x00000001
#define BN_SetFiltersForMakeCall       0x00000002
#define BN_ResetFiltersForCloseLine    0x00000003

//
// These are the states that a binding can be in.
// They are pretty self explanatory.
//
typedef enum
_BINDING_STATE
{
    BN_stateIdle = 0,           
    BN_stateBindPending,        
    BN_stateBound,
    BN_stateSleepPending,
    BN_stateSleeping,
    BN_stateUnbindPending,
    BN_stateUnbound
}
BINDING_STATE;

//
// These are the schedulable work items for the bindings:
//  
//  - BWT_workPrSend: This work item is scheduled by PrBroadcast() with a copy of a 
//                    packet given to broadcast. When it runs, it sends the clone packet.
//
//  - BWT_PrReceiveComplete: This work item is scheduled by PrReceivePacket() if a packet is received
//                           and there is no PrReceiveComplete() running to drain the receive queue.
//
typedef enum
_BINDING_WORKTYPE
{
    BWT_workUnknown = 0,
    BWT_workPrStartBinds,
    BWT_workPrSend,
    BWT_workPrReceiveComplete
}
BINDING_WORKTYPE;

//
// This is the binding context.
// All information pertinent to our bindings are kept here.
//
typedef struct
_BINDING
{
    //
    // Link to other bindings in the protocols binding list
    //
    LIST_ENTRY linkBindings;

    //
    // Tag that identifies the binding (used for debugging)
    //
    ULONG tagBinding;

    //
    // Keeps reference count on the binding. 
    // References are added and deleted for the following operations:
    //
    // (a) A reference is added in AddBindingToProtocol and removed in RemoveBindingFromProtocol
    //
    // (b) A reference is added when a call is added, and removed when call is removed.
    //
    // (c) A reference is added when a BWT_workPrSend item is scheduled and removed when
    //     work item is executed.
    //
    // (d) A reference must be added before sending a packet, and must be removed if NdisSend()
    //     completes synchronously. Otherwise it will be removed by PrSendComplete() function
    //     when Ndis calls it to notify the completion of the send.
    //
    LONG lRef;

    //
    // (a) BNBF_OpenAdapterCompleted: This flag will be set by PrOpenAdapterComplete().
    //
    // (b) BNBF_CurrentAddressQueryCompleted: This flag will be set by PrRequestComplete().
    //
    // (c) BNBF_LinkSpeedQueryCompleted: This flag will be set by PrRequestComplete().
    //
    // (d) BNBF_MaxFrameSizeQueryCompleted: This flag will be set by PrRequestComplete().
    //
    // (e) BNBF_BindAdapterCompleted: This flag will be set by PrBindAdapter().
    //
    // (f) BNBF_CloseAdapterCompleted: This flag will be set by PrCloseAdapterComplete().
    //
    // (g) BNBF_PacketFilterSet: This flag indicates that the packet filter for the binding is set.
    //                           It will be set and reset in ChangePacketFiltersForBindings().
    //
    // (h) BNBF_PacketFilterChangeInProgress: This flag indicates that the binding is referenced for
    //                                        packet filter change.
    //
    ULONG ulBindingFlags;
        #define BNBF_OpenAdapterCompleted            0x00000001
        #define BNBF_CurrentAddressQueryCompleted    0x00000002
        #define BNBF_LinkSpeedQueryCompleted         0x00000004
        #define BNBF_MaxFrameSizeQueryCompleted      0x00000008
        #define BNBF_BindAdapterCompleted            0x00000010
        #define BNBF_CloseAdapterCompleted           0x00000020
        #define BNBF_PacketFilterSet                 0x00000040
        #define BNBF_PacketFilterChangeInProgress    0x00000080
          
    //
    // Shows the status of the bind adapter operation.
    // Valid only if BNBF_BindAdapterCompleted is set.
    //
    NDIS_STATUS BindAdapterStatus;

    //
    // Shows the status of the open adapter operation.
    // Valid only if BNBF_OpenAdapterCompleted is set.
    //
    NDIS_STATUS OpenAdapterStatus;

    //
    // Shows the status of the latest request made to NDIS.
    //
    NDIS_STATUS RequestStatus;

    //
    // Ndis Request structure passed to the underlying NIC cards
    //
    NDIS_REQUEST Request;

    //
    // Event to be signaled when requests are completed.
    //
    NDIS_EVENT RequestCompleted;

    //
    // Keeps the MAC address of the NIC card represented by this binding.
    // This information is obtained from the underlying by passing it a set of OID queries
    //
    CHAR LocalAddress[6];

    //
    // Keeps the speed of the NIC cards represented by this binding.
    // This information is obtained from the underlying by passing it a set of OID queries
    //
    ULONG ulSpeed;

    //
    // Max frame size of the underlying NIC
    //
    ULONG ulMaxFrameSize;
    
    //
    // Keeps the filter information for this binding.
    //
    ULONG ulPacketFilter;
    
    //
    // This is the handle returned to us by NdisOpenAdapter().
    // It is the handle for accessing the underlying NIC card represented by this binding.
    //
    NDIS_HANDLE NdisBindingHandle;      

    //
    // This is the index of the supported medium by the underlying NIC card.
    //
    UINT uintSelectedMediumIndex;       

    //
    // This is the event that we wait on in PrUnbindAdapter().
    // It will be signaled from DereferenceBinding() when ref count of the binding reaches 0.
    //
    NDIS_EVENT  eventFreeBinding;       

    //
    // Spin lock to synchronize access to shared members
    //
    NDIS_SPIN_LOCK lockBinding;

    //
    // Indicates state information about the binding
    //
    BINDING_STATE stateBinding;

    //
    // Flag that indicates that the receive loop is running.
    // To make sure the serialization of PPP packets, we can not let more than 1 threads
    // making receive indications to NDISWAN
    //
    BOOLEAN fRecvLoopRunning;

    //
    // List of received packets waiting to be processed by ProtocolReceiveComplete()
    //
    LIST_ENTRY linkPackets;

    //
    // This is the number of packets that are received that are owned by NDIS and must
    // be returned back to NDIS.
    //
    LONG NumPacketsOwnedByNdis;

}
BINDING, *PBINDING;

/////////////////////////////////////////////////////////////////////////////
//
//
// Local macros
//
/////////////////////////////////////////////////////////////////////////////

#define ALLOC_BINDING( ppB )    NdisAllocateMemoryWithTag( ppB, sizeof( BINDING ), MTAG_BINDING )

#define FREE_BINDING( pB )      NdisFreeMemory( pB, sizeof( BINDING ), 0 )

#define VALIDATE_BINDING( pB )  ( ( pB ) && ( pB->tagBinding == MTAG_BINDING ) )

NDIS_STATUS 
InitializeProtocol(
    IN NDIS_HANDLE NdisProtocolHandle,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PrLoad(
    VOID 
    );

BINDING* 
AllocBinding();

VOID 
ReferenceBinding(
    IN BINDING* pBinding,
    IN BOOLEAN fAcquireLock
    );

VOID 
DereferenceBinding(
    IN BINDING* pBinding
    );

VOID 
BindingCleanup(
    IN BINDING* pBinding
    );

VOID
DetermineMaxFrameSize();

VOID
ChangePacketFiltersForAdapters(
   BOOLEAN fSet
   );

VOID 
AddBindingToProtocol(
    IN BINDING* pBinding
    );

VOID 
RemoveBindingFromProtocol(
    IN BINDING* pBinding
    );

VOID
PrUnload(
    VOID 
    );

NDIS_STATUS 
PrRegisterProtocol(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT NDIS_HANDLE* pNdisProtocolHandle
    );

VOID
PrBindAdapter(
    OUT PNDIS_STATUS Status,
    IN NDIS_HANDLE  BindContext,
    IN PNDIS_STRING  DeviceName,
    IN PVOID  SystemSpecific1,
    IN PVOID  SystemSpecific2
    );

BOOLEAN 
PrOpenAdapter(
    IN BINDING* pBinding,
    IN PNDIS_STRING  DeviceName
    );

VOID 
PrOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus
    );

BOOLEAN
PrQueryAdapterForCurrentAddress(
    IN BINDING* pBinding
    );

BOOLEAN
PrQueryAdapterForLinkSpeed(
    IN BINDING* pBinding
    );

BOOLEAN
PrQueryAdapterForMaxFrameSize(
    IN BINDING* pBinding
    );

BOOLEAN
PrSetPacketFilterForAdapter(
    IN BINDING* pBinding,
    IN BOOLEAN fSet
    );
    
VOID
PrRequestComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_REQUEST pRequest,
    IN NDIS_STATUS status
    );

VOID 
PrUnbindAdapter(
    OUT PNDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  UnbindContext
    );

VOID
PrCloseAdapter( 
    IN BINDING* pBinding 
    );

VOID 
PrCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status
    );

BOOLEAN 
PrAddCallToBinding(
    IN BINDING* pBinding,
    IN PCALL pCall
    );

VOID 
PrRemoveCallFromBinding(
    IN BINDING* pBinding,
    IN PCALL pCall
    );

VOID 
PrSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS Status
    );

INT 
PrReceivePacket(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet
    );

NDIS_STATUS 
PrBroadcast(
    IN PPPOE_PACKET* pPacket
    );

VOID 
ExecBindingWorkItem(
    PVOID Args[4],
    UINT workType
    );  

NDIS_STATUS
PrReceive(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  MacReceiveContext,
    IN PVOID  HeaderBuffer,
    IN UINT  HeaderBufferSize,
    IN PVOID  LookAheadBuffer,
    IN UINT  LookaheadBufferSize,
    IN UINT  PacketSize
    );
    
VOID
PrTransferDataComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet,
    IN NDIS_STATUS  Status,
    IN UINT  BytesTransferred
    );
    
VOID
PrReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

ULONG
PrQueryMaxFrameSize();

NDIS_STATUS
PrSend(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    );

VOID
PrStatus(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer, 
    IN UINT StatusBufferSize
    );  

NDIS_STATUS
PrPnPEvent(
    IN NDIS_HANDLE hProtocolBindingContext,
    IN PNET_PNP_EVENT pNetPnPEvent
    );
    
VOID
PrReEnumerateBindings(
    VOID
    );
  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\protocol.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    protocol.c

Abstract:

    This module contains all the protocol interface routines.  

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include <tdikrnl.h> // For TdiCopyLookaheadData()
//
// VOID
// TdiCopyLookaheadData(
//     IN PVOID Destination,
//     IN PVOID Source,
//     IN ULONG Length,
//     IN ULONG ReceiveFlags
//     );
//
/*
#ifdef _M_IX86
#define TdiCopyLookaheadData(_Destination,_Source,_Length,_ReceiveFlags)   \
    RtlCopyMemory(_Destination,_Source,_Length)
#else
#define TdiCopyLookaheadData(_Destination,_Source,_Length,_ReceiveFlags) { \
    if ((_ReceiveFlags) & TDI_RECEIVE_COPY_LOOKAHEAD) {                    \
        RtlCopyMemory(_Destination,_Source,_Length);                       \
    } else {                                                               \
        PUCHAR _Src = (PUCHAR)(_Source);                                   \
        PUCHAR _Dest = (PUCHAR)(_Destination);                             \
        PUCHAR _End = _Dest + (_Length);                                   \
        while (_Dest < _End) {                                             \
            *_Dest++ = *_Src++;                                            \
        }                                                                  \
    }                                                                      \
}
#endif
*/

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

extern NPAGED_LOOKASIDE_LIST gl_llistWorkItems;

/////////////////////////////////////////////////////////////////////////////
//
// Variables local to this module
// They are defined as global only for debugging purposes
//
/////////////////////////////////////////////////////////////////////////////

#define INVALID_HANDLE_VALUE                (NDIS_HANDLE) 0

//
// Handle passed to us by NDIS while registering the protocol
//
NDIS_HANDLE gl_hNdisProtocolHandle = INVALID_HANDLE_VALUE;

//
// Controls access for members listed below
//
NDIS_SPIN_LOCK gl_lockProtocol;

//
// List of binding contexts that are bound
//
LIST_ENTRY gl_linkBindings;

//
// Boolean flag to remember if PrUnload() was called previously
//
BOOLEAN gl_fProtocolUnloaded = TRUE;

// Boolean flag to decide if we need to set packet filters at bind time
//
//
BOOLEAN gl_fSetPacketFiltersAtBind = FALSE;

//
// Boolean flag set to tell the protocol it is okay to bind
// This flag is initially FALSE and is only set to true
// when a tapi client either wants to make an outgoing call
// or listen for incoming calls
//
BOOLEAN gl_fBindProtocol = FALSE;


//
// Number of binding contexts in linkBindings
//
ULONG gl_ulNumBindings;

//
// Keeps the minimum of max frame sizes of bindings.
// This value is used by miniport and is passed to NDISWAN
// in OID_WAN_GET_INFO query.
//
ULONG gl_ulMaxFrameSize = 0;


/////////////////////////////////////////////////////////////////////////////
//
//
// Local functions (not exposed) definitions
//
/////////////////////////////////////////////////////////////////////////////
    
NDIS_STATUS 
InitializeProtocol(
    IN NDIS_HANDLE NdisProtocolHandle,
    IN PUNICODE_STRING RegistryPath
)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function initializes the static protocol members.
    NdisRegisterProtocol() must be called before.

Parameters:

    DriverObject:
        Pointer to the driver object.

    RegistryPath:
        A unicode string that identifies the registry entry. We can use this this retrieve
        value from the registry.
    
Return Values:

    NDIS_STATUS_SUCCESS:
        Protocol initialized.

    NDIS_STATUS_XXX:
        Protocol initialization failed, deregister protocol.
---------------------------------------------------------------------------*/   

{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    TRACE( TL_N, TM_Pr, ("+InitializeProtocol") );

    //
    // Future: Read values from registry here
    //

    //
    // Initialize the NdisProtocolHandle
    //
    gl_hNdisProtocolHandle = NdisProtocolHandle;

    //
    // Allocate the spin lock
    //
    NdisAllocateSpinLock( &gl_lockProtocol );

    //
    // Initialize list of bindings
    //
    NdisInitializeListHead( &gl_linkBindings );

    //
    // Initialize number of allocated bindings
    //
    gl_ulNumBindings = 0;

    //
    // Load the resources
    //
    PrLoad();

    TRACE( TL_N, TM_Pr, ("-InitializeProtocol=$%x",status) );

    return status;
}


VOID
PrLoad()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will allocate the resources for the protocol.

    Caller must make sure that PrLoad() and PrUnload() are not called simultaneously, 
    as well as multiple PrLoad()'s are not called simultanesouly.

    It will load the resources if they were unloaded, and do nothing otherwise.

    We need this function because the resources freed by PrUnload() must be loaded
    somehow, and there is no function called prior to PrBindAdapter() once PrUnload()
    is called. So we allocate all the resources for the binding, and once binding is completed,
    we call this function to load the resources if necesarry prior to notifying the completion
    of binding to NDIS.
        
Parameters:

    None
    
Return Values:

    - Pointer to the newly allocated binding context.
    - NULL if allocation fails.
    
---------------------------------------------------------------------------*/   

{

    TRACE( TL_N, TM_Pr, ("+PrLoad") );

    //
    // Make sure we are not trying to initialize resources, 
    // unless they are already freed by PrUnload()
    //
    if ( gl_fProtocolUnloaded )
    {
        TRACE( TL_N, TM_Pr, ("PrLoad: Loading the resources" ) );
    
        ASSERT( gl_ulNumBindings == 0 );
    
        //
        // Allocate packet pool
        //
        PacketPoolInit();

        gl_fProtocolUnloaded = FALSE;
    }

    TRACE( TL_N, TM_Pr, ("-PrLoad") );
}



BINDING* 
AllocBinding()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will allocate the resources for the binding context.
        
Parameters:

    pBinding     _ A pointer to our binding information structure.
    
    fAcquireLock _ Flag that indicates if the function needs to acquire the lock
                   or not. If the caller already owns the lock for the binding,
                   then it should be supplied as TRUE, otherwise FALSE.

Return Values:

    - Pointer to the newly allocated binding context.
    - NULL if allocation fails.
    
---------------------------------------------------------------------------*/   
{

    BINDING* pBinding = NULL;

    TRACE( TL_N, TM_Pr, ("+AllocBinding") );

    if ( ALLOC_BINDING( &pBinding ) != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Pr, ("AllocBinding: Could not allocate context") );

        TRACE( TL_N, TM_Pr, ("-AllocBinding") );

        return NULL;
    }

    NdisZeroMemory( pBinding, sizeof(BINDING) );

    pBinding->tagBinding = MTAG_BINDING;

    pBinding->stateBinding = BN_stateBindPending;

    NdisInitializeEvent( &pBinding->RequestCompleted );

    pBinding->BindAdapterStatus = NDIS_STATUS_FAILURE;

    NdisInitializeEvent( &pBinding->eventFreeBinding );
    
    NdisAllocateSpinLock( &pBinding->lockBinding );

    InitializeListHead( &pBinding->linkPackets );

    TRACE( TL_N, TM_Pr, ("-AllocBinding") );
    
    return pBinding;
}


VOID 
ReferenceBinding(
    IN BINDING* pBinding,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the binding.
        
Parameters:

    pBinding     _ A pointer ot our binding information structure.
    
    fAcquireLock _ Flag that indicates if the function needs to acquire the lock
                   or not. If the caller already owns the lock for the binding,
                   then it should be supplied as TRUE, otherwise FALSE.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    LONG lRef;
    
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+ReferenceBinding") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pBinding->lockBinding );

    lRef = ++pBinding->lRef;
    
    if ( fAcquireLock )
        NdisReleaseSpinLock( &pBinding->lockBinding );

    TRACE( TL_V, TM_Pr, ("-ReferenceBinding=$%d",lRef) );
}

VOID 
DereferenceBinding(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the binding.
    If the count reaches 0, it will signal pBinding->eventFreeBinding 
    so that PrUnbindAdapter() function can free the protocol context.

    CAUTION: Caller must not be holding any locks.
    
Parameters:

    pBinding _ A pointer to our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    BOOLEAN fSignalFreeBindingEvent = FALSE;
    LONG lRef;
    
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+DereferenceBinding") );

    NdisAcquireSpinLock( &pBinding->lockBinding );

    lRef = --pBinding->lRef;
    
    if ( lRef == 0 )
    {
        fSignalFreeBindingEvent = TRUE;
    }

    NdisReleaseSpinLock( &pBinding->lockBinding );

    if ( fSignalFreeBindingEvent )
        NdisSetEvent( &pBinding->eventFreeBinding );

    TRACE( TL_V, TM_Pr, ("-DereferenceBinding=$%d",lRef) );

}


VOID 
BindingCleanup(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will free the resources allocated for the binding context.
        
Parameters:

    pBinding     _ A pointer to our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+BindingCleanup") );
    
    ASSERT( pBinding->lRef == 0 );
    
    NdisFreeSpinLock( &pBinding->lockBinding );

    FREE_BINDING( pBinding );

    TRACE( TL_N, TM_Pr, ("-BindingCleanup") );
}

VOID
DetermineMaxFrameSize()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called when a new binding is added or removed.
    It will walk thru all the bindings and select the minimum of max frame
    size values, and set it to gl_ulMaxFrameSize.

    It will be called from 2 places:
    - PrAddBindingToProtocol()
    - PrRemoveBindingFromProtocol()
    
    CAUTION: gl_lockProtocol must be acquired before calling this function.

Parameters:

    None

Return Values:

    None
---------------------------------------------------------------------------*/       
{
    LIST_ENTRY* pLink = NULL;
    
    pLink = gl_linkBindings.Flink;

    //
    // See if we have any bindings
    //
    if ( pLink != &gl_linkBindings )
    {
        ULONG MinOfMaxFrameSizes = 0;
        BINDING* pBinding = NULL;

        //
        // We have at least one binding, so walk thru the list
        // and select the minimum of MaxFrameSize values
        //
        pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

        MinOfMaxFrameSizes = pBinding->ulMaxFrameSize;
    
        //
        // Iterate to the next binding
        //
        pLink = pLink->Flink;
        
        while ( pLink != &gl_linkBindings )
        {
            ULONG MaxFrameSize;

            //
            // Retrieve the MaxFrameSize value of the next binding and 
            // select the minimum
            //
            pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

            MaxFrameSize = pBinding->ulMaxFrameSize;
    
            if ( MinOfMaxFrameSizes > MaxFrameSize )
            {
                MinOfMaxFrameSizes = MaxFrameSize;
            }
    
            //
            // Iterate to the next binding
            //
            pLink = pLink->Flink;
        }

        //
        // Set gl_ulMaxFrameSize to the selected minimum value
        //
        gl_ulMaxFrameSize = MinOfMaxFrameSizes;
    }
    else
    {
        //
        // Binding list is empty, so set it to 0
        //
        gl_ulMaxFrameSize = 0;
    }

}
    

VOID 
AddBindingToProtocol(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will insert a binding to protocols binding table.

    It will also put a reference on the binding which will go away
    when the binding is removed from this table with a call to 
    RemoveBindingFromProtocol().

Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/       
{

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+AddBindingToProtocol") );

    NdisAcquireSpinLock( &gl_lockProtocol );

    InsertTailList( &gl_linkBindings, &pBinding->linkBindings );

    gl_ulNumBindings++;

    //
    // Determine the new max frame size value
    //
    DetermineMaxFrameSize();
    
    NdisReleaseSpinLock( &gl_lockProtocol );

    ReferenceBinding( pBinding, TRUE );

    TRACE( TL_N, TM_Pr, ("-AddBindingToProtocol") );
}

VOID 
RemoveBindingFromProtocol(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will remove a binding from protocols binding list. 

    Binding will be dereferenced after removal from the list.

    CAUTION: Caller must not be holding any locks before calling this function.

Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    None
---------------------------------------------------------------------------*/       
    
{
    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+RemoveBindingFromProtocol") );
    
    NdisAcquireSpinLock( &gl_lockProtocol );

    RemoveHeadList( pBinding->linkBindings.Blink );

    InitializeListHead( &pBinding->linkBindings );

    gl_ulNumBindings--;

    //
    // Determine the new max frame size value
    //
    DetermineMaxFrameSize();

    NdisReleaseSpinLock( &gl_lockProtocol );

    DereferenceBinding( pBinding );

    TRACE( TL_N, TM_Pr, ("-RemoveBindingFromProtocol") );
}

/////////////////////////////////////////////////////////////////////////////
//
// Interface functions (exposed) definitions
//
/////////////////////////////////////////////////////////////////////////////

VOID
PrUnload(
    VOID 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    In response to a user request to uninstall a protocol, NDIS calls a protocol's
    ProtocolUnload function if the protocol has registered an entry point for 
    this function in the NDIS_PROTOCOL_CHARACTERISTICS structure that it passed 
    to NdisRegisterProtocol. NDIS calls ProtocolUnload after calling the protocol's
    ProtocolUnbindAdapter function once for each bound adapter.

    ProtocolUnload performs driver-determined cleanup operations. For example, 
    ProtocolUnload could request clients to close handles that they have opened 
    to device objects exported by the protocol. Until all such handles are closed,
    the I/O Manager will not call the DriverUnload function that the protocol 
    registered in the driver object passed to its DriverEntry function. After all 
    the handles are closed, ProtocolUnload could call IoDeleteDevice one or more 
    times to delete device objects created by the protocol.

    ProtocolUnload does not have to close a protocol's open bindings. When a 
    protocol's DriverUnload function calls NdisDeregisterProtocol, NDIS calls the 
    protocol's ProtocolUnbindAdapter function once for each binding that the 
    protocol has open. The ProtocolUnbindAdapter function calls NdisCloseAdapter 
    to close the binding.
    
    ProtocolUnload must be written so that it can run at IRQL PASSIVE_LEVEL.
   
Parameters:

    None
    
Return Values:

    None
        
---------------------------------------------------------------------------*/
{
    TRACE( TL_N, TM_Pr, ("+PrUnload") );

    if ( !gl_fProtocolUnloaded && gl_ulNumBindings == 0 )
    {
        TRACE( TL_N, TM_Pr, ("PrUnload: Unloading the resources" ) );
        
        PacketPoolUninit();

        gl_fProtocolUnloaded = TRUE;
    }

    TRACE( TL_N, TM_Pr, ("-PrUnlooad") );

}

NDIS_STATUS 
PrRegisterProtocol(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT NDIS_HANDLE* pNdisProtocolHandle
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will register the protocol with NDIS.
    It must be called from DriverEntry() function before any other in this module
    can be called.
        
Parameters:

    DriverObject:
        Pointer to the driver object.

    RegistryPath:
        A unicode string that identifies the registry entry. We can use this this retrieve
        value from the registry.

Return Values:

    NDIS_STATUS_SUCCESS :
        The NDIS library registered the caller as a protocol driver. 

    NDIS_STATUS_BAD_CHARACTERISTICS :
        The CharacteristicsLength is too small for the MajorNdisVersion specified in 
        the buffer at ProtocolCharacteristics. 

    NDIS_STATUS_BAD_VERSION :
        The MajorNdisVersion specified in the buffer at ProtocolCharacteristics is 
        invalid. 

    NDIS_STATUS_RESOURCES :
        A shortage of resources, possibly memory, prevented the NDIS library from 
        registering the caller.
        
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    BOOLEAN fProtocolRegistered = FALSE;
    NDIS_HANDLE NdisProtocolHandle;
    NDIS_PROTOCOL_CHARACTERISTICS npc;
    STRING NameString;
    UNICODE_STRING UnicodeNameString;
    

    TRACE( TL_I, TM_Pr, ("+PrRegisterProtocol") );

    do
    {
    
        NdisZeroMemory( &npc, sizeof(npc) );

        npc.MajorNdisVersion = PR_NDIS_MajorVersion;
        npc.MinorNdisVersion = PR_NDIS_MinorVersion;

        npc.Reserved = NDIS_USE_WAN_WRAPPER;

        npc.OpenAdapterCompleteHandler = PrOpenAdapterComplete;
        npc.CloseAdapterCompleteHandler = PrCloseAdapterComplete;
        npc.SendCompleteHandler = PrSendComplete;
        npc.TransferDataCompleteHandler = PrTransferDataComplete;
        // npc.ResetCompleteHandler = PrResetCompleteHandler;
        npc.RequestCompleteHandler = PrRequestComplete;
        npc.ReceiveHandler = PrReceive;
        npc.ReceiveCompleteHandler = PrReceiveComplete;
        npc.StatusHandler = PrStatus;
        // npc.StatusCompleteHandler;

        RtlInitString( &NameString, PR_CHARACTERISTIC_NAME );

        RtlAnsiStringToUnicodeString( &UnicodeNameString,
                                      &NameString,
                                      TRUE );

        npc.Name.Length = UnicodeNameString.Length;
        npc.Name.Buffer = UnicodeNameString.Buffer;

        //
        // MajorNdisVersion must be set to 0x04 or 0x05
        // with any of the following members.
        //
        npc.ReceivePacketHandler = PrReceivePacket;
        npc.BindAdapterHandler = PrBindAdapter;
        npc.UnbindAdapterHandler = PrUnbindAdapter;
        npc.PnPEventHandler = PrPnPEvent;
        npc.UnloadHandler = PrUnload;
        
        //
        // MajorNdisVersion must be set to 0x05 
        // with any of the following members.
        //
        // CoSendCompleteHandler;
        // CoStatusHandler;
        // CoReceivePacketHandler;
        // CoAfRegisterNotifyHandler;

        NdisRegisterProtocol(   &status,
                                &NdisProtocolHandle,
                                &npc,
                                sizeof( NDIS_PROTOCOL_CHARACTERISTICS ) );

        if ( status != NDIS_STATUS_SUCCESS )
            break;

        fProtocolRegistered = TRUE;

        status = InitializeProtocol( NdisProtocolHandle, RegistryPath );

        if ( status != NDIS_STATUS_SUCCESS )
            break;
    
    } while ( FALSE );

    if ( status != NDIS_STATUS_SUCCESS )
    {
        if ( fProtocolRegistered )
        {
            NDIS_STATUS tempStatus;

            NdisDeregisterProtocol( &tempStatus, NdisProtocolHandle );
        }
    }
    else
    {
        *pNdisProtocolHandle = NdisProtocolHandle;
    }

    TRACE( TL_I, TM_Pr, ("-PrRegisterProtocol=$%x",status) );

    return status;
}



VOID
PrBindAdapter(
    OUT PNDIS_STATUS Status,
    IN NDIS_HANDLE  BindContext,
    IN PNDIS_STRING  DeviceName,
    IN PVOID  SystemSpecific1,
    IN PVOID  SystemSpecific2
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS when an underlying adapter wants to 
    bind to us.
        
Parameters:

    Status 
        Points to a variable in which ProtocolBindAdapter returns the status of its 
        operation(s), as one of the following: 

            NDIS_STATUS_SUCCESS 
                The driver completed initialization successfully and bound itself to the 
                given NIC driver specified at DeviceName. 

            NDIS_STATUS_PENDING 
                The protocol will complete the bind operation asynchronously with a call to 
                NdisCompleteBindAdapter when it is ready to accept receives from the 
                underlying driver and to send transmit, query, and set requests down to the 
                underlying driver. 

            NDIS_STATUS_XXX or NTSTATUS_XXX 
                The protocol's attempt to set up a binding failed or the protocol could not 
                allocate the resources it needed to carry out network I/O operations. Usually
                , such an error status is propagated from an NdisXxx function or a kernel-
                mode support routine. 
                
    BindContext 
        Specifies a handle, supplied by NDIS, that the protocol passes subsequently 
        to NdisCompleteBindAdapter. 

    DeviceName 
        Points to a buffered Unicode string naming an underlying NIC driver or 
        virtual NIC driver to which ProtocolBindAdapter should bind. 

    SystemSpecific1 
        Specifies a registry path pointer that is a required parameter to 
        NdisOpenProtocolConfiguration. The caller cannot use this pointer for any 
        other purpose. 

    SystemSpecific2 
        Reserved for system use. The caller cannot use this pointer for any purpose. 

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    BINDING* pBinding = NULL;

    TRACE( TL_I, TM_Pr, ("+PrBindAdapter") );

    do 
    {
        NdisAcquireSpinLock( &gl_lockProtocol );

        if (gl_fBindProtocol == FALSE) {

            TRACE( TL_I, TM_Pr, ("PrBindAdapter: Not ready to bind!") );

            NdisReleaseSpinLock( &gl_lockProtocol );
            
            status = NDIS_STATUS_FAILURE;
            
            break;
        }

        NdisReleaseSpinLock( &gl_lockProtocol );

        pBinding = AllocBinding();
        
        if ( pBinding == NULL )
        {
            status = NDIS_STATUS_RESOURCES;
            
            break;
        }

        //
        // Load resources
        //
        PrLoad();

        //
        // Open adapter, and query it
        //
        if ( !PrOpenAdapter( pBinding, DeviceName ) )
        {
            break;
        }

        if ( !PrQueryAdapterForCurrentAddress( pBinding ) )
        {
            break;
        }

        //
        // No need to break if this one fails since it is not critical enough
        //
        PrQueryAdapterForLinkSpeed( pBinding );
       
        if ( !PrQueryAdapterForMaxFrameSize( pBinding ) )
        {
            break;
        }

        //
        // Check if we need to set packet filters at bind time 
        //
        if ( gl_fSetPacketFiltersAtBind )
        {
           PrSetPacketFilterForAdapter( pBinding, TRUE);
        }
        
        //
        // Change the state to bound
        //
        pBinding->stateBinding = BN_stateBound;

        // AddBindingToProtocol() will insert the new binding to protocols 
        // binding list, and reference it
        //
        AddBindingToProtocol( pBinding );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE);

    if ( pBinding ) 
    {
        pBinding->ulBindingFlags |= BNBF_BindAdapterCompleted;

        pBinding->BindAdapterStatus = status;

        if ( status != NDIS_STATUS_SUCCESS )
        {
           //
           // We did not call NdisCompleteBindAdapter() because
           // somethings went wrong
           //

           //
           // Close the adapter if it was opened succesfully
           //
           if ( ( pBinding->ulBindingFlags & BNBF_OpenAdapterCompleted ) &&
                ( pBinding->OpenAdapterStatus == NDIS_STATUS_SUCCESS ) )
           {
               PrCloseAdapter( pBinding );
           }

           //
           // Clean up the binding context
           //
           BindingCleanup( pBinding );
        }
    }

    *Status = status;

    TRACE( TL_I, TM_Pr, ("-PrBindAdapter=$%x",status) );
}

BOOLEAN 
PrOpenAdapter(
    IN BINDING* pBinding,
    IN PNDIS_STRING  DeviceName
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to open the underlying adapter.

    CAUTION: It must be called from PASSIVE_LEVEL.

Parameters:

    pBinding:
        A pointer ot our binding information structure.

    DeviceName:
        Name of the device to be opened. This is passed to PrBindAdapter()
        by NDIS.

Return Values:
    TRUE:
        If underlying adapter could be opened succesfully.

    FALSE:
        If underlying adapter could not be opened succesfully.
    
---------------------------------------------------------------------------*/    
{
    NDIS_STATUS status;
    NDIS_STATUS openErrorStatus;

    NDIS_MEDIUM arrayNdisMedium[] = { NdisMedium802_3 };
    UINT sizeNdisMediumArray = sizeof( arrayNdisMedium ) / sizeof( NDIS_MEDIUM );

    TRACE( TL_N, TM_Pr, ("+PrOpenAdapter") );

    NdisOpenAdapter( &status,
                     &openErrorStatus,
                     &pBinding->NdisBindingHandle,
                     &pBinding->uintSelectedMediumIndex,
                     arrayNdisMedium,                   
                     sizeNdisMediumArray,               
                     gl_hNdisProtocolHandle,
                     pBinding,
                     DeviceName,
                     0,
                     NULL );

    if ( status != NDIS_STATUS_PENDING )
    {
       //
       // NidsOpenAdapter() completed synchronously, 
       // so call PrOpenAdapterComplete() manually.
       //
       PrOpenAdapterComplete( pBinding,
                              status,
                              openErrorStatus );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrOpenAdapter") );

    return pBinding->OpenAdapterStatus == NDIS_STATUS_SUCCESS;
}

VOID 
PrOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called after the underlying adapter is opened. 

    We save the result of the Open adapter operation and set the RequestCompleted
    member of the binding context to resume the thread waiting for this to complete.

    CAUTION: It can be called from PASSIVE_LEVEL or at DISPATCH_LEVEL.
    
Parameters:

    ProtocolBindingContext:
        A pointer ot our binding information structure.

    Status:
        NDIS_STATUS_SUCCESS:
            Indicates that NdisOpenAdapter() completed succesfully.

        NDIS_XXX:
            Indicates that NdisOpenAdapter() did not complete succesfully.

    OpenErrorStatus:
        Specifies additional information about the reason for a failure if the value 
        at Status is not NDIS_STATUS_SUCCESS and if the underlying driver supplied 
        this information. For example, the driver of a Token Ring NIC might return a 
        ring error that NDIS forwards to ProtocolOpenAdapterComplete. This parameter 
        can be NULL. 
    
Return Values:

    None
---------------------------------------------------------------------------*/
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_I, TM_Pr, ("+PrOpenAdapterComplete") );

    TRACE( TL_N, TM_Pr, ("PrOpenAdapterComplete: NdisOpenAdapter() completed=$%x", Status ) );

    pBinding->ulBindingFlags |= BNBF_OpenAdapterCompleted;

    pBinding->OpenAdapterStatus = Status;

    NdisSetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_I, TM_Pr, ("-PrOpenAdapterComplete") );
}


BOOLEAN
PrQueryAdapterForCurrentAddress(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to query the underlying adapter for current MAC
    address oid.

    The underlying adapter must have been opened succesfully prior to calling
    this function.

    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;

    TRACE( TL_N, TM_Pr, ("+PrQueryAdapterForCurrentAddress") );

    //
    // Generate an NDIS_REQUEST for querying current address oid
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestQueryInformation ;

    pRequest->DATA.QUERY_INFORMATION.Oid = OID_802_3_CURRENT_ADDRESS;

    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBinding->LocalAddress;

    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof( CHAR ) * 6;

    //
    // Request information from the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0  );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrQueryAdapterForCurrentAddress") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

BOOLEAN
PrQueryAdapterForLinkSpeed(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to query the underlying adapter for link speed oid.

    The underlying adapter must have been opened succesfully prior to calling
    this function.
        
    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;

    TRACE( TL_N, TM_Pr, ("+PrQueryAdapterForLinkSpeed") );

    //
    // Generate an NDIS_REQUEST for querying link speed oid
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestQueryInformation ;

    pRequest->DATA.QUERY_INFORMATION.Oid = OID_GEN_LINK_SPEED;

    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = &pBinding->ulSpeed;

    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof( pBinding->ulSpeed );

    //
    // Request information from the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrQueryAdapterForLinkSpeed") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

BOOLEAN
PrQueryAdapterForMaxFrameSize(
    IN BINDING* pBinding
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to query the underlying adapter for max frame size
    oid.

    The underlying adapter must have been opened succesfully prior to calling
    this function.
        
    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;

    TRACE( TL_N, TM_Pr, ("+PrQueryAdapterForMaxFrameSize") );

    //
    // Generate an NDIS_REQUEST for querying link speed oid
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestQueryInformation ;

    pRequest->DATA.QUERY_INFORMATION.Oid = OID_GEN_MAXIMUM_FRAME_SIZE;

    pRequest->DATA.QUERY_INFORMATION.InformationBuffer = &pBinding->ulMaxFrameSize;

    pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof( pBinding->ulMaxFrameSize );

    //
    // Request information from the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrQueryAdapterForMaxFrameSize") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

BOOLEAN
PrSetPacketFilterForAdapter(
    IN BINDING* pBinding,
    IN BOOLEAN fSet
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to set the current generic packet filter for our
    protocol.

    The underlying adapter must have been opened succesfully prior to calling
    this function.
        
    We save the result of the request in the binding context and set the 
    RequestCompleted member of the binding context to resume the thread 
    waiting for this to complete.

    CAUTION: It must be called from PASSIVE_LEVEL.
        
Parameters:

    pBinding:
        A pointer ot our binding information structure.

    fSet:
        Indicates what the filters will be set to. 
        TRUE means receive packets, FALSE means set it to 0.

Return Values:

    TRUE:
        If the request was completed succesfully.

    FALSE:
        If the request was not completed succesfully.
---------------------------------------------------------------------------*/
{

    NDIS_STATUS status;
    PNDIS_REQUEST pRequest = &pBinding->Request;
    BOOLEAN fPacketFilterAlreadySet = (BOOLEAN) ( pBinding->ulBindingFlags & BNBF_PacketFilterSet );

    TRACE( TL_N, TM_Pr, ("+PrSetPacketFilterForAdapter") );

    //
    // See if we already are in the state the request wants us to be in
    //
    if ( ( fPacketFilterAlreadySet && fSet ) ||
         ( !fPacketFilterAlreadySet && !fSet ) )
    {
       pBinding->RequestStatus = NDIS_STATUS_SUCCESS;

       TRACE( TL_N, TM_Pr, ("PrSetPacketFilterForAdapter: Already in the requested state") );

       TRACE( TL_N, TM_Pr, ("-PrSetPacketFilterForAdapter") );

       return TRUE;
    }
    
    pBinding->ulPacketFilter = ( fSet ) ? (NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED) : 0;

    //
    // Generate an NDIS_REQUEST for setting current packet filter
    //
    NdisZeroMemory( pRequest, sizeof( NDIS_REQUEST ) );

    pRequest->RequestType = NdisRequestSetInformation;

    pRequest->DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_PACKET_FILTER;

    pRequest->DATA.SET_INFORMATION.InformationBuffer = &pBinding->ulPacketFilter;

    pRequest->DATA.SET_INFORMATION.InformationBufferLength = sizeof( ULONG );

    //
    // Request set info on the adapter
    //
    NdisRequest( &status,
                 pBinding->NdisBindingHandle,
                 pRequest );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisRequest() completed synchronously, call PrRequestComplete()
        // manually.
        //
        PrRequestComplete( pBinding,
                           pRequest,
                           status );
    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );
    
    TRACE( TL_N, TM_Pr, ("-PrSetPacketFilterForAdapter") );

    return pBinding->RequestStatus == NDIS_STATUS_SUCCESS;
}

VOID
PrRequestComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_REQUEST pRequest,
    IN NDIS_STATUS status
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to indicate that an NDIS request submitted
    previously has completed.

    We submit 2 requests:
    - OID_802_3_CURRENT_ADDRESS: This is submitted from PrQueryAdapterForCurrentAddress()
                                 to obtain the current MAC address for the underlying 
                                 adapter.

    - OID_GEN_LINK_SPEED: This is submitted from PrQueryAdapterForLinkSpeed() to obtain
                          the current link speed of the underlying adapter.

    - OID_GEN_CURRENT_PACKET_FILTER: This is submitted from PrSetPacketFilterForAdapter()
                                     to set the packet types we are interested in to NDIS.


    If the request for MAC address fail, we clean up the binding context and notify
    NDIS that bind adapter failed, otherwise we go ahead and query the adapter for link 
    speed.

    Regardless of the status of request for link speed, we notify NDIS about succesful
    completion of the bind operation as this is not a fatal error.

    Before calling this function, the underlying adapter must have been opened
    succesfully.
        
Parameters:

    ProtocolBindingContext:
        A pointer ot our binding information structure.

    pRequest:
        A pointer to the request submitted previously.

    Status:
        Completion status of the request.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    BOOLEAN fUnknownOid = FALSE;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_I, TM_Pr, ("+PrRequestComplete") );
   
    switch ( pRequest->RequestType )
    {

        case NdisRequestQueryInformation:
            {
        
                switch ( pRequest->DATA.QUERY_INFORMATION.Oid )
                {

                    case OID_802_3_CURRENT_ADDRESS:
    
                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_802_3_CURRENT_ADDRESS=$%x",status) );

                        pBinding->ulBindingFlags |= BNBF_CurrentAddressQueryCompleted;

                        break;

                    case OID_GEN_LINK_SPEED:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_GEN_LINK_SPEED=$%x",status) );

                        pBinding->ulBindingFlags |= BNBF_LinkSpeedQueryCompleted;
                                
                        break;

                    case OID_GEN_MAXIMUM_FRAME_SIZE:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_GEN_MAXIMUM_FRAME_SIZE=$%x",status) );

                        pBinding->ulBindingFlags |= BNBF_MaxFrameSizeQueryCompleted;

                        break;
                        
                    default:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: UNKNOWN OID=$%x",pRequest->DATA.QUERY_INFORMATION.Oid) );

                        fUnknownOid = TRUE;
                    
                        break;
                }

            }

            break;

        case NdisRequestSetInformation:
            {
                switch ( pRequest->DATA.SET_INFORMATION.Oid )
                {
            
                    case OID_GEN_CURRENT_PACKET_FILTER:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: OID_GEN_CURRENT_PACKET_FILTER=$%x",status) );

                        if ( status == NDIS_STATUS_SUCCESS )
                        {
                           if ( pBinding->ulBindingFlags & BNBF_PacketFilterSet )
                           {
                              //
                              // Packet filter was set, so reset it
                              //
                              pBinding->ulBindingFlags &= ~BNBF_PacketFilterSet;
                           }
                           else
                           {
                              //
                              // Packet filter was reset, so set it
                              //
                              pBinding->ulBindingFlags |= BNBF_PacketFilterSet;
                           }
                        }                           

                        break;
                        
                    default:

                        TRACE( TL_N, TM_Pr, ("PrRequestComplete: UNKNOWN OID=$%x",pRequest->DATA.SET_INFORMATION.Oid) );
                    
                        fUnknownOid = TRUE;
                        
                        break;

                }
            }

            break;

        default:

            TRACE( TL_N, TM_Pr, ("PrRequestComplete: Unknown RequestType=$%x",pRequest->RequestType) );

            fUnknownOid = TRUE;
            
            break;

    }

    if ( !fUnknownOid )
    {
       pBinding->RequestStatus = status;

       NdisSetEvent( &pBinding->RequestCompleted );
    }

    TRACE( TL_I, TM_Pr, ("-PrRequestComplete") );
}

VOID 
PrUnbindAdapter(
    OUT PNDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  UnbindContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS when an underlying adapter wants to 
    unbind from us.

    ArvindM says PrBindAdapter() and PrUnbindAdapter() will be serialized
    by NDIS.

    This function will not be called if PrBindAdapter() did not succeed.

    Also this function will not be called as long as there are outstanding
    PrReceivePacket() calls active.

    However this function may be called while there are outstanding
    PrSend(), PrSendPayload() or PrBroadcast() calls, that's why we keep
    track of such calls with pBinding->nSendPending and wait on the completion
    of these requests. And as we set the state to BN_stateUnbinding, no such
    new requests will be accepted, and pBinding->nSendPending will reach 0
    at some point which will trigger the pBinding->eventSendCompleted.

    This function is called at IRQL_PASSIVE level by default so we can
    safely wait on events.
        
Parameters:

    Status 
        Points to a variable in which ProtocolBindAdapter returns the status of its 
        operation(s), as one of the following: 

            NDIS_STATUS_SUCCESS 
                The driver completed the unbind operation and deallocated the resources. 

            NDIS_STATUS_PENDING 
                The protocol will complete the unbind operation asynchronously with a call to 
                NdisCompleteUnbindAdapter when ProtocolCloseAdapterComplete() is called.
            
    ProtocolBindingContext 
        A pointer to our binding context.

    UnbindContext:
        This handle is supplied by NDIS and should be used if NdisCloseAdapter() pends.
        Then we will get a call to ProtocolCloseAdapterComplete() which will use this
        handle to notify NDIS about the completion of the initial PrUnbindAdapter()
        request.
        
Return Values:

    None
---------------------------------------------------------------------------*/   
    
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_I, TM_Pr, ("+PrUnbindAdapter") );

    NdisAcquireSpinLock( &pBinding->lockBinding );

    //
    // If there is a sleep request pending, wait for it to complete
    //
    while ( pBinding->stateBinding == BN_stateSleepPending )
    {
        NdisReleaseSpinLock( &pBinding->lockBinding );
        
        NdisMSleep( 10000 );
        
        NdisAcquireSpinLock( &pBinding->lockBinding );
    }
    
    //
    // Mark binding as unbind pending
    //
    ASSERT( pBinding->stateBinding == BN_stateSleeping ||
            pBinding->stateBinding == BN_stateBound );

    pBinding->stateBinding = BN_stateUnbindPending;

    NdisReleaseSpinLock( &pBinding->lockBinding );

    //
    // Unbind all the active sessions on this binding
    //
    MpNotifyBindingRemoval( pBinding );
    
    //
    // Remove Binding from protocols binding table
    // 
    RemoveBindingFromProtocol( pBinding );
    
    //
    // Wait for all references to be deleted
    //
    NdisWaitEvent( &pBinding->eventFreeBinding, 0 );

    TRACE( TL_N, TM_Pr, ("PrUnbindAdapter: All references are deleted") );

    //
    // All references have been removed, now wait for all packets owned by NDIS
    // to be returned.
    //
    // Note that no synchronization is necesarry for reading the value of numPacketsOwnedByNdis
    // at this point since it can only be incremented when there is at least 1 reference on the 
    // binding - at this point ref count is 0 -, and because it can not be incremented, it can 
    // only reach 0 once.
    //
    while ( pBinding->NumPacketsOwnedByNdis )
    {
        NdisMSleep( 10000 );
    }

    TRACE( TL_N, TM_Pr, ("PrUnbindAdapter: All NDIS owned packets have been returned") );

    //
    // Since all references have been deleted, we can close the underlying adapter.
    //
    PrCloseAdapter( pBinding );

    //
    // Change the binding state to unbound
    //
    pBinding->stateBinding = BN_stateUnbound;

    //
    // Clean up the binding context
    //
    BindingCleanup( pBinding );

    *Status = NDIS_STATUS_SUCCESS;

    TRACE( TL_I, TM_Pr, ("-PrUnbindAdapter") );
}


VOID
PrCloseAdapter( 
    IN BINDING* pBinding 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to close the underlying adapter. It must be called
    either from PrBindAdapter() or PrUnbindAdapter().

    CAUTION: It must be called from PASSIVE_LEVEL.

Parameters:

    pBinding:
        Binding context that owns the adapter to close.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status;
    
    TRACE( TL_N, TM_Pr, ("+PrCloseAdapter") );

    NdisCloseAdapter( &status, pBinding->NdisBindingHandle );

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisCloseAdapter() completed synchronously, 
        // complete the request manually
        //      
        PrCloseAdapterComplete( pBinding, status );

    }

    NdisWaitEvent( &pBinding->RequestCompleted, 0 );

    NdisResetEvent( &pBinding->RequestCompleted );

    TRACE( TL_N, TM_Pr, ("-PrCloseAdapter") );
}


VOID 
PrCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function can be called from PrCloseAdapter() if NdisCloseAdapter()
    completes synchronously, or it will be called by NDIS at DISPATCH_LEVEL.

    It sets the BNBF_CloseAdapterCompleted flag and sets the RequestCompleted
    member of the binding context to resume the thread waiting on this event.

    CAUTION: It can be called from PASSIVE_LEVEL or DISPATCH_LEVEL.

Parameters:

    ProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 

    Status:
        Indicates the final status of the close operation in the underlying driver.     

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    BINDING* pBinding = ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_I, TM_Pr, ("+PrCloseAdapterComplete") );
   
    TRACE( TL_N, TM_Pr, ("PrCloseAdapterComplete: NdisCloseAdapter() completed=$%x", Status ) );

    pBinding->ulBindingFlags |= BNBF_CloseAdapterCompleted;

    NdisSetEvent( &pBinding->RequestCompleted );

    TRACE( TL_I, TM_Pr, ("-PrCloseAdapterComplete") );
}


BOOLEAN 
PrAddCallToBinding(
    IN BINDING* pBinding,
    IN PCALL pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will put a reference on the binding which will be removed
    when PrRemoveCallFromBinding() is called.

    It will return TRUE if reference is added succesfully, and FALSE if reference
    could not be added.

    Reference will not be added if binding is not in bound state.

    CAUTION: Caller must make sure that the binding is not freed before calling this
             function.

Parameters:

    pBinding:
        A pointer ot our binding information structure.

    pCall:
        A pointer to our call information structure.

Return Values:

    TRUE:
        Binding referenced for the call

    FALSE:
        Binding not reference for the call
        
---------------------------------------------------------------------------*/       
{
    BOOLEAN fResult;

    TRACE( TL_N, TM_Pr, ("+PrAddCallToBinding") );

    //
    // We have to acquire lock of call first to avoid dead locks
    //
    NdisAcquireSpinLock( &pCall->lockCall );

    if ( pCall->ulClFlags & CLBF_CallDropped ||
         pCall->ulClFlags & CLBF_CallClosePending )
    {
        NdisReleaseSpinLock( &pCall->lockCall );

        TRACE( TL_A, TM_Pr, ("PrAddCallToBinding: Call already dropped or close pending") );

        TRACE( TL_N, TM_Pr, ("-PrAddCallToBinding") );

        return FALSE;

    }

    NdisAcquireSpinLock( &pBinding->lockBinding );

    //
    // Check the state of the binding, if it is not bound
    // we can not add the call
    //
    if ( pBinding->stateBinding != BN_stateBound )
    {

        NdisReleaseSpinLock( &pBinding->lockBinding );

        NdisReleaseSpinLock( &pCall->lockCall );

        TRACE( TL_A, TM_Pr, ("PrAddCallToBinding: Binding state not bound") );

        TRACE( TL_N, TM_Pr, ("-PrAddCallToBinding") );

        return FALSE;

    }

    //
    // Both binding and call are ready to be bound
    // Go ahead and add the call
    //

    //
    // Set call's binding context ptr to binding
    //
    pCall->pBinding = pBinding;

    //
    // Copy the local address of the binding
    //
    NdisMoveMemory( pCall->SrcAddr, pBinding->LocalAddress, 6 * sizeof( CHAR ) );

    //
    // Set call's link speed
    //
    pCall->ulSpeed = pBinding->ulSpeed;

    //
    // Pass the MaxFrameSize to call context
    //
    pCall->ulMaxFrameSize = pBinding->ulMaxFrameSize - ( PPPOE_PACKET_HEADER_LENGTH - ETHERNET_HEADER_LENGTH );
    
    //
    // Make a reference on the binding which will be removed when PrRemoveCallFromBinding()
    // is called
    //
    ReferenceBinding( pBinding, FALSE );

    //
    // Release the locks, and return
    //
    NdisReleaseSpinLock( &pBinding->lockBinding );

    NdisReleaseSpinLock( &pCall->lockCall );

    TRACE( TL_N, TM_Pr, ("-PrAddCallToBinding") );

    return TRUE;
}


VOID 
PrRemoveCallFromBinding(
    IN BINDING* pBinding,
    IN CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to remove a reference added by a  PrAddCallToBinding()
    for a call on this binding. 

Parameters:

    pBinding:
        Pointer to the binding context that the will be dereferenced.

    pCall: 
        Pointer to the call context being unbound fromthe binding.

Return Values:

    None
    
---------------------------------------------------------------------------*/       
{
    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_N, TM_Pr, ("+PrRemoveCallFromBinding") );

    NdisAcquireSpinLock( &pCall->lockCall );

    pCall->pBinding = NULL;

    pCall->ulSpeed = 0;

    NdisReleaseSpinLock( &pCall->lockCall );

    DereferenceBinding( pBinding );

    TRACE( TL_N, TM_Pr, ("-PrRemoveCallFromBinding") );
}

VOID 
PrSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS Status
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS to notify that a previously send operation
    on this packet has been completed.

    It will notify NDISWAN, if packet was a payload packet.

    It will remove the references on the packet and binding added by the PrSendXXX()
    functions.
        
Parameters:

    ProtocolBindingContext:
        A pointer to our binding context.
    
    pNdisPacket:
        Ndis Packet that was send previously.

    Status:
        Status of the send operation.

Return Values:

    None
    
---------------------------------------------------------------------------*/       
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    PPPOE_PACKET* pPacket = NULL;
    USHORT usCode;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrSendComplete($%x,$%x,$%x)",pBinding,pNdisPacket,Status) );

    //
    // Retrieve the related PPPoE packet context from the NDIS packet
    //
    pPacket = PacketGetRelatedPppoePacket( pNdisPacket );
    
    ASSERT( pPacket != NULL );
    
    //
    // Set the completion status for the send to be passed back to
    // NDISWAN when the packet is freed (only for Payload packets)
    //
    PacketSetSendCompletionStatus( pPacket, Status );

    //
    // Remove the reference on the packet added by the sending function
    //
    DereferencePacket( pPacket );

    //
    // Remove the reference on the binding
    //
    DereferenceBinding( pBinding );

    TRACE( TL_V, TM_Pr, ("-PrSendComplete($%x,$%x,$%x)",pBinding,pNdisPacket,Status) );
}

INT 
PrReceivePacket(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called by NDIS when a packet is received over this binding.

    Packet is converted into a PPPoE packet and notified to Miniport so that miniport
    processes it.
    
Parameters:

    ProtocolBindingContext:
        A pointer to our binding context.
        
    Packet:
        An Ndis packet received over this binding.

Return Values:

    The return value represents the number of references NDIS should wait for
    before freeing his copy of the packet, but we will be done by the NDIS packet
    at the end of the function, we always return 0.
    
---------------------------------------------------------------------------*/       
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    PPPOE_PACKET* pPacket = NULL;
    INT nRefCount = 0;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrReceivePacket($%x,$%x)",pBinding,Packet) );

    do
    {
        pPacket = PacketNdis2Pppoe( (PVOID) pBinding,
                                    Packet,
                                    &nRefCount );

        if ( pPacket )
        {

            TRACE( TL_V, TM_Pr, ("PrReceivePacket: Received PPPoE packet=$%x",pPacket) );

            //
            // We have a copy of the packet, insert it into our queue of received packets, 
            // so that it will be consumed by a call to our PrReceiveComplete() function.
            //
            // It will be freed when it is consumed in PrReceiveComplete().
            //
        
            NdisInterlockedInsertTailList( &pBinding->linkPackets,
                                           &pPacket->linkPackets,
                                           &pBinding->lockBinding );
        }
        
    } while ( FALSE );

    TRACE( TL_V, TM_Pr, ("-PrReceivePacket($%x,$%x)",pBinding,Packet) );

    return nRefCount;
}

NDIS_STATUS 
PrBroadcast(
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called by an adapter to broadcast a PADI packet.

    It clones the packet and schedules a send over each binding that's currrently
    active.

    The caller can destroy the packet after return from this function.
    
Parameters:

    pPacket:
        A PPPoE PADI packet ready to be broadcast.

Return Values:

    NDIS_STATUS_SUCCESS:
        At least 1 send operation was scheduled over a binding.

    NDIS_STATUS_FAILURE:
        No sends could be scheduled.
    
---------------------------------------------------------------------------*/       
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    TRACE( TL_N, TM_Pr, ("+PrBroadcast($%x)",pPacket) );

    //
    // Check if we have any bindings
    //
    if ( gl_ulNumBindings == 0 )
    {
        TRACE( TL_N, TM_Pr, ("PrBroadcast($%x): No bindings available",pPacket) );
    
        TRACE( TL_N, TM_Pr, ("-PrBroadcast($%x)=$%x",pPacket,status) );

        return status;
    }

    NdisAcquireSpinLock( &gl_lockProtocol );

    do
    {
        LIST_ENTRY* pHead = NULL;

        //
        // We have to do the same check again, as the first one is to make sure
        // we have allocated the spin lock, and this one is to make sure after we acquired
        // it, we still have some bindings
        //
        if ( gl_ulNumBindings == 0 )
        {
            TRACE( TL_N, TM_Pr, ("PrBroadcast($%x): No bindings available",pPacket) );
    
            break;
        }

        //
        // Get the head of the bindings list
        //
        pHead = gl_linkBindings.Flink;

        //
        // Traverse the bindings list and schedule a PrSend() with a clone of pNdisPacket
        //
        while ( pHead != &gl_linkBindings )
        {
            PPPOE_PACKET* pClone = NULL;
            BINDING* pBinding = (BINDING*) CONTAINING_RECORD( pHead,
                                                              BINDING,
                                                              linkBindings );
            //
            // Do not schedule a send if binding is not bound
            //
            if ( pBinding->stateBinding != BN_stateBound )
            {
                pHead = pHead->Flink;

                continue;
            }

            //
            // Make a clone of the actual packet
            //
            pClone = PacketMakeClone( pPacket );

            if ( pClone != NULL )
            {
                WORKITEM* pWorkItem = NULL;
                PVOID Args[4];

                //
                // Set the source address on the packet to be sent
                //
                PacketSetSrcAddr( pClone, pBinding->LocalAddress );

                //
                // Set the arguements array
                //
                Args[0] = (PVOID) pBinding;
                Args[1] = (PVOID) pClone;

                //
                // Allocate work item
                //
                pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                           ExecBindingWorkItem,
                                           NULL,
                                           Args,
                                           BWT_workPrSend );
                
                if ( pWorkItem != NULL )
                {

                    ReferenceBinding( pBinding, TRUE );

                    ReferencePacket( pClone );
    
                    //
                    // Schedule the send operation
                    //
                    ScheduleWorkItem( pWorkItem );

                    status = NDIS_STATUS_SUCCESS;

                }

                //
                // We can free the packet since we have put a reference for scheduling it
                //
                PacketFree( pClone );
            }

            pHead = pHead->Flink;
        }
            
    } while ( FALSE );

    NdisReleaseSpinLock( &gl_lockProtocol );

    TRACE( TL_N, TM_Pr, ("-PrBroadcast($%x)=$%x",pPacket,status) );

    return status;
}

VOID 
ExecBindingWorkItem(
    IN PVOID Args[4],
    IN UINT workType
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function executes the scheduled work items for the binding.

    
Parameters:

    Args:
        An array of length 4 keeping PVOIDs

    workType:
        Indicates the type of the work to be executed.
        We use this to understand what we should do in this function.

Return Values:

    None
    
---------------------------------------------------------------------------*/       
{
    TRACE( TL_V, TM_Pr, ("+ExecBindingWorkItem") );

    switch( workType )
    {

        case BWT_workPrStartBinds:
            //
            // Tell NDIS to bind our protocol to any interested miniports.
            // If we need to start an outgoing call then kick that off too.
            //
            {
                ULONG_PTR FilterChangeRequest = (ULONG_PTR) Args[0]; 
                BOOLEAN fSetFilters = (BOOLEAN) ( FilterChangeRequest != BN_ResetFiltersForCloseLine );
               
                switch ( FilterChangeRequest )
                {
                     case BN_SetFiltersForMediaDetection:
                        {   
                             //
                             // This is a set default media detection request so complete it
                             //
                             LINE* pLine = (LINE*) Args[1];
                             PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest = (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION) Args[2];

                             PrReEnumerateBindings();

                             ChangePacketFiltersForAdapters( fSetFilters );

                             TpSetDefaultMediaDetectionComplete( pLine, pRequest );
                        }   
   
                        break;
                          
                     case BN_SetFiltersForMakeCall:
                        {
                             //
                             // This is a make call request so schedule the real work item and complete it
                             //
                             CALL* pCall = (CALL*) Args[1];
                             PNDIS_TAPI_MAKE_CALL pRequest = (PNDIS_TAPI_MAKE_CALL) Args[2];
                             WORKITEM* pWorkItem = (WORKITEM*) Args[3];
                             
                             PrReEnumerateBindings();

                             ChangePacketFiltersForAdapters( fSetFilters );

                             TpMakeCallComplete( pCall, pRequest );
   
                             ScheduleWorkItem( pWorkItem );
                        }                          
   
                        break;
   
                     case BN_ResetFiltersForCloseLine:
                        {
                             //
                             // This is a close line request so dereference it
                             //
                             LINE* pLine = (LINE*) Args[1];

                             ChangePacketFiltersForAdapters( fSetFilters );

                             DereferenceLine( pLine );
                        }
   
                        break;

                     default:
                        {
                             //
                             // Unknown request
                             //
                             ASSERT( FALSE );
                        }                          
   
                        break;
                }
            }
            
            break;

        case BWT_workPrSend:
            //
            // Scheduled from PrBroadcast() to send PADI packets
            //
            {
                NDIS_STATUS status;

                status = PrSend( ( BINDING*) Args[0], (PPPOE_PACKET*) Args[1] );

                TRACE( TL_N, TM_Pr, ("ExecBindingWorkItem: BWT_workSend=$%x",status) );
                
            }

            break;

        case BWT_workPrReceiveComplete:

            //
            // Scheduled from PrReceivePacket() if receive loop on the specific binding is not running
            //
            {
                BINDING* pBinding = ( ( BINDING*) Args[0] );

                PrReceiveComplete( pBinding );

                DereferenceBinding( pBinding );
                
            }

            break;
            
        default:

            break;
    }

    TRACE( TL_V, TM_Pr, ("-ExecBindingWorkItem") );
}


NDIS_STATUS
PrReceive(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  MacReceiveContext,
    IN PVOID  HeaderBuffer,
    IN UINT  HeaderBufferSize,
    IN PVOID  LookaheadBuffer,
    IN UINT  LookaheadBufferSize,
    IN UINT  PacketSize
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by NDIS to indicate the receipt of a new packet.

    We check if packet is a PPPoE frame, and if it is not, we just return.

    However if it is then we determine if we have received the whole packet or
    not. If we have received the whole packet, we call PrTransferDataComplete()
    manually, otherwise we initiate the data transfer and return. When transfer 
    is completed PrDataTransferComplete() will be called by NDIS.
    
Parameters:

    ProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 
        
    MacReceiveContext:
        Specifies a context handle that the underlying NIC driver associates with the 
        packet received from the network. This handle is opaque to the protocol, 
        reserved for use by the underlying driver that made the indication, and a 
        required parameter to NdisTransferData. 
        
    HeaderBuffer:
        Points to the base virtual address of a range containing the buffered packet 
        header. The address is valid only within the current call to ProtocolReceive. 

    HeaderBufferSize:
        Specifies the number of bytes in the packet header. 

    LookAheadBuffer:
        Points to the base virtual address of a range that contains 
        LookaheadBufferSize bytes of buffered network packet data. This address is 
        valid only within the current call to ProtocolReceive. 

    LookaheadBufferSize:
        Specifies the number of bytes of network packet data in the lookahead buffer. 
        The indicating driver ensures this number is at least as large as the size it 
        returned for the protocol's preceding call to NdisRequest with 
        OID_GEN_CURRENT_LOOKAHEAD or the size of the packet, whichever is less. 

        If PacketSize is less than or equal to the given LookaheadBufferSize, the 
        kahead buffer contains the entire packet. If the underlying driver made 
        the indication with NdisMIndicateReceivePacket, the lookahead buffer always 
        contains a full network packet. 

    PacketSize:
        Specifies the size, in bytes, of the network packet data. The length of the 
        packet does not include the length of the header. 
        ProtocolReceive determines whether the protocol must call NdisTransferData by 
        comparing this parameter to the given LookaheadBufferSize. 

Return Values:

    NDIS_STATUS_NOT_ACCEPTED:
        The protocol has no use for the indicated packet, that is, it has no current 
        clients interested in the indicated network data. 
        Returning this status quickly for rejected packets yields higher performance 
        for the protocol and the highest possible network I/O throughput for the 
        system as a whole. 

    NDIS_STATUS_SUCCESS:
        ProtocolReceive has processed the header information and accepted the packet, 
        that is, it has copied the indicated network data from the header and 
        lookahead buffers and, possibly, called NdisTransferData to retrieve the 
        remaining data if less than a full network packet was indicated. 
    
---------------------------------------------------------------------------*/       
{
    NDIS_STATUS status = NDIS_STATUS_NOT_ACCEPTED;
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    PPPOE_PACKET *pPacket = NULL;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrReceive") );

    //
    // Check if the packet is a PPPoE frame or not
    //
    if ( !PacketFastIsPPPoE( (CHAR*) HeaderBuffer, HeaderBufferSize ) ) 
    {
        TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );
        
        return status;
    }

   //
   // Make sure packet is not too large
   //
   if ( HeaderBufferSize + PacketSize > PPPOE_PACKET_BUFFER_SIZE )
   {
      TRACE( TL_A, TM_Pr, ("PrReceive: Packet too large" ) );

        TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );
        
        return status;
    }

    //
    // Let's create our PPPoE packet to keep the copy of the received packet
    //
    pPacket = PacketCreateSimple();

    if ( pPacket == NULL )
    {
        TRACE( TL_A, TM_Pr, ("PrReceive: Could not allocate context to copy the packet") );

        TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );
        
        return status;
    }

    //
    // See if the packet indicated is complete, or not.
    // If it is not the complete packet then we should call NdisTransferData(),
    // otherwise we can do the copy here
    //
    if ( LookaheadBufferSize >= PacketSize )
    {
        TRACE( TL_V, TM_Pr, ("PrReceive: Complete packet indicated, transferring data") );

        //
        // First copy the header portion
        //
        NdisMoveMemory( pPacket->pHeader,
                        HeaderBuffer,
                        HeaderBufferSize );

        //
        // Packet is complete, so let's copy whole data to our own copy
        //
        TdiCopyLookaheadData( pPacket->pHeader + HeaderBufferSize, 
                              (CHAR*) LookaheadBuffer,
                              (ULONG) PacketSize,
                              (ULONG) 0 );

        //
        // Let's call PrTransferDataComplete() manually now.
        //
        PrTransferDataComplete( pBinding,
                                pPacket->pNdisPacket,
                                NDIS_STATUS_SUCCESS,
                                PacketSize );
                                
    }
    else
    {
        UINT nBytesTransferred = 0;
        
        TRACE( TL_V, TM_Pr, ("PrReceive: Partial packet indicated, transferring data") );

      //
      // Mark the packet for incomplete indication
      //
      pPacket->ulFlags |= PCBF_PacketIndicatedIncomplete;
      
        //
        // First copy the header to the end of the packet
      //
        // Note that HeaderBufferSize MUST be equal to ETHERNET_HEADER_LENGTH and
        // this is ensured in PacketIsFastPPPoE().
        //
        NdisMoveMemory( pPacket->pHeader + (PPPOE_PACKET_BUFFER_SIZE - ETHERNET_HEADER_LENGTH),
                            HeaderBuffer,
                         HeaderBufferSize );

        //
        // Lookahead buffer does not contain all the packet, we should call NdisTransferData()
        // to receive the full packet
        //
        NdisTransferData( &status,
                          pBinding->NdisBindingHandle,
                          MacReceiveContext,
                          0,
                          PacketSize,
                          pPacket->pNdisPacket,
                          &nBytesTransferred );
                          
        if ( status != NDIS_STATUS_PENDING )
        {
            //
            // Call PrTransferDataComplete() manually if transfer data completed
            // synchronously
            //
            PrTransferDataComplete( pBinding,
                                    pPacket->pNdisPacket,
                                    status,
                                    nBytesTransferred );
    
        }
    }


    TRACE( TL_V, TM_Pr, ("-PrReceive=$%x",status) );

    return NDIS_STATUS_SUCCESS;
}

    
VOID
PrTransferDataComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN PNDIS_PACKET  Packet,
    IN NDIS_STATUS  Status,
    IN UINT  BytesTransferred
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to post process a received packet when whole data
    is copied into the packet context.

    It can be called by NDIS, or it can be called manually from inside PrReceive()
    if the indicated packet is a whole packet.

    If the status is succesfull, it will insert the packet to the end of the
    bindings received packets queue, otherwise it will clean up our copy of
    NDIS packet and return.
    
Parameters:

    ProtocolBindingContext 
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 

    Packet 
        Points to the protocol-allocated packet descriptor the driver originally 
        passed to NdisTransferData. 
        
    Status 
        Specifies the final status of the transfer-data operation. 
    
    BytesTransferred 
        Specifies the number of bytes of data that the NIC driver transferred into 
        the buffers mapped by buffer descriptors chained to the packet descriptor at 
        Packet. The protocol uses this value to determine whether the miniport 
        supplied all the requested data for the originally indicated network packet. 

Return Values:

    None
    
---------------------------------------------------------------------------*/
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    PPPOE_PACKET* pPacket = NULL;

    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_V, TM_Pr, ("+PrTransferDataComplete") );

    do
    {
        //
        // Retrieve the related PPPoE packet first
        //
        pPacket = PacketGetRelatedPppoePacket( Packet );
    
        //
        // Make sure the data transfer suceeded
        //
        if ( Status != NDIS_STATUS_SUCCESS )
        {
            //
            // Transfer of data to our copy of packet failed, so clean up our packet
            //
            PacketFree( pPacket );

            break;
        }

      //
      // Rearrange the data in the packet if the packet was indicated incomplete
      //
      if ( pPacket->ulFlags & PCBF_PacketIndicatedIncomplete )
      {
         CHAR tempHeader[ ETHERNET_HEADER_LENGTH ];

         CHAR* srcPos = pPacket->pHeader + BytesTransferred;

         //
         // Make a copy of the header stored at the end of the packet
         //
         NdisMoveMemory( tempHeader,
                         pPacket->pHeader + (PPPOE_PACKET_BUFFER_SIZE - ETHERNET_HEADER_LENGTH),
                         ETHERNET_HEADER_LENGTH );

         //
         // Move the contents of the packet appropriately to make room
         // for the header (slip contents by ETHERNET_HEADER_LENGTH)
         //
         while ( BytesTransferred > 0 )
         {
            #define TEMP_BUFFER_SIZE 100
            CHAR tempBuffer[ TEMP_BUFFER_SIZE ];

            UINT size = (BytesTransferred < TEMP_BUFFER_SIZE) ? 
                        BytesTransferred : 
                        TEMP_BUFFER_SIZE;

            srcPos -= size;

            NdisMoveMemory( tempBuffer,
                            srcPos,
                            size );

            NdisMoveMemory( srcPos + ETHERNET_HEADER_LENGTH,
                            tempBuffer,
                            size );

            BytesTransferred -= size;
         }

         //
         // Copy the header to the correct position in the packet
         //
         NdisMoveMemory( pPacket->pHeader,
                         tempHeader,
                         ETHERNET_HEADER_LENGTH );

         //
         // Clear the incomplete indication flag
         //
         pPacket->ulFlags &= ~PCBF_PacketIndicatedIncomplete;
      }

        //
        // Data transfer succeeded, insert into our queue of received packets, so that it will
        // be consumed by a call to our PrReceiveComplete() function
        //
        NdisInterlockedInsertTailList( &pBinding->linkPackets,
                                       &pPacket->linkPackets,
                                       &pBinding->lockBinding );
    
    } while ( FALSE );
    
    TRACE( TL_V, TM_Pr, ("-PrTransferDataComplete=$%x",Status) );
}

VOID
PrReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to perform post processing of received packets
    indicated previously. Underlying NIC will call it when it is not busy.

    We need to serialize the indication of packets to the miniport, since this
    is of vital importance for PPP frames. To achieve this, we use the lock 
    protected flag of binding (fRecvLoopRunning).

    When this function is called, it will return immediately if this flag is 
    already set. 

    If flag is not set, then it will set this flag and start processing packets
    from the received queue, and indicate all packets to miniport one by one
    untill all the queue is drained. Then it will reset the flag and return.
    
Parameters:

    ProtocolBindingContext 
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;
    LIST_ENTRY* pLink = NULL;
    PPPOE_PACKET* pPacket = NULL;
    BOOLEAN fStartRecvLoop = FALSE;

    ASSERT( VALIDATE_BINDING( pBinding ) );
    
    TRACE( TL_V, TM_Pr, ("+PrReceiveComplete") );

    NdisAcquireSpinLock( &pBinding->lockBinding );

    //
    // See if recv loop is already running
    //
    if ( !pBinding->fRecvLoopRunning )
    {
        //
        // Indicate the recv loop has started to run
        //
        pBinding->fRecvLoopRunning = TRUE;

        //
        // Now consume these packet's
        //
        while ( !IsListEmpty( &pBinding->linkPackets ) )
        {
            pLink = RemoveHeadList( &pBinding->linkPackets );

            NdisReleaseSpinLock( &pBinding->lockBinding );
    
            pPacket = (PPPOE_PACKET*) CONTAINING_RECORD( pLink, PPPOE_PACKET, linkPackets );

            InitializeListHead( &pPacket->linkPackets );
    
            if ( PacketInitializeFromReceived( pPacket ) == NDIS_STATUS_SUCCESS )
            {   
                //
                // Indicate the packet to miniport
                //
                MpRecvPacket( pBinding, pPacket );
            }
    
            //
            // Free the packet since we are done with it
            //
            PacketFree( pPacket );

            //
            // Acquire the lock again
            //
            NdisAcquireSpinLock( &pBinding->lockBinding );
        }

        //
        // The queue is drained, so stop the recv loop
        //
        pBinding->fRecvLoopRunning = FALSE;

    }

    NdisReleaseSpinLock( &pBinding->lockBinding );

    TRACE( TL_V, TM_Pr, ("-PrReceiveComplete") );
}


ULONG
PrQueryMaxFrameSize()
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by the miniport to retrieve the current minimum
    of max frame sizes of the bindings, since this is the value passed to
    NDISWAN in an OID_WAN_GET_INFO query as the MaxFrameSize.

    We adjust the max frame size considering the PPPoE and Ethernet headers.
    
Parameters:

    None
    
Return Values:

    Minimum of max frame sizes
    
---------------------------------------------------------------------------*/   
{
    ULONG ulMaxFrameSize = gl_ulMaxFrameSize;

    if ( ulMaxFrameSize == 0 )
    {
        ulMaxFrameSize = PACKET_PPP_PAYLOAD_MAX_LENGTH;
    }
    else
    {
        ulMaxFrameSize = ulMaxFrameSize - ( PPPOE_PACKET_HEADER_LENGTH + PPP_MAX_HEADER_LENGTH);
    }
    
    return ulMaxFrameSize;
}

NDIS_STATUS
PrSend(
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to transmit a PPPoE packet.

    The caller must have referenced the packet and binding before calling this
    function. Then the caller can forget about the references, everything will 
    be handled by the protocol. If send operation complets synchrnously then
    the references are removed in the function, otherwise PrSendComplete()
    will be called and references will be removed then.
        
Parameters:

    pBinding _ Binding to send the packet over.

    pPacket _ PPPoE packet to be transmitted.
    
Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_FAILURE
    NDIS_STATUS_XXXXXXX
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_V, TM_Pr, ("+PrSend") );

    //
    // Make sure we are bound before sending the packet.
    //
    // Note: We do not need to acquire the lock here since NDIS should prevent
    //       a crash even if we are unbound, and we already have a reference 
    //       on the binding, so this is not a really strict check..
    //
    if ( pBinding->stateBinding == BN_stateBound )
    {
        //
        // Make sure we are sending a packet not exceeding the max frame size
        // of the underlying NIC
        //
        if ( pBinding->ulMaxFrameSize + ETHERNET_HEADER_LENGTH >= 
            (ULONG) ( PacketGetLength( pPacket ) + PPPOE_PACKET_HEADER_LENGTH ) )
        {
            NdisSend( &status,
                      pBinding->NdisBindingHandle,
                      PacketGetNdisPacket( pPacket ) );
        }
    }

    if ( status != NDIS_STATUS_PENDING )
    {
        //
        // NdisSend() completed synchronously so call PrSendComplete()
        // manually here.
        //
        PrSendComplete( pBinding, PacketGetNdisPacket( pPacket ), status );

    }

    TRACE( TL_V, TM_Pr, ("-PrSend=$%x",status) );

    return status;
}

VOID
PrStatus(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer, 
    IN UINT StatusBufferSize
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    ProtocolStatus is a required driver function that handles status-change 
    notifications raised by an underlying connectionless NIC driver or by NDIS. 

    In this driver, we only use this function to receive Media disconnect
    notifications to disconnect the active calls on that NIC.
        
Parameters:

    ProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which the 
        protocol driver maintains per-binding runtime state. The driver supplied this 
        handle when it called NdisOpenAdapter. 
    
    GeneralStatus:
        Indicates the general status code, either raised by NDIS or propagated from 
        the underlying driver's call to NdisMIndicateStatus. 

    StatusBuffer:
        Points to a buffer containing medium-specific data that depends on the value 
        of GeneralStatus. 

        For example, if the GeneralStatus argument is NDIS_STATUS_RING_STATUS, this 
        parameter points to a ULONG-sized bitmask and StatusBufferSize is four. As 
        another example, if GeneralStatus is NDIS_STATUS_WAN_LINE_UP, this parameter 
        points to an NDIS_WAN_LINE_UP structure and StatusBufferSize is sizeof(
        NDIS_STATUS_WAN_LINE_UP). 
        
        For some NDIS_STATUS_XXX values, this pointer is NULL and StatusBufferSize is 
        set to zero. 

    StatusBufferSize:
        Specifies the number of bytes at StatusBuffer. 
    
Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    BINDING* pBinding = (BINDING*) ProtocolBindingContext;

    ASSERT( VALIDATE_BINDING( pBinding ) );

    TRACE( TL_N, TM_Pr, ("+PrStatus") );

    switch ( GeneralStatus )
    {
        case NDIS_STATUS_MEDIA_DISCONNECT:

            //
            // If the underlying media is disconnected, notify miniport of this event.
            // It will appear to the miniport as if the NIC is removed, so it will drop all the 
            // active calls
            //
            TRACE( TL_N, TM_Pr, ("PrStatus: Notifying miniport of media disconnect event") );

            MpNotifyBindingRemoval( pBinding );

            break;

    }
    
    TRACE( TL_N, TM_Pr, ("-PrStatus") );
}

NDIS_STATUS
PrPnPEvent(
    IN NDIS_HANDLE hProtocolBindingContext,
    IN PNET_PNP_EVENT pNetPnPEvent
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
    ProtocolPnPEvent is a required function in any protocol driver to support 
    Plug and Play and/or Power Management. NDIS calls ProtocolPnPEvent to 
    indicate a Plug and Play event or a Power Management event to a protocol 
    bound to a NIC.

    NDIS calls ProtocolPnPEvent to notify a protocol bound to a network NIC that 
    the operating system has issued a Plug and Play or Power Management event to 
    the device object representing the NIC. NDIS calls the ProtocolPnPEvent 
    function of each protocol bound to the NIC.

    The NET_PNP_EVENT structure passed to ProtocolPnPEvent describes the Plug and 
    Play or Power Management event. ProtocolPnPEvent interprets two basic pieces 
    of information in the NET_PNP_EVENT structure: 

    A NetEvent code that describes the Plug and Play or Power Management event. 
    Event-specific information (for example, for a NetEventSetPower, the device 
    power state to which the device is transitioning). 
    The protocol should save the NetPnPEvent pointer. This pointer is a required 
    input parameter to NdisCompletePnPEvent, which the protocol must subsequently 
    call if ProtocolPnPEvent returns NDIS_STATUS_PENDING.

Parameters

    hProtocolBindingContext:
        Specifies the handle to a protocol-allocated context area in which this 
        driver maintains per-binding runtime state. The protocol supplied this handle 
        when it called NdisOpenAdapter. A NetEventXxx indicated on a NULL 
        ProtocolBindingContext pertains to all network bindings. NetEventBindList and 
        NetEventBindsComplete are always indicated on a NULL ProtocolBindingContext. 
        NetEventReconfigure can be indicated on a particular ProtocolBindingContext 
        or a NULL ProtocolBindingContext. 

    pNetPnPEvent:
        Points to a NET_PNP_EVENT structure, which describes the Plug and Play event 
        or Power Management event being indicated to the protocol driver. 

Return Value

    NDIS_STATUS_SUCCESS:
        The protocol successfully handled the indicated Plug and Play or Power 
        Management event. The meaning of this status code depends on the NetEvent 
        code in the buffered NET_PNP_EVENT structure at NetPnPEvent.

    NDIS_STATUS_PENDING 
        The protocol will return its response to the indicated event asynchronously 
        with a call to NdisCompletePnPEvent. 

    NDIS_STATUS_RESOURCES 
        The protocol could not obtain the necessary system resources to satisfy the 
        indicated Plug and Play or Power Management event. 

    NDIS_STATUS_NOT_SUPPORTED 
        A legacy (non-PnP-aware) protocol can return this status in response to a 
        NetEventSetPower to indicate that NDIS should unbind the it from the NIC. 

    NDIS_STATUS_FAILURE 
        The protocol failed the indicated Plug and Play or Power Management event. 
        The meaning of this status code depends on the NetEvent code in the buffered 
        NET_PNP_EVENT structure at NetPnPEvent.

---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_NOT_SUPPORTED;
    BINDING *pBinding = (BINDING*) hProtocolBindingContext;

    TRACE( TL_N, TM_Pr, ("+PrPnpEvent") );

    switch ( pNetPnPEvent->NetEvent ) 
    {
    
        case NetEventQueryPower:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventQueryPower") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }

        case NetEventQueryRemoveDevice:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventQueryRemoveDevice") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
        
        case NetEventCancelRemoveDevice:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventCancelRemoveDevice") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        case NetEventReconfigure:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventReconfigure") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        case NetEventBindsComplete:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventBindsComplete") );
            
            status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        case NetEventPnPCapabilities:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventPnPCapabilities") );

            status = NDIS_STATUS_SUCCESS;
            break;
        }
    
        case NetEventBindList:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventBindList") );

            status = NDIS_STATUS_SUCCESS;
            break;
        }
        
        case NetEventSetPower:
        {
            BOOLEAN fWakeUp = FALSE;
            BOOLEAN fSleep  = FALSE;
            
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower") );

            NdisAcquireSpinLock( &pBinding->lockBinding );

            if ( *( (NDIS_DEVICE_POWER_STATE*) pNetPnPEvent->Buffer ) == NdisDeviceStateD0 )
            {
                if ( pBinding->stateBinding == BN_stateSleeping )
                {
                    TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower - Wake up request") );

                    fWakeUp = TRUE;

                    pBinding->stateBinding = BN_stateBound;

                }

            }
            else if ( *( (NDIS_DEVICE_POWER_STATE*) pNetPnPEvent->Buffer ) > NdisDeviceStateD0 )
            {
                if ( pBinding->stateBinding == BN_stateBound )
                {
                    TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower - Sleep request") );
                    
                    fSleep = TRUE;

                    pBinding->stateBinding = BN_stateSleepPending;
                }

            }

            NdisReleaseSpinLock( &pBinding->lockBinding );

            if ( fSleep )
            {
                //
                // Since this NIC is going to sleep, drop all the calls on it
                //
                MpNotifyBindingRemoval( pBinding );

                //
                // Wait for pending operations to be completed
                //
                TRACE( TL_N, TM_Pr, ("PrPnpEvent: NetEventSetPower - Waiting for pending operations to be completed") );

                NdisAcquireSpinLock( &pBinding->lockBinding );
                
                while ( pBinding->lRef > 1 )
                {
                    NdisReleaseSpinLock( &pBinding->lockBinding );

                    NdisMSleep( 10000 );                

                    NdisAcquireSpinLock( &pBinding->lockBinding );
                }

                pBinding->stateBinding = BN_stateSleeping;

                NdisReleaseSpinLock( &pBinding->lockBinding );
            }

            status = NDIS_STATUS_SUCCESS;
            break;
        }
        
        default:
        {
            TRACE( TL_N, TM_Pr, ("PrPnpEvent: Unknown Event - %x", pNetPnPEvent->NetEvent) );

            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    
    }

    TRACE( TL_N, TM_Pr, ("-PrPnpEvent=$%x", status) );

    return status;
}

VOID
PrReEnumerateBindings(
    VOID
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:
    
    PrReEnumerateBindings causes NDIS to send bind notifications to the pppoe 
    protocol section for each miniport that it needs to bind to.  It is called 
    when a tapi client is interested in either making an outgoing call or 
    listening for an incoming call.  It is expected that when this function
    returns all of the bindings between the protocol and underlying miniports
    will be finished!

   
Parameters

    None
    
Return Value

    None
---------------------------------------------------------------------------*/   
{
    TRACE( TL_N, TM_Pr, ("+PrReEnumerateBindings") );

    NdisAcquireSpinLock( &gl_lockProtocol );

    gl_fBindProtocol = TRUE;

    NdisReleaseSpinLock( &gl_lockProtocol );

    NdisReEnumerateProtocolBindings(gl_hNdisProtocolHandle);

    TRACE( TL_N, TM_Pr, ("-PrReEnumerateBindings") );
}

VOID
ChangePacketFiltersForAdapters(
   BOOLEAN fSet
   )
{
    LIST_ENTRY* pLink = NULL;

    TRACE( TL_N, TM_Pr, ("+ChangePacketFiltersForAdapters") );
    
    NdisAcquireSpinLock( &gl_lockProtocol );

    gl_fSetPacketFiltersAtBind = fSet;

    pLink = gl_linkBindings.Flink;

    //
    // See if we have any bindings
    //
    if ( pLink != &gl_linkBindings )
    {
        
        BINDING* pBinding = NULL;

        TRACE( TL_N, TM_Pr, ("ChangePacketFiltersForAdapters: %s packet filters", ( fSet ) ? "Setting" : "Resetting") );

        //
        // First reference the bindings in the list and mark their 
        // BNBF_ChangePacketFilterInProgress bit
        //
        while ( pLink != &gl_linkBindings )
        {
            //
            // We have at least one binding, so walk thru the list
            // and reference them
            //
            pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

            NdisAcquireSpinLock( &pBinding->lockBinding );
        
            if ( pBinding->stateBinding == BN_stateBound )
            {
               //
               // If the state of the binding is BN_stateBound then 
               // set the BNBF_PacketFilterChangeInProgress bit, 
               // reference 
               // the binding.
               //
               pBinding->ulBindingFlags |= BNBF_PacketFilterChangeInProgress;

               ReferenceBinding( pBinding, FALSE );
            }

            NdisReleaseSpinLock( &pBinding->lockBinding );

           //
           // Iterate to the next binding
           //
           pLink = pLink->Flink;
        }

        //
        // Now make a second pass and shoot the SetPacket filter request for
        // all the marked items
        //
        pLink = gl_linkBindings.Flink;
        
        while ( pLink != &gl_linkBindings )
        {
           //
           // We have at least one binding, so walk thru the list
           // and reference them
           //
           pBinding = ((BINDING*) CONTAINING_RECORD( pLink, BINDING, linkBindings ));

           //
           // Advance to the next item
           //
           pLink = pLink->Flink;

           NdisReleaseSpinLock( &gl_lockProtocol );

           //
           // If we are just marking, check the state of the binding and mark it
           // by setting the BNBF_SetPacketFilterInProgress bit
           //
           if ( pBinding->ulBindingFlags & BNBF_PacketFilterChangeInProgress )
           {
              //
              // This binding is marked by the previous loop so change the filter
              // for this binding
              //
              PrSetPacketFilterForAdapter( pBinding, fSet );

              //
              // Reset what was done in the first pass
              //
              pBinding->ulBindingFlags &= ~BNBF_PacketFilterChangeInProgress;

              DereferenceBinding( pBinding );

           }

           NdisAcquireSpinLock( &gl_lockProtocol );

        }

    }

    NdisReleaseSpinLock( &gl_lockProtocol );

    TRACE( TL_N, TM_Pr, ("-ChangePacketFiltersForAdapters") );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\timer.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.c
// RAS L2TP WAN mini-port/call-manager driver
// Timer management routines
//
// 01/07/97 Steve Cobb


#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event );

VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime );

VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ )

    // Initializes caller's timer queue context 'pTimerQ'.
    //
{
    TRACE( TL_N, TM_Time, ( "TqInit" ) );

    InitializeListHead( &pTimerQ->listItems );
    NdisAllocateSpinLock( &pTimerQ->lock );
    NdisInitializeTimer( &pTimerQ->timer, TimerEvent, pTimerQ );
    pTimerQ->pHandler = NULL;
    pTimerQ->fTerminating = FALSE;
    pTimerQ->ulTag = MTAG_TIMERQ;
}


VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem )

    // Initializes caller's timer queue item, 'pItem'.  This should be called
    // before passing 'pItem' to any other TimerQ routine.
    //
{
    InitializeListHead( &pItem->linkItems );
}


VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext )

    // Terminates timer queue 'pTimerQ'.  Each scheduled item is called back
    // with TE_Terminate.  Caller's 'pHandler' is called with 'pTimerQ' and
    // 'pContext' so the 'pTimerQ' can be freed, if necessary.  Caller's
    // 'pTimerQ' must remain accessible until the 'pHandler' callback occurs,
    // which might be after this routine returns.
    //
{
    BOOLEAN fCancelled;
    LIST_ENTRY list;
    LIST_ENTRY* pLink;

    TRACE( TL_N, TM_Time, ( "TqTerm" ) );

    InitializeListHead( &list );

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pTimerQ->fTerminating = TRUE;

        // Stop the timer.
        //
        NdisCancelTimer( &pTimerQ->timer, &fCancelled );
        TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

        if (!fCancelled && !IsListEmpty( &pTimerQ->listItems ))
        {
            // No event was cancelled but the list of events is not empty.
            // This means the timer has fired, but our internal handler has
            // not yet been called to process it, though it eventually will
            // be.  The internal handler must be the one to call the terminate
            // complete in this case, because there is no way for it to know
            // it cannot reference 'pTimerQ'.  Indicate this to the handler by
            // filling in the termination handler.
            //
            TRACE( TL_A, TM_Time, ( "Mid-expire Q" ) );
            pTimerQ->pHandler = pHandler;
            pTimerQ->pContext = pContext;
            pHandler = NULL;
        }

        // Move the scheduled events to a temporary list, marking them all
        // "not on queue" so any attempt by user to cancel the item will be
        // ignored.
        //
        while (!IsListEmpty( &pTimerQ->listItems ))
        {
            pLink = RemoveHeadList( &pTimerQ->listItems );
            InsertTailList( &list, pLink );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    // Must be careful here.  If 'pHandler' was set NULL above, 'pTimerQ' must
    // not be referenced in the rest of this routine.
    //
    // Call user's "terminate" event handler for each removed item.
    //
    while (!IsListEmpty( &list ))
    {
        TIMERQITEM* pItem;

        pLink = RemoveHeadList( &list );
        InitializeListHead( pLink );
        pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
        TRACE( TL_I, TM_Time,
            ( "Flush TQI=$%p, handler=$%p", pItem, pItem->pHandler ) );
        pItem->pHandler( pItem, pItem->pContext, TE_Terminate );
    }

    // Call user's "terminate complete" handler, if it's still our job.
    //
    if (pHandler)
    {
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pContext );
    }
}


VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext )

    // Schedule new timer event 'pNewItem' on timer queue 'pTimerQ'.  When the
    // event occurs in 'ulTimeoutMs' milliseconds, the 'pHandler' routine is
    // called with arguments 'pNewItem', 'pContext', and TE_Expired.  If the
    // item is cancelled or the queue terminated 'pHandler' is called as above
    // but with TE_Cancel or TE_Terminate as appropriate.
    //
{
    TRACE( TL_N, TM_Time, ( "TqSchedItem(ms=%d)", ulTimeoutMs ) );

    pNewItem->pHandler = pHandler;
    pNewItem->pContext = pContext;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        LIST_ENTRY* pLink;
        LARGE_INTEGER lrgTime;

        ASSERT( pNewItem->linkItems.Flink == &pNewItem->linkItems );

        // The system time at which the timeout will occur is stored.
        //
        NdisGetCurrentSystemTime( &lrgTime );
        pNewItem->llExpireTime =
            lrgTime.QuadPart + (((LONGLONG )ulTimeoutMs) * 10000);

        // Walk the list of timer items looking for the first item that will
        // expire before the new item.  Do it backwards so the likely case of
        // many timeouts with roughly the same interval is handled
        // efficiently.
        //
        for (pLink = pTimerQ->listItems.Blink;
             pLink != &pTimerQ->listItems;
             pLink = pLink->Blink )
        {
            TIMERQITEM* pItem;

            pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );

            if (pItem->llExpireTime < pNewItem->llExpireTime)
            {
                break;
            }
        }

        // Link the new item into the timer queue after the found item (or
        // after the head if none was found).
        //
        InsertAfter( &pNewItem->linkItems, pLink );

        if (pTimerQ->listItems.Flink == &pNewItem->linkItems)
        {
            // The new item expires before all other items so need to re-set
            // the NDIS timer.
            //
            SetTimer( pTimerQ, lrgTime.QuadPart );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );
}


BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Cancel', or nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was cancelled, false if it not, i.e. it was
    // not on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqCancelItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Cancel );
}


BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'TE_Expire', or do nothing if 'pItem' is
    // NULL.
    //
    // Returns true if the timer was expired, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqExpireItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Expire );
}


BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ', or do
    // nothing if 'pItem' is NULL.
    //
    // Returns true if the timer was terminated, false if it not, i.e. it was not
    // on the queue, possibly because it expired already.
    //
{
    TRACE( TL_N, TM_Time, ( "TqTermItem" ) );
    return RemoveTqi( pTimerQ, pItem, TE_Terminate );
}


#if DBG
CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event )

    // Debug utility to convert timer event coode 'event' to a corresponding
    // display string.
    //
{
    static CHAR* aszEvent[ 3 ] =
    {
        "expire",
        "cancel",
        "terminate"
    };

    return aszEvent[ (ULONG )event ];
}
#endif


//-----------------------------------------------------------------------------
// Timer utility routines (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
RemoveTqi(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem,
    IN TIMERQEVENT event )

    // Remove scheduled timer event 'pItem' from timer queue 'pTimerQ' and
    // call user's handler with event 'event'.  The 'TE_Expire' event handler
    // is not called directly, but rescheduled with a 0 timeout so it occurs
    // immediately, but at DPC when no locks are held just like the original
    // timer had fired..
    //
    // Returns true if the item was on the queue, false otherwise.
    //
{
    BOOLEAN fFirst;
    LIST_ENTRY* pLink;

    if (!pItem)
    {
        TRACE( TL_N, TM_Time, ( "NULL pTqi" ) );
        return FALSE;
    }

    pLink = &pItem->linkItems;

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        if (pItem->linkItems.Flink == &pItem->linkItems
            || pTimerQ->fTerminating)
        {
            // The item is not on the queue.  Another operation may have
            // already dequeued it, but may not yet have called user's
            // handler.
            //
            TRACE( TL_N, TM_Time, ( "Not scheduled" ) );
            NdisReleaseSpinLock( &pTimerQ->lock );
            return FALSE;
        }

        fFirst = (pLink == pTimerQ->listItems.Flink);
        if (fFirst)
        {
            BOOLEAN fCancelled;

            // Cancelling first item on list, so cancel the NDIS timer.
            //
            NdisCancelTimer( &pTimerQ->timer, &fCancelled );
            TRACE( TL_N, TM_Time, ( "NdisCancelTimer" ) );

            if (!fCancelled)
            {
                // Too late.  The item has expired already but has not yet
                // been removed from the list by the internal handler.
                //
                TRACE( TL_A, TM_Time, ( "Mid-expire e=%d $%p($%p)",
                    event, pItem->pHandler, pItem->pContext ) );
                NdisReleaseSpinLock( &pTimerQ->lock );
                return FALSE;
            }
        }

        // Un-schedule the event and mark the item descriptor "off queue", so
        // any later attempt to cancel will do nothing.
        //
        RemoveEntryList( pLink );
        InitializeListHead( pLink );

        if (fFirst)
        {
            // Re-set the NDIS timer to reflect the timeout of the new first
            // item, if any.
            //
            SetTimer( pTimerQ, 0 );
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (event == TE_Expire)
    {
        TimerQScheduleItem(
            pTimerQ, pItem, 0, pItem->pHandler, pItem->pContext );
    }
    else
    {
        // Call user's event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, event );
    }

    return TRUE;
}


VOID
SetTimer(
    IN TIMERQ* pTimerQ,
    IN LONGLONG llCurrentTime )

    // Sets the NDIS timer to expire when the timeout of the first link, if
    // any, in the timer queue 'pTimerQ' occurs.  Any previously set timeout
    // is "overwritten".  'LlCurrentTime' is the current system time, if
    // known, or 0 if not.
    //
    // IMPORTANT: Caller must hold the TIMERQ lock.
    //
{
    LIST_ENTRY* pFirstLink;
    TIMERQITEM* pFirstItem;
    LONGLONG llTimeoutMs;
    ULONG ulTimeoutMs;

    if (IsListEmpty( &pTimerQ->listItems ))
    {
        return;
    }

    pFirstLink = pTimerQ->listItems.Flink;
    pFirstItem = CONTAINING_RECORD( pFirstLink, TIMERQITEM, linkItems );

    if (llCurrentTime == 0)
    {
        LARGE_INTEGER lrgTime;

        NdisGetCurrentSystemTime( &lrgTime );
        llCurrentTime = lrgTime.QuadPart;
    }

    llTimeoutMs = (pFirstItem->llExpireTime - llCurrentTime) / 10000;
    if (llTimeoutMs <= 0)
    {
        // The timeout interval is negative, i.e. it's already passed.  Set it
        // to zero so it is triggered immediately.
        //
        ulTimeoutMs = 0;
    }
    else
    {
        // The timeout interval is in the future.
        //
        ASSERT( ((LARGE_INTEGER* )&llTimeoutMs)->HighPart == 0 );
        ulTimeoutMs = ((LARGE_INTEGER* )&llTimeoutMs)->LowPart;
    }

    NdisSetTimer( &pTimerQ->timer, ulTimeoutMs );
    TRACE( TL_N, TM_Time, ( "NdisSetTimer(%dms)", ulTimeoutMs ) );
}


VOID
TimerEvent(
    IN PVOID SystemSpecific1,
    IN PVOID FunctionContext,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3 )

    // NDIS_TIMER_FUNCTION called when a timer expires.
    //
{
    TIMERQ* pTimerQ;
    LIST_ENTRY* pLink;
    TIMERQITEM* pItem;
    PTIMERQTERMINATECOMPLETE pHandler;

    TRACE( TL_N, TM_Time, ( "TimerEvent" ) );

    pTimerQ = (TIMERQ* )FunctionContext;
    if (!pTimerQ || pTimerQ->ulTag != MTAG_TIMERQ)
    {
        // Should not happen.
        //
        TRACE( TL_A, TM_Time, ( "Not TIMERQ?" ) );
        return;
    }

    NdisAcquireSpinLock( &pTimerQ->lock );
    {
        pHandler = pTimerQ->pHandler;
        if (!pHandler)
        {
            // The termination handler is not set, so proceed normally.
            // Remove the first event item, make it un-cancel-able, and re-set
            // the timer for the next event.
            //
            if (IsListEmpty( &pTimerQ->listItems ))
            {
                // Should not happen (but does sometimes on MP Alpha?).
                //
                TRACE( TL_A, TM_Time, ( "No item queued?" ) );
                pItem = NULL;
            }
            else
            {
                pLink = RemoveHeadList( &pTimerQ->listItems );
                InitializeListHead( pLink );
                pItem = CONTAINING_RECORD( pLink, TIMERQITEM, linkItems );
                SetTimer( pTimerQ, 0 );
            }
        }
    }
    NdisReleaseSpinLock( &pTimerQ->lock );

    if (pHandler)
    {
        // The termination handler was set meaning the timer queue has been
        // terminated between this event firing and this handler being called.
        // That means we are the one who calls user's termination handler.
        // 'pTimerQ' must not be referenced after that call.
        //
        TRACE( TL_A, TM_Time, ( "Mid-event case handled" ) );
        pTimerQ->ulTag = MTAG_FREED;
        pHandler( pTimerQ, pTimerQ->pContext );
        return;
    }

    if (pItem)
    {
        // Call user's "expire" event handler.
        //
        pItem->pHandler( pItem, pItem->pContext, TE_Expire );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\timer.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// timer.h
// RAS L2TP WAN mini-port/call-manager driver
// Timer management header
//
// 01/07/97 Steve Cobb
//
// This interface encapsulates the queuing of multiple timer events onto a
// single NDIS timer.


#ifndef _TIMER_H_
#define _TIMER_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _TIMERQ TIMERQ;
typedef struct _TIMERQITEM TIMERQITEM;
typedef enum _TIMERQEVENT TIMERQEVENT;


// Timer queue event handler.  'PTqi' and 'pContext' are the timer event
// descriptor and user context passed to TimerQScheduleItem.  'Event' is the
// timer event code indicating whether the timer expired, was cancelled, or
// the queue was terminated.
//
// The "cancel" event is never generated internally, but only by a user call
// to TimerQCancelItem, thus user may require specific locks be held for
// "cancel" events.  User cannot require than specific locks be held for
// "expire" or "terminate" events as these may be generated internally.  User
// should pay attention to the return codes of TimerQCancelItem and
// TimerQTerminateItem calls, as it will occassionally be impossible to stop
// an "expire" event that has not yet been processed from occurring.
//
typedef
VOID
(*PTIMERQEVENT)(
    IN TIMERQITEM* pTqi,
    IN VOID* pContext,
    IN TIMERQEVENT event );

// Timer queue termination completion handler.  'PTimerQ' is the timer queue
// descriptor.  'PContext' is user's context as passed to TimerQTerminate.
// Caller must not free or reuse the TIMERQ before this routine is called.
//
typedef
VOID
(*PTIMERQTERMINATECOMPLETE)(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );


// Timer queue descriptor.  All access should be via the TimerQ* interface.
// There is no reason user should look inside.  All necessary locking is
// handled internally.
//
typedef struct
_TIMERQ
{
    // Set to MTAG_TIMERQ when the block is valid and to MTAG_FREED when no
    // longer valid.
    //
    ULONG ulTag;

    // Head of a double-linked list of "ticking" TIMERQITEMs.  The list is
    // sorted by time to expiration with the earliest expiration at the head
    // of the list.  The list is protected by 'lock'.
    //
    LIST_ENTRY listItems;

    // Caller's terminate complete handler as passed to TimerQTerminate.  This
    // is non-NULL only when our internal timer event handler must call it.
    //
    PTIMERQTERMINATECOMPLETE pHandler;

    // User's PTIMERQTERMINATECOMPLETE context passed back to 'pHandler'.
    //
    VOID* pContext;

    // Set when the timer queue is terminating.  No other requests are
    // accepted when this is the case.
    //
    BOOLEAN fTerminating;

    // Spin lock protecting the 'listItems' list.
    //
    NDIS_SPIN_LOCK lock;

    // NDIS timer object.
    //
    NDIS_TIMER timer;
}
TIMERQ;


// Timer queue event descriptor.  All access should be via the TimerQ*
// interface.  There is no reason user should look inside.  This is exposed to
// allow user to efficiently manage allocation of TIMERQITEMS for several
// timers from a large pool.
//
typedef struct
_TIMERQITEM
{
    // Links to the prev/next TIMERQITEM in the owning TIMERQ's chain of
    // pending timer events.  Access is protected by 'lock' in the TIMERQ
    // structure.
    //
    LIST_ENTRY linkItems;

    // System time at which this event should occur.
    //
    LONGLONG llExpireTime;

    // User's routine to handle the timeout event when it occurs.
    //
    PTIMERQEVENT pHandler;

    // User's PTIMERQEVENT context passed back to 'pHandler'.
    //
    VOID* pContext;
}
TIMERQITEM;


// Indicates the event which triggered user's callback to be called.
//
typedef enum
_TIMERQEVENT
{
    // The timeout interval has elapsed or user called TimerQExpireItem.
    //
    TE_Expire,

    // User called TimerQCancelItem.
    //
    TE_Cancel,

    // User called TimerQTerminateItem or called TimerQTerminate while the
    // item was queued.
    //
    TE_Terminate
}
TIMERQEVENT;


//-----------------------------------------------------------------------------
// Interface prototypes
//-----------------------------------------------------------------------------

BOOLEAN
IsTimerQItemScheduled(
    IN TIMERQITEM* pItem );

VOID
TimerQInitialize(
    IN TIMERQ* pTimerQ );

VOID
TimerQInitializeItem(
    IN TIMERQITEM* pItem );

VOID
TimerQTerminate(
    IN TIMERQ* pTimerQ,
    IN PTIMERQTERMINATECOMPLETE pHandler,
    IN VOID* pContext );

VOID
TimerQScheduleItem(
    IN TIMERQ* pTimerQ,
    IN OUT TIMERQITEM* pNewItem,
    IN ULONG ulTimeoutMs,
    IN PTIMERQEVENT pHandler,
    IN VOID* pContext );

BOOLEAN
TimerQCancelItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

BOOLEAN
TimerQExpireItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );

CHAR*
TimerQPszFromEvent(
    IN TIMERQEVENT event );

BOOLEAN
TimerQTerminateItem(
    IN TIMERQ* pTimerQ,
    IN TIMERQITEM* pItem );


#endif // TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\tapi.h ===
#ifndef _TAPI_H_
#define _TAPI_H_

#define ALLOC_LINE( ppL ) NdisAllocateMemoryWithTag( (PVOID*) ppL, sizeof( LINE ), MTAG_LINE )

#define FREE_LINE( pL ) NdisFreeMemory( (PVOID) pL, sizeof( LINE ), 0 );

#define VALIDATE_LINE( pL ) ( (pL) && (pL->tagLine == MTAG_LINE) )

#define ALLOC_CALL( ppC ) NdisAllocateMemoryWithTag( (PVOID*) ppC, sizeof( CALL ), MTAG_CALL )

#define FREE_CALL( pC ) NdisFreeMemory( (PVOID) pC, sizeof( CALL ), 0 );

#define VALIDATE_CALL( pC ) ( (pC) && (pC->tagCall == MTAG_CALL) )

VOID 
ReferenceCall(
	IN CALL* pCall,
	IN BOOLEAN fAcquireLock
	);

VOID 
DereferenceCall(
	IN CALL *pCall
	);

VOID 
ReferenceLine(
	IN LINE* pLine,
	IN BOOLEAN fAcquireLock
	);

VOID 
DereferenceLine(
	IN LINE *pLine
	);

VOID 
ReferenceTapiProv(
	IN ADAPTER* pAdapter,
	IN BOOLEAN fAcquireLock
	);

VOID 
DereferenceTapiProv(
	IN ADAPTER *pAdapter
	);

NDIS_STATUS 
TpProviderInitialize(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_PROVIDER_INITIALIZE pRequest
	);

NDIS_STATUS
TpProviderShutdown(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest,
    IN BOOLEAN fNotifyNDIS
	);

NDIS_STATUS
TpOpenLine(
    ADAPTER* pAdapter,
    PNDIS_TAPI_OPEN pRequest
    );

NDIS_STATUS 
TpCloseLine(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_CLOSE pRequest,
	IN BOOLEAN fNotifyNDIS
	);

NDIS_STATUS 
TpCloseCall(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_CLOSE_CALL pRequest,
	IN BOOLEAN fNotifyNDIS
	);

NDIS_STATUS
TpDropCall(
	IN ADAPTER* pAdapter,
	IN PNDIS_TAPI_DROP pRequest,
	IN ULONG ulLineDisconnectMode
	);

VOID 
TpCloseCallComplete(
	IN CALL* pCall
	);

VOID 
TpCloseLineComplete(
	IN LINE* pLine
	);

VOID 
TpProviderShutdownComplete(
	IN ADAPTER* pAdapter
	);

VOID 
TpProviderCleanup(
	IN ADAPTER* pAdapter
	);

VOID 
TpLineCleanup(
	IN LINE* pLine
	);

VOID 
TpCallCleanup(
	IN CALL* pCall 
	);

NDIS_STATUS
TpSetDefaultMediaDetection(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    );

VOID
TpSetDefaultMediaDetectionComplete(
   IN LINE* pLine,
   IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest   
   );

NDIS_STATUS
TpNegotiateExtVersion(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_NEGOTIATE_EXT_VERSION pRequest
    );

NDIS_STATUS
TpGetExtensionId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_EXTENSION_ID pRequest
    );

NDIS_STATUS
TpGetAddressStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS pRequest
    );

NDIS_STATUS
TpGetId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ID pRequest,
    IN ULONG ulRequestLength
    );

NDIS_STATUS
TpGetDevCaps(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS pRequest
    );

NDIS_STATUS
TpGetCallStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS pRequest
    );

NDIS_STATUS
TpGetCallInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO pRequest
    );

NDIS_STATUS
TpGetAddressCaps(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    );

NDIS_STATUS
TpSetStatusMessages(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    );

VOID
TpCallStateChangeHandler(
	IN CALL* pCall,
    IN ULONG ulCallState,
    IN ULONG ulStateParam
	);

NDIS_STATUS
TpMakeCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_MAKE_CALL pRequest,
    IN ULONG ulRequestLength
    );

VOID
TpMakeCallComplete(
   IN CALL* pCall,
   IN PNDIS_TAPI_MAKE_CALL pRequest   
   );
    
NDIS_STATUS
TpCallInitialize(
	IN CALL* pCall,
	IN LINE* pLine,
	IN HTAPI_CALL htCall,
	IN BOOLEAN fIncoming
	);
    
NDIS_STATUS
TpAnswerCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    );	

VOID 
ExecAdapterWorkItem(
	IN PVOID Args[4],
	IN UINT workType
	);

VOID
TpReceiveCall(
	IN ADAPTER* pAdapter,
	IN BINDING* pBinding,
	IN PPPOE_PACKET* pPacket
	);	

BOOLEAN
TpIndicateNewCall(
	IN CALL* pCall
	);	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\util.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    util.c

Abstract:

    This module contains the routines some helper routines.

    	- Workitems: These routines manage the scheduled work items.
    	- Handle table: There routines manage a handle table that creates unique
    	                handles and stores context pointers into the table that are only
    	                accessible by the unique handle generated.

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/
#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"

VOID InitializeWorkItemLookasideList(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN ULONG tagLookaside
	)
{
	NdisInitializeNPagedLookasideList( pLookaside,
									   NULL,
									   NULL,
									   0,
									   sizeof( WORKITEM ),
									   tagLookaside,
									   0 );
}
	
WORKITEM* AllocWorkItem(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN WORKITEM_EXEC_ROUTINE pExecRoutine,
	IN WORKITEM_FREE_ROUTINE pFreeRoutine,
	IN PVOID Args[4],
	IN UINT workType
	)
{
	WORKITEM* pWorkItem = NULL;

	//
	// Allocate a binding work item from our pool
	//
	pWorkItem = NdisAllocateFromNPagedLookasideList( pLookaside );

	if ( pWorkItem == NULL )
		return NULL;

	//
	// Clear the memory
	//
	NdisZeroMemory( pWorkItem, sizeof( WORKITEM ) );

	//
	// Initialize the state of the work item
	//
	pWorkItem->workState = WS_NotScheduled;

	//
	// Initialize the type of work
	//
	pWorkItem->workType = workType;

	//
	// Set the lookaside list member
	//
	pWorkItem->pLookaside = pLookaside;

	//
	// Initialize the context for the work item
	//
	NdisMoveMemory( pWorkItem->Args, Args, 4 * sizeof( PVOID ) );

	pWorkItem->pExecRoutine = pExecRoutine;
	pWorkItem->pFreeRoutine = pFreeRoutine;
	
	//
	// As our NDIS_WORK_ITEM structure is embedded into our own work item
	// we can initialize it here.
	//
	NdisInitializeWorkItem( &pWorkItem->ndisWorkItem, 
							&WorkItemExec,
							pWorkItem );

	return pWorkItem;
}

VOID ScheduleWorkItem(
	IN WORKITEM *pWorkItem
	)
{
	//
	// Initialize the state of the work item
	//
	pWorkItem->workState = WS_Scheduled;

	//
	// Schedule the item
	//
	NdisScheduleWorkItem( &pWorkItem->ndisWorkItem );	
}

VOID FreeWorkItem(
	IN WORKITEM *pWorkItem
	)
{
	WORKITEM_FREE_ROUTINE pFreeRoutine = NULL;

	ASSERT( pWorkItem != NULL );

	//
	// Free the associated context information
	//
	if ( pWorkItem->pFreeRoutine != NULL )
		pWorkItem->pFreeRoutine( pWorkItem->Args, pWorkItem->workType );

	//
	// Free the actual work item
	//
	NdisFreeToNPagedLookasideList( pWorkItem->pLookaside, (PVOID) pWorkItem );
}


//
// This is the NDIS_WORK_ITEM handler that we schedule for our BINDING_WORKITEMs.
//
VOID WorkItemExec(
    IN NDIS_WORK_ITEM*  pNdisWorkItem,
    IN PVOID  pvContext
	)
{
	WORKITEM* pWorkItem = NULL;
	
	ASSERT( pNdisWorkItem != NULL );

	pWorkItem = (WORKITEM*) pvContext;

	ASSERT( pWorkItem->workState == WS_Scheduled );
	
	pWorkItem->workState = WS_Executing;

	if ( pWorkItem->pExecRoutine != NULL )
		pWorkItem->pExecRoutine( pWorkItem->Args, pWorkItem->workType );

	pWorkItem->workState = WS_Executed;

	FreeWorkItem( pWorkItem );	
}

HANDLE_TABLE InitializeHandleTable(
	IN UINT nHandleTableSize
	)
{
	NDIS_STATUS status = NDIS_STATUS_RESOURCES;
	HANDLE_TABLE Table = NULL;

	do
	{
		//
		// Allocate the table context
		//
		status = NdisAllocateMemoryWithTag( &Table,
										 	sizeof( HANDLE_TABLE_CB ),
											MTAG_HANDLETABLE );
	
		if ( status != NDIS_STATUS_SUCCESS )
			break;
	
		NdisZeroMemory( Table, sizeof( HANDLE_TABLE_CB ) );
	
		//
		// Allocate the array that holds the handle contexts
		//
		status = NdisAllocateMemoryWithTag( &Table->HandleTable,
											sizeof( HANDLE_CB ) * nHandleTableSize,
											MTAG_HANDLECB );
	
		if ( status != NDIS_STATUS_SUCCESS )
			break;
	
		NdisZeroMemory( Table->HandleTable, sizeof( HANDLE_CB ) * nHandleTableSize );
		
		Table->nTableSize = nHandleTableSize;
	
		Table->nActiveHandles = 0; 
		
		Table->usKeys = 0;

		status = NDIS_STATUS_SUCCESS;

	} while ( FALSE );

	if ( status != NDIS_STATUS_SUCCESS )
		FreeHandleTable( Table );
		
	return Table;				
}

VOID FreeHandleTable(
	IN OUT HANDLE_TABLE Table
	)
{
	if ( Table == NULL )
		return;

	if ( Table->HandleTable )		
	{
		NdisFreeMemory( Table->HandleTable,
						Table->nTableSize * sizeof( HANDLE_CB ),
						0 );
	}

	NdisFreeMemory( Table,
					sizeof( HANDLE_TABLE_CB ),
					0 );
}

NDIS_HANDLE InsertToHandleTable(
	IN HANDLE_TABLE Table,
	IN USHORT usPreferedIndex,
	IN PVOID pContext
	)
{
	ULONG ulHandle;
	USHORT usKey;

	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return (NDIS_HANDLE) NULL;

	if ( usPreferedIndex == NO_PREFERED_INDEX )
	{
		UINT i;
		
		for (i = 0 ; i < Table->nTableSize ; i++ )
			if ( !Table->HandleTable[i].fActive )
				break;

		usPreferedIndex = (USHORT) i;
	}
	else
	{
		if ( Table->HandleTable[ usPreferedIndex ].fActive )
			return NULL;
	}

	if ( usPreferedIndex >= Table->nTableSize )
		return NULL;

	//
	// Generate Handle
	//
	ulHandle = (ULONG) usPreferedIndex;

	usKey = ++Table->usKeys;

	ulHandle = ulHandle << 16;

	ulHandle |= (ULONG) usKey;

	//
	// Update the handle control block
	//
	pHandleCB = &Table->HandleTable[ usPreferedIndex ];

	pHandleCB->fActive = TRUE;

	pHandleCB->pContext = pContext;

	pHandleCB->Handle = (NDIS_HANDLE) ULongToPtr( ulHandle );

	//
	// Increment the active handle counter
	//
	Table->nActiveHandles++;

	return pHandleCB->Handle;
}
	
USHORT RetrieveIndexFromHandle(
	IN NDIS_HANDLE Handle
	)
{
	ULONG_PTR ulHandle = (ULONG_PTR) Handle;
	USHORT usIndex;
	
	usIndex = (USHORT) ( ulHandle >> 16 );

	return usIndex;
}

PVOID RetrieveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	)
{
	USHORT usIndex;
	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return NULL;

	usIndex = RetrieveIndexFromHandle( Handle );

	if ( usIndex >= Table->nTableSize )
		return NULL;

	pHandleCB = &Table->HandleTable[ usIndex ];

	if ( !pHandleCB->fActive )
		return NULL;

	if ( pHandleCB->Handle != Handle )
		return NULL;

	return pHandleCB->pContext;

}

PVOID RetrieveFromHandleTableByIndex(
	IN HANDLE_TABLE Table,
	IN USHORT usIndex
	)
{
	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return NULL;
		
	if ( usIndex >= Table->nTableSize )
		return NULL;

	pHandleCB = &Table->HandleTable[ usIndex ];

	if ( !pHandleCB->fActive )
		return NULL;

	return pHandleCB->pContext;
}

PVOID RetrieveFromHandleTableBySessionId(
	IN HANDLE_TABLE Table,
	IN USHORT usSessionId
	)
{
	USHORT usIndex = usSessionId - 1;

	return RetrieveFromHandleTableByIndex( Table, usIndex );
}

VOID RemoveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	)
{
	USHORT usIndex;

	HANDLE_CB* pHandleCB = NULL;

	if ( Table == NULL )
		return;
		
	usIndex = RetrieveIndexFromHandle( Handle );

	if ( usIndex >= Table->nTableSize )
		return;

	pHandleCB = &Table->HandleTable[ usIndex ];

	if ( !pHandleCB->fActive )
		return;

	if ( pHandleCB->Handle != Handle )
		return;

	NdisZeroMemory( pHandleCB, sizeof( HANDLE_CB ) );

	Table->nActiveHandles--;
}

USHORT RetrieveSessionIdFromHandle(
	IN NDIS_HANDLE Handle
	)
{
	return ( RetrieveIndexFromHandle( Handle ) + 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\tapi.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    tapi.c

Abstract:

    This module contains all the TAPI_OID processing routines.  

Author:

    Hakan Berk - Microsoft, Inc. (hakanb@microsoft.com) Feb-2000

Environment:

    Windows 2000 kernel mode Miniport driver or equivalent.

Revision History:

---------------------------------------------------------------------------*/

#include <ntddk.h>
#include <ntddndis.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#include "debug.h"
#include "timer.h"
#include "bpool.h"
#include "ppool.h"
#include "util.h"
#include "packet.h"
#include "protocol.h"
#include "miniport.h"
#include "tapi.h"
#include "fsm.h"

extern TIMERQ gl_TimerQ;

extern NPAGED_LOOKASIDE_LIST gl_llistWorkItems;

///////////////////////////////////////////////////////////////////////////////////
//
// Tapi provider, line and call context functions
//
///////////////////////////////////////////////////////////////////////////////////

VOID 
ReferenceCall(
    IN CALL* pCall,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the call object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             call, otherwise it will assume the caller owns the lock.
    
Parameters:

    pCall _ A pointer to our call information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    TRACE( TL_V, TM_Tp, ("+ReferenceCall") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pCall->lockCall );

    lRef = ++pCall->lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pCall->lockCall );

    TRACE( TL_V, TM_Tp, ("-ReferenceCall=$%d",lRef) );
}

VOID 
DereferenceCall(
    IN CALL *pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the call object

    If ref count drops to 0 (which means the call has been closed),
    it will set the CLBF_CallClosed bit. Then it will call TpCloseCallComplete() 
    function which eventually handles destroying the resources allocated for 
    this call context.

    CAUTION: All locks must be released before calling this function because
             it may cause a set of cascading events.

Parameters:

    pCall _ A pointer ot our call information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BOOLEAN fCallTpCloseCallComplete = FALSE;
    LONG lRef;

    TRACE( TL_V, TM_Tp, ("+DereferenceCall") );

    NdisAcquireSpinLock( &pCall->lockCall );

    lRef = --pCall->lRef;

    if ( lRef == 0 )
    {
        pCall->ulClFlags &= ~CLBF_CallOpen;
        pCall->ulClFlags &= ~CLBF_CallClosePending;
        pCall->ulClFlags |= CLBF_CallClosed;
        
        fCallTpCloseCallComplete = TRUE;
    }

    NdisReleaseSpinLock( &pCall->lockCall );

    if ( fCallTpCloseCallComplete )
        TpCloseCallComplete( pCall );

    TRACE( TL_V, TM_Tp, ("-DereferenceCall=$%d",lRef) );
}


VOID 
ReferenceLine(
    IN LINE* pLine,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the line object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             line, otherwise it will assume the caller owns the lock.
    
Parameters:

    pLine _ A pointer to our line information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    TRACE( TL_V, TM_Tp, ("+ReferenceLine") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pLine->lockLine );

    lRef = ++pLine->lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pLine->lockLine );

    TRACE( TL_V, TM_Tp, ("-ReferenceLine=$%d",lRef) );
        
}

VOID 
DereferenceLine(
    IN LINE *pLine
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the line object

    If the ref count drops to 0 (which means the line has been closed),
    it will set the LNBF_CallClosed bit. Then it will call TpCloseLineComplete() 
    function which eventually handles destroying the resources allocated for 
    this line context.

    CAUTION: All locks must be released before calling this function because
             it may cause a set of cascading events.
    
Parameters:

    pLine _ A pointer to our line information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BOOLEAN fCallTpCloseLineComplete = FALSE;
    LONG lRef;

    TRACE( TL_V, TM_Tp, ("+DereferenceLine") );
    

    NdisAcquireSpinLock( &pLine->lockLine );

    lRef = --pLine->lRef;
    
    if ( lRef == 0 )
    {
        pLine->ulLnFlags &= ~LNBF_LineOpen;
        pLine->ulLnFlags &= ~LNBF_LineClosePending;
        pLine->ulLnFlags |= LNBF_LineClosed;

        fCallTpCloseLineComplete = TRUE;
    }

    NdisReleaseSpinLock( &pLine->lockLine );

    if ( fCallTpCloseLineComplete )
        TpCloseLineComplete( pLine );

    TRACE( TL_V, TM_Tp, ("-DereferenceLine=$%d",lRef) );
}

VOID 
ReferenceTapiProv(
    IN ADAPTER* pAdapter,
    IN BOOLEAN fAcquireLock
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will increment the reference count on the tapi prov object.
    
    CAUTION: If fAcquireLock is set, this function will acquire the lock for the
             line, otherwise it will assume the caller owns the lock.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

    fAcquireLock _ Indicates if the caller already has the lock or not.
                   Caller must set this flag to FALSE if it has the lock, 
                   otherwise it must be supplied as TRUE.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    LONG lRef;
    
    TRACE( TL_V, TM_Tp, ("+ReferenceTapiProv") );

    if ( fAcquireLock )
        NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = ++pAdapter->TapiProv.lRef;

    if ( fAcquireLock )
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

    TRACE( TL_V, TM_Tp, ("-ReferenceTapiProv=$%d",lRef) );
}


VOID 
DereferenceTapiProv(
    IN ADAPTER *pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will decrement the reference count on the tapi prov object

    CAUTION: All locks must be released before calling this function because
             it may cause a set of cascading events.
    
Parameters:

    pAdapter _ A pointer to our adapter line information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    BOOLEAN fCallTpProviderShutdownComplete = FALSE;
    LONG lRef;

    TRACE( TL_V, TM_Tp, ("+DereferenceTapiProv") );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    lRef = --pAdapter->TapiProv.lRef;
    
    if ( lRef == 0 )
    {
        pAdapter->TapiProv.ulTpFlags &= ~TPBF_TapiProvInitialized;
        pAdapter->TapiProv.ulTpFlags &= ~TPBF_TapiProvShutdownPending;
        pAdapter->TapiProv.ulTpFlags |= TPBF_TapiProvShutdown;
        
        fCallTpProviderShutdownComplete = TRUE;
    }

    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    if ( fCallTpProviderShutdownComplete )
        TpProviderShutdownComplete( pAdapter );

    TRACE( TL_V, TM_Tp, ("-DereferenceTapiProv=$%d",lRef) );
        
}

NDIS_STATUS 
TpProviderInitialize(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_PROVIDER_INITIALIZE pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request initializes the TAPI portion of the miniport.

    It will set Tapi Provider's state to initialize, and reference both the
    owning adapter and tapi provider.

Parameters:

    Adapter _ A pointer ot our adapter information structure.

    Request _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceIDBase;
        OUT ULONG       ulNumLineDevs;
        OUT ULONG       ulProviderID;

    } NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;

Return Values:

    NDIS_STATUS_SUCCESS

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_RESOURCES;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderInitialize") );

    do 
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderInitialize: Invalid parameter") );  

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        //
        // Initialize the tapi provider context
        //
        NdisZeroMemory( &pAdapter->TapiProv, sizeof( pAdapter->TapiProv ) );
    
        //
        // Try to allocate resources
        //
        NdisAllocateMemoryWithTag( (PVOID) &pAdapter->TapiProv.LineTable, 
                                   sizeof( LINE* ) * pAdapter->nMaxLines,
                                   MTAG_TAPIPROV );
    
        if ( pAdapter->TapiProv.LineTable == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderInitialize: Could not allocate line table") );  

            break;
        }

        NdisZeroMemory( pAdapter->TapiProv.LineTable, sizeof( LINE* ) * pAdapter->nMaxLines );

        pAdapter->TapiProv.hCallTable = InitializeHandleTable( pAdapter->nMaxLines * pAdapter->nCallsPerLine );

        if ( pAdapter->TapiProv.hCallTable == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderInitialize: Could not allocate call handle table") );   

            break;
        }
    
        pAdapter->TapiProv.ulTpFlags = TPBF_TapiProvInitialized;
    
        pAdapter->TapiProv.ulDeviceIDBase = pRequest->ulDeviceIDBase;

        //
        // Do referencing
        //
        ReferenceTapiProv( pAdapter, FALSE );
    
        ReferenceAdapter( pAdapter, TRUE );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // Set output information
        //
        pRequest->ulNumLineDevs = pAdapter->nMaxLines;
    
        pRequest->ulProviderID = (ULONG_PTR) pAdapter->MiniportAdapterHandle;

    }
    else
    {
        //
        // Somethings failed, clean up
        //
        TpProviderCleanup( pAdapter );
    }

    TRACE( TL_N, TM_Tp, ("-TpProviderInitialize=$%x",status) );
    
    return status;
}

NDIS_STATUS
TpProviderShutdown(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest,
    IN BOOLEAN fNotifyNDIS
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request shuts down the miniport. The miniport should terminate any 
    activities it has in progress.

    This operation might pend as there might be lines and call contexts still 
    active. So this function marks the tapi provider context as close pending
    and calls TpCloseLine() on all active calls, and removes the reference added
    on the tapi provider in TpProviderInitialize(). 

    When ref count on the tapi provider context reaches 0, TpProviderShutdownComplete()
    will be called to clean up the tapi provider context, and remove the reference 
    on the owning adapter.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.
               If supplied as NULL, then we do not need to notify NDIS.

    typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN
    {
        IN  ULONG       ulRequestID;

    } NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;


    fNotifyNDIS _ Indicates if NDIS needs to be notified about the completion 
                  of this operation

Return Values:

    NDIS_STATUS_SUCCESS:
        Tapi provider shutdown and cleaned up succesfully.
    
    NDIS_STATUS_PENDING
        Shutdown operation is pending. When all shutdown operation completes
        owning adapter context will be dereferenced.

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status;
    BOOLEAN fDereferenceTapiProv = FALSE;
    BOOLEAN fLockAcquired = FALSE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderShutdown") );

    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpProviderShutdown: Invalid parameter") );    

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        NdisAcquireSpinLock( &pAdapter->lockAdapter );

        fLockAcquired = TRUE;

        //
        // See if tapi provider was initialized at all
        //
        if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
        {
            //
            // Tapi provider was not initialized so just return
            //
            status = NDIS_STATUS_SUCCESS;
            
            break;
        }


        //
        // See if we can shutdown immediately
        //
        if ( pAdapter->TapiProv.lRef == 1 )
        {
            //
            // We are holding the only reference, so we can shutdown immediately
            //
            pAdapter->TapiProv.ulTpFlags &= ~TPBF_TapiProvInitialized;
    
            pAdapter->TapiProv.ulTpFlags |= TPBF_TapiProvShutdown;
    
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            UINT i;
    
            //
            // Mark Tapi provider as shutdown pending
            //
            pAdapter->TapiProv.ulTpFlags |= TPBF_TapiProvShutdownPending;
            
            //
            // Mark tapi prov if the result of this operation needs to be reported to NDIS
            //
            if ( fNotifyNDIS )
                pAdapter->TapiProv.ulTpFlags |= TPBF_NotifyNDIS;
    
            // 
            // Close all active lines
            //
            for ( i = 0; i < pAdapter->nMaxLines; i++)
            {
                NDIS_TAPI_CLOSE DummyRequest;
            
                LINE* pLine = (LINE*) pAdapter->TapiProv.LineTable[i];
    
                if ( pLine )
                {
                            
                    DummyRequest.hdLine = pLine->hdLine;
    
                    NdisReleaseSpinLock( &pAdapter->lockAdapter );
        
                    TpCloseLine( pAdapter, &DummyRequest, FALSE );
        
                    NdisAcquireSpinLock( &pAdapter->lockAdapter );
                }
    
            }

            status = NDIS_STATUS_PENDING;       
        }

        fDereferenceTapiProv = TRUE;
        
    } while ( FALSE );

    if ( fLockAcquired ) 
    {
        NdisReleaseSpinLock( &pAdapter->lockAdapter );
    }

    if ( fDereferenceTapiProv )
    {
        DereferenceTapiProv( pAdapter );
    }

    TRACE( TL_N, TM_Tp, ("-TpProviderShutdown=$%x",status) );

    return status;
}

#define INVALID_LINE_HANDLE                         (HDRV_LINE) -1

HDRV_LINE
TpGetHdLineFromDeviceId(
               ADAPTER* pAdapter,
               ULONG ulID
               )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to map a Tapi Device Id to the driver's line handle.
    It returns INVALID_LINE_HANDLE if it can not map the device id.

    REMARK: 
      - pAdapter must not be NULL.
      - It must be called from one of the Tp...OidHandler() functions since
        this function relies on this and assumes there won't be any 
        synchronization problems.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    uldID _ Device Id that identifies a line context
    
Return Values:

    Handle to the line context if device id can be mapped to a valid line context,
    and INVALID_LINE_HANDLE otherwise.
       
---------------------------------------------------------------------------*/
{
    if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
          ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
    {
        if ( ( ulID < ( pAdapter->TapiProv.ulDeviceIDBase + pAdapter->nMaxLines ) ) &&                    
             ( ulID >= pAdapter->TapiProv.ulDeviceIDBase ) )                                    
        {
            return (HDRV_LINE) ( ulID - pAdapter->TapiProv.ulDeviceIDBase );
        }
    }

    return INVALID_LINE_HANDLE;
}

LINE* 
TpGetLinePtrFromHdLineEx(
               ADAPTER* pAdapter,
               HDRV_LINE hdLine
               )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to map a driver line handle to the line context ptr.
    It returns NULL if it can not map the handle. This is exactly the same as
    TpGetLinePtrFromHdLine function except that it doesn't check for the
    shutdown state.

    REMARK: 
      - pAdapter must not be NULL.
      - It must be called from one of the Tp...OidHandler() functions since
        this function relies on this and assumes there won't be any 
        synchronization problems. 
        (Basically assumes pAdapter->lock is being held)

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    hdL _ Driver's line handle
    
Return Values:

    Pointer to the Line context associated with the Line handle provided
    if mapping is succesful, and NULL otherwise.
    
---------------------------------------------------------------------------*/
{
    if ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized )
    {
        if ( ( (ULONG) hdLine < (ULONG) pAdapter->nMaxLines ) )
        {
            ASSERT( pAdapter->TapiProv.LineTable != 0 );
            
            return pAdapter->TapiProv.LineTable[ (ULONG) hdLine ];
        }
    }

    return NULL;
}


LINE* 
TpGetLinePtrFromHdLine(
               ADAPTER* pAdapter,
               HDRV_LINE hdLine
               )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is used to map a driver line handle to the line context ptr.
    It returns NULL if it can not map the handle.

    REMARK: 
      - pAdapter must not be NULL.
      - It must be called from one of the Tp...OidHandler() functions since
        this function relies on this and assumes there won't be any 
        synchronization problems. 
        (Basically assumes pAdapter->lock is being held)

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    hdL _ Driver's line handle
    
Return Values:

    Pointer to the Line context associated with the Line handle provided
    if mapping is succesful, and NULL otherwise.
    
---------------------------------------------------------------------------*/
{
    if ( !( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvShutdownPending ) &&
          ( pAdapter->TapiProv.ulTpFlags & TPBF_TapiProvInitialized ) )
    {
        if ( ( (ULONG) hdLine < (ULONG) pAdapter->nMaxLines ) )
        {
            ASSERT( pAdapter->TapiProv.LineTable != 0 );
            
            return pAdapter->TapiProv.LineTable[ (ULONG) hdLine ];
        }
    }

    return NULL;
}


NDIS_STATUS
TpOpenLine(
    ADAPTER* pAdapter,
    PNDIS_TAPI_OPEN pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function opens the line device whose device ID is given, returning
    the miniports handle for the device. The miniport must retain the
    Connection Wrapper's handle for the device for use in subsequent calls to
    the LINE_EVENT callback procedure.

    hdLine returned is the index to the pAdapter->TapiProv.LineTable array
    that holds the pointer to the new line context.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest - A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_OPEN
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  HTAPI_LINE  htLine;
        OUT HDRV_LINE   hdLine;

    } NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_TAPI_ALLOCATED
    NDIS_STATUS_TAPI_INVALMEDIAMODE
    NDIS_STATUS_FAILURE
    
---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;
    LINE* pLine = NULL;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpOpenLine") );

    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpOpenLine: Invalid parameter") );    

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }
    
        //
        // Map the device id to an entry in our line table
        //
        hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );

        if ( hdLine == INVALID_LINE_HANDLE )
        {
            TRACE( TL_N, TM_Tp, ("TpOpenLine: Invalid handle supplied") );  

            break;
        }

        //
        // Make sure the line is not busy already
        //
        if ( TpGetLinePtrFromHdLine( pAdapter, hdLine ) != NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpOpenLine: Line is busy") ); 

            break;
        }

        //
        // Allocate the line context
        //
        if ( ALLOC_LINE( &pLine ) != NDIS_STATUS_SUCCESS )
        {
            TRACE( TL_A, TM_Tp, ("TpOpenLine: Could not allocate context") );   

            break;
        }

        //
        // Initialize line context
        //
        NdisZeroMemory( pLine, sizeof( LINE ) );
        
        pLine->tagLine = MTAG_LINE;

        NdisAllocateSpinLock( &pLine->lockLine );

        pLine->ulLnFlags = LNBF_LineOpen;

        if ( pAdapter->fClientRole )
        {
            pLine->ulLnFlags |= LNBF_MakeOutgoingCalls;
        }

        //
        // Copy related info from adapter context
        //
        pLine->pAdapter = pAdapter;

        pLine->nMaxCalls = pAdapter->nCallsPerLine;

        InitializeListHead( &pLine->linkCalls );

        //
        // Set tapi handles
        //
        pLine->htLine = pRequest->htLine;

        pLine->hdLine = hdLine;
        
        //
        // Insert new line context to line table of tapi provider
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
        pAdapter->TapiProv.LineTable[ (ULONG) hdLine ] = pLine;

        pAdapter->TapiProv.nActiveLines++;

        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Do referencing
        //
        ReferenceLine( pLine, FALSE );

        ReferenceTapiProv( pAdapter, TRUE );

        status = NDIS_STATUS_SUCCESS;
        
    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        pRequest->hdLine = hdLine;
    }
        
    TRACE( TL_N, TM_Tp, ("-TpOpenLine=$%x",status) );

    return status;
}

NDIS_STATUS 
TpCloseLine(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_CLOSE pRequest,
    IN BOOLEAN fNotifyNDIS
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request closes the specified open line device after completing or
    aborting all outstanding calls and asynchronous requests on the device.

    It will remove the reference on the line context added in TpOpenLine().

    It will be called from 2 places:
        1. When miniport receives an OID_TAPI_CLOSE.
           In this case, fNotifyNDIS will be set as TRUE.
           
        2. When miniport is halting, TpProviderShutdown() will call
           this function for every active line context.
    
Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_CLOSE
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;

    } NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;

    fNotifyNDIS _ Indicates if NDIS needs to be notified about the completion 
                  of this operation
                  
Return Values:

    NDIS_STATUS_SUCCESS: Line context destroyed succesfully.
        
    NDIS_STATUS_PENDING: Close operation is pending. When line is closed, 
                         tapi provider will be dereferenced.
        
    NDIS_STATUS_TAPI_INVALLINEHANDLE: An invalid handle was supplied. 
                                      No operations performed.

---------------------------------------------------------------------------*/
{
    LINE* pLine = NULL;
    BOOLEAN fLockReleased = FALSE;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseLine") );


    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpCloseLine: Invalid parameter") );   

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        pLine = TpGetLinePtrFromHdLineEx( pAdapter, pRequest->hdLine );


        if ( pLine == NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpCloseLine: Invalid handle supplied") ); 

            status = NDIS_STATUS_TAPI_INVALLINEHANDLE;
            
            break;
        }

        //
        // Remove line context from tapi providers line table
        // and invalidate the handle, as we do not want any more 
        // requests on this line context.
        //
        // The active line counter will be adjusted in TpCloseLineComplete()
        // when we deallocate the line context.
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
        pAdapter->TapiProv.LineTable[ (ULONG) pRequest->hdLine ] = NULL;
    
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Now start closing the line
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        //
        // Do not accept any more incoming calls
        //
        pLine->ulLnFlags &= ~LNBF_AcceptIncomingCalls;

        //
        // Mark the line as close pending, so that we do not accept
        // any more requests on it
        //
        pLine->ulLnFlags |= LNBF_LineClosePending;

        if ( fNotifyNDIS )
            pLine->ulLnFlags |= LNBF_NotifyNDIS;

        while ( !IsListEmpty( &pLine->linkCalls ) )
        {
            CALL* pCall = NULL;
            NDIS_TAPI_CLOSE_CALL DummyRequest;
            
            //
            // Retrieve a call context from the head of active call list
            // and close it.
            //
            pCall = (CALL*) CONTAINING_RECORD( pLine->linkCalls.Flink,
                                               CALL,
                                               linkCalls );

            NdisReleaseSpinLock( &pLine->lockLine );

            DummyRequest.hdCall = pCall->hdCall;

            //
            // This will remove the call from the list,
            // so there will be a new call at the head of the list
            // next time we retrieve.
            //
            TpCloseCall( pAdapter, &DummyRequest, FALSE );

            NdisAcquireSpinLock( &pLine->lockLine );
        } 

        status = NDIS_STATUS_PENDING;
        
    } while ( FALSE );

    if ( status == NDIS_STATUS_PENDING )
    {
        BOOLEAN fNotifyTapiOfInternalLineClose = !( pLine->ulLnFlags & LNBF_NotifyNDIS );
    
        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // Check if this is an internal request to close the line, 
        // notify TAPI if it is
        //
        if ( fNotifyTapiOfInternalLineClose )
        {
            NDIS_TAPI_EVENT TapiEvent;

            NdisZeroMemory( &TapiEvent, sizeof( NDIS_TAPI_EVENT ) );
            
            TapiEvent.htLine = pLine->htLine;
            TapiEvent.ulMsg = LINE_CLOSE;

            NdisMIndicateStatus( pLine->pAdapter->MiniportAdapterHandle,
                                 NDIS_STATUS_TAPI_INDICATION,
                                 &TapiEvent,
                                 sizeof( NDIS_TAPI_EVENT ) );   
        }

        if ( pAdapter->TapiProv.nActiveLines == 1 )
        {
            //
            // We are closing the last line so notify protocol about this so
            // it can remove packet filters
            //
            WORKITEM* pWorkItem = NULL;
            PVOID Args[4];

            Args[0] = (PVOID) BN_ResetFiltersForCloseLine;           // Is a reset filters request
            Args[1] = (PVOID) pLine;
       
            //
            // Allocate work item for reenumerating bindings
            //
            pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                       ExecBindingWorkItem,
                                       NULL,
                                       Args,
                                       BWT_workPrStartBinds );

            if ( pWorkItem ) 
            {
               //
               // Schedule the work item.
               //
               // Note that we need to referencing here, because we do not want TpCloseLineCopmlete()
               // to be called before the work item is executed.
               //
               // This reference will be removed when the work item is executed.
               //
               ReferenceLine( pLine, TRUE );
               
               ScheduleWorkItem( pWorkItem );

               //
               // In this case this request will be completed later
               //
               status = NDIS_STATUS_PENDING;
            }
        }            

        //
        // Remove the reference added in line open
        //
        DereferenceLine( pLine );

    }

    TRACE( TL_N, TM_Tp, ("-TpCloseLine=$%x",status) );

    return status;
}


NDIS_STATUS 
TpCloseCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL pRequest,
    IN BOOLEAN fNotifyNDIS
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function is called to close a call.

    It will remove one of the references added in TpMakeCall() on the call
    context.
    
    It will be called from 2 places:
        1. When miniport receives an OID_TAPI_CLOSE_CALL.
           In this case, fNotifyNDIS will be set as TRUE.
           
        2. When miniport is halting, TpCloseLine() will call
           this function for every active call context.
   
Parameters:

    pAdapter _ A pointer to our adapter information structure.
    
    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_CLOSE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;

    } NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;


    fNotifyNDIS _ Indicates if NDIS needs to be notified about the completion 
                  of this operation
    
Return Values:

    NDIS_STATUS_SUCCESS: Call is succesfully closed and resources are freed.
    
    NDIS_STATUS_PENDING: Call close is pending on active calls.
                         When call is closed the owning line context will be
                         dereferenced.
                         
---------------------------------------------------------------------------*/
    
{
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CALL* pCall = NULL;
    BOOLEAN fLockReleased = FALSE;
    BOOLEAN fDereferenceCall = FALSE;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseCall") );
    
    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpCloseCall: Invalid parameter") );   

            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable,
                                         (NDIS_HANDLE) pRequest->hdCall );

        if ( pCall == NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpCloseCall: Invalid handle supplied") ); 
        
            break;
        }

        //
        // Now start closing the call
        //
        NdisAcquireSpinLock( &pCall->lockCall );

        /*
        if ( !fNotifyNDIS )
        {
            //
            // Request is not coming from TAPI directly, so see if we have informed TAPI of
            // a new call, because if we have then we can not close the call now, we should 
            // wait for TAPI to close it.
            //
            if ( pCall->htCall )
            {
                TRACE( TL_N, TM_Tp, ("TpCloseCall: Internal close request for a TAPI informed call, can not close now") );

                NdisReleaseSpinLock( &pCall->lockCall );

                status = NDIS_STATUS_FAILURE;

                break;
            }

        }
        */

        //
        // See if call is already closed or closing
        //
        if ( pCall->ulClFlags & CLBF_CallClosePending ||
             pCall->ulClFlags & CLBF_CallClosed )
        {
            TRACE( TL_N, TM_Tp, ("TpCloseCall: Close request on an already closed call") );
            
            NdisReleaseSpinLock( &pCall->lockCall );

            status = NDIS_STATUS_FAILURE;

            break;
        }

        //
        // Mark call if we need to notify NDIS about the completion of close
        //
        if ( fNotifyNDIS )
            pCall->ulClFlags |= CLBF_NotifyNDIS;

        //
        // Mark call as close pending
        //
        pCall->ulClFlags |= CLBF_CallClosePending;
        
        //
        // Drop the call first
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        //
        // Drop will take care of unbinding and cancelling the timer
        //
        {
            NDIS_TAPI_DROP DummyRequest;

            DummyRequest.hdCall = pRequest->hdCall;
            
            TpDropCall( pAdapter, &DummyRequest, 0 );
        }

        status = NDIS_STATUS_PENDING;

    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS ||
         status == NDIS_STATUS_PENDING )
    {
        LINE* pLine = pCall->pLine;
        
        //
        // Remove call from line's active call list, and decrement 
        // active call counter
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        RemoveHeadList( pCall->linkCalls.Blink );
    
        pLine->nActiveCalls--;
        
        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // We should now remove the call from the Tapi provider's call table,
        // and invalidate its' handle
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
        RemoveFromHandleTable( pAdapter->TapiProv.hCallTable,
                               (NDIS_HANDLE) pCall->hdCall );
    
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        //
        // Remove the reference for close call
        //
        DereferenceCall( pCall );
    }

    TRACE( TL_N, TM_Tp, ("-TpCloseCall=$%x",status) );
    
    return status;
}

NDIS_STATUS
TpDropCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_DROP pRequest,
    IN ULONG ulLineDisconnectMode
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called from a couple of places:
        1. If miniport receives an OID_TAPI_DROP_CALL request from TAPI.

        2. When NIC for the call is unbound, it will call TpUnbindCall(),
           and if the call is not dropped yet, it will call TpDropCall().

        3. When the call is in connect pending stage but the call needs
           to be dropped.

        4. When session is up and call receives a PADT packet from the peer.

    As this is a synchronous call, we do not need an fNotifyNDIS flag.
    
    CAUTION: All locks must be released before calling this function.
    
Parameters:

    pAdapter _ A pointer to our adaptert information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_DROP
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_DROP, *PNDIS_TAPI_DROP; 

    ulLineDisconnectMode _ Reason for dropping the call. This is reported 
                           back to TAPI in the appropriate state change
                           notification.

Return Values:

    NDIS_STATUS_SUCCESS: Call is succesfully dropped.
    
---------------------------------------------------------------------------*/   
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    CALL* pCall = NULL;
    BOOLEAN fSendPADT = FALSE;
    BINDING* pBinding = NULL;
    PPPOE_PACKET* pPacket = NULL;
    BOOLEAN fTapiNotifiedOfNewCall = FALSE;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpDropCall") );


    do
    {
        if ( pRequest == NULL || pAdapter == NULL )
        {
            TRACE( TL_A, TM_Tp, ("TpDropCall: Invalid parameter") );    


            status = NDIS_STATUS_TAPI_INVALPARAM;

            break;
        }

        //
        // Retrieve the pointer to call from the handle table
        //
        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                         (NDIS_HANDLE) pRequest->hdCall );

        if ( pCall == NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpDropCall: Invalid handle supplied") );  

            break;
        }

        NdisAcquireSpinLock( &pCall->lockCall );

        //
        // Make sure call is not dropped or closed previously
        //
        if ( pCall->ulClFlags & CLBF_CallDropped || pCall->ulClFlags & CLBF_CallClosed)
        {
            //
            // Call already dropped, quit
            //
            NdisReleaseSpinLock( &pCall->lockCall );

            TRACE( TL_N, TM_Tp, ("TpDropCall: Call already dropped or closed") );   

            break;
        }

        // 
        // Then we must be in open state either connected, or connect pending
        //
        ASSERT( pCall->ulClFlags & CLBF_CallOpen );

        pCall->ulClFlags &= ~CLBF_CallOpen;
        pCall->ulClFlags &= ~CLBF_CallConnectPending;
        pCall->ulClFlags |= CLBF_CallDropped;

        if ( pCall->htCall )
        {
            fTapiNotifiedOfNewCall = TRUE;
        }
        
        //
        // Save the binding pointer as we will detach call from it soon
        //
        pBinding = pCall->pBinding;

        if ( pCall->usSessionId && pBinding )
        {
            //
            // Prepare a PADT packet to send if:
            // - A session id is assigned to the call (which is different than fSessionUp)
            //   A session id is assigned to the call when the peer is informed about the session,
            //   however fSessionUp will be TRUE when NDISWAN is notified about the call
            //
            // - A binding exists to send the PADT packet
            //

            status = PacketInitializePADTToSend( &pPacket,
                                                 pCall->SrcAddr,
                                                 pCall->DestAddr,
                                                 pCall->usSessionId );

            if ( status == NDIS_STATUS_SUCCESS )
            {
                //
                // The following references are mandatory as in case PrSend() returns status pending,
                // they will be removed by PrSendComplete()
                //
                ReferencePacket( pPacket );
    
                ReferenceBinding( pBinding, TRUE );
    
                fSendPADT = TRUE;
            }

            //
            // Ignore the current status as this does not affect 
            // the status of the Drop operation.
            //
            status = NDIS_STATUS_SUCCESS;
        }

        //
        // Release the lock to take care of rest of the operation
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        //
        // Cancels the timer if it is set, otherwise it will not have any effect.
        //
        TimerQCancelItem( &gl_TimerQ, &pCall->timerTimeout );

        //
        // Send PADT here if we need to
        //
        if ( fSendPADT )
        {
            NDIS_STATUS SendStatus;

            SendStatus = PrSend( pBinding, pPacket );

            PacketFree( pPacket );
        }

        //
        // This will unbind us from the underlying NIC context if we are bound
        //
        if ( pBinding )
        {
            PrRemoveCallFromBinding( pBinding, pCall );
        }

        //
        // If TAPI was already notified of the call, move it to disconnected state
        //
        if ( fTapiNotifiedOfNewCall )
        {
            TpCallStateChangeHandler( pCall, 
                                      LINECALLSTATE_DISCONNECTED, 
                                      ulLineDisconnectMode );

        }
        
        //
        // Remove the reference added in TpMakeCall() that corresponds 
        // to the drop of the call.
        //
        DereferenceCall( pCall );

    } while ( FALSE );

    TRACE( TL_N, TM_Tp, ("-TpDropCall=$%x",status) );

    return status;
}


VOID 
TpCloseCallComplete(
    IN CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called only from DereferenceCall().
    It will only be called if ref count of the call drops to 0.

    When this function is called, it will deallocate the call context,
    and dereference the line context.
    
    If call contexts CLBF_NotifyNDIS flag is set, then it will call 
    NdisMQueryInformationComplete().

Parameters:

    pCall    _ A pointer to the call context that will be freed.
    
Return Values:

    None
                             
---------------------------------------------------------------------------*/
    
{
    LINE* pLine = NULL;

    ASSERT( VALIDATE_CALL( pCall ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseCallComplete") );

    //
    // No need to use spin locks here, as our ref count has dropped to 0, and
    // we should not be getting anymore requests on this call
    //
    pLine = pCall->pLine;

    //
    // CAUTION: Give an NDIS_MAC_LINE_DOWN indication here.
    //          It would be better to give this at drop time, but in that case
    //          there is a small timing window where NdisLinkHandle will be invalid 
    //          and although NDISWAN protects itself against invalid handles, it might
    //          assert in checked builds, so instead I will do it here.
    //         
    //          If problems occur with this approach, then I will do it at drop time.
    //
    if ( pCall->stateCall == CL_stateSessionUp )
    {
        NDIS_MAC_LINE_DOWN LineDownInfo;

        //
        // Fill-in the line down structure
        //
        LineDownInfo.NdisLinkContext = pCall->NdisLinkContext;

        //
        // Reflect the change onto the call
        //
        pCall->stateCall = CL_stateDisconnected;

        pCall->NdisLinkContext = 0;

        TRACE( TL_N, TM_Tp, ("TpCloseCallComplete: Indicate NDIS_STATUS_WAN_LINE_DOWN") );

        NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                             NDIS_STATUS_WAN_LINE_DOWN,
                             &LineDownInfo,
                             sizeof( NDIS_MAC_LINE_DOWN ) );    
         
    }

    if ( pCall->ulClFlags & CLBF_NotifyNDIS )
    {

        TRACE( TL_N, TM_Tp, ("TpCloseCallComplete: Notifying NDIS") );  

        //
        // The close call was a result of OID_TAPI_CLOSE_CALL request so complete the request.
        // There is a small timing window where this call may happen before MpSetInformation()
        // returns NDIS_STATUS_PENDING, but ArvindM says this is not a problem.
        //
        NdisMSetInformationComplete( pLine->pAdapter->MiniportAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    //
    // Clean up the call context
    //
    TpCallCleanup( pCall );

    //
    // Remove the reference on the owning line
    //
    DereferenceLine( pLine );

    TRACE( TL_N, TM_Tp, ("-TpCloseCallComplete") );

}


VOID 
TpCloseLineComplete(
    IN LINE* pLine
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to indicate that a line has been closed, and 
    the line context can be freed.

    It will only be called from DereferenceLine() if ref count on the line context
    drops to 0.

    It will also remove the reference on the owning tapi provider context.
    
Parameters:

    pLine    _ A pointer to our line information structure that is closed 
               and ready to be deallocated.
               
Return Values:

    None
---------------------------------------------------------------------------*/
{
    IN ADAPTER* pAdapter = NULL;

    ASSERT( VALIDATE_LINE( pLine ) );

    TRACE( TL_N, TM_Tp, ("+TpCloseLineComplete") );

    pAdapter = pLine->pAdapter;

    //
    // Decrement the tapi provider's active line counter
    //
    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    pAdapter->TapiProv.nActiveLines--;
    
    NdisReleaseSpinLock( &pAdapter->lockAdapter );

    //
    // Notify NDIS if necesarry
    //
    if ( pLine->ulLnFlags & LNBF_NotifyNDIS )
    {

        TRACE( TL_N, TM_Tp, ("TpCloseLineComplete: Notifying NDIS") );  

        //
        // Line was closed as a result of OID_TAPI_CLOSE request,
        // so indicate the completion.
        //
        NdisMSetInformationComplete( pAdapter->MiniportAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    //
    // Clean up line context
    //
    TpLineCleanup( pLine );

    //
    // Remove the reference on the owning tapi provider
    //
    DereferenceTapiProv( pAdapter );

    TRACE( TL_N, TM_Tp, ("-TpCloseLineComplete") );
}

VOID 
TpProviderShutdownComplete(
    IN ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will only be called from DereferenceTapiProv() if ref count
    on the tapi provider object drops to 0.

    It will do the necesarry clean up on the tapi provider context, and dereference
    the owning adapter context.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/
{
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderShutdownComplete") );

    //
    // See if we need to notify NDIS about the completion of shut down.
    //
    if ( pAdapter->TapiProv.ulTpFlags & TPBF_NotifyNDIS )
    {

        TRACE( TL_N, TM_Tp, ("TpProviderShutdownComplete: Notifying NDIS") );   

        //
        // Tapi was shut down as a result of OID_TAPI_PROVIDER_SHUTDOWN request,
        // so indicate the completion.
        //
        NdisMSetInformationComplete( pAdapter->MiniportAdapterHandle, NDIS_STATUS_SUCCESS );
    }

    //
    // Clean up tapi provider
    //
    TpProviderCleanup( pAdapter );

    //
    // Remove the reference on the owning adapter context
    //
    DereferenceAdapter( pAdapter );

    TRACE( TL_N, TM_Tp, ("-TpProviderShutdownComplete") );

}

VOID 
TpProviderCleanup(
    IN ADAPTER* pAdapter
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will do the necesarry clean up on the tapi provider deallocating
    all of its resources.
    
Parameters:

    pAdapter _ A pointer to our adapter information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpProviderCleanup") );

    if ( pAdapter )
    {
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
    
        if ( pAdapter->TapiProv.LineTable )
        {
            NdisFreeMemory( pAdapter->TapiProv.LineTable,
                            sizeof( LINE* ) * pAdapter->nMaxLines,
                            0 );
    
            pAdapter->TapiProv.LineTable = NULL;
        }
    
        if ( pAdapter->TapiProv.hCallTable )
        {
            FreeHandleTable( pAdapter->TapiProv.hCallTable );
            
            pAdapter->TapiProv.hCallTable = NULL;
        }
    
        NdisZeroMemory( &pAdapter->TapiProv, sizeof( pAdapter->TapiProv ) );
    
        NdisReleaseSpinLock( &pAdapter->lockAdapter );
    }

    TRACE( TL_N, TM_Tp, ("-TpProviderCleanup") );
}

VOID 
TpLineCleanup(
    IN LINE* pLine
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will do the necesarry clean up on the line context deallocating
    all of its resources.
    
Parameters:

    pLine _ A pointer to our line information structure.

Return Values:

    None
---------------------------------------------------------------------------*/   
{
    ASSERT( VALIDATE_LINE( pLine ) );

    TRACE( TL_N, TM_Tp, ("+TpLineCleanup") );

    NdisFreeSpinLock( &pLine->lockLine );

    FREE_LINE( pLine );

    TRACE( TL_N, TM_Tp, ("-TpLineCleanup") );
}

VOID 
TpCallCleanup(
    IN CALL* pCall 
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will do the necesarry clean up on the call context deallocating
    all of its resources.
    
Parameters:

    pCall _ A pointer to our call information structure.

Return Values:

    None
---------------------------------------------------------------------------*/       
{
    PPPOE_PACKET* pPacket = NULL;
    LIST_ENTRY* pLink = NULL;
    
    ASSERT( VALIDATE_CALL( pCall ) );

    TRACE( TL_N, TM_Tp, ("+TpCallCleanup") );

    NdisFreeSpinLock( &pCall->lockCall );

    if ( pCall->pSendPacket )
        PacketFree( pCall->pSendPacket );

    while ( pCall->nReceivedPackets > 0 )
    {
        pLink = RemoveHeadList( &pCall->linkReceivedPackets );

        pCall->nReceivedPackets--;

        pPacket = (PPPOE_PACKET*) CONTAINING_RECORD( pLink, PPPOE_PACKET, linkPackets );

        DereferencePacket( pPacket );
    }
    
    FREE_CALL( pCall );

    TRACE( TL_N, TM_Tp, ("-TpCallCleanup") );
}


NDIS_STATUS
TpSetDefaultMediaDetection(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request informs the miniport of the new set of media modes to detect 
    for the indicated line (replacing any previous set).

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulMediaModes;

    } NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION, *
PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALLINEHANDLE

---------------------------------------------------------------------------*/
{
    LINE* pLine = NULL;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpSetDefaultMediaDetection") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpSetDefaultMediaDetection: Invalid parameter") );    

        TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetection=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Retrieve the pointer to line context
    //
    pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );

    if ( pLine == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetection=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );

        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    //
    // We only accept this request if we are not in client mode, and digital media
    // is one of the modes proposed
    //
    if ( ( pRequest->ulMediaModes & LINEMEDIAMODE_DIGITALDATA ) && !pAdapter->fClientRole )
    {
        pLine->ulLnFlags |= LNBF_AcceptIncomingCalls;
    }
    else
    {
        pLine->ulLnFlags &= ~LNBF_AcceptIncomingCalls;
    }

    {
        //
        // Schedule a work item to reenumerate bindings
        //
        WORKITEM* pWorkItem = NULL;
        PVOID Args[4];
             
        Args[0] = (PVOID) BN_SetFiltersForMediaDetection;           // Is a set filters request
        Args[1] = (PVOID) pLine;
        Args[2] = (PVOID) pRequest;

        //
        // Allocate work item for reenumerating bindings
        //
        pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                   ExecBindingWorkItem,
                                   NULL,
                                   Args,
                                   BWT_workPrStartBinds );

        if ( pWorkItem ) 
        {
            //
            // Schedule work item.
            //
            // Note that we do not need to referencing becaue we are not completing
            // the query information request at this point, so nothing can go wrong
            // untill it is completed, and it will be done when the work item is executed.
            //
            ScheduleWorkItem( pWorkItem );
      
            //
            // In this case this request will be completed later
            //
            status = NDIS_STATUS_PENDING;
        }
    }

    TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetection=$%x",status) );

    return status;
}

VOID
TpSetDefaultMediaDetectionComplete(
   IN LINE* pLine,
   IN PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest   
   )
{
   TRACE( TL_N, TM_Tp, ("+TpSetDefaultMediaDetectionComplete") );

   NdisMQueryInformationComplete( pLine->pAdapter->MiniportAdapterHandle,
                                  NDIS_STATUS_SUCCESS );
                                  
   TRACE( TL_N, TM_Tp, ("-TpSetDefaultMediaDetectionComplete=$%x", NDIS_STATUS_SUCCESS) );
}


#define TAPI_EXT_VERSION                0x00010000

NDIS_STATUS
TpNegotiateExtVersion(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_NEGOTIATE_EXT_VERSION pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns the highest extension version number the service
    provider is willing to operate under for this device given the range of
    possible extension versions.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_NEGOTIATE_EXT_VERSION
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulLowVersion;
        IN  ULONG       ulHighVersion;
        OUT ULONG       ulExtVersion;
    } NDIS_TAPI_NEGOTIATE_EXT_VERSION, *PNDIS_TAPI_NEGOTIATE_EXT_VERSION;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION

---------------------------------------------------------------------------*/
{
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpNegotiateExtVersion") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpNegotiateExtVersion: Invalid parameter") ); 

        TRACE( TL_N, TM_Tp, ("-TpNegotiateExtVersion=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Make sure the miniport's version number is within the allowable
    // range requested by the caller.  
    //
    // We ignore the ulDeviceID because the version information applies 
    // to all devices on this adapter.
    //
    if ( TAPI_EXT_VERSION < pRequest->ulLowVersion ||
         TAPI_EXT_VERSION > pRequest->ulHighVersion )
    {
        TRACE( TL_N, TM_Tp, ("-TpNegotiateExtVersion=$%x",NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION) );
    
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    //
    // Looks like we're compatible, so tell the caller what we expect.
    //
    pRequest->ulExtVersion = TAPI_EXT_VERSION;

    TRACE( TL_N, TM_Tp, ("-TpNegotiateExtVersion=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpGetExtensionId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_EXTENSION_ID pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns the extension ID that the miniport supports for the
    indicated line device.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_EXTENSION_ID
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        OUT LINE_EXTENSION_ID   LineExtensionID;

    } NDIS_TAPI_GET_EXTENSION_ID, *PNDIS_TAPI_GET_EXTENSION_ID;

    typedef struct _LINE_EXTENSION_ID
    {
        ULONG   ulExtensionID0;
        ULONG   ulExtensionID1;
        ULONG   ulExtensionID2;
        ULONG   ulExtensionID3;

    } LINE_EXTENSION_ID, *PLINE_EXTENSION_ID;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_NODRIVER

---------------------------------------------------------------------------*/
{
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetExtensionId") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetExtensionId: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpGetExtensionId=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Retrieve the handle to line context
    //
    hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );
    
    if ( hdLine == INVALID_LINE_HANDLE )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetExtensionId=$%x",NDIS_STATUS_TAPI_NODRIVER) );
        
        return NDIS_STATUS_TAPI_NODRIVER;
    }
    
    //
    // This driver does not support any extensions, so we return zeros.
    //
    pRequest->LineExtensionID.ulExtensionID0 = 0;
    pRequest->LineExtensionID.ulExtensionID1 = 0;
    pRequest->LineExtensionID.ulExtensionID2 = 0;
    pRequest->LineExtensionID.ulExtensionID3 = 0;

    TRACE( TL_N, TM_Tp, ("-TpGetExtensionId=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpGetAddressStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ADDRESS_STATUS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request queries the specified address for its current status.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        OUT LINE_ADDRESS_STATUS LineAddressStatus;

    } NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;

    typedef struct _LINE_ADDRESS_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulNumInUse;
        ULONG   ulNumActiveCalls;
        ULONG   ulNumOnHoldCalls;
        ULONG   ulNumOnHoldPendCalls;
        ULONG   ulAddressFeatures;

        ULONG   ulNumRingsNoAnswer;
        ULONG   ulForwardNumEntries;
        ULONG   ulForwardSize;
        ULONG   ulForwardOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID

---------------------------------------------------------------------------*/
{
    LINE* pLine = NULL;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetAddressStatus") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetAddressStatus: Invalid parameter") );    

        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    //
    // Retrieve the pointer to line context
    //
    pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );

    if ( pLine == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
    
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    pRequest->LineAddressStatus.ulNeededSize = sizeof( LINE_ADDRESS_STATUS );

    if ( pRequest->LineAddressStatus.ulTotalSize < pRequest->LineAddressStatus.ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_INVALID_LENGTH) );
    
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineAddressStatus.ulUsedSize = pRequest->LineAddressStatus.ulNeededSize;
    
    //
    // Make sure the address is within range - we only support one per line.
    //
    if ( pRequest->ulAddressID > 1 )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_TAPI_INVALADDRESSID) );

        return NDIS_STATUS_TAPI_INVALADDRESSID;
    }

    //
    // Return the current status information for the address
    //
    pRequest->LineAddressStatus.ulNumInUse = ( pLine->nActiveCalls > 0 ) ? 1 : 0;
            
    pRequest->LineAddressStatus.ulNumActiveCalls = pLine->nActiveCalls;
            
    pRequest->LineAddressStatus.ulAddressFeatures = ( pLine->nActiveCalls < pLine->nMaxCalls ) ? 
                                                    LINEADDRFEATURE_MAKECALL : 
                                                    0;
                
    pRequest->LineAddressStatus.ulNumRingsNoAnswer = 999;

    TRACE( TL_N, TM_Tp, ("-TpGetAddressStatus=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

#define TAPI_DEVICECLASS_NAME        "tapi/line"
#define TAPI_DEVICECLASS_ID          1
#define NDIS_DEVICECLASS_NAME        "ndis"
#define NDIS_DEVICECLASS_ID          2

NDIS_STATUS
TpGetId(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_ID pRequest,
    IN ULONG ulRequestLength
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns a device ID for the specified device class
    associated with the selected line, address or call.

    Currently, there are two types of this request that must be supported by WAN 
    NIC drivers:

    1.  IN DeviceClass = "ndis"                 // case insensitive
        IN ulSelect = LINECALLSELECT_CALL
        IN hdCall = ActiveCallHandle
        OUT DeviceID = ConnectionWrapperID 

        DeviceID should be set to the NdisLinkContext handle returned by NDISWAN in 
        the NDIS_MAC_LINE_UP structure for the initial NDIS_STATUS_WAN_LINE_UP 
        indication to establish the link.
    
        The miniport must make the initial line-up indication to establish a link (or 
        open a data channel on a line) before returning from this request in order to 
        supply this DeviceID value. 
    
    2.  IN DeviceClass = "tapi/line"            // case insensitive
        IN ulSelect = LINECALLSELECT_LINE
        IN hdLine = OpenLineHandle
        OUT DeviceID = ulDeviceID 

        DeviceID will be set to the miniport-determined DeviceID associated with the 
        line handle.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_ID
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulAddressID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulSelect;
        IN  ULONG       ulDeviceClassSize;
        IN  ULONG       ulDeviceClassOffset;
        OUT VAR_STRING  DeviceID;

    } NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;

    typedef struct _VAR_STRING
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulStringFormat;
        ULONG   ulStringSize;
        ULONG   ulStringOffset;

    } VAR_STRING, *PVAR_STRING;

   ulRequestLength _ Length of the request buffer

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALDEVICECLASS
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLHANDLE
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    BOOLEAN fNotifyNDIS = FALSE;
    
    LINE* pLine = NULL;
    CALL* pCall = NULL;

    UINT DeviceClass;

    PUCHAR IDPtr;
    UINT  IDLength;
    ULONG_PTR DeviceID;

    TRACE( TL_N, TM_Tp, ("+TpGetId") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetId: Invalid parameter") );   

        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if ( pRequest->ulDeviceClassOffset + pRequest->ulDeviceClassSize > ulRequestLength )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if ( pRequest->ulSelect == LINECALLSELECT_LINE )
    {          

        if ( ( pRequest->ulDeviceClassSize == sizeof(TAPI_DEVICECLASS_NAME) ) &&
              ( _strnicmp(
                         (PCHAR) pRequest + pRequest->ulDeviceClassOffset, 
                         TAPI_DEVICECLASS_NAME, 
                         pRequest->ulDeviceClassSize
                         ) == 0 ) )
        {
            DeviceClass = TAPI_DEVICECLASS_ID;

            //
            // Do the size check up front
            //
            IDLength = sizeof(DeviceID);
            
            pRequest->DeviceID.ulNeededSize = sizeof(VAR_STRING) + IDLength;
            
            if ( pRequest->DeviceID.ulTotalSize < pRequest->DeviceID.ulNeededSize )
            {
                TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_INVALID_LENGTH) );
     
                return NDIS_STATUS_INVALID_LENGTH;
            }
 
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;

        }
        else    // UNSUPPORTED DEVICE CLASS
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALDEVICECLASS) );
        
            return NDIS_STATUS_TAPI_INVALDEVICECLASS;
        }

    }        
    else if ( pRequest->ulSelect == LINECALLSELECT_CALL )
    {

        if ( ( pRequest->ulDeviceClassSize == sizeof(NDIS_DEVICECLASS_NAME) ) &&
              ( _strnicmp(
                   (PCHAR) pRequest + pRequest->ulDeviceClassOffset, 
                   NDIS_DEVICECLASS_NAME, 
                   pRequest->ulDeviceClassSize
                   ) == 0 ) )
        {
            DeviceClass = NDIS_DEVICECLASS_ID;

            //
            // Do the size check up front
            //
            IDLength = sizeof(DeviceID);
            
            pRequest->DeviceID.ulNeededSize = sizeof(VAR_STRING) + IDLength;
            
            if ( pRequest->DeviceID.ulTotalSize < pRequest->DeviceID.ulNeededSize )
            {
                TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_INVALID_LENGTH) );
     
                return NDIS_STATUS_INVALID_LENGTH;
            }
 
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;

        }        
        else    // UNSUPPORTED DEVICE CLASS
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALDEVICECLASS) );
        
            return NDIS_STATUS_TAPI_INVALDEVICECLASS;
        }

    }        

    //
    // Find the link structure associated with the request/deviceclass.
    //
    if ( pRequest->ulSelect == LINECALLSELECT_LINE )
    {
        ASSERT( DeviceClass == TAPI_DEVICECLASS_ID );
        ASSERT( IDLength == sizeof( DeviceID ) );    
        //
        // Retrieve the pointer to line context
        //
        pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );
    
        if ( pLine == NULL )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
            
            return NDIS_STATUS_TAPI_INVALLINEHANDLE;
        }

        //
        // TAPI just wants the ulDeviceID for this line.
        //
        DeviceID = (ULONG) pLine->hdLine + pAdapter->TapiProv.ulDeviceIDBase ;
        IDPtr = (PUCHAR) &DeviceID;
        
    }
    else if ( pRequest->ulSelect == LINECALLSELECT_ADDRESS )
    {
    
        //
        // Retrieve the pointer to line context
        //
        pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );
    
        if ( pLine == NULL )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
            
            return NDIS_STATUS_TAPI_INVALLINEHANDLE;
        }


        if ( pRequest->ulAddressID > 1 )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALADDRESSID) );

            return NDIS_STATUS_TAPI_INVALADDRESSID;
        }
        
        //
        // Currently, there is no defined return value for this case...
        // This is just a place holder for future extensions.
        //
        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALDEVICECLASS) );
        
        return NDIS_STATUS_TAPI_INVALDEVICECLASS;
        
    }
    else if ( pRequest->ulSelect == LINECALLSELECT_CALL )
    {
        BOOLEAN fCallReferenced = FALSE;
        
        ASSERT( DeviceClass == NDIS_DEVICECLASS_ID );
        ASSERT( IDLength == sizeof( DeviceID ) );    

        //
        // Retrieve the pointer to call context
        //
        pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                         (NDIS_HANDLE) pRequest->hdCall );
    
        if ( pCall == NULL )
        {
            TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_TAPI_INVALLINEHANDLE) );
            
            return NDIS_STATUS_TAPI_INVALLINEHANDLE;
        }

        //
        // We can only return this if we have a valid NdisLinkContext,
        // and if our session is up, then our link handle must be valid
        //
  
        NdisAcquireSpinLock( &pCall->lockCall );
  
        if ( pCall->ulTapiCallState == LINECALLSTATE_CONNECTED )
        {
            //
            // Give a line-up indication to NDISWAN and obtain its handle
            //
            NDIS_MAC_LINE_UP LineUpInfo;
  
            //
            // Fill-in the line up structure
            //
            NdisZeroMemory( &LineUpInfo, sizeof( LineUpInfo ) );
            
            LineUpInfo.LinkSpeed    = pCall->ulSpeed;
            LineUpInfo.Quality      = NdisWanErrorControl;
            LineUpInfo.SendWindow   = 0;
            
            LineUpInfo.ConnectionWrapperID = (NDIS_HANDLE) pCall->htCall;
            LineUpInfo.NdisLinkHandle      = (NDIS_HANDLE) pCall->hdCall;
            LineUpInfo.NdisLinkContext     = 0;
  
            //
            // Reference the call once and deref it just after indication of status
            // to NDISWAN
            //
            ReferenceCall( pCall, FALSE );
  
            fCallReferenced = TRUE;
  
            NdisReleaseSpinLock( &pCall->lockCall );
  
            TRACE( TL_N, TM_Tp, ("TpGetId: Indicate NDIS_STATUS_WAN_LINE_UP") );
  
            NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                                 NDIS_STATUS_WAN_LINE_UP,
                                 &LineUpInfo,
                                 sizeof( NDIS_MAC_LINE_UP ) );  
  
            NdisAcquireSpinLock( &pCall->lockCall );                                     
  
            //
            // Set state to indicate that session is established
            //
            pCall->stateCall = CL_stateSessionUp;
  
            //
            // Set link context obtained from NDISWAN on the call context
            //
            pCall->NdisLinkContext = LineUpInfo.NdisLinkContext;
            
            DeviceID = (ULONG_PTR) pCall->NdisLinkContext;
            IDPtr = (PUCHAR) &DeviceID;
  
            //
            // Since the session is up, schedule the MpIndicateReceivedPackets() handler 
            //
            MpScheduleIndicateReceivedPacketsHandler( pCall );
  
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            status = NDIS_STATUS_TAPI_OPERATIONUNAVAIL;
        }
  
        NdisReleaseSpinLock( &pCall->lockCall );
  
        if ( fCallReferenced )
        {
           DereferenceCall( pCall );
        }
            
    }
    else // UNSUPPORTED SELECT REQUEST
    {
        TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",NDIS_STATUS_FAILURE) );         
        
        return NDIS_STATUS_FAILURE;
    }    

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // Now we need to place the device ID.
        //
        pRequest->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
        pRequest->DeviceID.ulStringSize   = IDLength;
        pRequest->DeviceID.ulStringOffset = sizeof(VAR_STRING);
  
        NdisMoveMemory(
                (PCHAR) &pRequest->DeviceID + sizeof(VAR_STRING),
                IDPtr,
                IDLength
                );
    }

    if ( fNotifyNDIS )
    {
        TRACE( TL_N, TM_Tp, ("TpGetId:Completing delayed request") );           

        NdisMQueryInformationComplete( pCall->pLine->pAdapter->MiniportAdapterHandle, status );

    }
    
    TRACE( TL_N, TM_Tp, ("-TpGetId=$%x",status) );          
    
    return status;

}

#define TAPI_PROVIDER_STRING        "VPN\0RASPPPOE"
#define TAPI_LINE_NAME              "RAS PPPoE Line"
#define TAPI_LINE_NUM               "0000"

NDIS_STATUS
TpGetDevCaps(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_DEV_CAPS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request queries a specified line device to determine its telephony
    capabilities. The returned information is valid for all addresses on the
    line device.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_DEV_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulExtVersion;
        OUT LINE_DEV_CAPS   LineDevCaps;

    } NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;

    typedef struct _LINE_DEV_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulProviderInfoSize;
        ULONG   ulProviderInfoOffset;

        ULONG   ulSwitchInfoSize;
        ULONG   ulSwitchInfoOffset;

        ULONG   ulPermanentLineID;
        ULONG   ulLineNameSize;
        ULONG   ulLineNameOffset;
        ULONG   ulStringFormat;

        ULONG   ulAddressModes;
        ULONG   ulNumAddresses;
        ULONG   ulBearerModes;
        ULONG   ulMaxRate;
        ULONG   ulMediaModes;

        ULONG   ulGenerateToneModes;
        ULONG   ulGenerateToneMaxNumFreq;
        ULONG   ulGenerateDigitModes;
        ULONG   ulMonitorToneMaxNumFreq;
        ULONG   ulMonitorToneMaxNumEntries;
        ULONG   ulMonitorDigitModes;
        ULONG   ulGatherDigitsMinTimeout;
        ULONG   ulGatherDigitsMaxTimeout;

        ULONG   ulMedCtlDigitMaxListSize;
        ULONG   ulMedCtlMediaMaxListSize;
        ULONG   ulMedCtlToneMaxListSize;
        ULONG   ulMedCtlCallStateMaxListSize;

        ULONG   ulDevCapFlags;
        ULONG   ulMaxNumActiveCalls;
        ULONG   ulAnswerMode;
        ULONG   ulRingModes;
        ULONG   ulLineStates;

        ULONG   ulUUIAcceptSize;
        ULONG   ulUUIAnswerSize;
        ULONG   ulUUIMakeCallSize;
        ULONG   ulUUIDropSize;
        ULONG   ulUUISendUserUserInfoSize;
        ULONG   ulUUICallInfoSize;

        LINE_DIAL_PARAMS    MinDialParams;
        LINE_DIAL_PARAMS    MaxDialParams;
        LINE_DIAL_PARAMS    DefaultDialParams;

        ULONG   ulNumTerminals;
        ULONG   ulTerminalCapsSize;
        ULONG   ulTerminalCapsOffset;
        ULONG   ulTerminalTextEntrySize;
        ULONG   ulTerminalTextSize;
        ULONG   ulTerminalTextOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_DEV_CAPS, *PLINE_DEV_CAPS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_NODRIVER

---------------------------------------------------------------------------*/
{
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;
    CHAR szTapiLineNum[] = TAPI_LINE_NUM;
    CHAR *pBuf = NULL;
    ULONG ulDeviceId;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetDevCaps") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetDevCaps: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    //
    // Retrieve the handle to line context
    //
    hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );
    
    if ( hdLine == INVALID_LINE_HANDLE )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_TAPI_NODRIVER) );
        
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    pRequest->LineDevCaps.ulNeededSize   = sizeof( LINE_DEV_CAPS ) + 
                                           sizeof( TAPI_PROVIDER_STRING ) +
                                           ( sizeof( TAPI_LINE_NAME ) - 1 ) +
                                           sizeof( TAPI_LINE_NUM );

    if ( pRequest->LineDevCaps.ulTotalSize < pRequest->LineDevCaps.ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_INVALID_LENGTH) );
        
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineDevCaps.ulUsedSize = pRequest->LineDevCaps.ulNeededSize;
    
    pRequest->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID |
                                           LINEADDRESSMODE_DIALABLEADDR;

    pRequest->LineDevCaps.ulNumAddresses = 1;

    pRequest->LineDevCaps.ulBearerModes  = LINEBEARERMODE_DATA;

    pRequest->LineDevCaps.ulDevCapFlags  = LINEDEVCAPFLAGS_CLOSEDROP;

    pRequest->LineDevCaps.ulMaxNumActiveCalls = pAdapter->nCallsPerLine;

    pRequest->LineDevCaps.ulAnswerMode   = LINEANSWERMODE_DROP;

    pRequest->LineDevCaps.ulRingModes    = 1;

    pRequest->LineDevCaps.ulPermanentLineID = pRequest->ulDeviceID;

    pRequest->LineDevCaps.ulMaxRate      = 0;

    pRequest->LineDevCaps.ulMediaModes   = LINEMEDIAMODE_DIGITALDATA;

    //
    // Insert the provider string and enumerated line name into line dev caps
    //
    pRequest->LineDevCaps.ulStringFormat = STRINGFORMAT_ASCII;

    {
        INT i;
        
        //
        // Tack on the ProviderString to the end of the LineDevCaps structure
        //
        pRequest->LineDevCaps.ulProviderInfoSize = sizeof( TAPI_PROVIDER_STRING );
    
        pRequest->LineDevCaps.ulProviderInfoOffset = sizeof( pRequest->LineDevCaps );
    
        pBuf = ( (PUCHAR) &pRequest->LineDevCaps ) + pRequest->LineDevCaps.ulProviderInfoOffset;
        
        NdisMoveMemory( pBuf , TAPI_PROVIDER_STRING, sizeof( TAPI_PROVIDER_STRING ) );
    
        //
        // Tack on the LineName after the ProviderString
        //
        pRequest->LineDevCaps.ulLineNameSize = ( sizeof( TAPI_LINE_NAME ) - 1 ) + sizeof( TAPI_LINE_NUM );
    
        pRequest->LineDevCaps.ulLineNameOffset = pRequest->LineDevCaps.ulProviderInfoOffset +
                                                 pRequest->LineDevCaps.ulProviderInfoSize;
                                                 
        pBuf = ( (PUCHAR) &pRequest->LineDevCaps ) + pRequest->LineDevCaps.ulLineNameOffset;
    
        NdisMoveMemory( pBuf , TAPI_LINE_NAME, sizeof( TAPI_LINE_NAME ) );
    
        //
        // Tack on the line enumeration index at the end of the LineName
        //
        ulDeviceId = (ULONG) hdLine;
        
        //
        // Subtract 2: 1 for '\0' and 1 to adjust for array indexing
        //
        i = ( sizeof( TAPI_LINE_NUM ) / sizeof( CHAR ) ) - 2;
    
        while ( i >= 0 && ( ulDeviceId > 0 ) )
        {
                szTapiLineNum[i] = (UCHAR)( ( ulDeviceId % 10 ) + '0' );
                ulDeviceId /= 10;
                i--;
        }
        
        pBuf += ( sizeof( TAPI_LINE_NAME ) - 1 );
    
        NdisMoveMemory( pBuf, szTapiLineNum, sizeof( TAPI_LINE_NUM ) );
    }
    
    TRACE( TL_N, TM_Tp, ("-TpGetDevCaps=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpGetCallStatus(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_STATUS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns detailed information about the specified call.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_CALL_STATUS
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_STATUS    LineCallStatus;

    } NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;

    typedef struct _LINE_CALL_STATUS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulCallState;
        ULONG   ulCallStateMode;
        ULONG   ulCallPrivilege;
        ULONG   ulCallFeatures;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_STATUS, *PLINE_CALL_STATUS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

---------------------------------------------------------------------------*/
{
    CALL* pCall = NULL;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetCallStatus") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetCallStatus: Invalid parameter") );   

        TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) pRequest->hdCall );

    if ( pCall == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_TAPI_INVALCALLHANDLE) );
    
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    pRequest->LineCallStatus.ulNeededSize = sizeof( LINE_CALL_STATUS );

   if ( pRequest->LineCallStatus.ulTotalSize < pRequest->LineCallStatus.ulNeededSize )
   {
        TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_INVALID_LENGTH) );
    
        return NDIS_STATUS_INVALID_LENGTH;
   }

    pRequest->LineCallStatus.ulUsedSize = pRequest->LineCallStatus.ulNeededSize;

    pRequest->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ANSWER | LINECALLFEATURE_DROP;
    pRequest->LineCallStatus.ulCallPrivilege = LINECALLPRIVILEGE_OWNER;
    pRequest->LineCallStatus.ulCallState = pCall->ulTapiCallState;

    switch ( pRequest->LineCallStatus.ulCallState )
    {
        case LINECALLSTATE_DIALTONE:
        
            pRequest->LineCallStatus.ulCallStateMode = LINEDIALTONEMODE_NORMAL;

            break;
            
        case LINECALLSTATE_BUSY:
        
            pRequest->LineCallStatus.ulCallStateMode = LINEBUSYMODE_STATION;
            break;
            
        case LINECALLSTATE_DISCONNECTED:
        
            pRequest->LineCallStatus.ulCallStateMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
            
        default:
            break;
    }

    TRACE( TL_N, TM_Tp, ("-TpGetCallStatus=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
 }

//
// As we return the MAC addresses for caller and called station id's
// we set their size as 7 although a MAC address occupies 6 bytes.
// This is because TAPI overwrites the last bytes we return in these
// strings with a NULL character destroying the vaulable data.
// See bug: 313295
//
#define TAPI_STATION_ID_SIZE            ( 7 * sizeof( CHAR ) )

NDIS_STATUS
TpGetCallInfo(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_GET_CALL_INFO pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request returns detailed information about the specified call.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_CALL_INFO
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        OUT LINE_CALL_INFO  LineCallInfo;

    } NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;

    typedef struct _LINE_CALL_INFO
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   hLine;
        ULONG   ulLineDeviceID;
        ULONG   ulAddressID;

        ULONG   ulBearerMode;
        ULONG   ulRate;
        ULONG   ulMediaMode;

        ULONG   ulAppSpecific;
        ULONG   ulCallID;
        ULONG   ulRelatedCallID;
        ULONG   ulCallParamFlags;
        ULONG   ulCallStates;

        ULONG   ulMonitorDigitModes;
        ULONG   ulMonitorMediaModes;
        LINE_DIAL_PARAMS    DialParams;

        ULONG   ulOrigin;
        ULONG   ulReason;
        ULONG   ulCompletionID;
        ULONG   ulNumOwners;
        ULONG   ulNumMonitors;

        ULONG   ulCountryCode;
        ULONG   ulTrunk;

        ULONG   ulCallerIDFlags;
        ULONG   ulCallerIDSize;
        ULONG   ulCallerIDOffset;
        ULONG   ulCallerIDNameSize;
        ULONG   ulCallerIDNameOffset;

        ULONG   ulCalledIDFlags;
        ULONG   ulCalledIDSize;
        ULONG   ulCalledIDOffset;
        ULONG   ulCalledIDNameSize;
        ULONG   ulCalledIDNameOffset;

        ULONG   ulConnectedIDFlags;
        ULONG   ulConnectedIDSize;
        ULONG   ulConnectedIDOffset;
        ULONG   ulConnectedIDNameSize;
        ULONG   ulConnectedIDNameOffset;

        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectionIDSize;
        ULONG   ulRedirectionIDOffset;
        ULONG   ulRedirectionIDNameSize;
        ULONG   ulRedirectionIDNameOffset;

        ULONG   ulRedirectingIDFlags;
        ULONG   ulRedirectingIDSize;
        ULONG   ulRedirectingIDOffset;
        ULONG   ulRedirectingIDNameSize;
        ULONG   ulRedirectingIDNameOffset;

        ULONG   ulAppNameSize;
        ULONG   ulAppNameOffset;

        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;
        ULONG   ulCommentOffset;

        ULONG   ulDisplaySize;
        ULONG   ulDisplayOffset;

        ULONG   ulUserUserInfoSize;
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;
        ULONG   ulLowLevelCompOffset;

        ULONG   ulChargingInfoSize;
        ULONG   ulChargingInfoOffset;

        ULONG   ulTerminalModesSize;
        ULONG   ulTerminalModesOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

    } LINE_CALL_INFO, *PLINE_CALL_INFO;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_INVALCALLHANDLE

---------------------------------------------------------------------------*/
{
    CALL* pCall = NULL;
    PLINE_CALL_INFO pLineCallInfo = NULL;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetCallInfo") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetCallInfo: Invalid parameter") ); 

        TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pLineCallInfo = &pRequest->LineCallInfo;

    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) pRequest->hdCall );

    if ( pCall == NULL )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_TAPI_INVALCALLHANDLE) );

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    pLineCallInfo->ulNeededSize = sizeof( LINE_CALL_INFO ) +
                                  TAPI_STATION_ID_SIZE  +
                                  TAPI_STATION_ID_SIZE;

    if ( pLineCallInfo->ulTotalSize < pLineCallInfo->ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_INVALID_LENGTH) );

        return NDIS_STATUS_INVALID_LENGTH;
    }

    pLineCallInfo->ulUsedSize = pLineCallInfo->ulNeededSize;

    pLineCallInfo->ulLineDeviceID = (ULONG) pCall->pLine->hdLine + 
                                    pCall->pLine->pAdapter->TapiProv.ulDeviceIDBase;
    pLineCallInfo->ulAddressID = 0;

    pLineCallInfo->ulBearerMode = LINEBEARERMODE_DATA;
    pLineCallInfo->ulRate = pCall->ulSpeed;
    pLineCallInfo->ulMediaMode = LINEMEDIAMODE_DIGITALDATA;

    pLineCallInfo->ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    pLineCallInfo->ulCallStates = TAPI_LINECALLSTATES_SUPPORTED;

    pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCallerIDSize = 0;
    pLineCallInfo->ulCalledIDOffset = 0;
    pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCalledIDSize = 0;

    //
    // Set the caller and called station id information for both
    // incoming and outgoing calls.
    //
    {
        CHAR *pBuf = NULL;

        //
        // Copy the caller id information
        //
        pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;
        pLineCallInfo->ulCallerIDSize = TAPI_STATION_ID_SIZE;
        pLineCallInfo->ulCallerIDOffset = sizeof(LINE_CALL_INFO);

        pBuf = ( (PUCHAR) pLineCallInfo ) + pLineCallInfo->ulCallerIDOffset;
        NdisMoveMemory( pBuf, pCall->DestAddr, TAPI_STATION_ID_SIZE );

        //
        // Copy the called id information
        //
        pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_ADDRESS;
        pLineCallInfo->ulCalledIDSize = TAPI_STATION_ID_SIZE;
        pLineCallInfo->ulCalledIDOffset = pLineCallInfo->ulCallerIDOffset + 
                                          pLineCallInfo->ulCallerIDSize;

        pBuf = ( (PUCHAR) pLineCallInfo ) + pLineCallInfo->ulCalledIDOffset;
        NdisMoveMemory( pBuf, pCall->SrcAddr, TAPI_STATION_ID_SIZE );

        pLineCallInfo->ulUsedSize = pLineCallInfo->ulNeededSize;
    }

    TRACE( TL_N, TM_Tp, ("-TpGetCallInfo=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

#define TAPI_LINE_ADDR_STRING           "PPPoE VPN"

NDIS_STATUS
TpGetAddressCaps(
    IN ADAPTER* pAdapter,
    PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request queries the specified address on the specified line device
    to determine its telephony capabilities.

Parameters:

    pAdapter _ A pointer ot our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS
    {
        IN  ULONG       ulRequestID;
        IN  ULONG       ulDeviceID;
        IN  ULONG       ulAddressID;
        IN  ULONG       ulExtVersion;
        OUT LINE_ADDRESS_CAPS   LineAddressCaps;

    } NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;

    typedef struct _LINE_ADDRESS_CAPS
    {
        ULONG   ulTotalSize;
        ULONG   ulNeededSize;
        ULONG   ulUsedSize;

        ULONG   ulLineDeviceID;

        ULONG   ulAddressSize;
        ULONG   ulAddressOffset;

        ULONG   ulDevSpecificSize;
        ULONG   ulDevSpecificOffset;

        ULONG   ulAddressSharing;
        ULONG   ulAddressStates;
        ULONG   ulCallInfoStates;
        ULONG   ulCallerIDFlags;
        ULONG   ulCalledIDFlags;
        ULONG   ulConnectedIDFlags;
        ULONG   ulRedirectionIDFlags;
        ULONG   ulRedirectingIDFlags;
        ULONG   ulCallStates;
        ULONG   ulDialToneModes;
        ULONG   ulBusyModes;
        ULONG   ulSpecialInfo;
        ULONG   ulDisconnectModes;

        ULONG   ulMaxNumActiveCalls;
        ULONG   ulMaxNumOnHoldCalls;
        ULONG   ulMaxNumOnHoldPendingCalls;
        ULONG   ulMaxNumConference;
        ULONG   ulMaxNumTransConf;

        ULONG   ulAddrCapFlags;
        ULONG   ulCallFeatures;
        ULONG   ulRemoveFromConfCaps;
        ULONG   ulRemoveFromConfState;
        ULONG   ulTransferModes;

        ULONG   ulForwardModes;
        ULONG   ulMaxForwardEntries;
        ULONG   ulMaxSpecificEntries;
        ULONG   ulMinFwdNumRings;
        ULONG   ulMaxFwdNumRings;

        ULONG   ulMaxCallCompletions;
        ULONG   ulCallCompletionConds;
        ULONG   ulCallCompletionModes;
        ULONG   ulNumCompletionMessages;
        ULONG   ulCompletionMsgTextEntrySize;
        ULONG   ulCompletionMsgTextSize;
        ULONG   ulCompletionMsgTextOffset;

    } LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION
    NDIS_STATUS_TAPI_NODRIVER

---------------------------------------------------------------------------*/        
{
    HDRV_LINE hdLine = INVALID_LINE_HANDLE;

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpGetAddressCaps") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpGetAddressCaps: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    //
    // Retrieve the handle to line context
    //
    hdLine = TpGetHdLineFromDeviceId( pAdapter, pRequest->ulDeviceID );
    
    if ( hdLine == INVALID_LINE_HANDLE )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_NODRIVER) );
        
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    //
    // Verify the address id
    //
    if ( pRequest->ulAddressID != 0 )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_INVALADDRESSID) );
        
        return NDIS_STATUS_TAPI_INVALADDRESSID;
    }

    //
    // Verify the extension versions
    //
    if ( pRequest->ulExtVersion != 0 &&
         pRequest->ulExtVersion != TAPI_EXT_VERSION)
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION) );
        
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    pRequest->LineAddressCaps.ulNeededSize = sizeof( LINE_ADDRESS_CAPS ) +
                                             sizeof( TAPI_LINE_ADDR_STRING );
    
    if ( pRequest->LineAddressCaps.ulTotalSize < pRequest->LineAddressCaps.ulNeededSize )
    {
        TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_INVALID_LENGTH) );

        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineAddressCaps.ulUsedSize = pRequest->LineAddressCaps.ulNeededSize;

    pRequest->LineAddressCaps.ulDialToneModes     = LINEDIALTONEMODE_NORMAL;
  
    pRequest->LineAddressCaps.ulSpecialInfo       = LINESPECIALINFO_UNAVAIL;
  
    pRequest->LineAddressCaps.ulDisconnectModes   = LINEDISCONNECTMODE_NORMAL |                                                    
                                                    LINEDISCONNECTMODE_UNKNOWN |
                                                    LINEDISCONNECTMODE_BUSY |
                                                    LINEDISCONNECTMODE_NOANSWER | 
                                                    LINEDISCONNECTMODE_UNREACHABLE |
                                                    LINEDISCONNECTMODE_BADADDRESS |
                                                    LINEDISCONNECTMODE_INCOMPATIBLE |
                                                    LINEDISCONNECTMODE_REJECT | 
                                                    LINEDISCONNECTMODE_NODIALTONE;
  
    pRequest->LineAddressCaps.ulMaxNumActiveCalls = pAdapter->nCallsPerLine;
    
    pRequest->LineAddressCaps.ulMaxNumTransConf   = 1;
    pRequest->LineAddressCaps.ulAddrCapFlags      = LINEADDRCAPFLAGS_DIALED;
  
    pRequest->LineAddressCaps.ulCallFeatures      = LINECALLFEATURE_ACCEPT |
                                                    LINECALLFEATURE_ANSWER |
                                                    LINECALLFEATURE_COMPLETECALL |
                                                    LINECALLFEATURE_DIAL |
                                                    LINECALLFEATURE_DROP;
  
    pRequest->LineAddressCaps.ulLineDeviceID      = pRequest->ulDeviceID;
    pRequest->LineAddressCaps.ulAddressSharing    = LINEADDRESSSHARING_PRIVATE;
    pRequest->LineAddressCaps.ulAddressStates     = 0;
  
    //
    // List of all possible call states.
    //
    pRequest->LineAddressCaps.ulCallStates        = TAPI_LINECALLSTATES_SUPPORTED;
    
    pRequest->LineAddressCaps.ulAddressSize = sizeof( TAPI_LINE_ADDR_STRING );
    pRequest->LineAddressCaps.ulAddressOffset = sizeof( LINE_ADDRESS_CAPS );

    {
        CHAR* pBuf;

        pBuf = ( (PUCHAR) &pRequest->LineAddressCaps ) + sizeof( LINE_ADDRESS_CAPS );
        NdisMoveMemory( pBuf, TAPI_LINE_ADDR_STRING, sizeof( TAPI_LINE_ADDR_STRING ) );
    }

    TRACE( TL_N, TM_Tp, ("-TpGetAddressCaps=$%x",NDIS_STATUS_SUCCESS) );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpSetStatusMessages(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request enables the Connection Wrapper to specify which notification 
    messages the miniport should generate for events related to status changes 
    for the specified line or any of its addresses. By default, address and 
    line status reporting is initially disabled for a line.

Parameters:

    pAdapter _ A pointer to our adapter information structure.

    pRequest _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  ULONG       ulLineStates;
        IN  ULONG       ulAddressStates;

    } NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALLINESTATE
    NDIS_STATUS_TAPI_INVALADDRESSSTATE

---------------------------------------------------------------------------*/
{

    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpSetStatusMessages") );
    //
    // We do not send any line or address state change notifications at all,
    // so we do not care about it. 
    // 
    // We care about call notification messages and they are always on by default.
    //

    TRACE( TL_N, TM_Tp, ("-TpSetStatusMessages=$%x",NDIS_STATUS_SUCCESS) );
    
    return NDIS_STATUS_SUCCESS;
}

VOID
TpCallStateChangeHandler(
    IN CALL* pCall,
    IN ULONG ulCallState,
    IN ULONG ulStateParam
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This routine will indicate the given LINECALLSTATE to the Connection
    wrapper if the event has been enabled by the wrapper. Otherwise the state
    information is saved, but no indication is made.


    LINECALLSTATE_ Constants: The LINECALLSTATE_ bit-flag constants describe the
                              call states a call can be in. 

    LINECALLSTATE_ACCEPTED:
        The call was in the offering state and has been accepted. This indicates to 
        other (monitoring) applications that the current owner application has 
        claimed responsibility for answering the call. In ISDN, the accepted state is 
        entered when the called-party equipment sends a message to the switch 
        indicating that it is willing to present the call to the called person. This 
        has the side effect of alerting (ringing) the users at both ends of the call. 
        An incoming call can always be immediately answered without first being 
        separately accepted. 
    
    LINECALLSTATE_BUSY 
        The call is receiving a busy tone. A busy tone indicates that the call cannot 
        be completed either a circuit (trunk) or the remote party's station are in use
        . See LINEBUSYMODE_ Constants. 
        
    LINECALLSTATE_CONFERENCED 
        The call is a member of a conference call and is logically in the connected 
        state. 
        
    LINECALLSTATE_CONNECTED 
        The call has been established and the connection is made. Information is able 
        to flow over the call between the originating address and the destination 
        address. 
        
    LINECALLSTATE_DIALING 
        The originator is dialing digits on the call. The dialed digits are collected 
        by the switch. Note that neither lineGenerateDigits nor 
        TSPI_lineGenerateDigits will place the line into the dialing state. 
        
    LINECALLSTATE_DIALTONE 
        The call is receiving a dial tone from the switch, which means that the 
        switch is ready to receive a dialed number. See LINEDIALTONEMODE_ Constants 
        for identifiers of special dial tones, such as a stutter tone of normal voice 
        mail. 
        
    LINECALLSTATE_DISCONNECTED 
        The remote party has disconnected from the call. 
        
    LINECALLSTATE_IDLE 
        The call exists but has not been connected. No activity exists on the call, 
        which means that no call is currently active. A call can never transition 
        into the idle state. 
        
    LINECALLSTATE_OFFERING 
        The call is being offered to the station, signaling the arrival of a new call
        . The offering state is not the same as causing a phone or computer to ring. 
        In some environments, a call in the offering state does not ring the user 
        until the switch instructs the line to ring. An example use might be where an 
        incoming call appears on several station sets but only the primary address 
        rings. The instruction to ring does not affect any call states. 
        
    LINECALLSTATE_ONHOLD 
        The call is on hold by the switch. This frees the physical line, which allows 
        another call to use the line. 
        
    LINECALLSTATE_ONHOLDPENDCONF 
        The call is currently on hold while it is being added to a conference. 

    LINECALLSTATE_ONHOLDPENDTRANSFER 
        The call is currently on hold awaiting transfer to another number. 

    LINECALLSTATE_PROCEEDING 
        Dialing has completed and the call is proceeding through the switch or 
        telephone network. This occurs after dialing is complete and before the call 
        reaches the dialed party, as indicated by ringback, busy, or answer. 

    LINECALLSTATE_RINGBACK 
        The station to be called has been reached, and the destination's switch is 
        generating a ring tone back to the originator. A ringback means that the 
        destination address is being alerted to the call. 

    LINECALLSTATE_SPECIALINFO 
        The call is receiving a special information signal, which precedes a 
        prerecorded announcement indicating why a call cannot be completed. See 
        LINESPECIALINFO_ Constants. 
        
    LINECALLSTATE_UNKNOWN 
        The call exists, but its state is currently unknown. This may be the result 
        of poor call progress detection by the service provider. A call state message 
        with the call state set to unknown may also be generated to inform the TAPI 
        DLL about a new call at a time when the actual call state of the call is not 
        exactly known. 

Parameters:

    pCall _ A pointer to our call information structure.

    ulCallState _ The LINECALLSTATE event to be posted to TAPI/WAN.

    ulStateParam _ This value depends on the event being posted, and some
                   events will pass in zero if they don't use this parameter.

Return Values:

    None

---------------------------------------------------------------------------*/
{
    BOOLEAN fIndicateStatus = FALSE;
    NDIS_TAPI_EVENT TapiEvent;
    ULONG ulOldCallState;
    
    ASSERT( VALIDATE_CALL( pCall ) );

    TRACE( TL_N, TM_Tp, ("+TpCallStateChangeHandler") );

    NdisAcquireSpinLock( &pCall->lockCall );

    do 
    {
        //
        // Check if we have a valid htCall member, otherwise it means we are already done,
        // so we should not give any more notifications to TAPI about state changes
        //
        if ( pCall->htCall == (HTAPI_CALL) NULL )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: No valid htCall") );

            break;
        }

        //
        // A connect notification can come only after a PROCEEDING or OFFERING state
        // is reached
        //
        if ( ulCallState == LINECALLSTATE_CONNECTED && 
             ( pCall->ulTapiCallState != LINECALLSTATE_OFFERING &&
               pCall->ulTapiCallState != LINECALLSTATE_PROCEEDING ) )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: Invalid order of state change") );
            
            break;
        }

        //
        // If the new state is the same as old state, just return
        //
        if ( pCall->ulTapiCallState == ulCallState )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: No state change") );

            break;
        }

        //
        // Otherwise, change the calls state, and 
        // make a notification to TAPI about the new state
        //
        ulOldCallState = pCall->ulTapiCallState;
        pCall->ulTapiCallState = ulCallState;
        
        TapiEvent.htLine = pCall->pLine->htLine;
        TapiEvent.htCall = pCall->htCall;   
    
        TapiEvent.ulMsg  = LINE_CALLSTATE;
        
        TapiEvent.ulParam1 = ulCallState;
        TapiEvent.ulParam2 = ulStateParam;
        TapiEvent.ulParam3 = LINEMEDIAMODE_DIGITALDATA; 

        fIndicateStatus = TRUE;

        if ( ulCallState == LINECALLSTATE_CONNECTED )
        {
            ADAPTER* pAdapter = pCall->pLine->pAdapter;
            
            //
            // Since the call is connected, reset CLBF_CallConnectPending bit
            //
            pCall->ulClFlags &= ~CLBF_CallConnectPending;

            //
            // Also prepare the WanLinkInfo structure of call context now
            // as right after we indicate line-up to NDISWAN, it will query us
            // for this info.
            //
            NdisZeroMemory( &pCall->NdisWanLinkInfo, sizeof( pCall->NdisWanLinkInfo ) );
            
            pCall->NdisWanLinkInfo.MaxSendFrameSize = pCall->ulMaxFrameSize;
            pCall->NdisWanLinkInfo.MaxRecvFrameSize = pCall->ulMaxFrameSize;
    
            pCall->NdisWanLinkInfo.HeaderPadding = pAdapter->NdisWanInfo.HeaderPadding;
            pCall->NdisWanLinkInfo.TailPadding = pAdapter->NdisWanInfo.TailPadding;
    
            pCall->NdisWanLinkInfo.SendFramingBits = pAdapter->NdisWanInfo.FramingBits;
            pCall->NdisWanLinkInfo.RecvFramingBits = pAdapter->NdisWanInfo.FramingBits;
        
            pCall->NdisWanLinkInfo.SendACCM = 0;
            pCall->NdisWanLinkInfo.RecvACCM = 0;
        
        }
        else if ( ulCallState == LINECALLSTATE_DISCONNECTED )
        {
            TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: LINEDISCONNECTMODE: %x", ulStateParam ) );

            //
            // This state change will only occur if TpDropCall() is in progress,
            // so we invalidate the htCall member of call context in order to prevent
            // a possible out of sync state change notification.
            //
            pCall->htCall = (HTAPI_CALL) NULL;
            
        }

    } while ( FALSE) ;
    
    NdisReleaseSpinLock( &pCall->lockCall );

    //
    // Notify state change to TAPI if needed
    //
    if ( fIndicateStatus )
    {
        TRACE( TL_N, TM_Tp, ("TpCallStateChangeHandler: Indicate LINE_CALLSTATE change: %x -> %x",ulOldCallState,ulCallState ) );

        NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                             NDIS_STATUS_TAPI_INDICATION,
                             &TapiEvent,
                             sizeof( NDIS_TAPI_EVENT ) );   
    }

    TRACE( TL_N, TM_Tp, ("-TpCallStateChangeHandler") );
}


NDIS_STATUS
TpMakeCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_MAKE_CALL pRequest,
    IN ULONG ulRequestLength
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request places a call on the specified line to the specified
    destination address. Optionally, call parameters can be specified if
    anything but default call setup parameters are requested.

Parameters:

    Adapter _ A pointer ot our adapter information structure.

    Request _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_MAKE_CALL
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_LINE   hdLine;
        IN  HTAPI_CALL  htCall;
        OUT HDRV_CALL   hdCall;
        IN  ULONG       ulDestAddressSize;
        IN  ULONG       ulDestAddressOffset;
        IN  BOOLEAN     bUseDefaultLineCallParams;
        IN  LINE_CALL_PARAMS    LineCallParams;

    } NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;

    typedef struct _LINE_CALL_PARAMS        // Defaults:
    {
        ULONG   ulTotalSize;                // ---------

        ULONG   ulBearerMode;               // voice
        ULONG   ulMinRate;                  // (3.1kHz)
        ULONG   ulMaxRate;                  // (3.1kHz)
        ULONG   ulMediaMode;                // interactiveVoice

        ULONG   ulCallParamFlags;           // 0
        ULONG   ulAddressMode;              // addressID
        ULONG   ulAddressID;                // (any available)

        LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

        ULONG   ulOrigAddressSize;          // 0
        ULONG   ulOrigAddressOffset;
        ULONG   ulDisplayableAddressSize;
        ULONG   ulDisplayableAddressOffset;

        ULONG   ulCalledPartySize;          // 0
        ULONG   ulCalledPartyOffset;

        ULONG   ulCommentSize;              // 0
        ULONG   ulCommentOffset;

        ULONG   ulUserUserInfoSize;         // 0
        ULONG   ulUserUserInfoOffset;

        ULONG   ulHighLevelCompSize;        // 0
        ULONG   ulHighLevelCompOffset;

        ULONG   ulLowLevelCompSize;         // 0
        ULONG   ulLowLevelCompOffset;

        ULONG   ulDevSpecificSize;          // 0
        ULONG   ulDevSpecificOffset;    
        
    } LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;

    typedef struct _LINE_DIAL_PARAMS
    {
        ULONG   ulDialPause;
        ULONG   ulDialSpeed;
        ULONG   ulDigitDuration;
        ULONG   ulWaitForDialtone;

    } LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;

    RequestLength _ Length of the request buffer

Return Values:

    NDIS_STATUS_TAPI_ADDRESSBLOCKED
    NDIS_STATUS_TAPI_BEARERMODEUNAVAIL
    NDIS_STATUS_TAPI_CALLUNAVAIL
    NDIS_STATUS_TAPI_DIALBILLING
    NDIS_STATUS_TAPI_DIALQUIET
    NDIS_STATUS_TAPI_DIALDIALTONE
    NDIS_STATUS_TAPI_DIALPROMPT
    NDIS_STATUS_TAPI_INUSE
    NDIS_STATUS_TAPI_INVALADDRESSMODE
    NDIS_STATUS_TAPI_INVALBEARERMODE
    NDIS_STATUS_TAPI_INVALMEDIAMODE
    NDIS_STATUS_TAPI_INVALLINESTATE
    NDIS_STATUS_TAPI_INVALRATE
    NDIS_STATUS_TAPI_INVALLINEHANDLE
    NDIS_STATUS_TAPI_INVALADDRESS
    NDIS_STATUS_TAPI_INVALADDRESSID
    NDIS_STATUS_TAPI_INVALCALLPARAMS
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_TAPI_OPERATIONUNAVAIL
    NDIS_STATUS_FAILURE
    NDIS_STATUS_TAPI_RESOURCEUNAVAIL
    NDIS_STATUS_TAPI_RATEUNAVAIL
    NDIS_STATUS_TAPI_USERUSERINFOTOOBIG

---------------------------------------------------------------------------*/
{   
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    LINE* pLine = NULL;

    CALL* pCall = NULL;
    HDRV_CALL hdCall = (HDRV_CALL) NULL;

    BOOLEAN fCallInsertedToHandleTable = FALSE;

    WORKITEM* pWorkItem = NULL;
    PVOID Args[4];

    BOOLEAN fRenumerationNotScheduled = FALSE;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpMakeCall") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpMakeCall: Invalid parameter") );    

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    //
    // Retrieve a pointer to the line context
    //
    pLine = TpGetLinePtrFromHdLine( pAdapter, pRequest->hdLine );

    if ( pLine == NULL )
    {
        status = NDIS_STATUS_TAPI_INVALLINEHANDLE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    //
    // See if we can make calls on this line at all
    //
    if ( ! (pLine->ulLnFlags & LNBF_MakeOutgoingCalls ) )
    {
        status = NDIS_STATUS_TAPI_ADDRESSBLOCKED;
        
        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    //
    // See if we can still make calls on this line
    //
    if ( pLine->nActiveCalls == pLine->nMaxCalls )
    {
        status = NDIS_STATUS_TAPI_OPERATIONUNAVAIL;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    //
    // Make sure the parameters suppied in the request are acceptable
    //
    if ( pRequest->bUseDefaultLineCallParams )
    {
        status = NDIS_STATUS_TAPI_INVALCALLPARAMS;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    if ( !( pRequest->LineCallParams.ulBearerMode & LINEBEARERMODE_DATA ) )
    {
        status = NDIS_STATUS_TAPI_INVALBEARERMODE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }
    
    if ( !( pRequest->LineCallParams.ulMediaMode & LINEMEDIAMODE_DIGITALDATA ) )
    {
        status = NDIS_STATUS_TAPI_INVALMEDIAMODE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    if ( !( pRequest->LineCallParams.ulAddressMode &
         ( LINEADDRESSMODE_ADDRESSID | LINEADDRESSMODE_DIALABLEADDR ) ) )
    {
        status = NDIS_STATUS_TAPI_INVALADDRESSMODE;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }
                                           
    if ( pRequest->LineCallParams.ulAddressID > 0 )
    {
        status = NDIS_STATUS_TAPI_INVALADDRESSID;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    if ( pRequest->ulDestAddressOffset + pRequest->ulDestAddressSize > ulRequestLength )
    {
        status = NDIS_STATUS_TAPI_INVALPARAM;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;

    }

    //
    // Create a call context 
    //
    if ( ALLOC_CALL( &pCall ) != NDIS_STATUS_SUCCESS )
    {
        status = NDIS_STATUS_RESOURCES;

        TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );   

        return status;
    }

    do
    {
        //
        // Initialize the call context
        //
        status = TpCallInitialize( pCall, pLine, pRequest->htCall, FALSE /* fIncoming */ );
    
        if ( status != NDIS_STATUS_SUCCESS )
            break;

        //
        // Insert the call context into the tapi provider's handle table
        //
        NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
        hdCall = (HDRV_CALL) InsertToHandleTable( pAdapter->TapiProv.hCallTable,
                                                  NO_PREFERED_INDEX,
                                                  pCall );
                            
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        if ( hdCall == (HDRV_CALL) NULL )
        {
            status = NDIS_STATUS_TAPI_CALLUNAVAIL;

            break;
        }

        fCallInsertedToHandleTable = TRUE;

        //
        // Set the call's hdCall member
        //
        pCall->hdCall = hdCall;

        //
        // Set AC Name and the service name passed in the request.
        // We expect it in the following format:
        // AC Name\Service Name
        //
        // The following examles are all valid:
        // AC Name\                          -> Connect to the default service on the specified AC
        // Service Name                      -> Connect to the specified service on any AC
        // AC Name\Service Name              -> Connect to the specified service on the specified AC
        //                                   -> Connect to the default service on any AC
        //
        // We will also strip off any leading or trailing space chars.
        //
                                                 
        {
            CHAR* pBuf = ( (PUCHAR) pRequest ) + pRequest->ulDestAddressOffset;
            ULONG size = pRequest->ulDestAddressSize;

            ULONG ACNameStartPos, ACNameEndPos;
            ULONG ServiceNameStartPos, ServiceNameEndPos;
            
            //
            // Remove the terminating NULL characters if passed any.
            // 
            for ( ; size > 0 ; size-- )
            {
                if ( pBuf[ size - 1] != '\0' )
                {
                    break;
                }
            }

            //
            // Get the AC Name and service name
            //
            do
            {
               ULONG i = 0;
               CHAR* pTempChar = pBuf;

               ACNameStartPos = ACNameEndPos = 0;
               ServiceNameStartPos = ServiceNameEndPos = 0;

               //
               // Skip leading spaces
               //
               while (i < size)
               {
                  if (*pTempChar != ' ')
                  {
                     break;
                  }
                  
                  i++;
                  
                  pTempChar++;
               }

               if (i == size)
               {
                  break;
               }

               ACNameStartPos = ACNameEndPos = i;
                              
               while (i < size)
               {
                  if (*pTempChar == '\\')
                  {
                     break;
                  }

                  i++;

                  if (*pTempChar != ' ')
                  {
                     //
                     // Mark the beginning of trailing spaces
                     //
                     ACNameEndPos = i;   
                  }

                  pTempChar++;
               }

               if (i == size)
               {
                  //
                  // No AC Name was specified, it was just Service Name 
                  // and we parsed it
                  //
                  ServiceNameStartPos = ACNameStartPos;
                  ServiceNameEndPos = ACNameEndPos;

                  ACNameStartPos = ACNameEndPos = 0;

                  break;
               }

               //
               // Advance 'i' and 'pTempChar' once to skip the '\' character
               //
               i++;
               
               pTempChar++;

               //
               // Skip leading spaces
               //
               while (i < size)
               {
                  if (*pTempChar != ' ')
                  {
                     break;
                  }
                  
                  i++;
                  
                  pTempChar++;
               }

               if (i == size)
               {
                  break;
               }

               ServiceNameStartPos = ServiceNameEndPos = i;

               while (i < size)
               {
                  i++;

                  if (*pTempChar != ' ')
                  {
                     //
                     // Mark the beginning of trailing spaces
                     //
                     ServiceNameEndPos = i;   
                  }

                  pTempChar++;
               }
               
            } while ( FALSE );

            //
            // Retrieve the AC Name information into the call context
            //
            pCall->nACNameLength = (USHORT) ( ( MAX_AC_NAME_LENGTH < ( ACNameEndPos - ACNameStartPos ) ) ?
                                                MAX_AC_NAME_LENGTH : ( ACNameEndPos - ACNameStartPos ) );


            if ( pCall->nACNameLength != 0 )
            {
                NdisMoveMemory( pCall->ACName, &pBuf[ACNameStartPos], pCall->nACNameLength );

                pCall->fACNameSpecified = TRUE;
            }

            //
            // Retrieve the Service Name information into the call context
            //
            pCall->nServiceNameLength = (USHORT) ( ( MAX_SERVICE_NAME_LENGTH < ( ServiceNameEndPos - ServiceNameStartPos ) ) ?
                                                     MAX_SERVICE_NAME_LENGTH : ( ServiceNameEndPos - ServiceNameStartPos ) );


            if ( pCall->nServiceNameLength != 0 )
            {
                NdisMoveMemory( pCall->ServiceName, &pBuf[ServiceNameStartPos], pCall->nServiceNameLength );
            }
        }

        //
        // Allocate a work item for scheduling FsmMakeCall()
        //
        // Set the arguements array
        //
        Args[0] = (PVOID) pCall;

        pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                   ExecAdapterWorkItem,
                                   NULL,
                                   Args, 
                                   CWT_workFsmMakeCall );

        if ( pWorkItem == NULL ) 
        {
            status = NDIS_STATUS_RESOURCES;

            break;
        }

        {
           //
           // Schedule a work item to reenumerate bindings
           //
            WORKITEM* pCallWorkItem;
            
            Args[0] = (PVOID) BN_SetFiltersForMakeCall;       // Is a set filter request
            Args[1] = (PVOID) pCall;
            Args[2] = (PVOID) pRequest;
            Args[3] = (PVOID) pWorkItem;

            pCallWorkItem = pWorkItem;

            //
            // Allocate work item for the bind
            //
            pWorkItem = AllocWorkItem( &gl_llistWorkItems,
                                       ExecBindingWorkItem,
                                       NULL,
                                       Args,
                                       BWT_workPrStartBinds );

            if ( pWorkItem == NULL ) 
            {
               //
               // We can not allocate the work item for reenumeration of bindings
               // But may be all enumerations are intact, so let the
               // make call request continue
               //

               pWorkItem = pCallWorkItem;

               fRenumerationNotScheduled = TRUE;
            }
        }

        //
        // Insert the call context into the line's active call list
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        InsertHeadList( &pLine->linkCalls, &pCall->linkCalls );

        pLine->nActiveCalls++;

        ReferenceLine( pLine, FALSE );

        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // Reference the call 3 times:
        //  1. For scheduling of FsmMakeCall()
        //  2. For dropping of the call
        //  3. For closing of the call
        //
        NdisAcquireSpinLock( &pCall->lockCall );
        
        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );

        NdisReleaseSpinLock( &pCall->lockCall );

        //
        // Schedule the bind operation
        //
        ScheduleWorkItem( pWorkItem );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE );

    if ( status == NDIS_STATUS_SUCCESS )
    {
        //
        // If succesfull, return the call handle to TAPI and mark call as TAPI notified
        // of new call
        //
        pRequest->hdCall = hdCall;

        //
        // If we have scheduled a reenumeration work item, then pend this request
        // It will be completed when reenumeration is complete.
        //
        if ( !fRenumerationNotScheduled )
        {
           status = NDIS_STATUS_PENDING;
        }           

    }
    else
    {

        //
        // Somethings failed, do clean up
        //
        
        if ( fCallInsertedToHandleTable )
        {
            NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
            RemoveFromHandleTable( pAdapter->TapiProv.hCallTable, (NDIS_HANDLE) hdCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }

        if ( pCall )
        {
            TpCallCleanup( pCall );
        }

    }

    TRACE( TL_N, TM_Tp, ("-TpMakeCall=$%x",status) );

    return status;  
}

VOID
TpMakeCallComplete(
   IN CALL* pCall,
   IN PNDIS_TAPI_MAKE_CALL pRequest   
   )
{
   TRACE( TL_N, TM_Tp, ("+TpMakeCallComplete") );

   NdisMQueryInformationComplete( pCall->pLine->pAdapter->MiniportAdapterHandle,
                                  NDIS_STATUS_SUCCESS );

   TRACE( TL_N, TM_Tp, ("-TpMakeCallComplete=$%x",NDIS_STATUS_SUCCESS) );

}

NDIS_STATUS
TpCallInitialize(
    IN CALL* pCall,
    IN LINE* pLine,
    IN HTAPI_CALL htCall,
    IN BOOLEAN fIncoming
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function makes initialization on the call context.

Parameters:

    pCall _ A pointer to our call information structure.

    pLine _ A pointer to the line information structure that the call belongs.

    htCall _ Handle assigned to the call by TAPI.

    fIncoming _ Flag that indicates if the call is inbound or outbound.

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE

---------------------------------------------------------------------------*/   
{

    TRACE( TL_N, TM_Tp, ("+TpCallInitialize") );

    NdisZeroMemory( pCall, sizeof( CALL ) );
    
    InitializeListHead( &pCall->linkCalls );

    pCall->tagCall = MTAG_CALL;

    pCall->ulClFlags = ( CLBF_CallOpen | CLBF_CallConnectPending );

    NdisAllocateSpinLock( &pCall->lockCall );

    pCall->fIncoming = fIncoming;

    pCall->pLine = pLine;

    pCall->htCall = htCall;

    InitializeListHead( &pCall->linkReceivedPackets );

    pCall->ulTapiCallState = LINECALLSTATE_IDLE;

    TRACE( TL_N, TM_Tp, ("-TpCallInitialize") );

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TpAnswerCall(
    IN ADAPTER* pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This request answers the specified offering call.  It may optionally send
    the specified user-to-user information to the calling party.

Parameters:

    Adapter _ A pointer ot our adapter information structure.

    Request _ A pointer to the NDIS_TAPI request structure for this call.

    typedef struct _NDIS_TAPI_ANSWER
    {
        IN  ULONG       ulRequestID;
        IN  HDRV_CALL   hdCall;
        IN  ULONG       ulUserUserInfoSize;
        IN  UCHAR       UserUserInfo[1];

    } NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_TAPI_INVALCALLHANDLE

---------------------------------------------------------------------------*/
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    CALL* pCall = NULL;
    
    ASSERT( VALIDATE_ADAPTER( pAdapter ) );

    TRACE( TL_N, TM_Tp, ("+TpAnswerCall") );

    if ( pRequest == NULL || pAdapter == NULL )
    {
        TRACE( TL_A, TM_Tp, ("TpAnswerCall: Invalid parameter") );  

        TRACE( TL_N, TM_Tp, ("-TpAnswerCall=$%x",NDIS_STATUS_TAPI_INVALPARAM) );

        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    
    pCall = RetrieveFromHandleTable( pAdapter->TapiProv.hCallTable, 
                                     (NDIS_HANDLE) pRequest->hdCall );

    if ( pCall == NULL )
    {
        status = NDIS_STATUS_TAPI_INVALCALLHANDLE;

        TRACE( TL_N, TM_Tp, ("-TpAnswerCall=$%x",status) ); 
    
        return status;
    }

    status = FsmAnswerCall( pCall );

    TRACE( TL_N, TM_Tp, ("-TpAnswerCall=$%x",status) ); 
    
    return status;
}

VOID 
ExecAdapterWorkItem(
    IN PVOID Args[4],
    IN UINT workType
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function executes the scheduled work items for the adapter.

    
Parameters:

    Args:
        An array of length 4 keeping PVOIDs

    workType:
        Indicates the type of the work to be executed.
        We use this to understand what we should do in this function.

Return Values:

    None
    
---------------------------------------------------------------------------*/
{

    TRACE( TL_N, TM_Mp, ("+ExecAdapterWorkItem") );

    switch ( workType )
    {

        case CWT_workFsmMakeCall:

            //
            // Scheduled from TpMakeCall() to start an outgoing call
            //
            {
                CALL* pCall = (CALL*) Args[0];
                
                FsmMakeCall( pCall );   

                //
                // Remove the reference due to scheduling of FsmMakeCall()
                //
                DereferenceCall( pCall );

                break;
            }

        default:

            break;


    }

    TRACE( TL_N, TM_Mp, ("-ExecAdapterWorkItem") );

}


VOID
TpReceiveCall(
    IN ADAPTER* pAdapter,
    IN BINDING* pBinding,
    IN PPPOE_PACKET* pPacket
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called by miniport when we receive a PADR packet 
    to initiate a call.
    
Parameters:

    pAdapter:
        A pointer to our adapter information structure.

    pPacket:
        A pointer to the received PADI packet.

Return Values:

    None
    
---------------------------------------------------------------------------*/   
{
    HANDLE_TABLE hCallTable = NULL; 
    UINT hCallTableSize     = 0;
    UINT nIndex             = 0;
    LINE* pLine             = NULL;
    CALL* pCall             = NULL;
    UINT i;
    NDIS_STATUS status;

    BOOLEAN fCallInsertedToHandleTable = FALSE;

    TRACE( TL_N, TM_Tp, ("+TpReceiveCall") );

    NdisAcquireSpinLock( &pAdapter->lockAdapter );

    //
    // Traverse the call handle table and find an empty spot
    //
    hCallTableSize = pAdapter->nMaxLines * pAdapter->nCallsPerLine;
                
    hCallTable = pAdapter->TapiProv.hCallTable;

    for ( nIndex = 0; nIndex < hCallTableSize; nIndex++ )
    {

        if ( RetrieveFromHandleTableByIndex( hCallTable, (USHORT) nIndex ) == NULL )
            break;
            
    }

    if ( nIndex == hCallTableSize )
    {
        //
        // We are already maxed out with current calls, do not respond to the request
        //
        // TODO: We could send a PADO packet with an error tag saying that we can 
        //       not accept calls temporarily.
        //
        TRACE( TL_N, TM_Tp, ("-TpReceiveCall: Can not take calls - Call table full") );
        
        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        return;
    }

    //
    // We have found an empty spot, now see if any of the open lines accept calls
    //
    for ( i = 0; i < pAdapter->nMaxLines; i++ )
    {
        pLine = pAdapter->TapiProv.LineTable[i];

        if ( pLine == NULL )
            continue;

        if ( pLine->nActiveCalls == pAdapter->nCallsPerLine )
        {
            pLine = NULL;
            
            continue;
        }

        if ( !( pLine->ulLnFlags & LNBF_AcceptIncomingCalls ) )
        {
            pLine = NULL;
            
            continue;
        }

        break;
        
    }

    if ( pLine == NULL )
    {
        //
        // We do not have any lines accepting calls right now
        //
        // TODO: We could send a PADO packet with an error tag saying that there are
        //       no active lines accepting calls at the moment.
        //
        TRACE( TL_N, TM_Tp, ("-TpReceiveCall: Can not take calls - No lines taking calls") );

        NdisReleaseSpinLock( &pAdapter->lockAdapter );

        return;

    }

    //
    // We have found a line accepting calls, and we have a free spot in call handle table,
    // so create a call context, add it to TapiProv structures, and notify TAPI of the new
    // call
    //

    do
    {
        HDRV_CALL hdCall;
        
        //
        // Create a call context 
        //
        if ( ALLOC_CALL( &pCall ) != NDIS_STATUS_SUCCESS )
        {
            status = NDIS_STATUS_RESOURCES;

            break;
        }

        //
        // Initialize the call context
        //
        status = TpCallInitialize( pCall, pLine, (HTAPI_CALL) 0, TRUE /* fIncoming */ );
    
        if ( status != NDIS_STATUS_SUCCESS )
            break;

        //
        // Insert the call context into the tapi provider's handle table
        //
        
        hdCall = (HDRV_CALL) InsertToHandleTable( pAdapter->TapiProv.hCallTable,
                                                  (USHORT) nIndex,
                                                  (PVOID) pCall );
                            

        if ( hdCall == (HDRV_CALL) NULL )
        {
            status = NDIS_STATUS_TAPI_CALLUNAVAIL;

            break;
        }

        fCallInsertedToHandleTable = TRUE;

        //
        // Set the call's hdCall member
        //
        pCall->hdCall = hdCall;

        //
        // Insert the call context into the line's active call list
        //
        NdisAcquireSpinLock( &pLine->lockLine );

        InsertHeadList( &pLine->linkCalls, &pCall->linkCalls );

        pLine->nActiveCalls++;

        ReferenceLine( pLine, FALSE );

        NdisReleaseSpinLock( &pLine->lockLine );

        //
        // Reference the call 3 times:
        //  1. For running FsmReceiveCall() below
        //  2. For dropping of the call
        //  3. For closing of the call
        //
        NdisAcquireSpinLock( &pCall->lockCall );

        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );
        ReferenceCall( pCall, FALSE );

        NdisReleaseSpinLock( &pCall->lockCall );

        status = NDIS_STATUS_SUCCESS;

    } while ( FALSE );

    NdisReleaseSpinLock( &pAdapter->lockAdapter );
    
    //
    // Check the status
    //
    if ( status == NDIS_STATUS_SUCCESS )
    {
    
        //
        // Kick the state machine to start receiving the call
        //
        FsmReceiveCall( pCall, pBinding, pPacket );

        //
        // Remove the reference added above
        //
        DereferenceCall( pCall );

    }
    else
    {
        //
        // If something failed, do clean up
        //  
        
        if ( fCallInsertedToHandleTable )
        {
            NdisAcquireSpinLock( &pAdapter->lockAdapter );
        
            RemoveFromHandleTable( pAdapter->TapiProv.hCallTable, (NDIS_HANDLE) pCall->hdCall );

            NdisReleaseSpinLock( &pAdapter->lockAdapter );
        }

        if ( pCall )
        {
            TpCallCleanup( pCall );
        }

    }

    TRACE( TL_N, TM_Tp, ("-TpReceiveCall=$%x",status) );
}

BOOLEAN
TpIndicateNewCall(
    IN CALL* pCall
    )
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Functional Description:

    This function will be called to indicate the new call context to to TAPI.

    If TAPI can be notified succesfully, then it returns TRUE, otherwise it 
    returns FALSE.
    
Parameters:

    pCall _ New call context to be indicated to TAPI.
    
Return Values:

    TRUE
    FALSE
    
---------------------------------------------------------------------------*/   
{
    NDIS_TAPI_EVENT TapiEvent;
    BOOLEAN fRet = FALSE;

    TRACE( TL_N, TM_Tp, ("+TpIndicateNewCall") );

    NdisAcquireSpinLock( &pCall->lockCall );

    if ( pCall->ulClFlags & CLBF_CallDropped ||
         pCall->ulClFlags & CLBF_CallClosePending )
    {
        TRACE( TL_N, TM_Tp, ("TpIndicateNewCall: Can not indicate new call since call is going down") );

        TRACE( TL_N, TM_Tp, ("-TpIndicateNewCall") );

        //
        // This may happen if call is closed internally due to the FSM timeout handlers
        //
        NdisReleaseSpinLock( &pCall->lockCall );

        return fRet;
    }

    NdisReleaseSpinLock( &pCall->lockCall );
    
    //
    // Indicate the new call to TAPI, retrieve the corresponding TAPI handle (htCall)
    // and set it in the call
    //
    // Future: The casts below between ulParam2. pCall->hdCall and pCall->htCall will
    //         be a problem on 64 bit machines.
    //
    TapiEvent.htLine = pCall->pLine->htLine;
    TapiEvent.htCall = 0;
    TapiEvent.ulMsg  = LINE_NEWCALL;
        
    TapiEvent.ulParam1 = (ULONG) pCall->hdCall;
    TapiEvent.ulParam2 = 0;
    TapiEvent.ulParam3 = 0; 

    TRACE( TL_N, TM_Tp, ("TpIndicateNewCall: Indicate LINE_NEWCALL") );

    NdisMIndicateStatus( pCall->pLine->pAdapter->MiniportAdapterHandle,
                         NDIS_STATUS_TAPI_INDICATION,
                         &TapiEvent,
                         sizeof( NDIS_TAPI_EVENT ) );   

    NdisAcquireSpinLock( &pCall->lockCall );
        
    pCall->htCall = (HTAPI_CALL) TapiEvent.ulParam2;

    fRet = TRUE;

    NdisReleaseSpinLock( &pCall->lockCall );

    TRACE( TL_N, TM_Tp, ("-TpIndicateNewCall") );

    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspppoe\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

typedef enum
_WORKSTATE
{
	WS_NotScheduled = 0,
	WS_Scheduled,
	WS_Executing,
	WS_Executed
}
WORKSTATE;

typedef 
VOID 
(*WORKITEM_EXEC_ROUTINE)( 
	IN PVOID Args[4],
	UINT workType 
	);
	
typedef 
VOID 
(*WORKITEM_FREE_ROUTINE)( 
	IN PVOID Args[4],
	IN UINT workType
	);

typedef struct
_WORKITEM
{
	//
	// Indicates the state of the work item
	//
	WORKSTATE workState;

	//
	// Indicates the type of work to be done
	//
	UINT workType;

	//
	// Points to the lookaside list the item was allocated from
	//
	PNPAGED_LOOKASIDE_LIST pLookaside;
	
	//
	// Context to be passed to scheduled item
	//
	PVOID Args[4];

	//
	// Routine to be called to execute the work item
	//
	WORKITEM_EXEC_ROUTINE pExecRoutine; 

	//
	// Routine to be called to free the context for the work item
	//
	WORKITEM_FREE_ROUTINE pFreeRoutine;
	
	//
    // Associated NdisWorkItem 
    //
    NDIS_WORK_ITEM	ndisWorkItem;

}
WORKITEM;

VOID InitializeWorkItemLookasideList(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN ULONG tagLookaside
	);

WORKITEM* AllocWorkItem(
	IN PNPAGED_LOOKASIDE_LIST pLookaside,
	IN WORKITEM_EXEC_ROUTINE pExecRoutine,
	IN WORKITEM_FREE_ROUTINE pFreeRoutine,
	IN PVOID Args[4],
	IN UINT workType
	);

VOID ScheduleWorkItem(
	IN WORKITEM *pWorkItem
	);

VOID FreeWorkItem(
	IN WORKITEM *pWorkItem
	);

VOID WorkItemExec(
    IN NDIS_WORK_ITEM*  pNdisWorkItem,
    IN PVOID  pvContext
	);	


typedef struct
_HANDLE_CB
{
	//
	// Indicates that the entry contains a valid context pointer
	//
	BOOLEAN fActive;

	//
	// Pointer to the context saved in this entry
	//
	PVOID pContext;

	//
	// Handle value to access this particular entry
	//
	NDIS_HANDLE Handle;
}
HANDLE_CB;

typedef struct
_HANDLE_TABLE_CB
{
	//
	// Points to the table that holds the Handle control blocks.
	//
	HANDLE_CB* HandleTable;

	//
	// Size of the handle table
	//
	UINT nTableSize;

	//
	// Shows the number of active handles
	//
	UINT nActiveHandles;

	//
	// Keeps the unique part of the handle.
	// This is incremented everytime a handle is generated and a context is inserted 
	// into the handle table.
	//
	USHORT usKeys;
}
HANDLE_TABLE_CB, *PHANDLE_TABLE_CB, *HANDLE_TABLE;

#define NO_PREFERED_INDEX 		(USHORT) -1

HANDLE_TABLE InitializeHandleTable(
	IN UINT nHandleTableSize
	);

VOID FreeHandleTable(
	IN OUT HANDLE_TABLE Table
	);

NDIS_HANDLE InsertToHandleTable(
	IN HANDLE_TABLE Table,
	IN USHORT usPreferedIndex,
	IN PVOID pContext
	);

PVOID RetrieveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	);

USHORT RetrieveIndexFromHandle(
	IN NDIS_HANDLE Handle
	);
	
PVOID RetrieveFromHandleTableByIndex(
	IN HANDLE_TABLE Table,
	IN USHORT usIndex
	);

PVOID RetrieveFromHandleTableBySessionId(
	IN HANDLE_TABLE Table,
	IN USHORT usSessionId
	);
	
VOID RemoveFromHandleTable(
	IN HANDLE_TABLE Table,
	IN NDIS_HANDLE Handle
	);	

USHORT RetrieveSessionIdFromHandle(
	IN NDIS_HANDLE Handle
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\bpool.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;

}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );

VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\ctdi.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   CTDI.H - Common TDI API and data types.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    8/4/1998
*
*****************************************************************************/

#ifndef CTDI_H
#define CTDI_H

#include "ctdios.h"

#define CTDI_FLAG_ENABLE_ROUTING        0x00000001
#define CTDI_FLAG_NETWORK_HEADER        0x00000002
#define IPADDR(x) (x & 0x000000ff),((x>>8) & 0x000000ff), ((x>>16) & 0x000000ff), ((x>>24) & 0x000000ff)


typedef NDIS_STATUS
(*CTDI_EVENT_DISCONNECT)(
    IN      PVOID                       pContext,
    IN      BOOLEAN                     Abortive
    );

typedef NDIS_STATUS
(*CTDI_EVENT_CONNECT_QUERY)(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      HANDLE                      hNewCtdi,
    OUT     PVOID                      *pNewContext
    );

typedef NDIS_STATUS
(*CTDI_EVENT_CONNECT_COMPLETE)(
    IN      PVOID                       pContext,
    IN      HANDLE                      hNewCtdi,
    IN      NDIS_STATUS                 ConnectStatus
    );

typedef NDIS_STATUS
(*CTDI_EVENT_RECEIVE)(
    IN      PVOID                       pContext,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

typedef NDIS_STATUS
(*CTDI_EVENT_RECEIVE_DATAGRAM)(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

typedef VOID
(*CTDI_EVENT_SEND_COMPLETE)(
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PUCHAR                      pBuffer,
    IN      NDIS_STATUS                 Result
    );

typedef VOID
(*CTDI_EVENT_QUERY_COMPLETE)(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    );

typedef VOID
(*CTDI_EVENT_SET_COMPLETE)(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    );

NDIS_STATUS
CtdiInitialize(
    IN      ULONG                       ulFlags
    );

NDIS_STATUS
CtdiClose(
    IN      HANDLE                      hCtdi
    );

NDIS_STATUS
CtdiListen(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   NumListen,
    IN      CTDI_EVENT_CONNECT_QUERY    pConnectQueryHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiConnect(
    IN      HANDLE                      hCtdi,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      CTDI_EVENT_CONNECT_COMPLETE pConnectCompleteHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiDisconnect(
    IN      HANDLE                      hCtdi,
    IN      BOOLEAN                     Abort
    );

NDIS_STATUS
CtdiReceiveComplete(
    IN      HANDLE                      hCtdi,
    IN      PUCHAR                      pBuffer
    );

NDIS_STATUS
CtdiSend(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pvBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CtdiSendDatagram(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PTRANSPORT_ADDRESS          pDestination,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CtdiCreateEndpoint(
    OUT     PHANDLE                     phCtdi,
    IN      ULONG_PTR                   ulAddressFamily,
    IN      ULONG_PTR                   ulType,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      ULONG_PTR                   ulRxPadding
    );

NDIS_STATUS
CtdiSetEventHandler(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulEventType,
    IN      PVOID                       pEventHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiSetInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   ulSetType,
    IN      PTDI_CONNECTION_INFORMATION pConnectionInformation,
    IN      CTDI_EVENT_SET_COMPLETE     pSetCompleteHandler,
    IN      PVOID                       pContext
    );

NDIS_STATUS
CtdiQueryInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulQueryType,
    IN OUT  PVOID                       pBuffer,
    IN      ULONG                       Length,
    IN      CTDI_EVENT_QUERY_COMPLETE   pQueryCompleteHandler,
    IN      PVOID                       pContext
    );

VOID CtdiShutdown();

VOID CtdiSetRequestPending(
    IN      HANDLE                      hCtdi
    );

#endif // CTDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\bpool.c ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.

#include "raspptp.h"
#include "bpool.h"


// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoubleBufferFrees = 0;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulBufferSize = ulBufferSize;
    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulBuffersPerBlock;
    }

    DEBUGMSG(DBG_POOL, (DTEXT("InitBp tag=$%08x buf=%d cnt=%d\n"),
                        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    DEBUGMSG(DBG_POOL, (DTEXT("FreeBp\n")));

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );
    NdisFreeSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        DEBUGMSG(DBG_POOL, (DTEXT("GetBfp=$%08x, %d free\n"),
                            pBuffer, pHead->pBlock->ulFreeBuffers));
    }
    else
    {
        DEBUGMSG(DBG_POOL, (DTEXT("GetBfp failed?\n" ) ));
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    if (fGarbageCollection)
    {
        DEBUGMSG(DBG_POOL, (DTEXT("FreeBtoP($%08x) %d free\n"),
                            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreeBuffers.Flink != &pHead->linkFreeBuffers)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoubleBufferFrees;
            break;
        }

        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the
                // pool not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    DEBUGMSG(DBG_POOL, (DTEXT("AddBpBlock(%d+%d)\n"),
                        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                DEBUGMSG(DBG_POOL, (DTEXT("Bp maxed?\n")));
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                {
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
                }
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = MyMemAlloc( ulSize, pPool->ulTag );
            if (!pNew)
            {
                DEBUGMSG(DBG_POOL, (DTEXT( "Alloc BB?\n" ) ));
                break;
            }

            // Zero only the block header portion.
            //
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_POOL, (DTEXT("AllocBp=$%x?\n"), status ));
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            MyMemFree( pNew, ulSize );
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_POOL, (DTEXT("AllocB=$%x?\n"), status ) );
                    ASSERT( FALSE );
                    continue;
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
{
    LIST_ENTRY* pLink;

    DEBUGMSG(DBG_POOL, (DTEXT("FreeUnusedBpBlocks\n" ) ));

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {
            ULONG i;
            BUFFERHEAD* pHead;

            DEBUGMSG(DBG_POOL, (DTEXT("FreeBpBlock(%d-%d)\n"),
                                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );
                InitializeListHead( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            MyMemFree( pBlock, sizeof(BUFFERBLOCKHEAD) + (pBlock->ulBuffers * (sizeof(BUFFERHEAD) + pPool->ulBufferSize)));
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\control.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   CONTROL.C - PPTP Control Layer functionality
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

typedef struct {
    LIST_ENTRY  ListEntry;
    ULONG       Length;
} MESSAGE_HEADER, *PMESSAGE_HEADER;

USHORT PptpControlPort = PPTP_TCP_PORT;
USHORT PptpProtocolNumber = PPTP_IP_GRE_PROTOCOL;
USHORT PptpUdpPort = PPTP_IP_GRE_PROTOCOL;
ULONG PptpWanEndpoints = OS_DEFAULT_WAN_ENDPOINTS;
ULONG PptpTunnelConfig = 0;
ULONG PptpListensPending = OS_LISTENS_PENDING;
BOOLEAN PptpEchoAlways = TRUE;
ULONG PptpEchoTimeout = PPTP_ECHO_TIMEOUT_DEFAULT;
ULONG PptpMessageTimeout = PPTP_MESSAGE_TIMEOUT_DEFAULT;
ULONG PptpMaxTransmit = PPTP_MAX_TRANSMIT;
BOOLEAN PptpAuthenticateIncomingCalls = FALSE;
PCLIENT_ADDRESS ClientList = NULL;
ULONG NumClientAddresses = 0;
BOOLEAN PptpInitialized = FALSE;
LONG PptpSendRecursionLimit = PPTP_SEND_RECURSION_LIMIT_DEFAULT;
ULONG PptpValidateAddress = TRUE;


static ULONG PptpMessageLength_v1[NUM_MESSAGE_TYPES] =
{
    0, // invalid
    sizeof(PPTP_CONTROL_START_PACKET),  // Request
    sizeof(PPTP_CONTROL_START_PACKET),  // Reply
    sizeof(PPTP_CONTROL_STOP_PACKET),   // Request
    sizeof(PPTP_CONTROL_STOP_PACKET),   // Reply
    sizeof(PPTP_CONTROL_ECHO_REQUEST_PACKET),
    sizeof(PPTP_CONTROL_ECHO_REPLY_PACKET),
    sizeof(PPTP_CALL_OUT_REQUEST_PACKET),
    sizeof(PPTP_CALL_OUT_REPLY_PACKET),
    sizeof(PPTP_CALL_IN_REQUEST_PACKET),
    sizeof(PPTP_CALL_IN_REPLY_PACKET),
    sizeof(PPTP_CALL_IN_CONNECT_PACKET),
    sizeof(PPTP_CALL_CLEAR_REQUEST_PACKET),
    sizeof(PPTP_CALL_DISCONNECT_NOTIFY_PACKET),
    sizeof(PPTP_WAN_ERROR_NOTIFY_PACKET),
    sizeof(PPTP_SET_LINK_INFO_PACKET)
};

VOID
CtlCleanup(
    PCONTROL_TUNNEL pCtl,
    BOOLEAN Locked
    );

VOID
CtlpEchoTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    );

VOID
CtlpDeathTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    );

CONTROL_STATE
CtlSetState(
    IN PCONTROL_TUNNEL pCtl,
    IN CONTROL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    );

CHAR *
ControlMsgToString(
    ULONG Message
    );

PCONTROL_TUNNEL
CtlAlloc(
    PPPTP_ADAPTER pAdapter
    )
{
    PCONTROL_TUNNEL pCtl;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlAlloc\n")));

    pCtl = MyMemAlloc(sizeof(CONTROL_TUNNEL), TAG_PPTP_TUNNEL);

    if (pCtl)
    {
        NdisZeroMemory(pCtl, sizeof(CONTROL_TUNNEL));

        pCtl->Signature = TAG_PPTP_TUNNEL;
        pCtl->pAdapter = pAdapter;
        pCtl->PptpMessageLength = PptpMessageLength_v1;

        NdisAllocateSpinLock(&pCtl->Lock);
        NdisInitializeListHead(&pCtl->CallList);
        NdisInitializeListHead(&pCtl->MessageList);
        NdisMInitializeTimer(&pCtl->Echo.Timer,
                             pAdapter->hMiniportAdapter,
                             CtlpEchoTimeout,
                             pCtl);
        NdisMInitializeTimer(&pCtl->WaitTimeout,
                             pAdapter->hMiniportAdapter,
                             CtlpDeathTimeout,
                             pCtl);
        NdisMInitializeTimer(&pCtl->StopTimeout,
                             pAdapter->hMiniportAdapter,
                             CtlpDeathTimeout,
                             pCtl);


        INIT_REFERENCE_OBJECT(pCtl, CtlFree);

        MyInterlockedInsertTailList(&pAdapter->ControlTunnelList,
                                    &pCtl->ListEntry,
                                    &pAdapter->Lock);

        // If doing file logging open the log session here
        OsFileLogOpen();
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlAlloc %08x\n"), pCtl));
    return pCtl;
}

VOID
CtlFree(PCONTROL_TUNNEL pCtl)
{
    BOOLEAN NotUsed;
    if (!IS_CTL(pCtl))
    {
        return;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlFree %08x\n"), pCtl));

    pCtl->Signature = 0;

    ASSERT(IsListEmpty(&pCtl->CallList));
    ASSERT(IsListEmpty(&pCtl->MessageList));

    NdisAcquireSpinLock(&pCtl->pAdapter->Lock);
    RemoveEntryList(&pCtl->ListEntry);
    NdisReleaseSpinLock(&pCtl->pAdapter->Lock);

    // This duplicates some of the cleanup code, but attempting to stop
    // the driver without first stopping tapi can result in an ungraceful
    // shutdown.
    NdisMCancelTimer(&pCtl->Echo.Timer, &NotUsed);
    NdisMCancelTimer(&pCtl->WaitTimeout, &NotUsed);
    NdisMCancelTimer(&pCtl->StopTimeout, &NotUsed);

    if (pCtl->hCtdi)
    {
        LOGMSG(FLL_USER, (DTEXT(LOGHDRS"TCP disconnecting\n"),
                          LOGHDR(21, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
        CtdiDisconnect(pCtl->hCtdi, FALSE);
        CtdiClose(pCtl->hCtdi);
        pCtl->hCtdi = NULL;
    }
    if (pCtl->hCtdiEndpoint)
    {
        CtdiClose(pCtl->hCtdiEndpoint);
        pCtl->hCtdiEndpoint = NULL;
    }

    NdisFreeSpinLock(&pCtl->Lock);

    MyMemFree(pCtl, sizeof(CONTROL_TUNNEL));

    OsFileLogClose();  // Close the logging session opened with the creation of the Ctl channel

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlFree\n")));
}

PVOID
CtlpAllocPacketLocked(
    PCONTROL_TUNNEL pCtl,
    PPTP_MESSAGE_TYPE Message
    )
{
    PMESSAGE_HEADER pMsg;
    ULONG PacketLength;

    DEBUGMSG(DBG_TUNNEL, (DTEXT("+CtlpAllocPacketLocked %d\n"), Message));

    ASSERT(IS_CTL(pCtl));
    ASSERT(Message>=CONTROL_START_REQUEST && Message<NUM_MESSAGE_TYPES);

    if (pCtl->State!=STATE_CTL_CLEANUP)
    {
        PacketLength = pCtl->PptpMessageLength[Message];

        pMsg = MyMemAlloc(sizeof(MESSAGE_HEADER)+PacketLength, TAG_CTL_PACKET);
        if (!pMsg)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("Failed to alloc control packet\n")));
        }
        else
        {
            PPTP_HEADER *pHeader = (PVOID)&pMsg[1];
            NdisZeroMemory(pMsg, sizeof(MESSAGE_HEADER)+PacketLength);
            pMsg->Length = sizeof(MESSAGE_HEADER)+PacketLength;

            pHeader->Length = htons((USHORT)PacketLength);
            pHeader->PacketType = htons(PPTP_CONTROL_MESSAGE);
            pHeader->Cookie = htonl(PPTP_MAGIC_COOKIE);
            pHeader->MessageType = htons(Message);

            InsertTailList(&pCtl->MessageList, &pMsg->ListEntry);
            REFERENCE_OBJECT(pCtl);  // pair in CtlFreePacket
        }
    }
    else
    {
        pMsg = NULL;
    }

    DEBUGMSG(DBG_TUNNEL, (DTEXT("-CtlpAllocPacketLocked %08x\n"), (pMsg ? &pMsg[1] : NULL)));
    return (pMsg ? &pMsg[1] : NULL);
}

PVOID
CtlAllocPacket(
    PCONTROL_TUNNEL pCtl,
    PPTP_MESSAGE_TYPE Message
    )
{
    PVOID pPacket = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlAllocPacket\n")));

    if (IS_CTL(pCtl))
    {
        NdisAcquireSpinLock(&pCtl->Lock);
        pPacket = CtlpAllocPacketLocked(pCtl, Message);
        NdisReleaseSpinLock(&pCtl->Lock);
    }


    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlAllocPacket\n")));
    return pPacket;
}


VOID
CtlFreePacket(
    PCONTROL_TUNNEL pCtl,
    PVOID pPacket
    )
{
    PMESSAGE_HEADER pMsg = ((PMESSAGE_HEADER)pPacket) - 1;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlFreePacket %08x\n"), pPacket));

    ASSERT(IS_CTL(pCtl));
    NdisAcquireSpinLock(&pCtl->Lock);
    RemoveEntryList(&pMsg->ListEntry);
    if (pCtl->State==STATE_CTL_CLEANUP && IsListEmpty(&pCtl->MessageList))
    {
        CtlCleanup(pCtl, LOCKED);
    }
    NdisReleaseSpinLock(&pCtl->Lock);

    MyMemFree(pMsg, pMsg->Length);

    DEREFERENCE_OBJECT(pCtl);  // pair in CtlpAllocPacket

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlFreePacket\n")));
}


STATIC VOID
CtlpCleanup(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCONTROL_TUNNEL pCtl = pWorkItem->Context;
    BOOLEAN CleanupComplete = FALSE;
    BOOLEAN TimeoutStopped;
    DEBUGMSG(DBG_FUNC|DBG_TUNNEL, (DTEXT("+CtlpCleanup %08x\n"), pCtl));

    ASSERT(IS_CTL(pCtl));
    NdisAcquireSpinLock(&pCtl->Lock);

    if (!IsListEmpty(&pCtl->CallList))
    {
        ENUM_CONTEXT Enum;
        PCALL_SESSION pCall;
        PLIST_ENTRY pListEntry;

        REFERENCE_OBJECT(pCtl);
        NdisReleaseSpinLock(&pCtl->Lock);
        InitEnumContext(&Enum);
        while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
        {
            pCall = CONTAINING_RECORD(pListEntry,
                                      CALL_SESSION,
                                      ListEntry);
            if (IS_CALL(pCall))
            {
                CallEventDisconnect(pCall);
            }
        }
        EnumComplete(&Enum, &pCtl->pAdapter->Lock);
        DEREFERENCE_OBJECT(pCtl);  // pair above
        NdisAcquireSpinLock(&pCtl->Lock);
        goto ccDone;
    }

    if (!IsListEmpty(&pCtl->MessageList))
    {
        goto ccDone;
    }

    NdisMCancelTimer(&pCtl->Echo.Timer, &TimeoutStopped);

    if (pCtl->Reference.Count!=2)
    {
        DEBUGMSG(DBG_TUNNEL, (DTEXT("CtlpCleanup %d references held, not cleaning up.\n"),
                              pCtl->Reference.Count));
        goto ccDone;
    }

    NdisMCancelTimer(&pCtl->WaitTimeout, &TimeoutStopped);
    NdisMCancelTimer(&pCtl->StopTimeout, &TimeoutStopped);

    if (pCtl->hCtdi)
    {
        LOGMSG(FLL_USER, (DTEXT(LOGHDRS"TCP disconnecting\n"),
                          LOGHDR(21, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
        CtdiDisconnect(pCtl->hCtdi, FALSE);
        CtdiClose(pCtl->hCtdi);
        pCtl->hCtdi = NULL;
    }
    if (pCtl->hCtdiEndpoint)
    {
        CtdiClose(pCtl->hCtdiEndpoint);
        pCtl->hCtdiEndpoint = NULL;
    }

    CleanupComplete = TRUE;


ccDone:
    if (!CleanupComplete)
    {
        pCtl->Cleanup = FALSE;
    }
    NdisReleaseSpinLock(&pCtl->Lock);
    DEREFERENCE_OBJECT(pCtl);  // For this work item.
    if (CleanupComplete)
    {
        //CtdiDeleteHostRoute(&pCtl->Remote.Address);

        DEREFERENCE_OBJECT(pCtl);  // Should be last one
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpCleanup\n")));
}

VOID
CtlCleanup(
    PCONTROL_TUNNEL pCtl,
    BOOLEAN Locked
    )
{
    DEBUGMSG(DBG_FUNC|DBG_TUNNEL, (DTEXT("+CtlCleanup %08x\n"), pCtl));

    if (!Locked)
    {
        NdisAcquireSpinLock(&pCtl->Lock);
    }
    if (IS_CTL(pCtl) && !pCtl->Cleanup)
    {
        REFERENCE_OBJECT(pCtl);
        pCtl->Cleanup = TRUE;
        if (ScheduleWorkItem(CtlpCleanup, pCtl, NULL, 0)!=NDIS_STATUS_SUCCESS)
        {
            DEREFERENCE_OBJECT(pCtl);
        }
    }
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCtl->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlCleanup\n")));
}

VOID
CtlpQueryConnInfoCallback(
    IN      PVOID                       pContext,
    IN      PVOID                       pData,
    IN      NDIS_STATUS                 Result
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    PTDI_CONNECTION_INFO pInfo = pData;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpQueryConnInfoCallback Result=%x\n"), Result));

    ASSERT(IS_CTL(pCtl));
    if (Result==NDIS_STATUS_SUCCESS && IS_CTL(pCtl) && pCtl->State!=STATE_CTL_CLEANUP)
    {
        pCtl->Speed = (pInfo->Throughput.QuadPart==-1) ? 0 : pInfo->Throughput.LowPart;
        DBG_D(DBG_INIT, pCtl->Speed);
    }
    MyMemFree(pInfo, sizeof(*pInfo));
    DEREFERENCE_OBJECT(pCtl);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpQueryConnInfoCallback\n")));
}

STATIC VOID
CtlpEngine(
    IN PCONTROL_TUNNEL pCtl,
    IN PUCHAR pNewData,
    IN ULONG Length
    )
{
    UNALIGNED PPTP_HEADER *pHeader;
    ULONG NeededLength;
    ULONG MessageType;
    BOOLEAN TimerStopped;
    BOOLEAN PacketValid = FALSE;
    BOOLEAN Shutdown = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpEngine\n")));
    // Check to see if we have a full packet yet.

    ASSERT(IS_CTL(pCtl));
    while (Length)
    {
        if (pCtl->BytesInPartialBuffer)
        {
            while (Length && pCtl->BytesInPartialBuffer < sizeof(PPTP_HEADER))
            {
                pCtl->PartialPacketBuffer[pCtl->BytesInPartialBuffer++] = *pNewData++;
                Length--;
            }
            if (pCtl->BytesInPartialBuffer < sizeof(PPTP_HEADER))
            {
                return;
            }
            pHeader = (UNALIGNED PPTP_HEADER*)pCtl->PartialPacketBuffer;
        }
        else if (Length >= sizeof(PPTP_HEADER))
        {
            pHeader = (UNALIGNED PPTP_HEADER*)pNewData;
        }
        else
        {
            // Too little data.  Copy and exit.
            memcpy(pCtl->PartialPacketBuffer, pNewData, Length);
            pCtl->BytesInPartialBuffer = Length;
            return;
        }

        // We have the header.  Validate it.

        NeededLength = htons(pHeader->Length);
        MessageType = htons(pHeader->MessageType);

        if (NeededLength <= MAX_CONTROL_PACKET_LENGTH &&
            pHeader->Cookie == htonl(PPTP_MAGIC_COOKIE) &&
            pHeader->PacketType == htons(PPTP_CONTROL_MESSAGE) &&
            MessageType >= CONTROL_START_REQUEST &&
            MessageType < NUM_MESSAGE_TYPES)
        {
            // ToDo: will probably need some v2 code here for the first packet
            if (NeededLength == pCtl->PptpMessageLength[MessageType])
            {
                PacketValid = TRUE;
            }
        }

        if (PacketValid)
        {
            if (pCtl->BytesInPartialBuffer+Length < NeededLength)
            {
                // We don't have the whole packet yet.  Copy and exit.
                memcpy(&pCtl->PartialPacketBuffer[pCtl->BytesInPartialBuffer],
                       pNewData,
                       Length);
                pCtl->BytesInPartialBuffer += Length;
                return;
            }

            if (pCtl->BytesInPartialBuffer)
            {
                // Make cetain the entire packet is in our PartialPacketBuffer and process it there.
                NeededLength -= pCtl->BytesInPartialBuffer;
                memcpy(&pCtl->PartialPacketBuffer[pCtl->BytesInPartialBuffer],
                       pNewData,
                       NeededLength);

                // We now have one complete packet in the PartialPacketBuffer

                pNewData += NeededLength;
                Length -= NeededLength;

                pHeader = (UNALIGNED PPTP_HEADER *)pCtl->PartialPacketBuffer;

                // We've got the whole packet, and we're about to consume it
                // Clear the var so next time through we start from the buffer
                // beginning
                pCtl->BytesInPartialBuffer = 0;
            }
            else
            {
                // The whole packet is in the new buffer.  Process it there.
                pHeader = (UNALIGNED PPTP_HEADER *)pNewData;
                pNewData += NeededLength;
                Length -= NeededLength;
            }

            switch (htons(pHeader->MessageType))
            {
                case CONTROL_START_REQUEST:
                {
                    UNALIGNED PPTP_CONTROL_START_PACKET *pPacket = 
                        (UNALIGNED PPTP_CONTROL_START_PACKET*)pHeader;
                    UNALIGNED PPTP_CONTROL_START_PACKET *pReply;
                    NDIS_STATUS Status;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CONTROL_START_REQUEST RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CONTROL_START_REQUEST RECEIVED\n"),
                                          LOGHDR(2, pCtl->Remote.Address.Address[0].Address[0].in_addr)));


                    switch (pCtl->State)
                    {
                        case STATE_CTL_WAIT_REQUEST:
                        {
                            pReply = CtlAllocPacket(pCtl, CONTROL_START_REPLY);

                            if (pReply)
                            {
                                PTDI_CONNECTION_INFO pInfo;
                                NdisMCancelTimer(&pCtl->WaitTimeout, &TimerStopped);
                                // Take the pertinent data.

                                pCtl->Remote.Version = htons(pPacket->Version);
                                pCtl->Remote.Framing = htonl(pPacket->FramingCapabilities);
                                pCtl->Remote.Bearer = htonl(pPacket->BearerCapabilities);
                                memcpy(pCtl->Remote.HostName, pPacket->HostName, MAX_HOSTNAME_LENGTH);
                                pCtl->Remote.HostName[MAX_HOSTNAME_LENGTH-1] = '\0';
                                memcpy(pCtl->Remote.Vendor, pPacket->Vendor, MAX_VENDOR_LENGTH);
                                pCtl->Remote.Vendor[MAX_VENDOR_LENGTH-1] = '\0';

                                DBG_X(DBG_PACKET, pCtl->Remote.Version);
                                DBG_X(DBG_PACKET, pCtl->Remote.Framing);
                                DBG_X(DBG_PACKET, pCtl->Remote.Bearer);
                                DBG_S(DBG_PACKET, pCtl->Remote.HostName);
                                DBG_S(DBG_PACKET, pCtl->Remote.Vendor);

                                if (pCtl->Remote.Version==PPTP_PROTOCOL_VERSION_1_00)
                                {
                                    pReply->Version = ntohs(PPTP_PROTOCOL_VERSION_1_00);
                                    pReply->ResultCode = RESULT_CONTROL_START_SUCCESS;
                                    pReply->FramingCapabilities = htonl(FRAMING_SYNC);
                                    pReply->BearerCapabilities = htonl(BEARER_ANALOG|BEARER_DIGITAL);
                                    pReply->MaxChannels = 0;
                                    pReply->FirmwareRevision = htons(PPTP_FIRMWARE_REVISION);
                                    strcpy(pReply->Vendor, PPTP_VENDOR);
                                }
                                else
                                {
                                    // ToDo: implement new version
                                    ASSERT(0);
                                }
                                CtlSetState(pCtl, STATE_CTL_ESTABLISHED, 0, UNLOCKED);
                                CtlSend(pCtl, pReply);  // ToDo: return value?

                                pInfo = MyMemAlloc(sizeof(*pInfo), TAG_CTL_CONNINFO);
                                if (pInfo)
                                {
                                    REFERENCE_OBJECT(pCtl);

                                    Status = CtdiQueryInformation(pCtl->hCtdi,
                                                                  TDI_QUERY_CONNECTION_INFO,
                                                                  pInfo,
                                                                  sizeof(*pInfo),
                                                                  CtlpQueryConnInfoCallback,
                                                                  pCtl);
                                    ASSERT(NT_SUCCESS(Status));
                                    Status = NDIS_STATUS_SUCCESS;
                                }
                            }
                            else
                            {
                                // Alloc failed.  Do nothing, and timeout will cause cleanup.
                            }

                            break;
                        }
                        case STATE_CTL_CLEANUP:
                            DEBUGMSG(DBG_WARN, (DTEXT("Shutting down tunnel, ignore packet\n")));
                            break;
                        default:
                            DEBUGMSG(DBG_WARN, (DTEXT("Bad state, shutdown tunnel\n")));
                            Shutdown = TRUE;
                            break;
                    }
                    break;
                }
                case CONTROL_START_REPLY:
                {
                    UNALIGNED PPTP_CONTROL_START_PACKET *pPacket = 
                        (UNALIGNED PPTP_CONTROL_START_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CONTROL_START_REPLY RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CTL CONTROL_START_REPLY RECEIVED\n"),
                                          LOGHDR(3, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                    switch (pCtl->State)
                    {
                        case STATE_CTL_WAIT_REPLY:
                        {
                            ENUM_CONTEXT Enum;
                            PCALL_SESSION pCall;
                            PLIST_ENTRY pListEntry;

                            NdisMCancelTimer(&pCtl->WaitTimeout, &TimerStopped);

                            // Take the pertinent data.
                            pCtl->Remote.Version = htons(pPacket->Version);
                            pCtl->Remote.Framing = htonl(pPacket->FramingCapabilities);
                            pCtl->Remote.Bearer = htonl(pPacket->BearerCapabilities);
                            memcpy(pCtl->Remote.HostName, pPacket->HostName, MAX_HOSTNAME_LENGTH);
                            pCtl->Remote.HostName[MAX_HOSTNAME_LENGTH-1] = '\0';
                            memcpy(pCtl->Remote.Vendor, pPacket->Vendor, MAX_VENDOR_LENGTH);
                            pCtl->Remote.Vendor[MAX_VENDOR_LENGTH-1] = '\0';

                            DBG_X(DBG_PACKET, pCtl->Remote.Version);
                            DBG_X(DBG_PACKET, pCtl->Remote.Framing);
                            DBG_X(DBG_PACKET, pCtl->Remote.Bearer);
                            DBG_S(DBG_PACKET, pCtl->Remote.HostName);
                            DBG_S(DBG_PACKET, pCtl->Remote.Vendor);

                            CtlSetState(pCtl, STATE_CTL_ESTABLISHED, 0, UNLOCKED);

                            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Control Channel Successfully Established\n"),
                                              LOGHDR(4, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                            // Notify all calls on this session.
                            REFERENCE_OBJECT(pCtl);
                            InitEnumContext(&Enum);
                            while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
                            {
                                pCall = CONTAINING_RECORD(pListEntry,
                                                          CALL_SESSION,
                                                          ListEntry);
                                if (IS_CALL(pCall))
                                {
                                    CallEventOutboundTunnelEstablished(pCall,
                                                                       NDIS_STATUS_SUCCESS);
                                }
                            }
                            EnumComplete(&Enum, &pCtl->pAdapter->Lock);
                            DEREFERENCE_OBJECT(pCtl);  // pair above
                            break;
                        }
                        default:
                            break;
                    }
                    break;
                }
                case CONTROL_ECHO_REQUEST:
                {
                    UNALIGNED PPTP_CONTROL_ECHO_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CONTROL_ECHO_REQUEST_PACKET*)pHeader;
                    UNALIGNED PPTP_CONTROL_ECHO_REPLY_PACKET *pReply;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("ECHO_REQUEST RECEIVED\n")));

                    DBG_X(DBG_PACKET, pPacket->Identifier);

                    pCtl->Echo.Needed = FALSE;
                    pReply = CtlAllocPacket(pCtl, CONTROL_ECHO_REPLY);
                    if (pReply)
                    {
                        if (pCtl->Remote.Version==PPTP_PROTOCOL_VERSION_1_00)
                        {
                            pReply->Identifier = pPacket->Identifier;
                            pReply->ResultCode = RESULT_CONTROL_ECHO_SUCCESS;
                            // ToDo: why would we send a ResultCode==failure?
                            CtlSend(pCtl, pReply);  // ToDo: return value?
                        }
                        else
                        {
                            // ToDo: implement new version
                            DEBUGMSG(DBG_WARN, (DTEXT("Echo request received when version unknown or wrong. Ignoring.\n")));
                        }
                    }

                    break;
                }
                case CALL_OUT_REQUEST:
                {
                    UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_OUT_REQUEST RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CTL CALL_OUT_REQUEST RECEIVED\n"),
                                          LOGHDR(5, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                    switch (pCtl->State)
                    {
                        case STATE_CTL_ESTABLISHED:
                        {
                            DBG_X(DBG_TUNNEL, htons(pPacket->CallId));
                            DBG_X(DBG_TUNNEL, htons(pPacket->SerialNumber));
                            DBG_D(DBG_TUNNEL, htonl(pPacket->MinimumBPS));
                            DBG_D(DBG_TUNNEL, htonl(pPacket->MaximumBPS));
                            DBG_X(DBG_TUNNEL, htonl(pPacket->BearerType));
                            DBG_X(DBG_TUNNEL, htonl(pPacket->FramingType));
                            DBG_X(DBG_TUNNEL, htons(pPacket->RecvWindowSize));
                            DBG_X(DBG_TUNNEL, htons(pPacket->ProcessingDelay));
                            DBG_X(DBG_TUNNEL, htons(pPacket->PhoneNumberLength));
                            DBG_S(DBG_TUNNEL, pPacket->PhoneNumber);
                            DBG_S(DBG_TUNNEL, pPacket->Subaddress);

                            // It's possible we had just closed our last call & were
                            // waiting for a CONTROL_STOP_REQUEST from the other side.
                            NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                            CallEventCallOutRequest(pCtl->pAdapter,
                                                    pCtl,
                                                    pPacket);
                            break;
                        }
                        default:
                            // Bogus, but not enough to kill us.  Ignore it.
                            break;
                    }
                    break;
                }
                case CALL_OUT_REPLY:
                {
                    UNALIGNED PPTP_CALL_OUT_REPLY_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_OUT_REPLY_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_OUT_REPLY RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CALL_OUT_REPLY RECEIVED\n"),
                                          LOGHDR(6, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ULONG CallId = htons(pPacket->PeerCallId);
                        PCALL_SESSION pCall = CallGetCall(pCtl->pAdapter, CallIdToDeviceId(CallId));

                        if (pCall)
                        {
                            DBG_X(DBG_TUNNEL, htons(pPacket->PeerCallId));
                            DBG_X(DBG_TUNNEL, pPacket->ResultCode);
                            DBG_X(DBG_TUNNEL, pPacket->ErrorCode);
                            DBG_X(DBG_TUNNEL, htons(pPacket->CauseCode));
                            DBG_D(DBG_TUNNEL, htonl(pPacket->ConnectSpeed));
                            DBG_D(DBG_TUNNEL, htons(pPacket->RecvWindowSize));
                            DBG_X(DBG_TUNNEL, htonl(pPacket->PhysicalChannelId));

                            CallEventCallOutReply(pCall, pPacket);
                        }
                        else
                        {
                            DEBUGMSG(DBG_WARN, (DTEXT("Bogus PeerCallId\n")));
                        }

                    }
                    else
                    {
                        // Bogus, but not enough to kill us.  Ignore it.
                    }
                    break;
                }
                case CALL_CLEAR_REQUEST:
                {
                    UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_CLEAR_REQUEST RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CALL_CLEAR_REQUEST RECEIVED\n"),
                                          LOGHDR(7, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ULONG CallId = htons(pPacket->CallId);
                        ENUM_CONTEXT Enum;
                        PCALL_SESSION pCall;
                        PLIST_ENTRY pListEntry;

                        // The peer has given us his own call ID, which does little
                        // good for fast lookup of the call.  Find the associated call.
                        REFERENCE_OBJECT(pCtl);

                        InitEnumContext(&Enum);

                        do
                        {
                            NdisAcquireSpinLock(&pCtl->pAdapter->Lock);
                            pListEntry = EnumListEntry(&pCtl->CallList, &Enum, NULL);
                            if(pListEntry != NULL)
                            {
                                pCall = CONTAINING_RECORD(pListEntry,
                                                          CALL_SESSION,
                                                          ListEntry);
                                if (IS_CALL(pCall) && pCall->pCtl==pCtl && pCall->Remote.CallId==CallId)
                                {
                                    REFERENCE_OBJECT(pCall);
                                    NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
                                    CallEventCallClearRequest(pCall, pPacket, pCtl);
                                    DEREFERENCE_OBJECT(pCall);
                                    break;
                                }
                            }
                            NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
                        
                        } while(pListEntry != NULL);
#if 0                        
                        while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
                        {
                            pCall = CONTAINING_RECORD(pListEntry,
                                                      CALL_SESSION,
                                                      ListEntry);
                            if (IS_CALL(pCall) && pCall->pCtl==pCtl && pCall->Remote.CallId==CallId)
                            {
                                CallEventCallClearRequest(pCall, pPacket);
                                break;
                            }
                        }

#endif                        
                        EnumComplete(&Enum, &pCtl->pAdapter->Lock);
                        DEREFERENCE_OBJECT(pCtl);  // pair above
                    }
                    break;
                }
                case CALL_DISCONNECT_NOTIFY:
                {
                    UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_DISCONNECT_NOTIFY RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CALL_DISCONNECT_NOTIFY RECEIVED\n"),
                                          LOGHDR(8, pCtl->Remote.Address.Address[0].Address[0].in_addr)));


                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ULONG CallId = htons(pPacket->CallId);
                        ENUM_CONTEXT Enum;
                        PCALL_SESSION pCall;
                        PLIST_ENTRY pListEntry;

                        // The peer has given us his own call ID, which does little
                        // good for fast lookup of the call.  Find the associated call.
                        REFERENCE_OBJECT(pCtl);

                        InitEnumContext(&Enum);
                        while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
                        {
                            pCall = CONTAINING_RECORD(pListEntry,
                                                      CALL_SESSION,
                                                      ListEntry);
                            if (IS_CALL(pCall) && pCall->pCtl==pCtl && pCall->Remote.CallId==CallId)
                            {
                                DBG_X(DBG_TUNNEL, htons(pPacket->CallId));
                                DBG_X(DBG_TUNNEL, pPacket->ResultCode);
                                DBG_X(DBG_TUNNEL, pPacket->ErrorCode);
                                DBG_X(DBG_TUNNEL, htons(pPacket->CauseCode));

                                CallEventCallDisconnectNotify(pCall, pPacket);
                                break;
                            }
                        }
                        EnumComplete(&Enum, &pCtl->pAdapter->Lock);
                        DEREFERENCE_OBJECT(pCtl);  // pair above

                    }
                    break;
                }
                case CONTROL_STOP_REQUEST:
                {
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CONTROL_STOP_REQUEST RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CONTROL_STOP_REQUEST RECEIVED\n"),
                                          LOGHDR(9, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
                    switch (pCtl->State)
                    {
                        case STATE_CTL_WAIT_STOP:
                        {
                            NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                            // No break
                        }
                        case STATE_CTL_WAIT_REPLY:
                        case STATE_CTL_ESTABLISHED:
                        {
                            UNALIGNED PPTP_CONTROL_STOP_PACKET *pReply;

                            pReply = CtlAllocPacket(pCtl, CONTROL_STOP_REPLY);
                            if (pReply)
                            {
                                pReply->ResultCode = RESULT_CONTROL_STOP_SUCCESS;
                                CtlSend(pCtl, pReply);
                            }
                            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
                            CtlCleanup(pCtl, UNLOCKED);
                            break;
                        }
                        default:
                            break;
                    }
                    break;
                }
                case CONTROL_STOP_REPLY:
                {
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CONTROL_STOP_REPLY RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CONTROL_STOP_REPLY RECEIVED\n"),
                                          LOGHDR(10, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
                    if (pCtl->State==STATE_CTL_WAIT_STOP)
                    {
                        NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
                        CtlCleanup(pCtl, UNLOCKED);
                    }
                    break;
                }
                case SET_LINK_INFO:
                {
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("SET_LINK_INFO RECEIVED\n")));
                    break;
                }
                case CALL_IN_REQUEST:
                {
                    UNALIGNED PPTP_CALL_IN_REQUEST_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_IN_REQUEST_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_IN_REQUEST RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CALL_IN_REQUEST RECEIVED\n"),
                                          LOGHDR(11, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        DBG_X(DBG_TUNNEL, htons(pPacket->CallId));
                        DBG_X(DBG_TUNNEL, htons(pPacket->SerialNumber));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->BearerType));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->PhysicalChannelId));
                        DBG_X(DBG_TUNNEL, htons(pPacket->DialedNumberLength));
                        DBG_X(DBG_TUNNEL, htons(pPacket->DialingNumberLength));
                        DBG_S(DBG_TUNNEL, pPacket->DialedNumber);
                        DBG_S(DBG_TUNNEL, pPacket->DialingNumber);
                        DBG_S(DBG_TUNNEL, pPacket->Subaddress);

                        // It's possible we had just closed our last call & were
                        // waiting for a CONTROL_STOP_REQUEST from the other side.
                        NdisMCancelTimer(&pCtl->StopTimeout, &TimerStopped);
                        CallEventCallInRequest(pCtl->pAdapter,
                                               pCtl,
                                               pPacket);
                    }

                    break;
                }
                case CALL_IN_REPLY:
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_IN_REPLY RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CALL_IN_REPLY RECEIVED\n"),
                                          LOGHDR(12, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
                    // We should never get one of these.
                    break;
                case CALL_IN_CONNECTED:
                {
                    UNALIGNED PPTP_CALL_IN_CONNECT_PACKET *pPacket = 
                        (UNALIGNED PPTP_CALL_IN_CONNECT_PACKET*)pHeader;

                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CALL_IN_CONNECTED RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"CALL_IN_CONNECTED RECEIVED\n"),
                                          LOGHDR(13, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

                    if (pCtl->State==STATE_CTL_ESTABLISHED)
                    {
                        ULONG CallId = htons(pPacket->PeerCallId);
                        PCALL_SESSION pCall;

                        DBG_X(DBG_TUNNEL, htons(pPacket->PeerCallId));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->ConnectSpeed));
                        DBG_X(DBG_TUNNEL, htons(pPacket->RecvWindowSize));
                        DBG_X(DBG_TUNNEL, htons(pPacket->ProcessingDelay));
                        DBG_X(DBG_TUNNEL, htonl(pPacket->FramingType));

                        pCall = CallGetCall(pCtl->pAdapter, CallIdToDeviceId(CallId));
                        if (pCall)
                        {
                            CallEventCallInConnect(pCall, pPacket);
                        }
                    }

                    break;
                }
                case CONTROL_ECHO_REPLY:
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("CONTROL_ECHO_REPLY RECEIVED\n")));
                    break;
                case WAN_ERROR_NOTIFY:
                    DEBUGMSG(DBG_TUNNEL, (DTEXT("WAN_ERROR_NOTIFY RECEIVED\n")));
                    break;
                default:
                    DEBUGMSG(DBG_TUNNEL|DBG_WARN, (DTEXT("UNKNOWN RECEIVED\n")));
                    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"Unknown control packet received\n"),
                                          LOGHDR(23, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
                    break;
            }
        }
        else // !PacketValid
        {
            Shutdown = TRUE;
        }

        if (Shutdown)
        {
            DEBUGMSG(DBG_TUNNEL|DBG_ERROR, (DTEXT("Tunnel problem, shutting it down.\n")));
            break;
        }
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpEngine\n")));
}

NDIS_STATUS
CtlConnectQueryCallback(
    IN      PVOID                pContext,
    IN      PTRANSPORT_ADDRESS   pAddress,
    IN      HANDLE               hNewCtdi,
    OUT     PVOID               *pNewContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_ADAPTER pAdapter = pContext;
    PTA_IP_ADDRESS pIp = (PTA_IP_ADDRESS)pAddress;
    PCONTROL_TUNNEL pCtl;
    BOOLEAN Accepting = TRUE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlConnectQueryCallback\n")));

    DEBUGMSG(DBG_TUNNEL, (DTEXT("Request to connect from %d.%d.%d.%d\n"),
                          IPADDR(pIp->Address[0].Address[0].in_addr)));
    LOGMSG(FLL_USER, (DTEXT(LOGHDRS"TCP connection request\n"),
                      LOGHDR(1, pIp->Address[0].Address[0].in_addr)));

    if (PptpAuthenticateIncomingCalls)
    {
        ULONG i;
        BOOLEAN Match = FALSE;
        for (i=0; i<NumClientAddresses; i++)
        {
            if ((pIp->Address[0].Address[0].in_addr&ClientList[i].Mask)==
                (ClientList[i].Address&ClientList[i].Mask))
            {
                Match = TRUE;
                break;
            }
        }
        if (!Match)
        {
            DEBUGMSG(DBG_TUNNEL|DBG_WARN, (DTEXT("No match found for IP %d.%d.%d.%d.  Refused.\n"),
                                IPADDR(pIp->Address[0].Address[0].in_addr)));
            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"IP not authenticated\n"),
                              LOGHDR(24, pIp->Address[0].Address[0].in_addr)));
            Accepting = FALSE;
            Status = NDIS_STATUS_FAILURE;
        }
    }

    if (Accepting)
    {
        pCtl = CtlAlloc(pAdapter);

        if (!pCtl)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {

            NdisAcquireSpinLock(&pAdapter->Lock);
            CtlSetState(pCtl, STATE_CTL_WAIT_REQUEST, 0, LOCKED);
            pCtl->Inbound = TRUE;
            NdisReleaseSpinLock(&pAdapter->Lock);
            NdisAcquireSpinLock(&pCtl->Lock);
            pCtl->hCtdi = hNewCtdi;
            pCtl->Remote.Address = *pIp;
            NdisMSetTimer(&pCtl->WaitTimeout, PptpMessageTimeout*1000);
            if (PptpEchoTimeout)
            {
                NdisMSetPeriodicTimer(&pCtl->Echo.Timer, PptpEchoTimeout*1000);
                pCtl->Echo.Needed = TRUE;
            }
            NdisReleaseSpinLock(&pCtl->Lock);
            *pNewContext = pCtl;
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlConnectQueryCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlConnectCompleteCallback(
    IN      PVOID                       pContext,
    IN      HANDLE                      hNewCtdi,
    IN      NDIS_STATUS                 ConnectStatus
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCONTROL_TUNNEL pCtl = pContext;
    PPTP_CONTROL_START_PACKET *pPacket = NULL;
    PTDI_CONNECTION_INFO pInfo;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlConnectCompleteCallback\n")));

    if (IS_CTL(pCtl))
    {
        if (pCtl->State!=STATE_CTL_DIALING)
        {
            DEBUGMSG(DBG_TUNNEL|DBG_ERR(Status), (DTEXT("Ctl in wrong state after connect %d\n"), pCtl->State));
            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            CtlCleanup(pCtl, UNLOCKED);
            Status = NDIS_STATUS_FAILURE;
        }
        else if (ConnectStatus==NDIS_STATUS_SUCCESS)
        {
            pPacket = CtlAllocPacket(pCtl, CONTROL_START_REQUEST);
            CtlSetState(pCtl, STATE_CTL_WAIT_REPLY, 0, UNLOCKED);
            NdisAcquireSpinLock(&pCtl->Lock);
            pCtl->hCtdi = hNewCtdi;
            NdisMSetTimer(&pCtl->WaitTimeout, PptpMessageTimeout*1000);
            if (PptpEchoTimeout)
            {
                NdisMSetPeriodicTimer(&pCtl->Echo.Timer, PptpEchoTimeout*1000);
                pCtl->Echo.Needed = TRUE;
            }
            NdisReleaseSpinLock(&pCtl->Lock);

            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Control channel TCP/IP port successfully connected\n"),
                              LOGHDR(14, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Starting PPTP control channel setup\n"),
                              LOGHDR(15, pCtl->Remote.Address.Address[0].Address[0].in_addr)));
            OsFileLogFlush();

            if (pPacket)
            {
                pPacket->Version = ntohs(PPTP_PROTOCOL_VERSION_1_00);  // ToDo: do v2
                pPacket->FramingCapabilities = ntohl(FRAMING_ASYNC);
                pPacket->BearerCapabilities = ntohl(BEARER_ANALOG);
                pPacket->MaxChannels = 0;
                pPacket->FirmwareRevision = htons(PPTP_FIRMWARE_REVISION);
                strcpy(pPacket->Vendor, PPTP_VENDOR);
                CtlSend(pCtl, pPacket); // ToDo: return value?
            }
            else
            {
                // Allocation failure will be covered by timeout
            }
            pInfo = MyMemAlloc(sizeof(*pInfo), TAG_CTL_CONNINFO);
            if (pInfo)
            {
                REFERENCE_OBJECT(pCtl);

                Status = CtdiQueryInformation(pCtl->hCtdi,
                                              TDI_QUERY_CONNECTION_INFO,
                                              pInfo,
                                              sizeof(*pInfo),
                                              CtlpQueryConnInfoCallback,
                                              pCtl);
                ASSERT(NT_SUCCESS(Status));
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            ENUM_CONTEXT Enum;
            PCALL_SESSION pCall;
            PLIST_ENTRY pListEntry;

            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Connection failed: NDIS Error 0x%x\n"),
                              LOGHDR(16, pCtl->Remote.Address.Address[0].Address[0].in_addr),
                              ConnectStatus));

            REFERENCE_OBJECT(pCtl);
            InitEnumContext(&Enum);
            while (pListEntry = EnumListEntry(&pCtl->CallList, &Enum, &pCtl->pAdapter->Lock))
            {
                pCall = CONTAINING_RECORD(pListEntry,
                                          CALL_SESSION,
                                          ListEntry);
                if (IS_CALL(pCall))
                {
                    CallEventConnectFailure(pCall, ConnectStatus);
                }
            }
            EnumComplete(&Enum, &pCtl->pAdapter->Lock);
            DEREFERENCE_OBJECT(pCtl);  // pair above
            Status = NDIS_STATUS_FAILURE;
        }
        DEREFERENCE_OBJECT(pCtl);  // pair at call to CtdiConnect
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlConnectCompleteCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlDisconnectCallback(
    IN      PVOID                       pContext,
    IN      BOOLEAN                     Abortive
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCONTROL_TUNNEL pCtl = pContext;
    BOOLEAN Cleanup = TRUE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlDisconnectCallback\n")));

    LOGMSG(FLL_USER, (DTEXT(LOGHDRS"TCP disconnected\n"),
                      LOGHDR(20, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

    NdisAcquireSpinLock(&pCtl->pAdapter->Lock);

    if (pCtl->State!=STATE_CTL_CLEANUP)
    {
        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, LOCKED);
        Cleanup = TRUE;
    }
    NdisReleaseSpinLock(&pCtl->pAdapter->Lock);

    if (Cleanup)
    {
        CtlCleanup(pCtl, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlDisconnectCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlReceiveCallback(
    IN      PVOID                       pContext,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCONTROL_TUNNEL pCtl = pContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlReceiveCallback\n")));

    // We must copy or consume the data before leaving this function.
    ASSERT(IS_CTL(pCtl));
    CtlpEngine(pCtl, pBuffer, ulLength);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlReceiveCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlConnectCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PCALL_SESSION pCall,
    IN PTA_IP_ADDRESS pTargetAddress
    )
{
    TA_IP_ADDRESS Local;
    PCONTROL_TUNNEL pCtl = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    BOOLEAN SignalEstablished = FALSE;
    BOOLEAN Connected = FALSE;
    BOOLEAN InvalidAddress = (pTargetAddress->TAAddressCount == 0xffffffff);  // Magic cookie passed set by

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlConnectCall\n")));

    DEBUGMSG(DBG_CALL, (DTEXT("New Dial request: Call:%08x  Ctl:%08x  Addr:%08x\n"),
                        pCall, pCtl, pTargetAddress->Address[0].Address[0].in_addr));

    if( !InvalidAddress ){
        InitEnumContext(&Enum);
        NdisAcquireSpinLock(&pAdapter->Lock);
        while (!Connected && (pListEntry = EnumListEntry(&pAdapter->ControlTunnelList, &Enum, NULL)))
        {

            pCtl = CONTAINING_RECORD(pListEntry, CONTROL_TUNNEL, ListEntry);

            if (IS_CTL(pCtl) &&
                (pCtl->State>=STATE_CTL_DIALING && pCtl->State<=STATE_CTL_ESTABLISHED) &&
                pTargetAddress->Address[0].Address[0].in_addr==pCtl->Remote.Address.Address[0].Address[0].in_addr)
            {
                DEBUGMSG(DBG_CALL, (DTEXT("Existing tunnel found for call %08x\n"), pCall));

                REFERENCE_OBJECT(pCtl);
                NdisReleaseSpinLock(&pAdapter->Lock);
                Connected = CallConnectToCtl(pCall, pCtl, FALSE);
                if (Connected)
                {
                    // keep the reference for now
                }
                else
                {
                    DEREFERENCE_OBJECT(pCtl);
                }
                NdisAcquireSpinLock(&pAdapter->Lock);

                if (Connected && pCtl->State==STATE_CTL_ESTABLISHED)
                {
                    SignalEstablished = TRUE;
                }
            }
        }
        EnumComplete(&Enum, NULL);
        NdisReleaseSpinLock(&pAdapter->Lock);
    }

    if (Connected)
    {
        if (SignalEstablished)
        {
            CallEventOutboundTunnelEstablished(pCall,
                                               NDIS_STATUS_SUCCESS);
        }
        // We found an existing tunnel, for which we have a reference.  Drop it.
        DEREFERENCE_OBJECT(pCtl);
    }
    else
    {
        HANDLE hCtdiEndpoint;
        pCtl = CtlAlloc(pAdapter);

        if (!pCtl)
        {
            Status = NDIS_STATUS_RESOURCES;
            goto cmcDone;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        CtlSetState(pCtl, STATE_CTL_DIALING, 0, LOCKED);

        pCtl->Inbound = pCall->Inbound;
        NdisReleaseSpinLock(&pAdapter->Lock);

        Connected = CallConnectToCtl(pCall, pCtl, FALSE);
        if (!Connected)
        {
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            NdisZeroMemory(&Local, sizeof(Local));

            if( InvalidAddress ){
                DEBUGMSG(DBG_ERROR, (DTEXT("Disconnecting due to error passed down from gethostbyname\n")));
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_UNREACHABLE, UNLOCKED);
                goto cmcDone;
            }

            Local.TAAddressCount = 1;
            Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
            Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
            Local.Address[0].Address[0].sin_port = 0;
            Local.Address[0].Address[0].in_addr = 0;

            Status = CtdiCreateEndpoint(&hCtdiEndpoint,
                                        AF_INET,
                                        SOCK_STREAM,
                                        (PTRANSPORT_ADDRESS)&Local,
                                        0);
            if (Status!=NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint failed %08x\n"), Status));
                goto cmcDone;
            }

            NdisAcquireSpinLock(&pCtl->Lock);
            pCtl->hCtdiEndpoint = hCtdiEndpoint;
            pCtl->Remote.Address = *pTargetAddress;
            REFERENCE_OBJECT(pCtl);  // Pair in CtlConnectCompleteCallback
            NdisReleaseSpinLock(&pCtl->Lock);

            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Attempting to connect to remote computer via TCP/IP\n"),
                              LOGHDR(17, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

            Status = CtdiConnect(pCtl->hCtdiEndpoint,
                                 (PTRANSPORT_ADDRESS)pTargetAddress,
                                 CtlConnectCompleteCallback,
                                 CtlReceiveCallback,
                                 CtlDisconnectCallback,
                                 pCtl);
        }
    }

cmcDone:
    if ( (Status!=NDIS_STATUS_SUCCESS && Status!=NDIS_STATUS_PENDING) || InvalidAddress)
    {
        if (IS_CTL(pCtl))
        {
            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Connection failed immediately NDIS Error 0x%x\n"),
                    LOGHDR(18, pCtl->Remote.Address.Address[0].Address[0].in_addr),Status));

            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            CtlCleanup(pCtl, UNLOCKED);
        }

    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlConnectCall %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlDisconnectCall(
    IN PCALL_SESSION pCall
    )
{
    PPPTP_ADAPTER pAdapter = pCall->pAdapter;
    PCONTROL_TUNNEL pCtl = pCall->pCtl;
    BOOLEAN Inbound = pCall->Inbound;
    BOOLEAN CloseTunnelNow = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlDisconnectCall\n")));
    ASSERT(IS_CTL(pCtl));

    DEBUGMSG(DBG_CALL, (DTEXT("Call:%08x disconnected\n"), pCall));
    REFERENCE_OBJECT(pCtl);
    CallDisconnectFromCtl(pCall, pCtl);

    NdisAcquireSpinLock(&pAdapter->Lock);
    if (IsListEmpty(&pCtl->CallList))
    {
        if (pCtl->State==STATE_CTL_ESTABLISHED)
        {
            if (!pCtl->Inbound)
            {
                CtlSetState(pCtl, STATE_CTL_WAIT_STOP, 0, LOCKED);
                CloseTunnelNow = TRUE;
            }
            else
            {
                NdisMSetTimer(&pCtl->StopTimeout, PptpMessageTimeout*1000);
            }
        }
        else
        {
            // Tunnel is already gone.
            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, LOCKED);
            NdisReleaseSpinLock(&pAdapter->Lock);
            CtlCleanup(pCtl, UNLOCKED);
            NdisAcquireSpinLock(&pAdapter->Lock);
        }
    }
    NdisReleaseSpinLock(&pAdapter->Lock);

    if (CloseTunnelNow)
    {
        PPPTP_CONTROL_STOP_PACKET pPacket;
        pPacket = CtlAllocPacket(pCtl, CONTROL_STOP_REQUEST);

        if (!pPacket)
        {
            Status = NDIS_STATUS_RESOURCES;
            // Don't attempt to shutdown gracefully.  Just close everything.
            CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
            CtlCleanup(pCtl, UNLOCKED);
        }
        else
        {
            pPacket->Reason = CONTROL_STOP_GENERAL;
            CtlSend(pCtl, pPacket);
            NdisAcquireSpinLock(&pCtl->Lock);
            NdisMSetTimer(&pCtl->StopTimeout, PptpMessageTimeout*1000);
            NdisReleaseSpinLock(&pCtl->Lock);
        }
    }

    DEREFERENCE_OBJECT(pCtl); // Pair above
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlDisconnectCall, %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtlListen(
    IN PPPTP_ADAPTER pAdapter
    )
{
    NDIS_STATUS Status;
    TA_IP_ADDRESS Ip;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlListen\n")));

    if (pAdapter->hCtdiListen)
    {
        // Already listening.  Bail with success.
        Status = NDIS_STATUS_SUCCESS;
        goto clDone;
    }

    NdisZeroMemory(&Ip, sizeof(Ip));
    Ip.TAAddressCount = 1;
    Ip.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    Ip.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    Ip.Address[0].Address[0].sin_port = htons(PptpControlPort);
    Ip.Address[0].Address[0].in_addr = 0;

    Status = CtdiCreateEndpoint(&pAdapter->hCtdiListen,
                                AF_INET,
                                SOCK_STREAM,
                                (PTRANSPORT_ADDRESS)&Ip,
                                0);
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint failed %08x\n"), Status));
        goto clDone;
    }

    Status = CtdiListen(pAdapter->hCtdiListen,
                        PptpListensPending,
                        CtlConnectQueryCallback,
                        CtlReceiveCallback,
                        CtlDisconnectCallback,
                        pAdapter);
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiListen failed %08x\n"), Status));
        goto clDone;
    }


clDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlListen %08x\n"), Status));
    return Status;
}

STATIC VOID
CtlpSendMessageComplete(
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PUCHAR                      pBuffer,
    IN      NDIS_STATUS                 Result
    )
{
    PCONTROL_TUNNEL pCtl = pContext;

    UNREFERENCED_PARAMETER(pDatagramContext);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpSendMessageComplete\n")));

    ASSERT(IS_CTL(pCtl));
    if (Result!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Failed to send control message %08x\n"), Result));
        // ToDo: code for this failure
    }

    CtlFreePacket(pCtl, pBuffer);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpSendMessageComplete\n")));
}

NDIS_STATUS
CtlSend(
    IN PCONTROL_TUNNEL pCtl,
    IN PVOID pPacketBuffer
    )
{
    ULONG PacketLength = htons(((UNALIGNED PPTP_HEADER *)pPacketBuffer)->Length);
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlSend %08x\n"), pPacketBuffer));

    ASSERT(IS_CTL(pCtl));

    DEBUGMSG(DBG_TUNNEL, (DTEXT("SENDING %s\n"),
        ControlMsgToString( htons(((UNALIGNED PPTP_HEADER *)pPacketBuffer)->MessageType))));

    // Log only if logging is on and not and ECHO message. Do a quick skip for the
    // common case of no logging
    if( (FileLogLevel>=FLL_DETAILED) &&
            (((UNALIGNED PPTP_HEADER *)pPacketBuffer)->MessageType != htons(CONTROL_ECHO_REQUEST)) &&
            (((UNALIGNED PPTP_HEADER *)pPacketBuffer)->MessageType != htons(CONTROL_ECHO_REPLY)))
    {
        LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"Sending %s\n"),
                LOGHDR(19, pCtl->Remote.Address.Address[0].Address[0].in_addr),
                ControlMsgToString( htons(((UNALIGNED PPTP_HEADER *)pPacketBuffer)->MessageType))));
    }

    Status = CtdiSend(pCtl->hCtdi,
                      CtlpSendMessageComplete,
                      pCtl,
                      pPacketBuffer,
                      PacketLength);

    if (Status==NDIS_STATUS_PENDING)
    {
        Status = NDIS_STATUS_SUCCESS;
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtlSend %08x\n"), Status));
    return Status;
}

CONTROL_STATE
CtlSetState(
    IN PCONTROL_TUNNEL pCtl,
    IN CONTROL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    )
{
    CONTROL_STATE PreviousState;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlSetState %08x %d %x\n"), pCtl, State, StateParam));
    ASSERT(IS_CTL(pCtl));

    if (!Locked)
    {
        NdisAcquireSpinLock(&pCtl->pAdapter->Lock);
    }
    PreviousState = pCtl->State;
    pCtl->State = State;
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCtl->pAdapter->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlSetState\n")));
    return PreviousState;
}

// StanA: lift some functions from L2TP to convert an IP address to text

VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft++ = *pchRight;
        *pchRight-- = ch;
    }
}

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.  It's
    // caller job to make sure 'pszBuf' is long enough to hold the returned
    // string.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);

    *pch = '\0';
    ReversePsz( pszBuf );
}

PWCHAR
StringToIpAddressW(
    IN PWCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    )
// Convert an address of the form #.#.#.#[:#][ \0] to a binary ip address
// [ and optional port ]
// Return a pointer to the end of the address.  If the string is determined
// to not contain an IP address, return the passed-in pszIpAddress unchanged
// ToDo: IPv6
{
    PWCHAR pStartString = pszIpAddress;
    ULONG Octet;
    ULONG NumOctets;
    ULONG IpAddress = INADDR_NONE;
    ULONG Port = PptpControlPort;

    *pValidAddress = FALSE;

    // Find the first digit.
    while (*pszIpAddress && (*pszIpAddress<L'0' || *pszIpAddress>L'9'))
    {
        pszIpAddress++;
    }
    if (!*pszIpAddress)
    {
        return pStartString;
    }

    for (NumOctets = 0; NumOctets<4 && *pszIpAddress; NumOctets++)
    {
        Octet = 0;
        while (*pszIpAddress && *pszIpAddress>=L'0' && *pszIpAddress<=L'9')
        {
            Octet = Octet * 10 + *pszIpAddress - L'0';
            if (Octet>0xff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
        if (NumOctets < 3)
        {
            if (*pszIpAddress!='.' || *(++pszIpAddress) < L'0' || *pszIpAddress > L'9')
            {
                return pStartString;
            }
        }
        IpAddress = (IpAddress << 8) + Octet;
    }

    if (*pszIpAddress==':')
    {
        // They've also specified the port.  Parse it.
        while (*pszIpAddress && *pszIpAddress>=L'0' && *pszIpAddress<=L'9')
        {
            Port = Port * 10 + *pszIpAddress - L'0';
            if (Port>0xffff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
    }

    pAddress->TAAddressCount = 1;
    pAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pAddress->Address[0].Address[0].sin_port = htons((USHORT)Port);
    pAddress->Address[0].Address[0].in_addr = htonl(IpAddress);

    *pValidAddress = TRUE;

    return pszIpAddress;
}

PUCHAR
StringToIpAddress(
    IN PUCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    )
// Convert an address of the form #.#.#.#[:#][ \0] to a binary ip address
// [ and optional port ]
// Return a pointer to the end of the address.  If the string is determined
// to not contain an IP address, return the passed-in pszIpAddress unchanged
// ToDo: IPv6
{
    PUCHAR pStartString = pszIpAddress;
    ULONG Octet;
    ULONG NumOctets;
    ULONG IpAddress = INADDR_NONE;
    ULONG Port = PptpControlPort;

    *pValidAddress = FALSE;

    // Find the first digit.
    while (*pszIpAddress && (*pszIpAddress<'0' || *pszIpAddress>'9'))
    {
        pszIpAddress++;
    }
    if (!*pszIpAddress)
    {
        return pStartString;
    }

    for (NumOctets = 0; NumOctets<4 && *pszIpAddress; NumOctets++)
    {
        Octet = 0;
        while (*pszIpAddress && *pszIpAddress>='0' && *pszIpAddress<='9')
        {
            Octet = Octet * 10 + *pszIpAddress - '0';
            if (Octet>0xff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
        if (NumOctets < 3)
        {
            if (*pszIpAddress!='.' || *(++pszIpAddress) < '0' || *pszIpAddress > '9')
            {
                return pStartString;
            }
        }
        IpAddress = (IpAddress << 8) + Octet;
    }

    if (*pszIpAddress==':')
    {
        // They've also specified the port.  Parse it.
        while (*pszIpAddress && *pszIpAddress>='0' && *pszIpAddress<='9')
        {
            Port = Port * 10 + *pszIpAddress - '0';
            if (Port>0xffff)
            {
                return pStartString;
            }
            pszIpAddress++;
        }
    }

    pAddress->TAAddressCount = 1;
    pAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pAddress->Address[0].Address[0].sin_port = htons((USHORT)Port);
    pAddress->Address[0].Address[0].in_addr = htonl(IpAddress);

    *pValidAddress = TRUE;

    return pszIpAddress;
}


VOID
IpAddressToString(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress )

    // Converts network byte-ordered IP addresss 'ulIpAddress' to a string in
    // the a.b.c.d form and returns same in caller's 'pszIpAddress' buffer.
    // The buffer should be at least 16 characters long.
    //
    // ToDo: IPv6
{
    CHAR szBuf[ 3 + 1 ];

    ULONG ulA = (ulIpAddress & 0xFF000000) >> 24;
    ULONG ulB = (ulIpAddress & 0x00FF0000) >> 16;
    ULONG ulC = (ulIpAddress & 0x0000FF00) >> 8;
    ULONG ulD = (ulIpAddress & 0x000000FF);

    ultoa( ulA, szBuf );
    strcpy( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulB, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulC, szBuf );
    strcat( pszIpAddress, szBuf );
    strcat( pszIpAddress, "." );
    ultoa( ulD, szBuf );
    strcat( pszIpAddress, szBuf );
}

VOID
CtlpEchoTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    PPTP_CONTROL_ECHO_REQUEST_PACKET *pPacket;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpEchoTimeout\n")));

    NdisAcquireSpinLock(&pCtl->Lock);
    // Don't take the adapter lock because we're only reading the State
    if (pCtl->State!=STATE_CTL_CLEANUP)
    {
        BOOLEAN DoEcho = pCtl->Echo.Needed;
        LONG Identifier = ++(pCtl->Echo.Identifier);

        pCtl->Echo.Needed = TRUE;

        NdisReleaseSpinLock(&pCtl->Lock);

        if (DoEcho)
        {
            pPacket = CtlAllocPacket(pCtl, CONTROL_ECHO_REQUEST);
            if (pPacket)
            {
                pPacket->Identifier = Identifier;

                // ToDo: deal with V2 stuff
                CtlSend(pCtl, pPacket);
            }
        }
    }
    else
    {
        NdisReleaseSpinLock(&pCtl->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpEchoTimeout\n")));
}

VOID
CtlpDeathTimeout(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    )
{
    PCONTROL_TUNNEL pCtl = pContext;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpDeathTimeout\n")));

    LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Fatal timeout\n"),
                      LOGHDR(22, pCtl->Remote.Address.Address[0].Address[0].in_addr)));

    CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
    CtlCleanup(pCtl, UNLOCKED);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpDeathTimeout\n")));
}

VOID
CtlpCleanupLooseEnds(
    PPPTP_ADAPTER pAdapter
    )
{
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    PCONTROL_TUNNEL pCtl;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtlpCleanupLooseEnds\n")));

    NdisAcquireSpinLock(&pAdapter->Lock);
    InitEnumContext(&Enum);
    while (pListEntry = EnumListEntry(&pAdapter->ControlTunnelList, &Enum, NULL))
    {
        pCtl = CONTAINING_RECORD(pListEntry, CONTROL_TUNNEL, ListEntry);
        if (pCtl->State==STATE_CTL_CLEANUP)
        {
            // REFERENCE the Ctl so it doesn't go away before we call CtlCleanup
            REFERENCE_OBJECT(pCtl);
            NdisReleaseSpinLock(&pAdapter->Lock);
            CtlCleanup(pCtl, UNLOCKED);
            DEREFERENCE_OBJECT(pCtl); // Pair above
            NdisAcquireSpinLock(&pAdapter->Lock);
        }
    }
    EnumComplete(&Enum, NULL);
    NdisReleaseSpinLock(&pAdapter->Lock);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtlpCleanupLooseEnds\n")));
}

NDIS_STATUS
PptpInitialize(
    PPPTP_ADAPTER pAdapter
    )
{
    NDIS_STATUS Status;
    TA_IP_ADDRESS Local;
    HANDLE hCtdi;
    DEBUGMSG(DBG_FUNC, (DTEXT("+PptpInitialize\n")));

    Status = CtdiInitialize(CTDI_FLAG_ENABLE_ROUTING|CTDI_FLAG_NETWORK_HEADER);
    if (Status!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiInitialize failed %08x\n"), Status));
        goto piDone;
    }

    if (!pAdapter->hCtdiDg && !(PptpTunnelConfig&CONFIG_DONT_ACCEPT_GRE))
    {
        NdisZeroMemory(&Local, sizeof(Local));
        Local.TAAddressCount = 1;
        Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        Local.Address[0].Address[0].sin_port = PptpProtocolNumber;
        Local.Address[0].Address[0].in_addr = 0;

        Status = CtdiCreateEndpoint(&hCtdi,
                                    AF_INET,
                                    SOCK_RAW,  //ToDo: RAWIP?
                                    (PTRANSPORT_ADDRESS)&Local,
                                    sizeof(DGRAM_CONTEXT));
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint failed %08x\n"), Status));
            goto piDone;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        pAdapter->hCtdiDg = hCtdi;
        NdisReleaseSpinLock(&pAdapter->Lock);

        Status = CtdiSetEventHandler(pAdapter->hCtdiDg,
                                     TDI_EVENT_RECEIVE_DATAGRAM,
                                     CallReceiveDatagramCallback,
                                     pAdapter);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler failed %08x\n"), Status));
            goto piDone;
        }
    }

    if (!pAdapter->hCtdiUdp && (PptpTunnelConfig&(CONFIG_ACCEPT_UDP|CONFIG_INITIATE_UDP)))
    {
        NdisZeroMemory(&Local, sizeof(Local));
        Local.TAAddressCount = 1;
        Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        Local.Address[0].Address[0].sin_port = htons(PptpProtocolNumber);
        Local.Address[0].Address[0].in_addr = 0;

        Status = CtdiCreateEndpoint(&hCtdi,
                                    AF_INET,
                                    SOCK_DGRAM,
                                    (PTRANSPORT_ADDRESS)&Local,
                                    sizeof(DGRAM_CONTEXT));
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("CtdiCreateEndpoint (UDP) failed %08x\n"), Status));
            goto piDone;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        pAdapter->hCtdiUdp = hCtdi;
        NdisReleaseSpinLock(&pAdapter->Lock);

        Status = CtdiSetEventHandler(pAdapter->hCtdiUdp,
                                     TDI_EVENT_RECEIVE_DATAGRAM,
                                     CallReceiveUdpCallback,
                                     pAdapter);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler failed %08x\n"), Status));
            goto piDone;
        }
    }

piDone:
    if (Status==STATUS_SUCCESS)
    {
        PptpInitialized = TRUE;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-PptpInitialize %08x\n"), Status));
    return Status;
}

CHAR *pControlMessageStrings[] =
{
    "INVALID CONTROL MESSAGE NUMBER",    // 0
    "CONTROL_START_REQUEST",             // 1
    "CONTROL_START_REPLY",               // 2
    "CONTROL_STOP_REQUEST",              // 3
    "CONTROL_STOP_REPLY",                // 4
    "CONTROL_ECHO_REQUEST",              // 5
    "CONTROL_ECHO_REPLY",                // 6

    "CALL_OUT_REQUEST",                  // 7
    "CALL_OUT_REPLY",                    // 8
    "CALL_IN_REQUEST",                   // 9
    "CALL_IN_REPLY",                     // 10
    "CALL_IN_CONNECTED",                 // 11
    "CALL_CLEAR_REQUEST",                // 12
    "CALL_DISCONNECT_NOTIFY",            // 13

    "WAN_ERROR_NOTIFY",                  // 14

    "SET_LINK_INFO",                     // 15
};



CHAR *ControlMsgToString( ULONG Message )
{
    if( Message >= NUM_MESSAGE_TYPES ){
        return pControlMessageStrings[0];
    }else{
        return pControlMessageStrings[Message];
    }
}

VOID 
CtlpCleanupCtls(
    PPPTP_ADAPTER pAdapter
    )
{
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    PCONTROL_TUNNEL pCtl;

    NdisAcquireSpinLock(&pAdapter->Lock);
    InitEnumContext(&Enum);
    while (pListEntry = EnumListEntry(&pAdapter->ControlTunnelList, &Enum, NULL))
    {
        pCtl = CONTAINING_RECORD(pListEntry, CONTROL_TUNNEL, ListEntry);

        // REFERENCE the Ctl so it doesn't go away before we call CtlCleanup
        REFERENCE_OBJECT(pCtl);
        NdisReleaseSpinLock(&pAdapter->Lock);
        CtlSetState(pCtl, STATE_CTL_CLEANUP, 0, UNLOCKED);
        CtlCleanup(pCtl, UNLOCKED);
        DEREFERENCE_OBJECT(pCtl); // Pair above
        NdisAcquireSpinLock(&pAdapter->Lock);
    }
    EnumComplete(&Enum, NULL);
    NdisReleaseSpinLock(&pAdapter->Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\debug.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DEBUG.C - debugging functions, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/2/1998
*
*****************************************************************************/

#include "raspptp.h"

#if DBG
    PPPTP_ADAPTER gAdapter;
#endif

#if MEM_CHECKING
typedef struct MEM_HDR {
    LIST_ENTRY  ListEntry;
    ULONG       Size;
    CHAR        File[16];
    ULONG       Line;
} MEM_HDR;

LIST_ENTRY leAlloc;
NDIS_SPIN_LOCK slAlloc;

VOID InitMemory()
{
    NdisAllocateSpinLock(&slAlloc);
    NdisInitializeListHead(&leAlloc);
}

VOID DeinitMemory()
{
    PLIST_ENTRY ListEntry;

    NdisAcquireSpinLock(&slAlloc);
    for (ListEntry=leAlloc.Flink;
         ListEntry!=&leAlloc;
         ListEntry = ListEntry->Flink)
    {
        MEM_HDR *Hdr = (MEM_HDR*)ListEntry;
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP Unfreed Memory:0x%08X size:%X <%s:%d>\n"),
                             &Hdr[1], Hdr->Size, Hdr->File, Hdr->Line));

    }
    NdisReleaseSpinLock(&slAlloc);
    NdisFreeSpinLock(&slAlloc);
}
#endif

#if MEM_CHECKING
PVOID
_MyMemAlloc(UINT size, ULONG tag, PUCHAR file, UINT line)
#else
PVOID
MyMemAlloc(UINT size, ULONG tag)
#endif
{
    PVOID                 memptr;
    NDIS_STATUS           status;

#if MEM_CHECKING
    status = NdisAllocateMemoryWithTag(&memptr, size+sizeof(MEM_HDR), tag);
#else
    status = NdisAllocateMemoryWithTag(&memptr, size, tag);
#endif

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Memory allocation failed <%s:%d>.\n"),
                             file, line));
        memptr = NULL;
    }
#if MEM_CHECKING
    else
    {
        MEM_HDR *Hdr = memptr;
        UINT FileNameLen = strlen(file);

        Hdr->Size = size;
        Hdr->Line = line;
        if (FileNameLen>sizeof(Hdr->File)-1)
            strcpy(Hdr->File, &file[FileNameLen-sizeof(Hdr->File)+1]);
        else
            strcpy(Hdr->File, file);
        MyInterlockedInsertHeadList(&leAlloc, &Hdr->ListEntry, &slAlloc);
        memptr = &Hdr[1];
    }
#endif

    return memptr;
}


VOID
MyMemFree(
    PVOID memptr,
    UINT size
    )
{
#if MEM_CHECKING
    PLIST_ENTRY ListEntry;
    MEM_HDR *Hdr = (MEM_HDR*)((PUCHAR)memptr-sizeof(MEM_HDR));

    NdisAcquireSpinLock(&slAlloc);
    for (ListEntry = leAlloc.Flink;
         ListEntry != &leAlloc;
         ListEntry = ListEntry->Flink)
    {
        if (ListEntry==&Hdr->ListEntry)
        {
            RemoveEntryList(&Hdr->ListEntry);
            break;
        }
    }
    if (ListEntry==&leAlloc)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP: Freeing memory not owned %x\n"), memptr));
    }
    NdisReleaseSpinLock(&slAlloc);

    NdisFreeMemory(Hdr, size+sizeof(MEM_HDR), 0);
#else
    NdisFreeMemory(memptr, size, 0);
#endif
}

#if LIST_CHECKING
VOID FASTCALL CheckList(PLIST_ENTRY ListHead)
{
    PLIST_ENTRY ListEntry, PrevListEntry;

    if (ListHead->Flink==ListHead)
    {
        if (ListHead->Blink!=ListHead)
        {
            DEBUGMSG(DBG_ERROR|DBG_BREAK,(DTEXT("PPTP: Corrupt list head:%x Flink:%x Blink:%x\n"), ListHead, ListHead->Flink, ListHead->Blink));
        }
    }
    else
    {
        ListEntry = ListHead;

        do
        {
            PrevListEntry = ListEntry;
            ListEntry = ListEntry->Flink;

            if (ListEntry->Blink!=PrevListEntry)
            {
                DEBUGMSG(DBG_ERROR|DBG_BREAK, (DTEXT("PPTP: Corrupt LIST_ENTRY Head:%08x %08x->Flink==%08x %08x->Blink==%08x\n"),
                                              ListHead, PrevListEntry, PrevListEntry->Flink, ListEntry, ListEntry->Blink));
            }
        } while (ListEntry!=ListHead);
    }
}

PLIST_ENTRY FASTCALL MyInterlockedInsertHeadList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock)
{
    PLIST_ENTRY RetVal;

    NdisAcquireSpinLock(SpinLock);
    if (IsListEmpty(Head))
        RetVal = NULL;
    else
        RetVal = Head->Flink;
    CheckedInsertHeadList(Head, Entry);
    NdisReleaseSpinLock(SpinLock);

    return RetVal;
}

PLIST_ENTRY FASTCALL MyInterlockedInsertTailList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock)
{
    PLIST_ENTRY RetVal;

    NdisAcquireSpinLock(SpinLock);
    if (IsListEmpty(Head))
        RetVal = NULL;
    else
        RetVal = Head->Blink;
    CheckedInsertTailList(Head, Entry);
    NdisReleaseSpinLock(SpinLock);

    return RetVal;
}

PLIST_ENTRY FASTCALL MyInterlockedRemoveHeadList(PLIST_ENTRY Head, PNDIS_SPIN_LOCK SpinLock)
{
    PLIST_ENTRY RetVal;
    NdisAcquireSpinLock(SpinLock);
    //RemoveHeadList uses RemoveEntryList, which is redefined to call CheckList in DEBUG.H
    RetVal = RemoveHeadList(Head);
    if (RetVal==Head)
        RetVal = NULL;
    else
        RetVal->Flink = RetVal->Blink = NULL;
    NdisReleaseSpinLock(SpinLock);

    return RetVal;
}
#endif


#define CASE_RETURN_NAME(x)   case x: return DTEXT(#x)

#ifdef DBG

char *ControlStateToString(ULONG State)
{
    switch( State ){
      CASE_RETURN_NAME(STATE_CTL_INVALID);
      CASE_RETURN_NAME(STATE_CTL_LISTEN);
      CASE_RETURN_NAME(STATE_CTL_DIALING);
      CASE_RETURN_NAME(STATE_CTL_WAIT_REQUEST);
      CASE_RETURN_NAME(STATE_CTL_WAIT_REPLY);
      CASE_RETURN_NAME(STATE_CTL_ESTABLISHED);
      CASE_RETURN_NAME(STATE_CTL_WAIT_STOP);
      CASE_RETURN_NAME(STATE_CTL_CLEANUP);
      default:
    	return DTEXT("UNKNOWN CONTROL STATE");
   } 	
}


char *CallStateToString(ULONG State)
{
    switch( State ){
      CASE_RETURN_NAME(STATE_CALL_INVALID);
      CASE_RETURN_NAME(STATE_CALL_CLOSED);
      CASE_RETURN_NAME(STATE_CALL_IDLE);
      CASE_RETURN_NAME(STATE_CALL_OFFHOOK);
      CASE_RETURN_NAME(STATE_CALL_OFFERING);
      CASE_RETURN_NAME(STATE_CALL_PAC_OFFERING);
      CASE_RETURN_NAME(STATE_CALL_PAC_WAIT);
      CASE_RETURN_NAME(STATE_CALL_DIALING);
      CASE_RETURN_NAME(STATE_CALL_PROCEEDING);
      CASE_RETURN_NAME(STATE_CALL_ESTABLISHED);
      CASE_RETURN_NAME(STATE_CALL_WAIT_DISCONNECT);
      CASE_RETURN_NAME(STATE_CALL_CLEANUP);
      default:
    	return DTEXT("UNKNOWN CALL STATE");
    } 	
}

#endif


#if LOCK_CHECKING
VOID FASTCALL
_MyAcquireSpinLock(
    PMY_SPIN_LOCK pLock,
    PUCHAR file,
    UINT line
    )
{
    UINT FileNameLen = strlen(file);
    NdisAcquireSpinLock((PNDIS_SPIN_LOCK)pLock);
    if (FileNameLen>sizeof(pLock->File)-1)
        strcpy(pLock->File, &file[FileNameLen-sizeof(pLock->File)+1]);
    else
        strcpy(pLock->File, file);
    pLock->Line = line;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\call.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   CALL.C - PPTP Call layer functionality
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

ULONG CallStateToLineCallStateMap[NUM_CALL_STATES] = {
    LINECALLSTATE_UNKNOWN,              // STATE_CALL_INVALID
    LINECALLSTATE_UNKNOWN,              // STATE_CALL_CLOSED
    LINECALLSTATE_IDLE,                 // STATE_CALL_IDLE
    LINECALLSTATE_IDLE,                 // STATE_CALL_OFFHOOK
    LINECALLSTATE_OFFERING,             // STATE_CALL_OFFERING
    LINECALLSTATE_OFFERING,             // STATE_CALL_PAC_OFFERING
    LINECALLSTATE_OFFERING,             // STATE_CALL_PAC_WAIT
    LINECALLSTATE_DIALING,              // STATE_CALL_DIALING
    LINECALLSTATE_PROCEEDING,           // STATE_CALL_PROCEEDING
    LINECALLSTATE_CONNECTED,            // STATE_CALL_ESTABLISHED
    LINECALLSTATE_CONNECTED,            // STATE_CALL_WAIT_DISCONNECT
    LINECALLSTATE_DISCONNECTED,         // STATE_CALL_CLEANUP
};

ULONG CallSerialNumber = 0;

VOID
CallpAckTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallpCloseTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallpDialTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallProcessRxPackets(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    );

VOID
CallpFinalDeref(IN PCALL_SESSION pCall);

VOID
InitCallLayer()
{
    LARGE_INTEGER Time;

    NdisGetCurrentSystemTime(&Time);
    CallSerialNumber = Time.HighPart;
}

VOID
CallAssignSerialNumber(
    PCALL_SESSION pCall
    )
{
    ASSERT(IS_CALL(pCall));
    ASSERT_LOCK_HELD(&pCall->Lock);
    pCall->SerialNumber = (USHORT)NdisInterlockedIncrement(&CallSerialNumber);
}

PCALL_SESSION
CallAlloc(PPPTP_ADAPTER pAdapter)
{
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallAlloc\n")));

    pCall = MyMemAlloc(sizeof(CALL_SESSION), TAG_PPTP_CALL);

    if (pCall)
    {
        NdisZeroMemory(pCall, sizeof(CALL_SESSION));

        pCall->Signature = TAG_PPTP_CALL;
        pCall->pAdapter = pAdapter;
        pCall->Close.Checklist = CALL_CLOSE_COMPLETE;

        NdisAllocateSpinLock(&pCall->Lock);

        NdisInitializeListHead(&pCall->RxPacketList);
        NdisInitializeListHead(&pCall->TxPacketList);

        NdisMInitializeTimer(&pCall->Close.Timer,
                             pAdapter->hMiniportAdapter,
                             CallpCloseTimeout,
                             pCall);

        NdisMInitializeTimer(&pCall->Ack.Timer,
                             pAdapter->hMiniportAdapter,
                             CallpAckTimeout,
                             pCall);

        NdisMInitializeTimer(&pCall->DialTimer,
                             pAdapter->hMiniportAdapter,
                             CallpDialTimeout,
                             pCall);

        PptpInitializeDpc(&pCall->ReceiveDpc,
                          pAdapter->hMiniportAdapter,
                          CallProcessRxPackets,
                          pCall);

        pCall->Ack.Packet.StartBuffer = pCall->Ack.PacketBuffer;
        pCall->Ack.Packet.EndBuffer = pCall->Ack.PacketBuffer + sizeof(pCall->Ack.PacketBuffer);
        pCall->Ack.Packet.CurrentBuffer = pCall->Ack.Packet.EndBuffer;
        pCall->Ack.Packet.CurrentLength = 0;

        INIT_REFERENCE_OBJECT(pCall, CallpFinalDeref);

        //
        // Instead of calling:
        // CallSetState(pCall, STATE_CALL_CLOSED, 0, UNLOCKED);
        //
        // it is better to set the state manually since the former creates an exception to our locking
        // scheme (First lock call, then lock adapter) exposing a potential deadlock in CallFindAndLock():
        //
        // - CallFindAndLock takes the Call lock then the Adapter lock.
        // - CallFindAndLock takes the adapter lock then calls CallAlloc which calls 
        //   setcallstate which takes the Call lock.
        //
        // Although this is a hypothetical scenario since the deadlock will never occur as the new
        // call context is not in the adapter's call array yet, but let's be consistent.
        //
        pCall->State = STATE_CALL_CLOSED;

    }

    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("-CallAlloc %08x\n"), pCall));
    return pCall;
}

VOID
CallpCleanup(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCALL_SESSION pCall = pWorkItem->Context;
    BOOLEAN SignalLineDown = FALSE;
    BOOLEAN Cancelled;
    BOOLEAN FreeNow = FALSE;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallpCleanup %08x\n"), pCall));

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    // Signal CLEANUP state
    if (!(pCall->Close.Checklist&CALL_CLOSE_CLEANUP_STATE))
    {
        if (pCall->State!=STATE_CALL_CLEANUP)
        {
            CallSetState(pCall, STATE_CALL_CLEANUP, 0, LOCKED);
        }
        pCall->Close.Checklist |= CALL_CLOSE_CLEANUP_STATE;
    }
    if (REFERENCE_COUNT(pCall)>2)
    {
        DEBUGMSG(DBG_CALL, (DTEXT("CallpCleanup: too many references (%d)\n"), REFERENCE_COUNT(pCall)));
        goto ccDone;
    }
    if (pCall->Close.Expedited)
    {
        if ((pCall->Close.Checklist&CALL_CLOSE_DROP) &&
            !(pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DROP_COMPLETE;
            DEBUGMSG(DBG_CALL, (DTEXT("TapiDrop Completed\n")));
            NdisReleaseSpinLock(&pCall->Lock);
            NdisMSetInformationComplete(pCall->pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
            NdisAcquireSpinLock(&pCall->Lock);
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_DISCONNECT))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DISCONNECT;
            if (pCall->pCtl)
            {
                NdisReleaseSpinLock(&pCall->Lock);
                CtlDisconnectCall(pCall);
                NdisAcquireSpinLock(&pCall->Lock);
            }
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_LINE_DOWN) &&
            (pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            SignalLineDown = TRUE;
            pCall->Close.Checklist |= CALL_CLOSE_LINE_DOWN;
            NdisReleaseSpinLock(&pCall->Lock);
            TapiLineDown(pCall);
            NdisAcquireSpinLock(&pCall->Lock);
        }
    }
    else // !Expedited
    {
        if (!(pCall->Close.Checklist&CALL_CLOSE_DISCONNECT))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DISCONNECT;
            if (pCall->pCtl)
            {
                NdisReleaseSpinLock(&pCall->Lock);
                CtlDisconnectCall(pCall);
                NdisAcquireSpinLock(&pCall->Lock);
            }
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_DROP))
        {
            goto ccDone;
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            pCall->Close.Checklist |= CALL_CLOSE_DROP_COMPLETE;
            DEBUGMSG(DBG_CALL, (DTEXT("TapiDrop Completed 2\n")));
            NdisReleaseSpinLock(&pCall->Lock);
            NdisMSetInformationComplete(pCall->pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
            NdisAcquireSpinLock(&pCall->Lock);
        }
        if (!(pCall->Close.Checklist&CALL_CLOSE_LINE_DOWN) &&
            (pCall->Close.Checklist&CALL_CLOSE_DROP_COMPLETE))
        {
            DEBUGMSG(DBG_CALL, (DTEXT("Signalling Line Down 2\n")));
            pCall->Close.Checklist |= CALL_CLOSE_LINE_DOWN;
            NdisReleaseSpinLock(&pCall->Lock);
            TapiLineDown(pCall);
            NdisAcquireSpinLock(&pCall->Lock);
        }
    }

    if ((pCall->Close.Checklist&CALL_CLOSE_COMPLETE)!=CALL_CLOSE_COMPLETE)
    {
        goto ccDone;
    }

    NdisReleaseSpinLock(&pCall->Lock);
    NdisMCancelTimer(&pCall->DialTimer, &Cancelled);
    NdisMCancelTimer(&pCall->Close.Timer, &Cancelled);
    NdisMCancelTimer(&pCall->Ack.Timer, &Cancelled);
    NdisAcquireSpinLock(&pCall->Lock);
    if (Cancelled)
    {
        pCall->Ack.PacketQueued = FALSE;
    }


    //pCall->hTapiLine = 0;
    //pCall->DeviceId = 0;
    pCall->Close.Expedited = FALSE;
    pCall->UseUdp = (PptpTunnelConfig&CONFIG_INITIATE_UDP) ? TRUE : FALSE;
    pCall->CallerId[0] = '\0';
    NdisZeroMemory(&pCall->Remote, sizeof(pCall->Remote));
    pCall->Packet.SequenceNumber = pCall->Packet.AckNumber = 0;
    CallSetState(pCall,
#if SINGLE_LINE
                 STATE_CALL_IDLE,
#else
                 (pCall->Open ? STATE_CALL_IDLE : STATE_CALL_CLOSED),
#endif
                 0, LOCKED);
    DEBUGMSG(DBG_CALL, (DTEXT("Call:%08x Cleanup complete, state==%d\n"),
                        pCall, pCall->State));

#if SINGLE_LINE
#if 0  // Keep these structures and reuse the memory.  They will be cleaned up in AdapterFree()
    if (REFERENCE_COUNT(pCall)==1)
    {
        CallDetachFromAdapter(pCall);
        DEREFERENCE_OBJECT(pCall);  // For the initial reference.
        FreeNow = TRUE;
    }
#endif
#else
    if (!pCall->Open && !REFERENCE_COUNT(pCall))
    {
        FreeNow = TRUE;
    }
#endif

ccDone:
    pCall->Close.Scheduled = FALSE;
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpCleanup Checklist:%08x\n"), pCall->Close.Checklist));

    if (FreeNow)
    {
        CallFree(pCall);
    }
}

VOID
CallCleanup(
    PCALL_SESSION pCall,
    BOOLEAN Locked
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallCleanup\n")));
    if (!Locked)
    {
        NdisAcquireSpinLock(&pCall->Lock);
    }
    ASSERT_LOCK_HELD(&pCall->Lock);
    if (!(pCall->Close.Scheduled) &&
        ScheduleWorkItem(CallpCleanup, pCall, NULL, 0)==NDIS_STATUS_SUCCESS)
    {
        pCall->Close.Scheduled = TRUE;
    }
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallCleanup\n")));
}

// Call lock must be held when calling this.
VOID
CallDetachFromAdapter(PCALL_SESSION pCall)
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallDetachFromAdapter %08x\n"), pCall));
    NdisAcquireSpinLock(&pCall->pAdapter->Lock);
#if SINGLE_LINE
    pCall->pAdapter->pCallArray[pCall->DeviceId] = NULL;
#else
    pCall->pAdapter->pCallArray[DeviceIdToIndex(pCall->pAdapter, pCall->DeviceId)] = NULL;
#endif
    NdisReleaseSpinLock(&pCall->pAdapter->Lock);
    pCall->Open = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallDetachFromAdapter\n")));
}

VOID
CallFree(PCALL_SESSION pCall)
{
    BOOLEAN NotUsed;
    if (!pCall)
    {
        return;
    }
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallFree %p\n"), pCall));
    ASSERT(IS_CALL(pCall));

    // This duplicates some of the cleanup code, but attempting to stop
    // the driver without first stopping tapi can result in an ungraceful
    // shutdown.
    NdisMCancelTimer(&pCall->DialTimer, &NotUsed);
    NdisMCancelTimer(&pCall->Close.Timer, &NotUsed);
    NdisMCancelTimer(&pCall->Ack.Timer, &NotUsed);

    ASSERT(pCall->Signature==TAG_PPTP_CALL);
    ASSERT(IsListEmpty(&pCall->RxPacketList));
    ASSERT(IsListEmpty(&pCall->TxPacketList));
    NdisFreeSpinLock(&pCall->Lock);
    MyMemFree(pCall, sizeof(CALL_SESSION));

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallFree\n")));
}

PCALL_SESSION FASTCALL
CallGetCall(
    IN PPPTP_ADAPTER pAdapter,
    IN ULONG_PTR ulDeviceId
    )
{
    PCALL_SESSION pCall = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallGetCall %d\n"), ulDeviceId));

    NdisAcquireSpinLock(&pAdapter->Lock);
#if SINGLE_LINE
    if (ulDeviceId<pAdapter->Info.Endpoints)
    {
        pCall = pAdapter->pCallArray[ulDeviceId];
    }
#else
    if (ulDeviceId>=pAdapter->Tapi.DeviceIdBase &&
        ulDeviceId<pAdapter->Tapi.DeviceIdBase+pAdapter->Info.Endpoints)
    {
        pCall = pAdapter->pCallArray[ulDeviceId - pAdapter->Tapi.DeviceIdBase];
    }
#endif
    NdisReleaseSpinLock(&pAdapter->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallGetCall %08x\n"), pCall));
    return pCall;
}

BOOLEAN FASTCALL
CallIsValidCall(
    IN PPPTP_ADAPTER pAdapter,
    IN ULONG_PTR ulDeviceId
    )
{
    BOOLEAN IsValid = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallIsValidCall %d\n"), ulDeviceId));

#if SINGLE_LINE
    if (ulDeviceId==pAdapter->Tapi.DeviceIdBase)
    {
        IsValid = TRUE;
    }
#else
    if (ulDeviceId>=pAdapter->Tapi.DeviceIdBase &&
        ulDeviceId<pAdapter->Tapi.DeviceIdBase+pAdapter->Info.Endpoints)
    {
        IsValid = TRUE;
    }
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallIsValidCall %d\n"), IsValid));
    return IsValid;
}


PCALL_SESSION
CallFindAndLock(
    IN PPPTP_ADAPTER        pAdapter,
    IN CALL_STATE           State,
    IN ULONG                Flags
    )
{
    LONG i, inc;
    PCALL_SESSION pCall = NULL;
    BOOLEAN fNewCallCreated = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallFindAndLock %d\n"), State));

    do
    {
        if (pCall)
        {
            NdisReleaseSpinLock(&pCall->Lock);
        }

        pCall = NULL;
        // Find a call that matches our state.  Start from the beginning (again)
        // This shouldn't be an infinite loop because we will either hit the end
        // or find a valid call in just a couple tries.
        NdisAcquireSpinLock(&pAdapter->Lock);
        if (Flags&FIND_INCOMING)
        {
            // Outgoing calls start top down
            inc = -1;
            i = pAdapter->Info.Endpoints - 1;
        }
        else
        {
            // Incoming calls start bottom up (0)
            inc = 1;
            i = 0;
        }
        while ( (Flags&FIND_INCOMING) ? (i>=0) : (i<(signed)pAdapter->Info.Endpoints) )
        {
            if (!pAdapter->pCallArray[i])
            {
                if (State==STATE_CALL_IDLE)
                {
                    pCall = CallAlloc(pAdapter);
                    if (pCall)
                    {

                        fNewCallCreated = TRUE;
                        
                        pCall->DeviceId = (unsigned)i;
                        break;
                    }
                }
            }
            else if (pAdapter->pCallArray[i]->State == State)
            {
                pCall = pAdapter->pCallArray[i];
                break;
            }

            i += inc;
        }

        NdisReleaseSpinLock(&pAdapter->Lock);

        if (pCall)
        {
            NdisAcquireSpinLock( &pCall->Lock );

            if ( fNewCallCreated )
            {
                CallSetState(pCall, STATE_CALL_IDLE, 0, LOCKED);

                NdisAcquireSpinLock( &pAdapter->Lock );
                pAdapter->pCallArray[i] = pCall;
                NdisReleaseSpinLock( &pAdapter->Lock );
            }
        }
        // The state could change while we were taking the lock, so look again.

    } while ( pCall && pCall->State!=State );
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallFindAndLock %08x\n"), pCall));
    return pCall;
}

NDIS_STATUS
CallEventCallClearRequest(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET *pPacket,
    PCONTROL_TUNNEL pCtl
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_CALL_DISCONNECT_NOTIFY_PACKET pReply;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallClearRequest\n")));

    pReply = CtlAllocPacket(pCall->pCtl, CALL_DISCONNECT_NOTIFY);
    // We don't really care if we fail this allocation because PPTP can clean up
    // along other avenues, and the cleanup just won't be as pretty.
    if (pReply)
    {
        pReply->CallId = htons(pCall->Packet.CallId);
        Status = CtlSend(pCtl, pReply);
    }
    CallCleanup(pCall, UNLOCKED);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallClearRequest %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventCallDisconnectNotify(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallDisconnectNotify\n")));

    if (IS_CALL(pCall))
    {
        CallCleanup(pCall, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallDisconnectNotify %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventCallInConnect(
    IN PCALL_SESSION        pCall,
    IN UNALIGNED PPTP_CALL_IN_CONNECT_PACKET *pPacket
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallEventCallInConnect\n")));

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    if (pCall->State==STATE_CALL_PAC_WAIT)
    {
        pCall->Speed = htonl(pPacket->ConnectSpeed);
        CallSetState(pCall, STATE_CALL_ESTABLISHED, htonl(pPacket->ConnectSpeed), LOCKED);
    }
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventCallInConnect\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CallEventCallInRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_IN_REQUEST_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallEventCallInRequest\n")));

    pCall = CallFindAndLock(pAdapter, STATE_CALL_IDLE, FIND_INCOMING);

    if (pCall)
    {
        NDIS_TAPI_EVENT TapiEvent;

        // We have a call in idle state, spinlock acquired
        pCall->Inbound = TRUE;
        pCall->Remote.CallId = htons(pPacket->CallId);
        pCall->Remote.Address = pCtl->Remote.Address;
        pCall->Remote.Address.Address[0].Address[0].sin_port = htons(PptpUdpPort);
        pCall->SerialNumber = htons(pPacket->SerialNumber);

        pCall->Close.Checklist &= ~CALL_CLOSE_DISCONNECT;
        CallConnectToCtl(pCall, pCtl, TRUE);

        NdisReleaseSpinLock(&pCall->Lock);

        pPacket->DialingNumber[MAX_PHONE_NUMBER_LENGTH-1] = '\0';
        strcpy(pPacket->DialingNumber, pCall->CallerId);

#if SINGLE_LINE
        TapiEvent.htLine = pAdapter->Tapi.hTapiLine;
#else
        TapiEvent.htLine = pCall->hTapiLine;
#endif
        LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"LINE_NEWCALL:%d\n"),
                              LOGHDR(27, pCall->Remote.Address.Address[0].Address[0].in_addr),
                              pCall->DeviceId));
        TapiEvent.htCall = 0;
        TapiEvent.ulMsg = LINE_NEWCALL;
        TapiEvent.ulParam1 = pCall->DeviceId;
        TapiEvent.ulParam2 = 0;
        TapiEvent.ulParam3 = 0;

        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_TAPI_INDICATION,
                            &TapiEvent,
                            sizeof(TapiEvent));

        NdisAcquireSpinLock(&pCall->Lock);
        pCall->hTapiCall = TapiEvent.ulParam2;
        CallSetState(pCall, STATE_CALL_PAC_OFFERING, 0, LOCKED);
        NdisReleaseSpinLock(&pCall->Lock);
        DEBUGMSG(DBG_TAPI, (DTEXT("LINE_NEWCALL on %d returned htCall %d\n"),
                            pCall->DeviceId, TapiEvent.ulParam2));

        DEBUGMSG(DBG_CALL, (DTEXT("New in call request: Call:%08x  Ctl:%08x  Addr:%08x\n"),
                            pCall, pCtl, pCall->Remote.Address.Address[0].Address[0].in_addr));
    }
    else
    {
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_IN_REPLY);

        if (pReply)
        {
            pReply->PeerCallId = pPacket->CallId;
            pReply->ResultCode = RESULT_CALL_IN_ERROR;
            pReply->ErrorCode = PPTP_STATUS_INSUFFICIENT_RESOURCES;

            // No call was available.  Send a rejection.
            Status = CtlSend(pCtl, pReply);
        }

    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallInRequest %08x\n"), Status));
    return Status;
}


NDIS_STATUS
CallEventCallOutRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET *pPacket
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallOutRequest\n")));

    pCall = CallFindAndLock(pAdapter, STATE_CALL_IDLE, FIND_INCOMING);

    if (pCall)
    {
        NDIS_TAPI_EVENT TapiEvent;

        // We have a call in idle state, spinlock acquired
        pCall->Inbound = TRUE;
        pCall->Remote.CallId = htons(pPacket->CallId);
        pCall->Remote.Address = pCtl->Remote.Address;
        pCall->Remote.Address.Address[0].Address[0].sin_port = htons(PptpUdpPort);
        pCall->SerialNumber = htons(pPacket->SerialNumber);

        IpAddressToString(htonl(pCtl->Remote.Address.Address[0].Address[0].in_addr), pCall->CallerId);

        pCall->Close.Checklist &= ~CALL_CLOSE_DISCONNECT;
        CallConnectToCtl(pCall, pCtl, TRUE);
        NdisReleaseSpinLock(&pCall->Lock);

#if SINGLE_LINE
        TapiEvent.htLine = pAdapter->Tapi.hTapiLine;
#else
        TapiEvent.htLine = pCall->hTapiLine;
#endif
        LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"LINE_NEWCALL:%d\n"),
                              LOGHDR(27, pCall->Remote.Address.Address[0].Address[0].in_addr),
                              pCall->DeviceId));
        TapiEvent.htCall = 0;
        TapiEvent.ulMsg = LINE_NEWCALL;
        TapiEvent.ulParam1 = pCall->DeviceId;
        TapiEvent.ulParam2 = 0;
        TapiEvent.ulParam3 = 0;

        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_TAPI_INDICATION,
                            &TapiEvent,
                            sizeof(TapiEvent));

        NdisAcquireSpinLock(&pCall->Lock);
        pCall->hTapiCall = TapiEvent.ulParam2;
        CallSetState(pCall, STATE_CALL_OFFERING, 0, LOCKED);
        NdisReleaseSpinLock(&pCall->Lock);
        DEBUGMSG(DBG_TAPI, (DTEXT("LINE_NEWCALL on %d returned htCall %d\n"),
                            pCall->DeviceId, TapiEvent.ulParam2));

        DEBUGMSG(DBG_CALL, (DTEXT("New call request: Call:%08x  Ctl:%08x  Addr:%hs\n"),
                            pCall, pCtl, pCall->CallerId));
    }
    else
    {
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_OUT_REPLY);

        if (pReply)
        {
            pReply->PeerCallId = pPacket->CallId;
            pReply->ResultCode = RESULT_CALL_OUT_ERROR;
            pReply->ErrorCode = PPTP_STATUS_INSUFFICIENT_RESOURCES;

            // No call was available.  Send a rejection.
            Status = CtlSend(pCtl, pReply);
        }

    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventCallOutRequest %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventCallOutReply(
    IN PCALL_SESSION                pCall,
    IN UNALIGNED PPTP_CALL_OUT_REPLY_PACKET *pPacket
    )
{
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventCallOutReply\n")));

    OsFileLogFlush();   // After the last connection message do a flush

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    if (pPacket->ResultCode==RESULT_CALL_OUT_CONNECTED)
    {
        if (pCall->State!=STATE_CALL_PROCEEDING ||
            pCall->Packet.CallId!=htons(pPacket->PeerCallId))
        {
            // Something's wrong.  Ignore it.
        }
        else
        {
            LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Call Successfully Established\n"),
                              LOGHDR(25, pCall->pCtl->Remote.Address.Address[0].Address[0].in_addr)));

            pCall->Remote.CallId = htons(pPacket->CallId);
            pCall->Speed = pCall->pCtl->Speed;
            CallSetState(pCall, STATE_CALL_ESTABLISHED, htonl(pPacket->ConnectSpeed), LOCKED);
        }
    }
    else
    {
        // The call fails for some reason.
        CallCleanup(pCall, LOCKED);
    }
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventCallOutReply\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CallEventDisconnect(
    PCALL_SESSION                       pCall
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventDisconnect %08x\n"), pCall));

    ASSERT(IS_CALL(pCall));
    CallCleanup(pCall, UNLOCKED);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallEventDisconnect %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallEventConnectFailure(
    PCALL_SESSION                       pCall,
    NDIS_STATUS                         FailureReason
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG DisconnectMode;
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventConnectFailure %08x\n"), FailureReason));

    ASSERT(IS_CALL(pCall));

    switch (FailureReason)
    {
        case STATUS_CONNECTION_REFUSED:
        case STATUS_IO_TIMEOUT:
            DisconnectMode = LINEDISCONNECTMODE_NOANSWER;
            break;
        case STATUS_BAD_NETWORK_PATH:
        case STATUS_NETWORK_UNREACHABLE:
        case STATUS_HOST_UNREACHABLE:
            DisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
            break;
        case STATUS_CONNECTION_ABORTED:
            DisconnectMode = LINEDISCONNECTMODE_REJECT;
            break;
        case STATUS_REMOTE_NOT_LISTENING:
            DisconnectMode = LINEDISCONNECTMODE_BADADDRESS;
            break;
        default:
            DisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
    }
    CallSetState(pCall, STATE_CALL_CLEANUP, DisconnectMode, UNLOCKED);
    CallCleanup(pCall, UNLOCKED);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventConnectFailure\n")));
    return Status;
}

NDIS_STATUS
CallEventOutboundTunnelEstablished(
    IN PCALL_SESSION        pCall,
    IN NDIS_STATUS          EventStatus
    )
{
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallEventOutboundTunnelEstablished %08x\n"), EventStatus));

    ASSERT(IS_CALL(pCall));
    DEBUGMSG(DBG_CALL, (DTEXT("Tunnel Established:Inbound:%d  State:%d\n"),
                        pCall->Inbound, pCall->State));
    if (!pCall->Inbound && pCall->State==STATE_CALL_DIALING)
    {
        PPTP_CALL_OUT_REQUEST_PACKET *pPacket = CtlAllocPacket(pCall->pCtl, CALL_OUT_REQUEST);

        if (!pPacket)
        {
            // Fatal for this call.
            CallCleanup(pCall, UNLOCKED);
        }
        else
        {
            BOOLEAN Cancelled;
            USHORT NewCallId;
            NdisAcquireSpinLock(&pCall->Lock);
            CallSetState(pCall, STATE_CALL_PROCEEDING, 0, LOCKED);
            NdisMCancelTimer(&pCall->DialTimer, &Cancelled);

            CallAssignSerialNumber(pCall);
            NewCallId = (USHORT)((pCall->SerialNumber << CALL_ID_INDEX_BITS) + pCall->DeviceId);
            if (pCall->Packet.CallId == NewCallId)
            {
                // Don't allow a line to have the same CallId twice in a row.
                NewCallId += (1<<CALL_ID_INDEX_BITS);
            }
  